quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance,"//===--------------------------------------------------------------------===//; // API to update (Post)DominatorTree information based on modifications to; // the CFG...; /// Inform the dominator tree about a sequence of CFG edge insertions and; /// deletions and perform a batch update on the tree.; ///; /// This function should be used when there were multiple CFG updates after; /// the last dominator tree update. It takes care of performing the updates; /// in sync with the CFG and optimizes away the redundant operations that; /// cancel each other.; /// The functions expects the sequence of updates to be balanced. Eg.:; /// - {{Insert, A, B}, {Delete, A, B}, {Insert, A, B}} is fine, because; /// logically it results in a single insertions.; /// - {{Insert, A, B}, {Insert, A, B}} is invalid, because it doesn't make; /// sense to insert the same edge twice.; ///; /// What's more, the functions assumes that it's safe to ask every node in the; /// CFG about its children and inverse children. This implies that deletions; /// of CFG edges must not delete the CFG nodes before calling this function.; ///; /// The applyUpdates function can reorder the updates and remove redundant; /// ones internally (as long as it is done in a deterministic fashion). The; /// batch updater is also able to detect sequences of zero and exactly one; /// update -- it's optimized to do less work in these cases.; ///; /// Note that for postdominators it automatically takes care of applying; /// updates on reverse edges internally (so there's no need to swap the; /// From and To pointers when constructing DominatorTree::UpdateType).; /// The type of updates is the same for DomTreeBase<T> and PostDomTreeBase<T>; /// with the same template parameter T.; ///; /// \param Updates An ordered sequence of updates to perform. The current CFG; /// and the reverse of these updates provides the pre-view of the CFG.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTree.h:264,perform,perform,264,interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTree.h,5,"['optimiz', 'perform']","['optimized', 'optimizes', 'perform', 'performing']"
Performance,"//===--------------------------------------------------------------------===//; // Addressing Mode #2; //===--------------------------------------------------------------------===//; //; // This is used for most simple load/store instructions.; //; // addrmode2 := reg +/- reg shop imm; // addrmode2 := reg +/- imm12; //; // The first operand is always a Reg. The second operand is a reg if in; // reg/reg form, otherwise it's reg#0. The third field encodes the operation; // in bit 12, the immediate in bits 0-11, and the shift op in 13-15. The; // fourth operand 16-17 encodes the index mode.; //; // If this addressing mode is a frame index (before prolog/epilog insertion; // and code rewriting), this operand will have the form: FI#, reg0, <offs>; // with no shift amount for the frame offset.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:219,load,load,219,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,1,['load'],['load']
Performance,"//===--------------------------------------------------------------------===//; // Addressing Mode #3; //===--------------------------------------------------------------------===//; //; // This is used for sign-extending loads, and load/store-pair instructions.; //; // addrmode3 := reg +/- reg; // addrmode3 := reg +/- imm8; //; // The first operand is always a Reg. The second operand is a reg if in; // reg/reg form, otherwise it's reg#0. The third field encodes the operation; // in bit 8, the immediate in bits 0-7. The fourth operand 9-10 encodes the; // index mode.; /// getAM3Opc - This function encodes the addrmode3 opc field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:222,load,loads,222,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,2,['load'],"['load', 'loads']"
Performance,"//===--------------------------------------------------------------------===//; // Addressing Mode #4; //===--------------------------------------------------------------------===//; //; // This is used for load / store multiple instructions.; //; // addrmode4 := reg, <mode>; //; // The four modes are:; // IA - Increment after; // IB - Increment before; // DA - Decrement after; // DB - Decrement before; // For VFP instructions, only the IA and DB modes are valid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:207,load,load,207,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,1,['load'],['load']
Performance,"//===--------------------------------------------------------------------===//; // Addressing Mode #5 FP16; //===--------------------------------------------------------------------===//; //; // This is used for coprocessor instructions, such as 16-bit FP load/stores.; //; // addrmode5fp16 := reg +/- imm8*2; //; // The first operand is always a Reg. The second operand encodes the; // operation (add or subtract) in bit 8 and the immediate in bits 0-7.; /// getAM5FP16Opc - This function encodes the addrmode5fp16 opc field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:256,load,load,256,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,1,['load'],['load']
Performance,"//===--------------------------------------------------------------------===//; // Addressing Mode #5; //===--------------------------------------------------------------------===//; //; // This is used for coprocessor instructions, such as FP load/stores.; //; // addrmode5 := reg +/- imm8*4; //; // The first operand is always a Reg. The second operand encodes the; // operation (add or subtract) in bit 8 and the immediate in bits 0-7.; /// getAM5Opc - This function encodes the addrmode5 opc field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:244,load,load,244,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,1,['load'],['load']
Performance,"//===--------------------------------------------------------------------===//; // Addressing Mode #6; //===--------------------------------------------------------------------===//; //; // This is used for NEON load / store instructions.; //; // addrmode6 := reg with optional alignment; //; // This is stored in two operands [regaddr, align]. The first is the; // address register. The second operand is the value of the alignment; // specifier in bytes or zero if no explicit alignment.; // Valid alignments depend on the specific instruction.; //===--------------------------------------------------------------------===//; // NEON/MVE Modified Immediates; //===--------------------------------------------------------------------===//; //; // Several NEON and MVE instructions (e.g., VMOV) take a ""modified immediate""; // vector operand, where a small immediate encoded in the instruction; // specifies a full NEON vector value. These modified immediates are; // represented here as encoded integers. The low 8 bits hold the immediate; // value; bit 12 holds the ""Op"" field of the instruction, and bits 11-8 hold; // the ""Cmode"" field of the instruction. The interfaces below treat the; // Op and Cmode values as a single 5-bit value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:212,load,load,212,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,1,['load'],['load']
Performance,//===--------------------------------------------------------------------===//; // Addressing mode description hooks (used by LSR etc).; //; /// CodeGenPrepare sinks address calculations into the same BB as Load/Store; /// instructions reading the address. This allows as much computation as; /// possible to be done in the address mode for that operand. This hook lets; /// targets also pass back when this should be done on intrinsics which; /// load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:207,Load,Load,207,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,"['Load', 'load']","['Load', 'load']"
Performance,//===--------------------------------------------------------------------===//; // ExternalSemaSource.; //===--------------------------------------------------------------------===//; /// Initialize the semantic source with the Sema instance; /// being used to perform semantic analysis on the abstract syntax; /// tree.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/MultiplexExternalSemaSource.h:261,perform,perform,261,interpreter/llvm-project/clang/include/clang/Sema/MultiplexExternalSemaSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/MultiplexExternalSemaSource.h,1,['perform'],['perform']
Performance,"//===--------------------------------------------------------------------===//; // High-level interface.; //===--------------------------------------------------------------------===//; //; // Calculate live ranges from scratch.; //; /// reset - Prepare caches for a new set of non-overlapping live ranges. The; /// caches must be reset before attempting calculations with a live range; /// that may overlap a previously computed live range, and before the first; /// live range in a function. If live ranges are not known to be; /// non-overlapping, call reset before each.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:254,cache,caches,254,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,2,['cache'],['caches']
Performance,//===--------------------------------------------------------------------===//; // High-level interface.; //===--------------------------------------------------------------------===//; //; // Check for interference before assigning virtual registers to physical; // registers.; //; /// Invalidate cached interference queries after modifying virtual register; /// live ranges. Interference checks may return stale information unless; /// caches are invalidated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:298,cache,cached,298,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,2,['cache'],"['cached', 'caches']"
Performance,//===--------------------------------------------------------------------===//; // Provided for performance analysis.; //===--------------------------------------------------------------------===//; /// The kind of memory backing used to support the MemoryBuffer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h:96,perform,performance,96,interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h,1,['perform'],['performance']
Performance,//===--------------------------------------------------------------------===//; // Queries for performance analysis.; //===--------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h:95,perform,performance,95,interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,1,['perform'],['performance']
Performance,//===--------------------------------------------------------------------===//; // Queries for performance analysis.; //===--------------------------------------------------------------------===//; /// Return the total amount of physical memory allocated by the; /// ContentCache allocator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:95,perform,performance,95,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['perform'],['performance']
Performance,"//===--------------------------------------------------------------------===//; // Register-operand Conversion Algorithm; // ---------; // For each innermost loop; // collectCmovCandidates() {; // Find all CMOV-group-candidates.; // }; //; // checkForProfitableCmovCandidates() {; // * Calculate both loop-depth and optimized-loop-depth.; // * Use these depth to check for loop transformation profitability.; // * Check for CMOV-group-candidate transformation profitability.; // }; //; // For each profitable CMOV-group-candidate; // convertCmovInstsToBranches() {; // * Create FalseBB, SinkBB, Conditional branch to SinkBB.; // * Replace each CMOV instruction with a PHI instruction in SinkBB.; // }; //; // Note: For more details, see each function description.; //===--------------------------------------------------------------------===//; // Build up the loops in pre-order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:316,optimiz,optimized-loop-depth,316,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,1,['optimiz'],['optimized-loop-depth']
Performance,"//===--------------------------------------------------------------------===//; // Side Effect Analysis; //===--------------------------------------------------------------------===//; /// Return true if this instruction could possibly read memory.; /// Instructions with this flag set are not necessarily simple load; /// instructions, they may load a value and modify it, for example.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:313,load,load,313,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,4,['load'],['load']
Performance,"//===--------------------------------------------------------------------===//; // Step 1: Calculate instruction depth and loop depth.; // Optimized-Loop:; // loop with CMOV-group-candidates converted into branches.; //; // Instruction-Depth:; // instruction latency + max operand depth.; // * For CMOV instruction in optimized loop the depth is calculated as:; // CMOV latency + getDepthOfOptCmov(True-Op-Depth, False-Op-depth); // TODO: Find a better way to estimate the latency of the branch instruction; // rather than using the CMOV latency.; //; // Loop-Depth:; // max instruction depth of all instructions in the loop.; // Note: instruction with max depth represents the critical-path in the loop.; //; // Loop-Depth[i]:; // Loop-Depth calculated for first `i` iterations.; // Note: it is enough to calculate depth for up to two iterations.; //; // Depth-Diff[i]:; // Number of cycles saved in first 'i` iterations by optimizing the loop.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:139,Optimiz,Optimized-Loop,139,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,7,"['Optimiz', 'latency', 'optimiz']","['Optimized-Loop', 'latency', 'optimized', 'optimizing']"
Performance,"//===--------------------------------------------------------------------===//; // Step 2: Check if Loop worth to be optimized.; // Worth-Optimize-Loop:; // case 1: Diff[1] == Diff[0]; // Critical-path is iteration independent - there is no dependency; // of critical-path instructions on critical-path instructions of; // previous iteration.; // Thus, it is enough to check gain percent of 1st iteration -; // To be conservative, the optimized loop need to have a depth of; // 12.5% cycles less than original loop, per iteration.; //; // case 2: Diff[1] > Diff[0]; // Critical-path is iteration dependent - there is dependency of; // critical-path instructions on critical-path instructions of; // previous iteration.; // Thus, check the gain percent of the 2nd iteration (similar to the; // previous case), but it is also required to check the gradient of; // the gain - the change in Depth-Diff compared to the change in; // Loop-Depth between 1st and 2nd iterations.; // To be conservative, the gradient need to be at least 50%.; //; // In addition, In order not to optimize loops with very small gain, the; // gain (in cycles) after 2nd iteration should not be less than a given; // threshold. Thus, the check (Diff[1] >= GainCycleThreshold) must apply.; //; // If loop is not worth optimizing, remove all CMOV-group-candidates.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:117,optimiz,optimized,117,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,5,"['Optimiz', 'optimiz']","['Optimize-Loop', 'optimize', 'optimized', 'optimizing']"
Performance,"//===--------------------------------------------------------------------===//; // Step 3: Check for each CMOV-group-candidate if it worth to be optimized.; // Worth-Optimize-Group:; // Iff it is worth to optimize all CMOV instructions in the group.; //; // Worth-Optimize-CMOV:; // Predicted branch is faster than CMOV by the difference between depth of; // condition operand and depth of taken (predicted) value operand.; // To be conservative, the gain of such CMOV transformation should cover at; // at least 25% of branch-misprediction-penalty.; //===--------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:145,optimiz,optimized,145,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,4,"['Optimiz', 'optimiz']","['Optimize-CMOV', 'Optimize-Group', 'optimize', 'optimized']"
Performance,"//===--------------------------------------------------------------------===//; // TargetLowering Optimization Methods; //; /// A convenience struct that encapsulates a DAG, and two SDValues for; /// returning information from TargetLowering to its clients that want to; /// combine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:98,Optimiz,Optimization,98,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['Optimiz'],['Optimization']
Performance,"//===--------------------------------------------------------------------===//; // Utilities; //===--------------------------------------------------------------------===//; /// EmitAggLoadOfLValue - Given an expression with aggregate type that; /// represents a value lvalue, this method emits the address of the lvalue,; /// then loads the result into DestPtr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp:332,load,loads,332,interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,1,['load'],['loads']
Performance,//===--------------------------------------------------------------------===//; // Vector Widening Utilities Support: LegalizeVectorTypes.cpp; //===--------------------------------------------------------------------===//; /// Helper function to generate a set of loads to load a vector with a; /// resulting wider type. It takes:; /// LdChain: list of chains for the load to be generated.; /// Ld: load to widen,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h:264,load,loads,264,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h,4,['load'],"['load', 'loads']"
Performance,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:84,Load,LoadExtType,84,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,7,"['LOAD', 'Load', 'load']","['LOADEXT', 'LoadExtType', 'load', 'loads']"
Performance,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:128,load,load,128,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,11,"['load', 'perform']","['load', 'performing']"
Performance,//===--------------------------------------------------------------------===//; /// This class is used by SelectionDAGISel to temporarily override; /// the optimization level on a per-function basis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:156,optimiz,optimization,156,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['optimiz'],['optimization']
Performance,"//===--------------------------------------------------------------------===//; /// This interface is used to plug different priorities computation; /// algorithms into the list scheduler. It implements the interface of a; /// standard priority queue, where nodes are inserted in arbitrary order and; /// returned in priority order. The computation of the priority and the; /// representation of the queue are totally up to the implementation to; /// decide.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:245,queue,queue,245,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,2,['queue'],['queue']
Performance,//===------------------------------------------------===//; //; // Notice: any optimization or new instruction that go; // into the code below should also be implemented in; // the cost-model.; //; //===------------------------------------------------===//; // 2. Copy and widen instructions from the old loop into the new loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:79,optimiz,optimization,79,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['optimiz'],['optimization']
Performance,"//===-CachePruning.cpp - LLVM Cache Directory Pruning ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the pruning of a directory based on least recently used.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CachePruning.cpp:6,Cache,CachePruning,6,interpreter/llvm-project/llvm/lib/Support/CachePruning.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CachePruning.cpp,2,['Cache'],"['Cache', 'CachePruning']"
Performance,"//===-Caching.cpp - LLVM Local File Cache ---------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the localCache function, which simplifies creating,; // adding to, and querying a local file system cache. localCache takes care of; // periodically pruning older files from the cache using a CachePruningPolicy.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Caching.cpp:36,Cache,Cache,36,interpreter/llvm-project/llvm/lib/Support/Caching.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Caching.cpp,4,"['Cache', 'cache']","['Cache', 'CachePruningPolicy', 'cache']"
Performance,"//===-Config.h - LLVM Link Time Optimizer Configuration ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the lto::Config data structure, which allows clients to; // configure LTO.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h:32,Optimiz,Optimizer,32,interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,1,['Optimiz'],['Optimizer']
Performance,"//===-LTO.cpp - LLVM Link Time Optimizer ----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements functions and classes used to support LTO.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:31,Optimiz,Optimizer,31,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['Optimiz'],['Optimizer']
Performance,"//===-LTO.h - LLVM Link Time Optimizer ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares functions and classes used to support LTO. It is intended; // to be used both by LTO classes as well as by clients (gold-plugin) that; // don't utilize the LTO code generator interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h:29,Optimiz,Optimizer,29,interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,1,['Optimiz'],['Optimizer']
Performance,"//===-LTOBackend.cpp - LLVM Link Time Optimizer Backend -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ""backend"" phase of LTO, i.e. it performs; // optimization and code generation on a loaded module. It is generally used; // internally by the LTO class but can also be used independently, for example; // to implement a standalone ThinLTO backend.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:38,Optimiz,Optimizer,38,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,4,"['Optimiz', 'load', 'optimiz', 'perform']","['Optimizer', 'loaded', 'optimization', 'performs']"
Performance,"//===-LTOBackend.h - LLVM Link Time Optimizer Backend ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ""backend"" phase of LTO, i.e. it performs; // optimization and code generation on a loaded module. It is generally used; // internally by the LTO class but can also be used independently, for example; // to implement a standalone ThinLTO backend.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTOBackend.h:36,Optimiz,Optimizer,36,interpreter/llvm-project/llvm/include/llvm/LTO/LTOBackend.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTOBackend.h,4,"['Optimiz', 'load', 'optimiz', 'perform']","['Optimizer', 'loaded', 'optimization', 'performs']"
Performance,"//===-LTOCodeGenerator.cpp - LLVM Link Time Optimizer ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Link Time Optimization library. This library is; // intended to be used by linker to optimize code at link time.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp:44,Optimiz,Optimizer,44,interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp,3,"['Optimiz', 'optimiz']","['Optimization', 'Optimizer', 'optimize']"
Performance,"//===-LTOCodeGenerator.h - LLVM Link Time Optimizer -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the LTOCodeGenerator class.; //; // LTO compilation consists of three phases: Pre-IPO, IPO and Post-IPO.; //; // The Pre-IPO phase compiles source code into bitcode file. The resulting; // bitcode files, along with object files and libraries, will be fed to the; // linker to through the IPO and Post-IPO phases. By using obj-file extension,; // the resulting bitcode file disguises itself as an object file, and therefore; // obviates the need of writing a special set of the make-rules only for LTO; // compilation.; //; // The IPO phase perform inter-procedural analyses and optimizations, and; // the Post-IPO consists two sub-phases: intra-procedural scalar optimizations; // (SOPT), and intra-procedural target-dependent code generator (CG).; //; // As of this writing, we don't separate IPO and the Post-IPO SOPT. They; // are intermingled together, and are driven by a single pass manager (see; // PassManagerBuilder::populateLTOPassManager()).; // FIXME: populateLTOPassManager no longer exists.; //; // The ""LTOCodeGenerator"" is the driver for the IPO and Post-IPO stages.; // The ""CodeGenerator"" here is bit confusing. Don't confuse the ""CodeGenerator""; // with the machine specific code generator.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOCodeGenerator.h:42,Optimiz,Optimizer,42,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOCodeGenerator.h,4,"['Optimiz', 'optimiz', 'perform']","['Optimizer', 'optimizations', 'perform']"
Performance,"//===-LTOModule.h - LLVM Link Time Optimizer ------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the LTOModule class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOModule.h:35,Optimiz,Optimizer,35,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOModule.h,1,['Optimiz'],['Optimizer']
Performance,"//===-ThinLTOCodeGenerator.cpp - LLVM Link Time Optimizer -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Thin Link Time Optimization library. This library is; // intended to be used by linker to optimize code at link time.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:48,Optimiz,Optimizer,48,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,3,"['Optimiz', 'optimiz']","['Optimization', 'Optimizer', 'optimize']"
Performance,"//===-ThinLTOCodeGenerator.h - LLVM Link Time Optimizer -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the ThinLTOCodeGenerator class, similar to the; // LTOCodeGenerator but for the ThinLTO scheme. It provides an interface for; // linker plugin.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:46,Optimiz,Optimizer,46,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,1,['Optimiz'],['Optimizer']
Performance,"//===-lto.cpp - LLVM Link Time Optimizer ----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Link Time Optimization library. This library is; // intended to be used by linker to optimize code at link time.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lto/lto.cpp:31,Optimiz,Optimizer,31,interpreter/llvm-project/llvm/tools/lto/lto.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lto/lto.cpp,3,"['Optimiz', 'optimiz']","['Optimization', 'Optimizer', 'optimize']"
Performance,"//====- X86CmovConversion.cpp - Convert Cmov to Branch --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file implements a pass that converts X86 cmov instructions into; /// branches when profitable. This pass is conservative. It transforms if and; /// only if it can guarantee a gain with high confidence.; ///; /// Thus, the optimization applies under the following conditions:; /// 1. Consider as candidates only CMOVs in innermost loops (assume that; /// most hotspots are represented by these loops).; /// 2. Given a group of CMOV instructions that are using the same EFLAGS def; /// instruction:; /// a. Consider them as candidates only if all have the same code condition; /// or the opposite one to prevent generating more than one conditional; /// jump per EFLAGS def instruction.; /// b. Consider them as candidates only if all are profitable to be; /// converted (assume that one bad conversion may cause a degradation).; /// 3. Apply conversion only for loops that are found profitable and only for; /// CMOV candidates that were found profitable.; /// a. A loop is considered profitable only if conversion will reduce its; /// depth cost by some threshold.; /// b. CMOV is considered profitable if the cost of its condition is higher; /// than the average cost of its true-value and false-value by 25% of; /// branch-misprediction-penalty. This assures no degradation even with; /// 25% branch misprediction.; ///; /// Note: This pass is assumed to run on SSA machine code.; //; //===----------------------------------------------------------------------===//; //; // External interfaces:; // FunctionPass *llvm::createX86CmovConverterPass();; // bool X86CmovConverterPass::runOnMachineFunctio",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:622,optimiz,optimization,622,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,1,['optimiz'],['optimization']
Performance,"//====- X86SpeculativeLoadHardening.cpp - A Spectre v1 mitigation ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Provide a pass which mitigates speculative execution attacks which operate; /// by speculating incorrectly past some predicate (a type check, bounds check,; /// or other condition) to reach a load with invalid inputs and leak the data; /// accessed by that load using a side channel out of the speculative domain.; ///; /// For details on the attacks, see the first variant in both the Project Zero; /// writeup and the Spectre paper:; /// https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html; /// https://spectreattack.com/spectre.pdf; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:588,load,load,588,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,2,['load'],['load']
Performance,"//=======- GCNDPPCombine.cpp - optimization for DPP instructions ---==========//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // The pass combines V_MOV_B32_dpp instruction with its VALU uses as a DPP src0; // operand. If any of the use instruction cannot be combined with the mov the; // whole sequence is reverted.; //; // $old = ...; // $dpp_value = V_MOV_B32_dpp $old, $vgpr_to_be_read_from_other_lane,; // dpp_controls..., $row_mask, $bank_mask, $bound_ctrl; // $res = VALU $dpp_value [, src1]; //; // to; //; // $res = VALU_DPP $combined_old, $vgpr_to_be_read_from_other_lane, [src1,]; // dpp_controls..., $row_mask, $bank_mask, $combined_bound_ctrl; //; // Combining rules :; //; // if $row_mask and $bank_mask are fully enabled (0xF) and; // $bound_ctrl==DPP_BOUND_ZERO or $old==0; // -> $combined_old = undef,; // $combined_bound_ctrl = DPP_BOUND_ZERO; //; // if the VALU op is binary and; // $bound_ctrl==DPP_BOUND_OFF and; // $old==identity value (immediate) for the VALU op; // -> $combined_old = src1,; // $combined_bound_ctrl = DPP_BOUND_OFF; //; // Otherwise cancel.; //; // The mov_dpp instruction should reside in the same BB as all its uses; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNDPPCombine.cpp:31,optimiz,optimization,31,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNDPPCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNDPPCombine.cpp,1,['optimiz'],['optimization']
Performance,"//==========-- ImmutableGraph.h - A fast DAG implementation ---------=========//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// Description: ImmutableGraph is a fast DAG implementation that cannot be; /// modified, except by creating a new ImmutableGraph. ImmutableGraph is; /// implemented as two arrays: one containing nodes, and one containing edges.; /// The advantages to this implementation are two-fold:; /// 1. Iteration and traversal operations benefit from cache locality.; /// 2. Operations on sets of nodes/edges are efficient, and representations of; /// those sets in memory are compact. For instance, a set of edges is; /// implemented as a bit vector, wherein each bit corresponds to one edge in; /// the edge array. This implies a lower bound of 64x spatial improvement; /// over, e.g., an llvm::DenseSet or llvm::SmallSet. It also means that; /// insert/erase/contains operations complete in negligible constant time:; /// insert and erase require one load and one store, and contains requires; /// just one load.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h:730,cache,cache,730,interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/ImmutableGraph.h,3,"['cache', 'load']","['cache', 'load']"
Performance,"//=========================================================================; // Load IMAGEHLP.DLL and get the address of functions in it that we'll use; // by Microsoft, from http://www.microsoft.com/msj/0597/hoodtextfigs.htm#fig1; //=========================================================================; // Make typedefs for some IMAGEHLP.DLL functions so that we can use them; // with GetProcAddress",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx:80,Load,Load,80,core/winnt/src/TWinNTSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx,1,['Load'],['Load']
Performance,"//===========================================================================; // Done with TrainNodeInfo declaration; //===========================================================================; ////////////////////////////////////////////////////////////////////////////////; /// Decide how to split a node using one of the variables that gives; /// the best separation of signal/background. In order to do this, for each; /// variable a scan of the different cut values in a grid (grid = fNCuts) is; /// performed and the resulting separation gains are compared.; /// in addition to the individual variables, one can also ask for a fisher; /// discriminant being built out of (some) of the variables and used as a; /// possible multivariate split.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DecisionTree.cxx:509,perform,performed,509,tmva/tmva/src/DecisionTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DecisionTree.cxx,1,['perform'],['performed']
Performance,"//==============================================================================; // TGLScene::TSceneInfo; //==============================================================================; //______________________________________________________________________; //; // Extend TGLSceneInfo for needs of TGLScene:; //; // 1. DrawElement vectors for opaque/transparent shapes which cache; // physicals that pass the clip tests (frustum and additional; // clip-object);; //; // 2. Statistics / debug information; //; ////////////////////////////////////////////////////////////////////////////////; /// Constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx:380,cache,cache,380,graf3d/gl/src/TGLScene.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx,1,['cache'],['cache']
Performance,"//==============================================================================; // VV3D; //==============================================================================; ////////////////////////////////////////////////////////////////////////////////; /// Start building of the scene.; /// Old contents is dropped, unless smart-refresh is in active. Then; /// the object supporting it are kept in a cache and possibly reused.; ///; /// TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; /// for description of viewer architecture.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScenePad.cxx:402,cache,cache,402,graf3d/gl/src/TGLScenePad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScenePad.cxx,1,['cache'],['cache']
Performance,"//==============================================================================; // unit: returns a unit vector (worse performance); //==============================================================================",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/Functions.h:120,perform,performance,120,math/smatrix/inc/Math/Functions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/Functions.h,2,['perform'],['performance']
Performance,"//===================================================================================; //________________________________________________________________________; //; // TSQLObjectDataPool contains list (pool) of data from single class table; // for differents objects, all belonging to the same key.; // This is typical situation when list of objects stored as single key.; // To optimize reading of such data, one query is submitted and results of that; // query kept in TSQLObjectDataPool object; //; //________________________________________________________________________",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/sql/src/TSQLObjectData.cxx:381,optimiz,optimize,381,io/sql/src/TSQLObjectData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/sql/src/TSQLObjectData.cxx,1,['optimiz'],['optimize']
Performance,//@}; /// The system include root to be used when loading the; /// precompiled header.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:50,load,loading,50,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loading']
Performance,"//Cache for polymarker's points.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLBoxPainter.h:2,Cache,Cache,2,graf3d/gl/inc/TGLBoxPainter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLBoxPainter.h,1,['Cache'],['Cache']
Performance,"//Cached meshes (will be used if geometry must be rebuilt; //after TPad::PaintModified)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLTF3Painter.h:2,Cache,Cached,2,graf3d/gl/inc/TGLTF3Painter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLTF3Painter.h,1,['Cache'],['Cached']
Performance,"//Clear mesh if it was from cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLTF3Painter.cxx:28,cache,cache,28,graf3d/gl/src/TGLTF3Painter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLTF3Painter.cxx,1,['cache'],['cache']
Performance,"//Clear the XrdClient cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx:22,cache,cache,22,io/io/src/TFileCacheRead.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx,1,['cache'],['cache']
Performance,"//Create new cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx:13,cache,cache,13,roofit/roofitcore/src/RooAddModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx,2,['cache'],['cache']
Performance,"//Error(""Compile"",""can only be called once; this first call generates both the optimized and memberwise actions."");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:79,optimiz,optimized,79,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,1,['optimiz'],['optimized']
Performance,"//FIXME It would be much better to cache the rule stat result and compare to the clang::FileEntry",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/BaseSelectionRule.cxx:35,cache,cache,35,core/dictgen/src/BaseSelectionRule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/BaseSelectionRule.cxx,1,['cache'],['cache']
Performance,"//Font manager - cache CTFontRef for GUI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/cocoa/src/CocoaPrivate.h:17,cache,cache,17,graf2d/cocoa/src/CocoaPrivate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/cocoa/src/CocoaPrivate.h,1,['cache'],['cache']
Performance,"//GetNdata should probably be const. However it need to cache some information about the actual dimension; //of arrays, so if GetNdata is const, the variables fUsedSizes and fCumulUsedSizes need to be declared; //mutable. We will be able to do that only when all the compilers supported for ROOT actually implemented; //the mutable keyword.; //NOTE: Also modify the code in PrintValue which current goes around this limitation :(",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeFormula.h:56,cache,cache,56,tree/treeplayer/inc/TTreeFormula.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeFormula.h,1,['cache'],['cache']
Performance,"//INTERNAL; //////////////////////////////////////////////////////////////////////////////////; /// \param[in] filename file location of Keras .h5; /// \return Parsed RModel object; ///; /// The `Parse()` function defined in `TMVA::Experimental::SOFIE::PyKeras` will; /// parse a trained Keras .h5 model into a RModel Object. After loading the model; /// in a Python Session, the included layers are extracted with properties; /// like Layer type, Attributes, Input tensor names, Output tensor names, data-type; /// and names of the weight/initialized tensors.; /// The extracted layers from the model are then passed into `AddKerasLayer()`; /// which prepares the specific ROperator and adds them into the RModel object.; /// The layers are also checked for adding any required routines for executing; /// the generated Inference code.; ///; /// For adding the Initialized tensors into the RModel object, the weights are; /// extracted from the Keras model in the form of NumPy arrays, which are then; /// passed into `AddInitializedTensor()` after appropriate casting.; ///; /// Input tensor infos are required to be added which will contain their names,; /// shapes and data-types. For keras models with single input tensors, the tensor; /// shape is returned as a Tuple object, whereas for multi-input models,; /// the tensor shape is returned as a List of Tuple object containing the shape; /// of the individual input tensors. SOFIE's RModel also requires that the Keras; /// models are initialized with Batch Size. The `GetDataFromTuple()` are called; /// on the Tuple objects, which then returns the shape vector required to call; /// the `AddInputTensorInfo()`.; ///; /// For adding the Output Tensor infos, only the names of the model's output; /// tensors are extracted and are then passed into `AddOutputTensorNameList()`.; ///; /// Provide optionally a batch size that can be used to overwrite the one given by the; /// model. If a batch size is not given 1 is used if the model does not ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/RModelParser_Keras.cxx:332,load,loading,332,tmva/pymva/src/RModelParser_Keras.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/RModelParser_Keras.cxx,1,['load'],['loading']
Performance,"//If an entry does not exist, fallback to the default implementation.; // Kind of shuffle depends on number of loaded values.; // If we load the entire data in one register, we can use a 1-src shuffle.; // Otherwise, we'll merge 2 sources in each operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:111,load,loaded,111,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,2,['load'],"['load', 'loaded']"
Performance,"//If the selector is writing into a TEntryList, the entry list's; //sublists need to be changed according to the loaded tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx:113,load,loaded,113,tree/treeplayer/src/TTreePlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx,1,['load'],['loaded']
Performance,"//If this turns out to be a bottleneck,; //one could use the RooNameReg to obtain the pointer to the arg's name and compare these",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooSTLRefCountList.h:28,bottleneck,bottleneck,28,roofit/roofitcore/inc/RooSTLRefCountList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooSTLRefCountList.h,1,['bottleneck'],['bottleneck']
Performance,"//If we failed to load a background image,; //we have nothing to show at all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/rootx/src/rootxx.cxx:18,load,load,18,rootx/src/rootxx.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/rootx/src/rootxx.cxx,1,['load'],['load']
Performance,"//In the current version of cocoa back-end, it's very expensive; //to read window's pixels, skip ""optimization"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGCanvas.cxx:98,optimiz,optimization,98,gui/gui/src/TGCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGCanvas.cxx,2,['optimiz'],['optimization']
Performance,"//Initialize meshes, trying to reuse mesh from; //mesh cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLTF3Painter.cxx:55,cache,cache,55,graf3d/gl/src/TGLTF3Painter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLTF3Painter.cxx,1,['cache'],['cache']
Performance,"//Internally, we have to enlarge the range of fit parameters to make; //fits converge even if we are close to the limit of a parameter. Therefore, we clone the pdf and its; //observables here. If something happens to the external PDF, the cache is wiped,; //and we start to clone again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooJeffreysPrior.cxx:239,cache,cache,239,roofit/roofit/src/RooJeffreysPrior.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooJeffreysPrior.cxx,1,['cache'],['cache']
Performance,"//Is branch already in the cache?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:27,cache,cache,27,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['cache'],['cache']
Performance,"//Is request already in the cache?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:28,cache,cache,28,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"//Load all the tree headers if the tree offsets are not known; //It is assumed here, that loading the last tree will load all; //previous ones",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:2,Load,Load,2,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,3,"['Load', 'load']","['Load', 'load', 'loading']"
Performance,"//Loading Dataset",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/VariableImportance.cxx:2,Load,Loading,2,tmva/tmva/src/VariableImportance.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/VariableImportance.cxx,3,['Load'],['Loading']
Performance,"//Make sure TStreamerInfo is not optimized, otherwise it will not be; //possible to support schema evolution in read mode.; //In case the StreamerInfo has already been computed and optimized,; //one must disable the option BypassStreamer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClonesArray.cxx:33,optimiz,optimized,33,core/cont/src/TClonesArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClonesArray.cxx,2,['optimiz'],['optimized']
Performance,"//Move old meshes into the cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLTF3Painter.cxx:27,cache,cache,27,graf3d/gl/src/TGLTF3Painter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLTF3Painter.cxx,1,['cache'],['cache']
Performance,"//NOTE: We can't use it as a cache due to the ""thoughtful"" self iterator; //if (fTitle.size()); // return fTitle.c_str();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingDataMemberInfo.cxx:29,cache,cache,29,core/metacling/src/TClingDataMemberInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingDataMemberInfo.cxx,1,['cache'],['cache']
Performance,"//NOTE: We can't use it as a cache due to the ""thoughtful"" self iterator; //if (fTitle.size()); // return fTitle.c_str();; // Try to get the comment either from the annotation or the header file if present; // Iterate over the redeclarations, we can have multiple definitions in the; // redecl chain (came from merging of pcms).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx:29,cache,cache,29,core/metacling/src/TClingMethodInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx,2,['cache'],['cache']
Performance,"//No meshes in a cache.; //Create new one and _swap_ data (look at Mesh_t::Swap in a header); //between empty mesh in a list and this mesh; //to avoid real copying.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLTF3Painter.cxx:17,cache,cache,17,graf3d/gl/src/TGLTF3Painter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLTF3Painter.cxx,1,['cache'],['cache']
Performance,"//Perform command line completion when hitting <TAB>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/rint/inc/TTabCom.h:2,Perform,Perform,2,core/rint/inc/TTabCom.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/rint/inc/TTabCom.h,1,['Perform'],['Perform']
Performance,"//Show/clear cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h:13,cache,cache,13,proof/proof/inc/TProof.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h,1,['cache'],['cache']
Performance,"//Stack of pointers to the cache where to temporarily store the value of 'missing' data members; // Default ctor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TBuffer.h:27,cache,cache,27,core/base/inc/TBuffer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TBuffer.h,1,['cache'],['cache']
Performance,"//TFile *input(0);; //input = TFile::Open(""~/Documents/gsoc/root/tree.root"", ""CACHEREAD"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestRegressionMethodDL.cxx:78,CACHE,CACHEREAD,78,tmva/tmva/test/DNN/TestRegressionMethodDL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestRegressionMethodDL.cxx,1,['CACHE'],['CACHEREAD']
Performance,"//TFile cache when reading",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFileCacheRead.h:8,cache,cache,8,io/io/inc/TFileCacheRead.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFileCacheRead.h,1,['cache'],['cache']
Performance,"//TFile cache when writing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFileCacheWrite.h:8,cache,cache,8,io/io/inc/TFileCacheWrite.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFileCacheWrite.h,1,['cache'],['cache']
Performance,"//TFoam::Varedu; ////////////////////////////////////////////////////////////////////////////////; /// Internal method used by Initialize.; ///; /// Determines the best edge-candidate and the position of the division plane; /// for the future cell division, in the case of the optimization of the maximum weight.; /// It exploits results of the cell MC exploration run stored in fHistEdg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx:277,optimiz,optimization,277,math/foam/src/TFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx,1,['optimiz'],['optimization']
Performance,"//TODO: Check whether we can implement this without loading the data in; // a temporary variable and whether this is noticeably faster.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:52,load,loading,52,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,1,['load'],['loading']
Performance,"//TODO: Does this even work?; // non-constant ptr can't be folded, keeps it as a v4f32 load",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp:87,load,load,87,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,1,['load'],['load']
Performance,//TODO: Support smaller loads,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp:24,load,loads,24,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,1,['load'],['loads']
Performance,//TODO: perform validation,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:8,perform,perform,8,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,1,['perform'],['perform']
Performance,"//There is a mesh in a cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLTF3Painter.cxx:23,cache,cache,23,graf3d/gl/src/TGLTF3Painter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLTF3Painter.cxx,1,['cache'],['cache']
Performance,"//True if optimization on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TVirtualStreamerInfo.h:10,optimiz,optimization,10,core/meta/inc/TVirtualStreamerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TVirtualStreamerInfo.h,1,['optimiz'],['optimization']
Performance,"//We also have other events in a queue, get rid of them!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/rootx/src/rootxx.cxx:33,queue,queue,33,rootx/src/rootxx.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/rootx/src/rootxx.cxx,1,['queue'],['queue']
Performance,"//____________________________________________________________________; //; // Cache doc info for all known classes; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/inc/TDocInfo.h:79,Cache,Cache,79,html/inc/TDocInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/inc/TDocInfo.h,1,['Cache'],['Cache']
Performance,"//____________________________________________________________________; //; // Cache doc info for all known modules; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/inc/TDocInfo.h:79,Cache,Cache,79,html/inc/TDocInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/inc/TDocInfo.h,1,['Cache'],['Cache']
Performance,//_______________________________________________________________________; /**; * Lets perform test an specific ml method given the method type in enum TMVA::Types::EMVA.; * \param method TMVA::Types::EMVA type.; * \param methodtitle method title.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Classification.cxx:87,perform,perform,87,tmva/tmva/src/Classification.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Classification.cxx,1,['perform'],['perform']
Performance,//_______________________________________________________________________; /**; * Lets perform test an specific ml method.; * \param methodname name of the method.; * \param methodtitle method title.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Classification.cxx:87,perform,perform,87,tmva/tmva/src/Classification.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Classification.cxx,1,['perform'],['perform']
Performance,//_______________________________________________________________________; /**; * Method to perform Train/Test over all ml method booked.; * If the option Jobs > 1 can do it in parallel with MultiProc.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Classification.cxx:92,perform,perform,92,tmva/tmva/src/Classification.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Classification.cxx,1,['perform'],['perform']
Performance,"//_______________________________________________________________________; /**; * Method to print the results in stdout.; * data loader name, method name/tittle and ROC-integ.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Classification.cxx:129,load,loader,129,tmva/tmva/src/Classification.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Classification.cxx,1,['load'],['loader']
Performance,//_______________________________________________________________________; /**; * Perform test evaluation in all booked methods.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Classification.cxx:82,Perform,Perform,82,tmva/tmva/src/Classification.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Classification.cxx,1,['Perform'],['Perform']
Performance,//_______________________________________________________________________; /**; Method to book the machine learning method to perform the algorithm.; \param method enum TMVA::Types::EMVA with the type of the mva method; \param methodTitle String with the method title.; \param options String with the options for the method.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Envelope.cxx:126,perform,perform,126,tmva/tmva/src/Envelope.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Envelope.cxx,1,['perform'],['perform']
Performance,//_______________________________________________________________________; /**; Method to book the machine learning method to perform the algorithm.; \param methodName String with the name of the mva method; \param methodTitle String with the method title.; \param options String with the options for the method.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Envelope.cxx:126,perform,perform,126,tmva/tmva/src/Envelope.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Envelope.cxx,1,['perform'],['perform']
Performance,"//_______________________________________________________________________; // Check options and load them to local python namespace",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyAdaBoost.cxx:96,load,load,96,tmva/pymva/src/MethodPyAdaBoost.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyAdaBoost.cxx,3,['load'],['load']
Performance,"//_________________________________________________________________________; /**. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommended to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h:92,perform,performing,92,math/mathmore/inc/Math/GSLIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLIntegrator.h,2,['perform'],"['performances', 'performing']"
Performance,"//__________________________________________________________________________; /**; Combined minimizer: combination of Migrad and Simplex. I; If the Migrad method fails at first attempt, a simplex; minimization is performed and then migrad is tried again. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/CombinedMinimizer.h:213,perform,performed,213,math/minuit2/inc/Minuit2/CombinedMinimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/CombinedMinimizer.h,1,['perform'],['performed']
Performance,//___________________________________________________________________________; /**; GSLSimAnnealing class for performing a simulated annealing search of; a multidimensional function. @ingroup MultiMin; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLSimAnnealing.h:110,perform,performing,110,math/mathmore/inc/Math/GSLSimAnnealing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLSimAnnealing.h,1,['perform'],['performing']
Performance,//____________________________________________________________________________; //; // Cuda Device Reference; //____________________________________________________________________________; /** TCudaDeviceReference; *; * Helper class emulating lvalue references for AFloat values that are; * physically on the device. Allows for example to assign to matrix elements.; * Note that device access through CudaDeviceReferences enforces synchronization; * with all streams and thus qualifies as performance killer. Only used for; * testing.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cuda/CudaMatrix.h:490,perform,performance,490,tmva/tmva/inc/TMVA/DNN/Architectures/Cuda/CudaMatrix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cuda/CudaMatrix.h,1,['perform'],['performance']
Performance,"//____________________________________________________________________________; //; // Cuda Matrix; //____________________________________________________________________________; /** TCudaMatrix Class; *; * The TCudaMatrix class represents matrices on a CUDA device. The elements; * of the matrix are stored in a TCudaDeviceBuffer object which takes care of; * the allocation and freeing of the device memory. TCudaMatrices are lightweight; * object, that means on assignment and copy creation only a shallow copy is; * performed and no new element buffer allocated. To perform a deep copy use; * the static Copy method of the TCuda architecture class.; *; * The TCudaDeviceBuffer has an associated cuda stream, on which the data is; * transferred to the device. This stream can be accessed through the; * GetComputeStream member function and used to synchronize computations.; *; * The TCudaMatrix class also holds static references to CUDA resources.; * Those are the cublas handle, a buffer of curand states for the generation; * of random numbers as well as a vector containing ones, which is used for; * summing column matrices using matrix-vector multiplication. The class also; * has a static buffer for returning results from the device.; *; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cuda/CudaMatrix.h:521,perform,performed,521,tmva/tmva/inc/TMVA/DNN/Architectures/Cuda/CudaMatrix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cuda/CudaMatrix.h,2,['perform'],"['perform', 'performed']"
Performance,"//______________________________________________________________________________; // void TTreeSQL::LoadNumberEntries(); // {; // R__ASSERT(0);; // fResult = fServer->Query(fQuery.Data());; // fEntries=0;; // while(fResult->Next()){; // fEntries++;; // }; // fResult = fServer->Query(fQuery.Data());; // }; ////////////////////////////////////////////////////////////////////////////////; /// Refresh contents of this Tree and its branches from the current; /// Tree status in the database; /// One can call this function in case the Tree on its file is being; /// updated by another process",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeSQL.cxx:100,Load,LoadNumberEntries,100,tree/tree/src/TTreeSQL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeSQL.cxx,1,['Load'],['LoadNumberEntries']
Performance,"//______________________________________________________________________________; //; // Caches class documentation information, like which module it belongs to,; // and whether THtml should generate documentation for the class.; //______________________________________________________________________________",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocInfo.cxx:89,Cache,Caches,89,html/src/TDocInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocInfo.cxx,1,['Cache'],['Caches']
Performance,"//______________________________________________________________________________; //; // Generic Gradient Descent Class; //______________________________________________________________________________; //; /*** \class TGradientDescent; *; * Generic implementation of gradient descent minimization.; *; * The TGradientDescent class implements an architecture and input data; * independent implementation of the gradient descent minimization algorithm.; *; * Provides Train(...) and TrainMomentum(...) functions that perform a complete; * training of a neural network. Those are mainly used for testing since for; * production a more fine grained control of the training process is desirable.; * This is provided by the Step(...), StepMomentum(...) and StepNesterov(...); * functions that perform a single minimization step.; *; * The main training characteristics are defined by the provided learning rate,; * the test interval, and the convergence steps required for convergence. The; * test interval defines how often the error on the validation set is computed,; * and the values with which the step counter is increased each time the; * HasConverged() member function is called. A convergence step is defined as; * a step in which the test error is NOT less than 0.999 times the current; * minimal test error that has been reached. If between two subsequent calls; * to HasConverged(Double_t) the test error has not been sufficiently reduced; * it is assumed that a number of convergence steps equal to the test interval; * has been performed.; *; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Minimizers.h:516,perform,perform,516,tmva/tmva/inc/TMVA/DNN/Minimizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Minimizers.h,3,['perform'],"['perform', 'performed']"
Performance,"//______________________________________________________________________________; //The next statement is not active anymore on Linux.; //Using posix_fadvise introduces a performance penalty (10 %) on optimized files; //and in addition it destroys the information of TTreePerfStats",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:171,perform,performance,171,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,2,"['optimiz', 'perform']","['optimized', 'performance']"
Performance,"//_____________________________________________________________________________________; /**; Class for performing function interpolation of points.; The class is instantiated with an interpolation methods, passed as an enumeration in the constructor.; See Interpolation::Type for the available interpolation algorithms, which are implemented using GSL.; See also the <A HREF=http://www.gnu.org/software/gsl/manual/html_node/Interpolation.html"">GSL manual</A> for more information.; The class provides additional methods for computing derivatives and integrals of interpolating functions. This class does not support copying.; @ingroup Interpolation; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Interpolator.h:104,perform,performing,104,math/mathmore/inc/Math/Interpolator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/Interpolator.h,1,['perform'],['performing']
Performance,//_____________________________________________________________________________________; /**; User Class to find the Root of one dimensional functions.; The GSL Methods are implemented in MathMore and they are loaded automatically; via the plug-in manager. The possible types of Root-finding algorithms are:; <ul>; <li>Root Bracketing Algorithms which do not require function derivatives; <ol>; <li>RootFinder::kBRENT (default method implemented in MathCore); <li>RootFinder::kGSL_BISECTION; <li>RootFinder::kGSL_FALSE_POS; <li>RootFinder::kGSL_BRENT; </ol>; <li>Root Finding Algorithms using Derivatives; <ol>; <li>RootFinder::kGSL_NEWTON; <li>RootFinder::kGSL_SECANT; <li>RootFinder::kGSL_STEFFENSON; </ol>; </ul>. This class does not cupport copying. @ingroup RootFinders. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/RootFinder.h:210,load,loaded,210,math/mathcore/inc/Math/RootFinder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/RootFinder.h,1,['load'],['loaded']
Performance,//___________________________________________________________________________________________; /**; User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GaussIntegrator.h:115,perform,performing,115,math/mathcore/inc/Math/GaussIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GaussIntegrator.h,1,['perform'],['performing']
Performance,//___________________________________________________________________________________________; /**; User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GaussLegendreIntegrator.h:115,perform,performing,115,math/mathcore/inc/Math/GaussLegendreIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GaussLegendreIntegrator.h,1,['perform'],['performing']
Performance,"//___________________________________________________________________________________________; /**; User class for performing function minimization. It will use the Brent Method for function minimization in a given interval.; First, a grid search is used to bracket the minimum value; with the a step size = (xmax-xmin)/npx. The step size; can be controlled via the SetNpx() function. A default value of npx = 100 is used.; The default value con be changed using the static method SetDefaultNpx.; If the function is unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval.; If the Brent method fails to converge the bracketing is repeated on the latest best estimate of the; interval. The procedure is repeated with a maximum value (default =10) which can be set for all; BrentRootFinder classes with the method SetDefaultNSearch. This class is implemented from TF1::GetMinimum. To use the class, three steps have to be taken:; 1. Create the class.; 2. Set a function within an interval to look for the minimum.; 3. Call the Minimize function with the error parameters. If another minimization is to be performed, repeat the last two steps. @ingroup Min1D. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/BrentMinimizer1D.h:115,perform,performing,115,math/mathcore/inc/Math/BrentMinimizer1D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/BrentMinimizer1D.h,2,['perform'],"['performed', 'performing']"
Performance,//___________________________________________________________________________________________; /**; User class for performing multidimensional integration. By default uses adaptive multi-dimensional integration using the algorithm from Genz Mallik; implemented in the class ROOT::Math::AdaptiveIntegratorMultiDim otherwise it can uses via the; plug-in manager the MC integration class (ROOT::Math::GSLMCIntegration) from MathMore. @ingroup Integration. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorMultiDim.h:115,perform,performing,115,math/mathcore/inc/Math/IntegratorMultiDim.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorMultiDim.h,1,['perform'],['performing']
Performance,"//____________________________________________________________________________________________; /**. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophisticated type. When performances are; important, it is then recommended to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h:116,perform,performing,116,math/mathcore/inc/Math/Integrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h,3,"['load', 'perform']","['load', 'performances', 'performing']"
Performance,"//____________________________________________________________________________________________________; /**; Class describing a 3 dimensional translation. It can be combined (using the operator *); with the ROOT::Math::Rotation3D classes and ROOT::Math::Transform3D to obtained combined; transformations and to operate on points and vectors.; Note that a the translation applied to a Vector object (DisplacementVector3D and LorentzVector classes); performs a noop, i.e. it returns the same vector. A translation can be applied only to the Point objects; (PositionVector3D classes). @ingroup GenVector. @sa Overview of the @ref GenVector ""physics vector library"". */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Translation3D.h:448,perform,performs,448,math/genvector/inc/Math/GenVector/Translation3D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Translation3D.h,1,['perform'],['performs']
Performance,"//_barlowCache[channel_name].at(bin_index) = cache;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/RooBarlowBeestonLL.cxx:45,cache,cache,45,roofit/histfactory/src/RooBarlowBeestonLL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/RooBarlowBeestonLL.cxx,1,['cache'],['cache']
Performance,"//add branch to cache (if any)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:16,cache,cache,16,tree/tree/src/TBranch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx,1,['cache'],['cache']
Performance,"//buffer larger than the cache itself: direct write to file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheWrite.cxx:25,cache,cache,25,io/io/src/TFileCacheWrite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheWrite.cxx,1,['cache'],['cache']
Performance,"//by setting the read cache to -1 we set it to the AutoFlush value when writing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/MainEvent.cxx:22,cache,cache,22,test/MainEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/MainEvent.cxx,1,['cache'],['cache']
Performance,"//cache and package handling messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/MessageTypes.h:2,cache,cache,2,core/base/inc/MessageTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/MessageTypes.h,1,['cache'],['cache']
Performance,"//cache memory in MB (default 40)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/inc/TMVA/MethodRSVM.h:2,cache,cache,2,tmva/rmva/inc/TMVA/MethodRSVM.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/inc/TMVA/MethodRSVM.h,1,['cache'],['cache']
Performance,"//cache->_numList.add(*func[1]);; //cache->_denList.add(*func[2]);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:2,cache,cache,2,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,2,['cache'],['cache']
Performance,"//cachedIntegral->disableCache(true) ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:2,cache,cachedIntegral,2,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['cache'],['cachedIntegral']
Performance,"//canvas for performance plots",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TProofBenchRunCPU.h:13,perform,performance,13,proof/proofbench/inc/TProofBenchRunCPU.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TProofBenchRunCPU.h,1,['perform'],['performance']
Performance,"//canvas for performance profile histograms",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TProofBenchRunDataRead.h:13,perform,performance,13,proof/proofbench/inc/TProofBenchRunDataRead.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TProofBenchRunDataRead.h,1,['perform'],['performance']
Performance,"//cl_khr_fp16; /**; * Perform an async gather of num_elements; * gentype elements from src to dst. The; * src_stride is the stride in elements for each; * gentype element read from src. The dst_stride; * is the stride in elements for each gentype; * element written to dst. The async gather is; * performed by all work-items in a work-group.; * This built-in function must therefore be; * encountered by all work-items in a work-group; * executing the kernel with the same argument; * values; otherwise the results are undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the; * async_work_group_strided_copy with a; * previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:22,Perform,Perform,22,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h,4,"['Perform', 'perform']","['Perform', 'perform', 'performed', 'performing']"
Performance,"//cl_khr_fp16; /**; * Returns 0.0 if x <= edge0 and 1.0 if x >= edge1 and; * performs smooth Hermite interpolation between 0; * and 1when edge0 < x < edge1. This is useful in; * cases where you would want a threshold function; * with a smooth transition.; * This is equivalent to:; * gentype t;; * t = clamp ((x - edge0) / (edge1 - edge0), 0, 1);; * return t * t * (3 - 2 * t);; * Results are undefined if edge0 >= edge1 or if x,; * edge0 or edge1 is a NaN.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:77,perform,performs,77,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h,1,['perform'],['performs']
Performance,//cl_khr_fp16; /**; * Wait for events that identify the; * async_work_group_copy operations to; * complete. The event objects specified in; * event_list will be released after the wait is; * performed.; * This function must be encountered by all workitems; * in a work-group executing the kernel with; * the same num_events and event objects specified; * in event_list; otherwise the results are undefined.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:191,perform,performed,191,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h,1,['perform'],['performed']
Performance,"//cl_khr_fp16; // OpenCL v1.1 s6.11.7, v1.2 s6.12.7, v2.0 s6.13.7 - Vector Data Load and Store Functions; // OpenCL extensions v1.1 s9.6.6, v1.2 s9.5.6, v2.0 s9.4.6 - Vector Data Load and Store Functions for Half Type; /**; * Use generic type gentype to indicate the built-in data types; * char, uchar, short, ushort, int, uint, long, ulong, float,; * double or half.; *; * vloadn return sizeof (gentypen) bytes of data read from address (p + (offset * n)).; *; * vstoren write sizeof (gentypen) bytes given by data to address (p + (offset * n)).; *; * The address computed as (p + (offset * n)) must be; * 8-bit aligned if gentype is char, uchar;; * 16-bit aligned if gentype is short, ushort, half;; * 32-bit aligned if gentype is int, uint, float;; * 64-bit aligned if gentype is long, ulong, double.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:80,Load,Load,80,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h,2,['Load'],['Load']
Performance,"//clear cache buffer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:8,cache,cache,8,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['cache'],['cache']
Performance,"//construct h-subsets and perform 2 CSteps in subgroups",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TRobustEstimator.cxx:26,perform,perform,26,math/physics/src/TRobustEstimator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TRobustEstimator.cxx,1,['perform'],['perform']
Performance,"//cout << ""RooCacheManager<T>::setObj() increasing object cache size from "" << _maxSize << "" to "" << _maxSize*2 << endl ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h:58,cache,cache,58,roofit/roofitcore/inc/RooCacheManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h,1,['cache'],['cache']
Performance,"//cout << ""RooCacheManager<T>::setObj()/SI increasing object cache size from "" << _maxSize << "" to "" << sterileIdx+4 << endl ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h:61,cache,cache,61,roofit/roofitcore/inc/RooCacheManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h,1,['cache'],['cache']
Performance,"//cout << ""RooConvBasBinding::loadValues["" << index << ""] loading value "" << xvector[index] << endl ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooConvIntegrandBinding.cxx:30,load,loadValues,30,roofit/roofitcore/src/RooConvIntegrandBinding.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooConvIntegrandBinding.cxx,2,['load'],"['loadValues', 'loading']"
Performance,"//cout << ""RooRealMPFE::getValF("" << GetName() << "") cache is clean, doing nothing"" << endl ;; // Cache is clean and calculated value is in cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx:53,cache,cache,53,roofit/roofitcore/src/RooRealMPFE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx,3,"['Cache', 'cache']","['Cache', 'cache']"
Performance,"//cout << ""RooRealMPFE::getValF("" << GetName() << "") calculation in progress, calling evaluate"" << endl ;; // Cache is clean and calculation is in progress",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx:110,Cache,Cache,110,roofit/roofitcore/src/RooRealMPFE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx,1,['Cache'],['Cache']
Performance,"//cout << ""RooRealSumPdf(""<<this<<"")::getAnalyticalIntegralWN:""<<GetName()<<""(""<<allVars<<"",""<<analVars<<"",""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << "" -> "" << _normIntMgr.lastIndex()+1 << "" (cached)"" << endl;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealSumPdf.cxx:225,cache,cached,225,roofit/roofitcore/src/RooRealSumPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealSumPdf.cxx,1,['cache'],['cached']
Performance,"//create a buffer where the object will be streamed; //We are forced to go via the I/O package (ie TBufferFile).; //Invoking TBufferFile via CINT will automatically load the I/O library",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TDirectory.cxx:165,load,load,165,core/base/src/TDirectory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TDirectory.cxx,1,['load'],['load']
Performance,"//creating loader for subseed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/VariableImportance.cxx:11,load,loader,11,tmva/tmva/src/VariableImportance.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/VariableImportance.cxx,2,['load'],['loader']
Performance,"//defined(__OPENCL_CPP_VERSION__) || (__OPENCL_C_VERSION__ >= CL_VERSION_2_0); // OpenCL v1.1 s6.11.9, v1.2 s6.12.9 - Explicit Memory Fence Functions; /**; * Orders loads and stores of a work-item; * executing a kernel. This means that loads; * and stores preceding the mem_fence will; * be committed to memory before any loads; * and stores following the mem_fence.; * The flags argument specifies the memory; * address space and can be set to a; * combination of the following literal; * values:; * CLK_LOCAL_MEM_FENCE; * CLK_GLOBAL_MEM_FENCE.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:165,load,loads,165,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h,3,['load'],['loads']
Performance,"//defined(__opencl_c_generic_address_space); // OpenCL v1.1 s6.11.10, v1.2 s6.12.10, v2.0 s6.13.10 - Async Copies from Global to Local Memory, Local to Global Memory, and Prefetch; /**; * event_t async_work_group_copy (; * __global gentype *dst,; * const __local gentype *src,; * size_t num_elements,; * event_t event); * Perform an async copy of num_elements; * gentype elements from src to dst. The async; * copy is performed by all work-items in a workgroup; * and this built-in function must therefore; * be encountered by all work-items in a workgroup; * executing the kernel with the same; * argument values; otherwise the results are; * undefined.; * Returns an event object that can be used by; * wait_group_events to wait for the async copy; * to finish. The event argument can also be used; * to associate the async_work_group_copy with; * a previous async copy allowing an event to be; * shared by multiple async copies; otherwise event; * should be zero.; * If event argument is non-zero, the event object; * supplied in event argument will be returned.; * This function does not perform any implicit; * synchronization of source data such as using a; * barrier before performing the copy.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:322,Perform,Perform,322,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h,4,"['Perform', 'perform']","['Perform', 'perform', 'performed', 'performing']"
Performance,"//defined(__opencl_c_named_address_space_builtins); // OpenCL v1.1 s6.11.8, v1.2 s6.12.8, v2.0 s6.13.8 - Synchronization Functions; /**; * All work-items in a work-group executing the kernel; * on a processor must execute this function before any; * are allowed to continue execution beyond the barrier.; * This function must be encountered by all work-items in; * a work-group executing the kernel.; * If barrier is inside a conditional statement, then all; * work-items must enter the conditional if any work-item; * enters the conditional statement and executes the; * barrier.; * If barrer is inside a loop, all work-items must execute; * the barrier for each iteration of the loop before any are; * allowed to continue execution beyond the barrier.; * The barrier function also queues a memory fence; * (reads and writes) to ensure correct ordering of; * memory operations to local or global memory.; * The flags argument specifies the memory address space; * and can be set to a combination of the following literal; * values.; * CLK_LOCAL_MEM_FENCE - The barrier function; * will either flush any variables stored in local memory; * or queue a memory fence to ensure correct ordering of; * memory operations to local memory.; * CLK_GLOBAL_MEM_FENCE - The barrier function; * will queue a memory fence to ensure correct ordering; * of memory operations to global memory. This can be; * useful when work-items, for example, write to buffer or; * image objects and then want to read the updated data.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h:783,queue,queues,783,interpreter/llvm-project/clang/lib/Headers/opencl-c.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c.h,3,['queue'],"['queue', 'queues']"
Performance,"//delete the file cache if it points to this Tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:18,cache,cache,18,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,3,['cache'],['cache']
Performance,"//f->cacheHash = cacheHash;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx:5,cache,cacheHash,5,gui/gui/src/TGFont.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx,2,['cache'],['cacheHash']
Performance,"//first delete cache if exists",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:15,cache,cache,15,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['cache'],['cache']
Performance,"//fontCache.DeleteHashEntry(cacheHash);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx:28,cache,cacheHash,28,gui/gui/src/TGFont.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx,1,['cache'],['cacheHash']
Performance,"//for all best solutions perform 2 CSteps and then choose the very best",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TRobustEstimator.cxx:25,perform,perform,25,math/physics/src/TRobustEstimator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TRobustEstimator.cxx,1,['perform'],['perform']
Performance,"//for the nbest best results, perform CSteps until convergence",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TLinearFitter.cxx:30,perform,perform,30,math/minuit/src/TLinearFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TLinearFitter.cxx,1,['perform'],['perform']
Performance,"//h1->Draw();; // gSystem->Load(""libMinuit2"");; // gSystem->Load(""libFit"");; // ROOT::Fit::DataVector<ROOT::Fit::BinPoint> dv;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/fit/testFit.cxx:27,Load,Load,27,math/mathcore/test/fit/testFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/fit/testFit.cxx,2,['Load'],['Load']
Performance,"//if GSL is available load (and register GSL integrator)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumIntFactory.cxx:22,load,load,22,roofit/roofitcore/src/RooNumIntFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumIntFactory.cxx,1,['load'],['load']
Performance,"//if a integer value k>0 is specified, a k-fold cross; //validation on the training data is performed to assess the; //quality of the model: the accuracy rate for classification; //and the Mean Squared Error for regression",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/inc/TMVA/MethodRSVM.h:92,perform,performed,92,tmva/rmva/inc/TMVA/MethodRSVM.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/inc/TMVA/MethodRSVM.h,1,['perform'],['performed']
Performance,"//initialise the prefetch object and set the cache directory; // start the thread only if the file is not local",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx:45,cache,cache,45,io/io/src/TFileCacheRead.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx,1,['cache'],['cache']
Performance,"//integer, optional (default=3); //maximum depth of the individual regression estimators. The maximum; //depth limits the number of nodes in the tree. Tune this parameter; //for best performance; the best value depends on the interaction; //of the input variables.; //Ignored if ``max_leaf_nodes`` is not None.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/inc/TMVA/MethodPyGTB.h:151,Tune,Tune,151,tmva/pymva/inc/TMVA/MethodPyGTB.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/inc/TMVA/MethodPyGTB.h,2,"['Tune', 'perform']","['Tune', 'performance']"
Performance,"//invalidate cached integral since parameters have changed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:13,cache,cached,13,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['cache'],['cached']
Performance,"//it is probably an url, try to load it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:32,load,load,32,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['load'],['load']
Performance,"//list of performance plots",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TProofBenchRunCPU.h:10,perform,performance,10,proof/proofbench/inc/TProofBenchRunCPU.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TProofBenchRunCPU.h,2,['perform'],['performance']
Performance,"//load in a new dataset and re-calculate the PDF; //return 0 if successful",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/Roo2DKeysPdf.h:2,load,load,2,roofit/roofit/inc/Roo2DKeysPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/Roo2DKeysPdf.h,1,['load'],['load']
Performance,"//load the next non-empty list. fTreeNumber is changed by LoadList()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx:2,load,load,2,tree/tree/src/TEntryListFromFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx,2,"['Load', 'load']","['LoadList', 'load']"
Performance,"//minim.optimizeConst(false);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ProfileLikelihoodTestStat.cxx:8,optimiz,optimizeConst,8,roofit/roostats/src/ProfileLikelihoodTestStat.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ProfileLikelihoodTestStat.cxx,1,['optimiz'],['optimizeConst']
Performance,"//not found in cache. Do we need to fill the cache?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:15,cache,cache,15,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['cache'],['cache']
Performance,"//now copy from the read-ahead buffer to the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:45,cache,cache,45,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['cache'],['cache']
Performance,"//now for nbest best results perform CSteps until convergence",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TRobustEstimator.cxx:29,perform,perform,29,math/physics/src/TRobustEstimator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TRobustEstimator.cxx,1,['perform'],['perform']
Performance,"//number of function evaluations performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx:33,perform,performed,33,math/mathcore/src/AdaptiveIntegratorMultiDim.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx,1,['perform'],['performed']
Performance,//optimizeSpeed,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:2,optimiz,optimizeSpeed,2,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['optimiz'],['optimizeSpeed']
Performance,"//optimx is available and loaded",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/rtools/src/RMinimizer.cxx:26,load,loaded,26,math/rtools/src/RMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/rtools/src/RMinimizer.cxx,1,['load'],['loaded']
Performance,"//relative CPU performance index",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TSlave.h:15,perform,performance,15,proof/proof/inc/TSlave.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TSlave.h,1,['perform'],['performance']
Performance,"//relative performance of this slave",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h:11,perform,performance,11,proof/proof/inc/TProof.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h,1,['perform'],['performance']
Performance,"//require to use numpy arrays; // Check options and load them to local python namespace",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyAdaBoost.cxx:52,load,load,52,tmva/pymva/src/MethodPyAdaBoost.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyAdaBoost.cxx,3,['load'],['load']
Performance,"//save performance profiles to file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBenchRunCPU.cxx:7,perform,performance,7,proof/proofbench/src/TProofBenchRunCPU.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBenchRunCPU.cxx,2,['perform'],['performance']
Performance,"//set performance index to 100 by default",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TCondor.cxx:6,perform,performance,6,proof/proof/src/TCondor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TCondor.cxx,1,['perform'],['performance']
Performance,"//set the file cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx:15,cache,cache,15,tree/treeplayer/src/TTreePlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx,1,['cache'],['cache']
Performance,"//std::cout << ""doing selected fit with option "" << opt << std::endl;; // perform the fit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx:74,perform,perform,74,test/stressHistoFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx,1,['perform'],['perform']
Performance,"//test to be performed every fStep workers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TProofBenchRunCPU.h:13,perform,performed,13,proof/proofbench/inc/TProofBenchRunCPU.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TProofBenchRunCPU.h,2,['perform'],['performed']
Performance,"//the linker does not like to be mmapped; //causes a crash in cling::DynamicLibraryManager::loadLibrary()); //with error message ""mmap of entire address space failed: Cannot allocate memory""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:92,load,loadLibrary,92,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['load'],['loadLibrary']
Performance,"//this call is required when using the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/MainEvent.cxx:39,cache,cache,39,test/MainEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/MainEvent.cxx,1,['cache'],['cache']
Performance,"//this list hasn't been loaded yet",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx:24,load,loaded,24,tree/tree/src/TEntryListFromFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx,1,['load'],['loaded']
Performance,"//this should fix multi-thread inizializations of arrays",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/Propagation.hxx:18,multi-thread,multi-thread,18,tmva/tmva/src/DNN/Architectures/Cpu/Propagation.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/Propagation.hxx,1,['multi-thread'],['multi-thread']
Performance,"//time_after_setVal=clock();; // Done with the first loops.; // Now evaluating the function; //clock_t time_before_eval, time_after_eval;; // Loop over the bins in the cache; //time_before_eval=clock();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/RooBarlowBeestonLL.cxx:168,cache,cache,168,roofit/histfactory/src/RooBarlowBeestonLL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/RooBarlowBeestonLL.cxx,1,['cache'],['cache']
Performance,"//true when performing a robust fit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/inc/TLinearFitter.h:12,perform,performing,12,math/minuit/inc/TLinearFitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/inc/TLinearFitter.h,1,['perform'],['performing']
Performance,"//trying to set the first tree, because in the Draw function; //the tree corresponding to firstentry has already been loaded,; //so it is not set in the entry list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx:118,load,loaded,118,tree/treeplayer/src/TTreePlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx,1,['load'],['loaded']
Performance,"//update error cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SVWorkingSet.cxx:15,cache,cache,15,tmva/tmva/src/SVWorkingSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SVWorkingSet.cxx,1,['cache'],['cache']
Performance,"//use 1% calls to optimize best founded minimum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SimulatedAnnealing.cxx:18,optimiz,optimize,18,tmva/tmva/src/SimulatedAnnealing.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SimulatedAnnealing.cxx,1,['optimiz'],['optimize']
Performance,"//use built-in optimized version",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx:15,optimiz,optimized,15,graf2d/asimage/src/TASImage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx,4,['optimiz'],['optimized']
Performance,"//use option load=kFALSE to avoid a warning like:; //""Warning in <TClass::TClass>: no dictionary for class TRefCnt is available""; //We can not afford to not have the class if it exist, so we; //use kTRUE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:13,load,load,13,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['load'],['load']
Performance,"//wc.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(_T(""SPLASH"")));",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/Win32Splash.cxx:13,Load,LoadIcon,13,core/winnt/src/Win32Splash.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/Win32Splash.cxx,1,['Load'],['LoadIcon']
Performance,"//we must flush the current cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheWrite.cxx:28,cache,cache,28,io/io/src/TFileCacheWrite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheWrite.cxx,1,['cache'],['cache']
Performance,"//we must reset the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx:20,cache,cache,20,tree/treeplayer/src/TTreePlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx,1,['cache'],['cache']
Performance,"//well may be the Exec has loaded the object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TRef.cxx:27,load,loaded,27,core/base/src/TRef.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TRef.cxx,1,['load'],['loaded']
Performance,"/12/30 13:57:55 dawes Exp $; *; * Copyright 1992 Network Computing Devices, Inc.; *; * Permission to use, copy, modify, and distribute this software and its; * documentation for any purpose and without fee is hereby granted, provided; * that the above copyright notice appear in all copies and that both that; * copyright notice and this permission notice appear in supporting; * documentation, and that the name of Network Computing Devices may not be; * used in advertising or publicity pertaining to distribution of the software; * without specific, written prior permission. Network Computing Devices makes; * no representations about the suitability of this software for any purpose.; * It is provided ``as is'' without express or implied warranty.; *; * NETWORK COMPUTING DEVICES DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS; * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,; * IN NO EVENT SHALL NETWORK COMPUTING DEVICES BE LIABLE FOR ANY SPECIAL,; * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM; * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE; * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR; * PERFORMANCE OF THIS SOFTWARE.; *; * Author: Jim Fulton; * Network Computing Devices, Inc.; *; * Simple if statement processor; *; * This module can be used to evaluate string representations of C language; * if constructs. It accepts the following grammar:; *; * EXPRESSION := VALUE; * | VALUE BINOP EXPRESSION; * | VALUE '?' EXPRESSION ':' EXPRESSION; *; * VALUE := '(' EXPRESSION ')'; * | '!' VALUE; * | '-' VALUE; * | '~' VALUE; * | 'defined' '(' variable ')'; * | 'defined' variable; * | # variable '(' variable-list ')'; * | variable; * | number; *; * BINOP := '*' | '/' | '%'; * | '+' | '-'; * | '<<' | '>>'; * | '<' | '>' | '<=' | '>='; * | '==' | '!='; * | '&' | '^' | '|'; * | '&&' | '||'; *; * The normal C order of precedence is supported.; *; *; * External Entry Points:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rmkdepend/ifparser.c:1340,PERFORM,PERFORMANCE,1340,misc/rmkdepend/ifparser.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rmkdepend/ifparser.c,1,['PERFORM'],['PERFORMANCE']
Performance,"/OR SOFTWARE (""SOFTWARE""),; YOU UNEQUIVOCALLY ACCEPT, AND AGREE TO BE BOUND BY, ALL OF THE; TERMS AND CONDITIONS OF THIS AGREEMENT.; IF YOU DO NOT AGREE, DO NOT DOWNLOAD, INSTALL, COPY, DISTRIBUTE OR USE; THE DATA FILES OR SOFTWARE. COPYRIGHT AND PERMISSION NOTICE. Copyright © 1991-2022 Unicode, Inc. All rights reserved.; Distributed under the Terms of Use in https://www.unicode.org/copyright.html. Permission is hereby granted, free of charge, to any person obtaining; a copy of the Unicode data files and any associated documentation; (the ""Data Files"") or Unicode software and any associated documentation; (the ""Software"") to deal in the Data Files or Software; without restriction, including without limitation the rights to use,; copy, modify, merge, publish, distribute, and/or sell copies of; the Data Files or Software, and to permit persons to whom the Data Files; or Software are furnished to do so, provided that either; (a) this copyright and permission notice appear with all copies; of the Data Files or Software, or; (b) this copyright and permission notice appear in associated; Documentation. THE DATA FILES AND SOFTWARE ARE PROVIDED ""AS IS"", WITHOUT WARRANTY OF; ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE; WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; NONINFRINGEMENT OF THIRD PARTY RIGHTS.; IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS; NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL; DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,; DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER; TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR; PERFORMANCE OF THE DATA FILES OR SOFTWARE. Except as contained in this notice, the name of a copyright holder; shall not be used in advertising or otherwise to promote the sale,; use or other dealings in these Data Files or Software without prior; written authorization of the copyright holder.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/UnicodeNameToCodepointGenerated.cpp:2688,PERFORM,PERFORMANCE,2688,interpreter/llvm-project/llvm/lib/Support/UnicodeNameToCodepointGenerated.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/UnicodeNameToCodepointGenerated.cpp,1,['PERFORM'],['PERFORMANCE']
Performance,"/README/CREDITS. *; *************************************************************************/; /** \class TTreeCache; \ingroup tree; \brief A cache to speed-up the reading of ROOT datasets. # A cache to speed-up the reading of ROOT datasets. ## Table of Contents; - [Motivation](\ref motivation); - [General Description](\ref description); - [Changes in behaviour](\ref changesbehaviour); - [Self-optimization](\ref cachemisses); - [Examples of usage](\ref examples); - [Check performance and stats](\ref checkPerf). \anchor motivation; ## Motivation: why having a cache is needed?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of TTrees with several; hundred or thousand branches. When writing, this does not generate a performance problem because branch; buffers are always written sequentially and, thanks to OS optimisations,; content is flushed to the output file when a few MBytes of data are available.; On the other hand, when reading, one may hit performance problems because of; latencies e.g imposed by network.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second. The TreeCache tries to prefetch all the buffers for the selected branches; in order to transfer a few multi-Megabytes large buffers instead of many; multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to; be read in increasing order such that the file is read sequentially. Systems like xrootd, dCache or httpd take advantage of the TTreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. ### Are there cases for which the usage o",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:1244,perform,performance,1244,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['perform'],['performance']
Performance,"2) A program when released has no strange ""features"" or bugs.; 3) A program is robust and handles ALL extreme and unusual cases.; 4) A program is written in phases and modules with hard tests for each one.; 5) A program is written for any user who doesn't need special knowledge; to use the program.; 6) A program has well defined user requirements and functional specifications.; 7) A program is written with regard to future expansion and integreation; with other systems (portability). When programming following these additional principles make programs easier; to maintain. A) Choose variable names that accurately describes what the variable does/is.; B) Write comments to inform someone faced with the task of modifying your code.; C) Avoid excessive comments. Write the code so that it says what it does.; D) Follow a strict one-in, one-out flow of control structues except in the; case of fatal error conditions.; E) Avoid using global variables.; F) Do not cause side effects to variables that were not parameters to a; function.; G) Have a single function perform a single purpose.; H) Select a single indentation style and stick with it.; I) Use a consistent naming convention. The following principles help me when I try optimizing code:. a) If optimizing, use a profiler to determine which sections of code most of; the time is spent in. Spend most of your effort in the most used sections.; Don't bother optimizing a procedure using less than 10% of the time. b) High level optimizations are far more effective than cycle shaving.; (e.g. use quick sort instead of optimizing a bubble sort.). c) Be flexible in your approach to solving a problem. List exactly what you; need as a result at a minimum. Get rid of unnecessary assumptions. d) Become familiar with sets of operations that are equivalent, or nearly so.; Learn the relative expense of basic operations. e) If possible, be careful not to needlessly sacrifice significant readability; of the code for a cycle or two. -- Spy. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/x3d.c:2602,perform,perform,2602,graf3d/x3d/src/x3d.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/x3d.c,6,"['optimiz', 'perform']","['optimizations', 'optimizing', 'perform']"
Performance,"2->Draw(""col same"");; h3->Draw(""col same"");; h4->Draw(""col same"");; }; End_Macro. The option `COL` can be combined with the option `POL`:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol1->Fill(px,py);; }; hcol1->Draw(""COLZPOL"");; }; End_Macro. \since **ROOT version 6.07/03:**. A second rendering technique is also available with the COL2 and COLZ2 options. These options provide potential performance improvements compared to the standard; COL option. The performance comparison of the COL2 to the COL option depends on; the histogram and the size of the rendering region in the current pad. In general,; a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; faster with the COL option. However, for larger histograms (approx. more than 100 bins per axis); that are not sparse, the COL2 option will provide up to 20 times performance improvements.; For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; faster with the COL2 option. The COL2 option will also scale its performance based on the size of the; pixmap the histogram image is being rendered into. It also is much better optimized for; sessions where the user is forwarding X11 windows through an `ssh` connection. For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; and COLZ options. There is one major difference and that concerns the treatment of; bins with zero content. The COL2 and COLZ2 options color these bins the color of zero. COL2 option renders the histogram as a bitmap. Therefore it cannot be saved in vector; graphics file format like PostScript or PDF (an empty image will be generated). It can; be saved only in bitmap files like PNG format for instance. \anchor HP140; ### The CANDLE and VIOLIN options. The mechanism behind Candle plots and Vi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:41469,perform,performance,41469,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['perform'],['performance']
Performance,"4 1996/09/28 16:15:24 rws $; *; * Copyright 1992 Network Computing Devices, Inc.; *; * Permission to use, copy, modify, and distribute this software and its; * documentation for any purpose and without fee is hereby granted, provided; * that the above copyright notice appear in all copies and that both that; * copyright notice and this permission notice appear in supporting; * documentation, and that the name of Network Computing Devices may not be; * used in advertising or publicity pertaining to distribution of the software; * without specific, written prior permission. Network Computing Devices makes; * no representations about the suitability of this software for any purpose.; * It is provided ``as is'' without express or implied warranty.; *; * NETWORK COMPUTING DEVICES DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS; * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,; * IN NO EVENT SHALL NETWORK COMPUTING DEVICES BE LIABLE FOR ANY SPECIAL,; * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM; * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE; * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR; * PERFORMANCE OF THIS SOFTWARE.; *; * Author: Jim Fulton; * Network Computing Devices, Inc.; *; * Simple if statement processor; *; * This module can be used to evaluate string representations of C language; * if constructs. It accepts the following grammar:; *; * EXPRESSION := VALUE; * | VALUE BINOP EXPRESSION; * | VALUE '?' EXPRESSION ':' EXPRESSION; *; * VALUE := '(' EXPRESSION ')'; * | '!' VALUE; * | '-' VALUE; * | '~' VALUE; * | 'defined' '(' variable ')'; * | variable; * | number; *; * BINOP := '*' | '/' | '%'; * | '+' | '-'; * | '<<' | '>>'; * | '<' | '>' | '<=' | '>='; * | '==' | '!='; * | '&' | '^' | '|'; * | '&&' | '||'; *; * The normal C order of precedence is supported.; *; *; * External Entry Points:; *; * ParseIfExpression parse a string for #if; */; /* $XFree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rmkdepend/ifparser.h:1256,PERFORM,PERFORMANCE,1256,misc/rmkdepend/ifparser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rmkdepend/ifparser.h,1,['PERFORM'],['PERFORMANCE']
Performance,"40,-3,3,40,-3,3);; auto h2 = new TH2F(""h2"",""h2"",40,-3,3,40,-3,3);; auto h3 = new TH2F(""h3"",""h3"",40,-3,3,40,-3,3);; auto h4 = new TH2F(""h4"",""h4"",40,-3,3,40,-3,3);; h1->SetBit(TH1::kNoStats);; for (Int_t i=0;i<5000;i++) {; double x,y;; gRandom->Rannor(x,y);; if(x>0 && y>0) h1->Fill(x,y,4);; if(x<0 && y<0) h2->Fill(x,y,3);; if(x>0 && y<0) h3->Fill(x,y,2);; if(x<0 && y>0) h4->Fill(x,y,1);; }; h1->Draw(""colz"");; h2->Draw(""col same"");; h3->Draw(""col same"");; h4->Draw(""col same"");; }; End_Macro. The option `COL` can be combined with the option `POL`:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol1->Fill(px,py);; }; hcol1->Draw(""COLZPOL"");; }; End_Macro. \since **ROOT version 6.07/03:**. A second rendering technique is also available with the COL2 and COLZ2 options. These options provide potential performance improvements compared to the standard; COL option. The performance comparison of the COL2 to the COL option depends on; the histogram and the size of the rendering region in the current pad. In general,; a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; faster with the COL option. However, for larger histograms (approx. more than 100 bins per axis); that are not sparse, the COL2 option will provide up to 20 times performance improvements.; For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; faster with the COL2 option. The COL2 option will also scale its performance based on the size of the; pixmap the histogram image is being rendered into. It also is much better optimized for; sessions where the user is forwarding X11 windows through an `ssh` connection. For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; and COLZ options. There is one major difference and that concerns the treatment of; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:41007,perform,performance,41007,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['perform'],['performance']
Performance,"43),; // [50, 75] <- (5075), [10, 85] <- (1085); //; // The data represents a set of overlapping intervals:; //; // 30--35 39------------50 55----61; // 31------------------------56; // 12--------21 25------------41 49-------------65 71-----79; // 11----16 20-----30 36----------------54 60------70 74---- 80; // 15---------------------40 43--43 50--------------------75; // 10----------------------------------------------------------------------85; //; // The items are stored in a binary tree with each node storing:; //; // MP: A middle point.; // IL: All intervals whose left value are completely to the left of the middle; // point. They are sorted in ascending order by their beginning point.; // IR: All intervals whose right value are completely to the right of the; // middle point. They are sorted in descending order by their ending point.; // LS: Left subtree.; // RS: Right subtree.; //; // As IL and IR will contain the same intervals, in order to optimize space,; // instead of storing intervals on each node, we use two vectors that will; // contain the intervals described by IL and IR. Each node will contain an; // index into that vector (global bucket), to indicate the beginning of the; // intervals assigned to the node.; //; // The following is the output from print():; //; // 0: MP:43 IR [10,85] [31,56] [36,54] [39,50] [43,43]; // 0: MP:43 IL [10,85] [31,56] [36,54] [39,50] [43,43]; // 1: MP:25 IR [25,41] [15,40] [20,30]; // 1: MP:25 IL [15,40] [20,30] [25,41]; // 2: MP:15 IR [12,21] [11,16]; // 2: MP:15 IL [11,16] [12,21]; // 2: MP:36 IR []; // 2: MP:36 IL []; // 3: MP:31 IR [30,35]; // 3: MP:31 IL [30,35]; // 1: MP:61 IR [50,75] [60,70] [49,65] [55,61]; // 1: MP:61 IL [49,65] [50,75] [55,61] [60,70]; // 2: MP:74 IR [74,80] [71,79]; // 2: MP:74 IL [71,79] [74,80]; //; // with:; // 0: Root Node.; // MP: Middle point.; // IL: Intervals to the left (in ascending order by beginning point).; // IR: Intervals to the right (in descending order by ending point).; //; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h:2718,optimiz,optimize,2718,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,1,['optimiz'],['optimize']
Performance,"5], is a follows (please refer to; [5] for a full discussion):. 1. Define \f$\mathbf{P} = (P_1, \ldots, P_5)\f$ are the 5 dependent; quantities that define a track.; 2. Compute, for \f$ M\f$ different values of \f$\mathbf{P}\f$, the tracks; through the magnetic field, and determine the corresponding; \f$\mathbf{x} = (x_1, \ldots, x_N)\f$.; 3. Use the simulated observations to determine, with a simple; approximation, the values of \f$\mathbf{P}_j\f$. We call these values; \f$\mathbf{P}^\prime_j, j = 1, \ldots, M\f$.; 4. Determine from \f$\mathbf{x}\f$ a set of at least five relevant; coordinates \f$\mathbf{x}^\prime\f$, using contrains, *or; alternative:*; 5. Perform a Principal Component Analysis (using TPrincipal), and use; to get a linear transformation \f$\mathbf{x} \rightarrow \mathbf{x}^\prime\f$, so that; \f$\mathbf{x}^\prime\f$ are constrained and linear independent.; 6. Perform a Principal Component Analysis on; \f$Q_i = P_i / P^\prime_i\, i = 1, \ldots, 5\f$, to get linear; indenpendent (among themselves, but not independent of \f$\mathbf{x}\f$) quantities; \f$\mathbf{Q}^\prime\f$; 7. For each component \f$Q^\prime_i\f$ make a multidimensional fit,; using \f$\mathbf{x}^\prime\f$ as the variables, thus determining a set of; coefficients \f$\mathbf{c}_i\f$. To process data, using this parameterisation, do; 1. Test wether the observation \f$\mathbf{x}\f$ within the domain of; the parameterization, using the result from the Principal Component; Analysis.; 2. Determine \f$\mathbf{P}^\prime\f$ as before.; 3. Determine \f$\mathbf{x}^\prime\f$ as before.; 4. Use the result of the fit to determine \f$\mathbf{Q}^\prime\f$.; 5. Transform back to \f$\mathbf{P}\f$ from \f$\mathbf{Q}^\prime\f$, using; the result from the Principal Component Analysis. ## Testing the parameterization; The class also provides functionality for testing the, over the; training sample, found parameterization (TMultiDimFit::Fit). This is done by passing; the class a test sample of \f$ M_t\f$ tu",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:15336,Perform,Perform,15336,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['Perform'],['Perform']
Performance,"6); // |.(VLAs)............................| (size of this area is unknown at; // |...................................| compile time); // |-----------------------------------| <- sp; // | | Lower address; //; //; // To access the data in a frame, at-compile time, a constant offset must be; // computable from one of the pointers (fp, bp, sp) to access it. The size; // of the areas with a dotted background cannot be computed at compile-time; // if they are present, making it required to have all three of fp, bp and; // sp to be set up to be able to access all contents in the frame areas,; // assuming all of the frame areas are non-empty.; //; // For most functions, some of the frame areas are empty. For those functions,; // it may not be necessary to set up fp or bp:; // * A base pointer is definitely needed when there are both VLAs and local; // variables with more-than-default alignment requirements.; // * A frame pointer is definitely needed when there are local variables with; // more-than-default alignment requirements.; //; // In some cases when a base pointer is not strictly needed, it is generated; // anyway when offsets from the frame pointer to access local variables become; // so large that the offset can't be encoded in the immediate fields of loads; // or stores.; //; // The frame pointer might be chosen to be r7 or r11, depending on the target; // architecture and operating system. See ARMSubtarget::getFramePointerReg for; // details.; //; // Outgoing function arguments must be at the bottom of the stack frame when; // calling another function. If we do not have variable-sized stack objects, we; // can allocate a ""reserved call frame"" area at the bottom of the local; // variable area, large enough for all outgoing calls. If we do have VLAs, then; // the stack pointer must be decremented and incremented around each call to; // make space for the arguments below the VLAs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:3721,load,loads,3721,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,1,['load'],['loads']
Performance,"6AvoidStoreForwardingBlocks.cpp - Avoid HW Store Forward Block ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // If a load follows a store and reloads data that the store has written to; // memory, Intel microarchitectures can in many cases forward the data directly; // from the store to the load, This ""store forwarding"" saves cycles by enabling; // the load to directly obtain the data instead of accessing the data from; // cache or memory.; // A ""store forward block"" occurs in cases that a store cannot be forwarded to; // the load. The most typical case of store forward block on Intel Core; // microarchitecture that a small store cannot be forwarded to a large load.; // The estimated penalty for a store forward block is ~13 cycles.; //; // This pass tries to recognize and handle cases where ""store forward block""; // is created by the compiler when lowering memcpy calls to a sequence; // of a load and a store.; //; // The pass currently only handles cases where memcpy is lowered to; // XMM/YMM registers, it tries to break the memcpy into smaller copies.; // breaking the memcpy should be possible since there is no atomicity; // guarantee for loads and stores to XMM/YMM.; //; // It could be better for performance to solve the problem by loading; // to XMM/YMM then inserting the partial store before storing back from XMM/YMM; // to memory, but this will result in a more conservative optimization since it; // requires we prove that all memory accesses between the blocking store and the; // load must alias/don't alias before we can move the store, whereas the; // transformation done here is correct regardless to other memory accesses.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:1176,load,load,1176,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,6,"['load', 'optimiz', 'perform']","['load', 'loading', 'loads', 'optimization', 'performance']"
Performance,"8;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias analysis in codegen).; // Such transformation can have following benefits:; // (1) It can always extract constants in the indices of structure type.; // (2) After such Lowering, there are more optimization opportunities such as; // CSE, LICM and CGP.; //; // E.g. The following GEPs have multiple indices:; // BB1:; // %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3; // load %p; // ...; // BB2:; // %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2; // load %p2; // ...; //; // We can not do CSE to the common part related to index ""i64 %i"". Lowering; // GEPs can achieve such goals.; // If the target does not use alias analysis in codegen, this pass will; // lower a GEP with multiple indices into arithmetic operations:; // BB1:; // %1 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = add i64 %1, %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = add i64 %3, %4; // %6 = add i64 %3, struct_field_3 ; Constant offset; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = add i64 %7, %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = add i64 %9, %10; // %12 = add i64 %11, struct_field_2 ; Constant offset; // %p = inttoptr i64 %12 to i32*; // load %p2; // ...; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:3790,load,load,3790,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,1,['load'],['load']
Performance,"8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +-----------------------+; //; // If we create live intervals for the variables above strictly based; // on the lifetime markers, we'll get the set of intervals on the; // left. If we ignore the lifetime start markers and instead treat a; // variable's lifetime as beginning with the first reference to the; // var, then we get the intervals on the right.; //; // LIFETIME_START First Use; // b1: [0,9] [3,4] [8,9]; // b2: [0,9] [6,9]; // b3: [2,4] [3,4]; // b4: [5,7] [6,7]; // b5: [5,7] [6,7]; //; // For the intervals on the left, the best we can do is overlap two; // variables (b3 and b4, for example); this gives us a stack size of; // 4*1024 bytes, not ideal. When treating first-use as the start of a; // lifetime, we can additionally overlap b1 and b5, giving us a 3*1024; // byte stack (better).; //; // Degenerate Slots:; // -----------------; //; // Relying entirely on first-use of stack slots is problematic,; // however, due to the fact that optimizations can sometimes migrate; // uses of a variable outside of its lifetime start/end region. Here; // is an example:; //; // int bar() {; // char b1[1024], b2[1024];; // if (...) {; // <uses of b2>; // return y;; // } else {; // <uses of b1>; // while (...) {; // char b3[1024];; // <uses of b3>; // }; // }; // }; //; // Before optimization, the control flow graph for the code above; // might look like the following:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------- block 2 -------+; // 2| <uses of b2> | 3| <uses of b1> |; // +-----------------------+ +-----------------------+; // | |; // | +------- block 3 -------+ <-\.; // | 4| <while condition> | |; // | +-----------------------+ |; // | / | |; // | / +------- block 4 -------+; // \ / 5| LIFETIME_START b3 | |; // \ / 6| <uses of b3> | |; // \ / 7| LIFETIME_END b3 | |; // \ | +---",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:7922,optimiz,optimizations,7922,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,1,['optimiz'],['optimizations']
Performance,": Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass searches for instructions that are prevented from being compressed; // by one of the following:; //; // 1. The use of a single uncompressed register.; // 2. A base register + offset where the offset is too large to be compressed; // and the base register may or may not be compressed.; //; //; // For case 1, if a compressed register is available, then the uncompressed; // register is copied to the compressed register and its uses are replaced.; //; // For example, storing zero uses the uncompressible zero register:; // sw zero, 0(a0) # if zero; // sw zero, 8(a0) # if zero; // sw zero, 4(a0) # if zero; // sw zero, 24(a0) # if zero; //; // If a compressed register (e.g. a1) is available, the above can be transformed; // to the following to improve code size:; // li a1, 0; // c.sw a1, 0(a0); // c.sw a1, 8(a0); // c.sw a1, 4(a0); // c.sw a1, 24(a0); //; //; // For case 2, if a compressed register is available, then the original base; // is copied and adjusted such that:; //; // new_base_register = base_register + adjustment; // base_register + large_offset = new_base_register + small_offset; //; // For example, the following offsets are too large for c.sw:; // lui a2, 983065; // sw a1, -236(a2); // sw a1, -240(a2); // sw a1, -244(a2); // sw a1, -248(a2); // sw a1, -252(a2); // sw a0, -256(a2); //; // If a compressed register is available (e.g. a3), a new base could be created; // such that the addresses can accessed with a compressible offset, thus; // improving code size:; // lui a2, 983065; // addi a3, a2, -256; // c.sw a1, 20(a3); // c.sw a1, 16(a3); // c.sw a1, 12(a3); // c.sw a1, 8(a3); // c.sw a1, 4(a3); // c.sw a0, 0(a3); //; //; // This optimization is only applied if there are enough uses of the copied; // register for code size to be reduced.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:2061,optimiz,optimization,2061,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,1,['optimiz'],['optimization']
Performance,"; *********/; /****f* libAfterImage/asimage/asimage_start(); * NAME; * asimage_start() Allocates memory needed to store scanline of the image ; * of supplied size. Assigns all the data members valid values. Makes sure ; * that ASImage structure is ready to store image data.; * SYNOPSIS; * void asimage_start (ASImage * im, unsigned int width,; * unsigned int height,; * unsigned int compression);; * INPUTS; * im - pointer to valid ASImage structure; * width - width of the image; * height - height of the image; * compression - level of compression to perform on image data.; * compression has to be in range of 0-100 with 100; * signifying highest level of compression.; * NOTES; * In order to resize ASImage structure after asimage_start() has been; * called, asimage_init() must be invoked to free all the memory, and; * then asimage_start() has to be called with new dimensions.; *********/; /****f* libAfterImage/asimage/create_asimage(); * NAME; * create_asimage() Performs memory allocation for the new ASImage ; * structure, as well as initialization of allocated structure based on ; * supplied parameters.; * SYNOPSIS; * ASImage *create_asimage( unsigned int width,; * unsigned int height,; * unsigned int compression);; * INPUTS; * width - desired image width; * height - desired image height; * compression - compression level in new ASImage( see asimage_start(); * for more ).; * RETURN VALUE; * Pointer to newly allocated and initialized ASImage structure on; * Success. NULL in case of any kind of error - that should never happen.; *********/; /****f* libAfterImage/asimage/clone_asimage(); * NAME ; * clone_asimage(); * SYNOPSIS; * ASImage *clone_asimage(ASImage *src, ASFlagType filter );; * INPUTS; * src - original ASImage.; * filter - bitmask of channels to be copied from one image to another.; * RETURN VALUE; * New ASImage, as a copy of original image.; * DESCRIPTION; * Creates exact clone of the original ASImage, with same compression,; * back_color and rest of the attrib",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h:1635,Perform,Performs,1635,graf2d/asimage/src/libAfterImage/asimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h,1,['Perform'],['Performs']
Performance,"; // Author: Rene Brun 07/01/95; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TClass; TClass instances represent classes, structs and namespaces in the ROOT type system. TClass instances are created starting from different sources of information:; 1. TStreamerInfo instances saved in a ROOT file which is opened. This is called in jargon an *emulated TClass*.; 2. From TProtoClass instances saved in a ROOT pcm file created by the dictionary generator and the dictionary itself.; 3. From a lookup in the AST built by cling. If a TClass instance is built through the mechanisms 1. and 2., it does not contain information about methods of the; class/struct/namespace it represents. Conversely, if built through 3. or 1., it does not carry the information which is necessary; to ROOT to perform I/O of instances of the class/struct it represents.; The mechanisms 1., 2. and 3. are not mutually exclusive: it can happen that during the execution of the program, all; the three are triggered, modifying the state of the TClass instance. In order to retrieve a TClass instance from the type system, a query can be executed as follows through the static; TClass::GetClass method:. ~~~ {.cpp}; auto myClassTClass_0 = TClass::GetClass(""myClass"");; auto myClassTClass_1 = TClass::GetClass<myClass>();; auto myClassTClass_2 = TClass::GetClass(myClassTypeInfo);; ~~~. The name of classes is crucial for ROOT. A careful procedure of *name normalization* is carried out for; each and every class. A *normalized name* is a valid C++ class name.; In order to access the name of a class within the ROOT type system, the method TClass::GetName() can be used.; */; //*-*x7.5 macros/layout_class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:1172,perform,perform,1172,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['perform'],['perform']
Performance,"; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing passes over SCCs of the call; /// graph. These passes form an important component of LLVM's interprocedural; /// optimizations. Because they operate on the SCCs of the call graph, and they; /// traverse the graph in post-order, they can effectively do pair-wise; /// interprocedural optimizations for all call edges in the program while; /// incrementally refining it and improving the context of these pair-wise; /// optimizations. At each call site edge, the callee has already been; /// optimized as much as is possible. This in turn allows very accurate; /// analysis of it for IPO.; ///; /// A secondary more general goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced into the call; /// graph by devirtualization or other technique, and thus ensures ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:1090,optimiz,optimization,1090,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,1,['optimiz'],['optimization']
Performance,"; // layout in the ""C-style"" case. Preferring larger fields tends to take; // better advantage of large gaps and may be more likely to have a size; // that's a multiple of a useful alignment. Preferring the initial; // order may help somewhat with locality but is mostly just a way of; // ensuring deterministic output.; //; // Note that this algorithm does not guarantee a minimal layout. Picking; // a larger object greedily may leave a gap that cannot be filled as; // efficiently. Unfortunately, solving this perfectly is an NP-complete; // problem (by reduction from bin-packing: let B_i be the bin sizes and; // O_j be the object sizes; add fixed-offset fields such that the gaps; // between them have size B_i, and add flexible-offset fields with; // alignment 1 and size O_j; if the layout size is equal to the end of; // the last fixed-layout field, the objects fit in the bins; note that; // this doesn't even require the complexity of alignment).; // The implementation below is essentially just an optimized version of; // scanning the list of remaining fields looking for the best, which; // would be O(n^2). In the worst case, it doesn't improve on that.; // However, in practice it'll just scan the array of alignment bins; // and consider the first few elements from one or two bins. The; // number of bins is bounded by a small constant: alignments are powers; // of two that are vanishingly unlikely to be over 64 and fairly unlikely; // to be over 8. And multiple elements only need to be considered when; // filling a gap between fixed-offset fields, which doesn't happen very; // often. We could use a data structure within bins that optimizes for; // finding the best-sized match, but it would require allocating memory; // and copying data, so it's unlikely to be worthwhile.; // Start by organizing the flexible-offset fields into bins according to; // their alignment. We expect a small enough number of bins that we; // don't care about the asymptotic costs of walking this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp:2786,optimiz,optimized,2786,interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp,2,['optimiz'],"['optimized', 'optimizes']"
Performance,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h:2136,perform,performed,2136,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h,4,['perform'],['performed']
Performance,"; // usage low.; //; // First the instructions are put into blocks.; // We want the blocks help control register usage and hide high latencies; // later. To help control register usage, we typically want all local; // computations, when for example you create a result that can be consumed; // right away, to be contained in a block. Block inputs and outputs would; // typically be important results that are needed in several locations of; // the shader. Since we do want blocks to help hide high latencies, we want; // the instructions inside the block to have a minimal set of dependencies; // on high latencies. It will make it easy to pick blocks to hide specific; // high latencies.; // The block creation algorithm is divided into several steps, and several; // variants can be tried during the scheduling process.; //; // Second the order of the instructions inside the blocks is chosen.; // At that step we do take into account only register usage and hiding; // low latency instructions; //; // Third the block order is chosen, there we try to hide high latencies; // and keep register usage low.; //; // After the third step, a pass is done to improve the hiding of low; // latencies.; //; // Actually when talking about 'low latency' or 'high latency' it includes; // both the latency to get the cache (or global mem) data go to the register,; // and the bandwidth limitations.; // Increasing the number of active wavefronts helps hide the former, but it; // doesn't solve the latter, thus why even if wavefront count is high, we have; // to try have as many instructions hiding high latencies as possible.; // The OpenCL doc says for example latency of 400 cycles for a global mem; // access, which is hidden by 10 instructions if the wavefront count is 10.; // Some figures taken from AMD docs:; // Both texture and constant L1 caches are 4-way associative with 64 bytes; // lines.; // Constant cache is shared with 4 CUs.; // For texture sampling, the address generation unit receives 4",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:3032,latency,latency,3032,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['latency'],['latency']
Performance,"; /// - String Table; /// - Function Info Data; ///; /// HEADER; ///; /// The header is fully described in ""llvm/DebugInfo/GSYM/Header.h"".; ///; /// ADDRESS TABLE; ///; /// The address table immediately follows the header in the file and consists; /// of Header.NumAddresses address offsets. These offsets are sorted and can be; /// binary searched for efficient lookups. Addresses in the address table are; /// stored as offsets from a 64 bit base address found in Header.BaseAddress.; /// This allows the address table to contain 8, 16, or 32 offsets. This allows; /// the address table to not require full 64 bit addresses for each address.; /// The resulting GSYM size is smaller and causes fewer pages to be touched; /// during address lookups when the address table is smaller. The size of the; /// address offsets in the address table is specified in the header in; /// Header.AddrOffSize. The first offset in the address table is aligned to; /// Header.AddrOffSize alignment to ensure efficient access when loaded into; /// memory.; ///; /// FUNCTION INFO OFFSETS TABLE; ///; /// The function info offsets table immediately follows the address table and; /// consists of Header.NumAddresses 32 bit file offsets: one for each address; /// in the address table. This data is aligned to a 4 byte boundary. The; /// offsets in this table are the relative offsets from the start offset of the; /// GSYM header and point to the function info data for each address in the; /// address table. Keeping this data separate from the address table helps to; /// reduce the number of pages that are touched when address lookups occur on a; /// GSYM file.; ///; /// FILE TABLE; ///; /// The file table immediately follows the function info offsets table. The; /// encoding of the FileTable is:; ///; /// struct FileTable {; /// uint32_t Count;; /// FileEntry Files[];; /// };; ///; /// The file table starts with a 32 bit count of the number of files that are; /// used in all of the function info, followed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h:2598,load,loaded,2598,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,1,['load'],['loaded']
Performance,"; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpistrm(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRM / PCMPISTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the result is zero-extended or expanded to 16; /// bytes. \n; /// 0: The result is zero-extended to 16 bytes. \n; /// 1: The result is expanded to 16 bytes (this expansion is performed by; /// repeating each bit 8 or 16 times).; /// \returns Returns a 128-bit integer vector representing the result mask of; /// the comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1673,perform,perform,1673,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,2,['perform'],"['perform', 'performed']"
Performance,"; /// in ModularFunctionMinimizer::Minimize and is used for direct function calls from that point on in the minimizer).; /// These can thus always be safely synced with this function's RooFit parameters using SetPdfParamVal.; /// - The values that arrive here via Gradient will be in internal coordinates if that is; /// what this class expects, and indeed this is the case for MinuitFcnGrad's current implementation. This is; /// communicated to Minuit via MinuitFcnGrad::returnsInMinuit2ParameterSpace. Inside Minuit, that function determines; /// whether this class's gradient calculator is wrapped inside a AnalyticalGradientCalculator, to which Minuit passes; /// ""external"" parameter values, or as an ExternalInternalGradientCalculator, which gets ""internal"" parameter values.; /// Long story short: when MinuitFcnGrad::returnsInMinuit2ParameterSpace() returns true, Minuit will pass ""internal""; /// values to Gradient. These cannot be synced with this function's RooFit parameters using; /// SetPdfParamVal, unless a manual transformation step is performed in advance. However, they do need to be passed; /// on to the gradient calculator, since indeed we expect values there to be in ""internal"" space. However, this is; /// calculator dependent. Note that in the current MinuitFcnGrad implementation we do not actually allow for; /// calculators in ""external"" (i.e. regular RooFit parameter space) values, since; /// MinuitFcnGrad::returnsInMinuit2ParameterSpace is hardcoded to true. This should in a future version be changed so; /// that the calculator (the wrapper) is queried for this information.; /// Because some gradient calculators may also use the regular RooFit parameters (e.g. for calculating the likelihood's; /// value itself), this information is also passed on to the gradient wrapper. Vice versa, when updated ""internal""; /// parameters are passed to Gradient, the likelihood may be affected as well. Even though a; /// transformation from internal to ""external"" may be nec",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/MinuitFcnGrad.cxx:1783,perform,performed,1783,roofit/roofitcore/src/TestStatistics/MinuitFcnGrad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/MinuitFcnGrad.cxx,1,['perform'],['performed']
Performance,"; ///; /// If 'option' contains the word 'fast' and nentries is -1, the; /// cloning will be done without unzipping or unstreaming the baskets; /// (i.e., a direct copy of the raw bytes on disk).; ///; /// When 'fast' is specified, 'option' can also contain a sorting; /// order for the baskets in the output file.; ///; /// There are currently 3 supported sorting order:; ///; /// - SortBasketsByOffset (the default); /// - SortBasketsByBranch; /// - SortBasketsByEntry; ///; /// When using SortBasketsByOffset the baskets are written in the; /// output file in the same order as in the original file (i.e. the; /// baskets are sorted by their offset in the original file; Usually; /// this also means that the baskets are sorted by the index/number of; /// the _last_ entry they contain); ///; /// When using SortBasketsByBranch all the baskets of each individual; /// branches are stored contiguously. This tends to optimize reading; /// speed when reading a small number (1->5) of branches, since all; /// their baskets will be clustered together instead of being spread; /// across the file. However it might decrease the performance when; /// reading more branches (or the full entry).; ///; /// When using SortBasketsByEntry the baskets with the lowest starting; /// entry are written first. (i.e. the baskets are sorted by the; /// index/number of the first entry they contain). This means that on; /// the file the baskets will be in the order in which they will be; /// needed when reading the whole tree sequentially.; ///; /// For examples of CloneTree, see tutorials:; ///; /// - copytree.C:; /// A macro to copy a subset of a TTree to a new TTree.; /// The input file has been generated by the program in; /// $ROOTSYS/test/Event with: Event 1000 1 1 1; ///; /// - copytree2.C:; /// A macro to copy a subset of a TTree to a new TTree.; /// One branch of the new Tree is written to a separate file.; /// The input file has been generated by the program in; /// $ROOTSYS/test/Event with: ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1935,optimiz,optimize,1935,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['optimiz'],['optimize']
Performance,"; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges globals with internal linkage into one. This way all the; // globals which were merged into a biggest one can be addressed using offsets; // from the same base pointer (no need for separate base pointer for each of the; // global). Such a transformation can significantly reduce the register pressure; // when many globals are involved.; //; // For example, consider the code which touches several global variables at; // once:; //; // static int foo[N], bar[N], baz[N];; //; // for (i = 0; i < N; ++i) {; // foo[i] = bar[i] * baz[i];; // }; //; // On ARM the addresses of 3 arrays should be kept in the registers, thus; // this code has quite large register pressure (loop body):; //; // ldr r1, [r5], #4; // ldr r2, [r6], #4; // mul r1, r2, r1; // str r1, [r0], #4; //; // Pass converts the code to something like:; //; // static struct {; // int foo[N];; // int bar[N];; // int baz[N];; // } merged;; //; // for (i = 0; i < N; ++i) {; // merged.foo[i] = merged.bar[i] * merged.baz[i];; // }; //; // and in ARM code this becomes:; //; // ldr r0, [r5, #40]; // ldr r1, [r5, #80]; // mul r0, r1, r0; // str r0, [r5], #4; //; // note that we saved 2 registers here almostly ""for free"".; //; // However, merging globals can have tradeoffs:; // - it confuses debuggers, tools, and users; // - it makes linker optimizations less useful (order files, LOHs, ...); // - it forces usage of indexed addressing (which isn't necessarily ""free""); // - it can increase register pressure when the uses are disparate enough.; //; // We use heuristics to discover the best global grouping we can (cf cl::opts).; //; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:1706,optimiz,optimizations,1706,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,1,['optimiz'],['optimizations']
Performance,"; TUnfoldDensity instead of TUnfoldSys. TUnfoldDensity adds; features to TUnfoldSys, related to possible complex multidimensional; arrangements of bins. For innocent; users, the most notable improvement of TUnfoldDensity over TUnfoldSys are; the getter functions. For TUnfoldSys, histograms have to be booked by the; user and the getter functions fill the histogram bins. TUnfoldDensity; simply returns a new, already filled histogram.</b>. If you use this software, please consider the following citation. <b>S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]</b>. Detailed documentation and updates are available on; http://www.desy.de/~sschmitt. Brief recipy to use TUnfoldSys:; <ul>; <li>a matrix (truth,reconstructed) is given as a two-dimensional histogram; as argument to the constructor of TUnfold</li>; <li>a vector of measurements is given as one-dimensional histogram using; the SetInput() method</li>; <li>repeated calls to SubtractBackground() to specify background; sources</li>; <li>repeated calls to AddSysError() to specify systematic uncertainties; <li>The unfolding is performed; <ul>; <li>either once with a fixed parameter tau, method DoUnfold(tau)</li>; <li>or multiple times in a scan to determine the best chouce of tau,; method ScanLCurve()</li>; </ul>; <li>Unfolding results are retrieved using various GetXXX() methods; </ul>. Description of (systematic) uncertainties available in; TUnfoldSys. There are covariance matrix contributions and there are; systematic shifts. Systematic shifts correspond to the variation of a; (buicance) parameter, for example a background normalisation or a; one-sigma variation of a correlated systematic error.; <table>; <tr><th> </th><th>Set by</th>; <th>Access covariance matrix</th>; <th>Access vector of shifts</th>; <th>Description</th>; </tr>; <tr>; <td>(a)</td><td>TUnfoldSys constructor</td>; <td>GetEmatrixSysUncorr()</td><td> n.a. </td>; <td>uncorrelated errors on the input matrix histA, taken as the errors; provided with the his",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx:2929,perform,performed,2929,hist/unfold/src/TUnfoldSys.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx,1,['perform'],['performed']
Performance,"; \f[; c_1\cdot\mathrm{PDF}_1 + c_2\cdot\mathrm{PDF}_2 \; + \; ... \; + \; \left( 1-\sum_{i=1}^{n-1}c_i \right) \cdot \mathrm{PDF}_n; \f]. The first form is for extended likelihood fits, where the; expected number of events is \f$ \sum_i c_i \f$. The coefficients \f$ c_i \f$; can either be explicitly provided, or, if all components support; extended likelihood fits, they can be calculated from the contribution; of each PDF to the total expected number of events. In the second form, the sum of the coefficients is required to be 1 or less,; and the coefficient of the last PDF is calculated automatically from the condition; that the sum of all coefficients has to be 1. ### Recursive coefficients; It is also possible to parameterise the coefficients recursively. \f[; \sum_{i=1}^n c_i \prod_{j=1}^{i-1} \left[ (1-c_j) \right] \cdot \mathrm{PDF}_i \\; = c_1 \cdot \mathrm{PDF}_1 + (1-c_1)\, c_2 \cdot \mathrm{PDF}_2 + \ldots + (1-c_1)\ldots(1-c_{n-1}) \cdot 1 \cdot \mathrm{PDF}_n \\; \f]. In this form the sum of the coefficients is always less than 1.0; for all possible values of the individual coefficients between 0 and 1.; \note Don't pass the \f$ n^\mathrm{th} \f$ coefficient. It is always 1, since the normalisation condition removes one degree of freedom. RooAddPdf relies on each component PDF to be normalized and will perform; no normalization other than calculating the proper last coefficient \f$ c_n \f$, if requested.; An (enforced) condition for this assumption is that each \f$ \mathrm{PDF}_i \f$ is independent of each \f$ c_i \f$. ## Difference between RooAddPdf / RooRealSumFunc / RooRealSumPdf; - RooAddPdf is a PDF of PDFs, *i.e.* its components need to be normalised and non-negative.; - RooRealSumPdf is a PDF of functions, *i.e.*, its components can be negative, but their sum cannot be. The normalisation; is computed automatically, unless the PDF is extended (see above).; - RooRealSumFunc is a sum of functions. It is neither normalised, nor need it be positive. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx:2262,perform,perform,2262,roofit/roofitcore/src/RooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx,1,['perform'],['perform']
Performance,"; first call. So the only effect of the flush parameter in this implementation; is on the return value of inflate(), as noted below, or when it returns early; because Z_BLOCK is used. If a preset dictionary is needed after this call (see inflateSetDictionary; below), inflate sets strm->adler to the adler32 checksum of the dictionary; chosen by the compressor and returns Z_NEED_DICT; otherwise it sets; strm->adler to the adler32 checksum of all output produced so far (that is,; total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described; below. At the end of the stream, inflate() checks that its computed adler32; checksum is equal to that saved by the compressor and returns Z_STREAM_END; only if the checksum is correct. inflate() will decompress and check either zlib-wrapped or gzip-wrapped; deflate data. The header type is detected automatically. Any information; contained in the gzip header is not retained, so applications that need that; information should instead use raw inflate, see inflateInit2() below, or; inflateBack() and perform their own processing of the gzip header and; trailer. inflate() returns Z_OK if some progress has been made (more input processed; or more output produced), Z_STREAM_END if the end of the compressed data has; been reached and all uncompressed output has been produced, Z_NEED_DICT if a; preset dictionary is needed at this point, Z_DATA_ERROR if the input data was; corrupted (input stream not conforming to the zlib format or incorrect check; value), Z_STREAM_ERROR if the stream structure was inconsistent (for example; if next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,; Z_BUF_ERROR if no progress is possible or if there was not enough room in the; output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and; inflate() can be called again with more input and more output space to; continue decompressing. If Z_DATA_ERROR is returned, the application may then; call inflateSync() t",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:4650,perform,perform,4650,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['perform'],['perform']
Performance,"==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file implements relative lookup table converter that converts; /// lookup tables to relative lookup tables to make them PIC-friendly.; ///; /// Switch lookup table example:; /// @switch.table.foo = private unnamed_addr constant [3 x i8*]; /// [; /// i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i64 0, i64 0),; /// i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i64 0, i64 0),; /// i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0); /// ], align 8; ///; /// switch.lookup:; /// %1 = sext i32 %cond to i64; /// %switch.gep = getelementptr inbounds [3 x i8*],; /// [3 x i8*]* @switch.table.foo, i64 0, i64 %1; /// %switch.load = load i8*, i8** %switch.gep, align 8; /// ret i8* %switch.load; ///; /// Switch lookup table will become a relative lookup table that; /// consists of relative offsets.; ///; /// @reltable.foo = private unnamed_addr constant [3 x i32]; /// [; /// i32 trunc (i64 sub (i64 ptrtoint ([5 x i8]* @.str to i64),; /// i64 ptrtoint ([3 x i32]* @reltable.foo to i64)) to i32),; /// i32 trunc (i64 sub (i64 ptrtoint ([4 x i8]* @.str.1 to i64),; /// i64 ptrtoint ([3 x i32]* @reltable.foo to i64)) to i32),; /// i32 trunc (i64 sub (i64 ptrtoint ([4 x i8]* @.str.2 to i64),; /// i64 ptrtoint ([3 x i32]* @reltable.foo to i64)) to i32); /// ], align 4; ///; /// IR after converting to a relative lookup table:; /// switch.lookup:; /// %1 = sext i32 %cond to i64; /// %reltable.shift = shl i64 %1, 2; /// %reltable.intrinsic = call i8* @llvm.load.relative.i64(; /// i8* bitcast ([3 x i32]* @reltable.foo to i8*),; /// i64 %reltable.shift); /// ret i8* %reltable.intrinsic; //===---------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/RelLookupTableConverter.h:1061,load,load,1061,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/RelLookupTableConverter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/RelLookupTableConverter.h,2,['load'],['load']
Performance,">BookMethod( ""MethodCFMlpANN"", OptionsString ); *; * *; * where: *; * TString OptionsString = ""n_training_cycles:n_hidden_layers"" *; * *; * default is: n_training_cycles = 5000, n_layers = 4 *; * note that the number of hidden layers in the NN is *; * *; * n_hidden_layers = n_layers - 2 *; * *; * since there is one input and one output layer. The number of *; * nodes (neurons) is predefined to be *; * *; * n_nodes[i] = nvars + 1 - i (where i=1..n_layers) *; * *; * with nvars being the number of variables used in the NN. *; * Hence, the default case is: n_neurons(layer 1 (input)) : nvars *; * n_neurons(layer 2 (hidden)): nvars-1 *; * n_neurons(layer 3 (hidden)): nvars-1 *; * n_neurons(layer 4 (out)) : 2 *; * *; * This artificial neural network usually needs a relatively large *; * number of cycles to converge (8000 and more). Overtraining can *; * be efficiently tested by comparing the signal and background *; * output of the NN for the events that were used for training and *; * an independent data sample (with equal properties). If the separation *; * performance is significantly better for the training sample, the *; * NN interprets statistical effects, and is hence overtrained. In *; * this case, the number of cycles should be reduced, or the size *; * of the training sample increased. *; * *; * Authors (alphabetical): *; * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; * Xavier Prudent <prudent@lapp.in2p3.fr> - LAPP, France *; * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; * *; * Copyright (c) 2005: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * LAPP, Annecy, France *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; * *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodCFMlpANN.h:2081,perform,performance,2081,tmva/tmva/inc/TMVA/MethodCFMlpANN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodCFMlpANN.h,1,['perform'],['performance']
Performance,"?; /// - Swizzle enable: SH_STATIC_MEM_CONFIG.SWIZZLE_ENABLE (must be 1 for; /// scratch); /// - Num records: Flat Scratch Work Item Size / Element Size (???); /// - Dst_sel_*: ???; /// - Num_format: ???; /// - Element_size: SH_STATIC_MEM_CONFIG.ELEMENT_SIZE (will be DWORD, must; /// agree with amd_kernel_code_t.privateElementSize); /// - Index_stride: SH_STATIC_MEM_CONFIG.INDEX_STRIDE (will be 64 as must; /// be number of wavefront lanes for scratch, must agree with; /// amd_kernel_code_t.wavefrontSize); /// - Add tid enable: 1; /// - ATC: from SH_MEM_CONFIG.PRIVATE_ATC,; /// - Hash_enable: ???; /// - Heap: ???; /// - Mtype: from SH_STATIC_MEM_CONFIG.PRIVATE_MTYPE; /// - Type: 0 (a buffer) (???); ///; /// Dispatch Ptr (enable_sgpr_dispatch_ptr):; /// Number of User SGPR registers: 2. 64 bit address of AQL dispatch packet; /// for kernel actually executing.; ///; /// Queue Ptr (enable_sgpr_queue_ptr):; /// Number of User SGPR registers: 2. 64 bit address of AmdQueue object for; /// AQL queue on which the dispatch packet was queued.; ///; /// Kernarg Segment Ptr (enable_sgpr_kernarg_segment_ptr):; /// Number of User SGPR registers: 2. 64 bit address of Kernarg segment. This; /// is directly copied from the kernargPtr in the dispatch packet. Having CP; /// load it once avoids loading it at the beginning of every wavefront.; ///; /// Dispatch Id (enable_sgpr_dispatch_id):; /// Number of User SGPR registers: 2. 64 bit Dispatch ID of the dispatch; /// packet being executed.; ///; /// Flat Scratch Init (enable_sgpr_flat_scratch_init):; /// Number of User SGPR registers: 2. This is 2 SGPRs.; ///; /// For CI/VI:; /// The first SGPR is a 32 bit byte offset from SH_MEM_HIDDEN_PRIVATE_BASE; /// to base of memory for scratch for this dispatch. This is the same offset; /// used in computing the Scratch Segment Buffer base address. The value of; /// Scratch Wave Offset must be added by the kernel code and moved to; /// SGPRn-4 for use as the FLAT SCRATCH BASE in flat memory instr",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:2939,queue,queue,2939,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,2,['queue'],"['queue', 'queued']"
Performance,"Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // BasicBlockSections implementation.; //; // The purpose of this pass is to assign sections to basic blocks when; // -fbasic-block-sections= option is used. Further, with profile information; // only the subset of basic blocks with profiles are placed in separate sections; // and the rest are grouped in a cold section. The exception handling blocks are; // treated specially to ensure they are all in one seciton.; //; // Basic Block Sections; // ====================; //; // With option, -fbasic-block-sections=list, every function may be split into; // clusters of basic blocks. Every cluster will be emitted into a separate; // section with its basic blocks sequenced in the given order. To get the; // optimized performance, the clusters must form an optimal BB layout for the; // function. We insert a symbol at the beginning of every cluster's section to; // allow the linker to reorder the sections in any arbitrary sequence. A global; // order of these sections would encapsulate the function layout.; // For example, consider the following clusters for a function foo (consisting; // of 6 basic blocks 0, 1, ..., 5).; //; // 0 2; // 1 3 5; //; // * Basic blocks 0 and 2 are placed in one section with symbol `foo`; // referencing the beginning of this section.; // * Basic blocks 1, 3, 5 are placed in a separate section. A new symbol; // `foo.__part.1` will reference the beginning of this section.; // * Basic block 4 (note that it is not referenced in the list) is placed in; // one section, and a new symbol `foo.cold` will point to it.; //; // There are a couple of challenges to be addressed:; //; // 1. The last basic block of every cluster should not have any implicit; // fallthrough to its next basic block, as it can be re",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:1089,optimiz,optimized,1089,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,2,"['optimiz', 'perform']","['optimized', 'performance']"
Performance,"B}^{-1}\mathbf{a})\,.\f$. The original model \f$\mathsf{F}\mathbf{c}\f$ is therefore identical with; this if; \f[; \mathbf{c} = \left(\mathsf{B}^{-1}\mathbf{a}\right) =; \left[\mathbf{a}^T\left(\mathsf{B}^{-1}\right)^T\right]^T\,.; \f]; The reason we use \f$\left(\mathsf{B}^{-1}\right)^T\f$ rather then; \f$\mathsf{B}^{-1}\f$ is to save storage, since \f$\left(\mathsf{B}^{-1}\right)^T\f$; can be stored in the same matrix as \f$\mathsf{B}\f$ (TMultiDimFit::MakeCoefficients).; The errors in the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions \f$ f_{lj}\f$ [1] (TMultiDimFit::MakeCoefficientErrors). ## Considerations; It's important to realize that the training sample should be; representative of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a *interpolation*, rather then a *extrapolation* [5]. Also, the independent variables \f$ x_{i}\f$ need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables \f$ \xi_{i}\f$ to a set of linear independent variables; \f$ x_{i}\f$, using a *Principal Components Analysis* (see TPrincipal), and; then use the transformed variable as input to this class [5] [6]. H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):. 1. Define \f$\mathbf{P} = (P_1, \ldots, P_5)\f$ are the 5 dependent; quantities that define a track.; 2. Compute, for \f$ M\f$ different values of \f$\mathbf{P}\f$, the tracks; through the magnetic field, and determine the corresponding; \f$\mathbf{x} = (x_1, \ldots, x_N)\f$.; 3. Use the simulated observations to determine, with a simple; approximation, the values of \f$\mathbf{P}_j\f$. We call these values; \f$\mathbf{P}^\prime_j, j = 1, ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:13985,perform,perform,13985,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['perform'],['perform']
Performance,"Frame; with the main tree:. ~~~{.cpp}; TTree main([...]);; TTree friend([...]);; main.AddFriend(&friend, ""myFriend"");. RDataFrame df(main);; auto df2 = df.Filter(""myFriend.MyCol == 42"");; ~~~. The same applies for TChains. Columns coming from the friend trees can be referred to by their full name, like in the example above,; or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of; ""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree). \note A common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their; entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original; one: rows will be mismatched. Indexed friend trees provide a way to perform simple joins of multiple trees over a common column.; When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the; ""index"" columns have a value identical to the one in the main one. For example, in Python:. ~~~{.py}; main_tree = ...; aux_tree = ... # If a friend tree has an index on `commonColumn`, when the main tree loads; # a given row, it also loads the row of the friend tree that has the same; # value of `commonColumn`; aux_tree.BuildIndex(""commonColumn""). mainTree.AddFriend(aux_tree). df = ROOT.RDataFrame(mainTree); ~~~. RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode. \anchor other-file-formats; ### Reading data formats other than ROOT trees; RDataFrame can be interfaced with RDataSources. The ROOT::RDF::RDataSource interface defines an API that RDataFrame can use to read arbitrary columnar data formats. RDataFrame calls into concrete RDataSource implementations to retrieve information about the data, retrieve (thread-local) readers or ""cursors"" for selected columns; and to advance the readers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:73241,load,loaded,73241,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,2,['load'],"['load', 'loaded']"
Performance,"In other words, within a slot, computation runs sequentially and events are processed sequentially.; Note that the same slot might be associated to different threads over the course of a single event loop, but two threads; will never receive the same slot at the same time.; This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different; processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot(). ### Parallel execution of multiple RDataFrame event loops; A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");. // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop. // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ~~~. ### Performance considerations. To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:50775,concurren,concurrently,50775,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['concurren'],['concurrently']
Performance,"LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The file implements ""cache-aware"" layout algorithms of basic blocks and; // functions in a binary.; //; // The algorithm tries to find a layout of nodes (basic blocks) of a given CFG; // optimizing jump locality and thus processor I-cache utilization. This is; // achieved via increasing the number of fall-through jumps and co-locating; // frequently executed nodes together. The name follows the underlying; // optimization problem, Extended-TSP, which is a generalization of classical; // (maximum) Traveling Salesmen Problem.; //; // The algorithm is a greedy heuristic that works with chains (ordered lists); // of basic blocks. Initially all chains are isolated basic blocks. On every; // iteration, we pick a pair of chains whose merging yields the biggest increase; // in the ExtTSP score, which models how i-cache ""friendly"" a specific chain is.; // A pair of chains giving the maximum gain is merged into a new chain. The; // procedure stops when there is only one chain left, or when merging does not; // increase ExtTSP. In the latter case, the remaining chains are sorted by; // density in the decreasing order.; //; // An important aspect is the way two chains are merged. Unlike earlier; // algorithms (e.g., based on the approach of Pettis-Hansen), two; // chains, X and Y, are first split into three, X1, X2, and Y. Then we; // consider all possible ways of gluing the three chains (e.g., X1YX2, X1X2Y,; // X2X1Y, X2YX1, YX1X2, YX2X1) and choose the one producing the largest score.; // This improves the quality of the final result (the search space is larger); // while keeping the implementation sufficiently fast.; //; // Reference:; // * A. Newell and S. Pupyrev, Improved Basic Block Reordering,; // IEEE Transactions on Computers, 2020; // http",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:1200,cache,cache,1200,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,1,['cache'],['cache']
Performance,"LTO prelink,; // every call edge originated from the callee B will be transferred to; // the caller A. If any transferred edge (say A->C) is indirect, the; // original profiled indirect edge B->C, even if considered, would not; // enforce a top-down order from the caller A to the potential indirect; // call target C in LTO postlink since the inlined callee B is gone from; // the static call graph.; // 4. #3 can happen even for direct call targets, due to functions defined; // in header files. A header function (say A), when included into source; // files, is defined multiple times but only one definition survives due; // to ODR. Therefore, the LTO prelink inlining done on those dropped; // definitions can be useless based on a local file scope. More; // importantly, the inlinee (say B), once fully inlined to a; // to-be-dropped A, will have no profile to consume when its outlined; // version is compiled. This can lead to a profile-less prelink; // compilation for the outlined version of B which may be called from; // external modules. while this isn't easy to fix, we rely on the; // postlink AutoFDO pipeline to optimize B. Since the survived copy of; // the A can be inlined in its local scope in prelink, it may not exist; // in the merged IR in postlink, and we'll need the profiled call edges; // to enforce a top-down order for the rest of the functions.; //; // Considering those cases, a profiled call graph completely independent of; // the static call graph is constructed based on profile data, where; // function objects are not even needed to handle case #3 and case 4.; //; // Note that static callgraph edges are completely ignored since they; // can be conflicting with profiled edges for cyclic SCCs and may result in; // an SCC order incompatible with profile-defined one. Using strictly; // profile order ensures a maximum inlining experience. On the other hand,; // static call edges are not so important when they don't correspond to a; // context in the profile.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:2094,optimiz,optimize,2094,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['optimiz'],['optimize']
Performance,"MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1, true); //<<< add branch1 and branch2 to the cache; T->AddBranchToCache(b2, true); //<<<; T->StopCacheLearningPhase(); //<<< we do not need the system to guess anything; for (auto i : TSeqL(nentries)) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; ... Here the entry is processed; }; ~~~; #### Always using at least the same two branches. In this example, two branches are always used: in addition, some analysis; functions are invoked and those may trigger the reading of other branches which; are a priori not known.; There is no point in prefetching branches that will be used very rarely: we can; rely on the system to cache the right branches.; ~~~ {.cpp}; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; for (auto i : TSeqL(nentries)) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; // At this point we may call a user function where a few more branches; // will be read conditionally. These branches will be put in the cache; // if they have been used in the first 10 entries; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... Here the en",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:9965,cache,cache,9965,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"OOT::RDF::SaveGraph(df);; ~~~. The generated graph can be rendered using one of the graphviz filters, e.g. `dot`. For instance, the image below can be generated with the following command:; ~~~{.sh}; $ dot -Tpng computation_graph.dot -ocomputation_graph.png; ~~~. \image html RDF_Graph2.png. \anchor rdf-logging; ### Activating RDataFrame execution logs. RDataFrame has experimental support for verbose logging of the event loop runtimes and other interesting related information. It is activated as follows:; ~~~{.cpp}; #include <ROOT/RLogger.hxx>. // this increases RDF's verbosity level as long as the `verbosity` variable is in scope; auto verbosity = ROOT::Experimental::RLogScopedVerbosity(ROOT::Detail::RDF::RDFLogChannel(), ROOT::Experimental::ELogLevel::kInfo);; ~~~. or in Python:; ~~~{.python}; import ROOT. verbosity = ROOT.Experimental.RLogScopedVerbosity(ROOT.Detail.RDF.RDFLogChannel(), ROOT.Experimental.ELogLevel.kInfo); ~~~. More information (e.g. start and end of each multi-thread task) is printed using `ELogLevel.kDebug` and even more; (e.g. a full dump of the generated code that RDataFrame just-in-time-compiles) using `ELogLevel.kDebug+10`. \anchor rdf-from-spec; ### Creating an RDataFrame from a dataset specification file. RDataFrame can be created using a dataset specification JSON file: . ~~~{.python}; import ROOT. df = ROOT.RDF.Experimental.FromSpec(""spec.json""); ~~~. The input dataset specification JSON file needs to be provided by the user and it describes all necessary samples and; their associated metadata information. The main required key is the ""samples"" (at least one sample is needed) and the; required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each; sample in the ""metadata"" key. A simple example for the formatting of the specification in the JSON file is the following:. ~~~{.cpp}; {; ""samples"": {; ""sampleA"": {; ""trees"": [""tree1"", ""tree2""],; ""files"": [""file1.root"", ""file2.root""],; ""met",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:77675,multi-thread,multi-thread,77675,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['multi-thread'],['multi-thread']
Performance,"OT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; /// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; ///; /// The default fitting of an histogram (when no option is given) is perfomed as following:; /// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1::Fit`):; /// - `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm.; /// For example `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; /// The current defaults are (""Minuit"",""Migrad"").; /// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; /// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:4642,perform,performed,4642,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['perform'],['performed']
Performance,"P with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias analysis in codegen).; // Such transformation can have following benefits:; // (1) It can always extract constants in the indices of structure type.; // (2) After such Lowering, there are more optimization opportunities such as; // CSE, LICM and CGP.; //; // E.g. The following GEPs have multiple indices:; // BB1:; // %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3; // load %p; // ...; // BB2:; // %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2; // load %p2; // ...; //; // We can not do CSE to the common part related to index ""i64 %i"". Lowering; // GEPs can achieve such goals.; // If the target does not use alias analysis in codegen, this pass will; // lower a GEP with multiple indices into arithmetic operations:; // BB1:; // %1 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = add i64 %1, %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = add i64 %3, %4; // %6 = add i64 %3, struct_field_3 ; Constant offset; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = add i64 %7, %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = add i64 %9, %10; // %12 = add i64 %11, struct_field_2 ; Constant offset; // %p = inttoptr i64 %12 to i32*; // load %p2; // ...; //; // If the target uses alias analysis in codegen, this pass will lower a GEP; // with multiple indices into multiple GEPs with a single index:; // BB1:; // %1 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = getelementptr i8* %1, i64 %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = getelementptr i8* %3, i6",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:4388,load,load,4388,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,1,['load'],['load']
Performance,"Partitioning.h ---------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements BalancedPartitioning, a recursive balanced graph; // partitioning algorithm.; //; // The algorithm is used to find an ordering of FunctionNodes while optimizing; // a specified objective. The algorithm uses recursive bisection; it starts; // with a collection of unordered FunctionNodes and tries to split them into; // two sets (buckets) of equal cardinality. Each bisection step is comprised of; // iterations that greedily swap the FunctionNodes between the two buckets while; // there is an improvement of the objective. Once the process converges, the; // problem is divided into two sub-problems of half the size, which are; // recursively applied for the two buckets. The final ordering of the; // FunctionNodes is obtained by concatenating the two (recursively computed); // orderings.; //; // In order to speed up the computation, we limit the depth of the recursive; // tree by a specified constant (SplitDepth) and apply at most a constant; // number of greedy iterations per split (IterationsPerSplit). The worst-case; // time complexity of the implementation is bounded by O(M*log^2 N), where; // N is the number of FunctionNodes and M is the number of; // FunctionNode-UtilityNode edges; (assuming that any collection of D; // FunctionNodes contains O(D) UtilityNodes). Notice that the two different; // recursive sub-problems are independent and thus can be efficiently processed; // in parallel.; //; // Reference:; // * Optimizing Function Layout for Mobile Applications,; // https://arxiv.org/abs/2211.09285; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h:1841,Optimiz,Optimizing,1841,interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,1,['Optimiz'],['Optimizing']
Performance,"Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file implements relative lookup table converter that converts; /// lookup tables to relative lookup tables to make them PIC-friendly.; ///; /// Switch lookup table example:; /// @switch.table.foo = private unnamed_addr constant [3 x i8*]; /// [; /// i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i64 0, i64 0),; /// i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i64 0, i64 0),; /// i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0); /// ], align 8; ///; /// switch.lookup:; /// %1 = sext i32 %cond to i64; /// %switch.gep = getelementptr inbounds [3 x i8*],; /// [3 x i8*]* @switch.table.foo, i64 0, i64 %1; /// %switch.load = load i8*, i8** %switch.gep, align 8; /// ret i8* %switch.load; ///; /// Switch lookup table will become a relative lookup table that; /// consists of relative offsets.; ///; /// @reltable.foo = private unnamed_addr constant [3 x i32]; /// [; /// i32 trunc (i64 sub (i64 ptrtoint ([5 x i8]* @.str to i64),; /// i64 ptrtoint ([3 x i32]* @reltable.foo to i64)) to i32),; /// i32 trunc (i64 sub (i64 ptrtoint ([4 x i8]* @.str.1 to i64),; /// i64 ptrtoint ([3 x i32]* @reltable.foo to i64)) to i32),; /// i32 trunc (i64 sub (i64 ptrtoint ([4 x i8]* @.str.2 to i64),; /// i64 ptrtoint ([3 x i32]* @reltable.foo to i64)) to i32); /// ], align 4; ///; /// IR after converting to a relative lookup table:; /// switch.lookup:; /// %1 = sext i32 %cond to i64; /// %reltable.shift = shl i64 %1, 2; /// %reltable.intrinsic = call i8* @llvm.load.relative.i64(; /// i8* bitcast ([3 x i32]* @reltable.foo to i8*),; /// i64 %reltable.shift); /// ret i8* %reltable.intrinsic; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/RelLookupTableConverter.h:1125,load,load,1125,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/RelLookupTableConverter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/RelLookupTableConverter.h,2,['load'],['load']
Performance,"R""(//auto-generated test macro; #include <RooFit/Detail/MathFuncs.h>; #include <Math/CladDerivator.h>. #pragma cling optimize(2); )""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFuncWrapper.cxx:117,optimiz,optimize,117,roofit/roofitcore/src/RooFuncWrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFuncWrapper.cxx,1,['optimiz'],['optimize']
Performance,"R""(usage: stressRooFit [ options ]. -b <mode> : Perform every fit in the tests with the EvalBackend(<mode>) command argument, where <mode> is a string; -f <file> : use given reference file instead of default (""stressRooFit_ref.root""); -w : write reference file, instead of reading file and running comparison tests. -n N : Only run test with sequential number N instead of full suite of tests; -c : dump file stressRooFit_DEBUG.root to which results of both current result and reference for each failed test are written; -mc : memory check mode, no regression test are performed. Set this flag when running with valgrind; -min <name> : minimizer name (default is Minuit, not Minuit2); -vs : Use vector-based storage for all datasets (default is tree-based storage); -v/-vv : set verbose mode (show result of each regression test) or very verbose mode (show all roofit output as well); -q : quiet mode where errors are not logged; -d N : set ROOT gDebug flag to N; )""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit.cxx:48,Perform,Perform,48,roofit/roofitcore/test/stressRooFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit.cxx,2,"['Perform', 'perform']","['Perform', 'performed']"
Performance,"R""(usage: stressRooStats [ options ]. -b <mode> : Perform every fit in the tests with the EvalBackend(<mode>) command argument, where <mode> is a string; -f <file> : use given reference file instead of default (""stressRooStats_ref.root""); -w : write reference file, instead of reading file and running comparison tests; -n N : only run test with sequential number N; -a : run full suite of tests (default is basic suite); this overrides the -n single test option; -c : dump file stressRooStats_DEBUG.root to which results of both current result and reference for each failed test are written; -mc : memory check mode, no regression test are performed. Set this flag when running with valgrind; -min <name> : minimizer name (default is Minuit, not Minuit2); -vs : use vector-based storage for all datasets (default is tree-based storage); -v/-vv : set verbose mode (show result of each regression test) or very verbose mode (show all roofit output as well); -d N : set ROOT gDebug flag to N; )""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/stressRooStats.cxx:50,Perform,Perform,50,roofit/roostats/test/stressRooStats.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/stressRooStats.cxx,2,"['Perform', 'perform']","['Perform', 'performed']"
Performance,"R""CODE(#ifdef __CLING__; #pragma cling optimize(0); #endif; )CODE""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TCanvas.cxx:39,optimiz,optimize,39,graf2d/gpad/src/TCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TCanvas.cxx,1,['optimiz'],['optimize']
Performance,"R""CODE(::Process(Long64_t entry); {; // The Process() function is called for each entry in the tree (or possibly; // keyed object in the case of PROOF) to be processed. The entry argument; // specifies which entry in the currently loaded tree is to be processed.; // When processing keyed objects with PROOF, the object is already loaded; // and is available via the fObject pointer.; //; // This function should contain the \""body\"" of the analysis. It can contain; // simple or elaborate selection criteria, run algorithms on the data; // of the event and typically fill histograms.; //; // The processing can be stopped by calling Abort().; //; // Use fStatus to set the return value of TTree::Process().; //; // The return value is currently not used. fReader.SetLocalEntry(entry);. return true;; }. void )CODE""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderGenerator.cxx:231,load,loaded,231,tree/treeplayer/src/TTreeReaderGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderGenerator.cxx,2,['load'],['loaded']
Performance,"R_AND_OBJ; // in unified shared memory mode or for local pointers; // p, &p[1], 24*sizeof(float), TARGET_PARAM | TO | FROM; //; // map((*a)[0:3]); // &(*a), &(*a), sizeof(pointer), TARGET_PARAM | TO | FROM; // &(*a), &(*a)[0], 3*sizeof(int), PTR_AND_OBJ | TO | FROM; //; // map(**a); // &(*a), &(*a), sizeof(pointer), TARGET_PARAM | TO | FROM; // &(*a), &(**a), sizeof(int), PTR_AND_OBJ | TO | FROM; //; // map(s); // &s, &s, sizeof(S2), TARGET_PARAM | TO | FROM; //; // map(s.i); // &s, &(s.i), sizeof(int), TARGET_PARAM | TO | FROM; //; // map(s.s.f); // &s, &(s.s.f[0]), 50*sizeof(float), TARGET_PARAM | TO | FROM; //; // map(s.p); // &s, &(s.p), sizeof(double*), TARGET_PARAM | TO | FROM; //; // map(to: s.p[:22]); // &s, &(s.p), sizeof(double*), TARGET_PARAM (*); // &s, &(s.p), sizeof(double*), MEMBER_OF(1) (**); // &(s.p), &(s.p[0]), 22*sizeof(double),; // MEMBER_OF(1) | PTR_AND_OBJ | TO (***); // (*) alloc space for struct members, only this is a target parameter; // (**) map the pointer (nothing to be mapped in this example) (the compiler; // optimizes this entry out, same in the examples below); // (***) map the pointee (map: to); //; // map(to: s.ref); // &s, &(s.ref), sizeof(int*), TARGET_PARAM (*); // &s, &(s.ref), sizeof(int), MEMBER_OF(1) | PTR_AND_OBJ | TO (***); // (*) alloc space for struct members, only this is a target parameter; // (**) map the pointer (nothing to be mapped in this example) (the compiler; // optimizes this entry out, same in the examples below); // (***) map the pointee (map: to); //; // map(s.ps); // &s, &(s.ps), sizeof(S2*), TARGET_PARAM | TO | FROM; //; // map(from: s.ps->s.i); // &s, &(s.ps), sizeof(S2*), TARGET_PARAM; // &s, &(s.ps), sizeof(S2*), MEMBER_OF(1); // &(s.ps), &(s.ps->s.i), sizeof(int), MEMBER_OF(1) | PTR_AND_OBJ | FROM; //; // map(to: s.ps->ps); // &s, &(s.ps), sizeof(S2*), TARGET_PARAM; // &s, &(s.ps), sizeof(S2*), MEMBER_OF(1); // &(s.ps), &(s.ps->ps), sizeof(S2*), MEMBER_OF(1) | PTR_AND_OBJ | TO; //; // map(s.ps->ps->p",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:1939,optimiz,optimizes,1939,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['optimiz'],['optimizes']
Performance,"Removing these edges may break cycles that form this RefSCC and; /// thus this operation may change the RefSCC graph significantly. In; /// particular, this operation will re-form new RefSCCs based on the; /// remaining connectivity of the graph. The following invariants are; /// guaranteed to hold after calling this method:; ///; /// 1) If a ref-cycle remains after removal, it leaves this RefSCC intact; /// and in the graph. No new RefSCCs are built.; /// 2) Otherwise, this RefSCC will be dead after this call and no longer in; /// the graph or the postorder traversal of the call graph. Any iterator; /// pointing at this RefSCC will become invalid.; /// 3) All newly formed RefSCCs will be returned and the order of the; /// RefSCCs returned will be a valid postorder traversal of the new; /// RefSCCs.; /// 4) No RefSCC other than this RefSCC has its member set changed (this is; /// inherent in the definition of removing such an edge).; ///; /// These invariants are very important to ensure that we can build; /// optimization pipelines on top of the CGSCC pass manager which; /// intelligently update the RefSCC graph without invalidating other parts; /// of the RefSCC graph.; ///; /// Note that we provide no routine to remove a *call* edge. Instead, you; /// must first switch it to a ref edge using \c switchInternalEdgeToRef.; /// This split API is intentional as each of these two steps can invalidate; /// a different aspect of the graph structure and needs to have the; /// invalidation handled independently.; ///; /// The runtime complexity of this method is, in the worst case, O(V+E); /// where V is the number of nodes in this RefSCC and E is the number of; /// edges leaving the nodes in this RefSCC. Note that E includes both edges; /// within this RefSCC and edges from this RefSCC to child RefSCCs. Some; /// effort has been made to minimize the overhead of common cases such as; /// self-edges and edge removals which result in a spanning tree with no; /// more cycles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1186,optimiz,optimization,1186,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,1,['optimiz'],['optimization']
Performance,"SEL; // aren't speculated. When conditional branch direction gets miss-speculated,; // the semantics of the inserted CSEL instruction is such that the taint; // register will contain all zero bits.; // One key requirement for this to work is that the conditional branch is; // followed by an execution of the CSEL instruction, where the CSEL; // instruction needs to use the same flags status as the conditional branch.; // This means that the conditional branches must not be implemented as one; // of the AArch64 conditional branches that do not use the flags as input; // (CB(N)Z and TB(N)Z). This is implemented by ensuring in the instruction; // selectors to not produce these instructions when speculation hardening; // is enabled. This pass will assert if it does encounter such an instruction.; // - On function call boundaries, the miss-speculation state is transferred from; // the taint register X16 to be encoded in the SP register as value 0.; //; // For the aspect of automatically hardening loads, using the taint register,; // (a.k.a. speculative load hardening, see; // https://llvm.org/docs/SpeculativeLoadHardening.html), the following; // implementation choices are made for AArch64:; // - Many of the optimizations described at; // https://llvm.org/docs/SpeculativeLoadHardening.html to harden fewer; // loads haven't been implemented yet - but for some of them there are; // FIXMEs in the code.; // - loads that load into general purpose (X or W) registers get hardened by; // masking the loaded data. For loads that load into other registers, the; // address loaded from gets hardened. It is expected that hardening the; // loaded data may be more efficient; but masking data in registers other; // than X or W is not easy and may result in being slower than just; // hardening the X address register loaded from.; // - On AArch64, CSDB instructions are inserted between the masking of the; // register and its first use, to ensure there's no non-control-flow; // speculation th",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:4038,load,loads,4038,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,1,['load'],['loads']
Performance,"SOFTWARE (""SOFTWARE""),; YOU UNEQUIVOCALLY ACCEPT, AND AGREE TO BE BOUND BY, ALL OF THE; TERMS AND CONDITIONS OF THIS AGREEMENT.; IF YOU DO NOT AGREE, DO NOT DOWNLOAD, INSTALL, COPY, DISTRIBUTE OR USE; THE DATA FILES OR SOFTWARE. COPYRIGHT AND PERMISSION NOTICE. Copyright © 1991-2022 Unicode, Inc. All rights reserved.; Distributed under the Terms of Use in https://www.unicode.org/copyright.html. Permission is hereby granted, free of charge, to any person obtaining; a copy of the Unicode data files and any associated documentation; (the ""Data Files"") or Unicode software and any associated documentation; (the ""Software"") to deal in the Data Files or Software; without restriction, including without limitation the rights to use,; copy, modify, merge, publish, distribute, and/or sell copies of; the Data Files or Software, and to permit persons to whom the Data Files; or Software are furnished to do so, provided that either; (a) this copyright and permission notice appear with all copies; of the Data Files or Software, or; (b) this copyright and permission notice appear in associated; Documentation. THE DATA FILES AND SOFTWARE ARE PROVIDED ""AS IS"", WITHOUT WARRANTY OF; ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE; WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; NONINFRINGEMENT OF THIRD PARTY RIGHTS.; IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS; NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL; DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,; DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER; TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR; PERFORMANCE OF THE DATA FILES OR SOFTWARE. Except as contained in this notice, the name of a copyright holder; shall not be used in advertising or otherwise to promote the sale,; use or other dealings in these Data Files or Software without prior; written authorization of the copyright holder.; */; )""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/UnicodeData/UnicodeNameMappingGenerator.cpp:2052,PERFORM,PERFORMANCE,2052,interpreter/llvm-project/llvm/utils/UnicodeData/UnicodeNameMappingGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/UnicodeData/UnicodeNameMappingGenerator.cpp,1,['PERFORM'],['PERFORMANCE']
Performance,"Selector has the following member functions:; ///; /// - Begin(): called every time a loop on the tree starts,; /// a convenient place to create your histograms.; /// - SlaveBegin(): called after Begin(), when on PROOF called only on the; /// slave servers.; /// - Process(): called for each event, in this function you decide what; /// to read and fill your histograms.; /// - SlaveTerminate: called at the end of the loop on the tree, when on PROOF; /// called only on the slave servers.; /// - Terminate(): called at the end of the loop on the tree,; /// a convenient place to draw/fit your histograms.; ///; /// If filename is of the form file.C, the file will be interpreted.; /// If filename is of the form file.C++, the file file.C will be compiled; /// and dynamically loaded.; ///; /// If filename is of the form file.C+, the file file.C will be compiled; /// and dynamically loaded. At next call, if file.C is older than file.o; /// and file.so, the file.C is not compiled, only file.so is loaded.; ///; /// ### NOTE 1; /// It may be more interesting to invoke directly the other Process function; /// accepting a TSelector* as argument.eg; /// ~~~{.cpp}; /// MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; /// selector->CallSomeFunction(..);; /// mytree.Process(selector,..);; /// ~~~; /// ### NOTE 2; /// One should not call this function twice with the same selector file; /// in the same script. If this is required, proceed as indicated in NOTE1,; /// by getting a pointer to the corresponding TSelector,eg; ///#### workaround 1; /// ~~~{.cpp}; ///void stubs1() {; /// TSelector *selector = TSelector::GetSelector(""h1test.C"");; /// TFile *f1 = new TFile(""stubs_nood_le1.root"");; /// TTree *h1 = (TTree*)f1->Get(""h1"");; /// h1->Process(selector);; /// TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; /// TTree *h2 = (TTree*)f2->Get(""h1"");; /// h2->Process(selector);; ///}; /// ~~~; /// or use ACLIC to compile the selector; ///#### workaround 2; /// ~~~{.c",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx:1431,load,loaded,1431,tree/treeplayer/src/TTreePlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx,1,['load'],['loaded']
Performance,"SlotEntry() for more information. |; | Vary() | Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). |. ### Actions; Actions aggregate data into a result. Each one is described in more detail in the reference guide. In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters. Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to; produce many different results in one event loop. Instant actions trigger the event loop instantly. | **Lazy action** | **Description** |; |------------------|-----------------|; | Aggregate() | Execute a user-defined accumulation operation on the processed column values. |; | Book() | Book execution of a custom action using a user-defined helper object. |; | Cache() | Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). |; | Count() | Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. |; | Display() | Provides a printable representation of the dataset contents. The method returns a ROOT::RDF::RDisplay() instance which can print a tabular representation of the data or return it as a string. |; | Fill() | Fill a user-defined object with the values of the specified columns, as if by calling `Obj.Fill(col1, col2, ...)`. |; | Graph() | Fills a TGraph with the two columns provided. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | GraphAsymmErrors() | Fills a TGraphAsymmErrors. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | Histo1D(), Histo2D(), Histo3D() | Fill a one-,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:6316,cache,cached,6316,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,2,['cache'],['cached']
Performance,"Source; \ingroup dataframe; \brief RDataSource defines an API that RDataFrame can use to read arbitrary data formats. A concrete RDataSource implementation (i.e. a class that inherits from RDataSource and implements all of its pure; methods) provides an adaptor that RDataFrame can leverage to read any kind of tabular data formats.; RDataFrame calls into RDataSource to retrieve information about the data, retrieve (thread-local) readers or ""cursors""; for selected columns and to advance the readers to the desired data entry. The sequence of calls that RDataFrame (or any other client of a RDataSource) performs is the following:. - SetNSlots() : inform RDataSource of the desired level of parallelism; - GetColumnReaders() : retrieve from RDataSource per-thread readers for the desired columns; - Initialize() : inform RDataSource that an event-loop is about to start; - GetEntryRanges() : retrieve from RDataSource a set of ranges of entries that can be processed concurrently; - InitSlot() : inform RDataSource that a certain thread is about to start working on a certain range of entries; - SetEntry() : inform RDataSource that a certain thread is about to start working on a certain entry; - FinalizeSlot() : inform RDataSource that a certain thread finished working on a certain range of entries; - Finalize() : inform RDataSource that an event-loop finished. RDataSource implementations must support running multiple event-loops consecutively (although sequentially) on the same dataset.; - \b SetNSlots() is called once per RDataSource object, typically when it is associated to a RDataFrame.; - \b GetColumnReaders() can be called several times, potentially with the same arguments, also in-between event-loops, but not during an event-loop.; - \b GetEntryRanges() will be called several times, including during an event loop, as additional ranges are needed. It will not be called concurrently.; - \b Initialize() and \b Finalize() are called once per event-loop, right before starting an",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx:1018,concurren,concurrently,1018,tree/dataframe/inc/ROOT/RDataSource.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx,1,['concurren'],['concurrently']
Performance,"TChain or TEventList have influence on the behaviour of the cache:. - Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. - Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning phase is started or restarted when:; - TTree automatically creates a cache.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTreeCache::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; - TTreeCache::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries.; - A 'cached' TChain switches over to a new file. \anchor cachemisses; ## Self-optimization in presence of cache misses. The TTreeCache can optimize its behavior on a cache miss. When; miss optimization is enabled (see the SetOptimizeMisses method),; it tracks all branches utilized after the learning phase which caused a cache; miss.; When one cache miss occurs, all the utilized branches are be prefetched; for that event. This optimization utilizes the observation that infrequently; accessed branches are often accessed together.; An example scenario where such behavior is desirable, is an analysis where; a set of collections are read only for a few events in which a certain; condition is respected, e.g. a trigger fired. ### Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase; by at most a factor two in the case of cache miss.; Additionally, on the first miss of an event, we must iterate through all the; ""active branches"" f",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:4669,cache,cached,4669,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cached']
Performance,"TIME_START First Use; // b1: [0,9] [3,4] [8,9]; // b2: [0,9] [6,9]; // b3: [2,4] [3,4]; // b4: [5,7] [6,7]; // b5: [5,7] [6,7]; //; // For the intervals on the left, the best we can do is overlap two; // variables (b3 and b4, for example); this gives us a stack size of; // 4*1024 bytes, not ideal. When treating first-use as the start of a; // lifetime, we can additionally overlap b1 and b5, giving us a 3*1024; // byte stack (better).; //; // Degenerate Slots:; // -----------------; //; // Relying entirely on first-use of stack slots is problematic,; // however, due to the fact that optimizations can sometimes migrate; // uses of a variable outside of its lifetime start/end region. Here; // is an example:; //; // int bar() {; // char b1[1024], b2[1024];; // if (...) {; // <uses of b2>; // return y;; // } else {; // <uses of b1>; // while (...) {; // char b3[1024];; // <uses of b3>; // }; // }; // }; //; // Before optimization, the control flow graph for the code above; // might look like the following:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------- block 2 -------+; // 2| <uses of b2> | 3| <uses of b1> |; // +-----------------------+ +-----------------------+; // | |; // | +------- block 3 -------+ <-\.; // | 4| <while condition> | |; // | +-----------------------+ |; // | / | |; // | / +------- block 4 -------+; // \ / 5| LIFETIME_START b3 | |; // \ / 6| <uses of b3> | |; // \ / 7| LIFETIME_END b3 | |; // \ | +------------------------+ |; // \ | \ /; // +------ block 5 -----+ \---------------; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +---------------------+; //; // During optimization, however, it can happen that an instruction; // computing an address in ""b3"" (for example, a loop-invariant GEP) is; // hoisted up out of the loop from block 4 to block 2. [Note that; // this is not an actual load from the stack, o",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:8259,optimiz,optimization,8259,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,1,['optimiz'],['optimization']
Performance,"Trunc->visitUnknown(%X),; // and call this function with %SymbolicPHI = %X.; //; // The analysis will find that the value coming around the backedge has; // the following SCEV:; // BEValue = ((sext i32 (trunc i64 %X to i32) to i64) + %Step); // Upon concluding that this matches the desired pattern, the function; // will return the pair {NewAddRec, SmallPredsVec} where:; // NewAddRec = {%Start,+,%Step}; // SmallPredsVec = {P1, P2, P3} as follows:; // P1(WrapPred): AR: {trunc(%Start),+,(trunc %Step)}<nsw> Flags: <nssw>; // P2(EqualPred): %Start == (sext i32 (trunc i64 %Start to i32) to i64); // P3(EqualPred): %Step == (sext i32 (trunc i64 %Step to i32) to i64); // The returned pair means that SymbolicPHI can be rewritten into NewAddRec; // under the predicates {P1,P2,P3}.; // This predicated rewrite will be cached in PredicatedSCEVRewrites:; // PredicatedSCEVRewrites[{%X,L}] = {NewAddRec, {P1,P2,P3)}; //; // TODO's:; //; // 1) Extend the Induction descriptor to also support inductions that involve; // casts: When needed (namely, when we are called in the context of the; // vectorizer induction analysis), a Set of cast instructions will be; // populated by this method, and provided back to isInductionPHI. This is; // needed to allow the vectorizer to properly record them to be ignored by; // the cost model and to avoid vectorizing them (otherwise these casts,; // which are redundant under the runtime overflow checks, will be; // vectorized, which can be costly).; //; // 2) Support additional induction/PHISCEV patterns: We also want to support; // inductions where the sext-trunc / zext-trunc operations (partly) occur; // after the induction update operation (the induction increment):; //; // (Trunc iy (SExt/ZExt ix (%SymbolicPHI + InvariantAccum) to iy) to ix); // which correspond to a phi->add->trunc->sext/zext->phi update chain.; //; // (Trunc iy ((SExt/ZExt ix (%SymbolicPhi) to iy) + InvariantAccum) to ix); // which correspond to a phi->trunc->add->sext/zext->phi upda",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1519,cache,cached,1519,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['cache'],['cached']
Performance,"UGLY HACK:; * This inline assembly hack forces acc into a normal register. This is the; * only thing that prevents GCC and Clang from autovectorizing the XXH32; * loop (pragmas and attributes don't work for some resason) without globally; * disabling SSE4.1.; *; * The reason we want to avoid vectorization is because despite working on; * 4 integers at a time, there are multiple factors slowing XXH32 down on; * SSE4:; * - There's a ridiculous amount of lag from pmulld (10 cycles of latency on; * newer chips!) making it slightly slower to multiply four integers at; * once compared to four integers independently. Even when pmulld was; * fastest, Sandy/Ivy Bridge, it is still not worth it to go into SSE; * just to multiply unless doing a long operation.; *; * - Four instructions are required to rotate,; * movqda tmp, v // not required with VEX encoding; * pslld tmp, 13 // tmp <<= 13; * psrld v, 19 // x >>= 19; * por v, tmp // x |= tmp; * compared to one for scalar:; * roll v, 13 // reliably fast across the board; * shldl v, v, 13 // Sandy Bridge and later prefer this for some reason; *; * - Instruction level parallelism is actually more beneficial here because; * the SIMD actually serializes this operation: While v1 is rotating, v2; * can load data, while v3 can multiply. SSE forces them to operate; * together.; *; * How this hack works:; * __asm__("""" // Declare an assembly block but don't declare any instructions; * : // However, as an Input/Output Operand,; * ""+r"" // constrain a read/write operand (+) as a general purpose register (r).; * (acc) // and set acc as the operand; * );; *; * Because of the 'r', the compiler has promised that seed will be in a; * general purpose register and the '+' says that it will be 'read/write',; * so it has to assume it has changed. It is like volatile without all the; * loads and stores.; *; * Since the argument has to be in a normal register (not an SSE register),; * each time XXH32_round is called, it is impossible to vectorize.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:1261,load,load,1261,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,['load'],"['load', 'loads']"
Performance,"\param[in] columnName The column to be aggregated. If omitted, the first default column is used instead.; /// \param[in] aggIdentity The aggregator variable of each thread is initialized to this value (or is default-constructed if the parameter is omitted); /// \return the result of the aggregation wrapped in a RResultPtr.; ///; /// An aggregator callable takes two values, an aggregator variable and a column value. The aggregator variable is; /// initialized to aggIdentity or default-constructed if aggIdentity is omitted.; /// This action calls the aggregator callable for each processed entry, passing in the aggregator variable and; /// the value of the column columnName.; /// If the signature is `U(U,T)` the aggregator variable is then copy-assigned the result of the execution of the callable.; /// Otherwise the signature of aggregator must be `void(U&,T)`.; ///; /// The merger callable is used to merge the partial accumulation results of each processing thread. It is only called in multi-thread executions.; /// If its signature is `U(U,U)` the aggregator variables of each thread are merged two by two.; /// If its signature is `void(std::vector<U>& a)` it is assumed that it merges all aggregators in a[0].; ///; /// This action is *lazy*: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr.; ///; /// Example usage:; /// ~~~{.cpp}; /// auto aggregator = [](double acc, double x) { return acc * x; };; /// ROOT::EnableImplicitMT();; /// // If multithread is enabled, the aggregator function will be called by more threads; /// // and will produce a vector of partial accumulators.; /// // The merger function performs the final aggregation of these partial results.; /// auto merger = [](std::vector<double> &accumulators) {; /// for (auto i : ROOT::TSeqU(1u, accumulators.size())) {; /// accumulators[0] *= accumulators[i];; /// }; /// };; ///; /// // The accumulator is initialized at this value by every thread.; /// double initValue ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1827,multi-thread,multi-thread,1827,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['multi-thread'],['multi-thread']
Performance,"______________________________________________; //; // The main motivation for the XML format is to facilitate the; // communication with other non ROOT applications. Currently; // writing and reading XML files is limited to ROOT applications.; // It is our intention to develop a simple reader independent; // of the ROOT libraries that could be used as an example for; // real applications. One of possible approach with code generation; // is implemented in TXMLPlayer class.; //; // The XML format should be used only for small data volumes,; // typically histogram files, pictures, geometries, calibrations.; // The XML file is built in memory before being dumped to disk.; //; // Like for normal ROOT files, XML files use the same I/O mechanism; // exploiting the ROOT/CINT dictionary. Any class having a dictionary; // can be saved in XML format.; //; // This first implementation does not support subdirectories; // or Trees.; //; // The shared library libRXML.so may be loaded dynamically; // via gSystem->Load(""libRXML""). This library is automatically; // loaded by the plugin manager as soon as a XML file is created; // via, eg; // TFile::Open(""file.xml"",""recreate"");; // TFile::Open returns a TXMLFile object. When a XML file is open in write mode,; // one can use the normal TObject::Write to write an object in the file.; // Alternatively one can use the new functions TDirectoryFile::WriteObject and; // TDirectoryFile::WriteObjectAny to write a TObject* or any class not deriving; // from TObject.; //; // example of a session saving a histogram to a XML file; // =====================================================; // TFile *f = TFile::Open(""Example.xml"",""recreate"");; // TH1F *h = new TH1F(""h"",""test"",1000,-2,2);; // h->FillRandom(""gaus"");; // h->Write();; // delete f;; //; // example of a session reading the histogram from the file; // ========================================================; // TFile *f = TFile::Open(""Example.xml"");; // TH1F *h = (TH1F*)f->Get(""h"");; // h",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/xml/src/TXMLFile.cxx:1477,load,loaded,1477,io/xml/src/TXMLFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/xml/src/TXMLFile.cxx,2,"['Load', 'load']","['Load', 'loaded']"
Performance,"_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6; /// %32 = load i16, i16* %30; /// %33 = load i16, i16* %31; /// %34 = call i16 @llvm.bswap.i16(i16 %32); /// %35 = call i16 @llvm.bswap.i16(i16 %33); /// %36 = zext i16 %34 to i64; /// %37 = zext i16 %35 to i64; /// %38 = sub i64 %36, %37; /// %39 = icmp ne i64 %38, 0; /// br i1 %39, label %res_block, label %loadbb3; /// loadbb3: ; preds = %loadbb2; /// %40 = bitcast i32* %buffer2 to i8*; /// %41 = bitcast i32* %buffer1 to i8*; /// %42 = getelementptr i8, i8* %41, i8 14; /// %43 = getelementptr i8, i8* %40, i8 14; /// %44 = load i8, i8* %42; /// %45 = load i8, i8* %43; /// %46 = zext i8 %44 to i32; /// %47 = zext i8 %45 to i32; /// %48 = sub i32 %46, %47; /// br label %endblock; /// endblock: ; preds = %res_block,; /// %loadbb3; /// %phi.res = phi i32 [ %48, %loadbb3 ], [ %11, %res_block ]; /// ret i32 ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:2013,load,load,2013,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,2,['load'],['load']
Performance,"_global__ and __shared__). Knowing the space of a memory access allows; // CUDA compilers to emit faster PTX loads and stores. For example, a load from; // shared memory can be translated to `ld.shared` which is roughly 10% faster; // than a generic `ld` on an NVIDIA Tesla K40c.; //; // Unfortunately, type qualifiers only apply to variable declarations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published i",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:1583,load,load,1583,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,1,['load'],['load']
Performance,"a build.ninja file. Suppose you have a header file that's autogenerated by (for example) Tablegen.; If a C++ compilation step needs to include that header, then it must be; executed after the Tablegen build step that generates the header. So the; dependency graph in build.ninja should have the Tablegen build step as an; ancestor of the C++ one. If it does not, then there's a latent build-failure; bug, because depending on the order that ninja chooses to schedule its build; steps, the C++ build step could run first, and fail because the header it needs; does not exist yet. But because that kind of bug can easily be latent or intermittent, you might; not notice, if your local test build happens to succeed. What you'd like is a; way to detect problems of this kind reliably, even if they _didn't_ cause a; failure on your first test. This script tries to do that. It's specific to the 'ninja' build tool, because; ninja has useful auxiliary output modes that produce the necessary data:. - 'ninja -t graph' emits the full DAG of formal dependencies derived from; build.ninja (in Graphviz format). - 'ninja -t deps' dumps the database of dependencies discovered at build time; by finding out which headers each source file actually included. By cross-checking these two sources of data against each other, you can find; true dependencies shown by 'deps' that are not reflected as formal dependencies; in 'graph', i.e. a generated header that is required by a given source file but; not forced to be built first. To run it:. - set up a build directory using ninja as the build tool (cmake -G Ninja). - in that build directory, run ninja to perform an actual build (populating; the dependency database). - then, in the same build directory, run this script. No arguments are needed; (but -C and -f are accepted, and propagated to ninja for convenience). Requirements outside core Python: the 'pygraphviz' module, available via pip or; as the 'python3-pygraphviz' package in Debian and Ubuntu. """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/check_ninja_deps.py:1694,perform,perform,1694,interpreter/llvm-project/llvm/utils/check_ninja_deps.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/check_ninja_deps.py,1,['perform'],['perform']
Performance,"a new IR instruction sequence.; /// We want to transform:; /// %call = call signext i32 @memcmp(i8* %0, i8* %1, i64 15); /// To:; /// loadbb:; /// %0 = bitcast i32* %buffer2 to i8*; /// %1 = bitcast i32* %buffer1 to i8*; /// %2 = bitcast i8* %1 to i64*; /// %3 = bitcast i8* %0 to i64*; /// %4 = load i64, i64* %2; /// %5 = load i64, i64* %3; /// %6 = call i64 @llvm.bswap.i64(i64 %4); /// %7 = call i64 @llvm.bswap.i64(i64 %5); /// %8 = sub i64 %6, %7; /// %9 = icmp ne i64 %8, 0; /// br i1 %9, label %res_block, label %loadbb1; /// res_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6; /// %32 = load i16, i16* %30; /// %33 = load i16, i16* %31; /// %34 = call i16 @llvm.bswap.i16(i16 %32); /// %35 = call i16 @llvm.bswap.i16(i16 %33); /// %36 = zext i16 %34 to i64; /// %37 = zext i16 %35 to i64; /// %38 = sub i64 %36, %37; /// %39 = icmp ne i64 %38, 0; /// br ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:1159,load,loadbb,1159,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,3,['load'],"['load', 'loadbb']"
Performance,"a v4i32; // into the lower half of a v8i16, in the same way that a NEON vmovn would.; // Most of the instructions in MVE follow the 'Beats' system, where moving; // values from different lanes is usually something that the instructions; // avoid.; //; // Instead it has top/bottom instructions such as VMOVLT/B and VMOVNT/B,; // which take a the top/bottom half of a larger lane and extend it (or do the; // opposite, truncating into the top/bottom lane from a larger lane). Note; // that because of the way we widen lanes, a v4i16 is really a v4i32 using the; // bottom 16bits from each vector lane. This works really well with T/B; // instructions, but that doesn't extend to v8i32->v8i16 where the lanes need; // to move order.; //; // But truncates and sext/zext are always going to be fairly common from llvm.; // We have several options for how to deal with them:; // - Wherever possible combine them into an instruction that makes them; // ""free"". This includes loads/stores, which can perform the trunc as part; // of the memory operation. Or certain shuffles that can be turned into; // VMOVN/VMOVL.; // - Lane Interleaving to transform blocks surrounded by ext/trunc. So; // trunc(mul(sext(a), sext(b))) may become; // VMOVNT(VMUL(VMOVLB(a), VMOVLB(b)), VMUL(VMOVLT(a), VMOVLT(b))). (Which in; // this case can use VMULL). This is performed in the; // MVELaneInterleavingPass.; // - Otherwise we have an option. By default we would expand the; // zext/sext/trunc into a series of lane extract/inserts going via GPR; // registers. One for each vector lane in the vector. This can obviously be; // very expensive.; // - The other option is to use the fact that loads/store can extend/truncate; // to turn a trunc into two truncating stack stores and a stack reload. This; // becomes 3 back-to-back memory operations, but at least that is less than; // all the insert/extracts.; //; // In order to do the last, we convert certain trunc's into MVETRUNC, which; // are either optimized where they",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:1040,load,loads,1040,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,"['load', 'perform']","['loads', 'perform']"
Performance,"aFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");. // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop. // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ~~~. ### Performance considerations. To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; should be preferred for performance-critical applications. Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case. Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs. Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:51963,perform,performance-critical,51963,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['perform'],['performance-critical']
Performance,"able outside of its lifetime start/end region. Here; // is an example:; //; // int bar() {; // char b1[1024], b2[1024];; // if (...) {; // <uses of b2>; // return y;; // } else {; // <uses of b1>; // while (...) {; // char b3[1024];; // <uses of b3>; // }; // }; // }; //; // Before optimization, the control flow graph for the code above; // might look like the following:; //; // +------ block 0 -------+; // 0| LIFETIME_START b1, b2 |; // 1| <test 'if' condition> |; // +-----------------------+; // ./ \.; // +------ block 1 -------+ +------- block 2 -------+; // 2| <uses of b2> | 3| <uses of b1> |; // +-----------------------+ +-----------------------+; // | |; // | +------- block 3 -------+ <-\.; // | 4| <while condition> | |; // | +-----------------------+ |; // | / | |; // | / +------- block 4 -------+; // \ / 5| LIFETIME_START b3 | |; // \ / 6| <uses of b3> | |; // \ / 7| LIFETIME_END b3 | |; // \ | +------------------------+ |; // \ | \ /; // +------ block 5 -----+ \---------------; // 8| <cleanupcode> |; // 9| LIFETIME_END b1, b2 |; // 10| return |; // +---------------------+; //; // During optimization, however, it can happen that an instruction; // computing an address in ""b3"" (for example, a loop-invariant GEP) is; // hoisted up out of the loop from block 4 to block 2. [Note that; // this is not an actual load from the stack, only an instruction that; // computes the address to be loaded]. If this happens, there is now a; // path leading from the first use of b3 to the return instruction; // that does not encounter the b3 LIFETIME_END, hence b3's lifetime is; // now larger than if we were computing live intervals strictly based; // on lifetime markers. In the example above, this lengthened lifetime; // would mean that it would appear illegal to overlap b3 with b2.; //; // To deal with this such cases, the code in ::collectMarkers() below; // tries to identify ""degenerate"" slots -- those slots where on a single; // forward pass through the CFG we encounter a f",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:9089,optimiz,optimization,9089,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,1,['optimiz'],['optimization']
Performance,"ache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file adds DWARF discriminators to the IR. Path discriminators are; // used to decide what CFG path was taken inside sub-graphs whose instructions; // share the same line and column number information.; //; // The main user of this is the sample profiler. Instruction samples are; // mapped to line number information. Since a single line may be spread; // out over several basic blocks, discriminators add more precise location; // for the samples.; //; // For example,; //; // 1 #define ASSERT(P); // 2 if (!(P)); // 3 abort(); // ...; // 100 while (true) {; // 101 ASSERT (sum < 0);; // 102 ...; // 130 }; //; // when converted to IR, this snippet looks something like:; //; // while.body: ; preds = %entry, %if.end; // %0 = load i32* %sum, align 4, !dbg !15; // %cmp = icmp slt i32 %0, 0, !dbg !15; // br i1 %cmp, label %if.end, label %if.then, !dbg !15; //; // if.then: ; preds = %while.body; // call void @abort(), !dbg !15; // br label %if.end, !dbg !15; //; // Notice that all the instructions in blocks 'while.body' and 'if.then'; // have exactly the same debug information. When this program is sampled; // at runtime, the profiler will assume that all these instructions are; // equally frequent. This, in turn, will consider the edge while.body->if.then; // to be frequently taken (which is incorrect).; //; // By adding a discriminator value to the instructions in block 'if.then',; // we can distinguish instructions at line 101 with discriminator 0 from; // the instructions at line 101 with discriminator 1.; //; // For more details about DWARF discriminators, please visit; // http://wiki.dwarfstd.org/index.php?title=Path_Discriminators; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:1115,load,load,1115,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,1,['load'],['load']
Performance,"ache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. ### Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all; entries such that not all branch buffers are read. \anchor description; ## General Description; This class acts as a file cache, registering automatically the baskets from; the branches being processed via direct manipulation of TTrees or with tools; such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame; when in the learning phase. The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. The usage of a TTreeCache can considerably improve the runtime performance at; the price of a modest investment in memory, in particular when the TTree is; accessed remotely, e.g. via a high latency network. For each TTree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted.; The user can change the size of the cache with the TTree::SetCacheSize method; (by default the size is 30 Megabytes). This feature can be controlled with the; environment variable `ROOT_TTREECACHE_SIZE` or the TTreeCache.Size option.; The entry range for which the cache is active can also be set with the; SetEntryRange method. \anchor changesbehaviour; ## Changes of behavior when using TChain and TEventList. The usage of TChain or TEventList have influence on the behaviour of the cache:. - Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. - Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning phase is started or restarted when:; - TTree a",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:3088,latency,latency,3088,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['latency'],['latency']
Performance,"ache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %s.sink = phi [%st, if.then], [%se, if.else]; // <...>; // store %s.sink, %addr_s; // <...>; //; //; //===----------------------- TODO -----------------------------------------===//; //; /",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1252,perform,performs,1252,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,2,"['load', 'perform']","['load', 'performs']"
Performance,"ack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point were not true, the decision on whether to; /// perform a tail call is done in LowerCallTo in SelectionDAG (or; /// CallLowering in GlobalISel) which occurs after the Stack Protector; /// Pass. As a result, one would need to put the relevant callinst into the; /// stack protector check success basic block (where the return inst is; /// placed) and then move it back later at ISel/MI time before the; /// stack protector check if the tail call optimization failed. The MI; /// level option was nixed immediately since it would require; /// platform-specific pattern matching. The ISel level option was; /// nixed because SelectionDAG only processes one IR level basic block at a; /// time implying one could not create a DAG Combine to move the callinst.; ///; /// To get around this problem:; ///; /// 1. SelectionDAG can only process one block at a time, we can generate; /// multiple machine basic blocks for one IR level basic block.; /// This is how we handle bit tests and switches.; ///; /// 2. At the MI level, tail calls are represented via a special return; /// MIInst cal",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:2045,perform,perform,2045,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,1,['perform'],['perform']
Performance,"activity is included (see ascompose.c); *; * 9. Image reference counting; *; * USES; * libAfterBase - AfterStep basic functionality library. That Includes; * Hash tables, file search methods, message output, generic types.; * However effort has been made to allow for standalone configuration as; * well. If libAfterBase is not found at compilation time - libAfterImage; * will use extract from libAfterBase included with libAfterImage.; *; * SEE ALSO; * Examples; * API Reference; *; * TODO; * Implement support for Targa and PCX image format and maybe some other; * formats as well.; *; * Implement complete support for I18N internationalization.; *; * Implement color<->pixel conversion for all colordepths.; *; * AUTHOR; * Sasha Vasko <sasha at aftercode dot net>; *********/; /****h* libAfterImage/Examples; * EXAMPLE; * ASView - image loading from the file and displaying in window.; * ASScale - image loading from file and scaling to arbitrary size.; * ASTile - image loading from file, tiling and tinting to arbitrary; * size and color.; * ASMerge - imgae loading and merging with another image.; * ASGrad - mutlipoint gradient drawing.; * ASFlip - image loading from file and rotation.; * ASText - trexturized semitransparent antialised text drawing.; *; * SEE ALSO; * API Reference; ******/; /****h* libAfterImage/API Reference; * CHILDREN; * Headers :; * ascmap.h asfont.h asimage.h asvisual.h blender.h export.h; * import.h transform.h ximage.h; * Structures :; * ColorPair; * ASScanline; * ASVisual; * ASImage; * ASImageManager; * ASImageBevel; * ASImageDecoder; * ASImageOutput; * ASImageLayer; * ASGradient; * ASFontManager; * ASFont; * ASGlyph; * ASGlyphRange; * ASColormap; * ASImageExportParams; * ASVectorPalette; *; * Functions :; * ASScanline handling:; * 	 prepare_scanline(), free_scanline(); *; * ASVisual initialization :; * 	 query_screen_visual(), setup_truecolor_visual(),; * 	 setup_pseudo_visual(), setup_as_colormap(),; * create_asvisual(), create_asvisual_for_id(),; *",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/afterimage.h:6016,load,loading,6016,graf2d/asimage/src/libAfterImage/afterimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/afterimage.h,1,['load'],['loading']
Performance,"add -f x.root f1.root f2.root f3.root; ```; will be a file x.root with h1 h2 h3 h4 h5 T1 T2; where; - h1 will be the sum of the 2 histograms in f1 and f2; - T1 will be the merge of the Trees in f1 and f2. The files may contain sub-directories. If the source files contains histograms and Trees, one can skip; the Trees with; ```; hadd -T targetfile source1 source2 ...; ```. Wildcarding and indirect files are also supported; ```; hadd result.root myfil*.root; ```; will merge all files in myfil*.root; ```; hadd result.root file1.root @list.txt file2. root myfil*.root; ```; will merge file1.root, file2.root, all files in myfil*.root; and all files in the indirect text file list.txt (""@"" as the first; character of the file indicates an indirect file. An indirect file; is a text file containing a list of other files, including other; indirect files, one line per file). If the sources and and target compression levels are identical (default),; the program uses the TChain::Merge function with option ""fast"", ie; the merge will be done without unzipping or unstreaming the baskets; (i.e. direct copy of the raw byte on disk). The ""fast"" mode is typically; 5 times faster than the mode unzipping and unstreaming the baskets. If the option -cachesize is used, hadd will resize (or disable if 0) the; prefetching cache use to speed up I/O operations. For options that take a size as argument, a decimal number of bytes is expected.; If the number ends with a `k`, `m`, `g`, etc., the number is multiplied; by 1000 (1K), 1000000 (1MB), 1000000000 (1G), etc.; If this prefix is followed by `i`, the number is multiplied by the traditional; 1024 (1KiB), 1048576 (1MiB), 1073741824 (1GiB), etc.; The prefix can be optionally followed by B whose casing is ignored,; eg. 1k, 1K, 1Kb and 1KB are the same. \note By default histograms are added. However hadd does not support the case where; histograms have their bit TH1::kIsAverage set. \authors Rene Brun, Dirk Geppert, Sven A. Schmidt, Toby Burnett; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/main/src/hadd.cxx:3367,cache,cachesize,3367,main/src/hadd.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/main/src/hadd.cxx,2,['cache'],"['cache', 'cachesize']"
Performance,"ads to a balanced kd-tree, in which each leaf node is about the same distance from the root.; However, balanced trees are not necessarily optimal for all applications.; The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used; by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the; concept):. ~~~~; function kdtree (list of points pointList, int depth); {; if pointList is empty; return nil;; else; {; // Select axis based on depth so that axis cycles through all valid values; var int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }; ~~~~. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. ### 3. Using TKDTree. #### 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developed to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:. \code{.cpp}; {; TTree *datatree = ...; ...; datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TKDTree.cxx:3188,optimiz,optimized,3188,math/mathcore/src/TKDTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TKDTree.cxx,1,['optimiz'],['optimized']
Performance,"after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The latter can perform more complex address checks to figure out whether; /// it's safe to touch the shadow memory.; /// Like with atomic operations, we call __msan_instrument_asm_store() before; /// the assembly call, so that changes to the shadow memory will be seen by; /// other threads together with main memory initialization.; ///; /// KernelMemorySanitizer (KMSAN) implementation.; ///; /// The major differences between KMSAN and MSan instrumentation are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:5682,perform,perform,5682,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['perform'],['perform']
Performance,"after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; ... Here the entry is processed; }; ~~~; #### Always using at least the same two branches. In this example, two branches are always used: in addition, some analysis; functions are invoked and those may trigger the reading of other branches which; are a priori not known.; There is no point in prefetching branches that will be used very rarely: we can; rely on the system to cache the right branches.; ~~~ {.cpp}; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; for (auto i : TSeqL(nentries)) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; // At this point we may call a user function where a few more branches; // will be read conditionally. These branches will be put in the cache; // if they have been used in the first 10 entries; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... Here the entry is processed; }; ~~~. \anchor checkPerf; ## How can the usage and performance of TTreeCache be verified?. Once the event loop terminated, the number of effective system reads for a; given file can be checked with a code like the following:; ~~~ {.cpp}; printf(""Reading %lld bytes in %d transactions\n"",myTFilePtr->GetBytesRead(), f->G",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:10082,cache,cachesize,10082,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,3,"['Load', 'cache']","['LoadTree', 'cachesize']"
Performance,"al elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; // element size. Do the same for stores.; // - For each equivalence class, greedily build ""chains"". Each chain has a; // leader instruction, and every other member of the chain has a known; // constant offset from the first instr in the chain.; // - Break up chains so that they contain only contiguous accesses of legal; // size with no intervening may-alias instrs.; // - Convert each chain to vector instructions.; //; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1954,load,load,1954,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,2,['load'],['load']
Performance,"al, for perfectly mixed samples *; * eg. purity=50% , N_signal = N_bkg *; * *; * Separation Gain: *; * the measure of how the quality of separation of the sample increases *; * by splitting the sample e.g. into a ""left-node"" and a ""right-node"" *; * (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right) *; * this is then the quality criterion which is optimized for when trying *; * to increase the information in the system (making the best selection *; * *; * Authors (alphabetical): *; * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; * *; * Copyright (c) 2005: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * Heidelberg U., Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; /*! \class TMVA::SeparationBase; \ingroup TMVA; An interface to calculate the ""SeparationGain"" for different; separation criteria used in various training algorithms. There are two things: the Separation Index, and the Separation Gain; Separation Index:; Measure of the ""purity"" of a sample. If all elements (events) in the; sample belong to the same class (e.g. signal or background), than the; separation index is 0 (meaning 100% purity (or 0% purity as it is; symmetric. The index becomes maximal, for perfectly mixed samples; eg. purity=50% , N_signal = N_bkg. Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality criterion which is optimized for when trying; to increase the information in the system (making the best selection; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SeparationBase.cxx:2672,optimiz,optimized,2672,tmva/tmva/src/SeparationBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SeparationBase.cxx,1,['optimiz'],['optimized']
Performance,"alculated . This number is of interest for estimating the accuracy; of x in the equation Ax=b; For example:; A is a (10x10) Hilbert matrix which looks deceivingly innocent; and simple, A(i,j) = 1/(i+j+1); b(i) = Sum_j A(i,j), so a sum of a row in A. the solution is x(i) = 1. i=0,.,9. However,; ~~~; TMatrixD m....; TVectorD b.....; TDecompLU lu(m); lu.SetTol(1.0e-12); lu.Solve(b); b.Print(); ~~~; gives,. ~~~; {1.000,1.000,1.000,1.000,0.998,1.000,0.993,1.001,0.996,1.000}; ~~~. Looking at the condition number, this is in line with expected the; accuracy . The condition number is 3.957e+12 . As a simple rule of; thumb, a condition number of 1.0e+n means that you lose up to n; digits of accuracy in a solution . Since doubles are stored with 15; digits, we can expect the accuracy to be as small as 3 digits . #### Det(Double_t &d1,Double_t &d2); The determinant is d1*TMath::Power(2.,d2); Expressing the determinant this way makes under/over-flow very; unlikely . #### Decompose(); Here the actually decomposition is performed . One can change the; matrix A after the decomposition constructor has been called; without effecting the decomposition result. #### Solve(TVectorD &b); Solve A x = b . x is supplied through the argument and replaced with; the solution . #### TransSolve(TVectorD &b); Solve A^T x = b . x is supplied through the argument and replaced; with the solution . #### MultiSolve(TMatrixD &B); Solve A X = B . where X and are now matrices . X is supplied through; the argument and replaced with the solution . #### Invert(TMatrixD &inv); This is of course just a call to MultiSolve with as input argument; the unit matrix . Note that for a matrix a(m,n) with m > n a; pseudo-inverse is calculated . ### Tolerances and Scaling. The tolerance parameter (which is a member of this base class) plays; a crucial role in all operations of the decomposition classes . It; gives the user a powerful tool to monitor and steer the operations; Its default value is sqrt(epsilon) where 1+ep",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompBase.cxx:1923,perform,performed,1923,math/matrix/src/TDecompBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompBase.cxx,1,['perform'],['performed']
Performance,"and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TGeoMatrix; \ingroup Geometry_classes. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. ~~~ {.cpp}; MASTER = T * LOCAL; ~~~. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embedding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication. Rotation: Inverse rotation:. ~~~ {.cpp}; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1; ~~~. Translation: Inverse translation:. ~~~ {.cpp}; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMatrix.cxx:1161,perform,performed,1161,geom/geom/src/TGeoMatrix.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMatrix.cxx,1,['perform'],['performed']
Performance,"and a list of pairs, one pair for each member; // of the struct. The first element of each pair is a type node (a struct type; // node or a scalar type node), specifying the type of the member, the second; // element of each pair is the offset of the member.; //; // Given an example; // typedef struct {; // short s;; // } A;; // typedef struct {; // uint16_t s;; // A a;; // } B;; //; // For an access to B.a.s, we attach !5 (a path tag node) to the load/store; // instruction. The base type is !4 (struct B), the access type is !2 (scalar; // type short) and the offset is 4.; //; // !0 = !{!""Simple C/C++ TBAA""}; // !1 = !{!""omnipotent char"", !0} // Scalar type node; // !2 = !{!""short"", !1} // Scalar type node; // !3 = !{!""A"", !2, i64 0} // Struct type node; // !4 = !{!""B"", !2, i64 0, !3, i64 4}; // // Struct type node; // !5 = !{!4, !2, i64 4} // Path tag node; //; // The struct type nodes and the scalar type nodes form a type DAG.; // Root (!0); // char (!1) -- edge to Root; // short (!2) -- edge to char; // A (!3) -- edge with offset 0 to short; // B (!4) -- edge with offset 0 to short and edge with offset 4 to A; //; // To check if two tags (tagX and tagY) can alias, we start from the base type; // of tagX, follow the edge with the correct offset in the type DAG and adjust; // the offset until we reach the base type of tagY or until we reach the Root; // node.; // If we reach the base type of tagY, compare the adjusted offset with; // offset of tagY, return Alias if the offsets are the same, return NoAlias; // otherwise.; // If we reach the Root node, perform the above starting from base type of tagY; // to see if we reach base type of tagX.; //; // If they have different roots, they're part of different potentially; // unrelated type systems, so we return Alias to be conservative.; // If neither node is an ancestor of the other and they have the same root,; // then we say NoAlias.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:4428,perform,perform,4428,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,1,['perform'],['perform']
Performance,"and if MigrateFalse is true, then FalseBB is the block being; // ""branched into""; //; // Here is the pseudo code for how I think the optimization should work:; // 1. Insert MOV GPR0, 0 before the branch instruction in diamond_head.; // 2. Insert MOV GPR0, 1 before the branch instruction in branch_from.; // 3. Move the branch instruction from diamond_head into its own basic; // block (new_block).; // 4. Add an unconditional branch from diamond_head to new_block; // 5. Replace the branch instruction in branch_from with an unconditional; // branch to new_block. If branch_from has multiple predecessors, then; // we need to replace the True/False block in the branch; // instruction instead of replacing it.; // 6. Change the condition of the branch instruction in new_block from; // COND to (COND || GPR0); //; // In order insert these MOV instruction, we will need to use the; // RegisterScavenger. Usually liveness stops being tracked during; // the late machine optimization passes, however if we implement; // bool TargetRegisterInfo::requiresRegisterScavenging(; // const MachineFunction &MF); // and have it return true, liveness will be tracked correctly; // by generic optimization passes. We will also need to make sure that; // all of our target-specific passes that run after regalloc and before; // the CFGStructurizer track liveness and we will need to modify this pass; // to correctly track liveness.; //; // After the above changes, the new CFG should look like this:; // entry; // / |; // diamond_head branch_from; // \ /; // new_block; // / |; // diamond_false diamond_true; // \ /; // done; //; // Without this optimization, we are forced to duplicate the diamond_true; // block and we will end up with a CFG like this:; //; // entry; // / |; // diamond_head branch_from; // / \ |; // diamond_false diamond_true diamond_true (duplicate); // \ / |; // done --------------------|; //; // Duplicating diamond_true can be very costly especially if it has a; // lot of instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp:1387,optimiz,optimization,1387,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp,3,['optimiz'],['optimization']
Performance,"ant PTX uses much fewer registers.; //; // mov.u32 %r1, %tid.x;; // mov.u32 %r2, %tid.y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias analysis in codegen).; // Such transformation can have following benefits:; // (1) It can always extract constants in the indices of structure type.; // (2) After such Lowering, there are more optimization opportunities such as; // CSE, LICM and CGP.; //; // E.g. The following GEPs have multiple indices:; // BB1:; // %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3; // load %p; // ...; // BB2:; // %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2; // load %p2; // ...; //; // We can not do CSE to the common part related to index ""i64 %i"". Lowering; // GEPs can achieve such goals.; // If the target does not use alias analysis in codegen, this pass will; // lower a GEP with multiple indices into arithmetic operations:; // BB1:; // %1 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = add i64 %1, %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = add i64 %3, %4; // %6 = add i64 %3, struct_field_3 ; Constant offset; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = add i64 %7, %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = add i64 %",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:3692,load,load,3692,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,1,['load'],['load']
Performance,"anvas. A Pad may contain other pads (unlimited pad hierarchy). A pad is a linked list of primitives of any type (graphics objects,; histograms, detectors, tracks, etc.). Adding a new element into a pad is in general performed by the Draw; member function of the object classes. It is important to realize that the pad is a linked list of references; to the original object.; For example, in case of a histogram, the histogram.Draw() operation; only stores a reference to the histogram object and not a graphical; representation of this histogram.; When the mouse is used to change (say the bin content), the bin content; of the original histogram is changed. The convention used in ROOT is that a Draw operation only adds; a reference to the object. The effective drawing is performed; when the canvas receives a signal to be painted. \image html gpad_pad1.png. This signal is generally sent when typing carriage return in the; command input or when a graphical operation has been performed on one; of the pads of this canvas.; When a Canvas/Pad is repainted, the member function Paint for all; objects in the Pad linked list is invoked. \image html gpad_pad2.png. When the mouse is moved on the Pad, The member function DistancetoPrimitive; is called for all the elements in the pad. DistancetoPrimitive returns; the distance in pixels to this object. When the object is within the distance window, the member function; ExecuteEvent is called for this object. In ExecuteEvent, move, changes can be performed on the object. For examples of DistancetoPrimitive and ExecuteEvent functions,; see classes; ~~~ {.cpp}; TLine::DistancetoPrimitive, TLine::ExecuteEvent; TBox::DistancetoPrimitive, TBox::ExecuteEvent; TH1::DistancetoPrimitive, TH1::ExecuteEvent; ~~~; A Pad supports linear and log scales coordinate systems.; The transformation coefficients are explained in TPad::ResizePad.; */; ////////////////////////////////////////////////////////////////////////////////; /// Pad default constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx:1610,perform,performed,1610,graf2d/gpad/src/TPad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx,1,['perform'],['performed']
Performance,"aphTime; - x[i] = Tree entry number; - y[i] = Time now; - ey[i] = readtime, eg timenow - start; The TTreePerfStats object can be saved in a ROOT file in such a way that; its inspection can be done outside the job that generated it. Example of use:; ~~~{.cpp}; {; TFile *f = TFile::Open(""RelValMinBias-GEN-SIM-RECO.root"");; T = (TTree*)f->Get(""Events"");; Long64_t nentries = T->GetEntries();; T->SetCacheSize(10000000);; T->SetCacheEntryRange(0,nentries);; T->AddBranchToCache(""*"");; //; TTreePerfStats *ps= new TTreePerfStats(""ioperf"",T);; //; for (Int_t i=0;i<nentries;i++) {; T->GetEntry(i);; }; ps->SaveAs(""cmsperf.root"");; }; ~~~; then, in a root interactive session, one can do:; ~~~{.cpp}; root > TFile f(""cmsperf.root"");; root > ioperf->Draw();; root > ioperf->Print();; ~~~; The Draw or Print functions print the following information:; - TreeCache = TTree cache size in MBytes; - N leaves = Number of leaves in the TTree; - ReadTotal = Total number of zipped bytes read; - ReadUnZip = Total number of unzipped bytes read; - ReadCalls = Total number of disk reads; - ReadSize = Average read size in KBytes; - Readahead = Readahead size in KBytes; - Readextra = Readahead overhead in percent; - Real Time = Real Time in seconds; - CPU Time = CPU Time in seconds; - Disk Time = Real Time spent in pure raw disk IO; - Disk IO = Raw disk IO speed in MBytes/second; - ReadUZRT = Unzipped MBytes per RT second; - ReadUZCP = Unipped MBytes per CP second; - ReadRT = Zipped MBytes per RT second; - ReadCP = Zipped MBytes per CP second. ### NOTE 1 :; The ReadTotal value indicates the effective number of zipped bytes; returned to the application. The physical number of bytes read; from the device (as measured for example with strace) is; ReadTotal +ReadTotal*Readextra/100. Same for ReadSize. ### NOTE 2 :; A consequence of NOTE1, the Disk I/O speed corresponds to the effective; number of bytes returned to the application per second.; The Physical disk speed is DiskIO + DiskIO*ReadExtra/100.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePerfStats.cxx:1648,cache,cache,1648,tree/treeplayer/src/TTreePerfStats.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePerfStats.cxx,1,['cache'],['cache']
Performance,"approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; - IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; - IACT > 2 => compute only the distance to exiting, ignoring anything else. #### `Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3], Int_t iact, Double_t step, Double_t; *safe)`. computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). #### `Double_t Safety(const Double_t *point[3], Bool_t inside)`. compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. #### `Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside)`. returns director cosines of normal to the crossed shape surface from a; given point towards a direction. One has to specify if the point is inside; or outside shape. According to this, the normal will be outwards or inwards; shape respectively. Normal components are statically stored by shape class,; so it has to be copied after retrieval in a different array. ### Dividing shapes. Shapes can generally be divided along a given axis. Supported axis are; X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis.; The general rule is that that divisions are possible on whatever axis that; produces still known shapes as slices. The division of shapes should not be; performed by TGeoShape::Divide() calls, but rather by TGeoVolume::Divide().; The algorithm for dividing a specific shape is known by the shape object, but; is always invoked in a generic way from the volume level. Details on how to; do that can be found in TGeoVolume class. One can see how all division options; are interpreted and which is their result inside specific shape classes. \image html geom_t_shape.png width=600px; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoShape.cxx:6231,perform,performed,6231,geom/geom/src/TGeoShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoShape.cxx,1,['perform'],['performed']
Performance,"arbitrary number of directories to be searched each.; * RETURN VALUE; * Pointer to ASImage structure holding image data on success.; * NULL on failure; * DESCRIPTION; * file2ASImage will attempt to interpret filename in the following way:; * 1)It will try to find file using unmodified filename in all the; * provided search paths.; * 2)It will attempt to append .gz and then .Z to the filename and; * find such file in all the provided search paths.; * 3)If filename ends with extension consisting of digits only - it will; * attempt to find file with this extension stripped off. On success; * this extension will be used to load subimage from the file with that; * number. Subimages are supported only for XCF, GIF, BMP, ICO and CUR; * files.; * After the file is found file2ASImage() attempts to detect file format,; * and if it is known it will load it into new ASImage structure.; * EXAMPLE; * asview.c: ASView.2; *********/; /****f* libAfterImage/import/get_asimage(); * NAME; * get_asimage() - increment reference counter if file is already loaded,; * or load image from file.; * SYNOPSIS; * ASImage *get_asimage( ASImageManager* imageman, const char *file,; * ASFlagType what, unsigned int compression );; * INPUTS; * imageman - pointer to valid ASVisual structure.; * file - root window ID for the destination screen.; * what - full image file's name with path.; * compression -; * RETURN VALUE; * Pointer to ASImage structure holding image data on success.; * NULL on failure; * DESCRIPTION; * get_asimage will attempt check with the ASImageManager's list of load; * images, and if image with requested filename already exists - it will; * increment its reference count and return its pointer.; * Otherwise it will call file2ASImage() to load image from file. It will; * use PATH and gamma values from the ASImageManager to pass to; * file2ASImage(). If image is successfully loaded - it will be added to; * the ASImageManager's list and its pointer will be returned.; * SEE ALSO; * file2AS",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.h:1535,load,loaded,1535,graf2d/asimage/src/libAfterImage/import.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.h,2,['load'],"['load', 'loaded']"
Performance,"ard methods, and thus a new basis is; obtained for the original 8-dimensional space the expansion of the; prototypes,; \f[; \mathbf{x}_m = \sum^7_{i=0} a_{m_i} \mathbf{e}_i; \quad; \mbox{where}; \quad; a_{m_i} = \mathbf{x}^T\bullet\mathbf{e}_i; \f]; allows the study of the behavior of the coefficients \f$a_{m_i}\f$ for all; the tracks of the sample. The eigenvectors which are insignificant for; the trajectory description in the expansion will have their; corresponding coefficients \f$a_{m_i}\f$ close to zero for all the; prototypes. On one hand, a reduction of the dimensionality is then obtained by; omitting these least significant vectors in the subsequent analysis. On the other hand, in the analysis of real data, these least; significant variables(?) can be used for the pattern; recognition problem of extracting the valid combinations of; coordinates describing a true trajectory from the set of all possible; wrong combinations. The program described here performs this principal components analysis; on a sample of data provided by the user. It computes the covariance; matrix, its eigenvalues ands corresponding eigenvectors and exhibits; the behavior of the principal components \f$a_{m_i}\f$, thus providing; to the user all the means of understanding their data. ## Principal Components Method; Let's consider a sample of \f$M\f$ prototypes each being characterized by; \f$P\f$ variables \f$x_0, x_1, \ldots, x_{P-1}\f$. Each prototype is a point, or a; column vector, in a \f$P\f$-dimensional *Pattern space*.; \f[; \mathbf{x} = \left[\begin{array}{c}; x_0\\x_1\\\vdots\\x_{P-1}\end{array}\right]\,,; \f]; where each \f$x_n\f$ represents the particular value associated with the; \f$n\f$-dimension. Those \f$P\f$ variables are the quantities accessible to the; experimentalist, but are not necessarily the most significant for the; classification purpose. The *Principal Components Method* consists of applying a; *linear* transformation to the original variables. This; transfor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:3056,perform,performs,3056,hist/hist/src/TPrincipal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx,1,['perform'],['performs']
Performance,"ares of residuals when taking \f$ j\f$ functions; into account. Then; \f[; S_l = \left[\mathbf{D} - \sum^l_{k=1} a_k\mathbf{w}_k\right]^2; = \mathbf{D}^2 - 2\mathbf{D} \sum^l_{k=1} a_k\mathbf{w}_k; + \sum^l_{k=1} a_k^2\mathbf{w}_k^2; \f]; Using [9], we see that; \f{eqnarray*}{; S_l &=& \mathbf{D}^2 - 2 \sum^l_{k=1} a_k^2\mathbf{w}_k^2 +; \sum^j_{k=1} a_k^2\mathbf{w}_k^2\nonumber\\; &=& \mathbf{D}^2 - \sum^l_{k=1} a_k^2\mathbf{w}_k^2\nonumber\\; &=& \mathbf{D}^2 - \sum^l_{k=1} \frac{\left(\mathbf D\bullet \mathbf; w_k\right)}{\mathbf w_k^2}; \f}; So for each new function \f$ F_l\f$ included in the model, we get a; reduction of the sum of squares of residuals of \f$a_l^2\mathbf{w}_l^2\f$,; where \f$\mathbf{w}_l\f$ is given by [4] and \f$ a_l\f$ by [9]. Thus, using; the Gram-Schmidt orthogonalisation, we; can decide if we want to include this function in the final model,; *before* the matrix inversion. ## Function Selection Based on Residual; Supposing that \f$ L-1\f$ steps of the procedure have been performed, the; problem now is to consider the \f$L^{\mbox{th}}\f$ function. The sum of squares of residuals can be written as; \f[; S_L = \textbf{D}^T\bullet\textbf{D} -; \sum^L_{l=1}a^2_l\left(\textbf{w}_l^T\bullet\textbf{w}_l\right); \f]; where the relation [9] have been taken into account. The; contribution of the \f$L^{\mbox{th}}\f$ function to the reduction of S, is; given by; \f[; \Delta S_L = a^2_L\left(\textbf{w}_L^T\bullet\textbf{w}_L\right); \f]; Two test are now applied to decide whether this \f$L^{\mbox{th}}\f$; function is to be included in the final expression, or not. ## Test 1; Denoting by \f$ H_{L-1}\f$ the subspace spanned by \f$\textbf{w}_1,\ldots,\textbf{w}_{L-1}\f$; the function \f$\textbf{w}_L\f$ is by construction (see 4) the projection of the function; \f$ F_L\f$ onto the direction perpendicular to \f$ H_{L-1}\f$. Now, if the; length of \f$\textbf{w}_L\f$ (given by \f$\textbf{w}_L\bullet\textbf{w}_L\f$); is very small compared to the length of \f$\t",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:8932,perform,performed,8932,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['perform'],['performed']
Performance,"ariables, when analyzing whether; // they are read or write-only).; //; // However, we only get to this code for weak-for-linkage values in one of; // two cases:; // 1) The prevailing copy is not in IR (it is in native code).; // 2) The prevailing copy in IR is not exported from its module.; // Additionally, at least for the new LTO API, case 2 will only happen if; // there is exactly one definition of the value (i.e. in exactly one; // module), as duplicate defs are result in the value being marked exported.; // Likely, users of the legacy LTO API are similar, however, currently there; // are llvm-lto based tests of the legacy LTO API that do not mark; // duplicate linkonce_odr copies as exported via the tool, so we need; // to handle that case below by checking the number of copies.; //; // Generally, we only want to internalize a weak-for-linker value in case; // 2, because in case 1 we cannot see how the value is used to know if it; // is read or write-only. We also don't want to bloat the binary with; // multiple internalized copies of non-prevailing linkonce/weak functions.; // Note if we don't internalize, we will convert non-prevailing copies to; // available_externally anyway, so that we drop them after inlining. The; // only reason to internalize such a function is if we indeed have a single; // copy, because internalizing it won't increase binary size, and enables; // use of inliner heuristics that are more aggressive in the face of a; // single call to a static (local). For variables, internalizing a read or; // write only variable can enable more aggressive optimization. However, we; // already perform this elsewhere in the ThinLTO backend handling for; // read or write-only variables (processGlobalForThinLTO).; //; // Therefore, only internalize linkonce/weak if there is a single copy, that; // is prevailing in this IR module. We can do so aggressively, without; // requiring the address to be insignificant, or that a variable be read or; // write-only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:2084,optimiz,optimization,2084,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"at callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over a single merged module; // that contains all vtables with !type metadata that participate in the link.; // The pass computes a resolution for each virtual call and stores it in the; // type identifier summary.; // - Import phase: this is run during the thin backends over the individual; // modules. The pass applies the resolutions previously computed during the; // import phase to each eligible virtual call.; //; // During ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over the index which; // contains a summary of all vtables with !type metadata that participate in; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1701,optimiz,optimization,1701,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,2,['optimiz'],['optimization']
Performance,"at off; /**; * \class ROOT::RDataFrame; * \ingroup dataframe; * \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; on their machines completely transparently.<br>; Skip to the [class reference](#reference) or keep reading for the user guide. In a nutshell:; ~~~{.cpp}; ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; myHisto->Draw(); // Event loop is run here, upon first access to a result; ~~~. Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; care of their execution. The implementation automatically puts in place several low level optimisations such as; multi-thread parallelization and caching. \htmlonly; <a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; alt=""DOI""></a>; \endhtmlonly. ## For the impatient user; You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python. ## Table of Contents; - [Cheat sheet](\ref cheatsheet); - [Introduction](\ref introduction); - [Crash course](\ref crash-course); - [Working with collections](\ref collections); - [Transformations: manipulating data](\ref transformations); - [Actions: getting results](\ref actions); - [Distributed execution in Python](\ref distrdf); - [Performance tips and parallel execution](\ref parallel-execution); - [More features](\ref more-features); - [Systematic variations](\ref systematics); - [RDataFrame objects as function arguments and return values](\ref rnode); - [Storing RDataFrame objects in collections",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:1037,multi-thread,multi-thread,1037,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['multi-thread'],['multi-thread']
Performance,"ataFrame event loops; A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");. // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop. // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ~~~. ### Performance considerations. To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; should be preferred for performance-critical applications. Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case. Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime co",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:51288,concurren,concurrently,51288,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['concurren'],['concurrently']
Performance,"ated for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like this:; //; // char *p;; // A1 = p + base1; // A2 = p + base1 + offset; // B1 = p + base2; // B2 = p + base2 + offset; //; // for (int i = 0; i < n; i++); // unsigned long x1 = *(unsigned long *)(A1 + i);; // unsigned long x2 = *(unsigned long *)(A2 + i); // unsigned long x3 = *(unsigned long *)(B1 + i);; // unsigned long x4 = *(unsigned long *)(B2 + i);; // }; //; // to look like this:; //; // A1_new = p + base1 // chain 1; // B1_new = p + base2 // chain 2, now inside the loop, common offset is; // // reused.; //; // for (long long i = 0; i < n; i+=count) {; // unsigned lon",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:1639,load,load,1639,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,1,['load'],['load']
Performance,"ations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published in; // CUDA: Compiling and optimizing for a GPU platform; // Chakrabarti, Grover, Aarts, Kong, Kudlur, Lin, Marathe, Murphy, Wang; // ICCS 2012; //; // Then, address space inference replaces all refinable generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:1758,optimiz,optimization,1758,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,1,['optimiz'],['optimization']
Performance,"atively a number of times which is controlled; // by the option `funcspec-max-iters`. Running it multiple times is needed; // for specializing recursive functions, but also exposes new opportunities; // arising from specializations which return constant values or contain calls; // which can be specialized.; //; // Function Specialization supports propagating constant parameters like; // function pointers, literal constants and addresses of global variables.; // By propagating function pointers, indirect calls become direct calls. This; // exposes inlining opportunities which we would have otherwise missed. That's; // why function specialization is run before the inliner in the optimization; // pipeline; that is by design.; //; // Cost Model:; // -----------; // The cost model facilitates a utility for estimating the specialization bonus; // from propagating a constant argument. This is the InstCostVisitor, a class; // that inherits from the InstVisitor. The bonus itself is expressed as codesize; // and latency savings. Codesize savings means the amount of code that becomes; // dead in the specialization from propagating the constant, whereas latency; // savings represents the cycles we are saving from replacing instructions with; // constant values. The InstCostVisitor overrides a set of `visit*` methods to; // be able to handle different types of instructions. These attempt to constant-; // fold the instruction in which case a constant is returned and propagated; // further.; //; // Function pointers are not handled by the InstCostVisitor. They are treated; // separately as they could expose inlining opportunities via indirect call; // promotion. The inlining bonus contributes to the total specialization score.; //; // For a specialization to be profitable its bonus needs to exceed a minimum; // threshold. There are three options for controlling the threshold which are; // expressed as percentages of the original function size:; // * funcspec-min-codesize-savings; /",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h:1694,latency,latency,1694,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h,1,['latency'],['latency']
Performance,"atrix (OpenGL column major ordering); for placing the object into the 3D master frame. If fLocalFrame is kFALSE, fLocalMaster should contain an identity matrix. This; is set by default, and can be reset using SetLocalMasterIdentity() function. ### Logical & Physical Objects. There are two cases of object addition:. - Add this object as a single independent entity in the world reference frame.; - Add a physical placement (copy) of this logical object (described in local reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the fID logical ID member of; TBuffer3D. If repeated addition of the same fID is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can also perform internal GL specific caching with considerable performance gains; in these cases. For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; ~~~ {.cpp}; PreferLocalFrame(); ~~~. If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements. For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object. As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. ## Scene Rebuilds. It should be understood that AddObject is not an explici",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualViewer3D.cxx:7747,perform,perform,7747,core/base/src/TVirtualViewer3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualViewer3D.cxx,2,['perform'],"['perform', 'performance']"
Performance,"aw deflate. In this case, -windowBits; determines the window size. deflate() will then generate raw deflate data; with no zlib header or trailer, and will not compute an adler32 check value. windowBits can also be greater than 15 for optional gzip encoding. Add; 16 to windowBits to write a simple gzip header and trailer around the; compressed data instead of a zlib wrapper. The gzip header will have no; file name, no extra data, no comment, no modification time (set to zero), no; header crc, and the operating system will be set to 255 (unknown). If a; gzip stream is being written, strm->adler is a crc32 instead of an adler32. The memLevel parameter specifies how much memory should be allocated; for the internal compression state. memLevel=1 uses minimum memory but is; slow and reduces compression ratio; memLevel=9 uses maximum memory for; optimal speed. The default value is 8. See zconf.h for total memory usage; as a function of windowBits and memLevel. The strategy parameter is used to tune the compression algorithm. Use the; value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a; filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no; string match), or Z_RLE to limit match distances to one (run-length; encoding). Filtered data consists mostly of small values with a somewhat; random distribution. In this case, the compression algorithm is tuned to; compress them better. The effect of Z_FILTERED is to force more Huffman; coding and less string matching; it is somewhat intermediate between; Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as; fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data. The; strategy parameter only affects the compression ratio but not the; correctness of the compressed output even if it is not set appropriately.; Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler; decoder for special applications. deflateInit2 returns Z_OK if success, Z_MEM_",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:2216,tune,tune,2216,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['tune'],['tune']
Performance,"aw deflate. In this case, -windowBits; determines the window size. deflate() will then generate raw deflate data; with no zlib header or trailer, and will not compute an adler32 check value. windowBits can also be greater than 15 for optional gzip encoding. Add; 16 to windowBits to write a simple gzip header and trailer around the; compressed data instead of a zlib wrapper. The gzip header will have no; file name, no extra data, no comment, no modification time (set to zero),; no header crc, and the operating system will be set to 255 (unknown). If a; gzip stream is being written, strm->adler is a crc32 instead of an adler32. The memLevel parameter specifies how much memory should be allocated; for the internal compression state. memLevel=1 uses minimum memory but; is slow and reduces compression ratio; memLevel=9 uses maximum memory; for optimal speed. The default value is 8. See zconf.h for total memory; usage as a function of windowBits and memLevel. The strategy parameter is used to tune the compression algorithm. Use the; value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a; filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no; string match), or Z_RLE to limit match distances to one (run-length; encoding). Filtered data consists mostly of small values with a somewhat; random distribution. In this case, the compression algorithm is tuned to; compress them better. The effect of Z_FILTERED is to force more Huffman; coding and less string matching; it is somewhat intermediate between; Z_DEFAULT and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as fast as; Z_HUFFMAN_ONLY, but give better compression for PNG image data. The strategy; parameter only affects the compression ratio but not the correctness of the; compressed output even if it is not set appropriately. Z_FIXED prevents the; use of dynamic Huffman codes, allowing for a simpler decoder for special; applications. deflateInit2 returns Z_OK if success, Z_MEM_ERROR if ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:2216,tune,tune,2216,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['tune'],['tune']
Performance,"bclasses of the SCEV class.; // These classes are used to represent certain types of subexpressions that we; // can handle. We only create one SCEV of a particular shape, so; // pointer-comparisons for equality are legal.; //; // One important aspect of the SCEV objects is that they are never cyclic, even; // if there is a cycle in the dataflow for an expression (ie, a PHI node). If; // the PHI node is one of the idioms that we can represent (e.g., a polynomial; // recurrence) then we represent it directly as a recurrence node, otherwise we; // represent it as a SCEVUnknown node.; //; // In addition to being able to represent expressions of various types, we also; // have folders that are used to build the *canonical* representation for a; // particular expression. These folders are capable of using a variety of; // rewrite rules to simplify the expressions.; //; // Once the folders are defined, we can implement the more interesting; // higher-level code, such as the code that recognizes PHI nodes of various; // types, computes the execution count of a loop, etc.; //; // TODO: We should use these routines and value representations to implement; // dependence analysis!; //; //===----------------------------------------------------------------------===//; //; // There are several good references for the techniques used in this analysis.; //; // Chains of recurrences -- a method to expedite the evaluation; // of closed-form functions; // Olaf Bachmann, Paul S. Wang, Eugene V. Zima; //; // On computational properties of chains of recurrences; // Eugene V. Zima; //; // Symbolic Evaluation of Chains of Recurrences for Loop Optimization; // Robert A. van Engelen; //; // Efficient Symbolic Analysis for Optimizing Compilers; // Robert A. van Engelen; //; // Using the chains of recurrences algebra for data dependence testing and; // induction variable substitution; // MS Thesis, Johnie Birch; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:2335,Optimiz,Optimization,2335,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,2,['Optimiz'],"['Optimization', 'Optimizing']"
Performance,"bitrary size colormap.; *; * 8. libAfterImage could be used without X window system, which is; * coninient for such thing as web development. XML Image manipulation; * tool, that could be used in such activity is included (see ascompose.c); *; * 9. Image reference counting; *; * USES; * libAfterBase - AfterStep basic functionality library. That Includes; * Hash tables, file search methods, message output, generic types.; * However effort has been made to allow for standalone configuration as; * well. If libAfterBase is not found at compilation time - libAfterImage; * will use extract from libAfterBase included with libAfterImage.; *; * SEE ALSO; * Examples; * API Reference; *; * TODO; * Implement support for Targa and PCX image format and maybe some other; * formats as well.; *; * Implement complete support for I18N internationalization.; *; * Implement color<->pixel conversion for all colordepths.; *; * AUTHOR; * Sasha Vasko <sasha at aftercode dot net>; *********/; /****h* libAfterImage/Examples; * EXAMPLE; * ASView - image loading from the file and displaying in window.; * ASScale - image loading from file and scaling to arbitrary size.; * ASTile - image loading from file, tiling and tinting to arbitrary; * size and color.; * ASMerge - imgae loading and merging with another image.; * ASGrad - mutlipoint gradient drawing.; * ASFlip - image loading from file and rotation.; * ASText - trexturized semitransparent antialised text drawing.; *; * SEE ALSO; * API Reference; ******/; /****h* libAfterImage/API Reference; * CHILDREN; * Headers :; * ascmap.h asfont.h asimage.h asvisual.h blender.h export.h; * import.h transform.h ximage.h; * Structures :; * ColorPair; * ASScanline; * ASVisual; * ASImage; * ASImageManager; * ASImageBevel; * ASImageDecoder; * ASImageOutput; * ASImageLayer; * ASGradient; * ASFontManager; * ASFont; * ASGlyph; * ASGlyphRange; * ASColormap; * ASImageExportParams; * ASVectorPalette; *; * Functions :; * ASScanline handling:; * 	 prepare_scanline(), ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/afterimage.h:5882,load,loading,5882,graf2d/asimage/src/libAfterImage/afterimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/afterimage.h,1,['load'],['loading']
Performance,"c->GetParameter(0); //value of 1st parameter; /// Double_t err0 = myfunc->GetParError(0); //error on first parameter; /// ~~~; ///; /// ##### Associated functions; ///; /// One or more object ( can be added to the list; /// of functions (fFunctions) associated to each histogram.; /// When TH1::Fit is invoked, the fitted function is added to the histogram list of functions (fFunctions).; /// If the histogram is made persistent, the list of associated functions is also persistent.; /// Given a histogram h, one can retrieve an associated function with:; ///; /// ~~~ {.cpp}; /// TF1 *myfunc = h->GetFunction(""myfunc"");; /// ~~~; /// or by quering directly the list obtained by calling `TH1::GetListOfFunctions`.; ///; /// \anchor HFitStatus; /// ### Fit status; ///; /// The status of the fit is obtained converting the TFitResultPtr to an integer; /// independently if the fit option ""S"" is used or not:; ///; /// ~~~ {.cpp}; /// TFitResultPtr r = h->Fit(myFunc,opt);; /// Int_t fitStatus = r;; /// ~~~; ///; /// - `status = 0` : the fit has been performed successfully (i.e no error occurred).; /// - `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.; /// - `status > 0` : return status from Minimizer, depends on used Minimizer. For example for TMinuit and Minuit2 we have:; /// - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`.; /// TMinuit returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of TMinuit::mnexcm). For example, for an error; /// only in Minos but not in Migrad a fitStatus of 40 will be returned.; /// Minuit2 returns 0 in case of success and different values in migrad,minos or; /// hesse depending on the error. See in this case the documentation of; /// Minuit2Minimizer::Minimize for the migrad return status, Minuit2Minimizer::GetMinosError for the; /// minos return status and Minuit2Minimizer::Hesse for ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:12186,perform,performed,12186,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['perform'],['performed']
Performance,"cache miss occurs, all the utilized branches are be prefetched; for that event. This optimization utilizes the observation that infrequently; accessed branches are often accessed together.; An example scenario where such behavior is desirable, is an analysis where; a set of collections are read only for a few events in which a certain; condition is respected, e.g. a trigger fired. ### Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase; by at most a factor two in the case of cache miss.; Additionally, on the first miss of an event, we must iterate through all the; ""active branches"" for the miss cache and find the correct basket.; This can be potentially a CPU-expensive operation compared to, e.g., the; latency of a SSD. This is why the miss cache is currently disabled by default. \anchor examples; ## Example usages of TTreeCache. A few use cases are discussed below. A cache may be created with automatic; sizing when a TTree is used:. In some applications, e.g. central processing workflows of experiments, the list; of branches to read is known a priori. For these cases, the TTreeCache can be; instructed about the branches which will be read via explicit calls to the TTree; or TTreeCache interfaces.; In less streamlined applications such as analysis, predicting the branches which; will be read can be difficult. In such cases, ROOT I/O flags used branches; automatically when a branch buffer is read during the learning phase. In the examples below, portions of analysis code are shown.; The few statements involving the TreeCache are marked with `//<<<`. ### ROOT::RDataFrame and TTreeReader Examples. If you use RDataFrame or TTreeReader, the system will automatically cache the; best set of branches: no action is required by the user. ### TTree::Draw Example. The TreeCache is automatically used by TTree::Draw. The method knows; which branches are used in the query and it puts automatical",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:5978,cache,cache,5978,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"cache:. - Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. - Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning phase is started or restarted when:; - TTree automatically creates a cache.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTreeCache::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; - TTreeCache::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries.; - A 'cached' TChain switches over to a new file. \anchor cachemisses; ## Self-optimization in presence of cache misses. The TTreeCache can optimize its behavior on a cache miss. When; miss optimization is enabled (see the SetOptimizeMisses method),; it tracks all branches utilized after the learning phase which caused a cache; miss.; When one cache miss occurs, all the utilized branches are be prefetched; for that event. This optimization utilizes the observation that infrequently; accessed branches are often accessed together.; An example scenario where such behavior is desirable, is an analysis where; a set of collections are read only for a few events in which a certain; condition is respected, e.g. a trigger fired. ### Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase; by at most a factor two in the case of cache miss.; Additionally, on the first miss of an event, we must iterate through all the; ""active branches"" for the miss cache and find the correct basket.; This can be p",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:4721,cache,cachemisses,4721,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,3,"['cache', 'optimiz']","['cache', 'cachemisses', 'optimization']"
Performance,"cally used by TTree::Draw. The method knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also inferred automatically. ### TTree::Process and TSelectors Examples. The user must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case only a subset of the events is processed to avoid wasteful caching. #### Reading all branches. ~~~ {.cpp}; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; ~~~. #### Reading a subset of all branches. In the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; ~~~ {.cpp}; TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=200UL;; auto efirst = 0;; auto elast = efirst+nentries;; auto cachesize = 10000000U; // 10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process(""myselector.C+"","""",nentries,efirst);; // In the TSelector::Process we read only 2 branches; auto b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; auto b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... Here the entry is processed; ~~~; ### Custom event loop. #### Always using the same two branches. In this example, exactly two branches are always used: those need to be; prefetched.; ~~~ {.cpp}; TTree *T;; f->GetObject(T, ""mytree"");; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; auto nentries = T->GetEntries();; auto cachesiz",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:7930,cache,cache,7930,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"can be retrieved by typing `rootls -lt myfile.root` at a command line. ### Distributed Snapshot. The Snapshot operation behaves slightly differently when executed distributedly. First off, it requires the path; supplied to the Snapshot call to be accessible from any worker of the cluster and from the client machine (in general; it should be provided as an absolute path). Another important difference is that `n` separate files will be produced,; where `n` is the number of dataset partitions. As with local RDataFrame, the result of a Snapshot on a distributed; RDataFrame is another distributed RDataFrame on which we can define a new computation graph and run more distributed; computations. ### Distributed RunGraphs. Submitting multiple distributed RDataFrame executions is supported through the RunGraphs function. Similarly to its; local counterpart, the function expects an iterable of objects representing an RDataFrame action. Each action will be; triggered concurrently to send multiple computation graphs to a distributed cluster at the same time:. ~~~{.py}; import ROOT; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; RunGraphs = ROOT.RDF.Experimental.Distributed.RunGraphs. # Create 3 different dataframes and book an histogram on each one; histoproxies = [; RDataFrame(100); .Define(""x"", ""rdfentry_""); .Histo1D((""name"", ""title"", 10, 0, 100), ""x""); for _ in range(4); ]. # Execute the 3 computation graphs; RunGraphs(histoproxies); # Retrieve all the histograms in one go; histos = [histoproxy.GetValue() for histoproxy in histoproxies]; ~~~. Every distributed backend supports this feature and graphs belonging to different backends can be still triggered with; a single call to RunGraphs (e.g. it is possible to send a Spark job and a Dask job at the same time). ### Histogram models in distributed mode. When calling a Histo*D operation in distributed mode, remember to pass to the function the model of the histogram to be; computed, e.g. the axis range and the n",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:43252,concurren,concurrently,43252,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['concurren'],['concurrently']
Performance,"can be run in batch or with the interpreter.; // You must run; // gmake on Unix systems; // nmake on Windows; // To run in batch, do; // stress -b 1000 : with no parameters, run standard test with 1000 events; // stress -b 30: run test with 30 events only; //; // To run interactively, do; // root -b; // Root > .L stress.cxx; // Root > stress(1000) run standard test with 1000 events; // Root > stress(30) run with 30 events only; //; // The standard test with 1000 events will create several files.; // The size of all files is around 100 Mbytes.; // The test with 30 events only require around 20 Mbytes; // NB: The test must be run with more than 10 events; //; // The tests runs sequentially 16 tests. Each test will produce; // one line (Test OK or Test failed) with some result parameters.; // At the end of the test a table is printed showing the global results; // with the amount of I/O, Real Time and Cpu Time.; // One single number (ROOTMARKS) is also calculated showing the relative; // performance of your machine compared to a reference machine; // a Pentium IV 2.4 Ghz) with 512 MBytes of memory; // and 120 GBytes IDE disk.; //; // An example of output when all the tests run OK is shown below:; // ******************************************************************; // * Starting R O O T - S T R E S S test suite with 1000 events; // ******************************************************************; // Test 1 : Functions, Random Numbers, Histogram Fits............. OK; // Test 2 : Check size & compression factor of a Root file........ OK; // Test 3 : Purge, Reuse of gaps in TFile......................... OK; // Test 4 : Test of 2-d histograms, functions, 2-d fits........... OK; // Test 5 : Test graphics & Postscript............................ OK; // Test 6 : Test subdirectories in a Root file.................... OK; // Test 7 : TNtuple, selections, TCut, TCutG, TEventList.......... OK; // Test 8 : Trees split and compression modes..................... OK; // Test 9 : ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stress.cxx:1388,perform,performance,1388,test/stress.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stress.cxx,1,['perform'],['performance']
Performance,"case of error and TSelector::GetStatus() in; /// in case of success.; ///; /// The code in filename is loaded (interpreted or compiled, see below),; /// filename must contain a valid class implementation derived from TSelector,; /// where TSelector has the following member functions:; ///; /// - Begin(): called every time a loop on the tree starts,; /// a convenient place to create your histograms.; /// - SlaveBegin(): called after Begin(), when on PROOF called only on the; /// slave servers.; /// - Process(): called for each event, in this function you decide what; /// to read and fill your histograms.; /// - SlaveTerminate: called at the end of the loop on the tree, when on PROOF; /// called only on the slave servers.; /// - Terminate(): called at the end of the loop on the tree,; /// a convenient place to draw/fit your histograms.; ///; /// If filename is of the form file.C, the file will be interpreted.; /// If filename is of the form file.C++, the file file.C will be compiled; /// and dynamically loaded.; ///; /// If filename is of the form file.C+, the file file.C will be compiled; /// and dynamically loaded. At next call, if file.C is older than file.o; /// and file.so, the file.C is not compiled, only file.so is loaded.; ///; /// ### NOTE 1; /// It may be more interesting to invoke directly the other Process function; /// accepting a TSelector* as argument.eg; /// ~~~{.cpp}; /// MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; /// selector->CallSomeFunction(..);; /// mytree.Process(selector,..);; /// ~~~; /// ### NOTE 2; /// One should not call this function twice with the same selector file; /// in the same script. If this is required, proceed as indicated in NOTE1,; /// by getting a pointer to the corresponding TSelector,eg; ///#### workaround 1; /// ~~~{.cpp}; ///void stubs1() {; /// TSelector *selector = TSelector::GetSelector(""h1test.C"");; /// TFile *f1 = new TFile(""stubs_nood_le1.root"");; /// TTree *h1 = (TTree*)f1->Get(""h1"");; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx:1208,load,loaded,1208,tree/treeplayer/src/TTreePlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx,1,['load'],['loaded']
Performance,"case you just copy completely opaque pixels to the; * output. For pixels that are not completely transparent (you just skip; * those) you do the composition math using png_composite or png_composite_16; * below then encode the resultant 8-bit or 16-bit values to match the output; * encoding.; *; * Other cases; * If neither the PNG nor the standard linear encoding work for you because; * of the software or hardware you use then you have a big problem. The PNG; * case will probably result in halos around the image. The linear encoding; * will probably result in a washed out, too bright, image (it's actually too; * contrasty.) Try the ALPHA_OPTIMIZED mode above - this will probably; * substantially reduce the halos. Alternatively try:; *; * png_set_alpha_mode(pp, PNG_ALPHA_BROKEN, PNG_DEFAULT_sRGB);; * This option will also reduce the halos, but there will be slight dark; * halos round the opaque parts of the image where the background is light.; * In the OPTIMIZED mode the halos will be light halos where the background; * is dark. Take your pick - the halos are unavoidable unless you can get; * your hardware/software fixed! (The OPTIMIZED approach is slightly; * faster.); *; * When the default gamma of PNG files doesn't match the output gamma.; * If you have PNG files with no gamma information png_set_alpha_mode allows; * you to provide a default gamma, but it also sets the output gamma to the; * matching value. If you know your PNG files have a gamma that doesn't; * match the output you can take advantage of the fact that; * png_set_alpha_mode always sets the output gamma but only sets the PNG; * default if it is not already set:; *; * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_DEFAULT_sRGB);; * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_GAMMA_MAC);; * The first call sets both the default and the output gamma values, the; * second call overrides the output gamma without changing the default. This; * is easier than achieving the same effect with png_set_gamma. You must ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:2938,OPTIMIZ,OPTIMIZED,2938,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['OPTIMIZ'],['OPTIMIZED']
Performance,"ce and binary forms,; * with or without modification, are permitted according to the terms; * listed in LICENSE (http://roofit.sourceforge.net/license.txt); */; /** \class RooStats::ModelConfig; \ingroup Roostats. ModelConfig is a simple class that holds configuration information specifying how a model; should be used in the context of various RooStats tools. A single model can be used; in different ways, and this class should carry all that is needed to specify how it should be used.; ModelConfig requires a workspace to be set. A ModelConfig holds sets of parameters of the likelihood function that have different interpretations:; - **Parameter of interest** Parameters that are measured (*i.e.* fitted).; - **Nuisance parameters** Parameters that are fitted, but their post-fit value is not interesting. Often,; they might be constrained because external knowledge about them exists, *e.g.* from external measurements.; - **Constraint parameters** No direct use in RooFit/RooStats. Can be used by the user for bookkeeping.; - **Observables** Parameters that have been measured externally, *i.e.* they exist in a dataset. These are not fitted,; but read during fitting from the entries of a dataset.; - **Conditional observables** Observables that are not integrated when the normalisation of the PDF is calculated.; See *e.g.* `rf306_condpereventerrors` in the RooFit tutorials.; - **Global observables** Observables that to the fit look like ""constant"" values, *i.e.* they are not being; fitted and they are not loaded from a dataset, but some knowledge exists that allows to set them to a; specific value. Examples:; -- A signal efficiency measured in a Monte Carlo study.; -- When constraining a parameter \f$ b \f$, the target value (\f$ b_0 \f$) that this parameter is constrained to:; \f[; \mathrm{Constraint}_b = \mathrm{Gauss}(b_0 \, | \, b, 0.2); \f]; - **External constraints** Include given external constraints to likelihood by multiplying them with the original; likelihood.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/ModelConfig.cxx:1713,load,loaded,1713,roofit/roofitcore/src/ModelConfig.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/ModelConfig.cxx,1,['load'],['loaded']
Performance,"ce to nearest limit divided by distance between limits).; The user must therefore be aware of the fact that, for example,; if he puts limits of \f$(0,10^{10})\f$ on a parameter, then the values \f$0.0\f$; and \f$1.0\f$ will be indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course,; so Minuit does a transformation of the error matrix (and the; ``parabolic'' parameter errors) when there are parameter limits.; Users should however realize that the transformation is only a linear; approximation, and that it cannot give a meaningful result if one or more; parameters is very close to a limit, where; \f$\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\f$.; Therefore, it is recommended that:. 1. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values. 2. When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. ### How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakness is that it depends heavily on; knowledge of the first derivatives, and fails miserably if they are very; inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. #### Getting the right minimum with limits. If MIGRAD converges normally to a point where no parameter is near one of; its limits, then the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:5002,perform,perform,5002,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,2,['perform'],['perform']
Performance,"ch has its own basket). When a basket is full; /// (32k worth of data by default), it is then optionally compressed; /// and written to disk (this operation is also called committing or; /// 'flushing' the basket). The committed baskets are then; /// immediately removed from memory.; ///; /// The function returns the number of bytes committed to the; /// individual branches.; ///; /// If a write error occurs, the number of bytes returned is -1.; ///; /// If no data are written, because, e.g., the branch is disabled,; /// the number of bytes returned is 0.; ///; /// __The baskets are flushed and the Tree header saved at regular intervals__; ///; /// At regular intervals, when the amount of data written so far is; /// greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; /// This makes future reading faster as it guarantees that baskets belonging to nearby; /// entries will be on the same disk region.; /// When the first call to flush the baskets happen, we also take this opportunity; /// to optimize the baskets buffers.; /// We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; /// In this case we also write the Tree header. This makes the Tree recoverable up to this point; /// in case the program writing the Tree crashes.; /// The decisions to FlushBaskets and Auto Save can be made based either on the number; /// of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; /// written (fAutoFlush and fAutoSave positive).; /// Note that the user can decide to call FlushBaskets and AutoSave in her event loop; /// base on the number of events written instead of the number of bytes written.; ///; /// \note Calling `TTree::FlushBaskets` too often increases the IO time.; ///; /// \note Calling `TTree::AutoSave` too often increases the IO time and also the; /// file size.; ///; /// \note This method calls `TTree::ChangeFile` when the tree reaches a size; /// greater than `TTree::fgMaxTreeSi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1513,optimiz,optimize,1513,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['optimiz'],['optimize']
Performance,"ch layout** : this defines how are the input batch. It is related to input layout but not the same.; # If the first layer is dense it should be ``1 | batch size ! number of variables`` (features); # *(note the use of the character `|` as separator of input parameters for DNN layout)*; # note that in case of only dense layer the input layout could be omitted but it is required when defining more; # complex architectures; # - **layer layout** string defining the layer architecture. The syntax is; # - layer type (e.g. DENSE, CONV, RNN); # - layer parameters (e.g. number of units); # - activation function (e.g TANH, RELU,...); # *the different layers are separated by the ``"",""`` *; #### 2. Define Training Strategy; # We define here the training strategy parameters for the DNN. The parameters are separated by the ``"",""`` separator.; # One can then concatenate different training strategy with different parameters. The training strategy are separated by; # the ``""|""`` separator.; # - Optimizer; # - Learning rate; # - Momentum (valid for SGD and RMSPROP); # - Regularization and Weight Decay; # - Dropout; # - Max number of epochs; # - Convergence steps. if the test error will not decrease after that value the training will stop; # - Batch size (This value must be the same specified in the input layout); # - Test Repetitions (the interval when the test error will be computed); #### 3. Define general DNN options; # We define the general DNN options concatenating in the final string the previously defined layout and training strategy.; # Note we use the ``"":""`` separator to separate the different higher level options, as in the other TMVA methods.; # In addition to input layout, batch layout and training strategy we add now:; # - Type of Loss function (e.g. CROSSENTROPY); # - Weight Initizalization (e.g XAVIER, XAVIERUNIFORM, NORMAL ); # - Variable Transformation; # - Type of Architecture (e.g. CPU, GPU, Standard); # We can then book the DL method using the built option string",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_Higgs_Classification.py:1629,Optimiz,Optimizer,1629,tutorials/tmva/TMVA_Higgs_Classification.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_Higgs_Classification.py,1,['Optimiz'],['Optimizer']
Performance,"changed using the method `SetMarkerStyle` and retrieved using the; method `GetMarkerStyle`. The following list gives the currently supported markers (screen; and PostScript) style. Each marker style is identified by an integer number; (first column) corresponding to a marker shape (second column) and can be also; accessed via a global name (third column). ~~~ {.cpp}; Marker number Marker shape Marker name; 1 dot kDot; 2 + kPlus; 3 * kStar; 4 o kCircle; 5 x kMultiply; 6 small dot kFullDotSmall; 7 medium dot kFullDotMedium; 8 large scalable dot kFullDotLarge; 9 -->19 large scalable dot; 20 full circle kFullCircle; 21 full square kFullSquare; 22 full triangle up kFullTriangleUp; 23 full triangle down kFullTriangleDown; 24 open circle kOpenCircle; 25 open square kOpenSquare; 26 open triangle up kOpenTriangleUp; 27 open diamond kOpenDiamond; 28 open cross kOpenCross; 29 full star kFullStar; 30 open star kOpenStar; 31 *; 32 open triangle down kOpenTriangleDown; 33 full diamond kFullDiamond; 34 full cross kFullCross; 35 open diamond cross kOpenDiamondCross; 36 open square diagonal kOpenSquareDiagonal; 37 open three triangle kOpenThreeTriangles; 38 octagon with cross kOctagonCross; 39 full three triangles kFullThreeTriangles; 40 open four triangleX kOpenFourTrianglesX; 41 full four triangleX kFullFourTrianglesX; 42 open double diamond kOpenDoubleDiamond; 43 full double diamond kFullDoubleDiamond; 44 open four triangle+ kOpenFourTrianglesPlus; 45 full four triangle+ kFullFourTrianglesPlus; 46 open cross X kOpenCrossX; 47 full cross X kFullCrossX; 48 four squares X kFourSquaresX; 49 four squares+ kFourSquaresPlus; ~~~. Begin_Macro; {; TCanvas *c = new TCanvas(""c"",""Marker types"",0,0,500,200);; TMarker marker;; marker.DisplayMarkerTypes();; }; End_Macro. \warning Non-symmetric symbols should be used carefully. See markerwarning.C. \anchor ATTMARKER21; ### Marker line width. The line width of a marker is not actually a marker attribute since it does; only apply to open marker sy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TAttMarker.cxx:2344,scalab,scalable,2344,core/base/src/TAttMarker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TAttMarker.cxx,2,['scalab'],['scalable']
Performance,"cies.; //; // Actually when talking about 'low latency' or 'high latency' it includes; // both the latency to get the cache (or global mem) data go to the register,; // and the bandwidth limitations.; // Increasing the number of active wavefronts helps hide the former, but it; // doesn't solve the latter, thus why even if wavefront count is high, we have; // to try have as many instructions hiding high latencies as possible.; // The OpenCL doc says for example latency of 400 cycles for a global mem; // access, which is hidden by 10 instructions if the wavefront count is 10.; // Some figures taken from AMD docs:; // Both texture and constant L1 caches are 4-way associative with 64 bytes; // lines.; // Constant cache is shared with 4 CUs.; // For texture sampling, the address generation unit receives 4 texture; // addresses per cycle, thus we could expect texture sampling latency to be; // equivalent to 4 instructions in the very best case (a VGPR is 64 work items,; // instructions in a wavefront group are executed every 4 cycles),; // or 16 instructions if the other wavefronts associated to the 3 other VALUs; // of the CU do texture sampling too. (Don't take these figures too seriously,; // as I'm not 100% sure of the computation); // Data exports should get similar latency.; // For constant loading, the cache is shader with 4 CUs.; // The doc says ""a throughput of 16B/cycle for each of the 4 Compute Unit""; // I guess if the other CU don't read the cache, it can go up to 64B/cycle.; // It means a simple s_buffer_load should take one instruction to hide, as; // well as a s_buffer_loadx2 and potentially a s_buffer_loadx8 if on the same; // cache line.; //; // As of today the driver doesn't preload the constants in cache, thus the; // first loads get extra latency. The doc says global memory access can be; // 300-600 cycles. We do not specially take that into account when scheduling; // As we expect the driver to be able to preload the constants soon.; // common code //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:4532,latency,latency,4532,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,9,"['cache', 'latency', 'load', 'throughput']","['cache', 'latency', 'loading', 'loads', 'throughput']"
Performance,"ck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; /// +----> 2. vhaddps %xmm3, %xmm3, %xmm4 ## REGISTER dependency: %xmm3; /// |; /// | < loop carried > ; /// |; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; ///; ///; /// The algorithm that computes the critical sequence is very similar to a; /// critical path analysis.; /// ; /// A dependency graph is used internally to track dependencies between nodes.; /// Nodes of the graph represent instructions from the input assembly sequence,; /// and edges of the graph represent data dependencies or processor resource; /// interferences.; ///; /// Edges are dynamically 'discovered' by observing instruction state; /// transitions and backend pressure increase events. Edges are internally; /// ranked based on their ""criticality"". A dependency is considered to be; /// critical if it takes a long time to execute, and if it contributes to; /// backend pressure increases. Criticality is internally measured in terms of; /// cycles; it is computed for every edge in the graph as a function of the edge; /// latency and the number of backend pressure increase cycles contributed by; /// that edge.; ///; /// At the end of simulation, costs are propagated to nodes through the edges of; /// the graph, and the most expensive path connecting the root-set (a; /// set of nodes with no predecessors) to a leaf node is reported as critical; /// sequence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:3141,latency,latency,3141,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,1,['latency'],['latency']
Performance,cking up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDSEED. IWKey was not loaded; /// ZF := 1; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:2020,load,loaded,2020,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,1,['load'],['loaded']
Performance,"code by having each thread write/modify a different; processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot(). ### Parallel execution of multiple RDataFrame event loops; A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");. // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop. // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ~~~. ### Performance considerations. To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; should be preferred for performance-critical applications. Python applications cannot easily specify template parameters or pass C++ callables to ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:51110,multi-thread,multi-thread,51110,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,2,['multi-thread'],['multi-thread']
Performance,"collection of TGraph (or derived) objects. - [Introduction](\ref MG00); - [MultiGraphs' drawing](\ref MG01); - [Setting drawing options](\ref MG01a); - [Titles setting](\ref MG01b); - [The option \""3D\""](\ref MG01c); - [Legend drawing](\ref MG01d); - [Automatic coloring](\ref MG01e); - [Reverse axis](\ref MG01f); - [MultiGraphs' fitting](\ref MG02); - [Fit box position](\ref MG02a); - [Axis' limits setting](\ref MG03). \anchor MG00; ### Introduction. A TMultiGraph allows to manipulate a set of graphs as a single entity. In particular,; when drawn, the X and Y axis ranges are automatically computed such as all the graphs; will be visible. `TMultiGraph::Add` should be used to add a new graph to the list. The TMultiGraph owns the objects in the list. The number of graphs in a multigraph can be retrieve with:; ~~~ {.cpp}; mg->GetListOfGraphs()->GetEntries();; ~~~. \anchor MG01; ### MultiGraphs' Drawing. The drawing options are the same as for TGraph.; Like for TGraph, the painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. Example:; ~~~ {.cpp}; TGraph *gr1 = new TGraph(...; TGraphErrors *gr2 = new TGraphErrors(...; TMultiGraph *mg = new TMultiGraph();; mg->Add(gr1,""lp"");; mg->Add(gr2,""cp"");; mg->Draw(""a"");; ~~~. \anchor MG01a; #### Setting drawing options. The drawing option for each TGraph may be specified as an optional; second argument of the `Add` function. If a draw option is specified, it will be used to draw the graph,; otherwise the graph will be drawn with the option specified in; `TMultiGraph::Draw`. \anchor MG01b; #### Titles setting. The global title and the axis titles can be modified the following way:. ~~~ {.cpp}; [...]; auto mg = new TMultiGraph;; mg->SetTitle(""title;xaxis title; yaxis title"");; mg->Add(g1);; mg->Add(g2);; mg->Draw(""apl"");; ~~~. \anchor MG01c; #### The option ""3D"". A special option `3D` allows to draw the graphs in a 3D space. See the; following example:. Begin",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:1144,perform,performed,1144,hist/hist/src/TMultiGraph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx,1,['perform'],['performed']
Performance,"common problems connected with correct peak identification are:; ///; /// - non-sensitivity to noise, i.e., only statistically; /// relevant peaks should be identified.; /// - non-sensitivity of the algorithm to continuous; /// background.; /// - ability to identify peaks close to the edges of the; /// spectrum region. Usually peak finders fail to detect them.; /// - resolution, decomposition of Double_tts and multiplets.; /// The algorithm should be able to recognise close positioned peaks.; /// - ability to identify peaks with different sigma.; ///; /// \image html TSpectrum_Searching1.jpg Fig. 27 An example of one-dimensional synthetic spectrum with found peaks denoted by markers.; ///; /// #### References:; ///; /// 1. M.A. Mariscotti: A method for identification of peaks in the presence of; /// background and its application to spectrum analysis. NIM 50 (1967),; /// 309-320.; /// 2. M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky,; /// I. Turzo.:Identification of peaks in; /// multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; /// 3. Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM; /// A 376 (1996), 451.; ///; /// Examples of peak searching method:; ///; /// The SearchHighRes function provides users with the possibility to vary the; /// input parameters and with the access to the output deconvolved data in the; /// destination spectrum. Based on the output data one can tune the parameters.; ///; /// ### Example 15 - script SearchHR1.C:; ///; /// One-dimensional spectrum with found peaks denoted by markers, 3 iterations; /// steps in the deconvolution.; ///; /// #### Script:; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/SearchHR1.C; /// End_Macro; ///; /// ### Example 16 - script SearchHR3.C:; ///; /// Influence of number of iterations (3-red, 10-blue, 100- green, 1000-magenta),; /// sigma=8, smoothing width=3.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/SearchHR3.C; /// End_Macro",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:3225,tune,tune,3225,hist/spectrum/src/TSpectrum.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx,1,['tune'],['tune']
Performance,"cond the order of the instructions inside the blocks is chosen.; // At that step we do take into account only register usage and hiding; // low latency instructions; //; // Third the block order is chosen, there we try to hide high latencies; // and keep register usage low.; //; // After the third step, a pass is done to improve the hiding of low; // latencies.; //; // Actually when talking about 'low latency' or 'high latency' it includes; // both the latency to get the cache (or global mem) data go to the register,; // and the bandwidth limitations.; // Increasing the number of active wavefronts helps hide the former, but it; // doesn't solve the latter, thus why even if wavefront count is high, we have; // to try have as many instructions hiding high latencies as possible.; // The OpenCL doc says for example latency of 400 cycles for a global mem; // access, which is hidden by 10 instructions if the wavefront count is 10.; // Some figures taken from AMD docs:; // Both texture and constant L1 caches are 4-way associative with 64 bytes; // lines.; // Constant cache is shared with 4 CUs.; // For texture sampling, the address generation unit receives 4 texture; // addresses per cycle, thus we could expect texture sampling latency to be; // equivalent to 4 instructions in the very best case (a VGPR is 64 work items,; // instructions in a wavefront group are executed every 4 cycles),; // or 16 instructions if the other wavefronts associated to the 3 other VALUs; // of the CU do texture sampling too. (Don't take these figures too seriously,; // as I'm not 100% sure of the computation); // Data exports should get similar latency.; // For constant loading, the cache is shader with 4 CUs.; // The doc says ""a throughput of 16B/cycle for each of the 4 Compute Unit""; // I guess if the other CU don't read the cache, it can go up to 64B/cycle.; // It means a simple s_buffer_load should take one instruction to hide, as; // well as a s_buffer_loadx2 and potentially a s_buffer_load",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:3898,cache,caches,3898,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['cache'],['caches']
Performance,"const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The index of the least significant set bit. \n; /// 1: The index of the most significant set bit. \n; /// \returns Returns an integer representing the result index of the comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1785,perform,perform,1785,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,1,['perform'],['perform']
Performance,"containing the script. It uses the; /// directive fMakeExe to do so.; /// For both directives, before passing them to TSystem::Exec, it expands the; /// variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs,; /// $DepLibs, $ExeName and $ObjectFiles. See SetMakeSharedLib() for more; /// information on those variables.; ///; /// This method is used to implement the following feature:; ///; /// Synopsis:; ///; /// The purpose of this addition is to allow the user to use an external; /// compiler to create a shared library from its C++ macro (scripts).; /// Currently in order to execute a script, a user has to type at the root; /// prompt; /// ~~~ {.cpp}; /// .X myfunc.C(arg1,arg2); /// ~~~; /// We allow them to type:; /// ~~~ {.cpp}; /// .X myfunc.C++(arg1,arg2); /// ~~~; /// or; /// ~~~ {.cpp}; /// .X myfunc.C+(arg1,arg2); /// ~~~; /// In which case an external compiler will be called to create a shared; /// library. This shared library will then be loaded and the function; /// myfunc will be called with the two arguments. With '++' the shared library; /// is always recompiled. With '+' the shared library is recompiled only; /// if it does not exist yet or the macro file is newer than the shared; /// library.; ///; /// Of course the + and ++ notation is supported in similar way for .x and .L.; ///; /// Through the function TSystem::SetMakeSharedLib(), the user will be able to; /// indicate, with shell commands, how to build a shared library (a good; /// default will be provided). The most common change, namely where to find; /// header files, will be available through the function; /// TSystem::SetIncludePath().; /// A good default will be provided so that a typical user session should be at; /// most:; /// ~~~ {.cpp}; /// root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; /// -I$HOME/mypackage/include"");; /// root[2] .x myfunc.C++(10,20);; /// ~~~; /// The user may sometimes try to compile a script before it has loaded all the; /// needed shared l",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:3227,load,loaded,3227,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['load'],['loaded']
Performance,"crete implementation of the NeymanConstruction; interface that, as the name suggests, performs a NeymanConstruction. It produces; a RooStats::PointSetInterval, which is a concrete implementation of the; ConfInterval interface. The Neyman Construction is not a uniquely defined statistical technique, it; requires that one specify an ordering rule or ordering principle, which is; usually incoded by choosing a specific test statistic and limits of integration; (corresponding to upper/lower/central limits). As a result, this class must be; configured with the corresponding information before it can produce an interval.; Common configurations, such as the Feldman-Cousins approach, can be enforced by; other light weight classes. The Neyman Construction considers every point in the parameter space; independently, no assumptions are made that the interval is connected or of a; particular shape. As a result, the PointSetInterval class is used to represent; the result. The user indicate which points in the parameter space to perform; the construction by providing a PointSetInterval instance with the desired points. This class is fairly light weight, because the choice of parameter points to be; considered is factorized and so is the creation of the sampling distribution of; the test statistic (which is done by a concrete class implementing the; DistributionCreator interface). As a result, this class basically just drives the; construction by:. - using a DistributionCreator to create the SamplingDistribution of a user-; defined test statistic for each parameter point of interest,; - defining the acceptance region in the data by finding the thresholds on the; test statistic such that the integral of the sampling distribution is of the; appropriate size and consistent with the limits of integration; (eg. upper/lower/central limits),; - and finally updating the PointSetInterval based on whether the value of the; test statistic evaluated on the data are in the acceptance region. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/NeymanConstruction.cxx:1540,perform,perform,1540,roofit/roostats/src/NeymanConstruction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/NeymanConstruction.cxx,1,['perform'],['perform']
Performance,"ct in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method; ~~~ {.cpp}; PreferLocalFrame(); ~~~. If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements. For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object. As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. ## Scene Rebuilds. It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. - It already has the object internally cached .; - The object falls outside some 'interest' limits of the viewer camera.; - The object is too small to be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should not try to make any assumptions about what the viewer did with it. This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via a TPad; repaint at present), and thus collect these objects if the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualViewer3D.cxx:8896,cache,cached,8896,core/base/src/TVirtualViewer3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualViewer3D.cxx,1,['cache'],['cached']
Performance,"ction to be executed takes more than; /// zero/one argument but all are fixed except zero/one, the function can be wrapped; /// in a lambda or via std::bind to give it the right signature.\n; ///; /// #### Return value:; /// An std::vector. The elements in the container; /// will be the objects returned by func. The ordering of the elements corresponds to the ordering of; /// the arguments.; ///; /// ### ROOT::TExecutorCRTP<SubC>::Reduce; /// These set of methods combine all elements from a std::vector into a single value.; /// \param redfunc; /// \parblock; /// a callable object, such as a lambda expression, an std::function, a; /// functor object or a function that takes an std::vector and combines all its elements into a single result.\n; /// \endparblock; /// \param [args]; /// \parblock; /// a standard vector\n; /// \endparblock; ///; /// ### ROOT::TExecutorCRTP<SubC>::MapReduce; /// This set of methods behaves exactly like Map, but takes an additional; /// function as a third argument. This function is applied to the set of; /// objects returned by the corresponding Map execution to ""squash"" them; /// into a single object. This function should be independent of the size of; /// the vector returned by Map due to optimization of the number of chunks.; ///; /// #### Examples:; /// ~~~{.cpp}; /// Generate 1 ten times and sum those tens; /// root[] ROOT::TProcessExecutor pool; auto ten = pool.MapReduce([]() { return 1; }, 10, [](const std::vector<int> &v) { return std::accumulate(v.begin(), v.end(), 0); }); /// root[] ROOT::TProcessExecutor pool; auto tenOnes = pool.Map([]() { return 1; }, 10); auto ten = Reduce([](const std::vector<int> &v) { return std::accumulate(v.begin(), v.end(), 0); }, tenOnes); ///; /// Create 10 histograms and merge them into one; /// root[] ROOT::TThreadExecutor pool; auto hist = pool.MapReduce(CreateAndFillHists, 10, PoolUtils::ReduceObjects);; ///; /// ~~~; ///; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/ROOT/TExecutorCRTP.hxx:2851,optimiz,optimization,2851,core/base/inc/ROOT/TExecutorCRTP.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/ROOT/TExecutorCRTP.hxx,1,['optimiz'],['optimization']
Performance,"ction using; // ""!tbaa"" are called path tag nodes.; //; // The path tag node has 4 fields with the last field being optional.; //; // The first field is the base type node, it can be a struct type node; // or a scalar type node. The second field is the access type node, it; // must be a scalar type node. The third field is the offset into the base type.; // The last field has the same meaning as the last field of our scalar TBAA:; // it's an integer which if equal to 1 indicates that the access is ""constant"".; //; // The struct type node has a name and a list of pairs, one pair for each member; // of the struct. The first element of each pair is a type node (a struct type; // node or a scalar type node), specifying the type of the member, the second; // element of each pair is the offset of the member.; //; // Given an example; // typedef struct {; // short s;; // } A;; // typedef struct {; // uint16_t s;; // A a;; // } B;; //; // For an access to B.a.s, we attach !5 (a path tag node) to the load/store; // instruction. The base type is !4 (struct B), the access type is !2 (scalar; // type short) and the offset is 4.; //; // !0 = !{!""Simple C/C++ TBAA""}; // !1 = !{!""omnipotent char"", !0} // Scalar type node; // !2 = !{!""short"", !1} // Scalar type node; // !3 = !{!""A"", !2, i64 0} // Struct type node; // !4 = !{!""B"", !2, i64 0, !3, i64 4}; // // Struct type node; // !5 = !{!4, !2, i64 4} // Path tag node; //; // The struct type nodes and the scalar type nodes form a type DAG.; // Root (!0); // char (!1) -- edge to Root; // short (!2) -- edge to char; // A (!3) -- edge with offset 0 to short; // B (!4) -- edge with offset 0 to short and edge with offset 4 to A; //; // To check if two tags (tagX and tagY) can alias, we start from the base type; // of tagX, follow the edge with the correct offset in the type DAG and adjust; // the offset until we reach the base type of tagY or until we reach the Root; // node.; // If we reach the base type of tagY, compare the adjusted of",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:3302,load,load,3302,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,1,['load'],['load']
Performance,"ction(*:bar); /// for (int i = 0; i < N; i++) {; /// foo += A[i]; bar *= B[i];; /// }; ///; /// where 'foo' and 'bar' are reduced across all OpenMP threads in; /// all teams. In our OpenMP implementation on the NVPTX device an; /// OpenMP team is mapped to a CUDA threadblock and OpenMP threads; /// within a team are mapped to CUDA threads within a threadblock.; /// Our goal is to efficiently aggregate values across all OpenMP; /// threads such that:; ///; /// - the compiler and runtime are logically concise, and; /// - the reduction is performed efficiently in a hierarchical; /// manner as follows: within OpenMP threads in the same warp,; /// across warps in a threadblock, and finally across teams on; /// the NVPTX device.; ///; /// Introduction to Decoupling; ///; /// We would like to decouple the compiler and the runtime so that the; /// latter is ignorant of the reduction variables (number, data types); /// and the reduction operators. This allows a simpler interface; /// and implementation while still attaining good performance.; ///; /// Pseudocode for the aforementioned OpenMP program generated by the; /// compiler is as follows:; ///; /// 1. Create private copies of reduction variables on each OpenMP; /// thread: 'foo_private', 'bar_private'; /// 2. Each OpenMP thread reduces the chunk of 'A' and 'B' assigned; /// to it and writes the result in 'foo_private' and 'bar_private'; /// respectively.; /// 3. Call the OpenMP runtime on the GPU to reduce within a team; /// and store the result on the team master:; ///; /// __kmpc_nvptx_parallel_reduce_nowait_v2(...,; /// reduceData, shuffleReduceFn, interWarpCpyFn); ///; /// where:; /// struct ReduceData {; /// double *foo;; /// double *bar;; /// } reduceData; /// reduceData.foo = &foo_private; /// reduceData.bar = &bar_private; ///; /// 'shuffleReduceFn' and 'interWarpCpyFn' are pointers to two; /// auxiliary functions generated by the compiler that operate on; /// variables of type 'ReduceData'. They aid the runtim",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:1289,perform,performance,1289,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['perform'],['performance']
Performance,"ctions are passed via param space,; // which imposes certain restrictions:; // http://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces; //; // Kernel parameters are read-only and accessible only via ld.param; // instruction, directly or via a pointer. Pointers to kernel; // arguments can't be converted to generic address space.; //; // Device function parameters are directly accessible via; // ld.param/st.param, but taking the address of one returns a pointer; // to a copy created in local space which *can't* be used with; // ld.param/st.param.; //; // Copying a byval struct into local memory in IR allows us to enforce; // the param space restrictions, gives the rest of IR a pointer w/o; // param space restrictions, and gives us an opportunity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global addre",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:1416,optimiz,optimizations,1416,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,1,['optimiz'],['optimizations']
Performance,"d (interpreted or compiled, see below),; /// filename must contain a valid class implementation derived from TSelector,; /// where TSelector has the following member functions:; ///; /// - Begin(): called every time a loop on the tree starts,; /// a convenient place to create your histograms.; /// - SlaveBegin(): called after Begin(), when on PROOF called only on the; /// slave servers.; /// - Process(): called for each event, in this function you decide what; /// to read and fill your histograms.; /// - SlaveTerminate: called at the end of the loop on the tree, when on PROOF; /// called only on the slave servers.; /// - Terminate(): called at the end of the loop on the tree,; /// a convenient place to draw/fit your histograms.; ///; /// If filename is of the form file.C, the file will be interpreted.; /// If filename is of the form file.C++, the file file.C will be compiled; /// and dynamically loaded.; ///; /// If filename is of the form file.C+, the file file.C will be compiled; /// and dynamically loaded. At next call, if file.C is older than file.o; /// and file.so, the file.C is not compiled, only file.so is loaded.; ///; /// ### NOTE 1; /// It may be more interesting to invoke directly the other Process function; /// accepting a TSelector* as argument.eg; /// ~~~{.cpp}; /// MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; /// selector->CallSomeFunction(..);; /// mytree.Process(selector,..);; /// ~~~; /// ### NOTE 2; /// One should not call this function twice with the same selector file; /// in the same script. If this is required, proceed as indicated in NOTE1,; /// by getting a pointer to the corresponding TSelector,eg; ///#### workaround 1; /// ~~~{.cpp}; ///void stubs1() {; /// TSelector *selector = TSelector::GetSelector(""h1test.C"");; /// TFile *f1 = new TFile(""stubs_nood_le1.root"");; /// TTree *h1 = (TTree*)f1->Get(""h1"");; /// h1->Process(selector);; /// TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; /// TTree *h2 = (TTree*)f",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx:1316,load,loaded,1316,tree/treeplayer/src/TTreePlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx,1,['load'],['loaded']
Performance,"d ...; // exn = wasm.catch(WebAssembly::CPP_EXCEPTION);; // // Only add below in case it's not a single catch (...); // wasm.landingpad.index(index);; // __wasm_lpad_context.lpad_index = index;; // __wasm_lpad_context.lsda = wasm.lsda();; // _Unwind_CallPersonality(exn);; // selector = __wasm_lpad_context.selector;; // ...; //; //; // * Background: Direct personality function call; // In WebAssembly EH, the VM is responsible for unwinding the stack once an; // exception is thrown. After the stack is unwound, the control flow is; // transfered to WebAssembly 'catch' instruction.; //; // Unwinding the stack is not done by libunwind but the VM, so the personality; // function in libcxxabi cannot be called from libunwind during the unwinding; // process. So after a catch instruction, we insert a call to a wrapper function; // in libunwind that in turn calls the real personality function.; //; // In Itanium EH, if the personality function decides there is no matching catch; // clause in a call frame and no cleanup action to perform, the unwinder doesn't; // stop there and continues unwinding. But in Wasm EH, the unwinder stops at; // every call frame with a catch intruction, after which the personality; // function is called from the compiler-generated user code here.; //; // In libunwind, we have this struct that serves as a communincation channel; // between the compiler-generated user code and the personality function in; // libcxxabi.; //; // struct _Unwind_LandingPadContext {; // uintptr_t lpad_index;; // uintptr_t lsda;; // uintptr_t selector;; // };; // struct _Unwind_LandingPadContext __wasm_lpad_context = ...;; //; // And this wrapper in libunwind calls the personality function.; //; // _Unwind_Reason_Code _Unwind_CallPersonality(void *exception_ptr) {; // struct _Unwind_Exception *exception_obj =; // (struct _Unwind_Exception *)exception_ptr;; // _Unwind_Reason_Code ret = __gxx_personality_v0(; // 1, _UA_CLEANUP_PHASE, exception_obj->exception_class, exception_",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp:1920,perform,perform,1920,interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WasmEHPrepare.cpp,1,['perform'],['perform']
Performance,"d VarLocBasedImpl.cpp for more information.; ///; /// This pass propagates variable locations between basic blocks, resolving; /// control flow conflicts between them. The problem is SSA construction, where; /// each debug instruction assigns the *value* that a variable has, and every; /// instruction where the variable is in scope uses that variable. The resulting; /// map of instruction-to-value is then translated into a register (or spill); /// location for each variable over each instruction.; ///; /// The primary difference from normal SSA construction is that we cannot; /// _create_ PHI values that contain variable values. CodeGen has already; /// completed, and we can't alter it just to make debug-info complete. Thus:; /// we can identify function positions where we would like a PHI value for a; /// variable, but must search the MachineFunction to see whether such a PHI is; /// available. If no such PHI exists, the variable location must be dropped.; ///; /// To achieve this, we perform two kinds of analysis. First, we identify; /// every value defined by every instruction (ignoring those that only move; /// another value), then re-compute an SSA-form representation of the; /// MachineFunction, using value propagation to eliminate any un-necessary; /// PHI values. This gives us a map of every value computed in the function,; /// and its location within the register file / stack.; ///; /// Secondly, for each variable we perform the same analysis, where each debug; /// instruction is considered a def, and every instruction where the variable; /// is in lexical scope as a use. Value propagation is used again to eliminate; /// any un-necessary PHIs. This gives us a map of each variable to the value; /// it should have in a block.; ///; /// Once both are complete, we have two maps for each block:; /// * Variables to the values they should have,; /// * Values to the register / spill slot they are located in.; /// After which we can marry-up variable values with a lo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:1504,perform,perform,1504,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['perform'],['perform']
Performance,"d before; * calling exec() in the child. %G_SPAWN_SEARCH_PATH means that; * <literal>argv[0]</literal> need not be an absolute path, it; * will be looked for in the user's PATH. %G_SPAWN_STDOUT_TO_DEV_NULL; * means that the child's standad output will be discarded, instead; * of going to the same location as the parent's standard output.; * %G_SPAWN_STDERR_TO_DEV_NULL means that the child's standard error; * will be discarded. %G_SPAWN_CHILD_INHERITS_STDIN means that; * the child will inherit the parent's standard input (by default,; * the child's standard input is attached to /dev/null).; * %G_SPAWN_FILE_AND_ARGV_ZERO means that the first element of @argv is; * the file to execute, while the remaining elements are the; * actual argument vector to pass to the file. Normally; * g_spawn_async_with_pipes() uses @argv[0] as the file to execute, and; * passes all of @argv to the child.; *; * @child_setup and @user_data are a function and user data to be; * called in the child after GLib has performed all the setup it plans; * to perform (including creating pipes, closing file descriptors,; * etc.) but before calling exec(). That is, @child_setup is called; * just before calling exec() in the child. Obviously actions taken in; * this function will only affect the child, not the parent. ; *; * If non-NULL, @child_pid will be filled with the child's process; * ID. You can use the process ID to send signals to the child, or; * to waitpid() if you specified the %G_SPAWN_DO_NOT_REAP_CHILD flag.; *; * If non-NULL, the @standard_input, @standard_output, @standard_error; * locations will be filled with file descriptors for writing to the child's; * standard input or reading from its standard output or standard error.; * The caller of g_spawn_async_with_pipes() must close these file descriptors; * when they are no longer in use. If these parameters are NULL, the; * corresponding pipe won't be created.; *; * @error can be NULL to ignore errors, or non-NULL to report errors.; * If an",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gspawn.c:2943,perform,performed,2943,graf2d/win32gdk/gdk/src/glib/gspawn.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gspawn.c,2,['perform'],"['perform', 'performed']"
Performance,"d of the event loop.; void Finalize(); {; *fFinalResult = std::accumulate(fPerThreadResults.begin(), fPerThreadResults.end(), 0);; }. // Called by RDataFrame to retrieve the name of this action.; std::string GetActionName() const { return ""MyCounter""; }; };. int main() {; ROOT::RDataFrame df(10);; ROOT::RDF::RResultPtr<int> resultPtr = df.Book<>(MyCounter{df.GetNSlots()}, {});; // The GetValue call triggers the event loop; std::cout << ""Number of processed entries: "" << resultPtr.GetValue() << std::endl;; }; ~~~. See the Book() method for more information and [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html); for a more complete example. #### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(). Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; executes the callable on the values of those columns for each event that passes all upstream selections.; It can be used to perform actions that are not already available in the interface. For example, the following snippet; evaluates the root mean square of column ""x"":; ~~~{.cpp}; // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; thread will execute the expression concurrently.; The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; this is probably too much head-scratch for such a simple operation. ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; guarantees that ForeachSlot() will invoke the user expression wit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:69494,perform,perform,69494,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['perform'],['perform']
Performance,"d on set of functions. It was made through; // special function comparison procedure that returns; // 0 when functions are equal,; // -1 when Left function is less than right function, and; // 1 for opposite case. We need total-ordering, so we need to maintain; // four properties on the functions set:; // a <= a (reflexivity); // if a <= b and b <= a then a = b (antisymmetry); // if a <= b and b <= c then a <= c (transitivity).; // for all a and b: a <= b or b <= a (totality).; //; // Comparison iterates through each instruction in each basic block.; // Functions are kept on binary tree. For each new function F we perform; // lookup in binary tree.; // In practice it works the following way:; // -- We define Function* container class with custom ""operator<"" (FunctionPtr).; // -- ""FunctionPtr"" instances are stored in std::set collection, so every; // std::set::insert operation will give you result in log(N) time.; //; // As an optimization, a hash of the function structure is calculated first, and; // two functions are only compared if they have the same hash. This hash is; // cheap to compute, and has the property that if function F == G according to; // the comparison function, then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:1430,optimiz,optimization,1430,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,1,['optimiz'],['optimization']
Performance,"d results. This poses the challenge that the; event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");. // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop. // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ~~~. ### Performance considerations. To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; should be preferred for performance-critical applications. Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case. Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; before the first event loop is",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:51406,Perform,Performance,51406,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['Perform'],['Performance']
Performance,"d sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %s.sink = phi [%st, if.then], [%se, if.else]; // <...>; // store %s.sink, %addr_s; // <...>; //; //; //===----------------------- TODO -----------------------------------------===//; //; // 1) Generalize to regions other than diamonds; // 2) Be more aggressive merging memory operations; // Note that both changes require register pressure control; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1566,load,load,1566,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,3,['load'],['load']
Performance,"d that one needs to be generated.; ///; /// *NOTE* The following is a high level documentation of SelectionDAG Stack; /// Protector Generation. This is now also ported be shared with GlobalISel,; /// but without any significant changes.; ///; /// High Level Overview of ISel Stack Protector Generation:; ///; /// Previously, the ""stack protector"" IR pass handled stack protector; /// generation. This necessitated splitting basic blocks at the IR level to; /// create the success/failure basic blocks in the tail of the basic block in; /// question. As a result of this, calls that would have qualified for the; /// sibling call optimization were no longer eligible for optimization since; /// said calls were no longer right in the ""tail position"" (i.e. the immediate; /// predecessor of a ReturnInst instruction).; ///; /// Since the sibling call optimization causes the callee to reuse the caller's; /// stack, if we could delay the generation of the stack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point were not true, the decision on whether to; /// perform a tail call is done in LowerCallTo in SelectionDAG (or; /// CallLowerin",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:973,optimiz,optimization,973,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,2,['optimiz'],['optimization']
Performance,"d!')"" );; /// Hello World!; ///; /// // Create a TNamed on the python side, and transfer it back and forth.; /// root [1] std::any res1;; /// root [2] TPython::Exec(""_anyresult = ROOT.std.make_any['TNamed']('hello', '')"", &res1);; /// root [3] TPython::Bind(&std::any_cast<TNamed&>(res1), ""n"");; /// root [4] std::any res2;; /// root [5] TPython::Exec(""_anyresult = ROOT.std.make_any['TNamed*', 'TNamed*'](n)"", &res2);; /// root [6] (&std::any_cast<TNamed&>(res1) == std::any_cast<TNamed*>(res2)); /// (bool) true; ///; /// // Variables can cross-over by using an `std::any` with a specific name.; /// root [6] TPython::Exec(""_anyresult = ROOT.std.make_any['Int_t'](1 + 1)"", &res1);; /// root [7] std::any_cast<int>(res1); /// (int) 2; /// ~~~; ///; /// And with a python file `MyPyClass.py` like this:; /// ~~~{.py}; /// print 'creating class MyPyClass ... '; ///; /// class MyPyClass:; /// def __init__( self ):; /// print 'in MyPyClass.__init__'; ///; /// def gime( self, what ):; /// return what; /// ~~~; /// one can load a python module, and use the class. Casts are; /// necessary as the type information can not be otherwise derived.; /// ~~~{.cpp}; /// root [6] TPython::LoadMacro( ""MyPyClass.py"" );; /// creating class MyPyClass ...; /// root [7] MyPyClass m;; /// in MyPyClass.__init__; /// root [8] std::string s = (char*)m.gime( ""aap"" );; /// root [9] s; /// (class TString)""aap""; /// ~~~; /// It is possible to switch between interpreters by calling `TPython::Prompt()`; /// on the Cling side, while returning with `^D` (EOF). State is preserved between; /// successive switches.; ///; /// The API part provides (direct) C++ access to the bindings functionality of; /// PyROOT. It allows verifying that you deal with a PyROOT python object in the; /// first place (CPPInstance_Check for CPPInstance and any derived types, as well; /// as CPPInstance_CheckExact for CPPInstance's only); and it allows conversions; /// of `void*` to an CPPInstance and vice versa.; //- data ---------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/tpython/src/TPython.cxx:1611,load,load,1611,bindings/tpython/src/TPython.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/tpython/src/TPython.cxx,1,['load'],['load']
Performance,"d, etc. --For multidimensional fitting, TFormulas of the form:; x[0]++...++x[n] can be used; ##### 2.2.2 There is no need to create the function if you don't want to,; the formula can be set by expression:; --Example:; ~~~~; // 2 is the number of dimensions; TLinearFitter *lf = new TLinearFitter(2);; lf->SetFormula(""x ++ y ++ x*x*y*y"");; ~~~~. ##### 2.2.3 The fastest functions to compute are polynomials and hyperplanes.; --Polynomials are set the usual way: ""pol1"", ""pol2"",...; --Hyperplanes are set by expression ""hyp3"", ""hyp4"", ...; ---The ""hypN"" expressions only work when the linear fitter; is used directly, not through TH1::Fit or TGraph::Fit.; To fit a graph or a histogram with a hyperplane, define; the function as ""1++x++y"".; ---A constant term is assumed for a hyperplane, when using; the ""hypN"" expression, so ""hyp3"" is in fact fitting with; ""1++x++y++z"" function.; --Fitting hyperplanes is much faster than fitting other; expressions so if performance is vital, calculate the; function values beforehand and give them to the fitter; as variables; --Example:; You want to fit ""sin(x)|cos(2*x)"" very fast. Calculate; sin(x) and cos(2*x) beforehand and store them in array *data.; Then:; TLinearFitter *lf=new TLinearFitter(2, ""hyp2"");; lf->AssignData(npoint, 2, data, y);. #### 2.3 Resetting the formula. ##### 2.3.1 If the input data is stored (or added via AssignData() function),; the fitting formula can be reset without re-adding all the points.; --Example:; ~~~~; TLinearFitter *lf=new TLinearFitter(""1++x++x*x"");; lf->AssignData(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();; ...; ~~~~. ##### 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. ### 3.Accessing the fit results. #### 3.1 There are methods in the fitter to access all rele",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TLinearFitter.cxx:4161,perform,performance,4161,math/minuit/src/TLinearFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TLinearFitter.cxx,1,['perform'],['performance']
Performance,"d.f F2(x). - One finds takes a value 'y' of both c.d.fs and determines the corresponding x; values x(1,2) at which F(1,2)(x)==y. - The value of the interpolated p.d.f fbar(x) is then calculated as; fbar(alpha*x1+(1-alpha)*x2) = f1(x1)*f2(x2) / ( alpha*f2(x2) + (1-alpha)*f1(x1) ) ;. From a technical point of view class RooIntegralMorph is a p.d.f that takes; two input p.d.fs f1(x,p) an f2(x,q) and an interpolation parameter to; make a p.d.f fbar(x,p,q,alpha). The shapes f1 and f2 are always taken; to be end the end-points of the parameter alpha, regardless of what; the those numeric values are. Since the value of fbar(x) cannot be easily calculated for a given value; of x, class RooIntegralMorph is an implementation of RooAbsCachedPdf and; calculates the shape of the interpolated p.d.f. fbar(x) for all values; of x for a given value of alpha,p,q and caches these values in a histogram; (as implemented by RooAbsCachedPdf). The binning granularity of the cache; can be controlled by the binning named ""cache"" on the RooRealVar representing; the observable x. The fbar sampling algorithm is based on a recursive division; mechanism with a built-in precision cutoff: First an initial sampling in; 64 equally spaced bins is made. Then the value of fbar is calculated in; the center of each gap. If the calculated value deviates too much from; the value obtained by linear interpolation from the edge bins, gap; is recursively divided. This strategy makes it possible to define a very; fine cache sampling (e.g. 1000 or 10000) bins without incurring a; corresponding CPU penalty. Note on numeric stability of the algorithm. Since the algorithm relies; on a numeric inversion of cumulative distributions functions, some precision; may be lost at the 'edges' of the same (i.e. at regions in x where the; c.d.f. value is close to zero or one). The general sampling strategy is; to start with 64 equally spaces samples in the range y=(0.01-0.99).; Then the y ranges are pushed outward by reducing y ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx:1860,cache,cache,1860,roofit/roofit/src/RooIntegralMorph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx,2,['cache'],['cache']
Performance,"d; * it creates with fork().; *; * The channel is comrised of a small shared pool of buffer memory mmapped into; * both process spaces, and two pipes to synchronise the exchange of data. The; * idea behind using the pipes at all is to have some primitive which we can; * block on without having to worry about atomic operations or polling, leaving; * these tasks to the OS. In case the anonymous mmap cannot be performed on the; * OS the code is running on (for whatever reason), the code falls back to; * mmapping /dev/zero, mmapping a temporary file, or (if those all fail), a; * dynamically allocated buffer which is then transmitted through the pipe(s),; * a slightly slower alternative (because the data is copied more often).; *; * The channel supports five major operations: read(), write(), flush(),; * purge() and close(). Reading and writing may block until the required buffer; * space is available. Writes may queue up data to be sent to the other end; * until either enough pages are full, or the user calls flush which forces; * any unsent buffers to be sent to the other end. flush forces any data that; * is to be sent to be sent. purge discards any buffered data waiting to be; * read and/or sent. Closing the channel on the child returns zero, closing it; * on the parent returns the child's exit status.; *; * The class also provides operator<< and operator>> for C++-style I/O for; * basic data types (bool, char, short, int, long, long long, float, double; * and their unsigned counterparts). Data is transmitted binary (i.e. no; * formatting to strings like std::cout does). There are also overloads to; * support C-style zero terminated strings and std::string. In terms of; * performance, the former is to be preferred.; *; * If the caller needs to multiplex input and output to/from several pipes, the; * class provides the poll() method which allows to block until an event occurs; * on any of the polled pipes.; *; * After the BidirMMapPipe is closed, no further operations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h:1190,queue,queue,1190,roofit/roofitcore/src/BidirMMapPipe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h,1,['queue'],['queue']
Performance,"d; then use the transformed variable as input to this class [5] [6]. H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):. 1. Define \f$\mathbf{P} = (P_1, \ldots, P_5)\f$ are the 5 dependent; quantities that define a track.; 2. Compute, for \f$ M\f$ different values of \f$\mathbf{P}\f$, the tracks; through the magnetic field, and determine the corresponding; \f$\mathbf{x} = (x_1, \ldots, x_N)\f$.; 3. Use the simulated observations to determine, with a simple; approximation, the values of \f$\mathbf{P}_j\f$. We call these values; \f$\mathbf{P}^\prime_j, j = 1, \ldots, M\f$.; 4. Determine from \f$\mathbf{x}\f$ a set of at least five relevant; coordinates \f$\mathbf{x}^\prime\f$, using contrains, *or; alternative:*; 5. Perform a Principal Component Analysis (using TPrincipal), and use; to get a linear transformation \f$\mathbf{x} \rightarrow \mathbf{x}^\prime\f$, so that; \f$\mathbf{x}^\prime\f$ are constrained and linear independent.; 6. Perform a Principal Component Analysis on; \f$Q_i = P_i / P^\prime_i\, i = 1, \ldots, 5\f$, to get linear; indenpendent (among themselves, but not independent of \f$\mathbf{x}\f$) quantities; \f$\mathbf{Q}^\prime\f$; 7. For each component \f$Q^\prime_i\f$ make a multidimensional fit,; using \f$\mathbf{x}^\prime\f$ as the variables, thus determining a set of; coefficients \f$\mathbf{c}_i\f$. To process data, using this parameterisation, do; 1. Test wether the observation \f$\mathbf{x}\f$ within the domain of; the parameterization, using the result from the Principal Component; Analysis.; 2. Determine \f$\mathbf{P}^\prime\f$ as before.; 3. Determine \f$\mathbf{x}^\prime\f$ as before.; 4. Use the result of the fit to determine \f$\mathbf{Q}^\prime\f$.; 5. Transform back to \f$\mathbf{P}\f$ from \f$\mathbf{Q}^\prime\f$, using; the result from the Principal Component Analysis. ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:15112,Perform,Perform,15112,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['Perform'],['Perform']
Performance,"default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. The usage of a TTreeCache can considerably improve the runtime performance at; the price of a modest investment in memory, in particular when the TTree is; accessed remotely, e.g. via a high latency network. For each TTree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted.; The user can change the size of the cache with the TTree::SetCacheSize method; (by default the size is 30 Megabytes). This feature can be controlled with the; environment variable `ROOT_TTREECACHE_SIZE` or the TTreeCache.Size option.; The entry range for which the cache is active can also be set with the; SetEntryRange method. \anchor changesbehaviour; ## Changes of behavior when using TChain and TEventList. The usage of TChain or TEventList have influence on the behaviour of the cache:. - Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. - Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning phase is started or restarted when:; - TTree automatically creates a cache.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTreeCache::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; - TTreeCache::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries.; - A 'cached' TChain switches over to a new file. \anchor cachemisses; ## Self-optimization in presence of cache misses. The TTreeCache can optimize its behavior ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:3857,cache,cache,3857,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"define palettes.; To store a palette in an array it is enough to do:. ~~~ {.cpp}; Int_t MyPalette[100];; Double_t Red[] = {0., 0.0, 1.0, 1.0, 1.0};; Double_t Green[] = {0., 0.0, 0.0, 1.0, 1.0};; Double_t Blue[] = {0., 1.0, 0.0, 0.0, 1.0};; Double_t Length[] = {0., .25, .50, .75, 1.0};; Int_t FI = TColor::CreateGradientColorTable(5, Length, Red, Green, Blue, 100);; for (int i=0;i<100;i++) MyPalette[i] = FI+i;; ~~~. Later on to reuse the palette `MyPalette` it will be enough to do. ~~~ {.cpp}; gStyle->SetPalette(100, MyPalette);; ~~~. As only one palette is active, one need to use `TExec` to be able to; display plots using different palettes on the same pad.; The tutorial multipalette.C illustrates this feature. Begin_Macro(source); ../../../tutorials/graphs/multipalette.C; End_Macro. \since **6.26:**; The function `TColor::CreateColorTableFromFile(""filename.txt"")` allows you to create a color; palette based on an input ASCII file. In contrast to `TColor::CreateGradientColorTable()`, here; the length (spacing) is constant and can not be tuned. There is no gradient being interpolated; between adjacent colors. The palette will contain the exact colors stored in the file, that; comprises one line per color in the format ""r g b"" as floats. \anchor C06; ## High quality predefined palettes; \since **6.04:**; 63 high quality palettes are predefined with 255 colors each. These palettes can be accessed ""by name"" with `gStyle->SetPalette(num)`.; `num` can be taken within the following enum:. ~~~ {.cpp}; kDeepSea=51, kGreyScale=52, kDarkBodyRadiator=53,; kBlueYellow= 54, kRainBow=55, kInvertedDarkBodyRadiator=56,; kBird=57, kCubehelix=58, kGreenRedViolet=59,; kBlueRedYellow=60, kOcean=61, kColorPrintableOnGrey=62,; kAlpine=63, kAquamarine=64, kArmy=65,; kAtlantic=66, kAurora=67, kAvocado=68,; kBeach=69, kBlackBody=70, kBlueGreenYellow=71,; kBrownCyan=72, kCMYK=73, kCandy=74,; kCherry=75, kCoffee=76, kDarkRainBow=77,; kDarkTerrain=78, kFall=79, kFruitPunch=80,; kFuchsia=81, kGrey",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx:8905,tune,tuned,8905,core/base/src/TColor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx,1,['tune'],['tuned']
Performance,"desired significance (width) of the error band; /// \param[in] params If non-zero, consider only the subset of the parameters in fr for the error evaluation; /// \param[in] argList Optional `RooCmdArg` that can be applied to a regular plotOn() operation; /// \param[in] linMethod By default (linMethod=true), a linearized error is shown.; /// \return The RooPlot the band was plotted on (for chaining of plotting commands).; ///; /// The linearized error is calculated as follows:; /// \f[; /// \mathrm{error}(x) = Z * F_a(x) * \mathrm{Corr}(a,a') * F_{a'}^\mathrm{T}(x),; /// \f]; ///; /// where; /// \f[; /// F_a(x) = \frac{ f(x,a+\mathrm{d}a) - f(x,a-\mathrm{d}a) }{2},; /// \f]; /// with \f$ f(x) \f$ the plotted curve and \f$ \mathrm{d}a \f$ taken from the fit result, and; /// \f$ \mathrm{Corr}(a,a') \f$ = the correlation matrix from the fit result, and \f$ Z \f$ = requested signifance (\f$ Z \sigma \f$ band); ///; /// The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; /// not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made; ///; /// Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; /// is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; /// from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; /// for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; /// that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); /// Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); /// longer to calculate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:2231,perform,perform,2231,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['perform'],['perform']
Performance,"dex, fRowIndex and; column index, fColIndex only for those elements unequal zero:. ~~~; fRowIndex[0,..,fNrows]: Stores for each row the index range of; the elements in the data and column array; fColIndex[0,..,fNelems-1]: Stores the column number for each data; element != 0; ~~~. As an example how to access all sparse data elements:. ~~~; for (Int_t irow = 0; irow < this->fNrows; irow++) {; const Int_t sIndex = fRowIndex[irow];; const Int_t eIndex = fRowIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = fColIndex[index];; const Element data = fElements[index];; printf(""data(%d,%d) = %.4e\n"",irow+this->fRowLwb,icol+; this->fColLwb,data);; }; }; ~~~. When checking whether sparse matrices are compatible (like in an; assignment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor from COO matrix format; ~~~; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; ~~~; It uses SetMatrixArray(..), see below; 2. constructor from Harwell-Boeing (CSR) matrix format; ~~~; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,; Int_t *rowptr, Int_t *col,Element *data);; ~~~; It copies input arrays into matrix .; 3. copy constructors; 4. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted. Be aware that the input data array will be modified; inside the routine for doing the necessary sorting of indices !; 5. SetMatrixArray(In",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixTSparse.cxx:1726,perform,performance,1726,math/matrix/src/TMatrixTSparse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixTSparse.cxx,1,['perform'],['performance']
Performance,"directories to be searched each.; * RETURN VALUE; * Pointer to ASImage structure holding image data on success.; * NULL on failure; * DESCRIPTION; * file2ASImage will attempt to interpret filename in the following way:; * 1)It will try to find file using unmodified filename in all the; * provided search paths.; * 2)It will attempt to append .gz and then .Z to the filename and; * find such file in all the provided search paths.; * 3)If filename ends with extension consisting of digits only - it will; * attempt to find file with this extension stripped off. On success; * this extension will be used to load subimage from the file with that; * number. Subimages are supported only for XCF, GIF, BMP, ICO and CUR; * files.; * After the file is found file2ASImage() attempts to detect file format,; * and if it is known it will load it into new ASImage structure.; * EXAMPLE; * asview.c: ASView.2; *********/; /****f* libAfterImage/import/get_asimage(); * NAME; * get_asimage() - increment reference counter if file is already loaded,; * or load image from file.; * SYNOPSIS; * ASImage *get_asimage( ASImageManager* imageman, const char *file,; * ASFlagType what, unsigned int compression );; * INPUTS; * imageman - pointer to valid ASVisual structure.; * file - root window ID for the destination screen.; * what - full image file's name with path.; * compression -; * RETURN VALUE; * Pointer to ASImage structure holding image data on success.; * NULL on failure; * DESCRIPTION; * get_asimage will attempt check with the ASImageManager's list of load; * images, and if image with requested filename already exists - it will; * increment its reference count and return its pointer.; * Otherwise it will call file2ASImage() to load image from file. It will; * use PATH and gamma values from the ASImageManager to pass to; * file2ASImage(). If image is successfully loaded - it will be added to; * the ASImageManager's list and its pointer will be returned.; * SEE ALSO; * file2ASImage(); *********/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.h:2056,load,load,2056,graf2d/asimage/src/libAfterImage/import.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.h,3,['load'],"['load', 'loaded']"
Performance,"don't require the original data to be present after the tree; has been built. Check the functions documentation for more details. #### 3b. Navigating the kd-tree. Nodes of the tree are indexed top to bottom, left to right. The root node has index 0. Functions; TKDTree::GetLeft(Index inode), TKDTree::GetRight(Index inode) and TKDTree::GetParent(Index inode); allow to find the children and the parent of a given node. For a given node, one can find the indexes of the original points, contained in this node,; by calling the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). ### 4. TKDtree implementation details - internal information, not needed to use the kd-tree. #### 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. - Drawback: Insertion to the TKDtree is not supported.; - Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; ~~~~; fAxis[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value; ~~~~. Given the index of a node in those arrays, it's e",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TKDTree.cxx:6325,optimiz,optimized,6325,math/mathcore/src/TKDTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TKDTree.cxx,1,['optimiz'],['optimized']
Performance,"e NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published in; // CUDA: Compiling and optimizing for a GPU platform; // Chakrabarti, Grover, Aarts, Kong, Kudlur, Lin, Marathe, Murphy, Wang; // ICCS 2012; //; // Then, address space inference replaces all refinable generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // which may create loops in the data flow graph. This brings two complications.; //; // First, the data flow analysis in Step 1 needs to be circular. For example,; // %generic.input = addrspacecast float addrspace(3)* %input to float*; // loop:; // %y = phi [ %generic.input, %y2 ]; // %y2 = getelementptr %y, 1; // %v = load %y2; // br ..., label %loop, ...; // proving %y specific requires proving both %generic.input and %y2 specific,; // but proving %y2 specific circles back to %y. To address this complication,; // the data flow analysis operates on a lattice:; // uninitialized > specific address spaces > generic.; // All address expressions (our implementation only considers phi, bitcast,; // addrspacecast, and getelementptr) start with the uninitialized address space.; // The monotone transfer function moves the address space of a pointer down a; // lattice path from uninitialized to specific and then to generic. A join; // operation of two different specific address spaces pushes the expression down; // to the generic address space. The analysis completes once it reaches a fixed; // point.; //; // Second, IR rewriting in Step 2 also needs to be circular. For example,; // converting %y to addrspace(3) requires the compiler to know the converted; // %y2, but converting %y2 needs the",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:3137,load,load,3137,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,1,['load'],['load']
Performance,"e dataset. Example usages include adding a column that contains the invariant mass of a particle, or a selection of elements of an array (e.g. only the `pt`s of ""good"" muons). |; | DefinePerSample() | Define a new column that is updated when the input sample changes, e.g. when switching tree being processed in a chain. |; | DefineSlot() | Same as Define(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Define() transformation when using RDataFrame after ROOT::EnableImplicitMT(). DefineSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; | DefineSlotEntry() | Same as DefineSlot(), but the entry number is passed in addition to the slot number. This is meant as a helper in case the expression depends on the entry number. For details about entry numbers in multi-threaded runs, see [here](\ref helper-cols). |; | Filter() | Filter rows based on user-defined conditions. |; | FilterAvailable() | Specialized Filter. If the value of the input column is available, keep the entry, otherwise discard it. |; | FilterMissing() | Specialized Filter. If the value of the input column is missing, keep the entry, otherwise discard it. |; | Range() | Filter rows based on entry number (single-thread only). |; | Redefine() | Overwrite the value and/or type of an existing column. See Define() for more information. |; | RedefineSlot() | Overwrite the value and/or type of an existing column. See DefineSlot() for more information. |; | RedefineSlotEntry() | Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. |; | Vary() | Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). |. ### Actions; Actions aggregate data into a result. Each one is described in more detail in",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:4572,multi-thread,multi-threaded,4572,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['multi-thread'],['multi-threaded']
Performance,"e fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes within the CGSCC walk,; /// and there we provide automatic update of the call graph including of the; /// pass manager to reflect call graph changes that fall out naturally as part; /// of scalar transformations.; ///; /// The patterns used to ensure the goals of post-order visitation of the fully; /// refined graph:; ///; /// 1) Sink toward the ""bottom"" as the graph is refined. This means that any; /// iteration continues in some valid post-order sequence after the mutation; /// has altered the structure.; ///; /// 2) Enqueue in post-o",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3620,optimiz,optimization,3620,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,1,['optimiz'],['optimization']
Performance,"e following member functions:; ///; /// - `Begin()`: called every time a loop on the tree starts,; /// a convenient place to create your histograms.; /// - `SlaveBegin()`: called after Begin(), when on PROOF called only on the; /// slave servers.; /// - `Process()`: called for each event, in this function you decide what; /// to read and fill your histograms.; /// - `SlaveTerminate`: called at the end of the loop on the tree, when on PROOF; /// called only on the slave servers.; /// - `Terminate()`: called at the end of the loop on the tree,; /// a convenient place to draw/fit your histograms.; ///; /// If filename is of the form file.C, the file will be interpreted.; ///; /// If filename is of the form file.C++, the file file.C will be compiled; /// and dynamically loaded.; ///; /// If filename is of the form file.C+, the file file.C will be compiled; /// and dynamically loaded. At next call, if file.C is older than file.o; /// and file.so, the file.C is not compiled, only file.so is loaded.; ///; /// ## NOTE1; ///; /// It may be more interesting to invoke directly the other Process function; /// accepting a TSelector* as argument.eg; /// ~~~ {.cpp}; /// MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; /// selector->CallSomeFunction(..);; /// mytree.Process(selector,..);; /// ~~~; /// ## NOTE2; //; /// One should not call this function twice with the same selector file; /// in the same script. If this is required, proceed as indicated in NOTE1,; /// by getting a pointer to the corresponding TSelector,eg; ///; /// ### Workaround 1; ///; /// ~~~ {.cpp}; /// void stubs1() {; /// TSelector *selector = TSelector::GetSelector(""h1test.C"");; /// TFile *f1 = new TFile(""stubs_nood_le1.root"");; /// TTree *h1 = (TTree*)f1->Get(""h1"");; /// h1->Process(selector);; /// TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; /// TTree *h2 = (TTree*)f2->Get(""h1"");; /// h2->Process(selector);; /// }; /// ~~~; /// or use ACLIC to compile the selector; ///; /// ### ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1446,load,loaded,1446,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['load'],['loaded']
Performance,"e functions, but also exposes new opportunities; // arising from specializations which return constant values or contain calls; // which can be specialized.; //; // Function Specialization supports propagating constant parameters like; // function pointers, literal constants and addresses of global variables.; // By propagating function pointers, indirect calls become direct calls. This; // exposes inlining opportunities which we would have otherwise missed. That's; // why function specialization is run before the inliner in the optimization; // pipeline; that is by design.; //; // Cost Model:; // -----------; // The cost model facilitates a utility for estimating the specialization bonus; // from propagating a constant argument. This is the InstCostVisitor, a class; // that inherits from the InstVisitor. The bonus itself is expressed as codesize; // and latency savings. Codesize savings means the amount of code that becomes; // dead in the specialization from propagating the constant, whereas latency; // savings represents the cycles we are saving from replacing instructions with; // constant values. The InstCostVisitor overrides a set of `visit*` methods to; // be able to handle different types of instructions. These attempt to constant-; // fold the instruction in which case a constant is returned and propagated; // further.; //; // Function pointers are not handled by the InstCostVisitor. They are treated; // separately as they could expose inlining opportunities via indirect call; // promotion. The inlining bonus contributes to the total specialization score.; //; // For a specialization to be profitable its bonus needs to exceed a minimum; // threshold. There are three options for controlling the threshold which are; // expressed as percentages of the original function size:; // * funcspec-min-codesize-savings; // * funcspec-min-latency-savings; // * funcspec-min-inlining-bonus; // There's also an option for controlling the codesize growth from recursive; // sp",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h:1836,latency,latency,1836,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h,1,['latency'],['latency']
Performance,"e gzip header will have no; file name, no extra data, no comment, no modification time (set to zero), no; header crc, and the operating system will be set to 255 (unknown). If a; gzip stream is being written, strm->adler is a crc32 instead of an adler32. The memLevel parameter specifies how much memory should be allocated; for the internal compression state. memLevel=1 uses minimum memory but is; slow and reduces compression ratio; memLevel=9 uses maximum memory for; optimal speed. The default value is 8. See zconf.h for total memory usage; as a function of windowBits and memLevel. The strategy parameter is used to tune the compression algorithm. Use the; value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a; filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no; string match), or Z_RLE to limit match distances to one (run-length; encoding). Filtered data consists mostly of small values with a somewhat; random distribution. In this case, the compression algorithm is tuned to; compress them better. The effect of Z_FILTERED is to force more Huffman; coding and less string matching; it is somewhat intermediate between; Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as; fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data. The; strategy parameter only affects the compression ratio but not the; correctness of the compressed output even if it is not set appropriately.; Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler; decoder for special applications. deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid; method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is; incompatible with the version assumed by the caller (ZLIB_VERSION). msg is; set to null if there is no error message. deflateInit2 does not perform any; compression: this will be done by deflate().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:2615,tune,tuned,2615,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,2,"['perform', 'tune']","['perform', 'tuned']"
Performance,"e in accordance with requested geometry.; * SYNOPSIS; * ASImage *pad_asimage( ASVisual *asv, ASImage *src,; * int dst_x, int dst_y,; * unsigned int to_width,; * unsigned int to_height,; * ARGB32 color,; * ASAltImFormats out_format,; * unsigned int compression_out, int quality );; * INPUTS; * asv - pointer to valid ASVisual structure; * src - source ASImage; * dst_x, dst_y - placement of the source image relative to the origin of; * destination image; * to_width - width of the destination image; * to_height - height of the destination image; * color - ARGB32 color value to pad with.; * out_format 	- optionally describes alternative ASImage format that; * should be produced as the result - XImage, ARGB32, etc.; * compression_out - compression level of resulting image in range 0-100.; * quality - output quality; * RETURN VALUE; * returns newly created and encoded ASImage on success, NULL of failure.; *********/; /****f* libAfterImage/transform/blur_asimage_gauss(); * NAME; * blur_asimage_gauss() Performs Gaussian blurr of the image ; * ( usefull for drop shadows and the likes ).; * SYNOPSIS; * ASImage* blur_asimage_gauss( ASVisual* asv, ASImage* src,; * double horz, double vert,; * ASAltImFormats out_format,; * unsigned int compression_out, ; * 								int quality );; * INPUTS; * asv - pointer to valid ASVisual structure; * src - source ASImage; * horz - horizontal radius of the blurr; * vert - vertical radius of the blurr; * out_format 	- optionally describes alternative ASImage format that; * should be produced as the result - XImage, ARGB32, etc.; * compression_out - compression level of resulting image in range 0-100.; * quality - output quality; * RETURN VALUE; * returns newly created and encoded ASImage on success, NULL of failure.; *********/; /****f* libAfterImage/transform/fill_asimage(); * NAME; * fill_asimage() - Fills rectangle within the existing ASImage with ; * specified color.; * SYNOPSIS; * Bool fill_asimage( ASVisual *asv, ASImage *im,; * int x, int y,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/transform.h:10198,Perform,Performs,10198,graf2d/asimage/src/libAfterImage/transform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/transform.h,1,['Perform'],['Performs']
Performance,"e independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes within the CGSCC walk,; /// and there we provide automatic update of the call graph including of the; /// pass manager to reflect call graph changes that fall out naturally as part; /// of scalar transformations.; ///; /// The p",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3235,cache,cache-based,3235,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,2,['cache'],"['cache-based', 'cached']"
Performance,"e information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file transforms calls of the current function (self recursion) followed; // by a return instruction with a branch to the entry of the function, creating; // a loop. This pass also implements the following extensions to the basic; // algorithm:; //; // 1. Trivial instructions between the call and return do not prevent the; // transformation from taking place, though currently the analysis cannot; // support moving any really useful instructions (only dead ones).; // 2. This pass transforms functions that are prevented from being tail; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's pos",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h:1128,perform,performed,1128,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h,2,['perform'],['performed']
Performance,"e into account the relative; ## predicted yields in those ranges.; ##; ## This is useful for example to represent a full-range fit, but with a; ## blinded signal region inside it.; ##; ##; ## ### 2. Shape+rate fits (extended likelihood); ##; ## If your pdf is extended, i.e. measuring both the distribution in the observable as well; ## as the event count in the fitted region, some intervention is needed to make fits in ranges; ## work in a way that corresponds to intuition.; ##; ## If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence; ## the expected event count will converge to a number that is smaller than what's visible in a plot.; ## In such cases, it is often preferred to interpret the extended term with respect to the full range; ## that's plotted, i.e., apply a correction to the extended likelihood term in such a way; ## that the interpretation of the expected event count remains that of the full range. This can; ## be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the; ## fitted range) in the Poisson term that represents the extended likelihood term.; ##; ## If an extended likelihood fit is performed over *two* sub-ranges, this correction is; ## even more important: without it, each component likelihood would have a different interpretation; ## of the expected event count (each corresponding to the count in its own region), and a joint; ## fit of these regions with different interpretations of the same model parameter results; ## in a number that is not easily interpreted.; ##; ## If both regions correct their interpretation such that N_expected refers to the full range,; ## it is interpreted easily, and consistent in both regions.; ##; ## This requires that the likelihood model is extended using RooAddPdf in the; ## form SumPdf = Nsig * sigPdf + Nbkg * bkgPdf.; ##; ## \macro_image; ## \macro_code; ## \macro_output; ##; ## \authors Stephan Hageboeck, Wouter Verkerke",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf204b_extendedLikelihood_rangedFit.py:1593,perform,performed,1593,tutorials/roofit/rf204b_extendedLikelihood_rangedFit.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf204b_extendedLikelihood_rangedFit.py,1,['perform'],['performed']
Performance,"e marker symbols are redefined with thicker lines by style numbers; starting from 50:. ~~~ {.cpp}; Marker numbers Line width; 50 - 67 2; 68 - 85 3; 86 - 103 4; 104 - 121 5; ...; ~~~. Begin_Macro; {; TCanvas *c = new TCanvas(""c"",""Marker line widths"",0,0,600,266);; TMarker marker;; marker.DisplayMarkerLineWidths();; }; End_Macro. \anchor M3; ## Marker size. Various marker sizes are shown in the figure below. The default marker size=1; is shown in the top left corner. Marker sizes smaller than 1 can be; specified. The marker size does not refer to any coordinate systems, it is an; absolute value. Therefore the marker size is not affected by any change; in TPad's scale. A marker size equal to 1 correspond to 8 pixels.; That is, a square marker with size 1 will be drawn with a side equal to 8; pixels on the screen. The marker size of any class inheriting from `TAttMarker` can; be changed using the method `SetMarkerSize` and retrieved using the; method `GetMarkerSize`. Begin_Macro; {; auto c = new TCanvas(""c"",""Marker sizes"",0,0,500,200);; TMarker marker;; marker.SetMarkerStyle(3);; Double_t x = 0;; Double_t dx = 1/6.0;; for (Int_t i=1; i<6; i++) {; x += dx;; marker.SetMarkerSize(i*0.2); marker.DrawMarker(x,.165);; marker.SetMarkerSize(i*0.8); marker.DrawMarker(x,.495);; marker.SetMarkerSize(i*1.0); marker.DrawMarker(x,.835);; }; }; End_Macro. Note that the marker styles number 1 6 and 7 (the dots), cannot be scaled. They; are meant to be very fast to draw and are always drawn with the same number of; pixels; therefore `SetMarkerSize` does not apply on them. To have a; ""scalable dot"" a filled circle should be used instead, i.e. the marker style; number 20. By default (if `SetMarkerStyle` is not specified), the marker; style used is 1. That's the most common one to draw scatter plots.; */; ////////////////////////////////////////////////////////////////////////////////; /// TAttMarker default constructor.; ///; /// Default text attributes are taking from the current style.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TAttMarker.cxx:5456,scalab,scalable,5456,core/base/src/TAttMarker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TAttMarker.cxx,1,['scalab'],['scalable']
Performance,"e master side.; *; * ## Message protocol; *; * One simple rule must be upheld for the messages that the implementer will; * send with 'send_back_task_result_from_worker' and 'update_state': the first; * part of the message must always be the 'Job''s ID, stored in 'Job::id'.; * The rest of the message, i.e. the actual data to be sent, is completely up; * to the implementation. Note that on the receiving end, i.e. in the; * implementation of 'receive_task_result_on_master', one will get the whole; * message, but the 'Job' ID part will already have been identified in the; * 'JobManager', so one needn't worry about it further inside; * 'Job::receive_task_result_on_master' (it is already routed to the correct; * 'Job'). The same goes for the receiving end of 'update_state', except that; * update_state is routed from the 'worker_loop', not the 'JobManager'.; *; * A second rule applies to 'update_state' messages: the second part must be; * a state identifier. This identifier will also be sent along with tasks to; * the queue. When a worker then takes a task from the queue, it can check; * whether it has already updated its state to what is expected to be there; * for the task at hand. If not, it should wait for the new state to arrive; * over the state subscription socket. Note: it is the implementer's task to; * actually update 'Job::state_id_' inside 'Job::update_state()'!; *; * ## Implementers notes; *; * The type of result from each task is strongly dependent on the Job at hand; * and so Job does not provide a default results member. It is up to the; * inheriting class to implement this in the above functions. We would have; * liked a template parameter task_result_t, so that we could also provide a; * default ""boilerplate"" calculate function to show a typical Job use-case of; * all the above infrastructure. This is not trivial, because the JobManager; * has to keep a list of Job pointers, so if there would be different template; * instantiations of Jobs, this would co",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Job.cxx:2090,queue,queue,2090,roofit/multiprocess/src/Job.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Job.cxx,1,['queue'],['queue']
Performance,"e operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrz(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI </c> instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1759,perform,perform,1759,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,1,['perform'],['perform']
Performance,"e order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; ~~~{.cpp}; ROOT::EnableImplicitMT(i); ~~~; replacing `i` with the number of CPUs/slots that were allocated for this job. ### Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads. Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; which eliminates all risks of race conditions. In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; where `slot` will be a number between 0 and `GetNSlots() - 1`.; In other wor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:48761,concurren,concurrently,48761,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['concurren'],['concurrently']
Performance,"e text line - triple-click on it; //; // to select all do quadruple-click. //; // //; // Cut, Copy, Paste //; // //; // After selecting some text, you can cut or copy it to the clipboard. //; // A subsequent paste operation will insert the contents of the //; // clipboard at the current cursor location. //; // //; // Text Search //; // //; // The editor uses a standard Search dialog. You can specify a forward //; // or backward search direction starting from the current cursor //; // location according to the selection made of a case sensitive mode //; // or not. The last search can be repeated by pressing F3. //; // //; // Text Font //; // //; // You can change the text font by selecting Edit menu / Set Font. //; // The Font Dialog pops up and shows the Name, Style, and Size of any //; // available font. The selected font sample is shown in the preview //; // area. //; // //; // Executing Macros //; // //; // You can execute the currently loaded macro in the editor by //; // selecting Tools menu / Execute Macro; by clicking on the //; // corresponding toolbar button, or by using Ctrl+F5 accelerator keys. //; // This is identical to the command "".x macro.C"" in the root prompt //; // command line. //; // //; // Compiling Macros //; // //; // The currently loaded macro can be compiled with ACLiC if you select //; // Tools menu / Compile Macro; by clicking on the corresponding //; // toolbar button, or by using Ctrl+F7 accelerator keys. //; // This is identical to the command "".L macro.C++"" in the root prompt //; // command line. //; // //; // Interrupting a Running Macro //; // //; // You can interrupt a running macro by selecting the Tools menu / //; // Interrupt; by clicking on the corresponding toolbar button, or by //; // using Shift+F5 accelerator keys. //; // //; // Interface to CINT Interpreter //; // //; // Any command entered in the Command combo box will be passed to //; // the CINT interpreter. This combo box will keep the commands history //; // and will a",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootIDE/TGRootIDE.cxx:3078,load,loaded,3078,test/RootIDE/TGRootIDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootIDE/TGRootIDE.cxx,1,['load'],['loaded']
Performance,"e to specify more than 16 User; /// SGPRs using the enable_sgpr_* bit fields, in which case only the first 16; /// are actually initialized. These are then immediately followed by the System; /// SGPRs that are set up by ADC/SPI and can have different values for each wave; /// of the grid dispatch.; ///; /// SGPR register initial state is defined as follows:; ///; /// Private Segment Buffer (enable_sgpr_private_segment_buffer):; /// Number of User SGPR registers: 4. V# that can be used, together with; /// Scratch Wave Offset as an offset, to access the Private/Spill/Arg; /// segments using a segment address. It must be set as follows:; /// - Base address: of the scratch memory area used by the dispatch. It; /// does not include the scratch wave offset. It will be the per process; /// SH_HIDDEN_PRIVATE_BASE_VMID plus any offset from this dispatch (for; /// example there may be a per pipe offset, or per AQL Queue offset).; /// - Stride + data_format: Element Size * Index Stride (???); /// - Cache swizzle: ???; /// - Swizzle enable: SH_STATIC_MEM_CONFIG.SWIZZLE_ENABLE (must be 1 for; /// scratch); /// - Num records: Flat Scratch Work Item Size / Element Size (???); /// - Dst_sel_*: ???; /// - Num_format: ???; /// - Element_size: SH_STATIC_MEM_CONFIG.ELEMENT_SIZE (will be DWORD, must; /// agree with amd_kernel_code_t.privateElementSize); /// - Index_stride: SH_STATIC_MEM_CONFIG.INDEX_STRIDE (will be 64 as must; /// be number of wavefront lanes for scratch, must agree with; /// amd_kernel_code_t.wavefrontSize); /// - Add tid enable: 1; /// - ATC: from SH_MEM_CONFIG.PRIVATE_ATC,; /// - Hash_enable: ???; /// - Heap: ???; /// - Mtype: from SH_STATIC_MEM_CONFIG.PRIVATE_MTYPE; /// - Type: 0 (a buffer) (???); ///; /// Dispatch Ptr (enable_sgpr_dispatch_ptr):; /// Number of User SGPR registers: 2. 64 bit address of AQL dispatch packet; /// for kernel actually executing.; ///; /// Queue Ptr (enable_sgpr_queue_ptr):; /// Number of User SGPR registers: 2. 64 bit address of AmdQueu",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:1921,Cache,Cache,1921,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,1,['Cache'],['Cache']
Performance,"e user must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case only a subset of the events is processed to avoid wasteful caching. #### Reading all branches. ~~~ {.cpp}; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; ~~~. #### Reading a subset of all branches. In the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; ~~~ {.cpp}; TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=200UL;; auto efirst = 0;; auto elast = efirst+nentries;; auto cachesize = 10000000U; // 10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process(""myselector.C+"","""",nentries,efirst);; // In the TSelector::Process we read only 2 branches; auto b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; auto b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... Here the entry is processed; ~~~; ### Custom event loop. #### Always using the same two branches. In this example, exactly two branches are always used: those need to be; prefetched.; ~~~ {.cpp}; TTree *T;; f->GetObject(T, ""mytree"");; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1, true); //<<< add branch1 and branch2 to the cache; T->AddBranchToCache(b2, true); //<<<; T->StopCacheLearningPhase(); //<<< we do not need the sy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:8114,cache,cachesize,8114,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['cache'],['cachesize']
Performance,"e-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a function pass that initializes undef vector value to; // temporary pseudo instruction and remove it in expandpseudo pass to prevent; // register allocation resulting in a constraint violated result for vector; // instruction. It also rewrites the NoReg tied operand back to an; // IMPLICIT_DEF.; //; // RISC-V vector instruction has register overlapping constraint for certain; // instructions, and will cause illegal instruction trap if violated, we use; // early clobber to model this constraint, but it can't prevent register; // allocator allocated same or overlapped if the input register is undef value,; // so convert IMPLICIT_DEF to temporary pseudo instruction and remove it later; // could prevent that happen, it's not best way to resolve this, and it might; // change the order of program or increase the register pressure, so ideally we; // should model the constraint right, but before we model the constraint right,; // it's the only way to prevent that happen.; //; // When we enable the subregister liveness option, it will also trigger same; // issue due to the partial of register is undef. If we pseudoinit the whole; // register, then it will generate redundant COPY instruction. Currently, it; // will generate INSERT_SUBREG to make sure the whole register is occupied; // when program encounter operation that has early-clobber constraint.; //; //; // See also: https://github.com/llvm/llvm-project/issues/50157; //; // Additionally, this pass rewrites tied operands of vector instructions; // from NoReg to IMPLICIT_DEF. (Not that this is a non-overlapping set of; // operands to the above.) We use NoReg to side step a MachineCSE; // optimization quality problem but need to convert back before; // TwoAddressInstruction. See pr64282 for context.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp:2065,optimiz,optimization,2065,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,1,['optimiz'],['optimization']
Performance,"e-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for instructions that can be replaced by a Test Data Class; // instruction, and replaces them when profitable.; //; // Roughly, the following rules are recognized:; //; // 1: fcmp pred X, 0 -> tdc X, mask; // 2: fcmp pred X, +-inf -> tdc X, mask; // 3: fcmp pred X, +-minnorm -> tdc X, mask; // 4: tdc (fabs X), mask -> tdc X, newmask; // 5: icmp slt (bitcast float X to int), 0 -> tdc X, mask [ie. signbit]; // 6: icmp sgt (bitcast float X to int), -1 -> tdc X, mask; // 7: icmp ne/eq (call @llvm.s390.tdc.*(X, mask)) -> tdc X, mask/~mask; // 8: and i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 & M2); // 9: or i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 | M2); // 10: xor i1 (tdc X, M1), (tdc X, M2) -> tdc X, (M1 ^ M2); //; // The pass works in 4 steps:; //; // 1. All fcmp and icmp instructions in a function are checked for a match; // with rules 1-3 and 5-7. Their TDC equivalents are stored in; // the ConvertedInsts mapping. If the operand of a fcmp instruction is; // a fabs, it's also folded according to rule 4.; // 2. All and/or/xor i1 instructions whose both operands have been already; // mapped are mapped according to rules 8-10. LogicOpsWorklist is used; // as a queue of instructions to check.; // 3. All mapped instructions that are considered worthy of conversion (ie.; // replacing them will actually simplify the final code) are replaced; // with a call to the s390.tdc intrinsic.; // 4. All intermediate results of replaced instructions are removed if unused.; //; // Instructions that match rules 1-3 are considered unworthy of conversion; // on their own (since a comparison instruction is superior), but are mapped; // in the hopes of folding the result using rules 4 and 8-10 (likely removing; // the original comparison in the process).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:1574,queue,queue,1574,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,1,['queue'],['queue']
Performance,"e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is introduced:; // uint32_t __builtin_preserve_field_info(member_access, info_kind); // In IR, a chain with two (or more) intrinsic calls will be generated:; // ...; // addr = preserve_struct_access_index(base, 1, 1) !struct s; // uint32_t result = bpf_preserve_field_info(addr, info_kind); //; // Suppose the info_kind is FIELD_SIGNEDNESS,; // The above two IR intrinsics will be replaced with; // a relocatable insn:; // signness = /* signness of member_access */; // and signness can be changed by bpf loader based on the; // types on the host.; //; // User can also test whether a field exists or not with; // uint32_t result = bpf_preserve_field_info(member_access, FIELD_EXISTENCE); // The field will be always available (result = 1) during initial; // compilation, but bpf loader can patch with the correct value; // on the target host where the member_access may or may not be available; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:1961,optimiz,optimization,1961,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,3,"['load', 'optimiz']","['loader', 'optimization']"
Performance,"e/def graph.; ///; /// Memory SSA class builds an SSA form that links together memory access; /// instructions such as loads, stores, atomics, and calls. Additionally, it; /// does a trivial form of ""heap versioning"" Every time the memory state changes; /// in the program, we generate a new heap version. It generates; /// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.; ///; /// As a trivial example,; /// define i32 @main() #0 {; /// entry:; /// %call = call noalias i8* @_Znwm(i64 4) #2; /// %0 = bitcast i8* %call to i32*; /// %call1 = call noalias i8* @_Znwm(i64 4) #2; /// %1 = bitcast i8* %call1 to i32*; /// store i32 5, i32* %0, align 4; /// store i32 7, i32* %1, align 4; /// %2 = load i32* %0, align 4; /// %3 = load i32* %1, align 4; /// %add = add nsw i32 %2, %3; /// ret i32 %add; /// }; ///; /// Will become; /// define i32 @main() #0 {; /// entry:; /// ; 1 = MemoryDef(0); /// %call = call noalias i8* @_Znwm(i64 4) #3; /// %2 = bitcast i8* %call to i32*; /// ; 2 = MemoryDef(1); /// %call1 = call noalias i8* @_Znwm(i64 4) #3; /// %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:1219,load,load,1219,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,5,['load'],['load']
Performance,"e; * user types punctuation characters or whitespace, at which point the; * code-completion location will coincide with the cursor. For example, if \c p; * is a pointer, code-completion might be triggered after the ""-"" and then; * after the "">"" in \c p->. When the code-completion location is after the "">"",; * the completion results will provide, e.g., the members of the struct that; * ""p"" points to. The client is responsible for placing the cursor at the; * beginning of the token currently being typed, then filtering the results; * based on the contents of the token. For example, when code-completing for; * the expression \c p->get, the client should provide the location just after; * the "">"" (e.g., pointing at the ""g"") to this code-completion hook. Then, the; * client can filter the results based on the current token text (""get""), only; * showing those results that start with ""get"". The intent of this interface; * is to separate the relatively high-latency acquisition of code-completion; * results from the filtering of results on a per-character basis, which must; * have a lower latency.; *; * \param TU The translation unit in which code-completion should; * occur. The source files for this translation unit need not be; * completely up-to-date (and the contents of those source files may; * be overridden via \p unsaved_files). Cursors referring into the; * translation unit may be invalidated by this invocation.; *; * \param complete_filename The name of the source file where code; * completion should be performed. This filename may be any file; * included in the translation unit.; *; * \param complete_line The line at which code-completion should occur.; *; * \param complete_column The column at which code-completion should occur.; * Note that the column should point just after the syntactic construct that; * initiated code completion, and not in the middle of a lexical token.; *; * \param unsaved_files the Files that have not yet been saved to disk; * but may be req",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1833,latency,latency,1833,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,2,['latency'],['latency']
Performance,"e; /// ~~~; /// and; /// ~~~{.cpp}; /// y_t cutfilename(); // i.e function with the same name as the file; /// ~~~; /// x_t and y_t needs to be types that can convert respectively to a double; /// and a bool (because the skeleton uses:; /// ~~~{.cpp}; /// if (cutfilename()) htemp->Fill(macrofilename());; /// ~~~; /// This 2 functions are run in a context such that the branch names are; /// available as local variables of the correct (read-only) type.; ///; /// Note that if you use the same 'variable' twice, it is more efficient; /// to 'cache' the value. For example; /// ~~~{.cpp}; /// Int_t n = fEventNumber; // Read fEventNumber; /// if (n<10 || n>10) { ... }; /// ~~~; /// is more efficient than; /// ~~~{.cpp}; /// if (fEventNumber<10 || fEventNumber>10); /// ~~~; /// Access to TClonesArray.; ///; /// If a branch (or member) is a TClonesArray (let's say fTracks), you; /// can access the TClonesArray itself by using ->:; /// ~~~{.cpp}; /// fTracks->GetLast();; /// ~~~; /// However this will load the full TClonesArray object and its content.; /// To quickly read the size of the TClonesArray use (note the dot):; /// ~~~{.cpp}; /// fTracks.GetEntries();; /// ~~~; /// This will read only the size from disk if the TClonesArray has been; /// split.; /// To access the content of the TClonesArray, use the [] operator:; /// ~~~; /// float px = fTracks[i].fPx; // fPx of the i-th track; /// ~~~; /// Warning:; ///; /// The variable actually use for access are 'wrapper' around the; /// real data type (to add autoload for example) and hence getting to; /// the data involves the implicit call to a C++ conversion operator.; /// This conversion is automatic in most case. However it is not invoked; /// in a few cases, in particular in variadic function (like printf).; /// So when using printf you should either explicitly cast the value or; /// use any intermediary variable:; /// ~~~{.cpp}; /// fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);; /// ~~~; /// Also, optionally, the gen",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx:3424,load,load,3424,tree/treeplayer/src/TTreePlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx,1,['load'],['load']
Performance,"e; colors to distinguish contours (`SURF` option at theta = 0). Combined; with the option `CONT` (or `CONT0`), the option `Z`; allows to display the color palette defined by `gStyle->SetPalette()`. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcont4 = new TH2F(""hcont4"",""Option CONT4Z example "",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcont4->Fill(px-1,5*py);; hcont4->Fill(2+0.5*px,2*py-10.,0.1);; }; hcont4->Draw(""CONT4Z"");; }; End_Macro. The default number of contour levels is 20 equidistant levels and can be changed; with `TH1::SetContour()` or `TStyle::SetNumberContours()`. \anchor HP16a; #### The LIST option. When option `LIST` is specified together with option; `CONT`, the points used to draw the contours are saved in; `TGraph` objects:. h->Draw(""CONT LIST"");; gPad->Update();. The contour are saved in `TGraph` objects once the pad is painted.; Therefore to use this functionality in a macro, `gPad->Update()`; should be performed after the histogram drawing. Once the list is; built, the contours are accessible in the following way:. TObjArray *contours = (TObjArray*)gROOT->GetListOfSpecials()->FindObject(""contours"");; Int_t ncontours = contours->GetSize();; TList *list = (TList*)contours->At(i);. Where `i` is a contour number, and list contains a list of; `TGraph` objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example (ContourList.C) shows how to use this functionality. Begin_Macro(source); ../../../tutorials/hist/ContourList.C; End_Macro. \anchor HP16b; #### The AITOFF, MERCATOR, SINUSOIDAL and PARABOLIC options. The following options select the `CONT4` option and are useful for; sky maps or exposure maps (earth.C). | Option | Description |; |--------------|-----------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:67707,perform,performed,67707,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['perform'],['performed']
Performance,"eating a logical dataset with the same number of rows and the union of the; columns of multiple trees) leverages TTree's ""friend"" mechanism. Simple joins of trees that do not have the same number of rows are also possible with indexed friend trees (see below). To use friend trees in RDataFrame, set up trees with the appropriate relationships and then instantiate an RDataFrame; with the main tree:. ~~~{.cpp}; TTree main([...]);; TTree friend([...]);; main.AddFriend(&friend, ""myFriend"");. RDataFrame df(main);; auto df2 = df.Filter(""myFriend.MyCol == 42"");; ~~~. The same applies for TChains. Columns coming from the friend trees can be referred to by their full name, like in the example above,; or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of; ""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree). \note A common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their; entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original; one: rows will be mismatched. Indexed friend trees provide a way to perform simple joins of multiple trees over a common column.; When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the; ""index"" columns have a value identical to the one in the main one. For example, in Python:. ~~~{.py}; main_tree = ...; aux_tree = ... # If a friend tree has an index on `commonColumn`, when the main tree loads; # a given row, it also loads the row of the friend tree that has the same; # value of `commonColumn`; aux_tree.BuildIndex(""commonColumn""). mainTree.AddFriend(aux_tree). df = ROOT.RDataFrame(mainTree); ~~~. RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode. \anchor other-file-formats; ### Reading data formats other t",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:72894,multi-thread,multi-thread,72894,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['multi-thread'],['multi-thread']
Performance,"ed to ValT objects. Intervals of keys that map to the; /// same value are represented in a compressed form.; ///; /// Iterators provide ordered access to the compressed intervals rather than the; /// individual keys, and insert and erase operations use key intervals as well.; ///; /// Like SmallVector, IntervalMap will store the first N intervals in the map; /// object itself without any allocations. When space is exhausted it switches; /// to a B+-tree representation with very small overhead for small key and; /// value objects.; ///; /// A Traits class specifies how keys are compared. It also allows IntervalMap; /// to work with both closed and half-open intervals.; ///; /// Keys and values are not stored next to each other in a std::pair, so we; /// don't provide such a value_type. Dereferencing iterators only returns the; /// mapped value. The interval bounds are accessible through the start() and; /// stop() iterator methods.; ///; /// IntervalMap is optimized for small key and value objects, 4 or 8 bytes; /// each is the optimal size. For large objects use std::map instead.; //; //===----------------------------------------------------------------------===//; //; // Synopsis:; //; // template <typename KeyT, typename ValT, unsigned N, typename Traits>; // class IntervalMap {; // public:; // typedef KeyT key_type;; // typedef ValT mapped_type;; // typedef RecyclingAllocator<...> Allocator;; // class iterator;; // class const_iterator;; //; // explicit IntervalMap(Allocator&);; // ~IntervalMap():; //; // bool empty() const;; // KeyT start() const;; // KeyT stop() const;; // ValT lookup(KeyT x, Value NotFound = Value()) const;; //; // const_iterator begin() const;; // const_iterator end() const;; // iterator begin();; // iterator end();; // const_iterator find(KeyT x) const;; // iterator find(KeyT x);; //; // void insert(KeyT a, KeyT b, ValT y);; // void clear();; // };; //; // template <typename KeyT, typename ValT, unsigned N, typename Traits>; // class Interva",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:1463,optimiz,optimized,1463,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,1,['optimiz'],['optimized']
Performance,"eed to create the function if you don't want to,; // the formula can be set by expression:; // --Example:; // // 2 is the number of dimensions; // TLinearFitter *lf = new TLinearFitter(2);; // lf->SetFormula(""x ++ y ++ x*x*y*y"");; // --That's the only way to go, if you want to fit in more; // than 3 dimensions; // 2.2.3 The fastest functions to compute are polynomials and hyperplanes.; // --Polynomials are set the usual way: ""pol1"", ""pol2"",...; // --Hyperplanes are set by expression ""hyp3"", ""hyp4"", ...; // ---The ""hypN"" expressions only work when the linear fitter; // is used directly, not through TH1::Fit or TGraph::Fit.; // To fit a graph or a histogram with a hyperplane, define; // the function as ""1++x++y"".; // ---A constant term is assumed for a hyperplane, when using; // the ""hypN"" expression, so ""hyp3"" is in fact fitting with; // ""1++x++y++z"" function.; // --Fitting hyperplanes is much faster than fitting other; // expressions so if performance is vital, calculate the; // function values beforehand and give them to the fitter; // as variables; // --Example:; // You want to fit ""sin(x)|cos(2*x)"" very fast. Calculate; // sin(x) and cos(2*x) beforehand and store them in array *data.; // Then:; // TLinearFitter *lf=new TLinearFitter(2, ""hyp2"");; // lf->AssignData(npoint, 2, data, y);; //; // 2.3 Resetting the formula; // 2.3.1 If the input data is stored (or added via AssignData() function),; // the fitting formula can be reset without re-adding all the points.; // --Example:; // TLinearFitter *lf=new TLinearFitter(""1++x++x*x"");; // lf->AssignData(n, 1, x, y, e);; // lf->Eval(); // //looking at the parameter significance, you see,; // // that maybe the fit will improve, if you take out; // // the constant term; // lf->SetFormula(""x++x*x"");; // lf->Eval();; // ...; // 2.3.2 If the input data is not stored, the fitter will have to be; // cleared and the data will have to be added again to try a; // different formula.; //; // 3.Accessing the fit results; // 3.1 Ther",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/inc/TLinearFitter.h:4224,perform,performance,4224,math/minuit/inc/TLinearFitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/inc/TLinearFitter.h,1,['perform'],['performance']
Performance,"een the components names. ## Example for building a simple geometry. Begin_Macro(source); ../../../tutorials/geom/rootgeom.C; End_Macro. ## TGeoManager - the manager class for the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. ## Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandatory steps; that have to be followed in order to be validated by the modeler. There are; general rules : volumes needs media and shapes in order to be created,; both container and containee volumes must be created before linking them together,; and the relative transformation matrix must be provided. All branches must; have an upper link point otherwise they will not be considered as part of the; geometry. Visibility or tracking properties of volumes can be provided both; at build time or after geometry is closed, but global visualization settings; (see TGeoPainter class) should not be provided at build time, otherwise the; drawing package will be loaded. ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:6031,cache,cache,6031,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,1,['cache'],['cache']
Performance,"eference Library License version 1 (for libpng 0.5 through 1.6.35); * -----------------------------------------------------------------------; *; * libpng versions 1.0.7, July 1, 2000, through 1.6.35, July 15, 2018 are; * Copyright (c) 2000-2002, 2004, 2006-2018 Glenn Randers-Pehrson, are; * derived from libpng-1.0.6, and are distributed according to the same; * disclaimer and license as libpng-1.0.6 with the following individuals; * added to the list of Contributing Authors:; *; * Simon-Pierre Cadieux; * Eric S. Raymond; * Mans Rullgard; * Cosmin Truta; * Gilles Vollant; * James Yu; * Mandar Sahastrabuddhe; * Google Inc.; * Vadim Barkov; *; * and with the following additions to the disclaimer:; *; * There is no warranty against interference with your enjoyment of; * the library or against infringement. There is no warranty that our; * efforts or the library will fulfill any of your particular purposes; * or needs. This library is provided with all faults, and the entire; * risk of satisfactory quality, performance, accuracy, and effort is; * with the user.; *; * Some files in the ""contrib"" directory and some configure-generated; * files that are distributed with libpng have other copyright owners, and; * are released under other open source licenses.; *; * libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are; * Copyright (c) 1998-2000 Glenn Randers-Pehrson, are derived from; * libpng-0.96, and are distributed according to the same disclaimer and; * license as libpng-0.96, with the following individuals added to the; * list of Contributing Authors:; *; * Tom Lane; * Glenn Randers-Pehrson; * Willem van Schaik; *; * libpng versions 0.89, June 1996, through 0.96, May 1997, are; * Copyright (c) 1996-1997 Andreas Dilger, are derived from libpng-0.88,; * and are distributed according to the same disclaimer and license as; * libpng-0.88, with the following individuals added to the list of; * Contributing Authors:; *; * John Bowler; * Kevin Bracey; * Sam Bu",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:3517,perform,performance,3517,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['perform'],['performance']
Performance,"el 1. These are defined; /// in the header file <em>Compression.h</em>.; /// Note that the compression settings may be changed at any time.; /// The new compression settings will only apply to branches created; /// or attached after the setting is changed and other objects written; /// after the setting is changed.; /// In case the file does not exist or is not a valid ROOT file,; /// it is made a Zombie. One can detect this situation with a code like:; /// ~~~{.cpp}; /// TFile f(""file.root"");; /// if (f.IsZombie()) {; /// std::cout << ""Error opening file"" << std::endl;; /// exit(-1);; /// }; /// ~~~; /// If you open a file instead with TFile::Open(""file.root"") use rather; /// the following code as a nullptr is returned.; /// ~~~{.cpp}; /// TFile* f = TFile::Open(""file.root"");; /// if (!f) {; /// std::cout << ""Error opening file"" << std::endl;; /// exit(-1);; /// }; /// ~~~; /// When opening the file, the system checks the validity of this directory.; /// If something wrong is detected, an automatic Recovery is performed. In; /// this case, the file is scanned sequentially reading all logical blocks; /// and attempting to rebuild a correct directory (see TFile::Recover).; /// One can disable the automatic recovery procedure when reading one; /// or more files by setting the environment variable ""TFile.Recover: 0""; /// in the system.rootrc file.; ///; /// A bit `TFile::kReproducible` can be enabled specifying; /// the `""reproducible""` url option when creating the file:; /// ~~~{.cpp}; /// TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; /// ~~~; /// Unlike regular `TFile`s, the content of such file has reproducible binary; /// content when writing exactly same data. This achieved by writing pre-defined; /// values for creation and modification date of TKey/TDirectory objects and; /// null value for TUUID objects inside TFile. As drawback, TRef objects stored; /// in such file cannot be read correctly.; ///; /// In case the name of the file is",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:5193,perform,performed,5193,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['perform'],['performed']
Performance,"en machine-independent; /// abstract property corresponds to a specific physical property across all; /// subtargets can't be done. Nonetheless, the abstract model is; /// useful. Futhermore, subtargets typically extend this model with processor; /// specific resources to model any hardware features that can be exploited by; /// scheduling heuristics and aren't sufficiently represented in the abstract.; ///; /// The abstract pipeline is built around the notion of an ""issue point"". This; /// is merely a reference point for counting machine cycles. The physical; /// machine will have pipeline stages that delay execution. The scheduler does; /// not model those delays because they are irrelevant as long as they are; /// consistent. Inaccuracies arise when instructions have different execution; /// delays relative to each other, in addition to their intrinsic latency. Those; /// special cases can be handled by TableGen constructs such as, ReadAdvance,; /// which reduces latency when reading data, and ReleaseAtCycles, which consumes; /// a processor resource when writing data for a number of abstract; /// cycles.; ///; /// TODO: One tool currently missing is the ability to add a delay to; /// ReleaseAtCycles. That would be easy to add and would likely cover all cases; /// currently handled by the legacy itinerary tables.; ///; /// A note on out-of-order execution and, more generally, instruction; /// buffers. Part of the CPU pipeline is always in-order. The issue point, which; /// is the point of reference for counting cycles, only makes sense as an; /// in-order part of the pipeline. Other parts of the pipeline are sometimes; /// falling behind and sometimes catching up. It's only interesting to model; /// those other, decoupled parts of the pipeline if they may be predictably; /// resource constrained in a way that the scheduler can exploit.; ///; /// The LLVM machine model distinguishes between in-order constraints and; /// out-of-order constraints so that the target's",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:1839,latency,latency,1839,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,1,['latency'],['latency']
Performance,"en, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShift) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. ### CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. ### WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and frequent case, TFormula is aware; of all TMath functions.; */; ////////////////////////////////////////////////////////////////////////////////; /// Formula default constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:2490,perform,performant,2490,hist/hist/src/TFormula_v5.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx,1,['perform'],['performant']
Performance,"enGL ""ogl"", X3D ""x3d"" or; Pad ""pad"" (default). The viewer is created via the plugin manager,; attached to pad, and the interface returned. ## Begin / End Scene. Objects must be added to viewer between BeginScene/EndScene calls e.g.; ~~~ {.cpp}; v->BeginScene();; .....; v->AddObject(....);; v->AddObject(....);; .....; v->EndScene();; ~~~. The BeginScene call will cause the viewer to suspend redraws etc, and after; the EndScene the viewer will reset the camera to frame the new scene and redraw.; [x3d viewer does not support changing of scenes - objects added after the; first Open/CloseScene pair will be ignored.]. ## Filling TBuffer3D and Adding to Viewer. The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. - Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; - Some need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details).; \image html base_tbuffer3d.png. The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags. The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion.; An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers. The r",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualViewer3D.cxx:3075,perform,performance,3075,core/base/src/TVirtualViewer3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualViewer3D.cxx,1,['perform'],['performance']
Performance,"ent.GetHistogram()->GetXaxis()->GetXmax(); /// ~~~; /// \endparblock; /// \param [in] selection; /// \parblock; /// A string containing a selection expression.; /// In a selection all usual C++ mathematical and logical operators are allowed.; /// The value corresponding to the selection expression is used as a weight; /// to fill the histogram (a weight of 0 is equivalent to not filling the histogram).\n; /// \n; /// Examples:; /// - ""x<y && sqrt(z)>3.2"": returns a weight = 0 or 1; /// - ""(x+y)*(sqrt(z)>3.2)"": returns a weight = x+y if sqrt(z)>3.2, 0 otherwise\n; /// \n; /// If the selection expression returns an array, it is iterated over in sync with the; /// array returned by the varexp argument (as described below in ""Drawing expressions using arrays and array; /// elements""). For example, if, for a given event, varexp evaluates to; /// `{1., 2., 3.}` and selection evaluates to `{0, 1, 0}`, the resulting histogram is filled with the value 2. For example, for each event here we perform a simple object selection:; /// ~~~{.cpp}; /// // Muon_pt is an array: fill a histogram with the array elements > 100 in each event; /// tree->Draw('Muon_pt', 'Muon_pt > 100'); /// ~~~; /// \endparblock; /// \param [in] option; /// \parblock; /// The drawing option.; /// - When an histogram is produced it can be any histogram drawing option; /// listed in THistPainter.; /// - when no option is specified:; /// - the default histogram drawing option is used; /// if the expression is of the form ""e1"".; /// - if the expression is of the form ""e1:e2""or ""e1:e2:e3"" a cloud of; /// unbinned 2D or 3D points is drawn respectively.; /// - if the expression has four fields ""e1:e2:e3:e4"" a cloud of unbinned 3D; /// points is produced with e1 vs e2 vs e3, and e4 is mapped on the current color; /// palette.; /// - If option COL is specified when varexp has three fields:; /// ~~~ {.cpp}; /// tree.Draw(""e1:e2:e3"","""",""col"");; /// ~~~; /// a 2D scatter is produced with e1 vs e2, and e3 is mapped on t",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:3295,perform,perform,3295,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['perform'],['perform']
Performance,"entlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning phase is started or restarted when:; - TTree automatically creates a cache.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTreeCache::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; - TTreeCache::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries.; - A 'cached' TChain switches over to a new file. \anchor cachemisses; ## Self-optimization in presence of cache misses. The TTreeCache can optimize its behavior on a cache miss. When; miss optimization is enabled (see the SetOptimizeMisses method),; it tracks all branches utilized after the learning phase which caused a cache; miss.; When one cache miss occurs, all the utilized branches are be prefetched; for that event. This optimization utilizes the observation that infrequently; accessed branches are often accessed together.; An example scenario where such behavior is desirable, is an analysis where; a set of collections are read only for a few events in which a certain; condition is respected, e.g. a trigger fired. ### Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase; by at most a factor two in the case of cache miss.; Additionally, on the first miss of an event, we must iterate through all the; ""active branches"" for the miss cache and find the correct basket.; This can be potentially a CPU-expensive operation compared to, e.g., the; latency of a SSD. This is why the miss cache is currently disabled by default. \anchor examples; ## Example usa",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:4853,optimiz,optimization,4853,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"ents straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that is the closest ancestor in the dominator tree.; //; // TODO:; //; // - Floating point arithmetics when fast math is enabled.; //; // - SLSR may decrease ILP at the architecture level. Targets that are very; // sensitive to ILP may want to disable it. Having SLSR to consider ILP is; // left as future work.; //; // - When (i' - i) is constant but i and i' are not, we could still perform; // SLSR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:1745,optimiz,optimized,1745,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,2,"['optimiz', 'perform']","['optimized', 'perform']"
Performance,"enus for mapped items from the left tree-type list :; The items from the left that are provided with context menus are tree and; branch items. You can directly activate the *MENU* marked methods of TTree; from this menu. Context menu for the right panel:. A general context menu is activated if the user right-clicks the right panel. Commands are :; - EmptyAll : clears the content of all expressions;; - ExecuteCommand : execute a ROOT command;; - MakeSelector : equivalent of TTree::MakeSelector();; - NewExpression : add an expression item in the right panel;; - Process : equivalent of TTree::Process();; - SaveSource : save the current session as a C++ macro;; - SetScanFileName : define a name for the file where TTree::Scan command; is redirected when the `<Scan>` button is checked;; - SetTreeName : open a new tree with this name in the viewer;. A specific context menu is activated if expressions/leaves are right-clicked. Commands are :; - Draw : draw a histogram for this item;; - EditExpression : pops-up the expression editor;; - Empty : empty the name and alias of this item;; - RemoveItem : removes clicked item from the list;; - Scan : scan this expression;; - SetExpression : edit name and alias for this item by hand;. Starting the viewer. 1. From the TBrowser: Select a tree in the TBrowser, then call the; StartViewer() method from its context menu (right-click on the tree).; 2. From the command line: Start a ROOT session in the directory where you have; your tree. You will need first to load the library for TTreeViewer and; optionally other libraries for user defined classes (you can do this later in; the session) :; ~~~ {.cpp}; root [0] gSystem->Load(\""TTreeViewer\"");; ~~~; Supposing you have the tree MyTree in the file MyFile, you can do :; ~~~ {.cpp}; root [1] TFile file(""Myfile"");; root [2] new TTreeViewer(""Mytree"");; ~~~; or :; ~~~ {.cpp}; root [2] TTreeViewer *tv = new TTreeViewer();; root [3] tv->SetTreeName(""Mytree"");; ~~~; \image html ttree_treeview.png; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx:7438,load,load,7438,tree/treeviewer/src/TTreeViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx,2,"['Load', 'load']","['Load', 'load']"
Performance,"ept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad repaint at present), and thus collect these objects if the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. ### Physical IDs. TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0). ~~~ {.cpp}; virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); ~~~. If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox); will generate IDs for each physical; object internally. In the second you can specify a unique identifier from the; client, which allows the viewer to be more efficient. It can now cache both logical; and physical objects, and only discard physical objects no longer of interest as; part of scene rebuilds. ### Child Objects. In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. ### Recycling TBuffer3D. Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer3D.cxx:8177,cache,cache,8177,core/base/src/TBuffer3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer3D.cxx,1,['cache'],['cache']
Performance,"equired by the MIPS ABI.; ///; /// MIPS has a few relocations that have an AHL component in the expression used; /// to evaluate them. This AHL component is an addend with the same number of; /// bits as a symbol value but not all of our ABI's are able to supply a; /// sufficiently sized addend in a single relocation.; ///; /// The O32 ABI for example, uses REL relocations which store the addend in the; /// section data. All the relocations with AHL components affect 16-bit fields; /// so the addend for a single relocation is limited to 16-bit. This ABI; /// resolves the limitation by linking relocations (e.g. R_MIPS_HI16 and; /// R_MIPS_LO16) and distributing the addend between the linked relocations. The; /// ABI mandates that such relocations must be next to each other in a; /// particular order (e.g. R_MIPS_HI16 must be immediately followed by a; /// matching R_MIPS_LO16) but the rule is less strict in practice.; ///; /// The de facto standard is lenient in the following ways:; /// - 'Immediately following' does not refer to the next relocation entry but; /// the next matching relocation.; /// - There may be multiple high parts relocations for one low part relocation.; /// - There may be multiple low part relocations for one high part relocation.; /// - The AHL addend in each part does not have to be exactly equal as long as; /// the difference does not affect the carry bit from bit 15 into 16. This is; /// to allow, for example, the use of %lo(foo) and %lo(foo+4) when loading; /// both halves of a long long.; ///; /// See getMatchingLoType() for a description of which high part relocations; /// match which low part relocations. One particular thing to note is that; /// R_MIPS_GOT16 and similar only have AHL addends if they refer to local; /// symbols.; ///; /// It should also be noted that this function is not affected by whether; /// the symbol was kept or rewritten into a section-relative equivalent. We; /// always match using the expressions from the source.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp:1578,load,loading,1578,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp,1,['load'],['loading']
Performance,"er calls flush which forces; * any unsent buffers to be sent to the other end. flush forces any data that; * is to be sent to be sent. purge discards any buffered data waiting to be; * read and/or sent. Closing the channel on the child returns zero, closing it; * on the parent returns the child's exit status.; *; * The class also provides operator<< and operator>> for C++-style I/O for; * basic data types (bool, char, short, int, long, long long, float, double; * and their unsigned counterparts). Data is transmitted binary (i.e. no; * formatting to strings like std::cout does). There are also overloads to; * support C-style zero terminated strings and std::string. In terms of; * performance, the former is to be preferred.; *; * If the caller needs to multiplex input and output to/from several pipes, the; * class provides the poll() method which allows to block until an event occurs; * on any of the polled pipes.; *; * After the BidirMMapPipe is closed, no further operations may be performed on; * that object, save for the destructor which may still be called.; *; * If the BidirMMapPipe has not properly been closed, the destructor will call; * close. However, the exit code of the child is lost in that case.; *; * Closing the object causes the mmapped memory to be unmapped and the two; * pipes to be closed. We also install an atexit handler in the process of; * creating BidirMMapPipes. This ensures that when the current process; * terminates, a SIGTERM signal is sent to the child processes created for all; * unclosed pipes to avoid leaving zombie processes in the OS's process table.; *; * BidirMMapPipe creation, closing and destruction are thread safe. If the; * BidirMMapPipe is used in more than one thread, the other operations have to; * be protected with a mutex (or something similar), though.; *; * End of file (other end closed its pipe, or died) is indicated with the eof(); * method, serious I/O errors set a flags (bad(), fail()), and also throw; * exceptions. Fo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h:2276,perform,performed,2276,roofit/roofitcore/src/BidirMMapPipe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h,1,['perform'],['performed']
Performance,"er sped up match copies, cleaned up some; b4 25 Mar 92 M. Adler added prototypes; removed window[] (now; is the responsibility of unzip.h--also; changed name to slide[]), so needs diffs; for unzip.c and unzip.h (this allows; compiling in the small model on MSDOS);; fixed cast of q in huft_build();; b5 26 Mar 92 M. Adler got rid of unintended macro recursion.; b6 27 Mar 92 M. Adler got rid of nextbyte() routine. fixed; bug in inflate_fixed().; c1 30 Mar 92 M. Adler removed lbits, dbits environment variables.; changed BMAX to 16 for explode. Removed; OUTB usage, and replaced it with flush()--; this was a 20% speed improvement! Added; an explode.c (to replace unimplod.c) that; uses the huft routines here. Removed; register union.; c2 4 Apr 92 M. Adler fixed bug for file sizes a multiple of 32k.; c3 10 Apr 92 M. Adler reduced memory of code tables made by; huft_build significantly (factor of two to; three).; c4 15 Apr 92 M. Adler added NOMEMCPY do kill use of memcpy().; worked around a Turbo C optimization bug.; c5 21 Apr 92 M. Adler added the WSIZE #define to allow reducing; the 32K window size for specialized; applications.; c6 31 May 92 M. Adler added some typecasts to eliminate warnings; c7 27 Jun 92 G. Roelofs added some more typecasts (444: MSC bug).; c8 5 Oct 92 J-l. Gailly added ifdef'd code to deal with PKZIP bug.; c9 9 Oct 92 M. Adler removed a memory error message (~line 416).; c10 17 Oct 92 G. Roelofs changed ULONG/UWORD/byte to ulg/ush/uch,; removed old inflate, renamed inflate_entry; to inflate, added Mark's fix to a comment.; c10.5 14 Dec 92 M. Adler fix up error messages for incomplete trees.; c11 2 Jan 93 M. Adler fixed bug in detection of incomplete; tables, and removed assumption that EOB is; the longest code (bad assumption).; c12 3 Jan 93 M. Adler make tables for fixed blocks only once.; c13 5 Jan 93 M. Adler allow all zero length codes (pkzip 2.04c; outputs one zero length code for an empty; distance tree).; c14 12 Mar 93 M. Adler made inflate.c sta",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZInflate.c:1594,optimiz,optimization,1594,core/zip/src/ZInflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZInflate.c,1,['optimiz'],['optimization']
Performance,"er. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for cases (a) and (b) to work the sequence %x-%y above has; // to be preserved by the IR passes.; //; // However, several optimization passes might sink `load` instruction; // or hoist `getelementptr` instruction so that the instructions are; // no longer in sequence. Examples of such passes are:; // SimplifyCFGPass, InstCombinePass, GVNPass.; // After such modification the verifier would reject the BPF program.; //; // To avoid this issue the patterns like (load/store (getelementptr ...)); // are replaced by calls to BPF specific intrinsic functions:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; //; // These calls are lowered back to (load/store (getelementptr ...)); // by BPFCheckAndAdjustIR pass right before the translation from IR to; // machine instructions.; //; // The transformation is split into the following steps:; // - When IR is generated from AST the calls to intrinsic function; // llvm.preserve.static.offset are inserted.; // - BPFPreserveStaticOffsetPass is executed as early as possible; // with AllowPatial set to true, this handles marked GEP chains; // with constant offsets.; // - BPFPreserveStaticOffsetPass is executed at ScalarOptimizerLateEPCallback; // with AllowPatial set to false, this handles marked GEP chains; // with offsets that became constant after loop unrolling, e.g.; // to handle the following code:; //; // struct context { int x[4]; } __attribute__((preserve_static_offset));; //; // struct context *ctx = ...;; // #pragma clang loop unroll(full); // for (int i = 0; i < 4; ++i); // foo(ctx->x[i]);; //; // The early BPFPreserveStaticOffsetPass run is necessary to allow; // addi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:2673,load,load,2673,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,1,['load'],['load']
Performance,"er; template), but the minimisation with respect to these additional parameters is; done analytically rather than introducing them as formal fit parameters. Some; special care needs to be taken in the case of bins with zero content. For more; details please see the original publication cited above. An example application of this fit is given below. For a TH1* histogram; (""data"") fitted as the sum of three Monte Carlo sources (""mc""):. ~~~{.cpp}; {; TH1F *data; //data histogram; TH1F *mc0; // first MC histogram; TH1F *mc1; // second MC histogram; TH1F *mc2; // third MC histogram; .... // retrieve histograms; TObjArray *mc = new TObjArray(3); // MC histograms are put in this array; mc->Add(mc0);; mc->Add(mc1);; mc->Add(mc2);; TFractionFitter* fit = new TFractionFitter(data, mc); // initialise; fit->Constrain(1,0.0,1.0); // constrain fraction 1 to be between 0 and 1; fit->SetRangeX(1,15); // use only the first 15 bins in the fit; Int_t status = fit->Fit(); // perform the fit; std::cout << ""fit status: "" << status << std::endl;; if (status == 0) { // check on fit status; TH1F* result = (TH1F*) fit->GetPlot();; data->Draw(""Ep"");; result->Draw(""same"");; }; }; ~~~. ## Assumptions; A few assumptions need to be made for the fit procedure to be carried out:; 1 The total number of events in each template is not too small; (so that its Poisson uncertainty can be neglected).; 2 The number of events in each bin is much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). ## Instantiation; A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:1701,perform,perform,1701,hist/hist/src/TFractionFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx,1,['perform'],['perform']
Performance,"ered, *e.g.* if the PDF is zero at xMin and non-zero at xMax. A rising tail may appear at xMin.; /// This is inevitable when using FFTs. A distribution with 3 bins therefore looks like:; /// ```; /// ... 0 1 2 0 1 2 0 1 2 ...; /// ```; ///; /// Therefore, if bins 0 and 2 are not equal, the FFT sees a cyclical function with a step at the 2|0 boundary, which causes; /// artifacts in Fourier space.; ///; /// The spillover or discontinuity can be reduced or eliminated by; /// introducing a buffer zone in the FFT calculation. If this feature is activated (on by default),; /// the sampling array for the FFT calculation is extended in both directions,; /// and padded with the lowest/highest bin.; /// Example:; /// ```; /// original: -5 -4 -3 -2 -1 0 +1 +2 +3 +4 +5; /// add buffer zones: U U -5 -4 -3 -2 -1 0 +1 +2 +3 +4 +5 O O; /// rotate: 0 +1 +2 +3 +4 +5 O O U U -5 -4 -3 -2 -1; /// ```; /// The buffer bins are stripped away when the FFT output values; /// are transferred back to the p.d.f cache. The default buffer size is 10% of the; /// observable domain size, and can be changed with the `setBufferFraction()` member function.; ///; /// The RooFFTConvPdf uses caching inherited from a RooAbsCachedPdf. If it is; /// evaluated for a particular value of x, the FFT and convolution is calculated; /// for all bins in the observable space for the given choice of parameters,; /// which are also stored in the cache. Subsequent evaluations for different values of the convolution observable and; /// identical parameters will be retrieved from the cache. If one or more; /// of the parameters change, the cache will be updated, *i.e.*, a new FFT runs.; ///; /// The sampling density of the FFT is controlled by the binning of the; /// the convolution observable, which can be changed using RooRealVar::setBins(N).; /// For good results, N should be large (>=1000). Additional interpolation; /// between the bins may improve the result if coarse binnings are chosen. These can be; /// activated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:2725,cache,cache,2725,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['cache'],['cache']
Performance,"ernal buffers; * or an error code, which can be tested using ZSTD_isError().; *; * At any moment, it's possible to flush whatever data might remain stuck within internal buffer,; * using ZSTD_compressStream2() with ZSTD_e_flush. `output->pos` will be updated.; * Note that, if `output->size` is too small, a single invocation with ZSTD_e_flush might not be enough (return code > 0).; * In which case, make some room to receive more compressed data, and call again ZSTD_compressStream2() with ZSTD_e_flush.; * You must continue calling ZSTD_compressStream2() with ZSTD_e_flush until it returns 0, at which point you can change the; * operation.; * note: ZSTD_e_flush will flush as much output as possible, meaning when compressing with multiple threads, it will; * block until the flush is complete or the output buffer is full.; * @return : 0 if internal buffers are entirely flushed,; * >0 if some data still present within internal buffer (the value is minimal estimation of remaining size),; * or an error code, which can be tested using ZSTD_isError().; *; * Calling ZSTD_compressStream2() with ZSTD_e_end instructs to finish a frame.; * It will perform a flush and write frame epilogue.; * The epilogue is required for decoders to consider a frame completed.; * flush operation is the same, and follows same rules as calling ZSTD_compressStream2() with ZSTD_e_flush.; * You must continue calling ZSTD_compressStream2() with ZSTD_e_end until it returns 0, at which point you are free to; * start a new frame.; * note: ZSTD_e_end will flush as much output as possible, meaning when compressing with multiple threads, it will; * block until the flush is complete or the output buffer is full.; * @return : 0 if frame fully completed and fully flushed,; * >0 if some data still present within internal buffer (the value is minimal estimation of remaining size),; * or an error code, which can be tested using ZSTD_isError().; *; * *******************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:3208,perform,perform,3208,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['perform'],['perform']
Performance,"erprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reachability used by the reference graph is a conservative approximation; /// that still allows us to have independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call graph occur we want to achieve two different things:; ///; /// - We need to update the call graph in-flight and invalidate analyses; /// cached on entities in the graph. Because of the cache-based analysis; /// design of the pass manager, it is essential to have stable identities for; /// the elements of the IR that passes traverse, and to invalidate any; /// analyses cached on these elements as the mutations take place.; ///; /// - We want to preserve the incremental and post-order traversal of the; /// graph even as it is refined and mutated. This means we want optimization; /// to observe the most refined form of the call graph and to do so in; /// post-order.; ///; /// To address this, the CGSCC manager uses both worklists that can be expanded; /// by passes which transform the IR, and provides invalidation tests to skip; /// entries that become dead. This extra data is provided to every SCC pass so; /// that it can carefully update the manager's traversal as the call graph; /// mutates.; ///; /// We also provide support for running function passes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:3187,cache,cached,3187,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,1,['cache'],['cached']
Performance,"es a specification format - `Summary' - and; // contains descriptions of some library functions in this format. Each; // specification contains a list of branches for splitting the program state; // upon call, and range constraints on argument and return-value symbols that; // are satisfied on each branch. This spec can be expanded to include more; // items, like external effects of the function.; //; // The main difference between this approach and the body farms technique is; // in more explicit control over how many branches are produced. For example,; // consider standard C function `ispunct(int x)', which returns a non-zero value; // iff `x' is a punctuation character, that is, when `x' is in range; // ['!', '/'] [':', '@'] U ['[', '\`'] U ['{', '~'].; // `Summary' provides only two branches for this function. However,; // any attempt to describe this range with if-statements in the body farm; // would result in many more branches. Because each branch needs to be analyzed; // independently, this significantly reduces performance. Additionally,; // once we consider a branch on which `x' is in range, say, ['!', '/'],; // we assume that such branch is an important separate path through the program,; // which may lead to false positives because considering this particular path; // was not consciously intended, and therefore it might have been unreachable.; //; // This checker uses eval::Call for modeling pure functions (functions without; // side effets), for which their `Summary' is a precise model. This avoids; // unnecessary invalidation passes. Conflicts with other checkers are unlikely; // because if the function has no other effects, other checkers would probably; // never want to improve upon the modeling done by this checker.; //; // Non-pure functions, for which only partial improvement over the default; // behavior is expected, are modeled via check::PostCall, non-intrusively.; //; //===---------------------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:1514,perform,performance,1514,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,1,['perform'],['performance']
Performance,"es can be referred to by their full name, like in the example above,; or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of; ""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree). \note A common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their; entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original; one: rows will be mismatched. Indexed friend trees provide a way to perform simple joins of multiple trees over a common column.; When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the; ""index"" columns have a value identical to the one in the main one. For example, in Python:. ~~~{.py}; main_tree = ...; aux_tree = ... # If a friend tree has an index on `commonColumn`, when the main tree loads; # a given row, it also loads the row of the friend tree that has the same; # value of `commonColumn`; aux_tree.BuildIndex(""commonColumn""). mainTree.AddFriend(aux_tree). df = ROOT.RDataFrame(mainTree); ~~~. RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode. \anchor other-file-formats; ### Reading data formats other than ROOT trees; RDataFrame can be interfaced with RDataSources. The ROOT::RDF::RDataSource interface defines an API that RDataFrame can use to read arbitrary columnar data formats. RDataFrame calls into concrete RDataSource implementations to retrieve information about the data, retrieve (thread-local) readers or ""cursors"" for selected columns; and to advance the readers to the desired data entry.; Some predefined RDataSources are natively provided by ROOT such as the ROOT::RDF::RCsvDS which allows to read comma separated files:; ~~~{.cpp}; auto tdf = ROOT::RDF::FromCSV(""MuRun2010B.csv"");; auto filteredEvents =; tdf.Filter(",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:73517,load,loads,73517,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,2,['load'],['loads']
Performance,"es having TUBESEG; shape. Other divisions can also create slices having shapes with different; dimensions, e.g. the division of a TRD1 volume on Z.; When positioning volumes inside slices, one can do it using the generic; volume family (e.g. slicey). This should be done as if the coordinate system; of the generic slice was the same as the one of the divided volume. The generic; slice in case of PHI division is centered with respect to X axis. If the; family contains slices of different sizes, any volume positioned inside should; fit into the smallest one.; Examples for specific divisions according to shape types can be found inside; shape classes. ~~~ {.cpp}; TGeoVolume::Divide(N, Xmin, Xmax, ""X"");; ~~~. The GEANT3 option MANY is supported by TGeoVolumeOverlap class. An overlapping; volume is in fact a virtual container that does not represent a physical object.; It contains a list of nodes that are not its daughters but that must be checked; always before the container itself. This list must be defined by users and it; is checked and resolved in a priority order. Note that the feature is non-standard; to geometrical modelers and it was introduced just to support conversions of; GEANT3 geometries, therefore its extensive usage should be avoided.; */; /** \class TGeoVolumeAssembly; \ingroup Geometry_classes. Volume assemblies. Assemblies a volumes that have neither a shape or a material/medium. Assemblies; behave exactly like normal volumes grouping several daughters together, but; the daughters can never extrude the assembly since this has no shape. However,; a bounding box and a voxelization structure are built for assemblies as for; normal volumes, so that navigation is still optimized. Assemblies are useful; for grouping hierarchically volumes which are otherwise defined in a flat; manner, but also to avoid clashes between container shapes.; To define an assembly one should just input a name, then start adding other; volumes (or volume assemblies) as content.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoVolume.cxx:17777,optimiz,optimized,17777,geom/geom/src/TGeoVolume.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoVolume.cxx,1,['optimiz'],['optimized']
Performance,"esult of a comparison is TRUE, the result is 1, otherwise 0. Already predefined names can be given. For example, if the formula. TFormula old(sin(x*(x<0.5 || x>1))) one can assign a name to the formula. By default; the name of the object = title = formula itself.; old.SetName(""old"").; then, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShift) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. ### CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. ### WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:1980,perform,performance,1980,hist/hist/src/TFormula_v5.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx,1,['perform'],['performance']
Performance,"et limits on one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used.; /// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; /// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; /// ""WIDTH"" | Scales the histogran bin content by the bin width (useful for variable bins histograms); /// ""SERIAL"" | Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; /// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; ///; /// The default fitting of an histogram (when no option is given) is perfomed as following:; /// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3871,multi-thread,multi-thread,3871,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,3,"['Perform', 'multi-thread']","['Perform', 'multi-thread']"
Performance,"etEntry(n)__ - returns the n-th entry number; - __Next__() - returns next entry number. Note, that this function is; much faster than GetEntry, and it's called when GetEntry() is called; for 2 or more indices in a row. ## TTree::Draw() and TChain::Draw(). Use option __entrylist__ to write the results of TTree::Draw and TChain::Draw into; an entry list. Example:; ~~~ {.cpp}; tree->Draw("">>elist"", ""x<0 && y>0"", ""entrylist"");; TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; ~~~; ## Example of Loop on TEntryList with a TChain; ~~~ {.cpp}; void loopChain() {; TFile *fe = TFile::Open(""myelist.root"");; TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; TChain *chain = new TChain(""ntuple"");; chain->Add(""hsimple.root"");; chain->Add(""hsimple2.root"");; Long64_t listEntries = myelist->GetN();; Long64_t chainEntries = chain->GetEntries();; Int_t treenum = 0;; chain->SetEntryList(myelist);. for (entry=start;entry < end;entry++) {; entryNumber = chain->GetEntryNumber(entry);; if (entryNumber < 0) break;; localEntry = chain->LoadTree(entryNumber);; if (localEntry < 0) break;; ....; then either call; branch->GetEntry(localEntry);; or; chain->GetEntry(entryNumber);; In the later case the LoadTree is then somewhat redundant.; ...; }; }; ~~~; When using the TEntryList interface directly, you can get the 'tree number' and entry in; the current tree (i.e. value similar to the return value of LoadTree) from calling; TEntryList::GetEntryAndTree:; ~~~ {.cpp}; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; ~~~; to obtain the entry number within the chain you need to add to it the value of; `treeEntry+ch->GetTreeOffset()[treenum]`; such that the loop in the previous example can also be written as:; ~~~ {.cpp}; for (Long64_t el = 0; el < listEntries; el++) {; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:2242,Load,LoadTree,2242,tree/tree/src/TEntryList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx,1,['Load'],['LoadTree']
Performance,"etValue call triggers the event loop; std::cout << ""Number of processed entries: "" << resultPtr.GetValue() << std::endl;; }; ~~~. See the Book() method for more information and [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html); for a more complete example. #### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(). Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; executes the callable on the values of those columns for each event that passes all upstream selections.; It can be used to perform actions that are not already available in the interface. For example, the following snippet; evaluates the root mean square of column ""x"":; ~~~{.cpp}; // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; thread will execute the expression concurrently.; The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; this is probably too much head-scratch for such a simple operation. ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; ~~~{.cpp}; // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; co",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:69898,multi-thread,multi-thread,69898,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,2,"['concurren', 'multi-thread']","['concurrently', 'multi-thread']"
Performance,"eter - the name of undo method; Since redo,undo methods are the same, undo name can be omitted, e.g.; ~~~ {.cpp}; TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");; ~~~; For objects derived from TObject class name can be omitted, e.g.; ~~~ {.cpp}; TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");; ~~~. 2. Setting undo, redo parameters.; ~~~ {.cpp}; Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);; ~~~; 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values; Since the number of undo,redo parameters is the same one can use; ~~~ {.cpp}; com->SetArgs(1, new_color, old_color);; ~~~. 3. Undo, redo method execution; ~~~ {.cpp}; com->Redo(); // execute redo method; com->Undo(); // execute undo method; ~~~. 4. Merged commands; It possible to group several commands together so an end user; can undo and redo them with one command.; ~~~ {.cpp}; TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);; ~~~. 5. Macro commands; ""Merging"" allows to create macro commands, e.g.; ~~~ {.cpp}; TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);; ...; ~~~; During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager.; TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used.; ~~~ {.cpp}; TQUndoManager *history = new TQUndoManager();; history->Add(com);; ~~~; TQUndoManager::Add automatically invokes execution of command's Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TQCommand.cxx:3050,perform,performing,3050,core/base/src/TQCommand.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TQCommand.cxx,1,['perform'],['performing']
Performance,"f each thread is initialized to this value (or is default-constructed if the parameter is omitted); /// \return the result of the aggregation wrapped in a RResultPtr.; ///; /// An aggregator callable takes two values, an aggregator variable and a column value. The aggregator variable is; /// initialized to aggIdentity or default-constructed if aggIdentity is omitted.; /// This action calls the aggregator callable for each processed entry, passing in the aggregator variable and; /// the value of the column columnName.; /// If the signature is `U(U,T)` the aggregator variable is then copy-assigned the result of the execution of the callable.; /// Otherwise the signature of aggregator must be `void(U&,T)`.; ///; /// The merger callable is used to merge the partial accumulation results of each processing thread. It is only called in multi-thread executions.; /// If its signature is `U(U,U)` the aggregator variables of each thread are merged two by two.; /// If its signature is `void(std::vector<U>& a)` it is assumed that it merges all aggregators in a[0].; ///; /// This action is *lazy*: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr.; ///; /// Example usage:; /// ~~~{.cpp}; /// auto aggregator = [](double acc, double x) { return acc * x; };; /// ROOT::EnableImplicitMT();; /// // If multithread is enabled, the aggregator function will be called by more threads; /// // and will produce a vector of partial accumulators.; /// // The merger function performs the final aggregation of these partial results.; /// auto merger = [](std::vector<double> &accumulators) {; /// for (auto i : ROOT::TSeqU(1u, accumulators.size())) {; /// accumulators[0] *= accumulators[i];; /// }; /// };; ///; /// // The accumulator is initialized at this value by every thread.; /// double initValue = 1.;; ///; /// // Multiplies all elements of the column ""x""; /// auto result = d.Aggregate(aggregator, merger, ""x"", initValue);; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:2500,perform,performs,2500,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['perform'],['performs']
Performance,"f points/lines/segments.; - Some need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). \image html base_tbuffer3d.png. The `SectionsValid() / SetSectionsValid / ClearSectionsValid()` methods of; TBuffer3D are used to test/set/clear these section valid flags. The sections found in TBuffer3D (`Core/BoundingBox/Raw Sizes/Raw`) are sufficient; to describe any tessellated shape in a generic fashion. An additional; `ShapeSpecific` section in derived shape specific classes allows a more abstract; shape description (""a sphere of inner radius x, outer radius y""). This; enables a viewer which knows how to draw (tessellate) the shape itself to do so,; which can bring considerable performance and quality benefits, while providing a; generic fallback suitable for all viewers. The rules for client negotiation with the viewer are:. - If suitable specialized TBuffer3D class exists, use it, otherwise use TBuffer3D.; - Complete the mandatory Core section.; - Complete the ShapeSpecific section if applicable.; - Complete the BoundingBox if you can.; - Pass this buffer to the viewer using one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) AddObject(); will return flags indicating which ones, otherwise it returns kNone. You must; fill the buffer and mark these sections valid, and pass the buffer again. A; typical code snippet would be:. ~~~ {.cpp}; TBuffer3DSphere sphereBuffer;; // Fill out kCore...; // Fill out kBoundingBox...; // Fill out kShapeSpecific for TBuffer3DSphere; // Try first add to viewer; Int_t reqSections = viewer-&gt;AddObject(buffer);; if (reqSections != TBuffer3D::kNone) {; if (reqS",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer3D.cxx:1404,perform,performance,1404,core/base/src/TBuffer3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer3D.cxx,1,['perform'],['performance']
Performance,"f the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is the LLVM loop vectorizer. This pass modifies 'vectorizable' loops; // and generates target-independent LLVM-IR.; // The vectorizer uses the TargetTransformInfo analysis to estimate the costs; // of instructions in order to estimate the profitability of vectorization.; //; // The loop vectorizer combines consecutive loop iterations into a single; // 'wide' iteration. After this transformation the index is incremented; // by the SIMD vector width, and not by one.; //; // This pass has four parts:; // 1. The main loop pass that drives the different parts.; // 2. LoopVectorizationLegality - A unit that checks for the legality; // of the vectorization.; // 3. InnerLoopVectorizer - A unit that performs the actual; // widening of instructions.; // 4. LoopVectorizationCostModel - A unit that checks for the profitability; // of vectorization. It decides on the optimal vector width, which; // can be one, if vectorization is not profitable.; //; // There is a development effort going on to migrate loop vectorizer to the; // VPlan infrastructure and to introduce outer loop vectorization support (see; // docs/VectorizationPlan.rst and; // http://lists.llvm.org/pipermail/llvm-dev/2017-December/119523.html). For this; // purpose, we temporarily introduced the VPlan-native vectorization path: an; // alternative vectorization path that is natively implemented on top of the; // VPlan infrastructure. See EnableVPlanNativePath for enabling.; //; //===----------------------------------------------------------------------===//; //; // The reduction-variable vectorization is based on the paper:; // D. Nuzman and R. Henderson. Multi-platform Auto-vectorization.; //; // Variable uniformity checks are",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:1088,perform,performs,1088,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,1,['perform'],['performs']
Performance,"f the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able to; /// form even a potential call edge from a function body which may dynamically; /// load the function and call it.; ///; /// This analysis still requires updates to remain valid after optimizations; /// which could potentially change the set of potential callees. The; /// constraints it operates under only make the traversal order remain valid.; ///; /// The entire analysis must be re-computed if full interprocedural; /// optimizations run at any point. For example, globalopt completely; /// invalidates the information in this analysis.; ///; /// FIXME: This class is named LazyCallGraph in a lame attempt to distinguish; /// it from the existing CallGraph. At some point, it is expected that this; /// will be the only call graph and it will be renamed accordingly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:2135,load,load,2135,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,3,"['load', 'optimiz']","['load', 'optimizations']"
Performance,"f the use of chi-square and likelihood functions in fits to histograms,”; /// Nucl. Instrum. Meth. 221 (1984) 437.; ///; /// \f[; /// NLL = \sum_{i}{( f(x(i) | p ) + y(i)\log(y(i)/ f(x(i) | p )) - y(i)) }; /// \f]; /// By using this formulation, `2*NLL` can be interpreted as the chi-square resulting from the fit.; ///; /// This method should be always used when the bin content represents counts (i.e. errors are sqrt(N) ).; /// The likelihood method has the advantage of treating correctly bins with low statistics. In case of high; /// statistics/bin the distribution of the bin content becomes a normal distribution and the likelihood and the chi2 fit; /// give the same result.; ///; /// The likelihood method, although a bit slower, it is therefore the recommended method,; /// when the histogram represent counts (Poisson statistics), where the chi-square methods may; /// give incorrect results, especially in case of low statistics.; /// In case of a weighted histogram, it is possible to perform also a likelihood fit by using the; /// option ""WL"". Note a weighted histogram is a histogram which has been filled with weights and it; /// has the information on the sum of the weight square for each bin ( TH1::Sumw2() has been called).; /// The bin error for a weighted histogram is the square root of the sum of the weight square.; ///; /// \anchor HFitRes; /// ### Fit Result; ///; /// The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; /// By default the TFitResultPtr contains only the status of the fit which is return by an; /// automatic conversion of the TFitResultPtr to an integer. One can write in this case directly:; ///; /// ~~~ {.cpp}; /// Int_t fitStatus = h->Fit(myFunc);; /// ~~~; ///; /// If the option ""S"" is instead used, TFitResultPtr behaves as a smart; /// pointer to the TFitResult object. This is useful for retrieving the full result information from the fit, such as the covariance matrix,; /// as shown in this example code:; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:9235,perform,perform,9235,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['perform'],['perform']
Performance,"f$ discriminating variables used in the MVA:. \f[; L_S(i) \ \prod_{j=1}^{N_{var}} p_{Sj} (i); \f]. and accordingly for \f$ L_B \f$.; In practise, TMVA uses polynomial splines to estimate the probability; density functions (PDF) obtained from the distributions of the; training variables. Note that in TMVA the output of the likelihood ratio is transformed by:. \f[; R_L(i) \to R'_L(i) = -\frac{1}{\tau} ln(R_L^{-1}(i) -1); \f]. to avoid the occurrence of heavy peaks at \f$ R_L = 0.1 \f$ . #### Decorrelated (or ""diagonalized"") Likelihood. The biggest drawback of the Likelihood approach is that it assumes; that the discriminant variables are uncorrelated. If it were the case,; it can be proven that the discrimination obtained by the above likelihood; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. </p>. Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; \f$ C \f$ is the matrix \f$ C&prime; \f$ that multiplied with itself; yields \f$ C \f$: \f$ C \f$=\f$ C&prime;C&prime; \f$. We compute the; square-root matrix (SQM) by means of diagonalising (\f$ D \f$) the; covariance matrix:. \f[; D = S^TCS \Rightarrow C' = S \sqrt{DS^T}; \f]. and the linear transformation of the linearly correlated into the; uncorrelated variables space is then given by multiplying the measured; variable tuple by the inverse of the SQM. Note that these transformations; are performed for both signal and background separately, since the; correlation pattern is not the same in the two samples. The above diagonalisation is complete for linearly correlated,; Gaussian distributed variables only. In real-world examples this; is not often the case, so that only little additional information; may be recovered by the diagonalisation procedure. In these cases,; non-linear methods must be applied.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodLikelihood.cxx:3514,perform,performed,3514,tmva/tmva/src/MethodLikelihood.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodLikelihood.cxx,1,['perform'],['performed']
Performance,"f(x) dx}.; * \f]; * <tr><td> `Range(double lo, double hi)` <td> Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; * <tr><td> `SumCoefRange(const char* name)` <td> Set the range in which to interpret the coefficients of RooAddPdf components; * <tr><td> `NumCPU(int num, int istrat)` <td> Parallelize NLL calculation on num CPUs; * <table>; * <tr><th> Strategy <th> Effect; * <tr><td> 0 = RooFit::BulkPartition - *default* <td> Divide events in N equal chunks; * <tr><td> 1 = RooFit::Interleave <td> Process event i%N in process N. Recommended for binned data with; * a substantial number of zero-bins, which will be distributed across processes more equitably in this strategy; * <tr><td> 2 = RooFit::SimComponents <td> Process each component likelihood of a RooSimultaneous fully in a single process; * and distribute components over processes. This approach can be beneficial if normalization calculation time; * dominates the total computation time of a component (since the normalization calculation must be performed; * in each process in strategies 0 and 1. However beware that if the RooSimultaneous components do not share many; * parameters this strategy is inefficient: as most minuit-induced likelihood calculations involve changing; * a single parameter, only 1 of the N processes will be active most of the time if RooSimultaneous components; * do not share many parameters; * <tr><td> 3 = RooFit::Hybrid <td> Follow strategy 0 for all RooSimultaneous components, except those with less than; * 30 dataset entries, for which strategy 2 is followed.; * </table>; * <tr><td> `EvalBackend(std::string const&)` <td> Choose a likelihood evaluation backend:; * <table>; * <tr><th> Backend <th> Description; * <tr><td> **cpu** - *default* <td> New vectorized evaluation mode, using faster math functions and auto-vectorisation.; * Since ROOT 6.23, this is the default if `EvalBackend()` is not passed, succeeding the **legacy** backend.; * If all R",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:2715,perform,performed,2715,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['perform'],['performed']
Performance,"fit.sourceforge.net/license.txt) *; *****************************************************************************/; //////////////////////////////////////////////////////////////////////////////; /// \class RooFFTConvPdf; /// \ingroup Roofitcore; ///; /// This class implements a generic one-dimensional numeric convolution of two PDFs,; /// and can convolve any two RooAbsPdfs. The class exploits the convolution theorem; /// \f[; /// f(x) * g(x) \rightarrow F(k_i) \cdot G(k_i); /// \f]; /// to calculate the convolution by calculating a Real->Complex FFT of both input PDFs,; /// multiplying the complex coefficients and performing the reverse Complex->Real FFT; /// to get the result in the input space. This class uses the ROOT FFT interface to; /// the (free) FFTW3 package (www.fftw.org), and requires that your ROOT installation is; /// compiled with the `fftw3=ON` (default). Instructions for manually installing fftw below.; ///; /// Note that the performance in terms of speed and stability of RooFFTConvPdf is; /// vastly superior to that of RooNumConvPdf.; ///; /// An important feature of FFT convolutions is that the observable is assumed to be; /// cyclical. This is correct for cyclical observables such as angles,; /// but does not hold in general. For non-cyclical variables, wrap-around artifacts may be; /// encountered, *e.g.* if the PDF is zero at xMin and non-zero at xMax. A rising tail may appear at xMin.; /// This is inevitable when using FFTs. A distribution with 3 bins therefore looks like:; /// ```; /// ... 0 1 2 0 1 2 0 1 2 ...; /// ```; ///; /// Therefore, if bins 0 and 2 are not equal, the FFT sees a cyclical function with a step at the 2|0 boundary, which causes; /// artifacts in Fourier space.; ///; /// The spillover or discontinuity can be reduced or eliminated by; /// introducing a buffer zone in the FFT calculation. If this feature is activated (on by default),; /// the sampling array for the FFT calculation is extended in both directions,; /// and pad",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:1349,perform,performance,1349,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['perform'],['performance']
Performance,"fter the completion of a deflate block, i.e. after all input has been; consumed and all output has been delivered when using any of the flush; options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH. The; compressor and decompressor must use exactly the same dictionary (see; inflateSetDictionary). The dictionary should consist of strings (byte sequences) that are likely; to be encountered later in the data to be compressed, with the most commonly; used strings preferably put towards the end of the dictionary. Using a; dictionary is most useful when the data to be compressed is short and can be; predicted with good accuracy; the data can then be compressed better than; with the default empty dictionary. Depending on the size of the compression data structures selected by; deflateInit or deflateInit2, a part of the dictionary may in effect be; discarded, for example if the dictionary is larger than the window size; provided in deflateInit or deflateInit2. Thus the strings most likely to be; useful should be put at the end of the dictionary, not at the front. In; addition, the current implementation of deflate will use at most the window; size minus 262 bytes of the provided dictionary. Upon return of this function, strm->adler is set to the adler32 value; of the dictionary; the decompressor may later use this value to determine; which dictionary has been used by the compressor. (The adler32 value; applies to the whole dictionary even if only a subset of the dictionary is; actually used by the compressor.) If a raw deflate was requested, then the; adler32 value is not computed and strm->adler is not set. deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a; parameter is invalid (e.g. dictionary being Z_NULL) or the stream state is; inconsistent (for example if deflate has already been called for this stream; or if not at a block boundary for raw deflate). deflateSetDictionary does; not perform any compression: this will be done by deflate().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:2312,perform,perform,2312,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['perform'],['perform']
Performance,"g (e.g. 1000 or 10000) bins without incurring a; corresponding CPU penalty. Note on numeric stability of the algorithm. Since the algorithm relies; on a numeric inversion of cumulative distributions functions, some precision; may be lost at the 'edges' of the same (i.e. at regions in x where the; c.d.f. value is close to zero or one). The general sampling strategy is; to start with 64 equally spaces samples in the range y=(0.01-0.99).; Then the y ranges are pushed outward by reducing y (or the distance of y to 1.0); by a factor of sqrt(10) iteratively up to the point where the corresponding; x value no longer changes significantly. For p.d.f.s with very flat tails; such as Gaussians some part of the tail may be lost due to limitations; in numeric precision in the CDF inversion step. An effect related to the above limitation in numeric precision should; be anticipated when floating the alpha parameter in a fit. If a p.d.f; with such flat tails is fitted, it is likely that the dataset contains; events in the flat tail region. If the alpha parameter is varied, the; likelihood contribution from such events may exhibit discontinuities; in alpha, causing discontinuities in the summed likelihood as well; that will cause convergence problems in MINUIT. To mitigate this effect; one can use the setCacheAlpha() method to instruct RooIntegralMorph; to construct a two-dimensional cache for its output values in both; x and alpha. If linear interpolation is requested on the resulting; output histogram, the resulting interpolation of the p.d.f in the; alpha dimension will smooth out the discontinuities in the tail regions; result in a continuous likelihood distribution that can be fitted.; An added advantage of the cacheAlpha option is that if parameters; p,q of f1,f2 are fixed, the cached values in RooIntegralMorph are; valid for the entire fit session and do not need to be recalculated; for each change in alpha, which may result an considerable increase; in calculation speed. **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx:3795,cache,cache,3795,roofit/roofit/src/RooIntegralMorph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx,3,['cache'],"['cache', 'cacheAlpha', 'cached']"
Performance,"g""; alt=""DOI""></a>; \endhtmlonly. ## For the impatient user; You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python. ## Table of Contents; - [Cheat sheet](\ref cheatsheet); - [Introduction](\ref introduction); - [Crash course](\ref crash-course); - [Working with collections](\ref collections); - [Transformations: manipulating data](\ref transformations); - [Actions: getting results](\ref actions); - [Distributed execution in Python](\ref distrdf); - [Performance tips and parallel execution](\ref parallel-execution); - [More features](\ref more-features); - [Systematic variations](\ref systematics); - [RDataFrame objects as function arguments and return values](\ref rnode); - [Storing RDataFrame objects in collections](\ref RDFCollections); - [Executing callbacks every N events](\ref callbacks); - [Default column lists](\ref default-branches); - [Special helper columns: `rdfentry_` and `rdfslot_`](\ref helper-cols); - [Just-in-time compilation: column type inference and explicit declaration of column types](\ref jitting); - [User-defined custom actions](\ref generic-actions); - [Dataset joins with friend trees](\ref friends); - [Reading data formats other than ROOT trees](\ref other-file-formats); - [Computation graphs (storing and reusing sets of transformations)](\ref callgraphs); - [Visualizing the computation graph](\ref representgraph); - [Activating RDataFrame execution logs](\ref rdf-logging); - [Creating an RDataFrame from a dataset specification file](\ref rdf-from-spec); - [Adding a progress bar](\ref progressbar); - [Working with missing values in the dataset](\ref missing-values); - [Efficient analysis in Python](\ref python); - <a class=""el"" href=""classROOT_1_1RDataFrame.html#reference"" onclick=""javascript:toggleInherit('pub_methods_classROOT_1_1RDF_1_1RInterface')"">Class reference</a>. \anchor cheatsheet; ## Cheat sheet; These are the operations which can be performed ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:1742,Perform,Performance,1742,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['Perform'],['Performance']
Performance,"g. via a high latency network. For each TTree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted.; The user can change the size of the cache with the TTree::SetCacheSize method; (by default the size is 30 Megabytes). This feature can be controlled with the; environment variable `ROOT_TTREECACHE_SIZE` or the TTreeCache.Size option.; The entry range for which the cache is active can also be set with the; SetEntryRange method. \anchor changesbehaviour; ## Changes of behavior when using TChain and TEventList. The usage of TChain or TEventList have influence on the behaviour of the cache:. - Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. - Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning phase is started or restarted when:; - TTree automatically creates a cache.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTreeCache::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; - TTreeCache::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries.; - A 'cached' TChain switches over to a new file. \anchor cachemisses; ## Self-optimization in presence of cache misses. The TTreeCache can optimize its behavior on a cache miss. When; miss optimization is enabled (see the SetOptimizeMisses method),; it tracks all branches utilized after the learning phase which caused a cache; miss.; When one cache miss occurs, all the utilized branches are be prefetched; fo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:4113,cache,cache,4113,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"gether, this means we need to adjust the; /// type of boolean operations to be regbank legal. All SALU booleans need to be; /// widened to 32-bits, and all VALU booleans need to be s1 values.; ///; /// A noteworthy exception to the s1-means-vcc rule is for legalization artifact; /// casts. G_TRUNC s1 results, and G_SEXT/G_ZEXT/G_ANYEXT sources are never vcc; /// bank. A non-boolean source (such as a truncate from a 1-bit load from; /// memory) will require a copy to the VCC bank which will require clearing the; /// high bits and inserting a compare.; ///; /// \par Constant bus restriction; ///; /// VALU instructions have a limitation known as the constant bus; /// restriction. Most VALU instructions can use SGPR operands, but may read at; /// most 1 SGPR or constant literal value (this to 2 in gfx10 for most; /// instructions). This is one unique SGPR, so the same SGPR may be used for; /// multiple operands. From a register bank perspective, any combination of; /// operands should be legal as an SGPR, but this is contextually dependent on; /// the SGPR operands all being the same register. There is therefore optimal to; /// choose the SGPR with the most uses to minimize the number of copies.; ///; /// We avoid trying to solve this problem in RegBankSelect. Any VALU G_*; /// operation should have its source operands all mapped to VGPRs (except for; /// VCC), inserting copies from any SGPR operands. This the most trivial legal; /// mapping. Anything beyond the simplest 1:1 instruction selection would be too; /// complicated to solve here. Every optimization pattern or instruction; /// selected to multiple outputs would have to enforce this rule, and there; /// would be additional complexity in tracking this rule for every G_*; /// operation. By forcing all inputs to VGPRs, it also simplifies the task of; /// picking the optimal operand combination from a post-isel optimization pass.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:3648,optimiz,optimization,3648,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,2,['optimiz'],['optimization']
Performance,"ght (c) 2015-2023 yWorks GmbH; * Copyright (c) 2013-2015 by Vitaly Puzrin; *; *; * Permission is hereby granted, free of charge, to any person obtaining a copy; * of this software and associated documentation files (the ""Software""), to deal; * in the Software without restriction, including without limitation the rights; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; * copies of the Software, and to permit persons to whom the Software is; * furnished to do so, subject to the following conditions:; *; * The above copyright notice and this permission notice shall be included in all; * copies or substantial portions of the Software.; *; * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; * SOFTWARE.; */; /******************************************************************************; Copyright (c) Microsoft Corporation. Permission to use, copy, modify, and/or distribute this software for any; purpose with or without fee is hereby granted. THE SOFTWARE IS PROVIDED ""AS IS"" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH; REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY; AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,; INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM; LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR; OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR; PERFORMANCE OF THIS SOFTWARE.; ***************************************************************************** */; /* global Reflect, Promise */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:1899,PERFORM,PERFORMANCE,1899,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,1,['PERFORM'],['PERFORMANCE']
Performance,"gical_lane_id /= 2;; /// ShuffleReduceFn(reduce_data, logical_lane_id,; /// remote_id-1-threadIdx.x, 2);; /// } while (logical_lane_id % 2 == 0 && size > 1);; /// }; ///; /// There is no assumption made about the initial state of the reduction.; /// Any number of lanes (>=1) could be active at any position. The reduction; /// result is returned in the first active lane.; ///; /// In this version, 'ShuffleReduceFn' behaves, per element, as follows:; ///; /// remote_elem = shuffle_down(reduce_elem, offset, WARPSIZE);; /// if (lane_id % 2 == 0 && offset > 0); /// reduce_elem = reduce_elem REDUCE_OP remote_elem; /// else; /// reduce_elem = remote_elem; ///; ///; /// Intra-Team Reduction; ///; /// This function, as implemented in the runtime call; /// '__kmpc_nvptx_parallel_reduce_nowait_v2', aggregates data across OpenMP; /// threads in a team. It first reduces within a warp using the; /// aforementioned algorithms. We then proceed to gather all such; /// reduced values at the first warp.; ///; /// The runtime makes use of the function 'InterWarpCpyFn', which copies; /// data from each of the ""warp master"" (zeroth lane of each warp, where; /// warp-reduced data is held) to the zeroth warp. This step reduces (in; /// a mathematical sense) the problem of reduction across warp masters in; /// a block to the problem of warp reduction.; ///; ///; /// Inter-Team Reduction; ///; /// Once a team has reduced its data to a single value, it is stored in; /// a global scratchpad array. Since each team has a distinct slot, this; /// can be done without locking.; ///; /// The last team to write to the scratchpad array proceeds to reduce the; /// scratchpad array. One or more workers in the last team use the helper; /// 'loadAndReduceDataFn' to load and reduce values from the array, i.e.,; /// the k'th worker reduces every k'th element.; ///; /// Finally, a call is made to '__kmpc_nvptx_parallel_reduce_nowait_v2' to; /// reduce across workers and compute a globally reduced value.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:9505,load,loadAndReduceDataFn,9505,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,2,['load'],"['load', 'loadAndReduceDataFn']"
Performance,"gruence class has a leader, and the leader is used to symbolize; // instructions in a canonical way (IE every operand of an instruction that is a; // member of the same congruence class will always be replaced with leader; // during symbolization). To simplify symbolization, we keep the leader as a; // constant if class can be proved to be a constant value. Otherwise, the; // leader is the member of the value set with the smallest DFS number. Each; // congruence class also has a defining expression, though the expression may be; // null. If it exists, it can be used for forward propagation and reassociation; // of values.; // For memory, we also track a representative MemoryAccess, and a set of memory; // members for MemoryPhis (which have no real instructions). Note that for; // memory, it seems tempting to try to split the memory members into a; // MemoryCongruenceClass or something. Unfortunately, this does not work; // easily. The value numbering of a given memory expression depends on the; // leader of the memory congruence class, and the leader of memory congruence; // class depends on the value numbering of a given memory expression. This; // leads to wasted propagation, and in some cases, missed optimization. For; // example: If we had value numbered two stores together before, but now do not,; // we move them to a new value congruence class. This in turn will move at one; // of the memorydefs to a new memory congruence class. Which in turn, affects; // the value numbering of the stores we just value numbered (because the memory; // congruence class is part of the value number). So while theoretically; // possible to split them up, it turns out to be *incredibly* complicated to get; // it to work right, because of the interdependency. While structurally; // slightly messier, it is algorithmically much simpler and faster to do what we; // do here, and track them both at once in the same class.; // Note: The default iterators for this class iterate over values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:1705,optimiz,optimization,1705,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['optimiz'],['optimization']
Performance,"h < pad_height) charheight = textsize*pad_width;; else charheight = textsize*pad_height;; ~~~. If the text precision is equal to 3, the text size doesn't depend on the pad's; dimensions. A given `textsize` value always generates the same absolute; size. The text size (`charheight`) is given in pixels:. ~~~ {.cpp}; charheight = textsize;; ~~~. Note that to scale fonts to the same size as the old True Type package a; scale factor of `0.93376068` is apply to the text size before drawing. The text size of any class inheriting from `TAttText` can; be changed using the method `SetTextSize` and retrieved using the; method `GetTextSize`. \anchor ATTTEXT5; ## Text Font and Precision. The text font code is combination of the font number and the precision.; ~~~ {.cpp}; Text font code = 10*fontnumber + precision; ~~~; Font numbers must be between 1 and 14. The precision can be:. - `precision = 0` fast hardware fonts (steps in the size); - `precision = 1` scalable and rotatable hardware fonts (see below); - `precision = 2` scalable and rotatable hardware fonts; - `precision = 3` scalable and rotatable hardware fonts. Text size; is given in pixels. The text font and precision of any class inheriting from `TAttText` can; be changed using the method `SetTextFont` and retrieved using the; method `GetTextFont`. \anchor ATTTEXT51; ### Font quality and speed. When precision 0 is used, only the original non-scaled X11 system fonts are; used. The fonts have a minimum (4) and maximum (37) size in pixels. These; fonts are fast and are of good quality. Their size varies with large steps; and they cannot be rotated.; Precision 1 and 2 fonts have a different behaviour depending if the; True Type Fonts (TTF) are used or not. If TTF are used, you always get very good; quality scalable and rotatable fonts.; These days TTF fonts are rendered fast enough and can be used in all cases. \anchor ATTTEXT52; ### How to use True Type Fonts. TTF fonts are used by default. They can be deactivated via the f",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TAttText.cxx:4609,scalab,scalable,4609,core/base/src/TAttText.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TAttText.cxx,3,['scalab'],['scalable']
Performance,"hadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The l",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4700,load,load,4700,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['load'],['load']
Performance,"he ""if"" condition compares the call site's called value to the given; /// callee. The original call site is moved into the ""else"" block, and a clone; /// of the call site is placed in the ""then"" block. The cloned instruction is; /// returned.; ///; /// For example, the call instruction below:; ///; /// orig_bb:; /// %t0 = call i32 %ptr(); /// ...; ///; /// Is replace by the following:; ///; /// orig_bb:; /// %cond = icmp eq i32 ()* %ptr, @func; /// br i1 %cond, %then_bb, %else_bb; ///; /// then_bb:; /// ; The clone of the original call instruction is placed in the ""then""; /// ; block. It is not yet promoted.; /// %t1 = call i32 %ptr(); /// br merge_bb; ///; /// else_bb:; /// ; The original call instruction is moved to the ""else"" block.; /// %t0 = call i32 %ptr(); /// br merge_bb; ///; /// merge_bb:; /// ; Uses of the original call instruction are replaced by uses of the phi; /// ; node.; /// %t2 = phi i32 [ %t0, %else_bb ], [ %t1, %then_bb ]; /// ...; ///; /// A similar transformation is performed for invoke instructions. However,; /// since invokes are terminating, more work is required. For example, the; /// invoke instruction below:; ///; /// orig_bb:; /// %t0 = invoke %ptr() to label %normal_dst unwind label %unwind_dst; ///; /// Is replace by the following:; ///; /// orig_bb:; /// %cond = icmp eq i32 ()* %ptr, @func; /// br i1 %cond, %then_bb, %else_bb; ///; /// then_bb:; /// ; The clone of the original invoke instruction is placed in the ""then""; /// ; block, and its normal destination is set to the ""merge"" block. It is; /// ; not yet promoted.; /// %t1 = invoke i32 %ptr() to label %merge_bb unwind label %unwind_dst; ///; /// else_bb:; /// ; The original invoke instruction is moved into the ""else"" block, and; /// ; its normal destination is set to the ""merge"" block.; /// %t0 = invoke i32 %ptr() to label %merge_bb unwind label %unwind_dst; ///; /// merge_bb:; /// ; Uses of the original invoke instruction are replaced by uses of the; /// ; phi node, and the merge ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp:1146,perform,performed,1146,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,1,['perform'],['performed']
Performance,"he assembly instruction associated to the entry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, class TimelineView also reports extra timing info; /// in another table named ""Average Wait times"" (see example below).; ///; ///; /// Average Wait times (based on the timeline view):; /// [0]: Executions; /// [1]: Average time spent waiting in a scheduler's queue; /// [2]: Average time spent waiting in a scheduler's queue while ready; /// [3]: Average time elapsed from WB until retire stage; ///; ///	[0]	[1]	[2]	[3]; /// 0.	 2	1.0	1.0	3.0	vmovshdup %xmm0, %xmm1; /// 1.	 2	1.0	1.0	3.0	vpermilpd $1, %xmm0, %xmm2; /// 2.	 2	1.0	1.0	2.5	vpermilps $231, %xmm0, %xmm5; /// 3.	 2	1.5	0.5	1.0	vaddss %xmm1, %xmm0, %xmm3; /// 4.	 2	3.5	0.0	0.0	vaddss %xmm3, %xmm2, %xmm4; /// 5.	 2	6.5	0.0	0.0	vaddss %xmm4, %xmm5, %xmm6; /// 2	2.4	0.6	1.6 <total>; ///; /// By comparing column [2] with column [1], we get an idea about how many; /// cycles were spent in the scheduler's queue due to data dependencies.; ///; /// In this example, instruction 5 spent an average of ~6 cycles in the; /// scheduler's queue. As soon as operands became ready, the instruction; /// was immediately issued to the pipeline(s).; /// That is expected because instruction 5 cannot transition to the ""ready""; /// state until %xmm4 is written by instruction 4.; ///; //===---------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:3466,queue,queue,3466,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,2,['queue'],['queue']
Performance,"he block creation algorithm is divided into several steps, and several; // variants can be tried during the scheduling process.; //; // Second the order of the instructions inside the blocks is chosen.; // At that step we do take into account only register usage and hiding; // low latency instructions; //; // Third the block order is chosen, there we try to hide high latencies; // and keep register usage low.; //; // After the third step, a pass is done to improve the hiding of low; // latencies.; //; // Actually when talking about 'low latency' or 'high latency' it includes; // both the latency to get the cache (or global mem) data go to the register,; // and the bandwidth limitations.; // Increasing the number of active wavefronts helps hide the former, but it; // doesn't solve the latter, thus why even if wavefront count is high, we have; // to try have as many instructions hiding high latencies as possible.; // The OpenCL doc says for example latency of 400 cycles for a global mem; // access, which is hidden by 10 instructions if the wavefront count is 10.; // Some figures taken from AMD docs:; // Both texture and constant L1 caches are 4-way associative with 64 bytes; // lines.; // Constant cache is shared with 4 CUs.; // For texture sampling, the address generation unit receives 4 texture; // addresses per cycle, thus we could expect texture sampling latency to be; // equivalent to 4 instructions in the very best case (a VGPR is 64 work items,; // instructions in a wavefront group are executed every 4 cycles),; // or 16 instructions if the other wavefronts associated to the 3 other VALUs; // of the CU do texture sampling too. (Don't take these figures too seriously,; // as I'm not 100% sure of the computation); // Data exports should get similar latency.; // For constant loading, the cache is shader with 4 CUs.; // The doc says ""a throughput of 16B/cycle for each of the 4 Compute Unit""; // I guess if the other CU don't read the cache, it can go up to 64B/cycle",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:3711,latency,latency,3711,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['latency'],['latency']
Performance,"he boosting parameter, beta, for AdaBoost; /// - UseRandomisedTrees choose at each node splitting a random set of variables; /// - UseNvars use UseNvars variables in randomised trees; /// - UsePoisson Nvars use UseNvars not as fixed number but as mean of a poisson distribution; /// - SeparationType the separation criterion applied in the node splitting.; /// Known:; /// - GiniIndex; /// - MisClassificationError; /// - CrossEntropy; /// - SDivSqrtSPlusB; /// - MinNodeSize: minimum percentage of training events in a leaf node (leaf criteria, stop splitting); /// - nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; /// step size is determined by the events); /// - UseFisherCuts: use multivariate splits using the Fisher criterion; /// - UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; /// (from the training) in the leaf node; /// - NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; /// misclassification error rate); /// - PruneMethod The Pruning method.; /// Known:; /// - NoPruning // switch off pruning completely; /// - ExpectedError; /// - CostComplexity; /// - PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; /// - PruningValFraction number of events to use for optimizing pruning (only if PruneStrength < 0, i.e. automatic pruning); /// - NegWeightTreatment; /// - IgnoreNegWeightsInTraining Ignore negative weight events in the training.; /// - DecreaseBoostWeight Boost ev. with neg. weight with 1/boostweight instead of boostweight; /// - PairNegWeightsGlobal Pair ev. with neg. and pos. weights in training sample and ""annihilate"" them; /// - MaxDepth maximum depth of the decision tree allowed before further splitting is stopped; /// - SkipNormalization Skip normalization at initialization, to keep expectation value of BDT output; /// according to the fraction of events",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx:1839,optimiz,optimizing,1839,tmva/tmva/src/MethodBDT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx,1,['optimiz'],['optimizing']
Performance,"he return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over a single merged module; // that contains all vtables with !type metadata that participate in the link.; // The pass computes a resolution for each virtual call and stores it in the; // type identifier summary.; // - Import phase: this is run during the thin backends over the individual; // modules. The pass applies the resolutions previously computed during the; // import phase to each eligible virtual call.; //; // During ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over the index which; // contains a summary of all vtables with !type metadata that participate in; // the link. It computes a resolution for each virtual call and stores it in; // the type identifier summary. Only single implementation devirtualization; // is supported.; // - Import phase: (same as with hybrid case above).; //; //===---",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1934,load,load,1934,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['load'],['load']
Performance,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:1866,optimiz,optimizer,1866,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,4,['optimiz'],"['optimization', 'optimizer']"
Performance,"he::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries.; - A 'cached' TChain switches over to a new file. \anchor cachemisses; ## Self-optimization in presence of cache misses. The TTreeCache can optimize its behavior on a cache miss. When; miss optimization is enabled (see the SetOptimizeMisses method),; it tracks all branches utilized after the learning phase which caused a cache; miss.; When one cache miss occurs, all the utilized branches are be prefetched; for that event. This optimization utilizes the observation that infrequently; accessed branches are often accessed together.; An example scenario where such behavior is desirable, is an analysis where; a set of collections are read only for a few events in which a certain; condition is respected, e.g. a trigger fired. ### Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase; by at most a factor two in the case of cache miss.; Additionally, on the first miss of an event, we must iterate through all the; ""active branches"" for the miss cache and find the correct basket.; This can be potentially a CPU-expensive operation compared to, e.g., the; latency of a SSD. This is why the miss cache is currently disabled by default. \anchor examples; ## Example usages of TTreeCache. A few use cases are discussed below. A cache may be created with automatic; sizing when a TTree is used:. In some applications, e.g. central processing workflows of experiments, the list; of branches to read is known a priori. For these cases, the TTreeCache can be; instructed about the branches which will be read via explicit calls to the TTree; or TTreeCache interfaces.; In less streamlined applications such as analysis, predicting the branches which; will be read can be difficult. In such cases, ROOT I/O flags used branches; automatically whe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:5434,optimiz,optimizing,5434,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,4,"['cache', 'optimiz']","['cache', 'optimizing']"
Performance,"he; /// errors in x is to make it equal the error in x times the slope of the line.; /// This approach is called ""effective variance method"" and; /// the implementation is provided in the function FitUtil::EvaluateChi2Effective; ///; /// \anchor GFitLinear; /// ### Linear fitting:; /// When the fitting function is linear (contains the `++` sign) or the fitting; /// function is a polynomial, a linear fitter is initialised.; /// To create a linear function, use the following syntax: linear parts; /// separated by `++` sign.; /// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; /// TF1 object as; ///; /// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; ///; /// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; /// Going via the linear fitter for functions, linear in parameters, gives a; /// considerable advantage in speed.; /// When using the linear fitting it is also possible to perform a robust fitting with the; /// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; /// See the tutorial `fitLinearRobust.C`.; ///; /// ### Notes on TGraph/TGraphErrors Fitting:; ///; /// 1. By using the ""effective variance"" method a simple linear regression; /// becomes a non-linear case, which takes several iterations; /// instead of 0 as in the linear case.; /// 2. The effective variance technique assumes that there is no correlation; /// between the x and y coordinate.; /// 3. The standard chi2 (least square) method without error in the coordinates (x) can; /// be forced by using option ""EX0""; /// 4. The linear fitter doesn't take into account the errors in x. When fitting a; /// TGraphErrors with a linear functions the errors in x will not be considered.; /// If errors in x are important, use option ""F"" for linear function fitting.; /// 5. When fitting a TGraph (i.e. no errors associated with each point),; /// a correction is applied to the errors on the parameters with the ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:5123,perform,perform,5123,hist/hist/src/TGraph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx,1,['perform'],['perform']
Performance,"heir partial results are merged before returning the final values to the user.; There are no guarantees on the order in which threads will process the batches of entries.; In particular, note that this means that, for multi-thread event loops, there is no; guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; ~~~{.cpp}; ROOT::EnableImplicitMT(i); ~~~; replacing `i` with the number of CPUs/slots that were allocated for this job. ### Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads. Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; which eliminates all risks of race conditions. In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; will pass an extra `slot` argument (an u",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:48546,multi-thread,multi-thread,48546,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['multi-thread'],['multi-thread']
Performance,"hitecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point were not true, the decision on whether to; /// perform a tail call is done in LowerCallTo in SelectionDAG (or; /// CallLowering in GlobalISel) which occurs after the Stack Protector; /// Pass. As a result, one would need to put the relevant callinst into the; /// stack protector check success basic block (where the return inst is; /// placed) and then move it back later at ISel/MI time before the; /// stack protector check if the tail call optimization failed. The MI; /// level option was nixed immediately since it would require; /// platform-specific pattern matching. The ISel level option was; /// nixed because SelectionDAG only processes one IR level basic block at a; /// time implying one could not create a DAG Combine to move the callinst.; ///; /// To get around this problem:; ///; /// 1. SelectionDAG can only process one block at a time, we can generate; /// multiple machine basic blocks for one IR level basic block.; /// This is how we handle bit tests and switches.; ///; /// 2. At the MI level, tail calls are represented via a special return; /// MIInst called ""tcreturn"". Thus if we know the basic block in which we; /// wish to insert the stack protector check, we get the correct behavior; /// by always inserting the stack protector check right before the return; /// statement. This is a ""magical t",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:2442,optimiz,optimization,2442,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,1,['optimiz'],['optimization']
Performance,hod method_list[method_count];; /// }; /// struct _protocol_t {; /// id isa; // NULL; /// const char *protocol_name;; /// const struct _protocol_list_t * protocol_list; // super protocols; /// const struct method_list_t *instance_methods;; /// const struct method_list_t *class_methods;; /// const struct method_list_t *optionalInstanceMethods;; /// const struct method_list_t *optionalClassMethods;; /// const struct _prop_list_t * properties;; /// const uint32_t size; // sizeof(struct _protocol_t); /// const uint32_t flags; // = 0; /// const char ** extendedMethodTypes;; /// }; /// struct _ivar_t {; /// unsigned long int *offset; // pointer to ivar offset location; /// const char *name;; /// const char *type;; /// uint32_t alignment;; /// uint32_t size;; /// }; /// struct _ivar_list_t {; /// uint32 entsize; // sizeof(struct _ivar_t); /// uint32 count;; /// struct _ivar_t list[count];; /// }; /// struct _class_ro_t {; /// uint32_t flags;; /// uint32_t instanceStart;; /// uint32_t instanceSize;; /// uint32_t reserved; // only when building for 64bit targets; /// const uint8_t *ivarLayout;; /// const char *name;; /// const struct _method_list_t *baseMethods;; /// const struct _protocol_list_t *baseProtocols;; /// const struct _ivar_list_t *ivars;; /// const uint8_t *weakIvarLayout;; /// const struct _prop_list_t *properties;; /// }; /// struct _class_t {; /// struct _class_t *isa;; /// struct _class_t *superclass;; /// void *cache;; /// IMP *vtable;; /// struct _class_ro_t *ro;; /// }; /// struct _category_t {; /// const char *name;; /// struct _class_t *cls;; /// const struct _method_list_t *instance_methods;; /// const struct _method_list_t *class_methods;; /// const struct _protocol_list_t *protocols;; /// const struct _prop_list_t *properties;; /// }; /// MessageRefTy - LLVM for:; /// struct _message_ref_t {; /// IMP messenger;; /// SEL name;; /// };; /// SuperMessageRefTy - LLVM for:; /// struct _super_message_ref_t {; /// SUPER_IMP messenger;; /// SEL name;; /// };,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:2177,cache,cache,2177,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,1,['cache'],['cache']
Performance,"https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %s.sink = phi [%st, if.then], [%se, if.else]; // <...>; // store %s.sink, %addr_s; // <...>; //; //; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1141,load,load,1141,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,1,['load'],['load']
Performance,"iMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; /// The current defaults are (""Minuit"",""Migrad"").; /// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; /// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance value for the minimization.; /// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; /// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; ///; /// Other options are possible depending on the Minimizer used, see the corresponding documentation.; /// The default minimizer can be also set in the resource file in etc/system.rootrc. For example; ///; /// ~~~ {.cpp}; /// Root.Fitter: Minuit2; /// ~~~; ///; /// \anchor HFitChi2; /// ### Chi-square Fits; ///; /// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; /// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; ///; /// \f[; /// Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }; /// \f]; ///; /// where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for; /// an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment; /// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; /// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; /// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.; /// In this case empty bins are considered in the fit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:6474,perform,performed,6474,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['perform'],['performed']
Performance,"i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableInterface *iface = new TGSimpleTableInterface(data, 6, 5);. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. //Update data; data[5][1] = 3.01;; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;. return mainframe;; }; ~~~. It is also possible to visualise data from a tree. A simple macro; showing the use of a TTreeTableInterface follows. ~~~; {; // Open a root file.; TFile *file = new TFile(""$ROOTSYS/tutorials/hsimple.root"");; // Load a tree from the file; TNtuple *ntuple = (TNtuple *)file->Get(""ntuple"");. // Create an interface; TTreeTableInterface *iface = new TTreeTableInterface(ntuple);. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface, 10, 6);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. // Set a selection; iface->SetSelection(""px > 0."");; // Add a column; iface->AddColumn(""(px+py)/(px-py)"", 0);; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;. return mainframe;; }; ~~~; */; ////////////////////////////////////////////////////////////////////////////////; /// TGTable constuctor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTable.cxx:2475,Load,Load,2475,gui/gui/src/TGTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTable.cxx,1,['Load'],['Load']
Performance,"ialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only ind",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4278,load,load,4278,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,3,['load'],['load']
Performance,"icant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_5 - Pa_5 = 16 #0 | subtract to get the offset; //; // Remark: %PTR is not maintained within this class. So in this instance the; // offset of 16 can only be assumed if the pointers are equal.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:1276,load,loads,1276,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,2,['load'],"['load', 'loads']"
Performance,"icense-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file define class ResourcePressureView.; /// Class ResourcePressureView observes hardware events generated by; /// the Pipeline object and collects statistics related to resource usage at; /// instruction granularity.; /// Resource pressure information is then printed out to a stream in the; /// form of a table like the one from the example below:; ///; /// Resources:; /// [0] - JALU0; /// [1] - JALU1; /// [2] - JDiv; /// [3] - JFPM; /// [4] - JFPU0; /// [5] - JFPU1; /// [6] - JLAGU; /// [7] - JSAGU; /// [8] - JSTC; /// [9] - JVIMUL; ///; /// Resource pressure per iteration:; /// [0] [1] [2] [3] [4] [5] [6] [7] [8] [9]; /// 0.00 0.00 0.00 0.00 2.00 2.00 0.00 0.00 0.00 0.00; ///; /// Resource pressure by instruction:; /// [0] [1] [2] [3] [4] [5] [6] [7] [8] [9] Instructions:; /// - - - - - 1.00 - - - - vpermilpd $1, %xmm0,; /// %xmm1; /// - - - - 1.00 - - - - - vaddps %xmm0, %xmm1,; /// %xmm2; /// - - - - - 1.00 - - - - vmovshdup %xmm2, %xmm3; /// - - - - 1.00 - - - - - vaddss %xmm2, %xmm3,; /// %xmm4; ///; /// In this example, we have AVX code executed on AMD Jaguar (btver2).; /// Both shuffles and vector floating point add operations on XMM registers have; /// a reciprocal throughput of 1cy.; /// Each add is issued to pipeline JFPU0, while each shuffle is issued to; /// pipeline JFPU1. The overall pressure per iteration is reported by two; /// tables: the first smaller table is the resource pressure per iteration;; /// the second table reports resource pressure per instruction. Values are the; /// average resource cycles consumed by an instruction.; /// Every vector add from the example uses resource JFPU0 for an average of 1cy; /// per iteration. Consequently, the resource pressure on JFPU0 is of 2cy per; /// iteration.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.h:1594,throughput,throughput,1594,interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/ResourcePressureView.h,1,['throughput'],['throughput']
Performance,"idth()`; should be used. To control the bar offset (default is 0) `TH1::SetBarOffset()` should; be used. These two parameters are useful when several histograms are plotted using; the option `SAME`. They allow to plot the histograms next to each other. \anchor HP11; ### The SCATter plot option (legacy draw option). \attention; Use of option `SCAT` has been deprecated. It was the default drawing option for 2D and; 3D histograms. The new default option is `COL` (heat-map). For each cell (i,j) a number of points proportional to the cell content is; drawn. A maximum of `kNMAX` points per cell is drawn. If the maximum is above; `kNMAX` contents are normalized to `kNMAX` (`kNMAX=2000`).; If option is of the form `scat=ff`, (eg `scat=1.8`,; `scat=1e-3`), then `ff` is used as a scale factor to compute the; number of dots. `scat=1` is the default. By default the scatter plot is painted with a ""dot marker"" which not scalable; (see the `TAttMarker` documentation). To change the marker size, a scalable marker; type should be used. For instance a circle (marker style 20). Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hscat = new TH2F(""hscat"",""Option SCATter example (default for 2D histograms) "",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hscat->Fill(px,5*py);; hscat->Fill(3+0.5*px,2*py-10.);; }; hscat->Draw(""scat=0.5""); // This a legacy draw option. Please consider using TScatter; }; End_Macro. \anchor HP12; ### The ARRow option. Shows gradient between adjacent cells. For each cell (i,j) an arrow is drawn; The orientation of the arrow follows the cell gradient. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto harr = new TH2F(""harr"",""Option ARRow example"",20,-4,4,20,-20,20);; harr->SetLineColor(kRed);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; harr->Fill(px,5*py);; harr->Fill(3+0.5*px,2*py-10.,0.1);; }; harr->Draw(""ARR"");; }; End_Macro. \since *",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:31200,scalab,scalable,31200,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['scalab'],['scalable']
Performance,"ifferent values of the `slot` parameter,; where `slot` will be a number between 0 and `GetNSlots() - 1`.; In other words, within a slot, computation runs sequentially and events are processed sequentially.; Note that the same slot might be associated to different threads over the course of a single event loop, but two threads; will never receive the same slot at the same time.; This extra parameter might facilitate writing safe parallel code by having each thread write/modify a different; processing slot, e.g. a different element of a list. See [here](#generic-actions) for an example usage of ForeachSlot(). ### Parallel execution of multiple RDataFrame event loops; A complex analysis may require multiple separate RDataFrame computation graphs to produce all desired results. This poses the challenge that the; event loops of each computation graph can be parallelized, but the different loops run sequentially, one after the other.; On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");. // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop. // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ~~~. ### Performance considerations. To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; For instance, `Filter(""x > 0"")` requires just-in-time c",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:50664,concurren,concurrently,50664,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['concurren'],['concurrently']
Performance,"ignment requirements.; //; // For Darwin platforms the frame-record (fp, lr) is stored at the top of the; // callee-saved area, since the unwind encoding does not allow for encoding; // this dynamically and existing tools depend on this layout. For other; // platforms, the frame-record is stored at the bottom of the (gpr) callee-saved; // area to allow SVE stack objects (allocated directly below the callee-saves,; // if available) to be accessed directly from the framepointer.; // The SVE spill/fill instructions have VL-scaled addressing modes such; // as:; // ldr z8, [fp, #-7 mul vl]; // For SVE the size of the vector length (VL) is not known at compile-time, so; // '#-7 mul vl' is an offset that can only be evaluated at runtime. With this; // layout, we don't need to add an unscaled offset to the framepointer before; // accessing the SVE object in the frame.; //; // In some cases when a base pointer is not strictly needed, it is generated; // anyway when offsets from the frame pointer to access local variables become; // so large that the offset can't be encoded in the immediate fields of loads; // or stores.; //; // Outgoing function arguments must be at the bottom of the stack frame when; // calling another function. If we do not have variable-sized stack objects, we; // can allocate a ""reserved call frame"" area at the bottom of the local; // variable area, large enough for all outgoing calls. If we do have VLAs, then; // the stack pointer must be decremented and incremented around each call to; // make space for the arguments below the VLAs.; //; // FIXME: also explain the redzone concept.; //; // An example of the prologue:; //; // .globl __foo; // .align 2; // __foo:; // Ltmp0:; // .cfi_startproc; // .cfi_personality 155, ___gxx_personality_v0; // Leh_func_begin:; // .cfi_lsda 16, Lexception33; //; // stp xa,bx, [sp, -#offset]!; // ...; // stp x28, x27, [sp, #offset-32]; // stp fp, lr, [sp, #offset-16]; // add fp, sp, #offset - 16; // sub sp, sp, #1360; //; /",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:4647,load,loads,4647,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['load'],['loads']
Performance,"ime functions, all calling 'shuffleReduceFn' to perform; /// the essential reduction step. Therefore, based on the 4th; /// parameter, this function behaves slightly differently to; /// cooperate with the runtime to ensure correctness under; /// different circumstances.; ///; /// 'InterWarpCpyFn' is a pointer to a function that transfers; /// reduced variables across warps. It tunnels, through CUDA; /// shared memory, the thread-private data of type 'ReduceData'; /// from lane 0 of each warp to a lane in the first warp.; /// 4. Call the OpenMP runtime on the GPU to reduce across teams.; /// The last team writes the global reduced value to memory.; ///; /// ret = __kmpc_nvptx_teams_reduce_nowait(...,; /// reduceData, shuffleReduceFn, interWarpCpyFn,; /// scratchpadCopyFn, loadAndReduceFn); ///; /// 'scratchpadCopyFn' is a helper that stores reduced; /// data from the team master to a scratchpad array in; /// global memory.; ///; /// 'loadAndReduceFn' is a helper that loads data from; /// the scratchpad array and reduces it with the input; /// operand.; ///; /// These compiler generated functions hide address; /// calculation and alignment information from the runtime.; /// 5. if ret == 1:; /// The team master of the last team stores the reduced; /// result to the globals in memory.; /// foo += reduceData.foo; bar *= reduceData.bar; ///; ///; /// Warp Reduction Algorithms; ///; /// On the warp level, we have three algorithms implemented in the; /// OpenMP runtime depending on the number of active lanes:; ///; /// Full Warp Reduction; ///; /// The reduce algorithm within a warp where all lanes are active; /// is implemented in the runtime as follows:; ///; /// full_warp_reduce(void *reduce_data,; /// kmp_ShuffleReductFctPtr ShuffleReduceFn) {; /// for (int offset = WARPSIZE/2; offset > 0; offset /= 2); /// ShuffleReduceFn(reduce_data, 0, offset, 0);; /// }; ///; /// The algorithm completes in log(2, WARPSIZE) steps.; ///; /// 'ShuffleReduceFn' is used here with lane_id ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:4150,load,loadAndReduceFn,4150,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,2,['load'],"['loadAndReduceFn', 'loads']"
Performance,"imization is enabled (see the SetOptimizeMisses method),; it tracks all branches utilized after the learning phase which caused a cache; miss.; When one cache miss occurs, all the utilized branches are be prefetched; for that event. This optimization utilizes the observation that infrequently; accessed branches are often accessed together.; An example scenario where such behavior is desirable, is an analysis where; a set of collections are read only for a few events in which a certain; condition is respected, e.g. a trigger fired. ### Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase; by at most a factor two in the case of cache miss.; Additionally, on the first miss of an event, we must iterate through all the; ""active branches"" for the miss cache and find the correct basket.; This can be potentially a CPU-expensive operation compared to, e.g., the; latency of a SSD. This is why the miss cache is currently disabled by default. \anchor examples; ## Example usages of TTreeCache. A few use cases are discussed below. A cache may be created with automatic; sizing when a TTree is used:. In some applications, e.g. central processing workflows of experiments, the list; of branches to read is known a priori. For these cases, the TTreeCache can be; instructed about the branches which will be read via explicit calls to the TTree; or TTreeCache interfaces.; In less streamlined applications such as analysis, predicting the branches which; will be read can be difficult. In such cases, ROOT I/O flags used branches; automatically when a branch buffer is read during the learning phase. In the examples below, portions of analysis code are shown.; The few statements involving the TreeCache are marked with `//<<<`. ### ROOT::RDataFrame and TTreeReader Examples. If you use RDataFrame or TTreeReader, the system will automatically cache the; best set of branches: no action is required by the user. ##",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:5848,cache,cache,5848,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"imply 10s penalty where a local read of the 10 MBytes would; take about 1 second. The TreeCache tries to prefetch all the buffers for the selected branches; in order to transfer a few multi-Megabytes large buffers instead of many; multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to; be read in increasing order such that the file is read sequentially. Systems like xrootd, dCache or httpd take advantage of the TTreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. ### Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all; entries such that not all branch buffers are read. \anchor description; ## General Description; This class acts as a file cache, registering automatically the baskets from; the branches being processed via direct manipulation of TTrees or with tools; such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame; when in the learning phase. The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. The usage of a TTreeCache can considerably improve the runtime performance at; the price of a modest investment in memory, in particular when the TTree is; accessed remotely, e.g. via a high latency network. For each TTree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted.; The user can change the size of the cache with the TTree::SetCacheSize method; (by default the size is 30 Megabytes). This feature can be controlled with the; environment variable `ROOT_TTREECACHE_SIZE` or the TTreeCache.Size option.; The entry range for which the cache is active can also be set with the; SetEntryRange method. \anchor changesbehaviour; ## Changes of behavior when u",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:2566,cache,cache,2566,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"in; * 5 or 6 bits per color, so that 8 or 4 different input values are counted; * in the same histogram cell.; *; * Next, the color-selection step begins with a box representing the whole; * color space, and repeatedly splits the ""largest"" remaining box until we; * have as many boxes as desired colors. Then the mean color in each; * remaining box becomes one of the possible output colors.; * ; * The second pass over the image maps each input pixel to the closest output; * color (optionally after applying a Floyd-Steinberg dithering correction).; * This mapping is logically trivial, but making it go fast enough requires; * considerable care.; *; * Heckbert-style quantizers vary a good deal in their policies for choosing; * the ""largest"" box and deciding where to cut it. The particular policies; * used here have proved out well in experimental comparisons, but better ones; * may yet be found.; *; * In earlier versions of the IJG code, this module quantized in YCbCr color; * space, processing the raw upsampled data without a color conversion step.; * This allowed the color conversion math to be done only once per colormap; * entry, not once per pixel. However, that optimization precluded other; * useful optimizations (such as merging color conversion with upsampling); * and it also interfered with desired capabilities such as quantizing to an; * externally-supplied colormap. We have therefore abandoned that approach.; * The present code works in the post-conversion color space, typically RGB.; *; * To improve the visual quality of the results, we actually work in scaled; * RGB space, giving G distances more weight than R, and R in turn more than; * B. To do everything in integer math, we must use integer scale factors.; * The 2/3/1 scale factors used here correspond loosely to the relative; * weights of the colors in the NTSC grayscale equation.; * If you want to use this code to quantize a non-RGB color space, you'll; * probably need to change these scale factors.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:1723,optimiz,optimization,1723,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,2,['optimiz'],"['optimization', 'optimizations']"
Performance,"independent properties defined here are used by the scheduler as; /// an abstract machine model. A real micro-architecture has a number of; /// buffers, queues, and stages. Declaring that a given machine-independent; /// abstract property corresponds to a specific physical property across all; /// subtargets can't be done. Nonetheless, the abstract model is; /// useful. Futhermore, subtargets typically extend this model with processor; /// specific resources to model any hardware features that can be exploited by; /// scheduling heuristics and aren't sufficiently represented in the abstract.; ///; /// The abstract pipeline is built around the notion of an ""issue point"". This; /// is merely a reference point for counting machine cycles. The physical; /// machine will have pipeline stages that delay execution. The scheduler does; /// not model those delays because they are irrelevant as long as they are; /// consistent. Inaccuracies arise when instructions have different execution; /// delays relative to each other, in addition to their intrinsic latency. Those; /// special cases can be handled by TableGen constructs such as, ReadAdvance,; /// which reduces latency when reading data, and ReleaseAtCycles, which consumes; /// a processor resource when writing data for a number of abstract; /// cycles.; ///; /// TODO: One tool currently missing is the ability to add a delay to; /// ReleaseAtCycles. That would be easy to add and would likely cover all cases; /// currently handled by the legacy itinerary tables.; ///; /// A note on out-of-order execution and, more generally, instruction; /// buffers. Part of the CPU pipeline is always in-order. The issue point, which; /// is the point of reference for counting cycles, only makes sense as an; /// in-order part of the pipeline. Other parts of the pipeline are sometimes; /// falling behind and sometimes catching up. It's only interesting to model; /// those other, decoupled parts of the pipeline if they may be predictably; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:1726,latency,latency,1726,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,1,['latency'],['latency']
Performance,"indexed friend trees (see below). To use friend trees in RDataFrame, set up trees with the appropriate relationships and then instantiate an RDataFrame; with the main tree:. ~~~{.cpp}; TTree main([...]);; TTree friend([...]);; main.AddFriend(&friend, ""myFriend"");. RDataFrame df(main);; auto df2 = df.Filter(""myFriend.MyCol == 42"");; ~~~. The same applies for TChains. Columns coming from the friend trees can be referred to by their full name, like in the example above,; or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of; ""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree). \note A common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their; entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original; one: rows will be mismatched. Indexed friend trees provide a way to perform simple joins of multiple trees over a common column.; When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the; ""index"" columns have a value identical to the one in the main one. For example, in Python:. ~~~{.py}; main_tree = ...; aux_tree = ... # If a friend tree has an index on `commonColumn`, when the main tree loads; # a given row, it also loads the row of the friend tree that has the same; # value of `commonColumn`; aux_tree.BuildIndex(""commonColumn""). mainTree.AddFriend(aux_tree). df = ROOT.RDataFrame(mainTree); ~~~. RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode. \anchor other-file-formats; ### Reading data formats other than ROOT trees; RDataFrame can be interfaced with RDataSources. The ROOT::RDF::RDataSource interface defines an API that RDataFrame can use to read arbitrary columnar data formats. RDataFrame calls into concrete RDataSource impl",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:73127,perform,perform,73127,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['perform'],['perform']
Performance,"ined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the resulting mask is non-zero, otherwise,; /// returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrc(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the resulting mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1749,perform,perform,1749,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,1,['perform'],['perform']
Performance,"input; // (CB(N)Z and TB(N)Z). This is implemented by ensuring in the instruction; // selectors to not produce these instructions when speculation hardening; // is enabled. This pass will assert if it does encounter such an instruction.; // - On function call boundaries, the miss-speculation state is transferred from; // the taint register X16 to be encoded in the SP register as value 0.; //; // For the aspect of automatically hardening loads, using the taint register,; // (a.k.a. speculative load hardening, see; // https://llvm.org/docs/SpeculativeLoadHardening.html), the following; // implementation choices are made for AArch64:; // - Many of the optimizations described at; // https://llvm.org/docs/SpeculativeLoadHardening.html to harden fewer; // loads haven't been implemented yet - but for some of them there are; // FIXMEs in the code.; // - loads that load into general purpose (X or W) registers get hardened by; // masking the loaded data. For loads that load into other registers, the; // address loaded from gets hardened. It is expected that hardening the; // loaded data may be more efficient; but masking data in registers other; // than X or W is not easy and may result in being slower than just; // hardening the X address register loaded from.; // - On AArch64, CSDB instructions are inserted between the masking of the; // register and its first use, to ensure there's no non-control-flow; // speculation that might undermine the hardening mechanism.; //; // Future extensions/improvements could be:; // - Implement this functionality using full speculation barriers, akin to the; // x86-slh-lfence option. This may be more useful for the intrinsics-based; // approach than for the SLH approach to masking.; // Note that this pass already inserts the full speculation barriers if the; // function for some niche reason makes use of X16/W16.; // - no indirect branch misprediction gets protected/instrumented; but this; // could be done for some indirect branches, such as ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:4560,load,loads,4560,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,3,['load'],"['load', 'loaded', 'loads']"
Performance,"integer only for the first.; /// \endparblock; /// **Note:** in cases where the function to be executed takes more than; /// zero/one argument but all are fixed except zero/one, the function can be wrapped; /// in a lambda or via std::bind to give it the right signature.\n; ///; /// #### Return value:; /// An std::vector. The elements in the container; /// will be the objects returned by func.; ///; ///; /// #### Examples:; ///; /// ~~~{.cpp}; /// root[] ROOT::TThreadExecutor pool; auto hists = pool.Map(CreateHisto, 10);; /// root[] ROOT::TThreadExecutor pool(2); auto squares = pool.Map([](int a) { return a*a; }, {1,2,3});; /// ~~~; ///; /// ### ROOT::TThreadExecutor::MapReduce; /// This set of methods behaves exactly like Map, but takes an additional; /// function as a third argument. This function is applied to the set of; /// objects returned by the corresponding Map execution to ""squash"" them; /// into a single object. This function should be independent of the size of; /// the vector returned by Map due to optimization of the number of chunks.; ///; /// If this function is a binary operator, the ""squashing"" will be performed in parallel.; /// This is exclusive to ROOT::TThreadExecutor and not any other ROOT::TExecutorCRTP-derived classes.\n; ///; /// An integer can be passed as the fourth argument indicating the number of chunks we want to divide our work in.; /// This may be useful to avoid the overhead introduced when running really short tasks.; ///; /// #### Examples:; /// ~~~{.cpp}; /// root[] ROOT::TThreadExecutor pool; auto ten = pool.MapReduce([]() { return 1; }, 10, [](const std::vector<int> &v) { return std::accumulate(v.begin(), v.end(), 0); }); /// root[] ROOT::TThreadExecutor pool; auto hist = pool.MapReduce(CreateAndFillHists, 10, PoolUtils::ReduceObjects);; /// ~~~; ///; //////////////////////////////////////////////////////////////////////////; /*; VERY IMPORTANT NOTE ABOUT WORK ISOLATION. We enclose the parallel_for and parallel_reduce invocati",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/TThreadExecutor.cxx:2964,optimiz,optimization,2964,core/imt/src/TThreadExecutor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/TThreadExecutor.cxx,1,['optimiz'],['optimization']
Performance,"interference (register pressure) across; // IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,; // reducing liveness interference across those edges benefits global register; // allocation. Currently handles only certain cases.; //; // For example, unmerge %GEPI and %UGEPI as below.; //; // ---------- BEFORE ----------; // SrcBlock:; // ...; // %GEPIOp = ...; // ...; // %GEPI = gep %GEPIOp, Idx; // ...; // indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]; // (* %GEPI is alive on the indirectbr edges due to other uses ahead); // (* %GEPIOp is alive on the indirectbr edges only because of it's used by; // %UGEPI); //; // DstB0: ... (there may be a gep similar to %UGEPI to be unmerged); // DstB1: ... (there may be a gep similar to %UGEPI to be unmerged); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPIOp, UIdx; // ...; // ---------------------------; //; // ---------- AFTER ----------; // SrcBlock:; // ... (same as above); // (* %GEPI is still alive on the indirectbr edges); // (* %GEPIOp is no longer alive on the indirectbr edges as a result of the; // unmerging); // ...; //; // DstBi:; // ...; // %UGEPI = gep %GEPI, (UIdx-Idx); // ...; // ---------------------------; //; // The register pressure on the IndirectBr edges is reduced because %GEPIOp is; // no longer alive on them.; //; // We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging; // of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as; // not to disable further simplications and optimizations as a result of GEP; // merging.; //; // Note this unmerging may increase the length of the data flow critical path; // (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff; // between the register pressure and the length of data-flow critical; // path. Restricting this to the uncommon IndirectBr case would minimize the; // impact of potentially longer critical path, if any, and the impact on compile; // time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:1590,optimiz,optimizations,1590,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['optimiz'],['optimizations']
Performance,"ion COLor combined with POL"",40,-4,4,40,-4,4);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol1->Fill(px,py);; }; hcol1->Draw(""COLZPOL"");; }; End_Macro. \since **ROOT version 6.07/03:**. A second rendering technique is also available with the COL2 and COLZ2 options. These options provide potential performance improvements compared to the standard; COL option. The performance comparison of the COL2 to the COL option depends on; the histogram and the size of the rendering region in the current pad. In general,; a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; faster with the COL option. However, for larger histograms (approx. more than 100 bins per axis); that are not sparse, the COL2 option will provide up to 20 times performance improvements.; For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; faster with the COL2 option. The COL2 option will also scale its performance based on the size of the; pixmap the histogram image is being rendered into. It also is much better optimized for; sessions where the user is forwarding X11 windows through an `ssh` connection. For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; and COLZ options. There is one major difference and that concerns the treatment of; bins with zero content. The COL2 and COLZ2 options color these bins the color of zero. COL2 option renders the histogram as a bitmap. Therefore it cannot be saved in vector; graphics file format like PostScript or PDF (an empty image will be generated). It can; be saved only in bitmap files like PNG format for instance. \anchor HP140; ### The CANDLE and VIOLIN options. The mechanism behind Candle plots and Violin plots is very similar. Because of this they are; implemented in the same class TCandle. The keywords CANDLE or VIOLIN will initiate the drawing of; the corresponding plots. Followed by the keyword the user can select a plot direction (",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:41648,perform,performance,41648,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['perform'],['performance']
Performance,"ion order doesn't depend on numerical key values, it only depends; /// on the order of insert() and erase() operations. Iteration order is the; /// insertion order. Iteration is only provided over elements of equivalent; /// keys, but iterators are bidirectional.; ///; /// Compared to BitVector, SparseMultiSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast iteration; /// independent on the size of the universe.; ///; /// SparseMultiSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT template; /// parameter provides a space/speed tradeoff for sets holding many elements.; ///; /// When SparseT is uint32_t, find() only touches up to 3 cache lines, but the; /// sparse array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 3+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// Multiset behavior is provided by providing doubly linked lists for values; /// that are inlined in the dense vector. SparseMultiSet is a good choice when; /// one desires a growable number of entries per key, as it will retain the; /// SparseSet algorithmic properties despite being growable. Thus, it is often a; /// better choice than a SparseSet of growable containers or a vector of; /// vectors. SparseMultiSet also keeps iterators valid after erasure (provided; /// the iterators don't point to the element erased), allowing for more; /// intuitive and fast removal.; ///; /// @tparam ValueT The type of objects in the set.; /// @tparam KeyFunctorT A functor that computes an unsigned index from KeyT.; /// @tparam SparseT An unsigned integer type. See above.;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:1600,cache,cache,1600,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,1,['cache'],['cache']
Performance,"ion over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. - \f$ minpts \f$: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to \f$ 2^n +2n(n+1) +1 \f$ where n is the function dimension; - \f$ maxpts \f$: Maximum number of function evaluations to be allowed.; \f$ maxpts >= 2^n +2n(n+1) +1 \f$; if \f$ maxpts<minpts \f$, \f$ maxpts \f$ is set to \f$ 10minpts \f$; - \f$ epstol \f$, \f$ epsrel \f$ : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function in the desired interval:. - an estimation of the relative accuracy of the result.; - number of function evaluations performed.; - status code:; 0. Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1. maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 2. size is too small for the specified number MAXPTS of function evaluations.; 3. n<2 or n>15. ### Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. ### Notes:. 1..Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2..Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. ### References:. 1. A.C. Genz and A.A. Malik",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h:1246,perform,performed,1246,math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h,1,['perform'],['performed']
Performance,"ion using a user-defined helper object. |; | Cache() | Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). |; | Count() | Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. |; | Display() | Provides a printable representation of the dataset contents. The method returns a ROOT::RDF::RDisplay() instance which can print a tabular representation of the data or return it as a string. |; | Fill() | Fill a user-defined object with the values of the specified columns, as if by calling `Obj.Fill(col1, col2, ...)`. |; | Graph() | Fills a TGraph with the two columns provided. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | GraphAsymmErrors() | Fills a TGraphAsymmErrors. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | Histo1D(), Histo2D(), Histo3D() | Fill a one-, two-, three-dimensional histogram with the processed column values. |; | HistoND() | Fill an N-dimensional histogram with the processed column values. |; | Max() | Return the maximum of processed column values. If the type of the column is inferred, the return type is `double`, the type of the column otherwise.|; | Mean() | Return the mean of processed column values.|; | Min() | Return the minimum of processed column values. If the type of the column is inferred, the return type is `double`, the type of the column otherwise.|; | Profile1D(), Profile2D() | Fill a one- or two-dimensional profile with the column values that passed all filters. |; | Reduce() | Reduce (e.g. sum, merge) entries using the function (lambda, functor...) passed as argument. The function must have signature `T(T,T)` where `T` is the type of the column. Return the final result of the reduction o",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:7144,multi-thread,multi-threading,7144,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['multi-thread'],['multi-threading']
Performance,"ion.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and term",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1209,load,load,1209,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['load'],['load']
Performance,"ions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines the pass that looks through the machine instructions; /// late in the compilation, and finds byte or word instructions that; /// can be profitably replaced with 32 bit instructions that give equivalent; /// results for the bits of the results that are used. There are two possible; /// reasons to do this.; ///; /// One reason is to avoid false-dependences on the upper portions; /// of the registers. Only instructions that have a destination register; /// which is not in any of the source registers can be affected by this.; /// Any instruction where one of the source registers is also the destination; /// register is unaffected, because it has a true dependence on the source; /// register already. So, this consideration primarily affects load; /// instructions and register-to-register moves. It would; /// seem like cmov(s) would also be affected, but because of the way cmov is; /// really implemented by most machines as reading both the destination and; /// and source registers, and then ""merging"" the two based on a condition,; /// it really already should be considered as having a true dependence on the; /// destination register as well.; ///; /// The other reason to do this is for potential code size savings. Word; /// operations need an extra override byte compared to their 32 bit; /// versions. So this can convert many word operations to their larger; /// size, saving a byte in encoding. This could introduce partial register; /// dependences where none existed however. As an example take:; /// orw ax, $0x1000; /// addw ax, $3; /// now if this were to get transformed into; /// orw ax, $1000; /// addl eax, $3; /// because the addl encodes shorter than the addw, this would introduce; /// a use of a register that was only pa",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:1153,load,load,1153,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,1,['load'],['load']
Performance,"ions_8C.html); for a more complete example. #### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(). Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; executes the callable on the values of those columns for each event that passes all upstream selections.; It can be used to perform actions that are not already available in the interface. For example, the following snippet; evaluates the root mean square of column ""x"":; ~~~{.cpp}; // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; thread will execute the expression concurrently.; The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; this is probably too much head-scratch for such a simple operation. ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; ~~~{.cpp}; // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; const unsigned int nSlots = df.GetNSlots();; std::vector<double> sumSqs(nSlots, 0.);; std::vector<unsigned int> ns(nSlots, 0);. df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; dou",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:70136,concurren,concurrent,70136,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['concurren'],['concurrent']
Performance,"iption** |; |------------------|-----------------|; | Aggregate() | Execute a user-defined accumulation operation on the processed column values. |; | Book() | Book execution of a custom action using a user-defined helper object. |; | Cache() | Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). |; | Count() | Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. |; | Display() | Provides a printable representation of the dataset contents. The method returns a ROOT::RDF::RDisplay() instance which can print a tabular representation of the data or return it as a string. |; | Fill() | Fill a user-defined object with the values of the specified columns, as if by calling `Obj.Fill(col1, col2, ...)`. |; | Graph() | Fills a TGraph with the two columns provided. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | GraphAsymmErrors() | Fills a TGraphAsymmErrors. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | Histo1D(), Histo2D(), Histo3D() | Fill a one-, two-, three-dimensional histogram with the processed column values. |; | HistoND() | Fill an N-dimensional histogram with the processed column values. |; | Max() | Return the maximum of processed column values. If the type of the column is inferred, the return type is `double`, the type of the column otherwise.|; | Mean() | Return the mean of processed column values.|; | Min() | Return the minimum of processed column values. If the type of the column is inferred, the return type is `double`, the type of the column otherwise.|; | Profile1D(), Profile2D() | Fill a one- or two-dimensional profile with the column values that passed all filters. |; | Reduce() | Reduce (e.g. sum, merge)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:6954,multi-thread,multi-threading,6954,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['multi-thread'],['multi-threading']
Performance,"ique, one considers an example derived from the analysis where; \f$\hbox {$_s$}{\cal P}lots\f$; have been first used (charmless B decays). One is dealing with a data; sample in which two species are present: the first is termed signal and; the second background. A maximum Likelihood fit is performed to obtain; the two yields \f$N_1\f$ and \f$N_2\f$ . The fit relies on two discriminating; variables collectively denoted \f$y\f$ which are chosen within three possible; variables denoted \f${m_{\rm ES}}\f$ , \f$\Delta E\f$ and \f${\cal F}\f$.; The variable which is not incorporated in \f$y\f$ is used as the control variable; \f$x\f$ . The six distributions of the three variables are assumed to be the ones; depicted in Fig. 1. \image html splot_pdfmesNIM.png Figure 1 width=800. Distributions of the three discriminating variables available to perform the Likelihood fit:; \f${m_{\rm ES}}\f$ , \f$\Delta E\f$ , \f${\cal F}\f$ .; Among the three variables, two are used to perform the fit while one is; kept out of the fit to serve the purpose of a control variable. The; three distributions on the top (resp. bottom) of the figure correspond; to the signal (resp. background). The unit of the vertical axis is; chosen such that it indicates the number of entries per bin, if one; slices the histograms in 25 bins. A data sample being built through a Monte Carlo simulation based on the; distributions shown in Fig.; 1,; one obtains the three distributions of Fig. 2.; Whereas the distribution of \f$\Delta E\f$ clearly indicates the presence of the signal,; the distribution of \f${m_{\rm ES}}\f$ and \f${\cal F}\f$ are less obviously populated by signal. \image html splot_genfiTOTNIM.png Figure 2 width=800. Distributions of the three discriminating variables for signal plus; background. The three distributions are the ones obtained from a data; sample obtained through a Monte Carlo simulation based on the; distributions shown in Fig.; 1.; The data sample consists of 500 signal events and ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/splot/src/TSPlot.cxx:7326,perform,perform,7326,math/splot/src/TSPlot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/splot/src/TSPlot.cxx,1,['perform'],['perform']
Performance,"ir of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push; // the children nodes to the queue via `static bool; // IsStructurallyEquivalent(StructuralEquivalenceContext &Context, Decl *D1,; // Decl *D2)`. So far so good, this is almost like the BFS. However, if we; // let a static implementation function to call `Finish` via another **member**; // function that means we end up with two nested while loops each of them; // working on the same queue. This is wrong and nobody can reason about it's; // doing. Thus, static implementation functions must not call the **member**; // functions.; //; //===-------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:1472,queue,queue,1472,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,1,['queue'],['queue']
Performance,"ire"", ""new_jersey"",; ""new_mexico"", ""new_york"", ""north_carolina"", ""north_dakota"",; ""ohio"", ""oklahoma"", ""oregon"", ""pennsylvania"",; ""rhode_island"", ""south_carolina"", ""south_dakota"", ""tennessee"",; ""texas"", ""utah"", ""vermont"", ""virginia"",; ""washington"", ""west_virginia"", ""wisconsin"", ""wyoming""; };; Double_t pop[nx] = {; 4708708, 6595778, 2889450, 36961664, 5024748, 3518288, 885122, 18537969,; 9829211, 1545801, 12910409, 6423113, 3007856, 2818747, 4314113, 4492076,; 1318301, 5699478, 6593587, 9969727, 5266214, 2951996, 5987580, 974989,; 1796619, 2643085, 1324575, 8707739, 2009671, 19541453, 9380884, 646844,; 11542645, 3687050, 3825657, 12604767, 1053209, 4561242, 812383, 6296254,; 24782302, 2784572, 621760, 7882590, 6664195, 1819777, 5654774, 544270; };. Double_t lon1 = -130;; Double_t lon2 = -65;; Double_t lat1 = 24;; Double_t lat2 = 50;; auto p = new TH2Poly(""USA"",""USA Population"",lon1,lon2,lat1,lat2);. TFile::SetCacheFileDir(""."");; auto f = TFile::Open(""http://root.cern/files/usa.root"", ""CACHEREAD"");. TMultiGraph *mg;; TKey *key;; TIter nextkey(gDirectory->GetListOfKeys());; while ((key = (TKey*)nextkey())) {; TObject *obj = key->ReadObj();; if (obj->InheritsFrom(""TMultiGraph"")) {; mg = (TMultiGraph*)obj;; bin = p->AddBin(mg);; }; }. for (i=0; i<nx; i++) p->Fill(states[i], pop[i]);. gStyle->SetOptStat(11);; p->Draw(""COLZ L"");; }; End_Macro. `TH2Poly` histograms can also be plotted using the GL interface using; the option ""GLLEGO"". \since **ROOT version 6.09/01**. In some cases it can be useful to not draw the empty bins. the option ""0""; combined with the option ""COL"" et COLZ allows to do that. Begin_Macro(source); {; auto chc = new TCanvas(""chc"",""chc"",600,400);. auto hc = new TH2Poly();; hc->Honeycomb(0,0,.1,25,25);; hc->SetName(""hc"");; hc->SetTitle(""Option COLZ 0"");; TRandom ran;; for (int i = 0; i<300; i++) hc->Fill(ran.Gaus(2.,1), ran.Gaus(2.,1));; hc->Draw(""colz 0"");; }; End_Macro. \anchor HP21; ### The SPEC option. This option allows to use the `TSpectrum2Painter` to",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:86393,CACHE,CACHEREAD,86393,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['CACHE'],['CACHEREAD']
Performance,"is RooStringVar,; but it is rarely used. The ""shapes"" that a RooAbsArg can possess can e.g. be the definition; range of an observable, or how many states a category object has. In computations,; values are expected to change often, while shapes remain mostly constant; (unless e.g. a new range is set for an observable). Nodes of a computation graph are connected using instances of RooAbsProxy.; If Node B declares a member `RooTemplateProxy<TypeOfNodeA>`, Node A will be; registered as a server of values to Node B, and Node B will know that it is; a client of node A. Using functions like dependsOn(), or getObservables(); / getParameters(), the relation of `A --> B` can be queried. Using graphVizTree(),; one can create a visualisation of the expression tree. An instance of RooAbsArg can have named attributes. It also has flags; to indicate that either its value or its shape were changed (= it is dirty).; RooAbsArg provides functionality to manage client/server relations in; a computation graph (\ref clientServerInterface), and helps propagating; value/shape changes through the graph. RooAbsArg implements interfaces; for inspecting client/server relationships (\ref clientServerInterface) and; setting/clearing/querying named attributes. ### Caching of values; The values of nodes in the computation graph are cached in RooFit. If; a value is used in two nodes of a graph, it doesn't need to be recomputed. If; a node acquires a new value, it notifies its consumers (""clients"") that; their cached values are dirty. See the functions in \ref optimisationInterface; for details.; A node uses its isValueDirty() and isShapeDirty() functions to decide if a; computation is necessary. Caching can be vetoed globally by setting a; bit using setDirtyInhibit(). This will make computations slower, but all the; nodes of the computation graph will be evaluated irrespective of whether their; state is clean or dirty. Using setOperMode(), caching can also be enabled/disabled; for single nodes. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:2761,cache,cached,2761,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,2,['cache'],['cached']
Performance,"is class acts as a file cache, registering automatically the baskets from; the branches being processed via direct manipulation of TTrees or with tools; such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame; when in the learning phase. The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. The usage of a TTreeCache can considerably improve the runtime performance at; the price of a modest investment in memory, in particular when the TTree is; accessed remotely, e.g. via a high latency network. For each TTree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted.; The user can change the size of the cache with the TTree::SetCacheSize method; (by default the size is 30 Megabytes). This feature can be controlled with the; environment variable `ROOT_TTREECACHE_SIZE` or the TTreeCache.Size option.; The entry range for which the cache is active can also be set with the; SetEntryRange method. \anchor changesbehaviour; ## Changes of behavior when using TChain and TEventList. The usage of TChain or TEventList have influence on the behaviour of the cache:. - Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. - Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning phase is started or restarted when:; - TTree automatically creates a cache.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTreeCache::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; - TTreeCache::StopLearningPhase is called.; - An entry outside ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:3527,cache,cache,3527,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"is done to improve the hiding of low; // latencies.; //; // Actually when talking about 'low latency' or 'high latency' it includes; // both the latency to get the cache (or global mem) data go to the register,; // and the bandwidth limitations.; // Increasing the number of active wavefronts helps hide the former, but it; // doesn't solve the latter, thus why even if wavefront count is high, we have; // to try have as many instructions hiding high latencies as possible.; // The OpenCL doc says for example latency of 400 cycles for a global mem; // access, which is hidden by 10 instructions if the wavefront count is 10.; // Some figures taken from AMD docs:; // Both texture and constant L1 caches are 4-way associative with 64 bytes; // lines.; // Constant cache is shared with 4 CUs.; // For texture sampling, the address generation unit receives 4 texture; // addresses per cycle, thus we could expect texture sampling latency to be; // equivalent to 4 instructions in the very best case (a VGPR is 64 work items,; // instructions in a wavefront group are executed every 4 cycles),; // or 16 instructions if the other wavefronts associated to the 3 other VALUs; // of the CU do texture sampling too. (Don't take these figures too seriously,; // as I'm not 100% sure of the computation); // Data exports should get similar latency.; // For constant loading, the cache is shader with 4 CUs.; // The doc says ""a throughput of 16B/cycle for each of the 4 Compute Unit""; // I guess if the other CU don't read the cache, it can go up to 64B/cycle.; // It means a simple s_buffer_load should take one instruction to hide, as; // well as a s_buffer_loadx2 and potentially a s_buffer_loadx8 if on the same; // cache line.; //; // As of today the driver doesn't preload the constants in cache, thus the; // first loads get extra latency. The doc says global memory access can be; // 300-600 cycles. We do not specially take that into account when scheduling; // As we expect the driver to be able to p",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:4129,latency,latency,4129,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['latency'],['latency']
Performance,"is function checks to see if an expansion of memcmp can be generated.; // It checks for constant compare size that is less than the max inline size.; // If an expansion cannot occur, returns false to leave as a library call.; // Otherwise, the library call is replaced with a new IR instruction sequence.; /// We want to transform:; /// %call = call signext i32 @memcmp(i8* %0, i8* %1, i64 15); /// To:; /// loadbb:; /// %0 = bitcast i32* %buffer2 to i8*; /// %1 = bitcast i32* %buffer1 to i8*; /// %2 = bitcast i8* %1 to i64*; /// %3 = bitcast i8* %0 to i64*; /// %4 = load i64, i64* %2; /// %5 = load i64, i64* %3; /// %6 = call i64 @llvm.bswap.i64(i64 %4); /// %7 = call i64 @llvm.bswap.i64(i64 %5); /// %8 = sub i64 %6, %7; /// %9 = icmp ne i64 %8, 0; /// br i1 %9, label %res_block, label %loadbb1; /// res_block: ; preds = %loadbb2,; /// %loadbb1, %loadbb; /// %phi.src1 = phi i64 [ %6, %loadbb ], [ %22, %loadbb1 ], [ %36, %loadbb2 ]; /// %phi.src2 = phi i64 [ %7, %loadbb ], [ %23, %loadbb1 ], [ %37, %loadbb2 ]; /// %10 = icmp ult i64 %phi.src1, %phi.src2; /// %11 = select i1 %10, i32 -1, i32 1; /// br label %endblock; /// loadbb1: ; preds = %loadbb; /// %12 = bitcast i32* %buffer2 to i8*; /// %13 = bitcast i32* %buffer1 to i8*; /// %14 = bitcast i8* %13 to i32*; /// %15 = bitcast i8* %12 to i32*; /// %16 = getelementptr i32, i32* %14, i32 2; /// %17 = getelementptr i32, i32* %15, i32 2; /// %18 = load i32, i32* %16; /// %19 = load i32, i32* %17; /// %20 = call i32 @llvm.bswap.i32(i32 %18); /// %21 = call i32 @llvm.bswap.i32(i32 %19); /// %22 = zext i32 %20 to i64; /// %23 = zext i32 %21 to i64; /// %24 = sub i64 %22, %23; /// %25 = icmp ne i64 %24, 0; /// br i1 %25, label %res_block, label %loadbb2; /// loadbb2: ; preds = %loadbb1; /// %26 = bitcast i32* %buffer2 to i8*; /// %27 = bitcast i32* %buffer1 to i8*; /// %28 = bitcast i8* %27 to i16*; /// %29 = bitcast i8* %26 to i16*; /// %30 = getelementptr i16, i16* %28, i16 6; /// %31 = getelementptr i16, i16* %29, i16 6; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:978,load,loadbb,978,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,1,['load'],['loadbb']
Performance,"is needed for getting correct parameter uncertainties for weighted fits.; /// ""P"" | Uses Pearson chi-square method. Uses expected errors instead of the observed one (default case). The expected error is instead estimated from the square-root of the bin function value.; /// ""MULTI"" | Uses Loglikelihood method based on multi-nomial distribution. In this case the function must be normalized and one fits only the function shape.; /// ""W"" | Fit using the chi-square method and ignoring the bin uncertainties and skip empty bins.; /// ""WW"" | Fit using the chi-square method and ignoring the bin uncertainties and include the empty bins.; /// ""I"" | Uses the integral of function in the bin instead of the default bin center value.; /// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; /// ""U"" | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter::SetFCN`; /// ""E"" | Performs a better parameter errors estimation using the Minos technique for all fit parameters.; /// ""M"" | Uses the IMPROVE algorithm (available only in TMinuit). This algorithm attempts improve the found local minimum by searching for a better one.; /// ""S"" | The full result of the fit is returned in the `TFitResultPtr`. This is needed to get the covariance matrix of the fit. See `TFitResult` and the base class `ROOT::Math::FitResult`.; /// ""Q"" | Quiet mode (minimum printing); /// ""V"" | Verbose mode (default is between Q and V); /// ""+"" | Adds this new fitted function to the list of fitted functions. By default, the previous function is deleted and only the last one is kept.; /// ""N"" | Does not store the graphics function, does not draw the histogram with the function after fitting.; /// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; /// ""R"" | Fit using a fitting rang",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:2067,Perform,Performs,2067,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['Perform'],['Performs']
Performance,"is pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their success",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1370,load,load,1370,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,2,['load'],"['load', 'loads']"
Performance,"it simply serves a cached result. \anchor named-filters-and-cutflow-reports; #### Named filters and cutflow reports; An optional string parameter `name` can be passed to the Filter() method to create a **named filter**. Named filters; work as usual, but also keep track of how many entries they accept and reject. Statistics are retrieved through a call to the Report() method:. - when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all; named filters declared up to that point; - when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport>; relative all named filters in the section of the chain between the main RDataFrame and that node (included). Stats are stored in the same order as named filters have been added to the graph, and *refer to the latest event-loop*; that has been run using the relevant RDataFrame. \anchor ranges; ### Ranges; When RDataFrame is not being used in a multi-thread environment (i.e. no call to EnableImplicitMT() was made),; Range() transformations are available. These act very much like filters but instead of basing their decision on; a filter expression, they rely on `begin`,`end` and `stride` parameters. - `begin`: initial entry number considered for this range.; - `end`: final entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset.; - `stride`: process one entry of the [begin, end) range every `stride` entries. Must be strictly greater than 0. The actual number of entries processed downstream of a Range() node will be `(end - begin)/stride` (or less if less; entries than that are available). Note that ranges act ""locally"", not based on the global entry count: `Range(10,50)` means ""skip the first 10 entries; *that reach this node*, let the next 40 entries pass, then stop processing"". If a range node hangs from a filter node,; and the range has a `begin` parame",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:30733,multi-thread,multi-thread,30733,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['multi-thread'],['multi-thread']
Performance,"ith 32 bit instructions that give equivalent; /// results for the bits of the results that are used. There are two possible; /// reasons to do this.; ///; /// One reason is to avoid false-dependences on the upper portions; /// of the registers. Only instructions that have a destination register; /// which is not in any of the source registers can be affected by this.; /// Any instruction where one of the source registers is also the destination; /// register is unaffected, because it has a true dependence on the source; /// register already. So, this consideration primarily affects load; /// instructions and register-to-register moves. It would; /// seem like cmov(s) would also be affected, but because of the way cmov is; /// really implemented by most machines as reading both the destination and; /// and source registers, and then ""merging"" the two based on a condition,; /// it really already should be considered as having a true dependence on the; /// destination register as well.; ///; /// The other reason to do this is for potential code size savings. Word; /// operations need an extra override byte compared to their 32 bit; /// versions. So this can convert many word operations to their larger; /// size, saving a byte in encoding. This could introduce partial register; /// dependences where none existed however. As an example take:; /// orw ax, $0x1000; /// addw ax, $3; /// now if this were to get transformed into; /// orw ax, $1000; /// addl eax, $3; /// because the addl encodes shorter than the addw, this would introduce; /// a use of a register that was only partially written earlier. On older; /// Intel processors this can be quite a performance penalty, so this should; /// probably only be done when it can be proven that a new partial dependence; /// wouldn't be created, or when your know a newer processor is being; /// targeted, or when optimizing for minimum code size.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:2235,perform,performance,2235,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,2,"['optimiz', 'perform']","['optimizing', 'performance']"
Performance,"ject, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform an entirely numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e., no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; common, etc). #### Implementing analytical integrals; To implement analytical integrals, two functions must be implemented. First,. ```; Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet); ```; should return the analytical integrals that are supported. `integSet`; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to `anaIntSet`, and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. ```; double analyticalIntegral(Int_t code); ```. implements the actual analytical integral(s) advertised by; `getAnalyticalIntegral()`. This function will only be called with; codes returned by `getAnalyticalIntegral()`, except code zero. The integration range for each dependent to be integrated can; be obtained from the dependent's proxy functions `min()` and; `max()`. Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g., in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. ### Direct generation of observables. Distributions for any PDF can be generated with the accept/reject method,; but for certain PDFs, more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for ana",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:3684,perform,performed,3684,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['perform'],['performed']
Performance,"kernel_code_t.privateElementSize); /// - Index_stride: SH_STATIC_MEM_CONFIG.INDEX_STRIDE (will be 64 as must; /// be number of wavefront lanes for scratch, must agree with; /// amd_kernel_code_t.wavefrontSize); /// - Add tid enable: 1; /// - ATC: from SH_MEM_CONFIG.PRIVATE_ATC,; /// - Hash_enable: ???; /// - Heap: ???; /// - Mtype: from SH_STATIC_MEM_CONFIG.PRIVATE_MTYPE; /// - Type: 0 (a buffer) (???); ///; /// Dispatch Ptr (enable_sgpr_dispatch_ptr):; /// Number of User SGPR registers: 2. 64 bit address of AQL dispatch packet; /// for kernel actually executing.; ///; /// Queue Ptr (enable_sgpr_queue_ptr):; /// Number of User SGPR registers: 2. 64 bit address of AmdQueue object for; /// AQL queue on which the dispatch packet was queued.; ///; /// Kernarg Segment Ptr (enable_sgpr_kernarg_segment_ptr):; /// Number of User SGPR registers: 2. 64 bit address of Kernarg segment. This; /// is directly copied from the kernargPtr in the dispatch packet. Having CP; /// load it once avoids loading it at the beginning of every wavefront.; ///; /// Dispatch Id (enable_sgpr_dispatch_id):; /// Number of User SGPR registers: 2. 64 bit Dispatch ID of the dispatch; /// packet being executed.; ///; /// Flat Scratch Init (enable_sgpr_flat_scratch_init):; /// Number of User SGPR registers: 2. This is 2 SGPRs.; ///; /// For CI/VI:; /// The first SGPR is a 32 bit byte offset from SH_MEM_HIDDEN_PRIVATE_BASE; /// to base of memory for scratch for this dispatch. This is the same offset; /// used in computing the Scratch Segment Buffer base address. The value of; /// Scratch Wave Offset must be added by the kernel code and moved to; /// SGPRn-4 for use as the FLAT SCRATCH BASE in flat memory instructions.; ///; /// The second SGPR is 32 bit byte size of a single work-item's scratch; /// memory usage. This is directly loaded from the dispatch packet Private; /// Segment Byte Size and rounded up to a multiple of DWORD.; ///; /// \todo [Does CP need to round this to >4 byte alignment?]; ///; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:3213,load,load,3213,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,2,['load'],"['load', 'loading']"
Performance,"kes no prediction on the expected number of events will result in error messages,; /// and the chi2 will fall back to the total data weight to scale the normalized pdf.; /// - There are cases where the fit **must** be done in extended mode. This happens for example when you have a RooAddPdf; /// where the coefficients represent component yields. If the fit is not extended, these coefficients will not be; /// well-defined, as the RooAddPdf always normalizes itself. If you pass `Extended(false)` in such a case, an error will be; /// printed and you'll most likely get garbage results.; /// <tr><td> `Range(const char* name)` <td> Fit only data inside range with given name; /// <tr><td> `Range(double lo, double hi)` <td> Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; /// Multiple comma separated range names can be specified.; /// <tr><td> `NumCPU(int num)` <td> Parallelize NLL calculation on num CPUs; /// <tr><td> `Optimize(bool flag)` <td> Activate constant term optimization (on by default); /// <tr><td> `IntegrateBins()` <td> Integrate PDF within each bin. This sets the desired precision.; ///; /// <tr><th> <th> Options to control flow of fit procedure; /// <tr><td> `InitialHesse(bool flag)` <td> Flag controls if HESSE before MIGRAD as well, off by default; /// <tr><td> `Hesse(bool flag)` <td> Flag controls if HESSE is run after MIGRAD, on by default; /// <tr><td> `Minos(bool flag)` <td> Flag controls if MINOS is run after HESSE, on by default; /// <tr><td> `Minos(const RooArgSet& set)` <td> Only run MINOS on given subset of arguments; /// <tr><td> `Save(bool flag)` <td> Flag controls if RooFitResult object is produced and returned, off by default; /// <tr><td> `Strategy(Int_t flag)` <td> Set Minuit strategy (0 through 2, default is 1); ///; /// <tr><th> <th> Options to control informational output; /// <tr><td> `Verbose(bool flag)` <td> Flag controls if verbose output is printed (NLL, parameter changes during fit; /// ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:1892,Optimiz,Optimize,1892,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,2,"['Optimiz', 'optimiz']","['Optimize', 'optimization']"
Performance,"l attaining good performance.; ///; /// Pseudocode for the aforementioned OpenMP program generated by the; /// compiler is as follows:; ///; /// 1. Create private copies of reduction variables on each OpenMP; /// thread: 'foo_private', 'bar_private'; /// 2. Each OpenMP thread reduces the chunk of 'A' and 'B' assigned; /// to it and writes the result in 'foo_private' and 'bar_private'; /// respectively.; /// 3. Call the OpenMP runtime on the GPU to reduce within a team; /// and store the result on the team master:; ///; /// __kmpc_nvptx_parallel_reduce_nowait_v2(...,; /// reduceData, shuffleReduceFn, interWarpCpyFn); ///; /// where:; /// struct ReduceData {; /// double *foo;; /// double *bar;; /// } reduceData; /// reduceData.foo = &foo_private; /// reduceData.bar = &bar_private; ///; /// 'shuffleReduceFn' and 'interWarpCpyFn' are pointers to two; /// auxiliary functions generated by the compiler that operate on; /// variables of type 'ReduceData'. They aid the runtime perform; /// algorithmic steps in a data agnostic manner.; ///; /// 'shuffleReduceFn' is a pointer to a function that reduces data; /// of type 'ReduceData' across two OpenMP threads (lanes) in the; /// same warp. It takes the following arguments as input:; ///; /// a. variable of type 'ReduceData' on the calling lane,; /// b. its lane_id,; /// c. an offset relative to the current lane_id to generate a; /// remote_lane_id. The remote lane contains the second; /// variable of type 'ReduceData' that is to be reduced.; /// d. an algorithm version parameter determining which reduction; /// algorithm to use.; ///; /// 'shuffleReduceFn' retrieves data from the remote lane using; /// efficient GPU shuffle intrinsics and reduces, using the; /// algorithm specified by the 4th parameter, the two operands; /// element-wise. The result is written to the first operand.; ///; /// Different reduction algorithms are implemented in different; /// runtime functions, all calling 'shuffleReduceFn' to perform; /// the essen",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:2255,perform,perform,2255,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['perform'],['perform']
Performance,"l class, do:; ~~~ {.cpp}; TRef fRef; //EXEC:execName. points to something; ~~~; When the special keyword ""EXEC:"" is found in the comment field of the member,; the next string is assumed to be the name of a TExec object.; When a file is connected, the dictionary of the classes on the file; is read in memory (see TFile::ReadStreamerInfo). When the TStreamerElement; object is read, a TExec object is automatically created with the name; specified after the keyword ""EXEC:"" in case a TExec with a same name does; not already exist. The action to be executed via this TExec can be specified with:. - a call to the TExec constructor, if the constructor is called before; opening the file.; - a call to TExec::SetAction at any time.; One can compute a pointer to an existing TExec with a name with:; ~~~ {.cpp}; TExec *myExec = gROOT->GetExec(execName);; myExec->SetAction(actionCommand);; ~~~; where actionCommand is a string containing a C++ instruction. Examples:; ~~~ {.cpp}; myExec->SetAction(""LoadHits()"");; myExec->SetAction("".x script.C"");; ~~~. When a TRef is dereferenced via TRef::GetObject, its TExec will be; automatically executed. In the function/script being executed, one or more; of the following actions can be executed:. - load a file containing the referenced object. This function typically; looks in the file catalog (GRID).; - compute a pointer to the referenced object and communicate this pointer; back to the calling function TRef::GetObject via:; ~~~ {.cpp}; TRef::SetStaticObject(object).; ~~~; When the TExec is called, it has access to the dereferencing TRef; by calling GetStaticObject() (TRef::GetObject() sets fgObject to ""this""; before the call to TExec). This can be useful for accessing the TRef's; fUniqueID. As soon as an object is returned to GetObject, the fUniqueID of the TRef is set; to the fUniqueID of the referenced object. At the next call to GetObject,; the pointer stored in fPid:fObjects[fUniqueID] will be returned directly. An example of action on dem",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TRef.cxx:6573,Load,LoadHits,6573,core/base/src/TRef.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TRef.cxx,1,['Load'],['LoadHits']
Performance,"le, the following snippet; evaluates the root mean square of column ""x"":; ~~~{.cpp}; // Single-thread evaluation of RMS of column ""x"" using Foreach; double sumSq = 0.;; unsigned int n = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; thread will execute the expression concurrently.; The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; this is probably too much head-scratch for such a simple operation. ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; ~~~{.cpp}; // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; const unsigned int nSlots = df.GetNSlots();; std::vector<double> sumSqs(nSlots, 0.);; std::vector<unsigned int> ns(nSlots, 0);. df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares; unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; Notice how we created one `double` variable for each processing slot and later merged their results via `std::accumulate`. \anchor friends; ### Dataset joins with friend trees. Vertically concate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:70560,concurren,concurrent,70560,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['concurren'],['concurrent']
Performance,"lect the ROOT marker color, default is black; ///; /// <tr><td> `MarkerSize(double size)` <td> Select the ROOT marker size; ///; /// <tr><td> `FillStyle(Int_t style)` <td> Select fill style, default is not filled. If a filled style is selected, also use VLines(); /// to add vertical downward lines at end of curve to ensure proper closure. Add `DrawOption(""F"")` for filled drawing.; /// <tr><td> `FillColor(Int_t color)` <td> Select fill color by ROOT color code; ///; /// <tr><td> `Range(const char* name)` <td> Only draw curve in range defined by given name; ///; /// <tr><td> `Range(double lo, double hi)` <td> Only draw curve in specified range; ///; /// <tr><td> `VLines()` <td> Add vertical lines to y=0 at end points of curve; ///; /// <tr><td> `Precision(double eps)` <td> Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; /// will result in more and more densely spaced curve points; ///; /// <tr><td> `Invisible(bool flag)` <td> Add curve to frame, but do not display. Useful in combination AddTo(); ///; /// <tr><td> `VisualizeError(const RooFitResult& fitres, double Z=1, bool linearMethod=true)`; /// <td> Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. The linear method is fast but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much) longer to calculate; ///; /// <tr><td> `VisualizeError(const RooFitResult& fitres, const RooArgSet& param, double Z=1, bool linearMethod=true)`; /// <td> Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma'; /// </table>; ///; /// Details on error band visualization; /// -----------------------------------; /// *VisualizeError() uses plotOnWithErrorBand(). Documentation of the latter:*; /// \see plotOnWithErrorBand()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:7500,perform,perform,7500,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['perform'],['perform']
Performance,"lel.; /// This is exclusive to ROOT::TThreadExecutor and not any other ROOT::TExecutorCRTP-derived classes.\n; ///; /// An integer can be passed as the fourth argument indicating the number of chunks we want to divide our work in.; /// This may be useful to avoid the overhead introduced when running really short tasks.; ///; /// #### Examples:; /// ~~~{.cpp}; /// root[] ROOT::TThreadExecutor pool; auto ten = pool.MapReduce([]() { return 1; }, 10, [](const std::vector<int> &v) { return std::accumulate(v.begin(), v.end(), 0); }); /// root[] ROOT::TThreadExecutor pool; auto hist = pool.MapReduce(CreateAndFillHists, 10, PoolUtils::ReduceObjects);; /// ~~~; ///; //////////////////////////////////////////////////////////////////////////; /*; VERY IMPORTANT NOTE ABOUT WORK ISOLATION. We enclose the parallel_for and parallel_reduce invocations in a; task_arena::isolate because we want to prevent a thread to start executing an; outer task when the task it's running spawned subtasks, e.g. with a parallel_for,; and is waiting on inner tasks to be completed. While this change has a negligible performance impact, it has benefits for; several applications, for example big parallelised HEP frameworks and; RDataFrame analyses.; - For HEP Frameworks, without work isolation, it can happen that a huge; framework task is pulled by a yielding ROOT task.; This causes to delay the processing of the event which is interrupted by the; long task.; For example, work isolation avoids that during the wait due to the parallel; flushing of baskets, a very long simulation task is pulled in by the idle task.; - For RDataFrame analyses we want to guarantee that each entry is processed from; the beginning to the end without TBB interrupting it to pull in other work items.; As a corollary, the usage of ROOT (or TBB in work isolation mode) in actions; and transformations guarantee that each entry is processed from the beginning to; the end without being interrupted by the processing of outer tasks.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/TThreadExecutor.cxx:4191,perform,performance,4191,core/imt/src/TThreadExecutor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/TThreadExecutor.cxx,1,['perform'],['performance']
Performance,"les of type 'ReduceData'. They aid the runtime perform; /// algorithmic steps in a data agnostic manner.; ///; /// 'shuffleReduceFn' is a pointer to a function that reduces data; /// of type 'ReduceData' across two OpenMP threads (lanes) in the; /// same warp. It takes the following arguments as input:; ///; /// a. variable of type 'ReduceData' on the calling lane,; /// b. its lane_id,; /// c. an offset relative to the current lane_id to generate a; /// remote_lane_id. The remote lane contains the second; /// variable of type 'ReduceData' that is to be reduced.; /// d. an algorithm version parameter determining which reduction; /// algorithm to use.; ///; /// 'shuffleReduceFn' retrieves data from the remote lane using; /// efficient GPU shuffle intrinsics and reduces, using the; /// algorithm specified by the 4th parameter, the two operands; /// element-wise. The result is written to the first operand.; ///; /// Different reduction algorithms are implemented in different; /// runtime functions, all calling 'shuffleReduceFn' to perform; /// the essential reduction step. Therefore, based on the 4th; /// parameter, this function behaves slightly differently to; /// cooperate with the runtime to ensure correctness under; /// different circumstances.; ///; /// 'InterWarpCpyFn' is a pointer to a function that transfers; /// reduced variables across warps. It tunnels, through CUDA; /// shared memory, the thread-private data of type 'ReduceData'; /// from lane 0 of each warp to a lane in the first warp.; /// 4. Call the OpenMP runtime on the GPU to reduce across teams.; /// The last team writes the global reduced value to memory.; ///; /// ret = __kmpc_nvptx_teams_reduce_nowait(...,; /// reduceData, shuffleReduceFn, interWarpCpyFn,; /// scratchpadCopyFn, loadAndReduceFn); ///; /// 'scratchpadCopyFn' is a helper that stores reduced; /// data from the team master to a scratchpad array in; /// global memory.; ///; /// 'loadAndReduceFn' is a helper that loads data from; /// the",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:3251,perform,perform,3251,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['perform'],['perform']
Performance,"linkage would be; /// unique per module; /// as the GUID includes the module path. We could have a guid alias if; /// there wasn't any distinguishing path when each file was compiled, but; /// that should be rare so we'll punt on those.; /// These next 2 cases should not happen and will assert:; /// - Multiple instances with external linkage. This should be caught in; /// symbol resolution; /// - Non-existent FunctionSummary for Aliasee. This presents a hole in our; /// knowledge meaning we have to go conservative.; /// Otherwise, we calculate attributes for a function as:; /// 1. If we have a local linkage, take its attributes. If there's somehow; /// multiple, bail and go conservative.; /// 2. If we have an external/WeakODR/LinkOnceODR linkage check that it is; /// prevailing, take its attributes.; /// 3. If we have a Weak/LinkOnce linkage the copies can have semantic; /// differences. However, if the prevailing copy is known it will be used; /// so take its attributes. If the prevailing copy is in a native file; /// all IR copies will be dead and propagation will go conservative.; /// 4. AvailableExternally summaries without a prevailing copy are known to; /// occur in a couple of circumstances:; /// a. An internal function gets imported due to its caller getting; /// imported, it becomes AvailableExternally but no prevailing; /// definition exists. Because it has to get imported along with its; /// caller the attributes will be captured by propagating on its; /// caller.; /// b. C++11 [temp.explicit]p10 can generate AvailableExternally; /// definitions of explicitly instanced template declarations; /// for inlining which are ultimately dropped from the TU. Since this; /// is localized to the TU the attributes will have already made it to; /// the callers.; /// These are edge cases and already captured by their callers so we; /// ignore these for now. If they become relevant to optimize in the; /// future this can be revisited.; /// 5. Otherwise, go conservative.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:2094,optimiz,optimize,2094,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['optimiz'],['optimize']
Performance,"ll also be sent along with tasks to; * the queue. When a worker then takes a task from the queue, it can check; * whether it has already updated its state to what is expected to be there; * for the task at hand. If not, it should wait for the new state to arrive; * over the state subscription socket. Note: it is the implementer's task to; * actually update 'Job::state_id_' inside 'Job::update_state()'!; *; * ## Implementers notes; *; * The type of result from each task is strongly dependent on the Job at hand; * and so Job does not provide a default results member. It is up to the; * inheriting class to implement this in the above functions. We would have; * liked a template parameter task_result_t, so that we could also provide a; * default ""boilerplate"" calculate function to show a typical Job use-case of; * all the above infrastructure. This is not trivial, because the JobManager; * has to keep a list of Job pointers, so if there would be different template; * instantiations of Jobs, this would complicate this list.; *; * A typical Job implementation will have an evaluation function that is; * called from the master process, like RooAbsArg::getVal calls evaluate().; * This function will have three purposes: 1. send updated parameter values; * to the workers (possibly through update_state() or in a dedicated; * function), 2. queue tasks and 3. wait for the results to be retrieved.; * 'Job::gather_worker_results()' is provided for convenience to wait for; * all tasks to be retrieved for the current Job. Implementers can also; * choose to have the master process perform other tasks in between any of; * these three steps, or even skip steps completely.; *; * Child classes should refrain from direct access to the JobManager instance; * (through JobManager::instance), but rather use the here provided; * Job::get_manager(). This function starts the worker_loop on the worker when; * first called, meaning that the workers will not be running before they; * are needed.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Job.cxx:3396,queue,queue,3396,roofit/multiprocess/src/Job.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Job.cxx,2,"['perform', 'queue']","['perform', 'queue']"
Performance,"ll of the uncompressed; data from that block has been written to strm->next_out. The number of; unused bits may in general be greater than seven, except when bit 7 of; data_type is set, in which case the number of unused bits will be less than; eight. data_type is set as noted here every time inflate() returns for all; flush options, and so can be used to determine the amount of currently; consumed input in bits. The Z_TREES option behaves as Z_BLOCK does, but it also returns when the; end of each deflate block header is reached, before any actual data in that; block is decoded. This allows the caller to determine the length of the; deflate block header for later use in random access within a deflate block.; 256 is added to the value of strm->data_type when inflate() returns; immediately after reaching the end of the deflate block header. inflate() should normally be called until it returns Z_STREAM_END or an; error. However if all decompression is to be performed in a single step (a; single call of inflate), the parameter flush should be set to Z_FINISH. In; this case all pending input is processed and all pending output is flushed;; avail_out must be large enough to hold all of the uncompressed data for the; operation to complete. (The size of the uncompressed data may have been; saved by the compressor for this purpose.) The use of Z_FINISH is not; required to perform an inflation in one step. However it may be used to; inform inflate that a faster approach can be used for the single inflate(); call. Z_FINISH also informs inflate to not maintain a sliding window if the; stream completes, which reduces inflate's memory footprint. If the stream; does not complete, either because not all of the stream is provided or not; enough output space is provided, then a sliding window will be allocated and; inflate() can be called again to continue the operation as if Z_NO_FLUSH had; been used. In this implementation, inflate() always flushes as much output as; possible to the",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:3475,perform,performed,3475,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['perform'],['performed']
Performance,"lled if the library is; // 'only' dlclosed.; // On Ubuntu the linker strips the unused libraries. Eventhough; // stressHistogram is explicitly linked against libNet, it is not; // retained and thus is loaded only as needed in the middle part of; // the execution. Concretely this also means that it is loaded; // *after* the construction of the TApplication object and thus; // after the registration (atexit) of the EndOfProcessCleanups; // routine. Consequently, after the end of main, libNet is; // unloaded before EndOfProcessCleanups is called. When; // EndOfProcessCleanups is executed it indirectly needs the TClass; // for TSocket and its search will use resources that have already; // been unloaded (technically the function static in TUnixSystem's; // DynamicPath and the dictionary from libNet).; // Similarly, the ordering (before this commit) was broken in the; // following case:; // TApplication creation (EndOfProcessCleanups registration); // load UserLibrary; // create TFile; // Append UserObject to TFile; // and after the end of main the order of execution was; // unload UserLibrary; // call EndOfProcessCleanups; // Write the TFile; // attempt to write the user object.; // ....; // where what we need is to have the files closen/written before; // the unloading of the library.; // To solve the problem we now register an atexit function for; // every dictionary thus making sure there is at least one executed; // before the first library tear down after main.; // If atexit is called directly within a library's code, the; // function will called *either* when the library is 'dlclose'd or; // after then end of main (whichever comes first). We do *not*; // want the files to be closed whenever a library is unloaded via; // dlclose. To avoid this, we add the function (CallCloseFiles); // from the dictionary indirectly (via ROOT::RegisterModule). In; // this case the function will only only be called either when; // libCore is 'dlclose'd or right after the end of main.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:1316,load,load,1316,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['load'],['load']
Performance,"longer valid to have visited, or such that functions not yet visited in; /// a bottom-up order of the SCC DAG are not required to have already been; /// visited.; ///; /// Within this constraint, the desire is to minimize the merge points of the; /// SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able to; /// form even a potential call edge from a function body which may dynamically; /// load the function and call it.; ///; /// This analysis still requires updates to remain valid after optimizations; /// which could potentially change the set of potential callees. The; /// constraints it operates under only make the traversal order remain valid.; ///; /// The entire analysis must be re-computed if full interprocedural; /// optimizations run at any point. For example, globalopt complete",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1632,optimiz,optimization,1632,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,1,['optimiz'],['optimization']
Performance,"lor code; /// <tr><td> `Range(const char* name)` <td> Only draw curve in range defined by given name. Multiple comma-separated ranges can be given.; /// An empty string """" or `nullptr` means to use the default range of the variable.; /// <tr><td> `Range(double lo, double hi)` <td> Only draw curve in specified range; /// <tr><td> `VLines()` <td> Add vertical lines to y=0 at end points of curve; /// <tr><td> `Precision(double eps)` <td> Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. A higher precision will; /// result in more and more densely spaced curve points. A negative precision value will disable; /// adaptive point spacing and restrict sampling to the grid point of points defined by the binning; /// of the plotted observable (recommended for expensive functions such as profile likelihoods); /// <tr><td> `Invisible(bool flag)` <td> Add curve to frame, but do not display. Useful in combination AddTo(); /// <tr><td> `VisualizeError(const RooFitResult& fitres, double Z=1, bool linearMethod=true)`; /// <td> Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma.; /// The linear method is fast but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made.; /// Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much) longer to calculate; /// \note To include the uncertainty from the expected number of events,; /// the Normalization() argument with `ScaleType` `RooAbsReal::RelativeExpected` has to be passed, e.g.; /// ```{.cpp}; /// pdf.plotOn(frame, VisualizeError(fitResult), Normalization(1.0, RooAbsReal::RelativeExpected));; /// ```; ///; /// <tr><td> `VisualizeError(const RooFitResult& fitres, const RooArgSet& param, double Z=1, bool linearMethod=true)`; /// <td> Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma; /// </table>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:7496,perform,perform,7496,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['perform'],['perform']
Performance,"lowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. ### NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"", i.e. the memory of your process grows and eventually; your program crashes. Even if you *always* delete the allocated; memory, the recovered space may not be efficiently reused. The; process knows that there are portions of free memory, but when you; allocate it again, a fresh piece of memory is grabbed. Your program; is free from semantic errors, but the total memory of your process; still grows, because your program's memory is full of ""holes"" which; reduce the efficiency of memory access; this is called ""memory; fragmentation"". Moreover new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. ### NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. - Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; - TClonesArray object classes containing pointers allocate memory.; To avoid ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClonesArray.cxx:3226,perform,performance,3226,core/cont/src/TClonesArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClonesArray.cxx,1,['perform'],['performance']
Performance,"ly; /// by monitoring the `Attributor::getAAFor` calls made by abstract attributes.; ///; /// The `updateImpl` method should inspect the IR and other abstract attributes; /// in-flight to justify the best possible (=optimistic) state. The actual; /// implementation is, similar to the underlying abstract state encoding, not; /// exposed. In the most common case, the `updateImpl` will go through a list of; /// reasons why its optimistic state is valid given the current information. If; /// any combination of them holds and is sufficient to justify the current; /// optimistic state, the method shall return UNCHAGED. If not, the optimistic; /// state is adjusted to the situation and the method shall return CHANGED.; ///; /// If the manifestation of the ""concrete attribute"" deduced by the subclass; /// differs from the ""default"" behavior, which is a (set of) LLVM-IR; /// attribute(s) for an argument, call site argument, function return value, or; /// function, the `AbstractAttribute::manifest` method should be overloaded.; ///; /// NOTE: If the state obtained via getState() is INVALID, thus if; /// AbstractAttribute::getState().isValidState() returns false, no; /// information provided by the methods of this class should be used.; /// NOTE: The Attributor currently has certain limitations to what we can do.; /// As a general rule of thumb, ""concrete"" abstract attributes should *for; /// now* only perform ""backward"" information propagation. That means; /// optimistic information obtained through abstract attributes should; /// only be used at positions that precede the origin of the information; /// with regards to the program flow. More practically, information can; /// *now* be propagated from instructions to their enclosing function, but; /// *not* from call sites to the called function. The mechanisms to allow; /// both directions will be added in the future.; /// NOTE: The mechanics of adding a new ""concrete"" abstract attribute are; /// described in the file comment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:2260,perform,perform,2260,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['perform'],['perform']
Performance,"m ... ]; // offset2[.discriminator]: number_of_samples [fn3:num fn4:num ... ]; // ...; // offsetN[.discriminator]: number_of_samples [fn5:num fn6:num ... ]; // offsetA[.discriminator]: fnA:num_of_total_samples; // offsetA1[.discriminator]: number_of_samples [fn7:num fn8:num ... ]; // ...; // !CFGChecksum: num; // !Attribute: flags; //; // This is a nested tree in which the indentation represents the nesting level; // of the inline stack. There are no blank lines in the file. And the spacing; // within a single line is fixed. Additional spaces will result in an error; // while reading the file.; //; // Any line starting with the '#' character is completely ignored.; //; // Inlined calls are represented with indentation. The Inline stack is a; // stack of source locations in which the top of the stack represents the; // leaf function, and the bottom of the stack represents the actual; // symbol to which the instruction belongs.; //; // Function names must be mangled in order for the profile loader to; // match them in the current translation unit. The two numbers in the; // function header specify how many total samples were accumulated in the; // function (first number), and the total number of samples accumulated; // in the prologue of the function (second number). This head sample; // count provides an indicator of how frequently the function is invoked.; //; // There are three types of lines in the function body.; //; // * Sampled line represents the profile information of a source location.; // * Callsite line represents the profile information of a callsite.; // * Metadata line represents extra metadata of the function.; //; // Each sampled line may contain several items. Some are optional (marked; // below):; //; // a. Source line offset. This number represents the line number; // in the function where the sample was collected. The line number is; // always relative to the line where symbol of the function is; // defined. So, if the function has its header at l",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h:1964,load,loader,1964,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h,1,['load'],['loader']
Performance,"m.; //; // Copying a byval struct into local memory in IR allows us to enforce; // the param space restrictions, gives the rest of IR a pointer w/o; // param space restrictions, and gives us an opportunity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global address space. In the IR level,; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // ; use %b; // }; //; // becomes; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // %b_global = addrspacecast i32* %b to i32 addrspace(1)*; // %b_generic = addrspacecast i32 addrspace(1)* %b_global to i32*; // ; use %b_generic; // }; //; // TODO: mer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:1914,optimiz,optimize,1914,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,2,"['load', 'optimiz']","['load', 'optimize']"
Performance,"m.; //; // To avoid this issue the patterns like (load/store (getelementptr ...)); // are replaced by calls to BPF specific intrinsic functions:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; //; // These calls are lowered back to (load/store (getelementptr ...)); // by BPFCheckAndAdjustIR pass right before the translation from IR to; // machine instructions.; //; // The transformation is split into the following steps:; // - When IR is generated from AST the calls to intrinsic function; // llvm.preserve.static.offset are inserted.; // - BPFPreserveStaticOffsetPass is executed as early as possible; // with AllowPatial set to true, this handles marked GEP chains; // with constant offsets.; // - BPFPreserveStaticOffsetPass is executed at ScalarOptimizerLateEPCallback; // with AllowPatial set to false, this handles marked GEP chains; // with offsets that became constant after loop unrolling, e.g.; // to handle the following code:; //; // struct context { int x[4]; } __attribute__((preserve_static_offset));; //; // struct context *ctx = ...;; // #pragma clang loop unroll(full); // for (int i = 0; i < 4; ++i); // foo(ctx->x[i]);; //; // The early BPFPreserveStaticOffsetPass run is necessary to allow; // additional GVN / CSE opportunities after functions inlining.; // The relative order of optimization applied to function:; // - early stage (1); // - ...; // - function inlining (2); // - ...; // - loop unrolling; // - ...; // - ScalarOptimizerLateEPCallback (3); //; // When function A is inlined into function B all optimizations for A; // are already done, while some passes remain for B. In case if; // BPFPreserveStaticOffsetPass is done at (3) but not done at (1); // the code after (2) would contain a mix of; // (load (gep %p)) and (get.and.load %p) usages:; // - the (load (gep %p)) would come from the calling function;; // - the (get.and.load %p) would come from the callee function.; // Thus clobbering CSE / GVN passes done after inlining.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:3746,optimiz,optimization,3746,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,6,"['load', 'optimiz']","['load', 'optimization', 'optimizations']"
Performance,"m.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to construct the appropriate SSA form for the value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:1273,load,loads,1273,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,4,['load'],"['load', 'loads']"
Performance,"mage *file2ASImage( const char *file, ASFlagType what,; * double gamma,; * unsigned int compression, ... );; * INPUTS; * file - file name with or without directory name; * what - reserved for future use; * gamma - gamma value to be used to correct image; * compression - compression level of the resulting ASImage; * ... - NULL terminated list of strings, representing; * arbitrary number of directories to be searched each.; * RETURN VALUE; * Pointer to ASImage structure holding image data on success.; * NULL on failure; * DESCRIPTION; * file2ASImage will attempt to interpret filename in the following way:; * 1)It will try to find file using unmodified filename in all the; * provided search paths.; * 2)It will attempt to append .gz and then .Z to the filename and; * find such file in all the provided search paths.; * 3)If filename ends with extension consisting of digits only - it will; * attempt to find file with this extension stripped off. On success; * this extension will be used to load subimage from the file with that; * number. Subimages are supported only for XCF, GIF, BMP, ICO and CUR; * files.; * After the file is found file2ASImage() attempts to detect file format,; * and if it is known it will load it into new ASImage structure.; * EXAMPLE; * asview.c: ASView.2; *********/; /****f* libAfterImage/import/get_asimage(); * NAME; * get_asimage() - increment reference counter if file is already loaded,; * or load image from file.; * SYNOPSIS; * ASImage *get_asimage( ASImageManager* imageman, const char *file,; * ASFlagType what, unsigned int compression );; * INPUTS; * imageman - pointer to valid ASVisual structure.; * file - root window ID for the destination screen.; * what - full image file's name with path.; * compression -; * RETURN VALUE; * Pointer to ASImage structure holding image data on success.; * NULL on failure; * DESCRIPTION; * get_asimage will attempt check with the ASImageManager's list of load; * images, and if image with requested filename alrea",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.h:1113,load,load,1113,graf2d/asimage/src/libAfterImage/import.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.h,1,['load'],['load']
Performance,"make the derived //; // class a singleton. That is, something like //; // //; // class MyGenerator : public TGenerator //; // { //; // public: //; // static MyGenerator* Instance() //; // { //; // if (!fgInstance) fgInstance = new MyGenerator; //; // return fgInstance; //; // } //; // void GenerateEvent() { ... } //; // void ImportParticles(TClonesArray* a, Option_t opt="""") {...} //; // Int_t ImportParticles(Option_t opt="""") { ... } //; // Int_t SetParameter(const char* name, Double_t val) { ... } //; // Double_t GetParameter(const char* name) { ... } //; // virtual ~MyGenerator() { ... } //; // protected: //; // MyGenerator() { ... } //; // MyGenerator(const MyGenerator& o) { ... } //; // MyGenerator& operator=(const MyGenerator& o) { ... } //; // static MyGenerator* fgInstance; //; // ClassDefOverride(MyGenerator,0); //; // }; //; // //; // Having multiple objects accessing the same common blocks is not //; // safe. //; // //; // concrete TGenerator classes can be loaded in scripts and subseqent- //; // ly used in compiled code: //; // //; // // MyRun.h //; // class MyRun : public TObject //; // { //; // public: //; // static MyRun* Instance() { ... } //; // void SetGenerator(TGenerator* g) { fGenerator = g; } //; // void Run(Int_t n, Option_t* option="""") //; // { //; // TFile* file = TFile::Open(""file.root"",""RECREATE""); //; // TTree* tree = new TTree(""T"",""T""); //; // TClonesArray* p = new TClonesArray(""TParticles""); //; // tree->Branch(""particles"", &p); //; // for (Int_t event = 0; event < n; event++) { //; // fGenerator->GenerateEvent(); //; // fGenerator->ImportParticles(p,option); //; // tree->Fill(); //; // } //; // file->Write(); //; // file->Close(); //; // } //; // ... //; // protected: //; // TGenerator* fGenerator; //; // ClassDefOverride(MyRun,0); //; // }; //; // //; // // Config.C //; // void Config() //; // { //; // MyRun* run = MyRun::Instance(); //; // run->SetGenerator(MyGenerator::Instance()); //; // } //; // //; // // main.cxx //; // int //; // m",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/TGenerator.h:3080,load,loaded,3080,montecarlo/eg/inc/TGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/TGenerator.h,1,['load'],['loaded']
Performance,"mbine; /// First Order Polynomial on an n-Bit Integer Value; ///; /// Polynomial(Value) = Value * B + A + E*2^(n-e); ///; /// A and B are the coefficients. E*2^(n-e) is an error within 'e' most; /// significant bits. It is introduced if an exact computation cannot be proven; /// (e.q. division by 2).; ///; /// As part of this optimization multiple loads will be combined. It necessary; /// to prove that loads are within some relative offset to each other. This; /// class is used to prove relative offsets of values loaded from memory.; ///; /// Representing an integer in this form is sound since addition in two's; /// complement is associative (trivial) and multiplication distributes over the; /// addition (see Proof(1) in Polynomial::mul). Further, both operations; /// commute.; //; // Example:; // declare @fn(i64 %IDX, <4 x float>* %PTR) {; // %Pa1 = add i64 %IDX, 2; // %Pa2 = lshr i64 %Pa1, 1; // %Pa3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pa2; // %Va = load <4 x float>, <4 x float>* %Pa3; //; // %Pb1 = add i64 %IDX, 4; // %Pb2 = lshr i64 %Pb1, 1; // %Pb3 = getelementptr inbounds <4 x float>, <4 x float>* %PTR, i64 %Pb2; // %Vb = load <4 x float>, <4 x float>* %Pb3; // ... }; //; // The goal is to prove that two loads load consecutive addresses.; //; // In this case the polynomials are constructed by the following; // steps.; //; // The number tag #e specifies the error bits.; //; // Pa_0 = %IDX #0; // Pa_1 = %IDX + 2 #0 | add 2; // Pa_2 = %IDX/2 + 1 #1 | lshr 1; // Pa_3 = %IDX/2 + 1 #1 | GEP, step signext to i64; // Pa_4 = (%IDX/2)*16 + 16 #0 | GEP, multiply index by sizeof(4) for floats; // Pa_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; //; // Pb_0 = %IDX #0; // Pb_1 = %IDX + 4 #0 | add 2; // Pb_2 = %IDX/2 + 2 #1 | lshr 1; // Pb_3 = %IDX/2 + 2 #1 | GEP, step signext to i64; // Pb_4 = (%IDX/2)*16 + 32 #0 | GEP, multiply index by sizeof(4) for floats; // Pb_5 = (%IDX/2)*16 + 16 #0 | GEP, add offset of leading components; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:1012,load,load,1012,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,2,['load'],['load']
Performance,"me extra options in a string; * like ""V:Color:Transformations=I;D;P;U;G:Silent:DrawProgressBar:ModelPersistence:Jobs=2"" where:; * V = verbose output; * Color = coloured screen output; * Silent = batch mode: boolean silent flag inhibiting any output from TMVA; * Transformations = list of transformations to test.; * DrawProgressBar = draw progress bar to display training and testing.; * ModelPersistence = to save the trained model in xml or serialized files.; * Jobs = number of ml methods to test/train in parallel using MultiProc, requires to call Evaluate method.; * Basic example.; * \code; void classification(UInt_t jobs = 2); {; TMVA::Tools::Instance();. TFile *input(0);; TString fname = ""./tmva_class_example.root"";; if (!gSystem->AccessPathName(fname)) {; input = TFile::Open(fname); // check if file in local directory exists; } else {; TFile::SetCacheFileDir(""."");; input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD"");; }; if (!input) {; std::cout << ""ERROR: could not open data file"" << std::endl;; exit(1);; }. // Register the training and test trees. TTree *signalTree = (TTree *)input->Get(""TreeS"");; TTree *background = (TTree *)input->Get(""TreeB"");. TMVA::DataLoader *dataloader = new TMVA::DataLoader(""dataset"");. dataloader->AddVariable(""myvar1 := var1+var2"", 'F');; dataloader->AddVariable(""myvar2 := var1-var2"", ""Expression 2"", """", 'F');; dataloader->AddVariable(""var3"", ""Variable 3"", ""units"", 'F');; dataloader->AddVariable(""var4"", ""Variable 4"", ""units"", 'F');. dataloader->AddSpectator(""spec1 := var1*2"", ""Spectator 1"", ""units"", 'F');; dataloader->AddSpectator(""spec2 := var1*3"", ""Spectator 2"", ""units"", 'F');. // global event weights per tree (see below for setting event-wise weights); Double_t signalWeight = 1.0;; Double_t backgroundWeight = 1.0;. dataloader->SetBackgroundWeightExpression(""weight"");. TMVA::Experimental::Classification *cl = new TMVA::Experimental::Classification(dataloader, Form(""Jobs=%d"", jobs));. cl->BookMethod(TMVA:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Classification.h:1844,CACHE,CACHEREAD,1844,tmva/tmva/inc/TMVA/Classification.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Classification.h,1,['CACHE'],['CACHEREAD']
Performance,"meters of the image superimposition.; * DESCRIPTION; * libAfterImage allows for simultaneous superimposition (overlaying) of; * arbitrary number of images. To facilitate this ASImageLayer structure; * has been created in order to specify parameters of each image; * participating in overlaying operation. Images need not to be exact; * same size. For each image its position on destination is specified; * via dst_x and dst_y data members. Each image maybe tiled and clipped; * to fit into rectangle specified by clip_x, clip_y, clip_width,; * clip_height ( in image coordinates - not destination ). If image is; * missing, then area specified by dst_x, dst_y, clip_width, clip_height; * will be filled with solid_color.; * Entire image will be tinted using tint parameter prior to overlaying.; * Bevel specified by bevel member will be drawn over image prior to; * overlaying. Specific overlay method has to be specified.; * merge_scanlines method is pointer to a function,; * that accepts 2 ASScanlines as arguments and performs overlaying of; * first one with the second one.; * There are 15 different merge_scanline methods implemented in; * libAfterImage, including alpha-blending, tinting, averaging,; * HSV and HSL colorspace operations, etc.; * NOTES; * ASImageLayer s could be organized into chains using next pointers.; * Since there could be a need to rearrange layers and maybe bypass some; * layers - we need to provide for flexibility, while at the same time; * allowing for simplicity of arrays. As the result next pointers could; * be used to link together continuous arrays of layer, like so :; * array1: [layer1(next==NULL)][layer2(next!=NULL)]; * ____________________________|; * V; * array2: [layer3(next==NULL)][layer4(next==NULL)][layer5(next!=NULL)]; * ________________________________________________|; * V; * array3: [layer6(next==NULL)][layer7(next==layer7)]; * ^______|; *; * While iterating throught such a list we check for two conditions -; * exceeding count of layers a",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h:1120,perform,performs,1120,graf2d/asimage/src/libAfterImage/asimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h,1,['perform'],['performs']
Performance,"minated; // after this step, and the code generated would be functionally correct.; //; // If the uses of the source values %1 and %2 are kills, and their; // definitions are predicable, then in the second step, the conditional; // transfers will then be rewritten as predicated instructions. E.g.; // %0 = A2_or %1, %2; // %3 = A2_tfrt %99, killed %0; // will be rewritten as; // %3 = A2_port %99, %1, %2; //; // This replacement has two variants: ""up"" and ""down"". Consider this case:; // %0 = A2_or %1, %2; // ... [intervening instructions] ...; // %3 = A2_tfrt %99, killed %0; // variant ""up"":; // %3 = A2_port %99, %1, %2; // ... [intervening instructions, %0->vreg3] ...; // [deleted]; // variant ""down"":; // [deleted]; // ... [intervening instructions] ...; // %3 = A2_port %99, %1, %2; //; // Both, one or none of these variants may be valid, and checks are made; // to rule out inapplicable variants.; //; // As an additional optimization, before either of the two steps above is; // executed, the pass attempts to coalesce the target register with one of; // the source registers, e.g. given an instruction; // %3 = C2_mux %0, %1, %2; // %3 will be coalesced with either %1 or %2. If this succeeds,; // the instruction would then be (for example); // %3 = C2_mux %0, %3, %2; // and, under certain circumstances, this could result in only one predicated; // instruction:; // %3 = A2_tfrf %0, %2; //; // Splitting a definition of a register into two predicated transfers; // creates a complication in liveness tracking. Live interval computation; // will see both instructions as actual definitions, and will mark the; // first one as dead. The definition is not actually dead, and this; // situation will need to be fixed. For example:; // dead %1 = A2_tfrt ... ; marked as dead; // %1 = A2_tfrf ...; //; // Since any of the individual predicated transfers may end up getting; // removed (in case it is an identity copy), some pre-existing def may; // be marked as dead after live interval re",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:2087,optimiz,optimization,2087,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,1,['optimiz'],['optimization']
Performance,"mplex, multidimensional arrangements of signal and; background bins are managed with the help of the class TUnfoldBinning. If you use this software, please consider the following citation; <br/>; <b>S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]</b>; <br/>; Detailed documentation and updates are available on; http://www.desy.de/~sschmitt. <h3>Brief recipy to use TUnfoldSys:</h3>; <ul>; <li>Set up binning schemes for the truth and measured; distributions. The binning schemes may be coded in the XML language,; for reading use TUnfoldBinningXML.</li>; <li>A matrix (truth,reconstructed) is given as a two-dimensional histogram; as argument to the constructor of TUnfold</li>; <li>A vector of measurements is given as one-dimensional histogram using; the SetInput() method</li>; <li>Repeated calls to SubtractBackground() to specify background; sources</li>; <li>Repeated calls to AddSysError() to specify systematic uncertainties; <li>The unfolding is performed; <ul>; <li>either once with a fixed parameter tau, method DoUnfold(tau)</li>; <li>or multiple times in a scan to determine the best chouce of tau,; method ScanLCurve()</li>; <li>or multiple times in a scan to determine the best chouce of tau,; method ScanTau()</li>; </ul>; <li>Unfolding results are retrieved using various GetXXX() methods; </ul>; A detailed documentation of the various GetXXX() methods to control; systematic uncertainties is given with the method TUnfoldSys. <h3>Why to use complex binning schemes</h3>. in literature on unfolding, the ""standard"" test case is a; one-dimensional distribution without underflow or overflow bins.; The migration matrix is almost diagonal.; <br/>; <b>This ""standard"" case is rarely realized for real problems.</b>; <br/>; Often one has to deal with multi-dimensional distributions.; In addition, there are underflow and overflow bins; or other background bins, possibly determined with the help of auxillary; measurements.; <br/>; In TUnfoldDensity, such complex binning schemes a",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldDensity.cxx:2496,perform,performed,2496,hist/unfold/src/TUnfoldDensity.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldDensity.cxx,1,['perform'],['performed']
Performance,"n LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; * \class RooBinSamplingPdf; * The RooBinSamplingPdf is supposed to be used as an adapter between a continuous PDF; * and a binned distribution.; * When RooFit is used to fit binned data, and the PDF is continuous, it takes the probability density; * at the bin centre as a proxy for the probability averaged (integrated) over the entire bin. This is; * correct only if the second derivative of the function vanishes, though. This is shown in the plots; * below.; *; * For PDFs that have larger curvatures, the RooBinSamplingPdf can be used. It integrates the PDF in each; * bin using an adaptive integrator. This usually requires 21 times more function evaluations, but significantly; * reduces biases due to better sampling of the PDF. The integrator can be accessed from the outside; * using integrator(). This can be used to change the integration rules, so less/more function evaluations are; * performed. The target precision of the integrator can be set in the constructor.; *; *; * ### How to use it; * There are two ways to use this class:; * - Manually wrap a PDF:; * ```; * RooBinSamplingPdf binSampler(""<name>"", ""title"", <binned observable of PDF>, <original PDF> [, <precision for integrator>]);; * binSampler.fitTo(data);; * ```; * When a PDF is wrapped with a RooBinSamplingPDF, just use the bin sampling PDF instead of the original one for fits; * or plotting etc.; * \note The binning will be taken from the observable. Make sure that this binning is the same as the one of the dataset that should be fit.; * Use RooRealVar::setBinning() to adapt it.; * - Instruct test statistics to carry out this wrapping automatically:; * ```; * pdf.fitTo(data, IntegrateBins(<precision>));; * ```; * This method is especially useful when used with a simultaneous PDF, since each component will automatically be wrapped,; * depending on the value of `prec",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx:1617,perform,performed,1617,roofit/roofitcore/src/RooBinSamplingPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx,1,['perform'],['performed']
Performance,"n SGPR; /// number.; ///; /// The initial SGPRs comprise up to 16 User SRGPs that are set up by CP and; /// apply to all waves of the grid. It is possible to specify more than 16 User; /// SGPRs using the enable_sgpr_* bit fields, in which case only the first 16; /// are actually initialized. These are then immediately followed by the System; /// SGPRs that are set up by ADC/SPI and can have different values for each wave; /// of the grid dispatch.; ///; /// SGPR register initial state is defined as follows:; ///; /// Private Segment Buffer (enable_sgpr_private_segment_buffer):; /// Number of User SGPR registers: 4. V# that can be used, together with; /// Scratch Wave Offset as an offset, to access the Private/Spill/Arg; /// segments using a segment address. It must be set as follows:; /// - Base address: of the scratch memory area used by the dispatch. It; /// does not include the scratch wave offset. It will be the per process; /// SH_HIDDEN_PRIVATE_BASE_VMID plus any offset from this dispatch (for; /// example there may be a per pipe offset, or per AQL Queue offset).; /// - Stride + data_format: Element Size * Index Stride (???); /// - Cache swizzle: ???; /// - Swizzle enable: SH_STATIC_MEM_CONFIG.SWIZZLE_ENABLE (must be 1 for; /// scratch); /// - Num records: Flat Scratch Work Item Size / Element Size (???); /// - Dst_sel_*: ???; /// - Num_format: ???; /// - Element_size: SH_STATIC_MEM_CONFIG.ELEMENT_SIZE (will be DWORD, must; /// agree with amd_kernel_code_t.privateElementSize); /// - Index_stride: SH_STATIC_MEM_CONFIG.INDEX_STRIDE (will be 64 as must; /// be number of wavefront lanes for scratch, must agree with; /// amd_kernel_code_t.wavefrontSize); /// - Add tid enable: 1; /// - ATC: from SH_MEM_CONFIG.PRIVATE_ATC,; /// - Hash_enable: ???; /// - Heap: ???; /// - Mtype: from SH_STATIC_MEM_CONFIG.PRIVATE_MTYPE; /// - Type: 0 (a buffer) (???); ///; /// Dispatch Ptr (enable_sgpr_dispatch_ptr):; /// Number of User SGPR registers: 2. 64 bit address of AQL dispatch ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:1836,Queue,Queue,1836,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,1,['Queue'],['Queue']
Performance,"n in that block. This is because the standard RPO; /// algorithm does not track what things have the same value number, it only; /// tracks what the value number of a given operation is (the mapping is; /// operation -> value number). Thus, when a value number of an operation; /// changes, it must reprocess everything to ensure all uses of a value number; /// get updated properly. In constrast, the sparse algorithm we use *also*; /// tracks what operations have a given value number (IE it also tracks the; /// reverse mapping from value number -> operations with that value number), so; /// that it only needs to reprocess the instructions that are affected when; /// something's value number changes. The vast majority of complexity and code; /// in this file is devoted to tracking what value numbers could change for what; /// instructions when various things happen. The rest of the algorithm is; /// devoted to performing symbolic evaluation, forward propagation, and; /// simplification of operations based on the value numbers deduced so far; ///; /// In order to make the GVN mostly-complete, we use a technique derived from; /// ""Detection of Redundant Expressions: A Complete and Polynomial-time; /// Algorithm in SSA"" by R.R. Pai. The source of incompleteness in most SSA; /// based GVN algorithms is related to their inability to detect equivalence; /// between phi of ops (IE phi(a+b, c+d)) and op of phis (phi(a,c) + phi(b, d)).; /// We resolve this issue by generating the equivalent ""phi of ops"" form for; /// each op of phis we see, in a way that only takes polynomial time to resolve.; ///; /// We also do not perform elimination by using any published algorithm. All; /// published algorithms are O(Instructions). Instead, we use a technique that; /// is O(number of operations with the same value number), enabling us to skip; /// trying to eliminate things that have unique value numbers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:2246,perform,performing,2246,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,2,['perform'],"['perform', 'performing']"
Performance,"n integer representing the result index of the; /// comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistri(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The index of the least significant set bit. \n; /// 1: The index of the most significant set bit. \n; /// \returns Returns an integer representing the result index of the comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1609,perform,perform,1609,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,1,['perform'],['perform']
Performance,"n method. Implemented by C. Delaere from the mclimit code written by Tom Junk [HEP-EX/9902006].; See [http://cern.ch/thomasj/searchlimits/ecl.html](http://cern.ch/thomasj/searchlimits/ecl.html) for more details. It takes signal, background and data histograms wrapped in a; TLimitDataSource as input and runs a set of Monte Carlo experiments in; order to compute the limits. If needed, inputs are fluctuated according; to systematics. The output is a TConfidenceLevel. The class TLimitDataSource takes the signal, background and data histograms as well as different; systematics sources to form the TLimit input. The class TConfidenceLevel represents the final result of the TLimit algorithm. It is created just after the; time-consuming part and can be stored in a TFile for further processing.; It contains light methods to return CLs, CLb and other interesting; quantities. The actual algorithm... From an input (TLimitDataSource) it produces an output TConfidenceLevel.; For this, nmc Monte Carlo experiments are performed.; As usual, the larger this number, the longer the compute time,; but the better the result. Supposing that there is a plotfile.root file containing 3 histograms; (signal, background and data), you can imagine doing things like:. ~~~{.cpp}; TFile* infile=new TFile(""plotfile.root"",""READ"");; infile->cd();; TH1* sh=(TH1*)infile->Get(""signal"");; TH1* bh=(TH1*)infile->Get(""background"");; TH1* dh=(TH1*)infile->Get(""data"");; TLimitDataSource* mydatasource = new TLimitDataSource(sh,bh,dh);; TConfidenceLevel *myconfidence = TLimit::ComputeLimit(mydatasource,50000);; std::cout << "" CLs : "" << myconfidence->CLs() << std::endl;; std::cout << "" CLsb : "" << myconfidence->CLsb() << std::endl;; std::cout << "" CLb : "" << myconfidence->CLb() << std::endl;; std::cout << ""< CLs > : "" << myconfidence->GetExpectedCLs_b() << std::endl;; std::cout << ""< CLsb > : "" << myconfidence->GetExpectedCLsb_b() << std::endl;; std::cout << ""< CLb > : "" << myconfidence->GetExpectedCLb_b() << std",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx:2172,perform,performed,2172,hist/hist/src/TLimit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx,1,['perform'],['performed']
Performance,"n number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; ~~~ {.cpp}; MSB <---; Version 4-Bit Code Description; ------------------------------------------------------------; | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value; ------------------------------------------------------------; ~~~. ## Clock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicated UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. ## Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, and; then added to the UTC time field of the UUID. ## Clock Overrun. The 100-nanosecond granularity of time should prove sufficient; even for bursts of UUID production in the next generation of; high-performance multiprocessors. If a system overruns the; clock adjustment by requesting too many UUIDs within a single; system clock tick, the UUID generator will stall until the; system clock catches up.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUUID.cxx:4201,perform,performance,4201,core/base/src/TUUID.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUUID.cxx,1,['perform'],['performance']
Performance,"n the ""tail position"" (i.e. the immediate; /// predecessor of a ReturnInst instruction).; ///; /// Since the sibling call optimization causes the callee to reuse the caller's; /// stack, if we could delay the generation of the stack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point were not true, the decision on whether to; /// perform a tail call is done in LowerCallTo in SelectionDAG (or; /// CallLowering in GlobalISel) which occurs after the Stack Protector; /// Pass. As a result, one would need to put the relevant callinst into the; /// stack protector check success basic block (where the return inst is; /// placed) and then move it back later at ISel/MI time before the; /// stack protector check if the tail call optimization failed. The MI; /// level option was nixed immediately since it would require; /// platform-specific pattern matching. The ISel level option was; /// nixed because SelectionDAG only processes one IR level basic block at a; /// time implying one could not create a DAG Combine to move the callinst.; ///; /// To get around this problem:; ///; /// 1. SelectionDAG can only process one block at a tim",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:1781,perform,perform,1781,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,1,['perform'],['perform']
Performance,"n to provide; /// more precise answers to certain TTI queries, while letting the target; /// independent and default TTI implementations handle the rest.; ///; //===----------------------------------------------------------------------===//; /// About Cost Model numbers used below it's necessary to say the following:; /// the numbers correspond to some ""generic"" X86 CPU instead of usage of a; /// specific CPU model. Usually the numbers correspond to the CPU where the; /// feature first appeared. For example, if we do Subtarget.hasSSE42() in; /// the lookups below the cost is based on Nehalem as that was the first CPU; /// to support that feature level and thus has most likely the worst case cost,; /// although we may discard an outlying worst cost from one CPU (e.g. Atom).; ///; /// Some examples of other technologies/CPUs:; /// SSE 3 - Pentium4 / Athlon64; /// SSE 4.1 - Penryn; /// SSE 4.2 - Nehalem / Silvermont; /// AVX - Sandy Bridge / Jaguar / Bulldozer; /// AVX2 - Haswell / Ryzen; /// AVX-512 - Xeon Phi / Skylake; ///; /// And some examples of instruction target dependent costs (latency); /// divss sqrtss rsqrtss; /// AMD K7 11-16 19 3; /// Piledriver 9-24 13-15 5; /// Jaguar 14 16 2; /// Pentium II,III 18 30 2; /// Nehalem 7-14 7-18 3; /// Haswell 10-13 11 5; ///; /// Interpreting the 4 TargetCostKind types:; /// TCK_RecipThroughput and TCK_Latency should try to match the worst case; /// values reported by the CPU scheduler models (and llvm-mca).; /// TCK_CodeSize should match the instruction count (e.g. divss = 1), NOT the; /// actual encoding size of the instruction.; /// TCK_SizeAndLatency should match the worst case micro-op counts reported by; /// by the CPU scheduler models (and llvm-mca), to ensure that they are; /// compatible with the MicroOpBufferSize and LoopMicroOpBufferSize values which are; /// often used as the cost thresholds where TCK_SizeAndLatency is requested.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:1630,latency,latency,1630,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['latency'],['latency']
Performance,"n with a step at the 2|0 boundary, which causes; /// artifacts in Fourier space.; ///; /// The spillover or discontinuity can be reduced or eliminated by; /// introducing a buffer zone in the FFT calculation. If this feature is activated (on by default),; /// the sampling array for the FFT calculation is extended in both directions,; /// and padded with the lowest/highest bin.; /// Example:; /// ```; /// original: -5 -4 -3 -2 -1 0 +1 +2 +3 +4 +5; /// add buffer zones: U U -5 -4 -3 -2 -1 0 +1 +2 +3 +4 +5 O O; /// rotate: 0 +1 +2 +3 +4 +5 O O U U -5 -4 -3 -2 -1; /// ```; /// The buffer bins are stripped away when the FFT output values; /// are transferred back to the p.d.f cache. The default buffer size is 10% of the; /// observable domain size, and can be changed with the `setBufferFraction()` member function.; ///; /// The RooFFTConvPdf uses caching inherited from a RooAbsCachedPdf. If it is; /// evaluated for a particular value of x, the FFT and convolution is calculated; /// for all bins in the observable space for the given choice of parameters,; /// which are also stored in the cache. Subsequent evaluations for different values of the convolution observable and; /// identical parameters will be retrieved from the cache. If one or more; /// of the parameters change, the cache will be updated, *i.e.*, a new FFT runs.; ///; /// The sampling density of the FFT is controlled by the binning of the; /// the convolution observable, which can be changed using RooRealVar::setBins(N).; /// For good results, N should be large (>=1000). Additional interpolation; /// between the bins may improve the result if coarse binnings are chosen. These can be; /// activated in the constructor or by calling `setInterpolationOrder()`.; /// For N >> 1000, interpolation will not substantially improve the accuracy.; ///; /// Additionial information on caching can be displayed by monitoring; /// the message stream with topic ""Caching"" at the INFO level, *i.e.*; /// by calling `RooMsgService:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:3144,cache,cache,3144,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['cache'],['cache']
Performance,"n.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the implementation of the FastISel class.; //; // ""Fast"" instruction selection is designed to emit very poor code quickly.; // Also, it is not designed to be able to do much lowering, so most illegal; // types (e.g. i64 on 32-bit targets) and operations are not supported. It is; // also not intended to be able to do much optimization, except in a few cases; // where doing optimizations reduces overall compile time. For example, folding; // constants into immediate fields is often done, because it's cheap and it; // reduces the number of instructions later phases have to examine.; //; // ""Fast"" instruction selection is able to fail gracefully and transfer; // control to the SelectionDAG selector for operations that it doesn't; // support. In many cases, this allows us to avoid duplicating a lot of; // the complicated lowering logic that SelectionDAG currently has.; //; // The intended use for ""fast"" instruction selection is ""-O0"" mode; // compilation, where the quality of the generated code is irrelevant when; // weighed against the speed at which the code can be generated. Also,; // at -O0, the LLVM optimizers are not running, and this makes the; // compile time of codegen a much higher portion of the overall compile; // time. Despite its limitations, ""fast"" instruction selection is able to; // handle enough code on its own to provide noticeable overall speedups; // in -O0 compiles.; //; // Basic operations are supported in a target-independent way, by reading; // the same instruction descriptions that the SelectionDAG selector reads,; // and identifying simple arithmetic operations that can be directly selected; // from simple operators. More complicated operations currently require; // target-specific code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp:1519,optimiz,optimizers,1519,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,1,['optimiz'],['optimizers']
Performance,"ncomplete: An incomplete TypeString;; /// IncompleteUsed: An incomplete TypeString that has been used in a; /// Recursive type encoding.; ///; /// A NonRecursive entry will have all of its sub-members expanded as fully; /// as possible. Whilst it may contain types which are recursive, the type; /// itself is not recursive and thus its encoding may be safely used whenever; /// the type is encountered.; ///; /// A Recursive entry will have all of its sub-members expanded as fully as; /// possible. The type itself is recursive and it may contain other types which; /// are recursive. The Recursive encoding must not be used during the expansion; /// of a recursive type's recursive branch. For simplicity the code uses; /// IncompleteCount to reject all usage of Recursive encodings for member types.; ///; /// An Incomplete entry is always a RecordType and only encodes its; /// identifier e.g. ""s(S){}"". Incomplete 'StubEnc' entries are ephemeral and; /// are placed into the cache during type expansion as a means to identify and; /// handle recursive inclusion of types as sub-members. If there is recursion; /// the entry becomes IncompleteUsed.; ///; /// During the expansion of a RecordType's members:; ///; /// If the cache contains a NonRecursive encoding for the member type, the; /// cached encoding is used;; ///; /// If the cache contains a Recursive encoding for the member type, the; /// cached encoding is 'Swapped' out, as it may be incorrect, and...; ///; /// If the member is a RecordType, an Incomplete encoding is placed into the; /// cache to break potential recursive inclusion of itself as a sub-member;; ///; /// Once a member RecordType has been expanded, its temporary incomplete; /// entry is removed from the cache. If a Recursive encoding was swapped out; /// it is swapped back in;; ///; /// If an incomplete entry is used to expand a sub-member, the incomplete; /// entry is marked as IncompleteUsed. The cache keeps count of how many; /// IncompleteUsed entries it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp:1362,cache,cache,1362,interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,1,['cache'],['cache']
Performance,"nctional expression by specifying; the powers of each variable in \f$ L\f$ specified functions \f$ F_1, \ldots,F_L\f$ (TMultiDimFit::SetPowers).; In that case, only the coefficients \f$ c_l\f$ is calculated by the class. ## Limiting the Number of Terms; As always when dealing with fits, there's a real chance of *over fitting*. As is well-known, it's; always possible to fit an \f$ N-1\f$ polynomial in \f$ x\f$ to \f$ N\f$ points \f$ (x,y)\f$ with; \f$\chi^2 = 0\f$, but the polynomial is not likely to fit new data at all [1].; Therefore, the user is asked to provide an upper limit, \f$ L_{max}\f$ to the number of terms in; \f$ D_p\f$ (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of \f$ F_l\f$ to choose from, the; user is asked to give the maximum power. \f$ P_{max,i}\f$, of each variable; \f$ x_i\f$ to be considered in the minimization of \f$ S\f$ (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable \f$ i\f$, is; to perform a regular fit to the dependent quantity \f$ D\f$, using a; polynomial only in \f$ x_i\f$. The maximum power is \f$ P_{max,i}\f$ is then the; power that does not significantly improve the one-dimensional; least-square fit over \f$ x_i\f$ to \f$ D\f$ [5]. There are still a huge amount of possible choices for \f$ F_l\f$; in fact; there are \f$\prod_{i=1}^{N} (P_{max,i} + 1)\f$ possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a *power control limit*, \f$ Q\f$ (TMultiDimFit::SetPowerLimit), and a function; \f$ F_l\f$ is only accepted if; \f[; Q_l = \sum_{i=1}^{N} \frac{P_{li}}{P_{max,i}} < Q; \f]; where \f$ P_{li}\f$ is the leading power of variable \f$ x_i\f$ in function \f$ F_l\f$ (TMultiDimFit::MakeCandidates).; So the number of functions increase with \f$ Q\f$ (1, 2 is fine, 5 is way out). ## Gram-Schmidt Orthogonalisation; To further reduce the number of functions in the final expression,; only those functions that significantly reduce \f$ S\f$ ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:4603,perform,perform,4603,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['perform'],['perform']
Performance,"nd TSelector::GetStatus() in; /// in case of success.; ///; /// The code in filename is loaded (interpreted or compiled, see below),; /// filename must contain a valid class implementation derived from TSelector,; /// where TSelector has the following member functions:; ///; /// - `Begin()`: called every time a loop on the tree starts,; /// a convenient place to create your histograms.; /// - `SlaveBegin()`: called after Begin(), when on PROOF called only on the; /// slave servers.; /// - `Process()`: called for each event, in this function you decide what; /// to read and fill your histograms.; /// - `SlaveTerminate`: called at the end of the loop on the tree, when on PROOF; /// called only on the slave servers.; /// - `Terminate()`: called at the end of the loop on the tree,; /// a convenient place to draw/fit your histograms.; ///; /// If filename is of the form file.C, the file will be interpreted.; ///; /// If filename is of the form file.C++, the file file.C will be compiled; /// and dynamically loaded.; ///; /// If filename is of the form file.C+, the file file.C will be compiled; /// and dynamically loaded. At next call, if file.C is older than file.o; /// and file.so, the file.C is not compiled, only file.so is loaded.; ///; /// ## NOTE1; ///; /// It may be more interesting to invoke directly the other Process function; /// accepting a TSelector* as argument.eg; /// ~~~ {.cpp}; /// MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; /// selector->CallSomeFunction(..);; /// mytree.Process(selector,..);; /// ~~~; /// ## NOTE2; //; /// One should not call this function twice with the same selector file; /// in the same script. If this is required, proceed as indicated in NOTE1,; /// by getting a pointer to the corresponding TSelector,eg; ///; /// ### Workaround 1; ///; /// ~~~ {.cpp}; /// void stubs1() {; /// TSelector *selector = TSelector::GetSelector(""h1test.C"");; /// TFile *f1 = new TFile(""stubs_nood_le1.root"");; /// TTree *h1 = (TTree*)f",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1223,load,loaded,1223,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['load'],['loaded']
Performance,"nd \f$\textbf{D}\f$ is smaller than; an upper limit \f$ \phi \f$, defined by the user (MultiDimFit::SetMaxAngle). However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of \f$ S\f$ are chosen first; (TMultiDimFit::TestFunction). In case \f$ \phi \f$ isn't defined, an alternative method of; performing this second test is used: The \f$L^{\mbox{th}}\f$; function \f$\textbf{f}_L\f$ is accepted if (refer also to equation (13)); \f[; \Delta S_L > \frac{S_{L-1}}{L_{max}-L}; \f]; where \f$ S_{L-1}\f$ is the sum of the \f$ L-1\f$ first residuals from the; \f$ L-1\f$ functions previously accepted; and \f$ L_{max}\f$ is the total number; of functions allowed in the final expression of the fit (defined by; user). From this we see, that by restricting \f$ L_{max}\f$ -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting. The more coefficients we evaluate, the more the sum of squares of; residuals \f$ S\f$ will be reduced. We can evaluate \f$ S\f$ before inverting; \f$\mathsf{B}\f$ as shown below. ## Coefficients and Coefficient Errors; Having found a parameterization, that is the \f$ F_l\f$'s and \f$ L\f$, that; minimizes \f$ S\f$, we still need to determine the coefficients; \f$ c_l\f$. However, it's a feature of how we choose the significant; functions, that the evaluation of the \f$ c_l\f$'s becomes trivial [5]. To derive; \f$\mathbf{c}\f$, we first note that; equation (4) can be written as; \f[; \mathsf{F} = \mathsf{W}\mathsf{B}; \f]; where; \f{eqnarray*}{; b_{ij} = \frac{\mathbf{f}_j \bullet \mathbf{w}_i}{\mathbf{w}_i^2}; & \mbox{if} & i < j\\; 1 & \mbox{if} & i = j\\; 0 & \mbox{if} & i > j; \f}; Consequently, \f$\mathsf{B}\f$ is an upper triangle matrix, which can be; readily inverted. So we now evalua",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:11802,perform,perform,11802,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['perform'],['perform']
Performance,"nd f2 are always taken; to be end the end-points of the parameter alpha, regardless of what; the those numeric values are. Since the value of fbar(x) cannot be easily calculated for a given value; of x, class RooIntegralMorph is an implementation of RooAbsCachedPdf and; calculates the shape of the interpolated p.d.f. fbar(x) for all values; of x for a given value of alpha,p,q and caches these values in a histogram; (as implemented by RooAbsCachedPdf). The binning granularity of the cache; can be controlled by the binning named ""cache"" on the RooRealVar representing; the observable x. The fbar sampling algorithm is based on a recursive division; mechanism with a built-in precision cutoff: First an initial sampling in; 64 equally spaced bins is made. Then the value of fbar is calculated in; the center of each gap. If the calculated value deviates too much from; the value obtained by linear interpolation from the edge bins, gap; is recursively divided. This strategy makes it possible to define a very; fine cache sampling (e.g. 1000 or 10000) bins without incurring a; corresponding CPU penalty. Note on numeric stability of the algorithm. Since the algorithm relies; on a numeric inversion of cumulative distributions functions, some precision; may be lost at the 'edges' of the same (i.e. at regions in x where the; c.d.f. value is close to zero or one). The general sampling strategy is; to start with 64 equally spaces samples in the range y=(0.01-0.99).; Then the y ranges are pushed outward by reducing y (or the distance of y to 1.0); by a factor of sqrt(10) iteratively up to the point where the corresponding; x value no longer changes significantly. For p.d.f.s with very flat tails; such as Gaussians some part of the tail may be lost due to limitations; in numeric precision in the CDF inversion step. An effect related to the above limitation in numeric precision should; be anticipated when floating the alpha parameter in a fit. If a p.d.f; with such flat tails is fitted, ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx:2392,cache,cache,2392,roofit/roofit/src/RooIntegralMorph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx,1,['cache'],['cache']
Performance,"nd will return when it gets to; the end of that block, or when it runs out of data. The Z_BLOCK option assists in appending to or combining deflate streams.; Also to assist in this, on return inflate() will set strm->data_type to the; number of unused bits in the last byte taken from strm->next_in, plus 64; if inflate() is currently decoding the last block in the deflate stream,; plus 128 if inflate() returned immediately after decoding an end-of-block; code or decoding the complete header up to just before the first byte of the; deflate stream. The end-of-block will not be indicated until all of the; uncompressed data from that block has been written to strm->next_out. The; number of unused bits may in general be greater than seven, except when; bit 7 of data_type is set, in which case the number of unused bits will be; less than eight. inflate() should normally be called until it returns Z_STREAM_END or an; error. However if all decompression is to be performed in a single step; (a single call of inflate), the parameter flush should be set to; Z_FINISH. In this case all pending input is processed and all pending; output is flushed; avail_out must be large enough to hold all the; uncompressed data. (The size of the uncompressed data may have been saved; by the compressor for this purpose.) The next operation on this stream must; be inflateEnd to deallocate the decompression state. The use of Z_FINISH; is never required, but can be used to inform inflate that a faster approach; may be used for the single inflate() call. In this implementation, inflate() always flushes as much output as; possible to the output buffer, and always uses the faster approach on the; first call. So the only effect of the flush parameter in this implementation; is on the return value of inflate(), as noted below, or when it returns early; because Z_BLOCK is used. If a preset dictionary is needed after this call (see inflateSetDictionary; below), inflate sets strm->adler to the adler32 check",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:2867,perform,performed,2867,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['perform'],['performed']
Performance,"nder the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %s.sink = phi [%st, if.then], [%se, if.else];",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1106,optimiz,optimization,1106,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,1,['optimiz'],['optimization']
Performance,"ndidates is updated to; // hold Z fr A, the RegisterMap is updated to hold Z for %3, and the InstrMap; // is updated to have Z mapped to %3. This is again because Z describes the; // debug variable A, Y is not updated to have $noreg as first operand because; // its first operand is an immediate, not a register.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // -> %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // Nothing happens here since the RegisterMap for %2 contains no value.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // -> %3 = ld ...; // %4 = ld ...; // Since the RegisterMap contains Z as a value for %3, the MachineInstr; // pointer Z is copied to come after the load for %3 and the old Z's first; // operand is changed to $noreg the Basic Block iterator is moved to after the; // DBG_VALUE Z's new position.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE $noreg, A, ..., # Old Z; // %2 = ld ...; // %3 = ld ...; // DBG_VALUE %3, A, ..., # Z; // -> %4 = ld ...; // Nothing happens for %4 and the algorithm exits having processed the entire; // Basic Block.; // DbgValueSinkCandidates = {A -> {Z}}, RegisterMap = {2 -> {}, 3 -> {Z}},; // InstrMap = {X -> 2, Z -> 3}; // DBG_VALUE $noreg, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE $noreg, A, ..., # Old Z; // %2 = ld ...; // %3 = ld ...; // DBG_VALUE %3, A, ..., # Z; // %4 = ld ...; // This map is used to track the relationship between; // a Debug Variable and the DBG_VALUE MachineInstr pointer that describes the; // debug information for that Debug Variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:4343,load,load,4343,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['load'],['load']
Performance,"ndow + cur_match; //s0; * if (*(ushf*)(match+best_len-1) != scan_end || //s1; * *(ushf*)match != scan_start) continue; //s2; * ...; *; * do {; * } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&; * *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&; * *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&; * *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&; * scan < strend); //s3; *; * ...; * } while(cond); //s4; *; * -------------------------------------------------------------; *; * The change include:; *; * 1) The hottest statements of the function is: s0, s1 and s4. Pull them; * together to form a new loop. The benefit is two-fold:; *; * o. Ease the compiler to yield good code layout: the conditional-branch; * corresponding to s1 and its biased target s4 become very close (likely,; * fit in the same cache-line), hence improving instruction-fetching; * efficiency.; *; * o. Ease the compiler to promote ""s->window"" into register. ""s->window""; * is loop-invariant; it is supposed to be promoted into register and keep; * the value throughout the entire loop. However, there are many such; * loop-invariant, and x86-family has small register file; ""s->window"" is; * likely to be chosen as register-allocation victim such that its value; * is reloaded from memory in every single iteration. By forming a new loop,; * ""s->window"" is loop-invariant of that newly created tight loop. It is; * lot easier for compiler to promote this quantity to register and keep; * its value throughout the entire small loop.; *; * 2) Transfrom s3 such that it examines sizeof(long)-byte-match at a time.; * This is done by:; * ------------------------------------------------; * v1 = load from ""scan"" by sizeof(long) bytes; * v2 = load from ""match"" by sizeof(lnog) bytes; * v3 = v1 xor v2; * match-bit = little-endian-machine(yes-for-x86) ?; * count-trailing-zero(v3) :; * count-leading-zero(v3);; *; * match-byte = match-bit/8; *; * ""scan"" and ""match"" advance if necessary; * -------------------------------------------------; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate_cf.c:2003,load,load,2003,builtins/zlib/deflate_cf.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate_cf.c,2,['load'],['load']
Performance,"ne Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //________________________________________________________________________; //; // Class for xml code generation; // It should be used for generation of xml streamers, which could be used outside root; // environment. This means, that with help of such streamers user can read and write; // objects from/to xml file, which later can be accepted by ROOT.; //; // At the moment supported only classes, which are not inherited from TObject; // and which not contains any TObject members.; //; // To generate xml code:; //; // 1. ROOT library with required classes should be created.; // In general, without such library non of user objects can be stored and; // retrieved from any ROOT file; //; // 2. Generate xml streamers by root script like:; //; // void generate() {; // gSystem->Load(""libRXML.so""); // load ROOT xml library; // gSystem->Load(""libuser.so""); // load user ROOT library; //; // TList lst;; // lst.Add(TClass::GetClass(""TUserClass1""));; // lst.Add(TClass::GetClass(""TUserClass2""));; // ...; // TXMLPlayer player;; // player.ProduceCode(&lst, ""streamers""); // create xml streamers; // }; //; // 3. Copy ""streamers.h"", ""streamers.cxx"", ""TXmlFile.h"", ""TXmlFile.cxx"" files; // to user project and compile them. TXmlFile class implementation can be taken; // from http://web-docs.gsi.de/~linev/xmlfile.tar.gz; //; // TXMLPlayer class generates one function per class, which called class streamer.; // Name of such function for class TExample will be TExample_streamer.; //; // Following data members for streamed classes are supported:; // - simple data types (int, double, float); // - array of simple types (int[5], double[5][6]); // - dynamic array of simple types (int* with comment field // [fSize]); // - const char*; // - object o",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/xml/src/TXMLPlayer.cxx:1209,Load,Load,1209,io/xml/src/TXMLPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/xml/src/TXMLPlayer.cxx,1,['Load'],['Load']
Performance,"needs to use the same flags status as the conditional branch.; // This means that the conditional branches must not be implemented as one; // of the AArch64 conditional branches that do not use the flags as input; // (CB(N)Z and TB(N)Z). This is implemented by ensuring in the instruction; // selectors to not produce these instructions when speculation hardening; // is enabled. This pass will assert if it does encounter such an instruction.; // - On function call boundaries, the miss-speculation state is transferred from; // the taint register X16 to be encoded in the SP register as value 0.; //; // For the aspect of automatically hardening loads, using the taint register,; // (a.k.a. speculative load hardening, see; // https://llvm.org/docs/SpeculativeLoadHardening.html), the following; // implementation choices are made for AArch64:; // - Many of the optimizations described at; // https://llvm.org/docs/SpeculativeLoadHardening.html to harden fewer; // loads haven't been implemented yet - but for some of them there are; // FIXMEs in the code.; // - loads that load into general purpose (X or W) registers get hardened by; // masking the loaded data. For loads that load into other registers, the; // address loaded from gets hardened. It is expected that hardening the; // loaded data may be more efficient; but masking data in registers other; // than X or W is not easy and may result in being slower than just; // hardening the X address register loaded from.; // - On AArch64, CSDB instructions are inserted between the masking of the; // register and its first use, to ensure there's no non-control-flow; // speculation that might undermine the hardening mechanism.; //; // Future extensions/improvements could be:; // - Implement this functionality using full speculation barriers, akin to the; // x86-slh-lfence option. This may be more useful for the intrinsics-based; // approach than for the SLH approach to masking.; // Note that this pass already inserts the full speculat",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:4357,load,loads,4357,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,1,['load'],['loads']
Performance,"neral goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced into the call; /// graph by devirtualization or other technique, and thus ensures that; /// subsequent pair-wise interprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reachability used by the reference graph is a conservative approximation; /// that still allows us to have independent regions of the graph.; ///; /// FIXME: There is one major drawback of the reference graph: in its naive; /// form it is quadratic because it contains a distinct edge for each; /// (potentially indirect) reference, even if are all through some common; /// global table of function pointers. This can be fixed in a number of ways; /// that essentially preserve enough of the normalization. While it isn't; /// expected to completely preclude the usability of this, it will need to be; /// addressed.; ///; ///; /// All of these issues are made substantially more complex in the face of; /// mutations to the call graph while optimization passes are being run. When; /// mutations to the call grap",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:1952,optimiz,optimize,1952,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,3,['optimiz'],"['optimizations', 'optimize', 'optimized']"
Performance,"nformation about the data, retrieve (thread-local) readers or ""cursors""; for selected columns and to advance the readers to the desired data entry. The sequence of calls that RDataFrame (or any other client of a RDataSource) performs is the following:. - SetNSlots() : inform RDataSource of the desired level of parallelism; - GetColumnReaders() : retrieve from RDataSource per-thread readers for the desired columns; - Initialize() : inform RDataSource that an event-loop is about to start; - GetEntryRanges() : retrieve from RDataSource a set of ranges of entries that can be processed concurrently; - InitSlot() : inform RDataSource that a certain thread is about to start working on a certain range of entries; - SetEntry() : inform RDataSource that a certain thread is about to start working on a certain entry; - FinalizeSlot() : inform RDataSource that a certain thread finished working on a certain range of entries; - Finalize() : inform RDataSource that an event-loop finished. RDataSource implementations must support running multiple event-loops consecutively (although sequentially) on the same dataset.; - \b SetNSlots() is called once per RDataSource object, typically when it is associated to a RDataFrame.; - \b GetColumnReaders() can be called several times, potentially with the same arguments, also in-between event-loops, but not during an event-loop.; - \b GetEntryRanges() will be called several times, including during an event loop, as additional ranges are needed. It will not be called concurrently.; - \b Initialize() and \b Finalize() are called once per event-loop, right before starting and right after finishing.; - \b InitSlot(), \b SetEntry(), and \b FinalizeSlot() can be called concurrently from multiple threads, multiple times per event-loop. Advanced users that plan to implement a custom RDataSource can check out existing implementations, e.g. RCsvDS or RNTupleDS.; See the inheritance diagram below for the full list of existing concrete implementations.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx:1943,concurren,concurrently,1943,tree/dataframe/inc/ROOT/RDataSource.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx,2,['concurren'],['concurrently']
Performance,"ng method; /// `isReady()`.; /// To emulate a write-combining memory type, rule 2. must be relaxed in a; /// derived class to enable the reordering of non-aliasing store operations.; ///; /// No assumptions are made by this class on the size of the store buffer. This; /// class doesn't know how to identify cases where store-to-load forwarding may; /// occur.; ///; /// LSUnit doesn't attempt to predict whether a load or store hits or misses; /// the L1 cache. To be more specific, LSUnit doesn't know anything about; /// cache hierarchy and memory types.; /// It only knows if an instruction ""mayLoad"" and/or ""mayStore"". For loads, the; /// scheduling model provides an ""optimistic"" load-to-use latency (which usually; /// matches the load-to-use latency for when there is a hit in the L1D).; /// Derived classes may expand this knowledge.; ///; /// Class MCInstrDesc in LLVM doesn't know about serializing operations, nor; /// memory-barrier like instructions.; /// LSUnit conservatively assumes that an instruction which `mayLoad` and has; /// `unmodeled side effects` behave like a ""soft"" load-barrier. That means, it; /// serializes loads without forcing a flush of the load queue.; /// Similarly, instructions that both `mayStore` and have `unmodeled side; /// effects` are treated like store barriers. A full memory; /// barrier is a 'mayLoad' and 'mayStore' instruction with unmodeled side; /// effects. This is obviously inaccurate, but this is the best that we can do; /// at the moment.; ///; /// Each load/store barrier consumes one entry in the load/store queue. A; /// load/store barrier enforces ordering of loads/stores:; /// - A younger load cannot pass a load barrier.; /// - A younger store cannot pass a store barrier.; ///; /// A younger load has to wait for the memory load barrier to execute.; /// A load/store barrier is ""executed"" when it becomes the oldest entry in; /// the load/store queue(s). That also means, all the older loads/stores have; /// already been executed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:2393,load,load-barrier,2393,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,17,"['load', 'queue']","['load', 'load-barrier', 'loads', 'queue']"
Performance,"ng the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. ~~~ {.cpp}; MASTER = T * LOCAL; ~~~. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embedding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication. Rotation: Inverse rotation:. ~~~ {.cpp}; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1; ~~~. Translation: Inverse translation:. ~~~ {.cpp}; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1; ~~~. Scale: Inverse scale:. ~~~ {.cpp}; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1; ~~~. where:; - `rij` are the 3x3 rotation matrix components,; - `tx`, `ty`, `tz` are the translation components; - `sx`, `sy`, `sz` are arbitrary scale constants on each axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen t",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMatrix.cxx:1887,perform,performed,1887,geom/geom/src/TGeoMatrix.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMatrix.cxx,1,['perform'],['performed']
Performance,"nity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global address space. In the IR level,; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // ; use %b; // }; //; // becomes; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // %b_global = addrspacecast i32* %b to i32 addrspace(1)*; // %b_generic = addrspacecast i32 addrspace(1)* %b_global to i32*; // ; use %b_generic; // }; //; // TODO: merge this pass with NVPTXInferAddressSpaces so that other passes don't; // cancel the addrspacecast pair this pass emits.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:2588,load,load,2588,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,2,['load'],['load']
Performance,"not recursive and thus its encoding may be safely used whenever; /// the type is encountered.; ///; /// A Recursive entry will have all of its sub-members expanded as fully as; /// possible. The type itself is recursive and it may contain other types which; /// are recursive. The Recursive encoding must not be used during the expansion; /// of a recursive type's recursive branch. For simplicity the code uses; /// IncompleteCount to reject all usage of Recursive encodings for member types.; ///; /// An Incomplete entry is always a RecordType and only encodes its; /// identifier e.g. ""s(S){}"". Incomplete 'StubEnc' entries are ephemeral and; /// are placed into the cache during type expansion as a means to identify and; /// handle recursive inclusion of types as sub-members. If there is recursion; /// the entry becomes IncompleteUsed.; ///; /// During the expansion of a RecordType's members:; ///; /// If the cache contains a NonRecursive encoding for the member type, the; /// cached encoding is used;; ///; /// If the cache contains a Recursive encoding for the member type, the; /// cached encoding is 'Swapped' out, as it may be incorrect, and...; ///; /// If the member is a RecordType, an Incomplete encoding is placed into the; /// cache to break potential recursive inclusion of itself as a sub-member;; ///; /// Once a member RecordType has been expanded, its temporary incomplete; /// entry is removed from the cache. If a Recursive encoding was swapped out; /// it is swapped back in;; ///; /// If an incomplete entry is used to expand a sub-member, the incomplete; /// entry is marked as IncompleteUsed. The cache keeps count of how many; /// IncompleteUsed entries it currently contains in IncompleteUsedCount;; ///; /// If a member's encoding is found to be a NonRecursive or Recursive viz:; /// IncompleteUsedCount==0, the member's encoding is added to the cache.; /// Else the member is part of a recursive type and thus the recursion has; /// been exited too soon for the en",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp:1610,cache,cache,1610,interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,4,['cache'],"['cache', 'cached']"
Performance,"nput a pointer to the fitted parameter values; /// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; /// previously performed fit using the TFitResult class.; /// Note that to get the TFitResult, te fit should be done using the fit option `S`.; /// Example:; /// ~~~~{.cpp}; /// TFitResultPtr r = histo2d->Fit(func2, ""S"");; /// func2->IntegralError(a,b,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; /// ~~~~; ///; /// IMPORTANT NOTE1:; ///; /// A null pointer to the parameter values vector and to the covariance matrix can be passed.; /// In this case, when the parameter values pointer is null, the parameter values stored in this; /// TF1 function object are used in the integral error computation.; /// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; /// from a global fitter instance when it exists. Note that the global fitter instance; /// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; /// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; /// returned.; ///; ///; /// IMPORTANT NOTE2:; ///; /// When no covariance matrix is passed and in the meantime a fit is done; /// using another function, the routine will signal an error and it will return zero only; /// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; /// In the case that npar is the same, an incorrect result is returned.; ///; /// IMPORTANT NOTE3:; ///; /// The user must pass a pointer to the elements of the full covariance matrix; /// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; /// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; /// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1446,multi-thread,multi-threading,1446,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['multi-thread'],['multi-threading']
Performance,"nstruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific input used.; // - Finding/confirming poison specific miscompiles by checking the poison; // status of an input/IR pair is the same before and after an optimization; // transform.; // - Checking that a bugpoint reduction does not introduce UB which didn't; // exist in the original program being reduced.; //; // The major sources of inaccuracy are currently:; // - Most validation rules not yet implemented for instructions with poison; // relavant flags. At the moment, only nsw/nuw on add/sub are supported.; // - UB which is control dependent on a branch on poison is not yet; // reported. Currently, only data flow dependence is modeled.; // - Poison which is propagated through memory is not modeled. As such,; // storing poison to memory and then reloading it will cause a false negative; // as we consider the reloaded value to not be poisoned.; // - Poison propagation across function boundaries is not modeled. At the; // moment, all arguments and return values are assumed not to be poison.; // - Undef is not modeled. In particular, the optimizer's freedom to pick; // concrete values for undef bits so as to maximize potential for producing; // poison is not modeled.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:3045,optimiz,optimizer,3045,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,1,['optimiz'],['optimizer']
Performance,"nstructions with close by immediate offsets.; // This will fuse operations such as; // ds_read_b32 v0, v2 offset:16; // ds_read_b32 v1, v2 offset:32; // ==>; // ds_read2_b32 v[0:1], v2, offset0:4 offset1:8; //; // The same is done for certain SMEM and VMEM opcodes, e.g.:; // s_buffer_load_dword s4, s[0:3], 4; // s_buffer_load_dword s5, s[0:3], 8; // ==>; // s_buffer_load_dwordx2 s[4:5], s[0:3], 4; //; // This pass also tries to promote constant offset to the immediate by; // adjusting the base. It tries to use a base from the nearby instructions that; // allows it to have a 13bit constant offset and then promotes the 13bit offset; // to the immediate.; // E.g.; // s_movk_i32 s0, 0x1800; // v_add_co_u32_e32 v0, vcc, s0, v2; // v_addc_co_u32_e32 v1, vcc, 0, v6, vcc; //; // s_movk_i32 s0, 0x1000; // v_add_co_u32_e32 v5, vcc, s0, v2; // v_addc_co_u32_e32 v6, vcc, 0, v6, vcc; // global_load_dwordx2 v[5:6], v[5:6], off; // global_load_dwordx2 v[0:1], v[0:1], off; // =>; // s_movk_i32 s0, 0x1000; // v_add_co_u32_e32 v5, vcc, s0, v2; // v_addc_co_u32_e32 v6, vcc, 0, v6, vcc; // global_load_dwordx2 v[5:6], v[5:6], off; // global_load_dwordx2 v[0:1], v[5:6], off offset:2048; //; // Future improvements:; //; // - This is currently missing stores of constants because loading; // the constant into the data register is placed between the stores, although; // this is arguably a scheduling problem.; //; // - Live interval recomputing seems inefficient. This currently only matches; // one pair, and recomputes live intervals and moves on to the next pair. It; // would be better to compute a list of all merges that need to occur.; //; // - With a list of instructions to process, we can also merge more. If a; // cluster of loads have offsets that are too large to fit in the 8-bit; // offsets, but are close enough to fit in the 8 bits, we can add to the base; // pointer and use the new reduced offsets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp:1687,load,loading,1687,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,2,['load'],"['loading', 'loads']"
Performance,"nstructions.; ///; /// The second SGPR is 32 bit byte size of a single work-item's scratch; /// memory usage. This is directly loaded from the dispatch packet Private; /// Segment Byte Size and rounded up to a multiple of DWORD.; ///; /// \todo [Does CP need to round this to >4 byte alignment?]; ///; /// The kernel code must move to SGPRn-3 for use as the FLAT SCRATCH SIZE in; /// flat memory instructions. Having CP load it once avoids loading it at; /// the beginning of every wavefront.; ///; /// For PI:; /// This is the 64 bit base address of the scratch backing memory for; /// allocated by CP for this dispatch.; ///; /// Private Segment Size (enable_sgpr_private_segment_size):; /// Number of User SGPR registers: 1. The 32 bit byte size of a single; /// work-item's scratch memory allocation. This is the value from the dispatch; /// packet. Private Segment Byte Size rounded up by CP to a multiple of DWORD.; ///; /// \todo [Does CP need to round this to >4 byte alignment?]; ///; /// Having CP load it once avoids loading it at the beginning of every; /// wavefront.; ///; /// \todo [This will not be used for CI/VI since it is the same value as; /// the second SGPR of Flat Scratch Init. However, it is need for PI which; /// changes meaning of Flat Scratchg Init..]; ///; /// Grid Work-Group Count X (enable_sgpr_grid_workgroup_count_x):; /// Number of User SGPR registers: 1. 32 bit count of the number of; /// work-groups in the X dimension for the grid being executed. Computed from; /// the fields in the HsaDispatchPacket as; /// ((gridSize.x+workgroupSize.x-1)/workgroupSize.x).; ///; /// Grid Work-Group Count Y (enable_sgpr_grid_workgroup_count_y):; /// Number of User SGPR registers: 1. 32 bit count of the number of; /// work-groups in the Y dimension for the grid being executed. Computed from; /// the fields in the HsaDispatchPacket as; /// ((gridSize.y+workgroupSize.y-1)/workgroupSize.y).; ///; /// Only initialized if <16 previous SGPRs initialized.; ///; /// Grid Wor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:4942,load,load,4942,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,2,['load'],"['load', 'loading']"
Performance,"nt as long as they are; /// consistent. Inaccuracies arise when instructions have different execution; /// delays relative to each other, in addition to their intrinsic latency. Those; /// special cases can be handled by TableGen constructs such as, ReadAdvance,; /// which reduces latency when reading data, and ReleaseAtCycles, which consumes; /// a processor resource when writing data for a number of abstract; /// cycles.; ///; /// TODO: One tool currently missing is the ability to add a delay to; /// ReleaseAtCycles. That would be easy to add and would likely cover all cases; /// currently handled by the legacy itinerary tables.; ///; /// A note on out-of-order execution and, more generally, instruction; /// buffers. Part of the CPU pipeline is always in-order. The issue point, which; /// is the point of reference for counting cycles, only makes sense as an; /// in-order part of the pipeline. Other parts of the pipeline are sometimes; /// falling behind and sometimes catching up. It's only interesting to model; /// those other, decoupled parts of the pipeline if they may be predictably; /// resource constrained in a way that the scheduler can exploit.; ///; /// The LLVM machine model distinguishes between in-order constraints and; /// out-of-order constraints so that the target's scheduling strategy can apply; /// appropriate heuristics. For a well-balanced CPU pipeline, out-of-order; /// resources would not typically be treated as a hard scheduling; /// constraint. For example, in the GenericScheduler, a delay caused by limited; /// out-of-order resources is not directly reflected in the number of cycles; /// that the scheduler sees between issuing an instruction and its dependent; /// instructions. In other words, out-of-order resources don't directly increase; /// the latency between pairs of instructions. However, they can still be used; /// to detect potential bottlenecks across a sequence of instructions and bias; /// the scheduling heuristics appropriately.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:3361,latency,latency,3361,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,2,"['bottleneck', 'latency']","['bottlenecks', 'latency']"
Performance,"nt has passed the selection (`true`) or not (`false`). It should perform ""read-only"" operations on the; columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; loop. See the paragraph about ""Just-in-time compilation"" below for more information. RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; each entry: after the first access it simply serves a cached result. \anchor named-filters-and-cutflow-reports; #### Named filters and cutflow reports; An optional string parameter `name` can be passed to the Filter() method to create a **named filter**. Named filters; work as usual, but also keep track of how many entries they accept and reject. Statistics are retrieved through a call to the Report() method:. - when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all; named filters declared up to that point; - when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport>; relative all named filters in the section of the chain between the main RDataFrame and that node (included). Stats are stored in the same order as named filters have been added to the graph, and *refer to the latest event-loop*; that has been run using the relevant R",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:29732,cache,cached,29732,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['cache'],['cached']
Performance,"ntry < 0) break;; ....; then either call; branch->GetEntry(localEntry);; or; chain->GetEntry(entryNumber);; In the later case the LoadTree is then somewhat redundant.; ...; }; }; ~~~; When using the TEntryList interface directly, you can get the 'tree number' and entry in; the current tree (i.e. value similar to the return value of LoadTree) from calling; TEntryList::GetEntryAndTree:; ~~~ {.cpp}; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; ~~~; to obtain the entry number within the chain you need to add to it the value of; `treeEntry+ch->GetTreeOffset()[treenum]`; such that the loop in the previous example can also be written as:; ~~~ {.cpp}; for (Long64_t el = 0; el < listEntries; el++) {; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);. ch->LoadTree(chainEntry); // this also returns treeEntry; needed_branch->GetEntry(treeEntry);; }; ~~~; ## TSelectors. To fill an TEntryList from a TSelector correctly, one must add the TEntryList object; to the output list of the selector (TSelector::fOutput). This is the only way to; make the sub-lists of the TEntryList switch when the current tree of the TChain is; changed. ## Using a TEntryList as input (TTree::SetEntryList() and TChain::SetEntryList()). while the TTree::SetEntryList() function is only setting the TTree::fEntryList; data member, the same function in TChain also finds correspondence between; the TTrees of this TChain and the sub-lists of this TEntryList. ## TEntryList and the current directory. TEntryList objects are automatically added to the current directory (like TTrees).; However, in case of a TEntryList for a chain, only the top-level entry list is added,; not the sub-lists for specific trees. Placing entry lists in the current directory; allows calling them as a part of a TTreeFormula expression, so if the user wants",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:3222,Load,LoadTree,3222,tree/tree/src/TEntryList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx,1,['Load'],['LoadTree']
Performance,"ntry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, class TimelineView also reports extra timing info; /// in another table named ""Average Wait times"" (see example below).; ///; ///; /// Average Wait times (based on the timeline view):; /// [0]: Executions; /// [1]: Average time spent waiting in a scheduler's queue; /// [2]: Average time spent waiting in a scheduler's queue while ready; /// [3]: Average time elapsed from WB until retire stage; ///; ///	[0]	[1]	[2]	[3]; /// 0.	 2	1.0	1.0	3.0	vmovshdup %xmm0, %xmm1; /// 1.	 2	1.0	1.0	3.0	vpermilpd $1, %xmm0, %xmm2; /// 2.	 2	1.0	1.0	2.5	vpermilps $231, %xmm0, %xmm5; /// 3.	 2	1.5	0.5	1.0	vaddss %xmm1, %xmm0, %xmm3; /// 4.	 2	3.5	0.0	0.0	vaddss %xmm3, %xmm2, %xmm4; /// 5.	 2	6.5	0.0	0.0	vaddss %xmm4, %xmm5, %xmm6; /// 2	2.4	0.6	1.6 <total>; ///; /// By comparing column [2] with column [1], we get an idea about how many; /// cycles were spent in the scheduler's queue due to data dependencies.; ///; /// In this example, instruction 5 spent an average of ~6 cycles in the; /// scheduler's queue. As soon as operands became ready, the instruction; /// was immediately issued to the pipeline(s).; /// That is expected because instruction 5 cannot transition to the ""ready""; /// state until %xmm4 is written by instruction 4.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:4076,queue,queue,4076,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,2,['queue'],['queue']
Performance,"nts (for the first signature); /// or one (for the second signature).; /// \endparblock; /// \param args; /// \parblock; /// a standard vector, a ROOT::TSeq of integer type or an initializer list for the second signature.; /// An integer only for the first.\n; /// \endparblock; ///; /// **Note:** in cases where the function to be executed takes more than; /// zero/one argument but all are fixed except zero/one, the function can be wrapped; /// in a lambda or via std::bind to give it the right signature.\n; ///; /// #### Return value:; /// An std::vector. The elements in the container; /// will be the objects returned by func.; ///; /// ### ROOT::Internal::TExecutor::MapReduce; /// This set of methods behaves exactly like Map, but takes an additional; /// function as a third argument. This function is applied to the set of; /// objects returned by the corresponding Map execution to ""squash"" them; /// into a single object. The signature of the reduce function should be `(const std::vector<T>) -> T`; ///; /// An integer can be passed as the fourth argument indicating the number of chunks we want to divide our work in.; /// <b>(Note: Please be aware that chunking is only available when the policy is kMultiThread, ignoring this argument in; /// other cases)</b> This may be useful to avoid the overhead introduced when running really short tasks. In this case,; /// the reduction function should be independent of the size of the vector returned by Map due to optimization of the; /// number of chunks.; ///; /// #### Examples:; /// ~~~{.cpp}; /// root[] ROOT::Internal::TExecutor pool; auto ten = pool.MapReduce([]() { return 1; }, 10, [](const std::vector<int>; /// &v) { return std::accumulate(v.begin(), v.end(), 0); }); /// root[] ROOT::Internal::TExecutor; /// pool(ROOT::EExecutionPolicy::kMultiProcess); auto hist = pool.MapReduce(CreateAndFillHists, 10,; /// PoolUtils::ReduceObjects);; /// ~~~; ///; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/TExecutor.cxx:2758,optimiz,optimization,2758,core/imt/src/TExecutor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/TExecutor.cxx,1,['optimiz'],['optimization']
Performance,"o generic address space.; //; // Device function parameters are directly accessible via; // ld.param/st.param, but taking the address of one returns a pointer; // to a copy created in local space which *can't* be used with; // ld.param/st.param.; //; // Copying a byval struct into local memory in IR allows us to enforce; // the param space restrictions, gives the rest of IR a pointer w/o; // param space restrictions, and gives us an opportunity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global address space. In the IR level,; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1; // %b = load i32*, i32** %b_ptr; // ; use %b; // }; //; // becomes; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i3",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:1820,load,load,1820,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,1,['load'],['load']
Performance,"o h4 = new TH2F(""h4"",""h4"",40,-3,3,40,-3,3);; h1->SetBit(TH1::kNoStats);; for (Int_t i=0;i<5000;i++) {; double x,y;; gRandom->Rannor(x,y);; if(x>0 && y>0) h1->Fill(x,y,4);; if(x<0 && y<0) h2->Fill(x,y,3);; if(x>0 && y<0) h3->Fill(x,y,2);; if(x<0 && y>0) h4->Fill(x,y,1);; }; h1->Draw(""colz"");; h2->Draw(""col same"");; h3->Draw(""col same"");; h4->Draw(""col same"");; }; End_Macro. The option `COL` can be combined with the option `POL`:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol1->Fill(px,py);; }; hcol1->Draw(""COLZPOL"");; }; End_Macro. \since **ROOT version 6.07/03:**. A second rendering technique is also available with the COL2 and COLZ2 options. These options provide potential performance improvements compared to the standard; COL option. The performance comparison of the COL2 to the COL option depends on; the histogram and the size of the rendering region in the current pad. In general,; a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; faster with the COL option. However, for larger histograms (approx. more than 100 bins per axis); that are not sparse, the COL2 option will provide up to 20 times performance improvements.; For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; faster with the COL2 option. The COL2 option will also scale its performance based on the size of the; pixmap the histogram image is being rendered into. It also is much better optimized for; sessions where the user is forwarding X11 windows through an `ssh` connection. For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; and COLZ options. There is one major difference and that concerns the treatment of; bins with zero content. The COL2 and COLZ2 options color these bins the color of zero. COL2 option renders the histog",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:41074,perform,performance,41074,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['perform'],['performance']
Performance,"o the NLL creation method.; * \see RooAbsPdf::createNLL(); *; * <tr><th><th> Options to control flow of fit procedure; * <tr><td> `Minimizer(""<type>"", ""<algo>"")` <td> Choose minimization package and optionally the algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer interface,; * but others can be specified (through RooMinimizer interface).; * <table>; * <tr><th> Type <th> Algorithm; * <tr><td> Minuit <td> migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); * <tr><td> Minuit2 <td> migrad, simplex, minimize, scan; * <tr><td> GSLMultiMin <td> conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; * <tr><td> GSLSimAn <td> -; * </table>; *; * <tr><td> `InitialHesse(bool flag)` <td> Flag controls if HESSE before MIGRAD as well, off by default; * <tr><td> `Optimize(bool flag)` <td> Activate constant term optimization of test statistic during minimization (on by default); * <tr><td> `Hesse(bool flag)` <td> Flag controls if HESSE is run after MIGRAD, on by default; * <tr><td> `Minos(bool flag)` <td> Flag controls if MINOS is run after HESSE, off by default; * <tr><td> `Minos(const RooArgSet& set)` <td> Only run MINOS on given subset of arguments; * <tr><td> `Save(bool flag)` <td> Flag controls if RooFitResult object is produced and returned, off by default; * <tr><td> `Strategy(Int_t flag)` <td> Set Minuit strategy (0 to 2, default is 1); * <tr><td> `MaxCalls(int n)` <td> Change maximum number of likelihood function calls from MINUIT (if `n <= 0`, the default of 500 * #%parameters is used); * <tr><td> `EvalErrorWall(bool flag=true)` <td> When parameters are in disallowed regions (e.g. PDF is negative), return very high value to fitter; * to force it out of that region. This can, however, mean that the fitter gets lost in this region. If; * this happens, try switching it off.; * <tr><td> `RecoverFromUndefinedRegions(double strength)` <td> When PDF is invalid (e.g. parameter in undefined region), try to direct minimiser away from that",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:2183,Optimiz,Optimize,2183,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,2,"['Optimiz', 'optimiz']","['Optimize', 'optimization']"
Performance,"o the end of the quoted; * text. The rules for quoting are as described in Quoting; * . During token recognition no substitutions will be actually; * performed, and the result token will contain exactly the; * characters that appear in the input (except for newline; * character joining), unmodified, including any embedded or; * enclosing quotes or substitution operators, between the quote; * mark and the end of the quoted text. The token will not be; * delimited by the end of the quoted field.""; *; * 2) ""If the current character is an unquoted newline character,; * the current token will be delimited.""; *; * 3) ""If the current character is an unquoted blank character, any; * token containing the previous character is delimited and the; * current character will be discarded.""; *; * 4) ""If the previous character was part of a word, the current; * character will be appended to that word.""; *; * 5) ""If the current character is a ""#"", it and all subsequent; * characters up to, but excluding, the next newline character; * will be discarded as a comment. The newline character that; * ends the line is not considered part of the comment. The; * ""#"" starts a comment only when it is at the beginning of a; * token. Since the search for the end-of-comment does not; * consider an escaped newline character specially, a comment; * cannot be continued to the next line.""; *; * 6) ""The current character will be used as the start of a new word.""; *; *; * - for each token (word), perform portions of word expansion, namely; * field splitting (using default whitespace IFS) and quote; * removal. Field splitting may increase the number of words.; * Quote removal does not increase the number of words.; *; * ""If the complete expansion appropriate for a word results in an; * empty field, that empty field will be deleted from the list of; * fields that form the completely expanded command, unless the; * original word contained single-quote or double-quote characters.""; * - UNIX98 spec; *; *; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gshell.c:2548,perform,perform,2548,graf2d/win32gdk/gdk/src/glib/gshell.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gshell.c,1,['perform'],['perform']
Performance,"oad float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published in; // CUDA: Compiling and optimizing for a GPU platform; // Chakrabarti, Grover, Aarts, Kong, Kudlur, Lin, Marathe, Murphy, Wang; // ICCS 2012; //; // Then, address space inference replaces all refinable generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // which may create loops in the data flow graph. This brings two complications.; //; // First, the data flow analysis in Step 1 needs to be circular. For example,; // %generic.input = addrspacecast float addrspace(3)* %input to float*; // loop:; // %y = phi [ %generic.input, %y2 ]; // %y2 = getelementptr %y, 1; // %v = load %y2; // br ..., label %loop, ...; // proving %y specific requires proving both %generic.input and %y2 specific,; // but proving %y2 specific circles back to %y. To address this complication,; // the data flow analysis operates on a lattice:; // uninitialized > specific address spaces > generic.; // All address expressions (our implementation only considers phi, bitcast,; // addrspacecast, and getelementptr) start with the uninitialized ad",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:2496,optimiz,optimizing,2496,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,1,['optimiz'],['optimizing']
Performance,"oad.; // Example:; // After the code below:; // inst_a; // inst_b; // %2 = ld ...; // DBG_VALUE %2, ""x"", ...; // %3 = ld ...; // The algorithm works in two phases: First RescheduleOps() populates the; // RegisterMap with registers that were moved as keys, there is no value; // inserted. In the next phase, every MachineInstr in a basic block is; // iterated over. If it is a valid DBG_VALUE or DBG_VALUE_LIST and it uses one; // or more registers in the RegisterMap, the RegisterMap and InstrMap are; // populated with the MachineInstr. If the DBG_VALUE or DBG_VALUE_LIST; // describes debug information for a variable that already exists in the; // DbgValueSinkCandidates, the MachineInstr in the DbgValueSinkCandidates must; // be set to undef. If the current MachineInstr is a load that was moved,; // undef the corresponding DBG_VALUE or DBG_VALUE_LIST and clone it to below; // the load.; // To illustrate the above algorithm visually let's take this example.; // Before the Pre Register Allocation Load Store Pass:; // %2 = ld ...; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // %3 = ld ...; // DBG_VALUE %3, A, ..., # Z; // %4 = ld ...; // After Pre Register Allocation Load Store Pass:; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // The algorithm below does the following:; // In the beginning, the RegisterMap will have been populated with the virtual; // registers %2, and %3, the DbgValueSinkCandidates and the InstrMap will be; // empty. DbgValueSinkCandidates = {}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap {}; // -> DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the first DBG_VALUE (denoted with an X) is processed, the; // DbgValueSinkCandidates and InstrMap will be populated and the RegisterMap; // entry for %2 will be populated as well. DbgValueSinkCandidates = {A -> X},",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:1564,Load,Load,1564,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['Load'],['Load']
Performance,"odesize; // and latency savings. Codesize savings means the amount of code that becomes; // dead in the specialization from propagating the constant, whereas latency; // savings represents the cycles we are saving from replacing instructions with; // constant values. The InstCostVisitor overrides a set of `visit*` methods to; // be able to handle different types of instructions. These attempt to constant-; // fold the instruction in which case a constant is returned and propagated; // further.; //; // Function pointers are not handled by the InstCostVisitor. They are treated; // separately as they could expose inlining opportunities via indirect call; // promotion. The inlining bonus contributes to the total specialization score.; //; // For a specialization to be profitable its bonus needs to exceed a minimum; // threshold. There are three options for controlling the threshold which are; // expressed as percentages of the original function size:; // * funcspec-min-codesize-savings; // * funcspec-min-latency-savings; // * funcspec-min-inlining-bonus; // There's also an option for controlling the codesize growth from recursive; // specializations. That is `funcspec-max-codesize-growth`.; //; // Once we have all the potential specializations with their score we need to; // choose the best ones, which fit in the module specialization budget. That; // is controlled by the option `funcspec-max-clones`. To find the best `NSpec`; // specializations we use a max-heap. For more details refer to D139346.; //; // Ideas:; // ------; // - With a function specialization attribute for arguments, we could have; // a direct way to steer function specialization, avoiding the cost-model,; // and thus control compile-times / code-size.; //; // - Perhaps a post-inlining function specialization pass could be more; // aggressive on literal constants.; //; // References:; // -----------; // 2021 LLVM Dev Mtg “Introducing function specialisation, and can we enable; // it by default?”, https",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h:2694,latency,latency-savings,2694,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h,1,['latency'],['latency-savings']
Performance,"of a module.; ///; /// With the edges of this graph, the motivating constraint that we are; /// attempting to maintain is that function-local optimization, CGSCC-local; /// optimizations, and optimizations transforming a pair of functions connected; /// by an edge in the graph, do not invalidate a bottom-up traversal of the SCC; /// DAG. That is, no optimizations will delete, remove, or add an edge such; /// that functions already visited in a bottom-up order of the SCC DAG are no; /// longer valid to have visited, or such that functions not yet visited in; /// a bottom-up order of the SCC DAG are not required to have already been; /// visited.; ///; /// Within this constraint, the desire is to minimize the merge points of the; /// SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able t",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1000,optimiz,optimizations,1000,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,1,['optimiz'],['optimizations']
Performance,"of entries in GetNextPacket; // 8 -> 9: support for stateless connection via xproofd; // 9 -> 10: new features requested, tested at CAF; // 10 -> 11: new merging strategy; // 11 -> 12: new progress message; // 12 -> 13: exchange version/architecture/compiler info; // 13 -> 14: new proofserv environment setting; // 14 -> 15: add support for entry lists; new version of TFileInfo; // 15 -> 16: add support for generic non-data based processing; // 16 -> 17: new dataset handling system; support for TFileCollection processing; // 17 -> 18: support for reconnection on daemon restarts; // 18 -> 19: TProofProgressStatus used in kPROOF_PROGRESS, kPROOF_STOPPROCESS; // and kPROOF_GETNEXTPACKET messages in Master - worker communication; // 19 -> 20: Fix the asynchronous mode (required changes in some messages); // 20 -> 21: Add support for session queuing; // 21 -> 22: Add support for switching from sync to async while running ('Ctrl-Z' functionality); // 22 -> 23: New dataset features (default tree name; classification per fileserver); // 23 -> 24: Merging optimization; // 24 -> 25: Handling of 'data' dir; group information; // 25 -> 26: Use new TProofProgressInfo class; // 26 -> 27: Use new file for updating the session status; // 27 -> 28: Support for multi-datasets, fix global pack dirs, fix AskStatistics,; // package download, dataset caching; // 28 -> 29: Support for config parameters in EnablePackage, idle-timeout; // 29 -> 30: Add information about data dir in TSlaveInfo; // 30 -> 31: Development cycle 5.29; // 31 -> 32: New log path trasmission; // 32 -> 33: Development cycle 5.29/04 (fixed worker activation, new startup technology, ...); // 33 -> 34: Development cycle 5.33/02 (fix load issue, ...); // 34 -> 35: Development cycle 5.99/01 (PLite on workers, staging requests in separate dsmgr...); // 35 -> 36: SetParallel in dynamic mode (changes default in GoParallel), cancel staging requests; // 36 -> 37: Support for remote (web) PAR packages; // PROOF magic constants",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h:2079,load,load,2079,proof/proof/inc/TProof.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h,1,['load'],['load']
Performance,"of sub; /// expressions in the stride and base of a SCEV corresponding to the; /// computation of a GCD (greatest common divisor) of base and stride. When; /// SCEV->delinearize fails, it returns the SCEV unchanged.; ///; /// For example: when analyzing the memory access A[i][j][k] in this loop nest; ///; /// void foo(long n, long m, long o, double A[n][m][o]) {; ///; /// for (long i = 0; i < n; i++); /// for (long j = 0; j < m; j++); /// for (long k = 0; k < o; k++); /// A[i][j][k] = 1.0;; /// }; ///; /// the delinearization input is the following AddRec SCEV:; ///; /// AddRec: {{{%A,+,(8 * %m * %o)}<%for.i>,+,(8 * %o)}<%for.j>,+,8}<%for.k>; ///; /// From this SCEV, we are able to say that the base offset of the access is %A; /// because it appears as an offset that does not divide any of the strides in; /// the loops:; ///; /// CHECK: Base offset: %A; ///; /// and then SCEV->delinearize determines the size of some of the dimensions of; /// the array as these are the multiples by which the strides are happening:; ///; /// CHECK: ArrayDecl[UnknownSize][%m][%o] with elements of sizeof(double); /// bytes.; ///; /// Note that the outermost dimension remains of UnknownSize because there are; /// no strides that would help identifying the size of the last dimension: when; /// the array has been statically allocated, one could compute the size of that; /// dimension by dividing the overall size of the array by the size of the known; /// dimensions: %m * %o * 8.; ///; /// Finally delinearize provides the access functions for the array reference; /// that does correspond to A[i][j][k] of the above C testcase:; ///; /// CHECK: ArrayRef[{0,+,1}<%for.i>][{0,+,1}<%for.j>][{0,+,1}<%for.k>]; ///; /// The testcases are checking the output of a function pass:; /// DelinearizationPass that walks through all loads and stores of a function; /// asking for the SCEV of the memory access with respect to all enclosing; /// loops, calling SCEV->delinearize on that and printing the results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:2129,load,loads,2129,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,1,['load'],['loads']
Performance,"oint of a branch is always an action."". ### Running on a range of entries; It is sometimes necessary to limit the processing of the dataset to a range of entries. For this reason, the RDataFrame; offers the concept of ranges as a node of the RDataFrame chain of transformations; this means that filters, columns and; actions can be concatenated to and intermixed with Range()s. If a range is specified after a filter, the range will act; exclusively on the entries passing the filter -- it will not even count the other entries! The same goes for a Range(); hanging from another Range(). Here are some commented examples:; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; // Here we store a dataframe that loops over only the first 30 entries in a variable; auto d30 = d.Range(30);; // This is how you pick all entries from 15 onwards; auto d15on = d.Range(15, 0);; // We can specify a stride too, in this case we pick an event every 3; auto d15each3 = d.Range(0, 15, 3);; ~~~; Note that ranges are not available when multi-threading is enabled. More information on ranges is available; [here](#ranges). ### Executing multiple actions in the same event loop; As a final example let us apply two different cuts on branch ""MET"" and fill two different histograms with the ""pt_v"" of; the filtered events.; By now, you should be able to easily understand what is happening:; ~~~{.cpp}; RDataFrame d(""treeName"", ""file.root"");; auto h1 = d.Filter(""MET > 10"").Histo1D(""pt_v"");; auto h2 = d.Histo1D(""pt_v"");; h1->Draw(); // event loop is run once here; h2->Draw(""SAME""); // no need to run the event loop again; ~~~; RDataFrame executes all above actions by **running the event-loop only once**. The trick is that actions are not; executed at the moment they are called, but they are **lazy**, i.e. delayed until the moment one of their results is; accessed through the smart pointer. At that time, the event loop is triggered and *all* results are produced; simultaneously. ### Properly exploiting RDataFrame ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:24608,multi-thread,multi-threading,24608,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['multi-thread'],['multi-threading']
Performance,"olled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load base + 32 * sizeof(float); // load base + 33 * sizeof(float); //; // Given the transformed IR, a backend that supports the reg+immediate; // addressing mode can easily fold the pointer arithmetics into the loads. For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:1604,optimiz,optimization,1604,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,1,['optimiz'],['optimization']
Performance,"olumnTypes...columnValues)`: each working thread shall call this method; /// during the event-loop, possibly concurrently. No two threads will ever call Exec with the same 'slot' value:; /// this parameter is there to facilitate writing thread-safe helpers. The other arguments will be the values of; /// the requested columns for the particular entry being processed.; /// * `void Finalize()`: this method is called at the end of the event loop. Commonly used to finalize the contents of the result.; /// * `std::string GetActionName()`: it returns a string identifier for this type of action that RDataFrame will use in; /// diagnostics, SaveGraph(), etc.; ///; /// ### Optional methods; ///; /// If these methods are implemented they enable extra functionality as per the description below.; ///; /// * `Result_t &PartialUpdate(unsigned int slot)`: if present, it must return the value of the partial result of this action for the given 'slot'.; /// Different threads might call this method concurrently, but will do so with different 'slot' numbers.; /// RDataFrame leverages this method to implement RResultPtr::OnPartialResult().; /// * `ROOT::RDF::SampleCallback_t GetSampleCallback()`: if present, it must return a callable with the; /// appropriate signature (see ROOT::RDF::SampleCallback_t) that will be invoked at the beginning of the processing; /// of every sample, as in DefinePerSample().; /// * `Helper MakeNew(void *newResult)`: if implemented, it enables varying the action's result with VariationsFor(). It takes a; /// type-erased new result that can be safely cast to a `std::shared_ptr<Result_t> *` (a pointer to shared pointer) and should; /// be used as the action's output result.; ///; /// In case Book is called without specifying column types as template arguments, corresponding typed code will be just-in-time compiled; /// by RDataFrame. In that case the Helper class needs to be known to the ROOT interpreter.; ///; /// This action is *lazy*: upon invocation of this ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:3594,concurren,concurrently,3594,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['concurren'],['concurrently']
Performance,"om-up traversal of the SCC; /// DAG. That is, no optimizations will delete, remove, or add an edge such; /// that functions already visited in a bottom-up order of the SCC DAG are no; /// longer valid to have visited, or such that functions not yet visited in; /// a bottom-up order of the SCC DAG are not required to have already been; /// visited.; ///; /// Within this constraint, the desire is to minimize the merge points of the; /// SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able to; /// form even a potential call edge from a function body which may dynamically; /// load the function and call it.; ///; /// This analysis still requires updates to remain valid after optimizations; /// which could potentially change the set of potential callees. The; /// constraints it operates und",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1420,optimiz,optimizations,1420,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,1,['optimiz'],['optimizations']
Performance,"omatically deleted when the Tree is deleted or; when the file is deleted.; The user can change the size of the cache with the TTree::SetCacheSize method; (by default the size is 30 Megabytes). This feature can be controlled with the; environment variable `ROOT_TTREECACHE_SIZE` or the TTreeCache.Size option.; The entry range for which the cache is active can also be set with the; SetEntryRange method. \anchor changesbehaviour; ## Changes of behavior when using TChain and TEventList. The usage of TChain or TEventList have influence on the behaviour of the cache:. - Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. - Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning phase is started or restarted when:; - TTree automatically creates a cache.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTreeCache::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; - TTreeCache::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries.; - A 'cached' TChain switches over to a new file. \anchor cachemisses; ## Self-optimization in presence of cache misses. The TTreeCache can optimize its behavior on a cache miss. When; miss optimization is enabled (see the SetOptimizeMisses method),; it tracks all branches utilized after the learning phase which caused a cache; miss.; When one cache miss occurs, all the utilized branches are be prefetched; for that event. This optimization utilizes the observation that infrequently; accessed branches are often accessed ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:4180,cache,cache,4180,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"ompared to, e.g., the; latency of a SSD. This is why the miss cache is currently disabled by default. \anchor examples; ## Example usages of TTreeCache. A few use cases are discussed below. A cache may be created with automatic; sizing when a TTree is used:. In some applications, e.g. central processing workflows of experiments, the list; of branches to read is known a priori. For these cases, the TTreeCache can be; instructed about the branches which will be read via explicit calls to the TTree; or TTreeCache interfaces.; In less streamlined applications such as analysis, predicting the branches which; will be read can be difficult. In such cases, ROOT I/O flags used branches; automatically when a branch buffer is read during the learning phase. In the examples below, portions of analysis code are shown.; The few statements involving the TreeCache are marked with `//<<<`. ### ROOT::RDataFrame and TTreeReader Examples. If you use RDataFrame or TTreeReader, the system will automatically cache the; best set of branches: no action is required by the user. ### TTree::Draw Example. The TreeCache is automatically used by TTree::Draw. The method knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also inferred automatically. ### TTree::Process and TSelectors Examples. The user must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case only a subset of the events is processed to avoid wasteful caching. #### Reading all branches. ~~~ {.cpp}; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; ~~~. #### Reading a ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:6787,cache,cache,6787,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"ompile-time information about what that node does. One way to cope with this complication; is to use template functions and/or C++14 auto return types:; ~~~{.cpp}; template <typename RDF>; auto ApplySomeFilters(RDF df); {; return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; }; ~~~. A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be; converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode:; ~~~{.cpp}; // a function that conditionally adds a Range to an RDataFrame node.; RNode MaybeAddRange(RNode df, bool mustAddRange); {; return mustAddRange ? df.Range(1) : df;; }; // use as :; ROOT::RDataFrame df(10);; auto maybeRangedDF = MaybeAddRange(df, true);; ~~~. The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`. \anchor RDFCollections; ### Storing RDataFrame objects in collections. ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:. ~~~{.cpp}; std::vector<ROOT::RDF::RNode> dfs;; dfs.emplace_back(ROOT::RDataFrame(10));; dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));; ~~~. \anchor callbacks; ### Executing callbacks every N events; It's possible to schedule execution of arbitrary functions (callbacks) during the event loop.; Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running,; drawing a partially-filled histogram every time a certain number of new entries is processed, or; displaying a progress bar while the event loop runs. For example one can draw an up-to-date version of a result histogram every 100 entries like this:; ~~~{.cpp}; auto h = df.Histo1D(""x"");; TCanvas c(""c"",""x hist"");; h.OnPartialResult(100",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:61469,perform,perform,61469,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['perform'],['perform']
Performance,"on of points/lines/segments.; - Some need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details).; \image html base_tbuffer3d.png. The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags. The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion.; An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers. The rules for client negotiation with the viewer are:. - If suitable specialized TBuffer3D class exists, use it, otherwise use TBuffer3D.; - Complete the mandatory Core section.; - Complete the ShapeSpecific section if applicable.; - Complete the BoundingBox if you can.; - Pass this buffer to the viewer using one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) AddObject(); will return flags indicating which ones, otherwise it returns kNone. You must; fill the buffer and mark these sections valid, and pass the buffer again. A; typical code snippet would be:; ~~~ {.cpp}; TBuffer3DSphere sphereBuffer;; // Fill out kCore...; // Fill out kBoundingBox...; // Fill out kShapeSpecific for TBuffer3DSphere; // Try first add to viewer; Int_t reqSections = viewer->AddObject(buffer);; if (reqSections != TBuffer3D::kNone) {; if (reqSect",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualViewer3D.cxx:3912,perform,performance,3912,core/base/src/TVirtualViewer3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualViewer3D.cxx,1,['perform'],['performance']
Performance,"on string defining the fit options (see table below).; /// \param[in] goption specify a list of graphics options. See TGraph::Draw and TGraphPainter for a complete list of these possible options.; /// \param[in] rxmin lower fitting range; /// \param[in] rxmax upper fitting range; ///; /// \anchor GFitOpt; /// ### Graph Fitting Options; /// The list of fit options is given in parameter option.; ///; /// option | description; /// -------|------------; /// ""S"" | The full result of the fit is returned in the `TFitResultPtr`. This is needed to get the covariance matrix of the fit. See `TFitResult` and the base class `ROOT::Math::FitResult`.; /// ""W"" | Ignore all point errors when fitting a TGraphErrors or TGraphAsymmErrors; /// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; /// ""U"" | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter::SetFCN`; /// ""E"" | Performs a better parameter errors estimation using the Minos technique for all fit parameters.; /// ""M"" | Uses the IMPROVE algorithm (available only in TMinuit). This algorithm attempts improve the found local minimum by searching for a better one.; /// ""Q"" | Quiet mode (minimum printing); /// ""V"" | Verbose mode (default is between Q and V); /// ""+"" | Adds this new fitted function to the list of fitted functions. By default, the previous function is deleted and only the last one is kept.; /// ""N"" | Does not store the graphics function, does not draw the histogram with the function after fitting.; /// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; /// ""R"" | Fit using a fitting range specified in the function range with `TF1::SetRange`.; /// ""B"" | Use this option when you want to fix one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:1189,Perform,Performs,1189,hist/hist/src/TGraph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx,1,['Perform'],['Performs']
Performance,"on the python side, and transfer it back and forth.; /// root [1] std::any res1;; /// root [2] TPython::Exec(""_anyresult = ROOT.std.make_any['TNamed']('hello', '')"", &res1);; /// root [3] TPython::Bind(&std::any_cast<TNamed&>(res1), ""n"");; /// root [4] std::any res2;; /// root [5] TPython::Exec(""_anyresult = ROOT.std.make_any['TNamed*', 'TNamed*'](n)"", &res2);; /// root [6] (&std::any_cast<TNamed&>(res1) == std::any_cast<TNamed*>(res2)); /// (bool) true; ///; /// // Variables can cross-over by using an `std::any` with a specific name.; /// root [6] TPython::Exec(""_anyresult = ROOT.std.make_any['Int_t'](1 + 1)"", &res1);; /// root [7] std::any_cast<int>(res1); /// (int) 2; /// ~~~; ///; /// And with a python file `MyPyClass.py` like this:; /// ~~~{.py}; /// print 'creating class MyPyClass ... '; ///; /// class MyPyClass:; /// def __init__( self ):; /// print 'in MyPyClass.__init__'; ///; /// def gime( self, what ):; /// return what; /// ~~~; /// one can load a python module, and use the class. Casts are; /// necessary as the type information can not be otherwise derived.; /// ~~~{.cpp}; /// root [6] TPython::LoadMacro( ""MyPyClass.py"" );; /// creating class MyPyClass ...; /// root [7] MyPyClass m;; /// in MyPyClass.__init__; /// root [8] std::string s = (char*)m.gime( ""aap"" );; /// root [9] s; /// (class TString)""aap""; /// ~~~; /// It is possible to switch between interpreters by calling `TPython::Prompt()`; /// on the Cling side, while returning with `^D` (EOF). State is preserved between; /// successive switches.; ///; /// The API part provides (direct) C++ access to the bindings functionality of; /// PyROOT. It allows verifying that you deal with a PyROOT python object in the; /// first place (CPPInstance_Check for CPPInstance and any derived types, as well; /// as CPPInstance_CheckExact for CPPInstance's only); and it allows conversions; /// of `void*` to an CPPInstance and vice versa.; //- data ---------------------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/tpython/src/TPython.cxx:1769,Load,LoadMacro,1769,bindings/tpython/src/TPython.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/tpython/src/TPython.cxx,1,['Load'],['LoadMacro']
Performance,"on](\ref description); - [Changes in behaviour](\ref changesbehaviour); - [Self-optimization](\ref cachemisses); - [Examples of usage](\ref examples); - [Check performance and stats](\ref checkPerf). \anchor motivation; ## Motivation: why having a cache is needed?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of TTrees with several; hundred or thousand branches. When writing, this does not generate a performance problem because branch; buffers are always written sequentially and, thanks to OS optimisations,; content is flushed to the output file when a few MBytes of data are available.; On the other hand, when reading, one may hit performance problems because of; latencies e.g imposed by network.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second. The TreeCache tries to prefetch all the buffers for the selected branches; in order to transfer a few multi-Megabytes large buffers instead of many; multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to; be read in increasing order such that the file is read sequentially. Systems like xrootd, dCache or httpd take advantage of the TTreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. ### Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all; entries such that not all branch buffers are read. \anchor description; ## General Description; This class acts as a file cache, registering automatically the baskets from; the branches being ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:1578,latency,latency,1578,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,"['cache', 'latency']","['cache', 'latency']"
Performance,"oncatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: Why):; /// - Nullary twines are always represented with their Kind on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - Unary twines are always represented with the value on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - If a Twine has another Twine as a child, that child should always be; /// binary (otherwise it could have been folded into the parent).; ///; /// These invariants are check by \see isValid().; ///; /// \b Efficiency Considerations; ///; /// The Twine is designed to yield efficient and small code for common; /// situations. For this reason, the concat() method is inlined so that; /// concatenations of leaf nodes can be optimized into stores directly into a; /// single stack allocated object.; ///; /// In practice, not all compilers can be trusted to optimize concat() fully,; /// so we provide two additional methods (and accompanying operator+; /// overloads) to guarantee that particularly important cases (cstring plus; /// StringRef) codegen as desired.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:2697,optimiz,optimized,2697,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,2,['optimiz'],"['optimize', 'optimized']"
Performance,"ons.; /// Under this assumption, younger loads are always allowed to pass older; /// stores (this would only affects rule 4).; /// Essentially, this class doesn't perform any sort alias analysis to; /// identify aliasing loads and stores.; ///; /// To enforce aliasing between loads and stores, flag `AssumeNoAlias` must be; /// set to `false` by the constructor of LSUnit.; ///; /// Note that this class doesn't know about the existence of different memory; /// types for memory operations (example: write-through, write-combining, etc.).; /// Derived classes are responsible for implementing that extra knowledge, and; /// provide different sets of rules for loads and stores by overriding method; /// `isReady()`.; /// To emulate a write-combining memory type, rule 2. must be relaxed in a; /// derived class to enable the reordering of non-aliasing store operations.; ///; /// No assumptions are made by this class on the size of the store buffer. This; /// class doesn't know how to identify cases where store-to-load forwarding may; /// occur.; ///; /// LSUnit doesn't attempt to predict whether a load or store hits or misses; /// the L1 cache. To be more specific, LSUnit doesn't know anything about; /// cache hierarchy and memory types.; /// It only knows if an instruction ""mayLoad"" and/or ""mayStore"". For loads, the; /// scheduling model provides an ""optimistic"" load-to-use latency (which usually; /// matches the load-to-use latency for when there is a hit in the L1D).; /// Derived classes may expand this knowledge.; ///; /// Class MCInstrDesc in LLVM doesn't know about serializing operations, nor; /// memory-barrier like instructions.; /// LSUnit conservatively assumes that an instruction which `mayLoad` and has; /// `unmodeled side effects` behave like a ""soft"" load-barrier. That means, it; /// serializes loads without forcing a flush of the load queue.; /// Similarly, instructions that both `mayStore` and have `unmodeled side; /// effects` are treated like store barriers. ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:1627,load,load,1627,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,1,['load'],['load']
Performance,"opied more often).; *; * The channel supports five major operations: read(), write(), flush(),; * purge() and close(). Reading and writing may block until the required buffer; * space is available. Writes may queue up data to be sent to the other end; * until either enough pages are full, or the user calls flush which forces; * any unsent buffers to be sent to the other end. flush forces any data that; * is to be sent to be sent. purge discards any buffered data waiting to be; * read and/or sent. Closing the channel on the child returns zero, closing it; * on the parent returns the child's exit status.; *; * The class also provides operator<< and operator>> for C++-style I/O for; * basic data types (bool, char, short, int, long, long long, float, double; * and their unsigned counterparts). Data is transmitted binary (i.e. no; * formatting to strings like std::cout does). There are also overloads to; * support C-style zero terminated strings and std::string. In terms of; * performance, the former is to be preferred.; *; * If the caller needs to multiplex input and output to/from several pipes, the; * class provides the poll() method which allows to block until an event occurs; * on any of the polled pipes.; *; * After the BidirMMapPipe is closed, no further operations may be performed on; * that object, save for the destructor which may still be called.; *; * If the BidirMMapPipe has not properly been closed, the destructor will call; * close. However, the exit code of the child is lost in that case.; *; * Closing the object causes the mmapped memory to be unmapped and the two; * pipes to be closed. We also install an atexit handler in the process of; * creating BidirMMapPipes. This ensures that when the current process; * terminates, a SIGTERM signal is sent to the child processes created for all; * unclosed pipes to avoid leaving zombie processes in the OS's process table.; *; * BidirMMapPipe creation, closing and destruction are thread safe. If the; * BidirMMapPipe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h:1968,perform,performance,1968,roofit/roofitcore/src/BidirMMapPipe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h,1,['perform'],['performance']
Performance,"options are:; | Name | Description |; |------|-------------|; | SetUseSuffixes() | suffix usage in column names (default - on) |; | SetArrayLimit() | defines maximum array size, which can has column for each element (default 21) |; | SetTablesType() | table type name in MySQL database (default ""InnoDB"") |; | SetUseIndexes() | usage of indexes in database (default kIndexesBasic) |. Normally these functions should be called immediately after TSQLFile constructor.; When objects data written to database, by default START TRANSACTION/COMMIT; SQL commands are used before and after data storage. If TSQLFile detects; any problems, ROLLBACK command will be used to restore; previous state of data base. If transactions not supported by SQL server,; they can be disabled by SetUseTransactions(kTransactionsOff). Or user; can take responsibility to use transactions function himself.; By default only indexes for basic tables are created.; In most cases usage of indexes increase performance to data reading,; but it also can increase time of writing data to database.; There are several modes of index usage available in SetUseIndexes() method; There is MakeSelectQuery(TClass*) method, which; produces SELECT statement to get objects data of specified class.; Difference from simple statement like:; mysql> SELECT * FROM TH1I_ver1; that not only data for that class, but also data from parent classes; will be extracted from other tables and combined in single result table.; Such select query can be useful for external access to objects data. Up to now MySQL 4.1 and Oracle 9i were tested.; Some extra work is required for other SQL databases.; Hopefully, this should be straightforward. Known problems and open questions.; -# TTree is not supported by TSQLFile. There is independent development; of TTreeSQL class, which allows to store trees directly in SQL database; -# TClonesArray is store objects in raw format,; which can not be accessed outside ROOT.; This will be changed later.; -# TDirect",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/sql/src/TSQLFile.cxx:5181,perform,performance,5181,io/sql/src/TSQLFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/sql/src/TSQLFile.cxx,1,['perform'],['performance']
Performance,"or compiled, see below),; /// filename must contain a valid class implementation derived from TSelector,; /// where TSelector has the following member functions:; ///; /// - `Begin()`: called every time a loop on the tree starts,; /// a convenient place to create your histograms.; /// - `SlaveBegin()`: called after Begin(), when on PROOF called only on the; /// slave servers.; /// - `Process()`: called for each event, in this function you decide what; /// to read and fill your histograms.; /// - `SlaveTerminate`: called at the end of the loop on the tree, when on PROOF; /// called only on the slave servers.; /// - `Terminate()`: called at the end of the loop on the tree,; /// a convenient place to draw/fit your histograms.; ///; /// If filename is of the form file.C, the file will be interpreted.; ///; /// If filename is of the form file.C++, the file file.C will be compiled; /// and dynamically loaded.; ///; /// If filename is of the form file.C+, the file file.C will be compiled; /// and dynamically loaded. At next call, if file.C is older than file.o; /// and file.so, the file.C is not compiled, only file.so is loaded.; ///; /// ## NOTE1; ///; /// It may be more interesting to invoke directly the other Process function; /// accepting a TSelector* as argument.eg; /// ~~~ {.cpp}; /// MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; /// selector->CallSomeFunction(..);; /// mytree.Process(selector,..);; /// ~~~; /// ## NOTE2; //; /// One should not call this function twice with the same selector file; /// in the same script. If this is required, proceed as indicated in NOTE1,; /// by getting a pointer to the corresponding TSelector,eg; ///; /// ### Workaround 1; ///; /// ~~~ {.cpp}; /// void stubs1() {; /// TSelector *selector = TSelector::GetSelector(""h1test.C"");; /// TFile *f1 = new TFile(""stubs_nood_le1.root"");; /// TTree *h1 = (TTree*)f1->Get(""h1"");; /// h1->Process(selector);; /// TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; /// TTr",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1331,load,loaded,1331,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['load'],['loaded']
Performance,"or license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push; // the children nodes to the queue via `static bool; // IsStructurallyEquivalent(StructuralEquivalenceContext &Context, Decl *D1,; // Decl *D2)`. So far so good, this is almost like the BFS. However, if",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:1189,queue,queue,1189,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,1,['queue'],['queue']
Performance,"or x86 --=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// Description: This pass finds Load Value Injection (LVI) gadgets consisting; /// of a load from memory (i.e., SOURCE), and any operation that may transmit; /// the value loaded from memory over a covert channel, or use the value loaded; /// from memory to determine a branch/call target (i.e., SINK). After finding; /// all such gadgets in a given function, the pass minimally inserts LFENCE; /// instructions in such a manner that the following property is satisfied: for; /// all SOURCE+SINK pairs, all paths in the CFG from SOURCE to SINK contain at; /// least one LFENCE instruction. The algorithm that implements this minimal; /// insertion is influenced by an academic paper that minimally inserts memory; /// fences for high-performance concurrent programs:; /// http://www.cs.ucr.edu/~lesani/companion/oopsla15/OOPSLA15.pdf; /// The algorithm implemented in this pass is as follows:; /// 1. Build a condensed CFG (i.e., a GadgetGraph) consisting only of the; /// following components:; /// - SOURCE instructions (also includes function arguments); /// - SINK instructions; /// - Basic block entry points; /// - Basic block terminators; /// - LFENCE instructions; /// 2. Analyze the GadgetGraph to determine which SOURCE+SINK pairs (i.e.,; /// gadgets) are already mitigated by existing LFENCEs. If all gadgets have been; /// mitigated, go to step 6.; /// 3. Use a heuristic or plugin to approximate minimal LFENCE insertion.; /// 4. Insert one LFENCE along each CFG edge that was cut in step 3.; /// 5. Go to step 2.; /// 6. If any LFENCEs were inserted, return `true` from runOnMachineFunction(); /// to tell LLVM that the function was modified.; ///; //===------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:1116,perform,performance,1116,interpreter/llvm-project/llvm/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp,2,"['concurren', 'perform']","['concurrent', 'performance']"
Performance,"orkspace for each internal datastructure:; *; * - These different internal datastructures have different setup requirements:; *; * - The static objects need to be cleared once and can then be trivially; * reused for each compression.; *; * - Various buffers don't need to be initialized at all--they are always; * written into before they're read.; *; * - The matchstate tables have a unique requirement that they don't need; * their memory to be totally cleared, but they do need the memory to have; * some bound, i.e., a guarantee that all values in the memory they've been; * allocated is less than some maximum value (which is the starting value; * for the indices that they will then use for compression). When this; * guarantee is provided to them, they can use the memory without any setup; * work. When it can't, they have to clear the area.; *; * - These buffers also have different alignment requirements.; *; * - We would like to reuse the objects in the workspace for multiple; * compressions without having to perform any expensive reallocation or; * reinitialization work.; *; * - We would like to be able to efficiently reuse the workspace across; * multiple compressions **even when the compression parameters change** and; * we need to resize some of the objects (where possible).; *; * To attempt to manage this buffer, given these constraints, the ZSTD_cwksp; * abstraction was created. It works as follows:; *; * Workspace Layout:; *; * [ ... workspace ... ]; * [objects][tables ... ->] free space [<- ... aligned][<- ... buffers]; *; * The various objects that live in the workspace are divided into the; * following categories, and are allocated separately:; *; * - Static objects: this is optionally the enclosing ZSTD_CCtx or ZSTD_CDict,; * so that literally everything fits in a single buffer. Note: if present,; * this must be the first object in the workspace, since ZSTD_customFree{CCtx,; * CDict}() rely on a pointer comparison to see whether one or two frees are; * requi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h:1387,perform,perform,1387,builtins/zstd/compress/zstd_cwksp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_cwksp.h,1,['perform'],['perform']
Performance,"ort warnings for Clang modules.; /// 3. Analyze live DIEs and type names(if ODR deduplication is requested).; /// 4. Clone DIEs(Generate output DIEs and resulting DWARF tables).; /// The result is in an OutDebugInfoBytes, which is an ELF file; /// containing DWARF tables corresponding to the current compile unit.; /// 5. Cleanup Input and Output DIEs.; /// }; ///; /// Deallocate loaded Object file.; /// }; ///; /// if (ODR deduplication is requested); /// Generate an artificial compilation unit (""Type Table"": used to partially; /// generate DIEs at the clone stage).; ///; /// for_each (ObjectFile) {; /// for_each (Compile Unit) {; /// 1. Set offsets to Compile Units DWARF tables.; /// 2. Sort offsets/attributes/patches to have a predictable result.; /// 3. Patch size/offsets fields.; /// 4. Generate index tables.; /// 5. Move DWARF tables of compile units into the resulting file.; /// }; /// }; ///; /// Every compile unit is processed separately, visited only once; /// (except case inter-CU references exist), and used data is freed; /// after the compile unit is processed. The resulting file is glued together; /// from the generated debug tables which correspond to separate compile units.; ///; /// Handling inter-CU references: inter-CU references are hard to process; /// using only one pass. f.e. if CU1 references CU100 and CU100 references; /// CU1, we could not finish handling of CU1 until we finished CU100.; /// Thus we either need to load all CUs into the memory, either load CUs several; /// times. This implementation loads inter-connected CU into memory at the first; /// pass and processes them at the second pass.; ///; /// ODR deduplication: Artificial compilation unit will be constructed to keep; /// type dies. All types are moved into that compilation unit. Type's references; /// are patched so that they point to the corresponding types from artificial; /// compilation unit. All partial type definitions would be merged into single; /// type definition.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Parallel/DWARFLinker.h:2546,load,load,2546,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Parallel/DWARFLinker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Parallel/DWARFLinker.h,3,['load'],"['load', 'loads']"
Performance,"ory inside the TFile. It is sufficient to specify the path to; /// the TTree as part of the TTree name, e.g. `df.Snapshot(""subdir/t"", ""f.root"")` write TTree `t` in the; /// sub-directory `subdir` of file `f.root` (creating file and sub-directory as needed).; ///; /// \attention In multi-thread runs (i.e. when EnableImplicitMT() has been called) threads will loop over clusters of; /// entries in an undefined order, so Snapshot will produce outputs in which (clusters of) entries will be shuffled with; /// respect to the input TTree. Using such ""shuffled"" TTrees as friends of the original trees would result in wrong; /// associations between entries in the main TTree and entries in the ""shuffled"" friend. Since v6.22, ROOT will; /// error out if such a ""shuffled"" TTree is used in a friendship.; ///; /// \note In case no events are written out (e.g. because no event passes all filters) the behavior of Snapshot in; /// single-thread and multi-thread runs is different: in single-thread runs, Snapshot will write out a TTree with; /// the specified name and zero entries; in multi-thread runs, no TTree object will be written out to disk.; ///; /// \note Snapshot will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Snapshot(..., {""nbar""})`.; ///; /// ### Example invocations:; ///; /// ~~~{.cpp}; /// // without specifying template parameters (column types automatically deduced); /// df.Snapshot(""outputTree"", ""outputFile.root"", {""x"", ""y""});; ///; /// // specifying template parameters (""x"" is `int`, ""y"" is `float`); /// df.Snapshot<int, float>(""outputTree"", ""outputFile.root"", {""x"", ""y""});; /// ~~~; ///; /// To book a Snapshot without triggering the event loop, one needs to set ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:2695,multi-thread,multi-thread,2695,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,2,['multi-thread'],['multi-thread']
Performance,"owing GEPs have multiple indices:; // BB1:; // %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3; // load %p; // ...; // BB2:; // %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2; // load %p2; // ...; //; // We can not do CSE to the common part related to index ""i64 %i"". Lowering; // GEPs can achieve such goals.; // If the target does not use alias analysis in codegen, this pass will; // lower a GEP with multiple indices into arithmetic operations:; // BB1:; // %1 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = add i64 %1, %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = add i64 %3, %4; // %6 = add i64 %3, struct_field_3 ; Constant offset; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = add i64 %7, %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = add i64 %9, %10; // %12 = add i64 %11, struct_field_2 ; Constant offset; // %p = inttoptr i64 %12 to i32*; // load %p2; // ...; //; // If the target uses alias analysis in codegen, this pass will lower a GEP; // with multiple indices into multiple GEPs with a single index:; // BB1:; // %1 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = getelementptr i8* %1, i64 %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = getelementptr i8* %3, i64 %4; // %6 = getelementptr i8* %5, struct_field_3 ; Constant offset; // %p = bitcast i8* %6 to i32*; // load %p; // ...; // BB2:; // %7 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = getelementptr i8* %7, i64 %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = getelementptr i8* %9, i64 %10; // %12 = getelementptr i8* %",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:4738,load,load,4738,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,1,['load'],['load']
Performance,"p/bottom instructions such as VMOVLT/B and VMOVNT/B,; // which take a the top/bottom half of a larger lane and extend it (or do the; // opposite, truncating into the top/bottom lane from a larger lane). Note; // that because of the way we widen lanes, a v4i16 is really a v4i32 using the; // bottom 16bits from each vector lane. This works really well with T/B; // instructions, but that doesn't extend to v8i32->v8i16 where the lanes need; // to move order.; //; // But truncates and sext/zext are always going to be fairly common from llvm.; // We have several options for how to deal with them:; // - Wherever possible combine them into an instruction that makes them; // ""free"". This includes loads/stores, which can perform the trunc as part; // of the memory operation. Or certain shuffles that can be turned into; // VMOVN/VMOVL.; // - Lane Interleaving to transform blocks surrounded by ext/trunc. So; // trunc(mul(sext(a), sext(b))) may become; // VMOVNT(VMUL(VMOVLB(a), VMOVLB(b)), VMUL(VMOVLT(a), VMOVLT(b))). (Which in; // this case can use VMULL). This is performed in the; // MVELaneInterleavingPass.; // - Otherwise we have an option. By default we would expand the; // zext/sext/trunc into a series of lane extract/inserts going via GPR; // registers. One for each vector lane in the vector. This can obviously be; // very expensive.; // - The other option is to use the fact that loads/store can extend/truncate; // to turn a trunc into two truncating stack stores and a stack reload. This; // becomes 3 back-to-back memory operations, but at least that is less than; // all the insert/extracts.; //; // In order to do the last, we convert certain trunc's into MVETRUNC, which; // are either optimized where they can be, or eventually lowered into stack; // stores/loads. This prevents us from splitting a v8i16 trunc into two stores; // two early, where other instructions would be better, and stops us from; // having to reconstruct multiple buildvector shuffles into loads/stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:1412,perform,performed,1412,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,5,"['load', 'optimiz', 'perform']","['loads', 'optimized', 'performed']"
Performance,"penGL column major ordering); for placing the object into the 3D master frame. If `fLocalFrame` is kFALSE, `fLocalMaster` should contain an identity matrix. This; is set by default, and can be reset using `SetLocalMasterIdentity()` function. Logical & Physical Objects.; There are two cases of object addition:. - Add this object as a single independent entity in the world reference frame.; - Add a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively few logical (unique) shapes.; Some viewers (OpenGL only at present) are able to take advantage of this by; identifying unique logical shapes from the `fID` logical ID member of; TBuffer3D. If repeated addition of the same `fID` is found, the shape; is cached already - and the costly tessellation does not need to be sent again.; The viewer can also perform internal GL specific caching with considerable; performance gains in these cases. For this to work correctly the logical object in must be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method. ~~~ {.cpp}; PreferLocalFrame(); ~~~. If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different `fLocalMaster` placements. For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the `fLocalMaster` transform and the; `fColor` and `fTransparency` attributes, which can be varied for each physical; object. As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. ### Scene Rebuilds. It should be understood that AddObject is not a",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer3D.cxx:5269,perform,perform,5269,core/base/src/TBuffer3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer3D.cxx,2,['perform'],"['perform', 'performance']"
Performance,"perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestro(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:1718,perform,perform,1718,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,1,['perform'],['perform']
Performance,"phics class in the ROOT system. A Pad is contained in a Canvas. A Pad may contain other pads (unlimited pad hierarchy). A pad is a linked list of primitives of any type (graphics objects,; histograms, detectors, tracks, etc.). Adding a new element into a pad is in general performed by the Draw; member function of the object classes. It is important to realize that the pad is a linked list of references; to the original object.; For example, in case of a histogram, the histogram.Draw() operation; only stores a reference to the histogram object and not a graphical; representation of this histogram.; When the mouse is used to change (say the bin content), the bin content; of the original histogram is changed. The convention used in ROOT is that a Draw operation only adds; a reference to the object. The effective drawing is performed; when the canvas receives a signal to be painted. \image html gpad_pad1.png. This signal is generally sent when typing carriage return in the; command input or when a graphical operation has been performed on one; of the pads of this canvas.; When a Canvas/Pad is repainted, the member function Paint for all; objects in the Pad linked list is invoked. \image html gpad_pad2.png. When the mouse is moved on the Pad, The member function DistancetoPrimitive; is called for all the elements in the pad. DistancetoPrimitive returns; the distance in pixels to this object. When the object is within the distance window, the member function; ExecuteEvent is called for this object. In ExecuteEvent, move, changes can be performed on the object. For examples of DistancetoPrimitive and ExecuteEvent functions,; see classes; ~~~ {.cpp}; TLine::DistancetoPrimitive, TLine::ExecuteEvent; TBox::DistancetoPrimitive, TBox::ExecuteEvent; TH1::DistancetoPrimitive, TH1::ExecuteEvent; ~~~; A Pad supports linear and log scales coordinate systems.; The transformation coefficients are explained in TPad::ResizePad.; */; ///////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx:1092,perform,performed,1092,graf2d/gpad/src/TPad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx,1,['perform'],['performed']
Performance,"pletely distinct : WIRE_CO_1 and WIRE_CO_2. We will; want now to place symmetrically 1000 chambers on a pad, following a pattern; of 20 rows and 50 columns. One way to do this will be to replicate our chamber; by positioning it 1000 times in different positions of the pad. Unfortunately,; this is far from being the optimal way of doing what we want.; Imagine that we would like to find out which of the 1000 chambers is containing; a (x,y,z) point defined in the pad reference. You will never have to do that,; since the modeller will take care of it for you, but let's guess what it has; to do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current chamber; contains the point or not. This might be efficient for pads with few chambers,; but definitely not for 1000. Fortunately the modeler is smarter than that and; create for each volume some optimization structures called voxels (see Voxelization); to minimize the penalty having too many daughters, but if you have 100 pads like; this in your geometry you will anyway loose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the; usage of divisions. We will describe them in detail later on. Let's think now; at a different situation : instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical and have; a wire inside, but their dimensions are different. However, we would like all; to be represented by a single volume family, since they have the same properties.; */; /** \class TGeoVolumeMulti; \ingroup Geometry_classes. Volume families. A volume family is represented by the class TGeoVolumeMulti. It represents; a class of volumes having the same shape type and each member will be; identified by the same name and volume ID. Any operation applied to a; TGeoVolume equally affects all volumes in that family. The creation of a; fami",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoVolume.cxx:10105,optimiz,optimization,10105,geom/geom/src/TGeoVolume.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoVolume.cxx,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"ppose, that the child node is stored under the index inode. Then:; - Parent `index = inode/2`. Number of division nodes and number of terminals :; `fNNodes = (fNPoints/fBucketSize)`. The nodes are filled always from left side to the right side:; Let inode be the index of a node, and irow - the index of a row; The TKDTree looks the following way:; Ideal case:; ~~~~; Number of _terminal_ nodes = 2^N, N=3. INode; irow 0 0 - 1 inode; irow 1 1 2 - 2 inodes; irow 2 3 4 5 6 - 4 inodes; irow 3 7 8 9 10 11 12 13 14 - 8 inodes; ~~~~. Non ideal case:; ~~~~; Number of _terminal_ nodes = 2^N+k, N=3 k=1. INode; irow 0 0 - 1 inode; irow 1 1 2 - 2 inodes; irow 2 3 4 5 6 - 3 inodes; irow 3 7 8 9 10 11 12 13 14 - 8 inodes; irow 4 15 16 - 2 inodes; ~~~~. #### 4b. The division algorithm:. As described above, the kd-tree is built by repeatingly dividing the given set of points into; 2 smaller sets. The cut is made on the axis with the biggest spread, and the value on the axis,; on which the cut is performed, is chosen based on the following formula:; Suppose, we want to divide n nodes into 2 groups, left and right. Then the left and right; will have the following number of nodes:. ~~~~; n=2^k+rest. Left = 2^k-1 + ((rest>2^k-2) ? 2^k-2 : rest); Right = 2^k-1 + ((rest>2^k-2) ? rest-2^k-2 : 0); ~~~~. For example, let `n_nodes=67`. Then, the closest `2^k=64, 2^k-1=32, 2^k-2=16`.; Left node gets `32+3=35` sub-nodes, and the right node gets 32 sub-nodes. The division process continues until all the nodes contain not more than a predefined number; of points. #### 4c. The order of nodes in boundary-related arrays. Some kd-tree based algorithms need to know the boundaries of each node. This information can; be computed by calling the TKDTree::MakeBoundaries() function. It fills the following arrays:. - `fRange` : array containing the boundaries of the domain:; `| 1st dimension (min + max) | 2nd dimension (min + max) | ...`; `fBoundaries` : nodes boundaries; `| 1st node {1st dim * 2 elements | 2nd",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TKDTree.cxx:8549,perform,performed,8549,math/mathcore/src/TKDTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TKDTree.cxx,1,['perform'],['performed']
Performance,"practice to; specify it as a template parameter to the action itself, like this:; ~~~{.cpp}; df.Histo1D(""b1""); // OK, the type of ""b1"" is deduced at runtime; df.Min<MyNumber_t>(""myObject""); // OK, ""myObject"" is deduced to be of type `MyNumber_t`; ~~~. Deducing types at runtime requires the just-in-time compilation of the relevant actions, which has a small runtime; overhead, so specifying the type of the columns as template parameters to the action is good practice when performance is a goal. When strings are passed as expressions to Filter() or Define(), fundamental types are passed as constants. This avoids certaincommon mistakes such as typing `x = 0` rather than `x == 0`:. ~~~{.cpp}; // this throws an error (note the typo); df.Define(""x"", ""0"").Filter(""x = 0"");; ~~~. \anchor generic-actions; ### User-defined custom actions; RDataFrame strives to offer a comprehensive set of standard actions that can be performed on each event. At the same; time, it allows users to inject their own action code to perform arbitrarily complex data reductions. #### Implementing custom actions with Book(). Through the Book() method, users can implement a custom action and have access to the same features; that built-in RDataFrame actions have, e.g. hooks to events related to the start, end and execution of the; event loop, or the possibility to return a lazy RResultPtr to an arbitrary type of result:. ~~~{.cpp}; #include <ROOT/RDataFrame.hxx>; #include <memory>. class MyCounter : public ROOT::Detail::RDF::RActionImpl<MyCounter> {; std::shared_ptr<int> fFinalResult = std::make_shared<int>(0);; std::vector<int> fPerThreadResults;. public:; // We use a public type alias to advertise the type of the result of this action; using Result_t = int;. MyCounter(unsigned int nSlots) : fPerThreadResults(nSlots) {}. // Called before the event loop to retrieve the address of the result that will be filled/generated.; std::shared_ptr<int> GetResultPtr() const { return fFinalResult; }. // Called at the",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:67274,perform,perform,67274,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['perform'],['perform']
Performance,"prefix'; ///; /// ""macrofilename"" and optionally ""cutfilename"" are expected to point; /// to source files which will be included by the generated skeleton.; /// Method of the same name as the file(minus the extension and path); /// will be called by the generated skeleton's Process method as follow:; /// ~~~ {.cpp}; /// [if (cutfilename())] htemp->Fill(macrofilename());; /// ~~~; /// ""option"" can be used select some of the optional features during; /// the code generation. The possible options are:; ///; /// - nohist : indicates that the generated ProcessFill should not fill the histogram.; ///; /// 'maxUnrolling' controls how deep in the class hierarchy does the; /// system 'unroll' classes that are not split. Unrolling a class; /// allows direct access to its data members (this emulates the behavior; /// of TTreeFormula).; ///; /// The main features of this skeleton are:; ///; /// * on-demand loading of branches; /// * ability to use the 'branchname' as if it was a data member; /// * protection against array out-of-bounds errors; /// * ability to use the branch data as an object (when the user code is available); ///; /// For example with Event.root, if; /// ~~~ {.cpp}; /// Double_t somePx = fTracks.fPx[2];; /// ~~~; /// is executed by one of the method of the skeleton,; /// somePx will updated with the current value of fPx of the 3rd track.; ///; /// Both macrofilename and the optional cutfilename are expected to be; /// the name of source files which contain at least a free standing; /// function with the signature:; /// ~~~ {.cpp}; /// x_t macrofilename(); // i.e function with the same name as the file; /// ~~~; /// and; /// ~~~ {.cpp}; /// y_t cutfilename(); // i.e function with the same name as the file; /// ~~~; /// x_t and y_t needs to be types that can convert respectively to a double; /// and a bool (because the skeleton uses:; ///; /// if (cutfilename()) htemp->Fill(macrofilename());; ///; /// These two functions are run in a context such that the branch",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1518,load,loading,1518,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['load'],['loading']
Performance,"propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published in; // CUDA: Compiling and optimizing for a GPU platform; // Chakrabarti, Grover, Aarts, Kong, Kudlur, Lin, Marathe, Murphy, Wang; // ICCS 2012; //; // Then, address space inference replaces all refinable generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // which may create loops in the data flow graph. This brings two complications.; //; // First, the data flow analysis in Step 1 needs to be circular. For example,; // %generic.input = addrspacecast float addrspace(3)* %input to float*; // loop:; // %y = phi [ %generic.input, %y2 ]; // %y2 = getelementptr %y, 1; // %v = load %y2; // br ..., label %loop, ...; // proving %y specific requires proving both %generic.input and %y2 specific,; // but proving %y2 specific circles back to %y. To address this complication,; // the data flow analysis operates on a lattice:; // uninitialized > specific address spaces > generic.; // All address expressions (our implementation only considers phi, bitcast,; // addrspacecast, and getelementptr) start with the uninitialized address space.; // The monotone transfer function moves the address space of a pointer down a; // lattice path from uninitialized to specific and then to generic. A join; // operation of two different specific addre",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:2779,optimiz,optimization,2779,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,1,['optimiz'],['optimization']
Performance,"protocol changed; // 3 -> 4: introduction of multi-level-master support; // 4 -> 5: added friends support; // 5 -> 6: drop TFTP, support for asynchronous queries; // 6 -> 7: support for multisessions, archieve, retrieve, ...; // 7 -> 8: return number of entries in GetNextPacket; // 8 -> 9: support for stateless connection via xproofd; // 9 -> 10: new features requested, tested at CAF; // 10 -> 11: new merging strategy; // 11 -> 12: new progress message; // 12 -> 13: exchange version/architecture/compiler info; // 13 -> 14: new proofserv environment setting; // 14 -> 15: add support for entry lists; new version of TFileInfo; // 15 -> 16: add support for generic non-data based processing; // 16 -> 17: new dataset handling system; support for TFileCollection processing; // 17 -> 18: support for reconnection on daemon restarts; // 18 -> 19: TProofProgressStatus used in kPROOF_PROGRESS, kPROOF_STOPPROCESS; // and kPROOF_GETNEXTPACKET messages in Master - worker communication; // 19 -> 20: Fix the asynchronous mode (required changes in some messages); // 20 -> 21: Add support for session queuing; // 21 -> 22: Add support for switching from sync to async while running ('Ctrl-Z' functionality); // 22 -> 23: New dataset features (default tree name; classification per fileserver); // 23 -> 24: Merging optimization; // 24 -> 25: Handling of 'data' dir; group information; // 25 -> 26: Use new TProofProgressInfo class; // 26 -> 27: Use new file for updating the session status; // 27 -> 28: Support for multi-datasets, fix global pack dirs, fix AskStatistics,; // package download, dataset caching; // 28 -> 29: Support for config parameters in EnablePackage, idle-timeout; // 29 -> 30: Add information about data dir in TSlaveInfo; // 30 -> 31: Development cycle 5.29; // 31 -> 32: New log path trasmission; // 32 -> 33: Development cycle 5.29/04 (fixed worker activation, new startup technology, ...); // 33 -> 34: Development cycle 5.33/02 (fix load issue, ...); // 34 -> 35: Development",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h:1433,optimiz,optimization,1433,proof/proof/inc/TProof.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h,1,['optimiz'],['optimization']
Performance,"ption; //; //===----------------------------------------------------------------------===//; //; // Transform each threading path to effectively jump thread the DFA. For; // example, the CFG below could be transformed as follows, where the cloned; // blocks unconditionally branch to the next correct case based on what is; // identified in the analysis.; //; // sw.bb sw.bb; // / | \ / | \; // case1 case2 case3 case1 case2 case3; // \ | / | | |; // determinator det.2 det.3 det.1; // br sw.bb / | \; // sw.bb.2 sw.bb.3 sw.bb.1; // br case2 br case3 br case1§; //; // Definitions and Terminology:; //; // * Threading path:; // a list of basic blocks, the exit state, and the block that determines; // the next state, for which the following notation will be used:; // < path of BBs that form a cycle > [ state, determinator ]; //; // * Predictable switch:; // The switch variable is always a known constant so that all conditional; // jumps based on switch variable can be converted to unconditional jump.; //; // * Determinator:; // The basic block that determines the next state of the DFA.; //; // Representing the optimization in C-like pseudocode: the code pattern on the; // left could functionally be transformed to the right pattern if the switch; // condition is predictable.; //; // X = A goto A; // for (...) A:; // switch (X) ...; // case A goto B; // X = B B:; // case B ...; // X = C goto C; //; // The pass first checks that switch variable X is decided by the control flow; // path taken in the loop; for example, in case B, the next value of X is; // decided to be C. It then enumerates through all paths in the loop and labels; // the basic blocks where the next state is decided.; //; // Using this information it creates new paths that unconditionally branch to; // the next case. This involves cloning code, so it only gets triggered if the; // amount of code duplicated is below a threshold.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:1402,optimiz,optimization,1402,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,1,['optimiz'],['optimization']
Performance,"ptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements whole program optimization of virtual calls in cases; // where we know (via !type metadata) that the list of callees is fixed. This; // includes the following:; // - Single implementation devirtualization: if a virtual call has a single; // possible callee, replace all calls with a direct call to that callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass operates in two phases:; // - Export phase: this is run during the thin link over a single merged module; // that contains all vtables with !type metadata that",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:1086,optimiz,optimization,1086,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['optimiz'],['optimization']
Performance,"putations run here, upon first access to the result; ~~~; The filter string (which must contain a valid C++ expression) is applied to the specified columns for each event;; the name and types of the columns are inferred automatically. The string expression is required to return a `bool`; which signals whether the event passes the filter (`true`) or not (`false`). You can think of your data as ""flowing"" through the chain of calls, being transformed, filtered and finally used to; perform actions. Multiple Filter() calls can be chained one after another. Using string filters is nice for simple things, but they are limited to specifying the equivalent of a single return; statement or the body of a lambda, so it's cumbersome to use strings with more complex filters. They also add a small; runtime overhead, as ROOT needs to just-in-time compile the string into C++ code. When more freedom is required or; runtime performance is very important, a C++ callable can be specified instead (a lambda in the following snippet,; but it can be any kind of function or even a functor class), together with a list of column names.; This snippet is analogous to the one above:; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto metCut = [](double x) { return x > 4.; }; // a C++11 lambda function checking ""x > 4""; auto c = d.Filter(metCut, {""MET""}).Count();; std::cout << *c << std::endl;; ~~~. An example of a more complex filter expressed as a string containing C++ code is shown below. ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto df = d.Define(""p"", ""std::array<double, 4> p{px, py, pz}; return p;""); .Filter(""double p2 = 0.0; for (auto&& x : p) p2 += x*x; return sqrt(p2) < 10.0;"");; ~~~. The code snippet above defines a column `p` that is a fixed-size array using the component column names and then; filters on its magnitude by looping over its elements. It must be noted that the usage of strings to define columns; like the one above is currently the only possibility when using PyROO",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:19229,perform,performance,19229,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['perform'],['performance']
Performance,"r than histograms. The interpolation method, in short,; works as follows. - Given a p.d.f f1(x) with c.d.f F1(x) and p.d.f f2(x) with c.d.f F2(x). - One finds takes a value 'y' of both c.d.fs and determines the corresponding x; values x(1,2) at which F(1,2)(x)==y. - The value of the interpolated p.d.f fbar(x) is then calculated as; fbar(alpha*x1+(1-alpha)*x2) = f1(x1)*f2(x2) / ( alpha*f2(x2) + (1-alpha)*f1(x1) ) ;. From a technical point of view class RooIntegralMorph is a p.d.f that takes; two input p.d.fs f1(x,p) an f2(x,q) and an interpolation parameter to; make a p.d.f fbar(x,p,q,alpha). The shapes f1 and f2 are always taken; to be end the end-points of the parameter alpha, regardless of what; the those numeric values are. Since the value of fbar(x) cannot be easily calculated for a given value; of x, class RooIntegralMorph is an implementation of RooAbsCachedPdf and; calculates the shape of the interpolated p.d.f. fbar(x) for all values; of x for a given value of alpha,p,q and caches these values in a histogram; (as implemented by RooAbsCachedPdf). The binning granularity of the cache; can be controlled by the binning named ""cache"" on the RooRealVar representing; the observable x. The fbar sampling algorithm is based on a recursive division; mechanism with a built-in precision cutoff: First an initial sampling in; 64 equally spaced bins is made. Then the value of fbar is calculated in; the center of each gap. If the calculated value deviates too much from; the value obtained by linear interpolation from the edge bins, gap; is recursively divided. This strategy makes it possible to define a very; fine cache sampling (e.g. 1000 or 10000) bins without incurring a; corresponding CPU penalty. Note on numeric stability of the algorithm. Since the algorithm relies; on a numeric inversion of cumulative distributions functions, some precision; may be lost at the 'edges' of the same (i.e. at regions in x where the; c.d.f. value is close to zero or one). The general sampli",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx:1756,cache,caches,1756,roofit/roofit/src/RooIntegralMorph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx,1,['cache'],['caches']
Performance,"r the FFT calculation is extended in both directions,; /// and padded with the lowest/highest bin.; /// Example:; /// ```; /// original: -5 -4 -3 -2 -1 0 +1 +2 +3 +4 +5; /// add buffer zones: U U -5 -4 -3 -2 -1 0 +1 +2 +3 +4 +5 O O; /// rotate: 0 +1 +2 +3 +4 +5 O O U U -5 -4 -3 -2 -1; /// ```; /// The buffer bins are stripped away when the FFT output values; /// are transferred back to the p.d.f cache. The default buffer size is 10% of the; /// observable domain size, and can be changed with the `setBufferFraction()` member function.; ///; /// The RooFFTConvPdf uses caching inherited from a RooAbsCachedPdf. If it is; /// evaluated for a particular value of x, the FFT and convolution is calculated; /// for all bins in the observable space for the given choice of parameters,; /// which are also stored in the cache. Subsequent evaluations for different values of the convolution observable and; /// identical parameters will be retrieved from the cache. If one or more; /// of the parameters change, the cache will be updated, *i.e.*, a new FFT runs.; ///; /// The sampling density of the FFT is controlled by the binning of the; /// the convolution observable, which can be changed using RooRealVar::setBins(N).; /// For good results, N should be large (>=1000). Additional interpolation; /// between the bins may improve the result if coarse binnings are chosen. These can be; /// activated in the constructor or by calling `setInterpolationOrder()`.; /// For N >> 1000, interpolation will not substantially improve the accuracy.; ///; /// Additionial information on caching can be displayed by monitoring; /// the message stream with topic ""Caching"" at the INFO level, *i.e.*; /// by calling `RooMsgService::instance().addStream(RooMsgService::INFO,Topic(""Caching""))`; /// to see these message on stdout.; ///; /// Multi-dimensional convolutions are not supported at the moment.; ///; /// ---; ///; /// Installing an external version of FFTW on Linux and compiling ROOT to use it; /// ----",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:3339,cache,cache,3339,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['cache'],['cache']
Performance,"r-Discriminant implementation: *; * Andre Gaidot, CEA-France; *; * (Translation from FORTRAN) *; * *; * Authors (alphabetical): *; * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; * Xavier Prudent <prudent@lapp.in2p3.fr> - LAPP, France *; * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; * *; * Copyright (c) 2005: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * LAPP, Annecy, France *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; /*! \class TMVA::MethodFisher; \ingroup TMVA. Fisher and Mahalanobis Discriminants (Linear Discriminant Analysis). In the method of Fisher discriminants event selection is performed; in a transformed variable space with zero linear correlations, by; distinguishing the mean values of the signal and background; distributions. The linear discriminant analysis determines an axis in the (correlated); hyperspace of the input variables; such that, when projecting the output classes (signal and background); upon this axis, they are pushed as far as possible away from each other,; while events of a same class are confined in a close vicinity.; The linearity property of this method is reflected in the metric with; which ""far apart"" and ""close vicinity"" are determined: the covariance; matrix of the discriminant variable space. The classification of the events in signal and background classes; relies on the following characteristics (only): overall sample means, \f$ x_i \f$,; for each input variable, \f$ i \f$,; class-specific sample means, \f$ x_{S(B),i}\f$,; and total covariance matrix \f$ T_{ij} \f$. The covariance matrix; can be decomposed into the sum of a _within_ (\f$ W_{ij} \f$); and a _between-class_ (\f",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodFisher.cxx:1378,perform,performed,1378,tmva/tmva/src/MethodFisher.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodFisher.cxx,1,['perform'],['performed']
Performance,"r. The find(), insert(), and erase(); /// operations are all constant time, and typically faster than a hash table.; /// The iteration order doesn't depend on numerical key values, it only depends; /// on the order of insert() and erase() operations. Iteration order is the; /// insertion order. Iteration is only provided over elements of equivalent; /// keys, but iterators are bidirectional.; ///; /// Compared to BitVector, SparseMultiSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast iteration; /// independent on the size of the universe.; ///; /// SparseMultiSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT template; /// parameter provides a space/speed tradeoff for sets holding many elements.; ///; /// When SparseT is uint32_t, find() only touches up to 3 cache lines, but the; /// sparse array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 3+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// Multiset behavior is provided by providing doubly linked lists for values; /// that are inlined in the dense vector. SparseMultiSet is a good choice when; /// one desires a growable number of entries per key, as it will retain the; /// SparseSet algorithmic properties despite being growable. Thus, it is often a; /// better choice than a SparseSet of growable containers or a vector of; /// vectors. SparseMultiSet also keeps iterators valid after erasure (provided; /// the iterators don't point to the element erased), allowing for more; /// intuitive and fast removal.; ///; /// @tparam ValueT The type of objects in the set.; /// ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:1456,cache,cache,1456,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,1,['cache'],['cache']
Performance,"rallelized, but the different loops run sequentially, one after the other.; On many-core architectures it might be desirable to run different event loops concurrently to improve resource usage.; ROOT::RDF::RunGraphs() allows running multiple RDataFrame event loops concurrently:; ~~~{.cpp}; ROOT::EnableImplicitMT();; ROOT::RDataFrame df1(""tree1"", ""f1.root"");; ROOT::RDataFrame df2(""tree2"", ""f2.root"");; auto histo1 = df1.Histo1D(""x"");; auto histo2 = df2.Histo1D(""y"");. // just accessing result pointers, the event loops of separate RDataFrames run one after the other; histo1->Draw(); // runs first multi-thread event loop; histo2->Draw(); // runs second multi-thread event loop. // alternatively, with ROOT::RDF::RunGraphs, event loops for separate computation graphs can run concurrently; ROOT::RDF::RunGraphs({histo1, histo2});; histo1->Draw(); // results can then be used as usual; ~~~. ### Performance considerations. To obtain the maximum performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; should be preferred for performance-critical applications. Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case. Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated u",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:51456,perform,performance,51456,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['perform'],['performance']
Performance,"range; * 0..MAXJSAMPLE; the input value may fall somewhat outside this range; * due to noise introduced by quantization, roundoff error, etc. These; * processes are inner loops and need to be as fast as possible. On most; * machines, particularly CPUs with pipelines or instruction prefetch,; * a (subscript-check-less) C table lookup; *		x = sample_range_limit[x];; * is faster than explicit tests; *		if (x < 0) x = 0;; *		else if (x > MAXJSAMPLE) x = MAXJSAMPLE;; * These processes all use a common table prepared by the routine below.; *; * For most steps we can mathematically guarantee that the initial value; * of x is within MAXJSAMPLE+1 of the legal range, so a table running from; * -(MAXJSAMPLE+1) to 2*MAXJSAMPLE+1 is sufficient. But for the initial; * limiting step (just after the IDCT), a wildly out-of-range value is ; * possible if the input data is corrupt. To avoid any chance of indexing; * off the end of memory and getting a bad-pointer trap, we perform the; * post-IDCT limiting thus:; *		x = range_limit[x & MASK];; * where MASK is 2 bits wider than legal sample data, ie 10 bits for 8-bit; * samples. Under normal circumstances this is more than enough range and; * a correct output will be generated; with bogus input data the mask will; * cause wraparound, and we will safely generate a bogus-but-in-range output.; * For the post-IDCT step, we want to convert the data from signed to unsigned; * representation by adding CENTERJSAMPLE at the same time that we limit it.; * So the post-IDCT limiting table ends up looking like this:; * CENTERJSAMPLE,CENTERJSAMPLE+1,...,MAXJSAMPLE,; * MAXJSAMPLE (repeat 2*(MAXJSAMPLE+1)-CENTERJSAMPLE times),; * 0 (repeat 2*(MAXJSAMPLE+1)-CENTERJSAMPLE times),; * 0,1,...,CENTERJSAMPLE-1; * Negative inputs select values from the upper half of the table after; * masking.; *; * We can save some space by overlapping the start of the post-IDCT table; * with the simpler range limiting table. The post-IDCT table begins at; * sample_range_lim",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c:1040,perform,perform,1040,graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c,1,['perform'],['perform']
Performance,"ransposes of the four 2x2 matrices that form the 2x8.; // For example, with the inputs as above, the result will be:; // 0 8 2 A 4 C 6 E; // 1 9 3 B 5 D 7 F; // Now, this result can be tranposed again, but with the group size of 2:; // 08 19 4C 5D; // 2A 3B 6E 7F; // If we then transpose that result, but with the group size of 4, we get:; // 0819 2A3B; // 4C5D 6E7F; // If we concatenate these two rows, it will be; // 0 8 1 9 2 A 3 B 4 C 5 D 6 E 7 F; // which is the same as the ""deal"" [*] above.; //; // In general, a ""deal"" of individual elements is a series of 2x2 transposes,; // with changing group size. HVX has two instructions:; // Vdd = V6_vdealvdd Vu, Vv, Rt; // Vdd = V6_shufvdd Vu, Vv, Rt; // that perform exactly that. The register Rt controls which transposes are; // going to happen: a bit at position n (counting from 0) indicates that a; // transpose with a group size of 2^n will take place. If multiple bits are; // set, multiple transposes will happen: vdealvdd will perform them starting; // with the largest group size, vshuffvdd will do them in the reverse order.; //; // The main observation is that each 2x2 transpose corresponds to swapping; // columns of bits in the binary representation of the values.; //; // The numbers {3,2,1,0} and the log2 of the number of contiguous 1 bits; // in a given column. The * denote the columns that will be swapped.; // The transpose with the group size 2^n corresponds to swapping columns; // 3 (the highest log) and log2(n):; //; // 3 2 1 0 0 2 1 3 0 2 3 1; // * * * * * *; // 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; // 1 0 0 0 1 8 1 0 0 0 8 1 0 0 0 8 1 0 0 0; // 2 0 0 1 0 2 0 0 1 0 1 0 0 0 1 1 0 0 0 1; // 3 0 0 1 1 A 1 0 1 0 9 1 0 0 1 9 1 0 0 1; // 4 0 1 0 0 4 0 1 0 0 4 0 1 0 0 2 0 0 1 0; // 5 0 1 0 1 C 1 1 0 0 C 1 1 0 0 A 1 0 1 0; // 6 0 1 1 0 6 0 1 1 0 5 0 1 0 1 3 0 0 1 1; // 7 0 1 1 1 E 1 1 1 0 D 1 1 0 1 B 1 0 1 1; // 8 1 0 0 0 1 0 0 0 1 2 0 0 1 0 4 0 1 0 0; // 9 1 0 0 1 9 1 0 0 1 A 1 0 1 0 C 1 1 0 0; // A 1 0 1 0 3 0 0 ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:2293,perform,perform,2293,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['perform'],['perform']
Performance,"rarchy defined by nodes and volumes. The expansion of the logical graph by; all possible paths defines a tree structure where all nodes are unique; ""touchable"" objects. We will call this the ""physical tree"". Unlike the logical; graph, the physical tree can become a huge structure with several milions of nodes; in case of complex geometries, therefore it is not always a good idea to keep it; transient in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retrieved for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. ~~~ {.cpp}; TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);; ~~~. The creation of overlapping nodes can be done with a similar prototype:. ~~~ {.cpp}; TGeoVolume::AddNodeOverlap(same arguments);; ~~~. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. \image html geom_t_node.png; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNode.cxx:3082,perform,perform,3082,geom/geom/src/TGeoNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNode.cxx,1,['perform'],['perform']
Performance,"rce of confusion is that trees that are written out from a multi-thread Snapshot() call will have their; entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original; one: rows will be mismatched. Indexed friend trees provide a way to perform simple joins of multiple trees over a common column.; When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the; ""index"" columns have a value identical to the one in the main one. For example, in Python:. ~~~{.py}; main_tree = ...; aux_tree = ... # If a friend tree has an index on `commonColumn`, when the main tree loads; # a given row, it also loads the row of the friend tree that has the same; # value of `commonColumn`; aux_tree.BuildIndex(""commonColumn""). mainTree.AddFriend(aux_tree). df = ROOT.RDataFrame(mainTree); ~~~. RDataFrame supports indexed friend TTrees from ROOT v6.24 in single-thread mode and from v6.28/02 in multi-thread mode. \anchor other-file-formats; ### Reading data formats other than ROOT trees; RDataFrame can be interfaced with RDataSources. The ROOT::RDF::RDataSource interface defines an API that RDataFrame can use to read arbitrary columnar data formats. RDataFrame calls into concrete RDataSource implementations to retrieve information about the data, retrieve (thread-local) readers or ""cursors"" for selected columns; and to advance the readers to the desired data entry.; Some predefined RDataSources are natively provided by ROOT such as the ROOT::RDF::RCsvDS which allows to read comma separated files:; ~~~{.cpp}; auto tdf = ROOT::RDF::FromCSV(""MuRun2010B.csv"");; auto filteredEvents =; tdf.Filter(""Q1 * Q2 == -1""); .Define(""m"", ""sqrt(pow(E1 + E2, 2) - (pow(px1 + px2, 2) + pow(py1 + py2, 2) + pow(pz1 + pz2, 2)))"");; auto h = filteredEvents.Histo1D(""m"");; h->Draw();; ~~~. See also FromNumpy (Python-only), FromRNTuple(), FromArrow(), FromSqlite(). \anchor callgraphs; ### Computation graphs ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:73831,multi-thread,multi-thread,73831,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['multi-thread'],['multi-thread']
Performance,"rchy: Used to describe 3D objects; (""shapes""); - filled /added by negotiation with viewer via TVirtualViewer3D. Together these allow clients to publish objects to any one of the 3D viewers; (currently OpenGL/x3d,TPad), free of viewer specific drawing code. They allow; our simple x3d viewer, and considerably more sophisticated OpenGL one to both; work with both geometry libraries (g3d and geom) efficiently. Publishing to a viewer consists of the following steps:. 1. Create / obtain viewer handle; 2. Begin scene on viewer; 3. Fill mandatory parts of TBuffer3D describing object; 4. Add to viewer; 5. Fill optional parts of TBuffer3D if requested by viewer, and add again; ... repeat 3/4/5 as required; 6. End scene on viewer. ## Creating / Obtaining Viewer. Create/obtain the viewer handle via local/global pad - the viewer is always; bound to a TPad object at present [This may be removed as a restriction in; the future] . You should perform the publishing to the viewer described below; in the Paint() method of the object you attach to the pad (via Draw()); ~~~ {.cpp}; TVirtualViewer3D * v = gPad->GetViewer3D(""xxxx"");; ~~~. "" xxxx"" is viewer type: OpenGL ""ogl"", X3D ""x3d"" or; Pad ""pad"" (default). The viewer is created via the plugin manager,; attached to pad, and the interface returned. ## Begin / End Scene. Objects must be added to viewer between BeginScene/EndScene calls e.g.; ~~~ {.cpp}; v->BeginScene();; .....; v->AddObject(....);; v->AddObject(....);; .....; v->EndScene();; ~~~. The BeginScene call will cause the viewer to suspend redraws etc, and after; the EndScene the viewer will reset the camera to frame the new scene and redraw.; [x3d viewer does not support changing of scenes - objects added after the; first Open/CloseScene pair will be ignored.]. ## Filling TBuffer3D and Adding to Viewer. The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. - Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - ot",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualViewer3D.cxx:1792,perform,perform,1792,core/base/src/TVirtualViewer3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualViewer3D.cxx,1,['perform'],['perform']
Performance,"re no; /// stores nor barriers in between the two loads.; /// 2) An younger store is not allowed to pass an older store.; /// 3) A younger store is not allowed to pass an older load.; /// 4) A younger load is allowed to pass an older store only if the load does; /// not alias with the store.; ///; /// This class optimistically assumes that loads don't alias store operations.; /// Under this assumption, younger loads are always allowed to pass older; /// stores (this would only affects rule 4).; /// Essentially, this class doesn't perform any sort alias analysis to; /// identify aliasing loads and stores.; ///; /// To enforce aliasing between loads and stores, flag `AssumeNoAlias` must be; /// set to `false` by the constructor of LSUnit.; ///; /// Note that this class doesn't know about the existence of different memory; /// types for memory operations (example: write-through, write-combining, etc.).; /// Derived classes are responsible for implementing that extra knowledge, and; /// provide different sets of rules for loads and stores by overriding method; /// `isReady()`.; /// To emulate a write-combining memory type, rule 2. must be relaxed in a; /// derived class to enable the reordering of non-aliasing store operations.; ///; /// No assumptions are made by this class on the size of the store buffer. This; /// class doesn't know how to identify cases where store-to-load forwarding may; /// occur.; ///; /// LSUnit doesn't attempt to predict whether a load or store hits or misses; /// the L1 cache. To be more specific, LSUnit doesn't know anything about; /// cache hierarchy and memory types.; /// It only knows if an instruction ""mayLoad"" and/or ""mayStore"". For loads, the; /// scheduling model provides an ""optimistic"" load-to-use latency (which usually; /// matches the load-to-use latency for when there is a hit in the L1D).; /// Derived classes may expand this knowledge.; ///; /// Class MCInstrDesc in LLVM doesn't know about serializing operations, nor; /// memory-b",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:1270,load,loads,1270,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,1,['load'],['loads']
Performance,"re than; /// zero/one argument but all are fixed except zero/one, the function can be wrapped; /// in a lambda or via std::bind to give it the right signature.\n; ///; /// #### Return value:; /// An std::vector. The elements in the container; /// will be the objects returned by func.; ///; ///; /// #### Examples:; ///; /// ~~~{.cpp}; /// root[] ROOT::TThreadExecutor pool; auto hists = pool.Map(CreateHisto, 10);; /// root[] ROOT::TThreadExecutor pool(2); auto squares = pool.Map([](int a) { return a*a; }, {1,2,3});; /// ~~~; ///; /// ### ROOT::TThreadExecutor::MapReduce; /// This set of methods behaves exactly like Map, but takes an additional; /// function as a third argument. This function is applied to the set of; /// objects returned by the corresponding Map execution to ""squash"" them; /// into a single object. This function should be independent of the size of; /// the vector returned by Map due to optimization of the number of chunks.; ///; /// If this function is a binary operator, the ""squashing"" will be performed in parallel.; /// This is exclusive to ROOT::TThreadExecutor and not any other ROOT::TExecutorCRTP-derived classes.\n; ///; /// An integer can be passed as the fourth argument indicating the number of chunks we want to divide our work in.; /// This may be useful to avoid the overhead introduced when running really short tasks.; ///; /// #### Examples:; /// ~~~{.cpp}; /// root[] ROOT::TThreadExecutor pool; auto ten = pool.MapReduce([]() { return 1; }, 10, [](const std::vector<int> &v) { return std::accumulate(v.begin(), v.end(), 0); }); /// root[] ROOT::TThreadExecutor pool; auto hist = pool.MapReduce(CreateAndFillHists, 10, PoolUtils::ReduceObjects);; /// ~~~; ///; //////////////////////////////////////////////////////////////////////////; /*; VERY IMPORTANT NOTE ABOUT WORK ISOLATION. We enclose the parallel_for and parallel_reduce invocations in a; task_arena::isolate because we want to prevent a thread to start executing an; outer task when the tas",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/TThreadExecutor.cxx:3075,perform,performed,3075,core/imt/src/TThreadExecutor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/TThreadExecutor.cxx,1,['perform'],['performed']
Performance,"rect copy of the raw; /// bytes on disk).; ///; /// When 'fast' is specified, 'option' can also contains a; /// sorting order for the baskets in the output file.; ///; /// There is currently 3 supported sorting order:; /// ~~~ {.cpp}; /// SortBasketsByOffset (the default); /// SortBasketsByBranch; /// SortBasketsByEntry; /// ~~~; /// When using SortBasketsByOffset the baskets are written in; /// the output file in the same order as in the original file; /// (i.e. the basket are sorted on their offset in the original; /// file; Usually this also means that the baskets are sorted; /// on the index/number of the _last_ entry they contain); ///; /// When using SortBasketsByBranch all the baskets of each; /// individual branches are stored contiguously. This tends to; /// optimize reading speed when reading a small number (1->5) of; /// branches, since all their baskets will be clustered together; /// instead of being spread across the file. However it might; /// decrease the performance when reading more branches (or the full; /// entry).; ///; /// When using SortBasketsByEntry the baskets with the lowest; /// starting entry are written first. (i.e. the baskets are; /// sorted on the index/number of the first entry they contain).; /// This means that on the file the baskets will be in the order; /// in which they will be needed when reading the whole tree; /// sequentially.; ///; /// ## IMPORTANT Note 1: AUTOMATIC FILE OVERFLOW; ///; /// When merging many files, it may happen that the resulting file; /// reaches a size > TTree::fgMaxTreeSize (default = 100 GBytes).; /// In this case the current file is automatically closed and a new; /// file started. If the name of the merged file was ""merged.root"",; /// the subsequent files will be named ""merged_1.root"", ""merged_2.root"",; /// etc. fgMaxTreeSize may be modified via the static function; /// TTree::SetMaxTreeSize.; /// When in fast mode, the check and switch is only done in between each; /// input file.; ///; /// ## IMPO",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:2632,perform,performance,2632,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['perform'],['performance']
Performance,"redirection stuff, etc.; *; * READ THE UNIX98 SPEC on ""Shell Command Language"" before changing; * the behavior of this code.; *; * Steps to parsing the argv string:; *; * - tokenize the string (but since we ignore operators,; * our tokenization may diverge from what the shell would do); * note that tokenization ignores the internals of a quoted; * word and it always splits on spaces, not on IFS even; * if we used IFS. We also ignore ""end of input indicator""; * (I guess this is control-D?); *; * Tokenization steps, from UNIX98 with operator stuff removed,; * are:; * ; * 1) ""If the current character is backslash, single-quote or; * double-quote (\, ' or "") and it is not quoted, it will affect; * quoting for subsequent characters up to the end of the quoted; * text. The rules for quoting are as described in Quoting; * . During token recognition no substitutions will be actually; * performed, and the result token will contain exactly the; * characters that appear in the input (except for newline; * character joining), unmodified, including any embedded or; * enclosing quotes or substitution operators, between the quote; * mark and the end of the quoted text. The token will not be; * delimited by the end of the quoted field.""; *; * 2) ""If the current character is an unquoted newline character,; * the current token will be delimited.""; *; * 3) ""If the current character is an unquoted blank character, any; * token containing the previous character is delimited and the; * current character will be discarded.""; *; * 4) ""If the previous character was part of a word, the current; * character will be appended to that word.""; *; * 5) ""If the current character is a ""#"", it and all subsequent; * characters up to, but excluding, the next newline character; * will be discarded as a comment. The newline character that; * ends the line is not considered part of the comment. The; * ""#"" starts a comment only when it is at the beginning of a; * token. Since the search for the end-of-comm",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gshell.c:1214,perform,performed,1214,graf2d/win32gdk/gdk/src/glib/gshell.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gshell.c,1,['perform'],['performed']
Performance,"reeCache can be; instructed about the branches which will be read via explicit calls to the TTree; or TTreeCache interfaces.; In less streamlined applications such as analysis, predicting the branches which; will be read can be difficult. In such cases, ROOT I/O flags used branches; automatically when a branch buffer is read during the learning phase. In the examples below, portions of analysis code are shown.; The few statements involving the TreeCache are marked with `//<<<`. ### ROOT::RDataFrame and TTreeReader Examples. If you use RDataFrame or TTreeReader, the system will automatically cache the; best set of branches: no action is required by the user. ### TTree::Draw Example. The TreeCache is automatically used by TTree::Draw. The method knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also inferred automatically. ### TTree::Process and TSelectors Examples. The user must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case only a subset of the events is processed to avoid wasteful caching. #### Reading all branches. ~~~ {.cpp}; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; ~~~. #### Reading a subset of all branches. In the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; ~~~ {.cpp}; TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=200UL;; auto efirst = 0;; auto elast = efirst+nentries;; auto cachesize = 10000000U; // 10 MBytes; TTreeCache::SetLearnEntries(1); //<<< ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:7160,cache,cache,7160,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['cache'],['cache']
Performance,"res are drawn instead of boxes.|. \anchor HP29c; #### TH3 as iso-surface(s). The supported option is:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""GLISO"" | TH3 is drawn using iso-surfaces.|. \anchor HP29d; #### TF3 (implicit function). The supported option is:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""GL"" | Draw a TF3.|. \anchor HP29e; #### Parametric surfaces. `$ROOTSYS/tutorials/gl/glparametric.C` shows how to create parametric; equations and visualize the surface. \anchor HP29f; #### Interaction with the plots. All the interactions are implemented via standard methods; `DistancetoPrimitive()` and `ExecuteEvent()`. That's why all the; interactions with the OpenGL plots are possible only when the mouse cursor is; in the plot's area (the plot's area is the part of a the pad occupied by; gl-produced picture). If the mouse cursor is not above gl-picture, the standard; pad interaction is performed. \anchor HP29g; #### Selectable parts. Different parts of the plot can be selected:. - xoz, yoz, xoy back planes: When such a plane selected, it's highlighted in green; if the dynamic slicing by this plane is supported, and it's highlighted in red,; if the dynamic slicing is not supported.; - The plot itself:; On surfaces, the selected surface is outlined in red. (TF3 and; ISO are not outlined). On lego plots, the selected bin is; highlighted. The bin number and content are displayed in pad's; status bar. In box plots, the box or sphere is highlighted and; the bin info is displayed in pad's status bar. \anchor HP29h; #### Rotation and zooming. - Rotation:; When the plot is selected, it can be rotated by pressing and; holding the left mouse button and move the cursor.; - Zoom/Unzoom:; Mouse wheel or 'j', 'J', 'k', 'K' keys. \anchor HP29i; #### Panning. The selected plot can be moved in a pad's area by pressing and; holding the left mouse butto",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:102152,perform,performed,102152,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['perform'],['performed']
Performance,"ress the mouse; and drag the mouse while holding the left button pressed.; To select a word, double-click on it;; to select the text line - triple-click on it;; to select all do quadruple-click. #### Cut, Copy, Paste. After selecting some text, you can cut or copy it to the clipboard.; A subsequent paste operation will insert the contents of the; clipboard at the current cursor location. #### Text Search. The editor uses a standard Search dialog. You can specify a forward; or backward search direction starting from the current cursor; location according to the selection made of a case sensitive mode; or not. The last search can be repeated by pressing F3. #### Text Font. You can change the text font by selecting Edit menu / Set Font.; The Font Dialog pops up and shows the Name, Style, and Size of any; available font. The selected font sample is shown in the preview; area. #### Executing Macros. You can execute the currently loaded macro in the editor by; selecting Tools menu / Execute Macro; by clicking on the; corresponding toolbar button, or by using Ctrl+F5 accelerator keys.; This is identical to the command "".x macro.C"" in the root prompt; command line. #### Compiling Macros. The currently loaded macro can be compiled with ACLiC if you select; Tools menu / Compile Macro; by clicking on the corresponding; toolbar button, or by using Ctrl+F7 accelerator keys.; This is identical to the command "".L macro.C++"" in the root prompt; command line. #### Interrupting a Running Macro. You can interrupt a running macro by selecting the Tools menu /; Interrupt; by clicking on the corresponding toolbar button, or by; using Shift+F5 accelerator keys. #### Interface to CINT Interpreter. Any command entered in the Command combo box will be passed to; the CINT interpreter. This combo box will keep the commands history; and will allow you to re-execute the same commands during an editor; session. #### Keyboard Bindings. The following table lists the keyboard shortcuts and accelerato",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEditor.cxx:3226,load,loaded,3226,gui/gui/src/TGTextEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEditor.cxx,1,['load'],['loaded']
Performance,"rformance at; the price of a modest investment in memory, in particular when the TTree is; accessed remotely, e.g. via a high latency network. For each TTree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted.; The user can change the size of the cache with the TTree::SetCacheSize method; (by default the size is 30 Megabytes). This feature can be controlled with the; environment variable `ROOT_TTREECACHE_SIZE` or the TTreeCache.Size option.; The entry range for which the cache is active can also be set with the; SetEntryRange method. \anchor changesbehaviour; ## Changes of behavior when using TChain and TEventList. The usage of TChain or TEventList have influence on the behaviour of the cache:. - Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. - Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning phase is started or restarted when:; - TTree automatically creates a cache.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTreeCache::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; - TTreeCache::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries.; - A 'cached' TChain switches over to a new file. \anchor cachemisses; ## Self-optimization in presence of cache misses. The TTreeCache can optimize its behavior on a cache miss. When; miss optimization is enabled (see the SetOptimizeMisses method),; it tracks all branches utilized after the learnin",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:4024,cache,cache,4024,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"rger window. windowBits can also be zero to request that inflate use the window size in; the zlib header of the compressed stream. windowBits can also be -8..-15 for raw inflate. In this case, -windowBits; determines the window size. inflate() will then process raw deflate data,; not looking for a zlib or gzip header, not generating a check value, and not; looking for any check values for comparison at the end of the stream. This; is for use with other formats that use the deflate compressed data format; such as zip. Those formats provide their own check values. If a custom; format is developed using the raw deflate format for compressed data, it is; recommended that a check value such as an adler32 or a crc32 be applied to; the uncompressed data as is done in the zlib, gzip, and zip formats. For; most applications, the zlib format should be used as is. Note that comments; above on the use in deflateInit2() applies to the magnitude of windowBits. windowBits can also be greater than 15 for optional gzip decoding. Add; 32 to windowBits to enable zlib and gzip decoding with automatic header; detection, or add 16 to decode only the gzip format (the zlib format will; return a Z_DATA_ERROR). If a gzip stream is being decoded, strm->adler is a; crc32 instead of an adler32. inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_VERSION_ERROR if the zlib library version is incompatible with the; version assumed by the caller, or Z_STREAM_ERROR if the parameters are; invalid, such as a null pointer to the structure. msg is set to null if; there is no error message. inflateInit2 does not perform any decompression; apart from possibly reading the zlib header if present: actual decompression; will be done by inflate(). (So next_in and avail_in may be modified, but; next_out and avail_out are unused and unchanged.) The current implementation; of inflateInit2() does not process any header information -- that is; deferred until inflate() is called.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:3626,perform,perform,3626,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['perform'],['perform']
Performance,"ributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //________________________________________________________________________; //; // Class for xml code generation; // It should be used for generation of xml streamers, which could be used outside root; // environment. This means, that with help of such streamers user can read and write; // objects from/to xml file, which later can be accepted by ROOT.; //; // At the moment supported only classes, which are not inherited from TObject; // and which not contains any TObject members.; //; // To generate xml code:; //; // 1. ROOT library with required classes should be created.; // In general, without such library non of user objects can be stored and; // retrieved from any ROOT file; //; // 2. Generate xml streamers by root script like:; //; // void generate() {; // gSystem->Load(""libRXML.so""); // load ROOT xml library; // gSystem->Load(""libuser.so""); // load user ROOT library; //; // TList lst;; // lst.Add(TClass::GetClass(""TUserClass1""));; // lst.Add(TClass::GetClass(""TUserClass2""));; // ...; // TXMLPlayer player;; // player.ProduceCode(&lst, ""streamers""); // create xml streamers; // }; //; // 3. Copy ""streamers.h"", ""streamers.cxx"", ""TXmlFile.h"", ""TXmlFile.cxx"" files; // to user project and compile them. TXmlFile class implementation can be taken; // from http://web-docs.gsi.de/~linev/xmlfile.tar.gz; //; // TXMLPlayer class generates one function per class, which called class streamer.; // Name of such function for class TExample will be TExample_streamer.; //; // Following data members for streamed classes are supported:; // - simple data types (int, double, float); // - array of simple types (int[5], double[5][6]); // - dynamic array of simple types (int* with comment field // [fSize]); // - const char*; // - object of any nonROOT class; // - pointer on object; // - array of objects; // - array of pointers on objects; // - stl string; // - stl vector, ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/xml/src/TXMLPlayer.cxx:1290,load,load,1290,io/xml/src/TXMLPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/xml/src/TXMLPlayer.cxx,1,['load'],['load']
Performance,"riginal approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push; // the children nodes to the queue via `static bool; // IsStructurallyEquivalent(StructuralEquivalenceContext &Context, Decl *D1,; // Decl *D2)`. So far so good, this is almost like the BFS. However, if we; // let a static implementation function to call `Finish` via another **member**; // function that means we end up with two nested while loops each of them; // working on the same queue. This is wrong and nobody can reason about it's; // doing. Thus, static implementation functions must not call the **member**; // functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:2032,queue,queue,2032,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,2,['queue'],['queue']
Performance,"ring is the preorder of the nodes. Since the; /// Twine can be efficiently rendered into a buffer when its result is used,; /// it avoids the cost of generating temporary values for intermediate string; /// results -- particularly in cases when the Twine result is never; /// required. By explicitly tracking the type of leaf nodes, we can also avoid; /// the creation of temporary strings for conversions operations (such as; /// appending an integer to a string).; ///; /// A Twine is not intended for use directly and should not be stored, its; /// implementation relies on the ability to store pointers to temporary stack; /// objects which may be deallocated at the end of a statement. Twines should; /// only be used as const references in arguments, when an API wishes; /// to accept possibly-concatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: Why):; /// - Nullary twines are always represented with their Kind on the left-hand; /// side, and the Empty kind on the right-hand side.; /// - Unary twines are always represented with the value on the left-hand; /// side, and the Empt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:1264,perform,performed,1264,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,1,['perform'],['performed']
Performance,"rk's fix to a comment.; c10.5 14 Dec 92 M. Adler fix up error messages for incomplete trees.; c11 2 Jan 93 M. Adler fixed bug in detection of incomplete; tables, and removed assumption that EOB is; the longest code (bad assumption).; c12 3 Jan 93 M. Adler make tables for fixed blocks only once.; c13 5 Jan 93 M. Adler allow all zero length codes (pkzip 2.04c; outputs one zero length code for an empty; distance tree).; c14 12 Mar 93 M. Adler made inflate.c standalone with the; introduction of inflate.h.; c14b 16 Jul 93 G. Roelofs added (unsigned) typecast to w at 470.; c14c 19 Jul 93 J. Bush changed v[N_MAX], l[288], ll[28x+3x] arrays; to static for Amiga.; c14d 13 Aug 93 J-l. Gailly de-complicatified Mark's c[*p++]++ thing.; c14e 8 Oct 93 G. Roelofs changed memset() to memzero().; c14f 22 Oct 93 G. Roelofs renamed quietflg to qflag; made Trace(); conditional; added inflate_free().; c14g 28 Oct 93 G. Roelofs changed l/(lx+1) macro to pointer (Cray bug); c14h 7 Dec 93 C. Ghisler huft_build() optimizations.; c14i 9 Jan 94 A. Verheijen set fixed_t{d,l} to NULL after freeing;; G. Roelofs check NEXTBYTE macro for EOF.; c14j 23 Jan 94 G. Roelofs removed Ghisler ""optimizations""; ifdef'd; EOF check.; c14k 27 Feb 94 G. Roelofs added some typecasts to avoid warnings.; c14l 9 Apr 94 G. Roelofs fixed split comments on preprocessor lines; to avoid bug in Encore compiler.; c14m 7 Jul 94 P. Kienitz modified to allow assembler version of; inflate_codes() (define ASM_INFLATECODES); c14n 22 Jul 94 G. Roelofs changed fprintf to FPRINTF for DLL versions; c14o 23 Aug 94 C. Spieler added a newline to a debug statement;; G. Roelofs added another typecast to avoid MSC warning; */; /*; Inflate deflated (PKZIP's method 8 compressed) data. The compression; method searches for as much of the current string of bytes (up to a; length of 258) in the previous 32K bytes. If it doesn't find any; matches (of at least length 3), it codes the next byte. Otherwise, it; codes the length of the matched stri",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZInflate.c:3132,optimiz,optimizations,3132,core/zip/src/ZInflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZInflate.c,1,['optimiz'],['optimizations']
Performance,"rmat off; /// Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result.; ///; /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; ///; /// See `OnPartialResult` for a generic explanation of the callback mechanism.; /// Compared to `OnPartialResult`, this method has two major differences:; /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; /// callback concurrently but always with different `slot` numbers.; /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; ///; /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; /// \code; /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; /// std::string progress;; /// std::mutex bar_mutex;; /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; /// std::lock_guard<std::mutex> lg(bar_mutex);; /// progress.push_back('#');; /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; /// });; /// std::cout << ""Analysis running..."" << std::endl;; /// *c; // trigger the event loop by accessing an action's result; /// std::cout << ""\nDone!"" << std::endl;; /// \endcode; // clang-format o",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:963,multi-thread,multi-thread,963,tree/dataframe/inc/ROOT/RResultPtr.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx,2,"['concurren', 'multi-thread']","['concurrently', 'multi-thread']"
Performance,"roach and will work in academic; * environments where everything is done by the book. It has the shortcoming; * of assuming that input PNG data with no gamma information is linear - this; * is unlikely to be correct unless the PNG files where generated locally.; * Most of the time the output precision will be so low as to show; * significant banding in dark areas of the image.; *; * png_set_expand_16(pp);; * png_set_alpha_mode(pp, PNG_ALPHA_STANDARD, PNG_DEFAULT_sRGB);; * This is a somewhat more realistic Jim Blinn inspired approach. PNG files; * are assumed to have the sRGB encoding if not marked with a gamma value and; * the output is always 16 bits per component. This permits accurate scaling; * and processing of the data. If you know that your input PNG files were; * generated locally you might need to replace PNG_DEFAULT_sRGB with the; * correct value for your system.; *; * png_set_alpha_mode(pp, PNG_ALPHA_OPTIMIZED, PNG_DEFAULT_sRGB);; * If you just need to composite the PNG image onto an existing background; * and if you control the code that does this you can use the optimization; * setting. In this case you just copy completely opaque pixels to the; * output. For pixels that are not completely transparent (you just skip; * those) you do the composition math using png_composite or png_composite_16; * below then encode the resultant 8-bit or 16-bit values to match the output; * encoding.; *; * Other cases; * If neither the PNG nor the standard linear encoding work for you because; * of the software or hardware you use then you have a big problem. The PNG; * case will probably result in halos around the image. The linear encoding; * will probably result in a washed out, too bright, image (it's actually too; * contrasty.) Try the ALPHA_OPTIMIZED mode above - this will probably; * substantially reduce the halos. Alternatively try:; *; * png_set_alpha_mode(pp, PNG_ALPHA_BROKEN, PNG_DEFAULT_sRGB);; * This option will also reduce the halos, but there will be slight ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:1938,optimiz,optimization,1938,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['optimiz'],['optimization']
Performance,"rogram is not allowed to read or write memory using this; // register. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for cases (a) and (b) to work the sequence %x-%y above has; // to be preserved by the IR passes.; //; // However, several optimization passes might sink `load` instruction; // or hoist `getelementptr` instruction so that the instructions are; // no longer in sequence. Examples of such passes are:; // SimplifyCFGPass, InstCombinePass, GVNPass.; // After such modification the verifier would reject the BPF program.; //; // To avoid this issue the patterns like (load/store (getelementptr ...)); // are replaced by calls to BPF specific intrinsic functions:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; //; // These calls are lowered back to (load/store (getelementptr ...)); // by BPFCheckAndAdjustIR pass right before the translation from IR to; // machine instructions.; //; // The transformation is split into the following steps:; // - When IR is generated from AST the calls to intrinsic function; // llvm.preserve.static.offset are inserted.; // - BPFPreserveStaticOffsetPass is executed as early as possible; // with AllowPatial set to true, this handles marked GEP chains; // with constant offsets.; // - BPFPreserveStaticOffsetPass is executed at ScalarOptimizerLateEPCallback; // with AllowPatial set to false, this handles marked GEP chains; // with offsets that became constant after loop unrolling, e.g.; // to handle the following code:; //; // struct context { int x[4]; } __attribute__((preserve_static_offset));; //; // struct context *ctx = ...;; // #pragma clang loop unroll(full); // for (int i = 0; i < 4; ++i); // foo(ctx->x[i]);; //; // The e",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:2588,load,load,2588,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,1,['load'],['load']
Performance,"ront lane.; ///; /// Work-Item Id X (enable_vgpr_workitem_id > 0):; /// Number of registers: 1. 32 bit work item id in Z dimension of work-group; /// for wavefront lane.; ///; ///; /// The setting of registers is being done by existing GPU hardware as follows:; /// 1) SGPRs before the Work-Group Ids are set by CP using the 16 User Data; /// registers.; /// 2) Work-group Id registers X, Y, Z are set by SPI which supports any; /// combination including none.; /// 3) Scratch Wave Offset is also set by SPI which is why its value cannot; /// be added into the value Flat Scratch Offset which would avoid the; /// Finalizer generated prolog having to do the add.; /// 4) The VGPRs are set by SPI which only supports specifying either (X),; /// (X, Y) or (X, Y, Z).; ///; /// Flat Scratch Dispatch Offset and Flat Scratch Size are adjacent SGRRs so; /// they can be moved as a 64 bit value to the hardware required SGPRn-3 and; /// SGPRn-4 respectively using the Finalizer ?FLAT_SCRATCH? Register.; ///; /// The global segment can be accessed either using flat operations or buffer; /// operations. If buffer operations are used then the Global Buffer used to; /// access HSAIL Global/Readonly/Kernarg (which are combine) segments using a; /// segment address is not passed into the kernel code by CP since its base; /// address is always 0. Instead the Finalizer generates prolog code to; /// initialize 4 SGPRs with a V# that has the following properties, and then; /// uses that in the buffer instructions:; /// - base address of 0; /// - no swizzle; /// - ATC=1; /// - MTYPE set to support memory coherence specified in; /// amd_kernel_code_t.globalMemoryCoherence; ///; /// When the Global Buffer is used to access the Kernarg segment, must add the; /// dispatch packet kernArgPtr to a kernarg segment address before using this V#.; /// Alternatively scalar loads can be used if the kernarg offset is uniform, as; /// the kernarg segment is constant for the duration of the kernel execution.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:10066,load,loads,10066,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,1,['load'],['loads']
Performance,"rray.; // - one branch for the TRefArray of high Pt tracks; // - one branch for the TRefArray of muon tracks; // - one branch for the reference pointer to the last track; // - one branch for the object fH (histogram of class TH1F).; //; // if split = 0 only one single branch is created and the complete event; // is serialized in one single buffer.; // if split = -2 the event is split using the old TBranchObject mechanism; // if split = -1 the event is streamed using the old TBranchObject mechanism; // if split > 0 the event is split using the new TBranchElement mechanism.; //; // if comp = 0 no compression at all.; // if comp = 1 event is compressed.; // if comp = 2 same as 1. In addition branches with floats in the TClonesArray; // are also compressed.; // The 4th argument fill can be set to 0 if one wants to time; // the percentage of time spent in creating the event structure and; // not write the event in the file.; // The 5th argument will enable IMT mode (Implicit Multi-Threading), allowing; // ROOT to use multiple threads internally, if enabled.; // The 6th argument allows the user to specify the compression algorithm:; // - 1 - zlib.; // - 2 - LZMA.; // - 3 - ""old ROOT algorithm"" A variant of zlib; do not use, kept for; // backwards compatability.; // - 4 - LZ4.; // In this example, one loops over nevent events.; // The branch ""event"" is created at the first event.; // The branch address is set for all other events.; // For each event, the event header is filled and ntrack tracks; // are generated and added to the TClonesArray list.; // For each event the event histogram is saved as well as the list; // of all tracks.; //; // The two TRefArray contain only references to the original tracks owned by; // the TClonesArray fTracks.; //; // The number of events can be given as the first argument to the program.; // By default 400 events are generated.; // The compression option can be activated/deactivated via the second argument.; //; // Additionally, if the env",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/MainEvent.cxx:2093,Multi-Thread,Multi-Threading,2093,test/MainEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/MainEvent.cxx,1,['Multi-Thread'],['Multi-Threading']
Performance,"rrectly for all; /// implemented operations. Currently implemented operations are add, subtract,; /// multiply, divide, fused-multiply-add, conversion-to-float,; /// conversion-to-integer and conversion-from-integer. New rounding modes; /// (e.g. away from zero) can be added with three or four lines of code.; ///; /// Four formats are built-in: IEEE single precision, double precision,; /// quadruple precision, and x87 80-bit extended double (when operating with; /// full extended precision). Adding a new format that obeys IEEE semantics; /// only requires adding two lines of code: a declaration and definition of the; /// format.; ///; /// All operations return the status of that operation as an exception bit-mask,; /// so multiple operations can be done consecutively with their results or-ed; /// together. The returned status can be useful for compiler diagnostics; e.g.,; /// inexact, underflow and overflow can be easily diagnosed on constant folding,; /// and compiler optimizers can determine what exceptions would be raised by; /// folding operations and optimize, or perhaps not optimize, accordingly.; ///; /// At present, underflow tininess is detected after rounding; it should be; /// straight forward to add support for the before-rounding case too.; ///; /// The library reads hexadecimal floating point numbers as per C99, and; /// correctly rounds if necessary according to the specified rounding mode.; /// Syntax is required to have been validated by the caller. It also converts; /// floating point numbers to hexadecimal text as per the C99 %a and %A; /// conversions. The output precision (or alternatively the natural minimal; /// precision) can be specified; if the requested precision is less than the; /// natural precision the output is correctly rounded for the specified rounding; /// mode.; ///; /// It also reads decimal floating point numbers and correctly rounds according; /// to the specified rounding mode.; ///; /// Conversion to decimal text is not curre",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:1814,optimiz,optimizers,1814,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,3,['optimiz'],"['optimize', 'optimizers']"
Performance,"rs of the supplied ASImage structure, and; * 	initializes it to all 0.; * SYNOPSIS; * void asimage_init (ASImage * im, Bool free_resources);; * INPUTS; * im - pointer to valid ASImage structure; * free_resources - if True will make function attempt to free; * all non-NULL pointers.; *********/; /****f* libAfterImage/asimage/flush_asimage_cache(); * NAME; * flush_asimage_cache() destroys XImage and mask XImage kept from previous ; * conversions to/from X Pixmap.; * SYNOPSIS; * void flush_asimage_cache (ASImage * im );; * INPUTS; * im - pointer to valid ASImage structure; *********/; /****f* libAfterImage/asimage/asimage_start(); * NAME; * asimage_start() Allocates memory needed to store scanline of the image ; * of supplied size. Assigns all the data members valid values. Makes sure ; * that ASImage structure is ready to store image data.; * SYNOPSIS; * void asimage_start (ASImage * im, unsigned int width,; * unsigned int height,; * unsigned int compression);; * INPUTS; * im - pointer to valid ASImage structure; * width - width of the image; * height - height of the image; * compression - level of compression to perform on image data.; * compression has to be in range of 0-100 with 100; * signifying highest level of compression.; * NOTES; * In order to resize ASImage structure after asimage_start() has been; * called, asimage_init() must be invoked to free all the memory, and; * then asimage_start() has to be called with new dimensions.; *********/; /****f* libAfterImage/asimage/create_asimage(); * NAME; * create_asimage() Performs memory allocation for the new ASImage ; * structure, as well as initialization of allocated structure based on ; * supplied parameters.; * SYNOPSIS; * ASImage *create_asimage( unsigned int width,; * unsigned int height,; * unsigned int compression);; * INPUTS; * width - desired image width; * height - desired image height; * compression - compression level in new ASImage( see asimage_start(); * for more ).; * RETURN VALUE; * Pointer to new",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h:1216,perform,perform,1216,graf2d/asimage/src/libAfterImage/asimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h,1,['perform'],['perform']
Performance,"rtional to the content's absolute value. A negative content is marked with a X. |; | ""BOX1"" | A button is drawn for each cell with surface proportional to content's absolute value. A sunken button is drawn for negative values a raised one for positive.|; | ""COL"" | A box is drawn for each cell with a color scale varying with contents. All the none empty bins are painted. Empty bins are not painted unless some bins have a negative content because in that case the null bins might be not empty. `TProfile2D` histograms are handled differently because, for this type of 2D histograms, it is possible to know if an empty bin has been filled or not. So even if all the bins' contents are positive some empty bins might be painted. And vice versa, if some bins have a negative content some empty bins might be not painted (default).|; | ""COLZ"" | Same as ""COL"". In addition the color palette is also drawn.|; | ""COL2"" | Alternative rendering algorithm to ""COL"". Can significantly improve rendering performance for large, non-sparse 2-D histograms.|; | ""COLZ2"" | Same as ""COL2"". In addition the color palette is also drawn.|; | ""Z CJUST"" | In combination with colored options ""COL"",""CONT0"" etc: Justify labels in the color palette at color boundaries. For more details see `TPaletteAxis`|; | ""CANDLE"" | Draw a candle plot along X axis.|; | ""CANDLEX"" | Same as ""CANDLE"".|; | ""CANDLEY"" | Draw a candle plot along Y axis.|; | ""CANDLEXn"" | Draw a candle plot along X axis. Different candle-styles with n from 1 to 6.|; | ""CANDLEYn"" | Draw a candle plot along Y axis. Different candle-styles with n from 1 to 6.|; | ""VIOLIN"" | Draw a violin plot along X axis.|; | ""VIOLINX"" | Same as ""VIOLIN"".|; | ""VIOLINY"" | Draw a violin plot along Y axis.|; | ""VIOLINXn"" | Draw a violin plot along X axis. Different violin-styles with n being 1 or 2.|; | ""VIOLINYn"" | Draw a violin plot along Y axis. Different violin-styles with n being 1 or 2.|; | ""CONT"" | Draw a contour plot (same as CONT0).|; | ""CONT0"" | Draw a contou",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:10990,perform,performance,10990,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['perform'],['performance']
Performance,"ry. This shared library will then be loaded and the function; /// myfunc will be called with the two arguments. With '++' the shared library; /// is always recompiled. With '+' the shared library is recompiled only; /// if it does not exist yet or the macro file is newer than the shared; /// library.; ///; /// Of course the + and ++ notation is supported in similar way for .x and .L.; ///; /// Through the function TSystem::SetMakeSharedLib(), the user will be able to; /// indicate, with shell commands, how to build a shared library (a good; /// default will be provided). The most common change, namely where to find; /// header files, will be available through the function; /// TSystem::SetIncludePath().; /// A good default will be provided so that a typical user session should be at; /// most:; /// ~~~ {.cpp}; /// root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; /// -I$HOME/mypackage/include"");; /// root[2] .x myfunc.C++(10,20);; /// ~~~; /// The user may sometimes try to compile a script before it has loaded all the; /// needed shared libraries. In this case we want to be helpful and output a; /// list of the unresolved symbols. So if the loading of the created shared; /// library fails, we will try to build a executable that contains the; /// script. The linker should then output a list of missing symbols.; ///; /// To support this we provide a TSystem::SetMakeExe() function, that sets the; /// directive telling how to create an executable. The loader will need; /// to be informed of all the libraries available. The information about; /// the libraries that has been loaded by .L and TSystem::Load() is accessible; /// to the script compiler. However, the information about; /// the libraries that have been selected at link time by the application; /// builder (like the root libraries for root.exe) are not available and need; /// to be explicitly listed in fLinkedLibs (either by default or by a call to; /// TSystem::SetLinkedLibs()).; ///; /// To simplify customiz",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:4212,load,loaded,4212,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['load'],['loaded']
Performance,"s Rademakers 30/9/2001; /*************************************************************************; * Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TUUID; \ingroup Base. This class defines a UUID (Universally Unique IDentifier), also; known as GUIDs (Globally Unique IDentifier). A UUID is 128 bits; long, and if generated according to this algorithm, is either; guaranteed to be different from all other UUIDs/GUIDs generated; until 3400 A.D. or extremely likely to be different. UUIDs were; originally used in the Network Computing System (NCS) and; later in the Open Software Foundation's (OSF) Distributed Computing; Environment (DCE). \note In the way this UUID is constructed, when used outside of; their original concept (NCS), they are actually not Globally unique; and indeed multiple distinct concurrent processes are actually likely; to generate the same UUID. Technically this is because the UUID is; constructed only from the node information and time information.; To make a globally unique number, this needs to be combined with; TProcessUUID. Structure of universal unique IDs (UUIDs). Depending on the network data representation, the multi-; octet unsigned integer fields are subject to byte swapping; when communicated between dissimilar endian machines.; ~~~ {.cpp}; +-----------------------------------+; | low 32 bits of time | 0-3 .fTimeLow; +-------------------------------+----; | mid 16 bits of time | 4-5 .fTimeMid; +-------+-----------------------+; | vers. | hi 12 bits of time | 6-7 .fTimeHiAndVersion; +-------+-------+---------------+; |Res | clkSeqHi | 8 .fClockSeqHiAndReserved; +---------------+; | clkSeqLow | 9 .fClockSeqLow; +---------------+------------------+; | node ID | 10-15 .fNode; +---------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUUID.cxx:1085,concurren,concurrent,1085,core/base/src/TUUID.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUUID.cxx,1,['concurren'],['concurrent']
Performance,"s and the other arguments; /// have the same meaning as above.; ///; /// For either set of signatures, the processing function is executed as many times as; /// needed by a pool of fNWorkers workers; the number of workers can be passed to the constructor; /// or set via SetNWorkers. It defaults to the number of cores.\n; /// A collection containing the result of each execution is returned.\n; /// **Note:** the user is responsible for the deletion of any object that might; /// be created upon execution of func, returned objects included: ROOT::TTreeProcessorMP never; /// deletes what it returns, it simply forgets it.\n; /// **Note:** that the usage of ROOT::TTreeProcessorMP::Process is indicated only when the task to be; /// executed takes more than a few seconds, otherwise the overhead introduced; /// by Process will outrun the benefits of parallel execution on most machines.; ///; /// \param func; /// \parblock; /// a lambda expression, an std::function, a loaded macro, a; /// functor class or a function that takes zero arguments (for the first signature); /// or one (for the second signature).; /// \endparblock; /// \param args; /// \parblock; /// a standard container (vector, list, deque), an initializer list; /// or a pointer to a TCollection (TList*, TObjArray*, ...).; /// \endparblock; /// **Note:** the version of ROOT::TTreeProcessorMP::Process that takes a TFileCollection* as argument incurs; /// in the overhead of copying data from the TCollection to an STL container. Only; /// use it when absolutely necessary.\n; /// **Note:** in cases where the function to be executed takes more than; /// zero/one argument but all are fixed except zero/one, the function can be wrapped; /// in a lambda or via std::bind to give it the right signature.\n; /// **Note:** the user should take care of initializing random seeds differently in each; /// process (e.g. using the process id in the seed). Otherwise several parallel executions; /// might generate the same sequence of p",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProcessorMP.cxx:2178,load,loaded,2178,tree/treeplayer/src/TTreeProcessorMP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProcessorMP.cxx,1,['load'],['loaded']
Performance,"s behavior on a cache miss. When; miss optimization is enabled (see the SetOptimizeMisses method),; it tracks all branches utilized after the learning phase which caused a cache; miss.; When one cache miss occurs, all the utilized branches are be prefetched; for that event. This optimization utilizes the observation that infrequently; accessed branches are often accessed together.; An example scenario where such behavior is desirable, is an analysis where; a set of collections are read only for a few events in which a certain; condition is respected, e.g. a trigger fired. ### Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase; by at most a factor two in the case of cache miss.; Additionally, on the first miss of an event, we must iterate through all the; ""active branches"" for the miss cache and find the correct basket.; This can be potentially a CPU-expensive operation compared to, e.g., the; latency of a SSD. This is why the miss cache is currently disabled by default. \anchor examples; ## Example usages of TTreeCache. A few use cases are discussed below. A cache may be created with automatic; sizing when a TTree is used:. In some applications, e.g. central processing workflows of experiments, the list; of branches to read is known a priori. For these cases, the TTreeCache can be; instructed about the branches which will be read via explicit calls to the TTree; or TTreeCache interfaces.; In less streamlined applications such as analysis, predicting the branches which; will be read can be difficult. In such cases, ROOT I/O flags used branches; automatically when a branch buffer is read during the learning phase. In the examples below, portions of analysis code are shown.; The few statements involving the TreeCache are marked with `//<<<`. ### ROOT::RDataFrame and TTreeReader Examples. If you use RDataFrame or TTreeReader, the system will automatically cache the; best set of bran",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:5809,latency,latency,5809,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['latency'],['latency']
Performance,"s class doesn't know about the existence of different memory; /// types for memory operations (example: write-through, write-combining, etc.).; /// Derived classes are responsible for implementing that extra knowledge, and; /// provide different sets of rules for loads and stores by overriding method; /// `isReady()`.; /// To emulate a write-combining memory type, rule 2. must be relaxed in a; /// derived class to enable the reordering of non-aliasing store operations.; ///; /// No assumptions are made by this class on the size of the store buffer. This; /// class doesn't know how to identify cases where store-to-load forwarding may; /// occur.; ///; /// LSUnit doesn't attempt to predict whether a load or store hits or misses; /// the L1 cache. To be more specific, LSUnit doesn't know anything about; /// cache hierarchy and memory types.; /// It only knows if an instruction ""mayLoad"" and/or ""mayStore"". For loads, the; /// scheduling model provides an ""optimistic"" load-to-use latency (which usually; /// matches the load-to-use latency for when there is a hit in the L1D).; /// Derived classes may expand this knowledge.; ///; /// Class MCInstrDesc in LLVM doesn't know about serializing operations, nor; /// memory-barrier like instructions.; /// LSUnit conservatively assumes that an instruction which `mayLoad` and has; /// `unmodeled side effects` behave like a ""soft"" load-barrier. That means, it; /// serializes loads without forcing a flush of the load queue.; /// Similarly, instructions that both `mayStore` and have `unmodeled side; /// effects` are treated like store barriers. A full memory; /// barrier is a 'mayLoad' and 'mayStore' instruction with unmodeled side; /// effects. This is obviously inaccurate, but this is the best that we can do; /// at the moment.; ///; /// Each load/store barrier consumes one entry in the load/store queue. A; /// load/store barrier enforces ordering of loads/stores:; /// - A younger load cannot pass a load barrier.; /// - A younger sto",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:1926,load,loads,1926,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,5,"['latency', 'load']","['latency', 'load-to-use', 'loads']"
Performance,"s for its computations will request it from a reader, e.g. a column created via `Define` or; available from the input dataset. The action will request values from each column of the list of input columns (either; inferred or specified by the user), in order. For example:. ~~~{.cpp}; ROOT::RDataFrame df{1};; auto df1 = df.Define(""x"", []{ return 11; });; auto df2 = df1.Define(""y"", []{ return 22; });; auto graph = df2.Graph<int, int>(""x"",""y"");; ~~~. The `Graph` action is going to request first the value from column ""x"", then that of column ""y"". Specifically, the order; of execution of the operations of nodes in this branch of the computation graph is guaranteed to be top to bottom. \anchor distrdf; ## Distributed execution. RDataFrame applications can be executed in parallel through distributed computing frameworks on a set of remote machines; thanks to the Python package `ROOT.RDF.Experimental.Distributed`. This experimental, **Python-only** package allows to scale the; optimized performance RDataFrame can achieve on a single machine to multiple nodes at the same time. It is designed so; that different backends can be easily plugged in, currently supporting [Apache Spark](http://spark.apache.org/) and; [Dask](https://dask.org/). To make use of distributed RDataFrame, you only need to switch `ROOT.RDataFrame` with; the backend-specific `RDataFrame` of your choice, for example:. ~~~{.py}; import ROOT. # Point RDataFrame calls to the Spark specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame. # It still accepts the same constructor arguments as traditional RDataFrame; df = RDataFrame(""mytree"", ""myfile.root""). # Continue the application with the traditional RDataFrame API; sum = df.Filter(""x > 10"").Sum(""y""); h = df.Histo1D((""name"", ""title"", 10, 0, 10), ""x""). print(sum.GetValue()); h.Draw(); ~~~. The main goal of this package is to support running any RDataFrame application distributedly. Nonetheless, not all; parts of the RDataFrame API curr",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:36298,optimiz,optimized,36298,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,2,"['optimiz', 'perform']","['optimized', 'performance']"
Performance,"s in LikelihoodJobs.; *; * The default number of workers is set using 'std::thread::hardware_concurrency()'.; * To change it, use 'Config::setDefaultNWorkers()' to set it to a different value; * before creation of a new JobManager instance. Note that it cannot be set to zero; * and also cannot be changed after JobManager has been instantiated.; *; * Use Config::getDefaultNWorkers() to access the current value.; *; * Under Config::LikelihoodJob, we find two members for the number of tasks to use to; * calculate the range of events and components in parallel, respectively:; * defaultNEventTasks and defaultNComponentTasks. Newly created LikelihoodJobs will; * then use these values at construction time. Note that (like with the number of; * workers) the number cannot be changed for an individual LikelihoodJob after it has; * been created.; *; * Both event- and component-based tasks by default are set to automatic mode using; * the automaticNEventTasks and automaticNComponentTasks constants (both under; * Config::LikelihoodJob as well). These are currently set to zero, but this could; * change. Automatic mode for events means that the number of tasks is set to the; * number of workers in the JobManager, with events divided equally over workers. For; * components, the automatic mode uses just 1 task for all components. These automatic; * modes may change in the future (for instance, we may switch them around).; *; * Under Config::Queue, we can set the desired queue type: FIFO or Priority. This; * setting is used when a JobManager is spun up, i.e. usually when the first Job; * starts. At this point, the Queue is also created according to the setting. The; * default is FIFO. When using a Priority Queue, the priority of tasks in a Job; * can be set using either setTaskPriorities or suggestTaskOrder. If no priorities; * are set, the Priority queue simply assumes equal priority for all tasks. The; * resulting order then depends on the implementation of std::priority_queue.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Config.cxx:1925,Queue,Queue,1925,roofit/multiprocess/src/Config.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Config.cxx,5,"['Queue', 'queue']","['Queue', 'queue']"
Performance,"s in.; * font_string - filename of the file containing font's data.; * face_no - number of face within the font file; * size - font size in points. Applicable only to scalable fonts,; * such as TrueType.; * verbose - if True, extensive error messages will be printed if; * problems encountered.; * RETURN VALUE; * pointer to Opened ASFont structure, containing all the glyphs of the; * font, as well as other relevant info. On failure returns NULL.; * DESCRIPTION; * open_freetype_font() will attempt to find font file in any of the; * directories specified in ASFontManager's font_path. If it fails to do; * so - then it will check if filename has alldigit extentions. It will; * then try to interpret that extention as a face number, and try and; * find the file with extention stripped off.; * If file was found function will atempt to read it using FreeType; * library. If requested face is not available in the font - face 0 will; * be used.; * On success all the font's glyphs will be rendered and cached, and; * needed font geometry info collected.; * When FreeType Library is not available that function does nothing.; *********/; /****f* libAfterImage/asfont/open_X11_font(); * NAME; * open_X11_font(); * SYNOPSIS; * ASFont *open_X11_font( ASFontManager *fontman,; * const char *font_string);; * INPUTS; * fontman - pointer to previously created ASFontManager. Needed for; * connection X Server.; * font_string - name of the font as recognized by Xlib.; * RETURN VALUE; * pointer to Opened ASFont structure, containing all the glyphs of the; * font, as well as other relevant info. On failure returns NULL.; * DESCRIPTION; * open_X11_font() attempts to load and query font using Xlib calls.; * On success it goes thgroughthe codemap of the font and renders all; * the glyphs available. Glyphs then gets transfered to the client's; * memory and encoded using RLE compression. At this time smoothing; * filters are applied on glyph pixmaps, if its size exceeds threshold.; * TODO; * implement p",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h:1372,cache,cached,1372,graf2d/asimage/src/libAfterImage/asfont.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h,1,['cache'],['cached']
Performance,"s is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; /",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1552,load,loads,1552,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['load'],['loads']
Performance,"s only supported for the Dask backend. \anchor parallel-execution; ## Performance tips and parallel execution; As pointed out before in this document, RDataFrame can transparently perform multi-threaded event loops to speed up; the execution of its actions. Users have to call ROOT::EnableImplicitMT() *before* constructing the RDataFrame; object to indicate that it should take advantage of a pool of worker threads. **Each worker thread processes a distinct; subset of entries**, and their partial results are merged before returning the final values to the user.; There are no guarantees on the order in which threads will process the batches of entries.; In particular, note that this means that, for multi-thread event loops, there is no; guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; ~~~{.cpp}; ROOT::EnableImplicitMT(i); ~~~; replacing `i` with the number of CPUs/slots that were allocated for this job. ### Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads. Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); expressions will often be *pure* in the functional programming sense (no side-effects,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:47999,multi-thread,multi-thread,47999,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['multi-thread'],['multi-thread']
Performance,"s the; // RegisterMap with registers that were moved as keys, there is no value; // inserted. In the next phase, every MachineInstr in a basic block is; // iterated over. If it is a valid DBG_VALUE or DBG_VALUE_LIST and it uses one; // or more registers in the RegisterMap, the RegisterMap and InstrMap are; // populated with the MachineInstr. If the DBG_VALUE or DBG_VALUE_LIST; // describes debug information for a variable that already exists in the; // DbgValueSinkCandidates, the MachineInstr in the DbgValueSinkCandidates must; // be set to undef. If the current MachineInstr is a load that was moved,; // undef the corresponding DBG_VALUE or DBG_VALUE_LIST and clone it to below; // the load.; // To illustrate the above algorithm visually let's take this example.; // Before the Pre Register Allocation Load Store Pass:; // %2 = ld ...; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // %3 = ld ...; // DBG_VALUE %3, A, ..., # Z; // %4 = ld ...; // After Pre Register Allocation Load Store Pass:; // DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // The algorithm below does the following:; // In the beginning, the RegisterMap will have been populated with the virtual; // registers %2, and %3, the DbgValueSinkCandidates and the InstrMap will be; // empty. DbgValueSinkCandidates = {}, RegisterMap = {2 -> {}, 3 -> {}},; // InstrMap {}; // -> DBG_VALUE %2, A, .... # X; // DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld ...; // After the first DBG_VALUE (denoted with an X) is processed, the; // DbgValueSinkCandidates and InstrMap will be populated and the RegisterMap; // entry for %2 will be populated as well. DbgValueSinkCandidates = {A -> X},; // RegisterMap = {2 -> {X}, 3 -> {}}, InstrMap {X -> 2}; // DBG_VALUE %2, A, .... # X; // -> DBG_VALUE 0, A, ... # Y; // DBG_VALUE %3, A, ..., # Z; // %2 = ld ...; // %3 = ld ...; // %4 = ld .",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:1751,Load,Load,1751,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['Load'],['Load']
Performance,"s tries to combine multiple image_load intrinsics with dim=2dmsaa; // or dim=2darraymsaa into a single image_msaa_load intrinsic if:; //; // - they refer to the same vaddr except for sample_id,; // - they use a constant sample_id and they fall into the same group,; // - they have the same dmask and the number of intrinsics and the number of; // vaddr/vdata dword transfers is reduced by the combine.; //; // Examples for the tradeoff (all are assuming 2DMsaa for vaddr):; //; // +----------+-----+-----+-------+---------+------------+---------+----------+; // | popcount | a16 | d16 | #load | vaddr / | #msaa_load | vaddr / | combine? |; // | (dmask) | | | | vdata | | vdata | |; // +----------+-----+-----+-------+---------+------------+---------+----------+; // | 1 | 0 | 0 | 4 | 12 / 4 | 1 | 3 / 4 | yes |; // +----------+-----+-----+-------+---------+------------+---------+----------+; // | 1 | 0 | 0 | 2 | 6 / 2 | 1 | 3 / 4 | yes? |; // +----------+-----+-----+-------+---------+------------+---------+----------+; // | 2 | 0 | 0 | 4 | 12 / 8 | 2 | 6 / 8 | yes |; // +----------+-----+-----+-------+---------+------------+---------+----------+; // | 2 | 0 | 0 | 2 | 6 / 4 | 2 | 6 / 8 | no |; // +----------+-----+-----+-------+---------+------------+---------+----------+; // | 1 | 0 | 1 | 2 | 6 / 2 | 1 | 3 / 2 | yes |; // +----------+-----+-----+-------+---------+------------+---------+----------+; //; // Some cases are of questionable benefit, like the one marked with ""yes?""; // above: fewer intrinsics and fewer vaddr and fewer total transfers between SP; // and TX, but higher vdata. We start by erring on the side of converting these; // to MSAA_LOAD.; //; // clang-format off; //; // This pass will combine intrinsics such as (not neccessarily consecutive):; // call float @llvm.amdgcn.image.load.2dmsaa.f32.i32(i32 1, i32 %s, i32 %t, i32 0, <8 x i32> %rsrc, i32 0, i32 0); // call float @llvm.amdgcn.image.load.2dmsaa.f32.i32(i32 1, i32 %s, i32 %t, i32 1, <8 x i32> %rsrc, i32 0, i",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUImageIntrinsicOptimizer.cpp:979,load,load,979,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUImageIntrinsicOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUImageIntrinsicOptimizer.cpp,1,['load'],['load']
Performance,"s web development. XML Image manipulation; * tool, that could be used in such activity is included (see ascompose.c); *; * 9. Image reference counting; *; * USES; * libAfterBase - AfterStep basic functionality library. That Includes; * Hash tables, file search methods, message output, generic types.; * However effort has been made to allow for standalone configuration as; * well. If libAfterBase is not found at compilation time - libAfterImage; * will use extract from libAfterBase included with libAfterImage.; *; * SEE ALSO; * Examples; * API Reference; *; * TODO; * Implement support for Targa and PCX image format and maybe some other; * formats as well.; *; * Implement complete support for I18N internationalization.; *; * Implement color<->pixel conversion for all colordepths.; *; * AUTHOR; * Sasha Vasko <sasha at aftercode dot net>; *********/; /****h* libAfterImage/Examples; * EXAMPLE; * ASView - image loading from the file and displaying in window.; * ASScale - image loading from file and scaling to arbitrary size.; * ASTile - image loading from file, tiling and tinting to arbitrary; * size and color.; * ASMerge - imgae loading and merging with another image.; * ASGrad - mutlipoint gradient drawing.; * ASFlip - image loading from file and rotation.; * ASText - trexturized semitransparent antialised text drawing.; *; * SEE ALSO; * API Reference; ******/; /****h* libAfterImage/API Reference; * CHILDREN; * Headers :; * ascmap.h asfont.h asimage.h asvisual.h blender.h export.h; * import.h transform.h ximage.h; * Structures :; * ColorPair; * ASScanline; * ASVisual; * ASImage; * ASImageManager; * ASImageBevel; * ASImageDecoder; * ASImageOutput; * ASImageLayer; * ASGradient; * ASFontManager; * ASFont; * ASGlyph; * ASGlyphRange; * ASColormap; * ASImageExportParams; * ASVectorPalette; *; * Functions :; * ASScanline handling:; * 	 prepare_scanline(), free_scanline(); *; * ASVisual initialization :; * 	 query_screen_visual(), setup_truecolor_visual(),; * 	 setup_pseudo_vis",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/afterimage.h:5949,load,loading,5949,graf2d/asimage/src/libAfterImage/afterimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/afterimage.h,1,['load'],['loading']
Performance,"s.; ""Empty bins, weights=1"" sets ON/OFF option 'WW' - all weights; equal to 1, including empty bins, error bars ignored.; ""Use range"" sets ON/OFF option 'R' - fit only data within the; specified function range with the slider.; ""Improve fit results"" sets ON/OFF option 'M' - after minimum is; found, search for a new one.; ""Add to list"" sets On/Off option '+'- add function to the list; without deleting the previous. Draw options:; ""SAME"" sets On/Off function drawing on the same pad.; ""No drawing"" sets On/Off option '0'- do not draw function graphics.; ""Do not store/draw"" sets On/Off option 'N'- do not store the; function, do not draw it. Sliders settings are used if option 'R' - use range is active.; Users can change min/max values by pressing the left mouse button; near to the left/right slider edges. It is possible o change both; values simultaneously by pressing the left mouse button near to its; center and moving it to a new desire position. ""Minimization"" Tab. ""Library"" group allows you to use Minuit, Minuit2 or Fumili; minimization packages for your fit.; ""Minuit"" - the popular Minuit minimization package.; ""Minuit2"" - a new object-oriented implementation of Minuit in C++.; ""Fumili"" - the popular Fumili minimization package. ""Method"" group has currently restricted functionality.; ""MIGRAD"" method is available for Minuit and Minuit2; ""FUMILI"" method is available for Fumili and Minuit2; ""SIMPLEX"" method is disabled (will come with the new fitter design). ""Minimization Settings' group allows users to set values for:; ""Error definition"" - between 0.0 and 100.0 (default is 1.0).; ""Maximum tolerance"" - the fit relative precision in use.; ""Maximum number of iterations"" - default is 5000. Print options:; ""Default"" - between Verbose and Quiet.; ""Verbose"" - prints results after each iteration.; ""Quiet"" - no fit information is printed. Fit button - performs a fit.; Reset - resets all GUI elements and related fit settings to the; default ones.; Close - closes this window. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx:4507,perform,performs,4507,gui/fitpanel/src/TFitEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx,1,['perform'],['performs']
Performance,"s.; - A 'cached' TChain switches over to a new file. \anchor cachemisses; ## Self-optimization in presence of cache misses. The TTreeCache can optimize its behavior on a cache miss. When; miss optimization is enabled (see the SetOptimizeMisses method),; it tracks all branches utilized after the learning phase which caused a cache; miss.; When one cache miss occurs, all the utilized branches are be prefetched; for that event. This optimization utilizes the observation that infrequently; accessed branches are often accessed together.; An example scenario where such behavior is desirable, is an analysis where; a set of collections are read only for a few events in which a certain; condition is respected, e.g. a trigger fired. ### Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase; by at most a factor two in the case of cache miss.; Additionally, on the first miss of an event, we must iterate through all the; ""active branches"" for the miss cache and find the correct basket.; This can be potentially a CPU-expensive operation compared to, e.g., the; latency of a SSD. This is why the miss cache is currently disabled by default. \anchor examples; ## Example usages of TTreeCache. A few use cases are discussed below. A cache may be created with automatic; sizing when a TTree is used:. In some applications, e.g. central processing workflows of experiments, the list; of branches to read is known a priori. For these cases, the TTreeCache can be; instructed about the branches which will be read via explicit calls to the TTree; or TTreeCache interfaces.; In less streamlined applications such as analysis, predicting the branches which; will be read can be difficult. In such cases, ROOT I/O flags used branches; automatically when a branch buffer is read during the learning phase. In the examples below, portions of analysis code are shown.; The few statements involving the TreeCache are marked wit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:5699,cache,cache,5699,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"s.; ///; /// Any user-define `struct` can participate in hashing via `HashBuilder` by; /// providing a `addHash` templated function.; ///; /// ```; /// template <typename HasherT, llvm::endianness Endianness>; /// void addHash(HashBuilder<HasherT, Endianness> &HBuilder,; /// const UserDefinedStruct &Value);; /// ```; ///; /// For example:; /// ```; /// struct SimpleStruct {; /// char c;; /// int i;; /// };; ///; /// template <typename HasherT, llvm::endianness Endianness>; /// void addHash(HashBuilder<HasherT, Endianness> &HBuilder,; /// const SimpleStruct &Value) {; /// HBuilder.add(Value.c);; /// HBuilder.add(Value.i);; /// }; /// ```; ///; /// To avoid endianness issues, specializations of `addHash` should; /// generally rely on exising `add`, `addRange`, and `addRangeElements`; /// functions. If directly using `update`, an implementation must correctly; /// handle endianness.; ///; /// ```; /// struct __attribute__ ((packed)) StructWithFastHash {; /// int I;; /// char C;; ///; /// // If possible, we want to hash both `I` and `C` in a single; /// // `update` call for performance concerns.; /// template <typename HasherT, llvm::endianness Endianness>; /// friend void addHash(HashBuilder<HasherT, Endianness> &HBuilder,; /// const StructWithFastHash &Value) {; /// if (Endianness == llvm::endianness::native) {; /// HBuilder.update(ArrayRef(; /// reinterpret_cast<const uint8_t *>(&Value), sizeof(Value)));; /// } else {; /// // Rely on existing `add` methods to handle endianness.; /// HBuilder.add(Value.I);; /// HBuilder.add(Value.C);; /// }; /// }; /// };; /// ```; ///; /// To avoid collisions, specialization of `addHash` for variable-size; /// types must take the size into account.; ///; /// For example:; /// ```; /// struct CustomContainer {; /// private:; /// size_t Size;; /// int Elements[100];; ///; /// public:; /// CustomContainer(size_t Size) : Size(Size) {; /// for (size_t I = 0; I != Size; ++I); /// Elements[I] = I;; /// }; /// template <typename HasherT, llv",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h:1134,perform,performance,1134,interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,1,['perform'],['performance']
Performance,"s/hist/hbars.C; End_Macro. To control the bar width (default is the bin width) `TH1::SetBarWidth()`; should be used. To control the bar offset (default is 0) `TH1::SetBarOffset()` should; be used. These two parameters are useful when several histograms are plotted using; the option `SAME`. They allow to plot the histograms next to each other. \anchor HP11; ### The SCATter plot option (legacy draw option). \attention; Use of option `SCAT` has been deprecated. It was the default drawing option for 2D and; 3D histograms. The new default option is `COL` (heat-map). For each cell (i,j) a number of points proportional to the cell content is; drawn. A maximum of `kNMAX` points per cell is drawn. If the maximum is above; `kNMAX` contents are normalized to `kNMAX` (`kNMAX=2000`).; If option is of the form `scat=ff`, (eg `scat=1.8`,; `scat=1e-3`), then `ff` is used as a scale factor to compute the; number of dots. `scat=1` is the default. By default the scatter plot is painted with a ""dot marker"" which not scalable; (see the `TAttMarker` documentation). To change the marker size, a scalable marker; type should be used. For instance a circle (marker style 20). Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hscat = new TH2F(""hscat"",""Option SCATter example (default for 2D histograms) "",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hscat->Fill(px,5*py);; hscat->Fill(3+0.5*px,2*py-10.);; }; hscat->Draw(""scat=0.5""); // This a legacy draw option. Please consider using TScatter; }; End_Macro. \anchor HP12; ### The ARRow option. Shows gradient between adjacent cells. For each cell (i,j) an arrow is drawn; The orientation of the arrow follows the cell gradient. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto harr = new TH2F(""harr"",""Option ARRow example"",20,-4,4,20,-20,20);; harr->SetLineColor(kRed);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; harr->Fill(",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:31123,scalab,scalable,31123,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['scalab'],['scalable']
Performance,"s: `rdfentry_` and `rdfslot_`](\ref helper-cols); - [Just-in-time compilation: column type inference and explicit declaration of column types](\ref jitting); - [User-defined custom actions](\ref generic-actions); - [Dataset joins with friend trees](\ref friends); - [Reading data formats other than ROOT trees](\ref other-file-formats); - [Computation graphs (storing and reusing sets of transformations)](\ref callgraphs); - [Visualizing the computation graph](\ref representgraph); - [Activating RDataFrame execution logs](\ref rdf-logging); - [Creating an RDataFrame from a dataset specification file](\ref rdf-from-spec); - [Adding a progress bar](\ref progressbar); - [Working with missing values in the dataset](\ref missing-values); - [Efficient analysis in Python](\ref python); - <a class=""el"" href=""classROOT_1_1RDataFrame.html#reference"" onclick=""javascript:toggleInherit('pub_methods_classROOT_1_1RDF_1_1RInterface')"">Class reference</a>. \anchor cheatsheet; ## Cheat sheet; These are the operations which can be performed with RDataFrame. ### Transformations; Transformations are a way to manipulate the data. | **Transformation** | **Description** |; |------------------|--------------------|; | Alias() | Introduce an alias for a particular column name. |; | DefaultValueFor() | If the value of the input column is missing, provide a default value instead. |; | Define() | Create a new column in the dataset. Example usages include adding a column that contains the invariant mass of a particle, or a selection of elements of an array (e.g. only the `pt`s of ""good"" muons). |; | DefinePerSample() | Define a new column that is updated when the input sample changes, e.g. when switching tree being processed in a chain. |; | DefineSlot() | Same as Define(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-saf",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:3191,perform,performed,3191,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['perform'],['performed']
Performance,"s:; - If p=1 the points represent the outliers. If they are shown, it means; some parts of the underlying distribution are not covered by the whiskers.; This can only occur when the whiskers are set to option w=2. Here the whiskers; can have a maximum length of \f$ 1.5 \times iqr \f$. So any points outside the; whiskers will be drawn as outliers. The outliers will be represented by crosses.; - If p=2 all points in the distribution will be painted as crosses. This is; useful for small datasets only (up to 10 or 20 points per candle).; The outliers are shown along the candle. Because the underlying distribution; is binned, is frequently occurs that a bin contains more than one value.; Because of this the points will be randomly scattered within their bin along; the candle axis. If the bin content for a bin is exactly 1 (usually; this happens for the outliers) if will be drawn in the middle of the bin along; the candle axis. As the maximum number of points per candle is limited by kNMax/2; on very large datasets scaling will be performed automatically. In that case one; would loose all outliers because they have usually a bin content of 1 (and a; bin content between 0 and 1 after the scaling). Because of this all bin contents; between 0 and 1 - after the scaling - will be forced to be 1.; - As the drawing of all values on large datasets can lead to big amounts of crosses,; one can show all values as a scatter plot instead by choosing p=3. The points will be; drawn as dots and will be scattered within the width of the candle. The color; of the points will be the color of the candle-chart. ##### Other Options; Is is possible to combine all options of candle and violin plots with each other. E.g. a box-plot; with a histogram. #### How to use the candle-plots drawing option. There are six predefined candle-plot representations:. - ""CANDLEX1"": Standard candle (whiskers cover the whole distribution); - ""CANDLEX2"": Standard candle with better whisker definition + outliers.; I",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:53981,perform,performed,53981,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,1,['perform'],['performed']
Performance,"se of this,; /// MemorySanitizer reports can show unrelated origins, but this is unlikely in; /// practice.; ///; /// Origins are meaningless for fully initialized values, so MemorySanitizer; /// avoids storing origin to memory when a fully initialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending o",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4078,load,load,4078,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,2,['load'],['load']
Performance,"se.; //; // Consequences of this GPU feature:; // - memory is limited and exceeding it halts compilation; // - a global accessed by one kernel exists independent of other kernels; // - a global exists independent of simultaneous execution of the same kernel; // - the address of the global may be different from different kernels as they; // do not alias, which permits only allocating variables they use; // - if the address is allowed to differ, functions need help to find it; //; // Uses from kernels are implemented here by grouping them in a per-kernel; // struct instance. This duplicates the variables, accurately modelling their; // aliasing properties relative to a single global representation. It also; // permits control over alignment via padding.; //; // Uses from functions are more complicated and the primary purpose of this; // IR pass. Several different lowering are chosen between to meet requirements; // to avoid allocating any LDS where it is not necessary, as that impacts; // occupancy and may fail the compilation, while not imposing overhead on a; // feature whose primary advantage over global memory is performance. The basic; // design goal is to avoid one kernel imposing overhead on another.; //; // Implementation.; //; // LDS variables with constant annotation or non-undef initializer are passed; // through unchanged for simplification or error diagnostics in later passes.; // Non-undef initializers are not yet implemented for LDS.; //; // LDS variables that are always allocated at the same address can be found; // by lookup at that address. Otherwise runtime information/cost is required.; //; // The simplest strategy possible is to group all LDS variables in a single; // struct and allocate that struct in every kernel such that the original; // variables are always at the same address. LDS is however a limited resource; // so this strategy is unusable in practice. It is not implemented here.; //; // Strategy | Precise allocation | Zero runtime cost |",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:2437,perform,performance,2437,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['perform'],['performance']
Performance,"sed into a CCtx, such as via; * ZSTD_CCtx_loadDictionary(), this param can be set on the CCtx to control; * whether the CDict that is created internally can use the feature or not.; *; * What it does:; *; * Normally, the internal data structures of the CDict are analogous to what; * would be stored in a CCtx after compressing the contents of a dictionary.; * To an approximation, a compression using a dictionary can then use those; * data structures to simply continue what is effectively a streaming; * compression where the simulated compression of the dictionary left off.; * Which is to say, the search structures in the CDict are normally the same; * format as in the CCtx.; *; * It is possible to do better, since the CDict is not like a CCtx: the search; * structures are written once during CDict creation, and then are only read; * after that, while the search structures in the CCtx are both read and; * written as the compression goes along. This means we can choose a search; * structure for the dictionary that is read-optimized.; *; * This feature enables the use of that different structure.; *; * Note that some of the members of the ZSTD_compressionParameters struct have; * different semantics and constraints in the dedicated search structure. It is; * highly recommended that you simply set a compression level in the CCtxParams; * you pass into the CDict creation call, and avoid messing with the cParams; * directly.; *; * Effects:; *; * This will only have any effect when the selected ZSTD_strategy; * implementation supports this feature. Currently, that's limited to; * ZSTD_greedy, ZSTD_lazy, and ZSTD_lazy2.; *; * Note that this means that the CDict tables can no longer be copied into the; * CCtx, so the dict attachment mode ZSTD_dictForceCopy will no longer be; * useable. The dictionary can only be attached or reloaded.; *; * In general, you should expect compression to be faster--sometimes very much; * so--and CDict creation to be slightly slower. Eventually, w",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:1650,optimiz,optimized,1650,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['optimiz'],['optimized']
Performance,"selected particles for each event, Define() can be used to create a column that contains the desired array elements as follows:. ~~~{.cpp}; // h is filled with all the elements of `good_pts`, for each event; auto h = df.Define(""good_pts"", [](const ROOT::RVecF &pt) { return pt[pt > 0]; }); .Histo1D(""good_pts"");; ~~~. And in Python:. ~~~{.py}; h = df.Define(""good_pts"", ""pt[pt > 0]"").Histo1D(""good_pts""); ~~~. Learn more at ROOT::VecOps::RVec. \anchor transformations; ## Transformations: manipulating data; \anchor Filters; ### Filters; A filter is created through a call to `Filter(f, columnList)` or `Filter(filterString)`. In the first overload, `f` can; be a function, a lambda expression, a functor class, or any other callable object. It must return a `bool` signalling; whether the event has passed the selection (`true`) or not (`false`). It should perform ""read-only"" operations on the; columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; loop. See the paragraph about ""Just-in-time compilation"" below for more information. RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; each entry: after the first access it simply serves a cached result. \anchor named-filters-and-cutflow-reports; #### Named filters and cutflow reports; An optional string parameter `n",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:28891,multi-thread,multi-threading,28891,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['multi-thread'],['multi-threading']
Performance,"ses over SCCs of the call; /// graph. These passes form an important component of LLVM's interprocedural; /// optimizations. Because they operate on the SCCs of the call graph, and they; /// traverse the graph in post-order, they can effectively do pair-wise; /// interprocedural optimizations for all call edges in the program while; /// incrementally refining it and improving the context of these pair-wise; /// optimizations. At each call site edge, the callee has already been; /// optimized as much as is possible. This in turn allows very accurate; /// analysis of it for IPO.; ///; /// A secondary more general goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced into the call; /// graph by devirtualization or other technique, and thus ensures that; /// subsequent pair-wise interprocedural optimizations observe the optimized; /// form of these functions. The (potentially transitive) reference; /// reachability used by the reference graph is a conservative approximation; /// that still allows us to have independent regions of the graph.; ///; /// FIXME: There is one major drawback of the referen",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:1401,optimiz,optimizations,1401,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,1,['optimiz'],['optimizations']
Performance,"set; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = add i64 %7, %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = add i64 %9, %10; // %12 = add i64 %11, struct_field_2 ; Constant offset; // %p = inttoptr i64 %12 to i32*; // load %p2; // ...; //; // If the target uses alias analysis in codegen, this pass will lower a GEP; // with multiple indices into multiple GEPs with a single index:; // BB1:; // %1 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = getelementptr i8* %1, i64 %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = getelementptr i8* %3, i64 %4; // %6 = getelementptr i8* %5, struct_field_3 ; Constant offset; // %p = bitcast i8* %6 to i32*; // load %p; // ...; // BB2:; // %7 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = getelementptr i8* %7, i64 %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = getelementptr i8* %9, i64 %10; // %12 = getelementptr i8* %11, struct_field_2 ; Constant offset; // %p2 = bitcast i8* %12 to i32*; // load %p2; // ...; //; // Lowering GEPs can also benefit other passes such as LICM and CGP.; // LICM (Loop Invariant Code Motion) can not hoist/sink a GEP of multiple; // indices if one of the index is variant. If we lower such GEP into invariant; // parts and variant parts, LICM can hoist/sink those invariant parts.; // CGP (CodeGen Prepare) tries to sink address calculations that match the; // target's addressing modes. A GEP with multiple indices may not match and will; // not be sunk. If we lower such GEP into smaller parts, CGP may sink some of; // them. So we end up with a better addressing mode.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:5653,load,load,5653,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,1,['load'],['load']
Performance,"shot() can be made *lazy* setting the appropriate flag in the snapshot options.|. ### Queries. These operations do not modify the dataframe or book computations but simply return information on the RDataFrame object. | **Operation** | **Description** |; |---------------------|-----------------|; | Describe() | Get useful information describing the dataframe, e.g. columns and their types. |; | GetColumnNames() | Get the names of all the available columns of the dataset. |; | GetColumnType() | Return the type of a given column as a string. |; | GetColumnTypeNamesList() | Return the list of type names of columns in the dataset. |; | GetDefinedColumnNames() | Get the names of all the defined columns. |; | GetFilterNames() | Return the names of all filters in the computation graph. |; | GetNRuns() | Return the number of event loops run by this RDataFrame instance so far. |; | GetNSlots() | Return the number of processing slots that RDataFrame will use during the event loop (i.e. the concurrency level). |; | SaveGraph() | Store the computation graph of an RDataFrame in [DOT format (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) for easy inspection. See the [relevant section](\ref representgraph) for details. |. \anchor introduction; ## Introduction; Users define their analysis as a sequence of operations to be performed on the dataframe object; the framework; takes care of the management of the loop over entries as well as low-level details such as I/O and parallelization.; RDataFrame provides methods to perform most common operations required by ROOT analyses;; at the same time, users can just as easily specify custom code that will be executed in the event loop. RDataFrame is built with a *modular* and *flexible* workflow in mind, summarised as follows:. 1. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, [CSV files](https://root.cern/doc/master/df014__CSVDataSource_8C.html), [SQLite files](ht",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:11106,concurren,concurrency,11106,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['concurren'],['concurrency']
Performance,"sible for finding the patterns that can be lowered to; // complex instructions, and building a graph to represent the complex; // structures. Starting from the ""Converging Shuffle"" (a shuffle that; // reinterleaves the complex components, with a mask of <0, 2, 1, 3>), the; // operands are evaluated and identified as ""Composite Nodes"" (collections of; // instructions that can potentially be lowered to a single complex; // instruction). This is performed by checking the real and imaginary components; // and tracking the data flow for each component while following the operand; // pairs. Validity of each node is expected to be done upon creation, and any; // validation errors should halt traversal and prevent further graph; // construction.; // Instead of relying on Shuffle operations, vector interleaving and; // deinterleaving can be represented by vector.interleave2 and; // vector.deinterleave2 intrinsics. Scalable vectors can be represented only by; // these intrinsics, whereas, fixed-width vectors are recognized for both; // shufflevector instruction and intrinsics.; //; // Replacement:; // This step traverses the graph built up by identification, delegating to the; // target to validate and generate the correct intrinsics, and plumbs them; // together connecting each end of the new intrinsics graph to the existing; // use-def chain. This step is assumed to finish successfully, as all; // information is expected to be correct by this point.; //; //; // Internal data structure:; // ComplexDeinterleavingGraph:; // Keeps references to all the valid CompositeNodes formed as part of the; // transformation, and every Instruction contained within said nodes. It also; // holds onto a reference to the root Instruction, and the root node that should; // replace it.; //; // ComplexDeinterleavingCompositeNode:; // A CompositeNode represents a single transformation point; each node should; // transform into a single complex instruction (ignoring vector splitting, which; // would",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:1341,Scalab,Scalable,1341,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,1,['Scalab'],['Scalable']
Performance,"sing new() operator and their deletion is done by; TGeoManager class. ### Available geometrical transformations. #### TGeoTranslation; Represent a (dx,dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted. ~~~ {.cpp}; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);; ~~~. #### Rotations; Represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :. ~~~ {.cpp}; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; ~~~. This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. ~~~ {.cpp}; r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); ~~~. This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. #### Scale transformations; Represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. #### Combined transformations; Represent a rotation followed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation. ~~~ {.cpp}; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;; ...; TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot); ~~~. #### TGeoGenTrans; Combined transformations including a scale. Not implemented. #### TGeoIdentity; A generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMatrix.cxx:6627,perform,performed,6627,geom/geom/src/TGeoMatrix.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMatrix.cxx,1,['perform'],['performed']
Performance,"sing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; //________________________________________________________________________; //; // Class for xml code generation; // It should be used for generation of xml streamers, which could be used outside root; // environment. This means, that with help of such streamers user can read and write; // objects from/to xml file, which later can be accepted by ROOT.; //; // At the moment supported only classes, which are not inherited from TObject; // and which not contains any TObject members.; //; // To generate xml code:; //; // 1. ROOT library with required classes should be created.; // In general, without such library non of user objects can be stored and; // retrieved from any ROOT file; //; // 2. Generate xml streamers by root script like:; //; // void generate() {; // gSystem->Load(""libRXML.so""); // load ROOT xml library; // gSystem->Load(""libuser.so""); // load user ROOT library; //; // TList lst;; // lst.Add(TClass::GetClass(""TUserClass1""));; // lst.Add(TClass::GetClass(""TUserClass2""));; // ...; // TXMLPlayer player;; // player.ProduceCode(&lst, ""streamers""); // create xml streamers; // }; //; // 3. Copy ""streamers.h"", ""streamers.cxx"", ""TXmlFile.h"", ""TXmlFile.cxx"" files; // to user project and compile them. TXmlFile class implementation can be taken; // from http://web-docs.gsi.de/~linev/xmlfile.tar.gz; //; // TXMLPlayer class generates one function per class, which called class streamer.; // Name of such function for class TExample will be TExample_streamer.; //; // Following data members for streamed classes are supported:; // - simple data types (int, double, float); // - array of simple types (int[5], double[5][6]); // - dynamic array of simple types (int* with comment field // [fSize]); // - const char*; // - object of any nonROOT class; // - pointer on object; // - array of objects; // - array",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/xml/src/TXMLPlayer.cxx:1232,load,load,1232,io/xml/src/TXMLPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/xml/src/TXMLPlayer.cxx,2,"['Load', 'load']","['Load', 'load']"
Performance,"size_of_arr3-1); /// As a comparison; /// ~~~ {.cpp}; /// tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; /// ~~~; /// will draw the sum arr3 for the index 0 to 2 only if the; /// actual_size_of_arr3 is greater or equal to 3.; /// Note that the array in 'primary' is flattened/linearized thus using; /// `Alt$` with multi-dimensional arrays of different dimensions in unlikely; /// to yield the expected results. To visualize a bit more what elements; /// would be matched by TTree::Draw, TTree::Scan can be used:; /// ~~~ {.cpp}; /// tree->Scan(""arr1:Alt$(arr2,0)"");; /// ~~~; /// will print on one line the value of arr1 and (arr2,0) that will be; /// matched by; /// ~~~ {.cpp}; /// tree->Draw(""arr1-Alt$(arr2,0)"");; /// ~~~; /// The ternary operator is not directly supported in TTree::Draw however, to plot the; /// equivalent of `var2<20 ? -99 : var1`, you can use:; /// ~~~ {.cpp}; /// tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");; /// ~~~; ///; /// ### Drawing a user function accessing the TTree data directly; ///; /// If the formula contains a file name, TTree::MakeProxy will be used; /// to load and execute this file. In particular it will draw the; /// result of a function with the same name as the file. The function; /// will be executed in a context where the name of the branches can; /// be used as a C++ variable.; ///; /// For example draw px using the file hsimple.root (generated by the; /// hsimple.C tutorial), we need a file named hsimple.cxx:; /// ~~~ {.cpp}; /// double hsimple() {; /// return px;; /// }; /// ~~~; /// MakeProxy can then be used indirectly via the TTree::Draw interface; /// as follow:; /// ~~~ {.cpp}; /// new TFile(""hsimple.root""); /// ntuple->Draw(""hsimple.cxx"");; /// ~~~; /// A more complete example is available in the tutorials directory:; /// `h1analysisProxy.cxx`, `h1analysProxy.h` and `h1analysisProxyCut.C`; /// which reimplement the selector found in `h1analysis.C`; ///; /// The main features of this facility are:; ///; /// * on-demand loading ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:18706,load,load,18706,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['load'],['load']
Performance,"so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v = load float addrspace(3)* %1 ; emits ld.shared.f32; // propagating the addrspace(3) from @a to %1. As the result, the NVPTX; // codegen is able to emit ld.shared.f32 for %v.; //; // Address space inference works in two steps. First, it uses a data-flow; // analysis to infer as many generic pointers as possible to point to only one; // specific address space. In the above example, it can prove that %1 only; // points to addrspace(3). This algorithm was published in; // CUDA: Compiling and optimizing for a GPU platform; // Chakrabarti, Grover, Aarts, Kong, Kudlur, Lin, Marathe, Murphy, Wang; // ICCS 2012; //; // Then, address space inference replaces all refinable generic pointers with; // equivalent specific pointers.; //; // The major challenge of implementing this optimization is handling PHINodes,; // which may create loops in the data flow graph. This brings two complications.; //; // First, the data flow analysis in Step 1 needs to be circular. F",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:1911,optimiz,optimizes,1911,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,2,"['load', 'optimiz']","['load', 'optimizes']"
Performance,"spheres are drawn instead of boxes. #### `TH3` as iso-surface(s) - (`TGLIsoPainter`); The supported option is:. - `""GLISO"" :` TH3 is drawn using iso-surfaces. #### `TH3` as color boxes - (`TGLVoxelPainter`); The supported option is:. - `""GLCOL"" :` TH3 is drawn using semi-transparent colored boxes.; See `$ROOTSYS/tutorials/gl/glvox1.C`. #### `TF3` (implicit function) - (`TGLTF3Painter`); The supported option is:. - `""GLTF3"" :` Draw a `TF3`. #### Parametric surfaces - (`TGLParametricPlot`); `$ROOTSYS/tutorials/gl/glparametric.C` shows how to create parametric equations and; visualize the surface. ### Interaction with the plots. #### General information. All the interactions are implemented via standard methods `DistancetoPrimitive` and; `ExecuteEvent`. That's why all the interactions with the OpenGL plots are possible i; only when the mouse cursor is in the plot's area (the plot's area is the part of a the pad; occupied by gl-produced picture). If the mouse cursor is not above gl-picture,; the standard pad interaction is performed. #### Selectable parts. Different parts of the plot can be selected:. - *xoz, yoz, xoy back planes*:; When such a plane selected, it's highlighted in green if the dynamic slicing; by this plane is supported, and it's highlighted in red, if the dynamic slicing; is not supported.; -*The plot itself*:; On surfaces, the selected surface is outlined in red. (TF3 and ISO are not; outlined). On lego plots, the selected bin is highlihted. The bin number and content are displayed in pad's status; bar. In box plots, the box or sphere is highlighted and the bin info is displayed in pad's status bar. #### Rotation and zooming. - *Rotation*:. When the plot is selected, it can be rotated by pressing and holding the left mouse button and move the cursor.; - *Zoom/Unzoom*:. Mouse wheel or `'j'`, `'J'`, `'k'`, `'K'` keys. #### Panning. The selected plot can be moved in a pad's area by; pressing and holding the left mouse button and the shift key. ### Box cut;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLHistPainter.cxx:2859,perform,performed,2859,graf3d/gl/src/TGLHistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLHistPainter.cxx,1,['perform'],['performed']
Performance,ss of Kernarg segment. This; /// is directly copied from the kernargPtr in the dispatch packet. Having CP; /// load it once avoids loading it at the beginning of every wavefront.; ///; /// Dispatch Id (enable_sgpr_dispatch_id):; /// Number of User SGPR registers: 2. 64 bit Dispatch ID of the dispatch; /// packet being executed.; ///; /// Flat Scratch Init (enable_sgpr_flat_scratch_init):; /// Number of User SGPR registers: 2. This is 2 SGPRs.; ///; /// For CI/VI:; /// The first SGPR is a 32 bit byte offset from SH_MEM_HIDDEN_PRIVATE_BASE; /// to base of memory for scratch for this dispatch. This is the same offset; /// used in computing the Scratch Segment Buffer base address. The value of; /// Scratch Wave Offset must be added by the kernel code and moved to; /// SGPRn-4 for use as the FLAT SCRATCH BASE in flat memory instructions.; ///; /// The second SGPR is 32 bit byte size of a single work-item's scratch; /// memory usage. This is directly loaded from the dispatch packet Private; /// Segment Byte Size and rounded up to a multiple of DWORD.; ///; /// \todo [Does CP need to round this to >4 byte alignment?]; ///; /// The kernel code must move to SGPRn-3 for use as the FLAT SCRATCH SIZE in; /// flat memory instructions. Having CP load it once avoids loading it at; /// the beginning of every wavefront.; ///; /// For PI:; /// This is the 64 bit base address of the scratch backing memory for; /// allocated by CP for this dispatch.; ///; /// Private Segment Size (enable_sgpr_private_segment_size):; /// Number of User SGPR registers: 1. The 32 bit byte size of a single; /// work-item's scratch memory allocation. This is the value from the dispatch; /// packet. Private Segment Byte Size rounded up by CP to a multiple of DWORD.; ///; /// \todo [Does CP need to round this to >4 byte alignment?]; ///; /// Having CP load it once avoids loading it at the beginning of every; /// wavefront.; ///; /// \todo [This will not be used for CI/VI since it is the same value as; /// the ,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:4061,load,loaded,4061,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,1,['load'],['loaded']
Performance,"ssure, the best load latencies are hidden; //; // Moreover some specifities (like the fact a lot of instructions in the shader; // have few dependencies) makes the generic scheduler have some unpredictable; // behaviours. For example when register pressure becomes high, it can either; // manage to prevent register pressure from going too high, or it can; // increase register pressure even more than if it hadn't taken register; // pressure into account.; //; // Also some other bad behaviours are generated, like loading at the beginning; // of the shader a constant in VGPR you won't need until the end of the shader.; //; // The scheduling problem for SI can distinguish three main parts:; // . Hiding high latencies (texture sampling, etc); // . Hiding low latencies (SGPR constant loading, etc); // . Keeping register usage low for better latency hiding and general; // performance; //; // Some other things can also affect performance, but are hard to predict; // (cache usage, the fact the HW can issue several instructions from different; // wavefronts if different types, etc); //; // This scheduler tries to solve the scheduling problem by dividing it into; // simpler sub-problems. It divides the instructions into blocks, schedules; // locally inside the blocks where it takes care of low latencies, and then; // chooses the order of the blocks by taking care of high latencies.; // Dividing the instructions into blocks helps control keeping register; // usage low.; //; // First the instructions are put into blocks.; // We want the blocks help control register usage and hide high latencies; // later. To help control register usage, we typically want all local; // computations, when for example you create a result that can be consumed; // right away, to be contained in a block. Block inputs and outputs would; // typically be important results that are needed in several locations of; // the shader. Since we do want blocks to help hide high latencies, we want; // the instruction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:1437,latency,latency,1437,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,4,"['cache', 'latency', 'perform']","['cache', 'latency', 'performance']"
Performance,"st argument on the rootcling command line.; 2) Note that the LinkDef file name must contain the string:; LinkDef.h, Linkdef.h or linkdef.h, i.e. NA49_LinkDef.h. Before specifying the first header file one can also add include; file directories to be searched and preprocessor defines, like:; -I$MYPROJECT/include -DDebug=1. NOTA BENE: the dictionaries that will be used within the same project must; have unique names. The (optional) file LinkDef.h looks like:. #ifdef __CLING__. #pragma link off all globals;; #pragma link off all classes;; #pragma link off all functions;. #pragma link C++ class TAxis;; #pragma link C++ class TAttAxis-;; #pragma link C++ class TArrayC-!;; #pragma link C++ class AliEvent+;. #pragma link C++ function StrDup;; #pragma link C++ function operator+(const TString&,const TString&);. #pragma link C++ global gROOT;; #pragma link C++ global gEnv;. #pragma link C++ enum EMessageTypes;. #endif. This file tells rootcling which classes will be persisted on disk and what; entities will trigger automatic load of the shared library which contains; it. A trailing - in the class name tells rootcling to not generate the; Streamer() method. This is necessary for those classes that need a; customized Streamer() method. A trailing ! in the class name tells rootcling; to not generate the operator>>(TBuffer &b, MyClass *&obj) function. This is; necessary to be able to write pointers to objects of classes not inheriting; from TObject. See for an example the source of the TArrayF class.; If the class contains a ClassDef macro, a trailing + in the class; name tells rootcling to generate an automatic Streamer(), i.e. a; streamer that let ROOT do automatic schema evolution. Otherwise, a; trailing + in the class name tells rootcling to generate a ShowMember; function and a Shadow Class. The + option is mutually exclusive with; the - option. For legacy reasons it is not yet the default.; When the linkdef file is not specified a default version exporting; the classes with",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling-argparse.py:1156,load,load,1156,core/dictgen/src/rootcling-argparse.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling-argparse.py,1,['load'],['load']
Performance,"st"");; TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; ~~~; ## Example of Loop on TEntryList with a TChain; ~~~ {.cpp}; void loopChain() {; TFile *fe = TFile::Open(""myelist.root"");; TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; TChain *chain = new TChain(""ntuple"");; chain->Add(""hsimple.root"");; chain->Add(""hsimple2.root"");; Long64_t listEntries = myelist->GetN();; Long64_t chainEntries = chain->GetEntries();; Int_t treenum = 0;; chain->SetEntryList(myelist);. for (entry=start;entry < end;entry++) {; entryNumber = chain->GetEntryNumber(entry);; if (entryNumber < 0) break;; localEntry = chain->LoadTree(entryNumber);; if (localEntry < 0) break;; ....; then either call; branch->GetEntry(localEntry);; or; chain->GetEntry(entryNumber);; In the later case the LoadTree is then somewhat redundant.; ...; }; }; ~~~; When using the TEntryList interface directly, you can get the 'tree number' and entry in; the current tree (i.e. value similar to the return value of LoadTree) from calling; TEntryList::GetEntryAndTree:; ~~~ {.cpp}; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; ~~~; to obtain the entry number within the chain you need to add to it the value of; `treeEntry+ch->GetTreeOffset()[treenum]`; such that the loop in the previous example can also be written as:; ~~~ {.cpp}; for (Long64_t el = 0; el < listEntries; el++) {; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);. ch->LoadTree(chainEntry); // this also returns treeEntry; needed_branch->GetEntry(treeEntry);; }; ~~~; ## TSelectors. To fill an TEntryList from a TSelector correctly, one must add the TEntryList object; to the output list of the selector (TSelector::fOutput). This is the only way to; make the sub-lists of the TEntryList switch when the current tree of the TChain is; changed. ## Using a TEntryList as",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:2610,Load,LoadTree,2610,tree/tree/src/TEntryList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx,1,['Load'],['LoadTree']
Performance,"stage); /// R: Instruction retired; /// =: Instruction waiting in the Scheduler's queue; /// -: Instruction executed, waiting to retire in order.; ///; /// dots ('.') and empty spaces are cycles where the instruction is not; /// in-flight.; ///; /// The last column is the assembly instruction associated to the entry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, class TimelineView also reports extra timing info; /// in another table named ""Average Wait times"" (see example below).; ///; ///; /// Average Wait times (based on the timeline view):; /// [0]: Executions; /// [1]: Average time spent waiting in a scheduler's queue; /// [2]: Average time spent waiting in a scheduler's queue while ready; /// [3]: Average time elapsed from WB until retire stage; ///; ///	[0]	[1]	[2]	[3]; /// 0.	 2	1.0	1.0	3.0	vmovshdup %xmm0, %xmm1; /// 1.	 2	1.0	1.0	3.0	vpermilpd $1, %xmm0, %xmm2; /// 2.	 2	1.0	1.0	2.5	vpermilps $231, %xmm0, %xmm5; /// 3.	 2	1.5	0.5	1.0	vaddss %xmm1, %xmm0, %xmm3; /// 4.	 2	3.5	0.0	0.0	vaddss %xmm3, %xmm2, %xmm4; /// 5.	 2	6.5	0.0	0.0	vaddss %xmm4, %xmm5, %xmm6; /// 2	2.4	0.6	1.6 <total>; ///; /// By comparing column [2] with column [1], we get an idea about how many; /// cycles were spent in the scheduler's queue due to data dependencies.; ///; /// In this example, instruction 5 spent an average of ~6 cycles in the; /// scheduler's queue. A",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:3200,queue,queue,3200,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,1,['queue'],['queue']
Performance,"start chrome in batch, used for image production, like ""$prog --headless --disable-gpu $geometry $url""; /// WebGui.ChromeHeadless: command to start chrome in headless mode, like ""fork: --headless --disable-gpu $geometry $url""; /// WebGui.ChromeInteractive: command to start chrome in interactive mode, like ""$prog $geometry --app=\'$url\' &""; /// WebGui.Firefox: full path to Mozilla Firefox executable; /// WebGui.FirefoxHeadless: command to start Firefox in headless mode, like ""fork:--headless --private-window --no-remote $profile $url""; /// WebGui.FirefoxInteractive: command to start Firefox in interactive mode, like ""$prog --private-window \'$url\' &""; /// WebGui.FirefoxProfile: name of Firefox profile to use; /// WebGui.FirefoxProfilePath: file path to Firefox profile; /// WebGui.FirefoxRandomProfile: usage of random Firefox profile -1 never, 0 - only for headless mode (dflt), 1 - always; /// WebGui.LaunchTmout: time required to start process in seconds (default 30 s); /// WebGui.OperationTmout: time required to perform WebWindow operation like execute command or update drawings; /// WebGui.RecordData: if specified enables data recording for each web window 0 - off, 1 - on; /// WebGui.JsonComp: compression factor for JSON conversion, if not specified - each widget uses own default values; /// WebGui.ForceHttp: 0 - off (default), 1 - always create real http server to run web window; /// WebGui.Console: -1 - output only console.error(), 0 - add console.warn(), 1 - add console.log() output; /// WebGui.ConnCredits: 10 - number of packets which can be send by server or client without acknowledge from receiving side; /// WebGui.openui5src: alternative location for openui5 like https://openui5.hana.ondemand.com/1.128.0/; /// WebGui.openui5libs: list of pre-loaded ui5 libs like sap.m, sap.ui.layout, sap.ui.unified; /// WebGui.openui5theme: openui5 theme like sap_belize (default) or sap_fiori_3; ///; /// THttpServer-related parameters documented in \ref CreateServer method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindowsManager.cxx:2261,perform,perform,2261,gui/webdisplay/src/RWebWindowsManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindowsManager.cxx,2,"['load', 'perform']","['loaded', 'perform']"
Performance,"state at a specific cycle.; ///; /// Possible instruction states are:; /// D: Instruction Dispatched; /// e: Instruction Executing; /// E: Instruction Executed (write-back stage); /// R: Instruction retired; /// =: Instruction waiting in the Scheduler's queue; /// -: Instruction executed, waiting to retire in order.; ///; /// dots ('.') and empty spaces are cycles where the instruction is not; /// in-flight.; ///; /// The last column is the assembly instruction associated to the entry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, class TimelineView also reports extra timing info; /// in another table named ""Average Wait times"" (see example below).; ///; ///; /// Average Wait times (based on the timeline view):; /// [0]: Executions; /// [1]: Average time spent waiting in a scheduler's queue; /// [2]: Average time spent waiting in a scheduler's queue while ready; /// [3]: Average time elapsed from WB until retire stage; ///; ///	[0]	[1]	[2]	[3]; /// 0.	 2	1.0	1.0	3.0	vmovshdup %xmm0, %xmm1; /// 1.	 2	1.0	1.0	3.0	vpermilpd $1, %xmm0, %xmm2; /// 2.	 2	1.0	1.0	2.5	vpermilps $231, %xmm0, %xmm5; /// 3.	 2	1.5	0.5	1.0	vaddss %xmm1, %xmm0, %xmm3; /// 4.	 2	3.5	0.0	0.0	vaddss %xmm3, %xmm2, %xmm4; /// 5.	 2	6.5	0.0	0.0	vaddss %xmm4, %xmm5, %xmm6; /// 2	2.4	0.6	1.6 <total>; ///; /// By comparing column [2] with column [1], we get an idea about how many; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:3030,bottleneck,bottlenecks,3030,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,1,['bottleneck'],['bottlenecks']
Performance,"t and are of good quality. Their size varies with large steps; and they cannot be rotated.; Precision 1 and 2 fonts have a different behaviour depending if the; True Type Fonts (TTF) are used or not. If TTF are used, you always get very good; quality scalable and rotatable fonts.; These days TTF fonts are rendered fast enough and can be used in all cases. \anchor ATTTEXT52; ### How to use True Type Fonts. TTF fonts are used by default. They can be deactivated via the following line; in the `.rootrc` file:. ~~~ {.cpp}; Unix.*.Root.UseTTFonts: false; ~~~. \anchor ATTTEXT53; ### List of the currently supported fonts. ~~~ {.cpp}; Font number TTF Names PostScript/PDF Names; 1 : ""Free Serif Italic"" ""Times-Italic""; 2 : ""Free Serif Bold"" ""Times-Bold""; 3 : ""Free Serif Bold Italic"" ""Times-BoldItalic""; 4 : ""Tex Gyre Regular"" ""Helvetica""; 5 : ""Tex Gyre Italic"" ""Helvetica-Oblique""; 6 : ""Tex Gyre Bold"" ""Helvetica-Bold""; 7 : ""Tex Gyre Bold Italic"" ""Helvetica-BoldOblique""; 8 : ""Free Mono"" ""Courier""; 9 : ""Free Mono Oblique"" ""Courier-Oblique""; 10 : ""Free Mono Bold"" ""Courier-Bold""; 11 : ""Free Mono Bold Oblique"" ""Courier-BoldOblique""; 12 : ""Symbol"" ""Symbol""; 13 : ""Free Serif"" ""Times-Roman""; 14 : ""Wingdings"" ""ZapfDingbats""; ~~~. The PostScript and PDF backends use the original PostScript-defined 13 fonts' styles; forming four type families (Courier, Helvetica, Times, Symbol) as listed in the; ""Core Font Set"" section of [this page](https://en.wikipedia.org/wiki/PostScript_fonts).; These fonts are always available and do not need to be loaded in the PS or PDF files; allowing to keep the files' sizes small. On screen, text is rendered using free TTF fonts similar to the PDF ones. The corresponding; font files are coming with the ROOT distribution in `$ROOTSYS/fonts/Free*`. Begin_Macro; fonts.C; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// AttText default constructor.; ///; /// Default text attributes are taken from the current style.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TAttText.cxx:6718,load,loaded,6718,core/base/src/TAttText.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TAttText.cxx,1,['load'],['loaded']
Performance,"t be described in TBuffer3D; in the local reference frame, complete with the local/master translation. The; viewer indicates this through the interface method. ~~~ {.cpp}; PreferLocalFrame(); ~~~. If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different `fLocalMaster` placements. For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the `fLocalMaster` transform and the; `fColor` and `fTransparency` attributes, which can be varied for each physical; object. As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. ### Scene Rebuilds. It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. - It already has the object internally cached .; - The object falls outside some 'interest' limits of the viewer camera.; - The object is too small to be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should not try to make any assumptions about what the viewer; did with it. This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad repaint at present), and thus collect these objects if the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer3D.cxx:6427,cache,cached,6427,core/base/src/TBuffer3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer3D.cxx,1,['cache'],['cached']
Performance,"t from all of its fields and bases.; // * __declspec(align) on bitfields has the effect of changing the bitfield's; // alignment instead of its required alignment. This is the only known way; // to make the alignment of a struct bigger than 8. Interestingly enough; // this alignment is also immune to the effects of #pragma pack and can be; // used to create structures with large alignment under #pragma pack.; // However, because it does not impact required alignment, such a structure,; // when used as a field or base, will not be aligned if #pragma pack is; // still active at the time of use.; //; // Known incompatibilities:; // * all: #pragma pack between fields in a record; // * 2010 and back: If the last field in a record is a bitfield, every object; // laid out after the record will have extra padding inserted before it. The; // extra padding will have size equal to the size of the storage class of the; // bitfield. 0 sized bitfields don't exhibit this behavior and the extra; // padding can be avoided by adding a 0 sized bitfield after the non-zero-; // sized bitfield.; // * 2012 and back: In 64-bit mode, if the alignment of a record is 16 or; // greater due to __declspec(align()) then a second layout phase occurs after; // The locations of the vf and vb pointers are known. This layout phase; // suffers from the ""last field is a bitfield"" bug in 2010 and results in; // _every_ field getting padding put in front of it, potentially including the; // vfptr, leaving the vfprt at a non-zero location which results in a fault if; // anything tries to read the vftbl. The second layout phase also treats; // bitfields as separate entities and gives them each storage rather than; // packing them. Additionally, because this phase appears to perform a; // (an unstable) sort on the members before laying them out and because merged; // bitfields have the same address, the bitfields end up in whatever order; // the sort left them in, a behavior we could never hope to replicate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:5856,perform,perform,5856,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['perform'],['perform']
Performance,"t to address several; * issues. First one, and most important is that X Window System; * completely lacks any tools for image manipulation, except for very; * rudimentary operations. With Introduction of Render extentions in; * XFree86 4.0 that situation is changing, but still is far from; * perfect. There need is therefore to implement client side image; * manipulation. That inturn creates a problem of image data transfer; * between Server and client.; *; * To avoid that full-time image storage on the client side is needed.; * Which is memory extensive. So there appears to be a need for some; * in-memory compression.; *; * On the other side there is an image quality issue. Its easy to write; * a scaling function by simply dropping out or duplicating pixels,; * but quality is awfull. What is needed is very fast; * averaging/interpolation code. That brings us to the issue of 8 bits; * per channel. Add two pixels together and you get overflow. So all the; * math has to be performed in different colorspace and then converted; * back. On the other side, such a conversion may discard valuable bits,; * so some compensation method has to be implemented.; *; * On the text drawing side of things, there are numerous problems just; * as well. Native X fonts look ugly as soon as you try to show any; * decently sized text. That is supposed to be solved with said Render; * extensions to XFree86, but as experiense has shown, things aren't as; * easy as it looks, besides one wants one's app to run well under any X; * Server. FreeType library provides a solution, but not always; * available. Another problem is that if you keep all your images on the; * client side, you want to draw text on client side as well.; *; * The solution is to provide transparent interface that could use both; * X fonts and FreeType, cache glyphs on the client side and possibly; * perform smoothing of ugly X fonts.; *; * There is no library solving all this problems in one fell swoop,; * except for monstrous ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/afterimage.h:2097,perform,performed,2097,graf2d/asimage/src/libAfterImage/afterimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/afterimage.h,1,['perform'],['performed']
Performance,"t use case is to take a workspace PDF as prototype and; /// ""split"" a parameter of that PDF into two specialized parameters; /// depending on a category in the dataset.; ///; /// For example, given a Gaussian; /// PDF \f$ G(x \,|\, m,s) \f$ we want to construct a \f$ G_a(x \,|\, m_a,s) \f$ and a \f$ G_b(x \,|\, m_b,s) \f$; /// with different mean parameters to be fit to a dataset with observables; /// \f$ (x,c) \f$ where \f$ c \f$ is a category with states 'a' and 'b'.; ///; /// Using RooSimWSTool, one can create a simultaneous PDF from \f$ G_a \f$ and \f$ G_b \f$; /// from \f$ G \f$ with the following commands:; /// ```; /// RooSimWSTool wst(wspace);; /// wst.build(""G_sim"", ""G"", SplitParam(""m"",""c""));; /// ```; ///; /// #### Splitting using a product category; /// From this simple example one can go to builds of arbitrary complexity; /// by specifying multiple SplitParam arguments on multiple parameters; /// involving multiple splitting categories. Splits can also be performed; /// in the product of multiple categories, *i.e.*,; /// ```; /// wst.build(""G_sim"", ""G"", SplitParam(""m"",""c,d""));; /// ```; /// splits the parameter \f$ m \f$ in the product of the states of \f$ c \f$ and; /// \f$ d \f$.; ///; /// #### Constrained split; /// Another possibility; /// is the ""constrained"" split, which clones the parameter for all but one state; /// and inserts a formula specialization in a chosen state that evaluates; /// to \f$ 1 - \sum_i(a_i) \f$ where \f$ a_i \f$ are all other specializations. For example,; /// given a category \f$ c \f$ with the states `""A"",""B"",""C"",""D""`, the specification; /// ```; /// SplitParamConstrained(""m"",""c"",""D""); /// ```; /// will create the parameters \f$ m_A,m_B,m_C \f$ and a formula expression \f$ m_D \f$; /// that evaluates to \f$ (1-(m_A+m_B+m_C)) \f$. Constrained splits can also be; /// specified in the product of categories. In that case, the name of the; /// remainder state follows the syntax `""{State1;State2}""`, where `State1` and; /// `State",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimWSTool.cxx:2010,perform,performed,2010,roofit/roofitcore/src/RooSimWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimWSTool.cxx,1,['perform'],['performed']
Performance,"t.SetFillColor(ROOT.kBlue). LiveVisualize([h_gaus, h_exp, h_random], set_fill_color); ~~~. - Passing a Dictionary of drawables and callback functions: ; For more control, you can create a dictionary where keys are plots and values are corresponding (optional) callback functions. For example:. ~~~{.py}; plot_callback_dict = {; graph: set_marker,; h_exp: fit_exp,; tprofile_2d: None; }. LiveVisualize(plot_callback_dict); ~~~. - Passing a Dictionary of drawables and callback functions with a global callback function: ; You can also combine a dictionary of plots and callbacks with a global callback function:. ~~~{.py}; LiveVisualize(plot_callback_dict, write_to_tfile); ~~~. \note The allowed operations to pass to LiveVisualize are:; - Histo1D(), Histo2D(), Histo3D(); - Graph(); - Profile1D(), Profile2D(). \warning The Live Visualization feature is only supported for the Dask backend. \anchor parallel-execution; ## Performance tips and parallel execution; As pointed out before in this document, RDataFrame can transparently perform multi-threaded event loops to speed up; the execution of its actions. Users have to call ROOT::EnableImplicitMT() *before* constructing the RDataFrame; object to indicate that it should take advantage of a pool of worker threads. **Each worker thread processes a distinct; subset of entries**, and their partial results are merged before returning the final values to the user.; There are no guarantees on the order in which threads will process the batches of entries.; In particular, note that this means that, for multi-thread event loops, there is no; guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. Thi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:47072,Perform,Performance,47072,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,3,"['Perform', 'multi-thread', 'perform']","['Performance', 'multi-threaded', 'perform']"
Performance,"t; /// directory structure is requested ('-' option). With the '-' option the libraries; /// are created directly in the directory 'build_dir'; in particular this means that; /// 2 scripts with the same name in different source directory will over-write each; /// other's library.; /// See also TSystem::SetBuildDir.; ///; /// If dirmode is not zero and we need to create the target directory, the; /// file mode bit will be change to 'dirmode' using chmod.; ///; /// If library_specified is not specified, CompileMacro generate a default name; /// for library by taking the name of the file ""filename"" but replacing the; /// dot before the extension by an underscore and by adding the shared; /// library extension for the current platform.; /// For example on most platform, hsimple.cxx will generate hsimple_cxx.so; ///; /// It uses the directive fMakeSharedLibs to create a shared library.; /// If loading the shared library fails, it tries to output a list of missing; /// symbols by creating an executable (on some platforms like OSF, this does; /// not HAVE to be an executable) containing the script. It uses the; /// directive fMakeExe to do so.; /// For both directives, before passing them to TSystem::Exec, it expands the; /// variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs,; /// $DepLibs, $ExeName and $ObjectFiles. See SetMakeSharedLib() for more; /// information on those variables.; ///; /// This method is used to implement the following feature:; ///; /// Synopsis:; ///; /// The purpose of this addition is to allow the user to use an external; /// compiler to create a shared library from its C++ macro (scripts).; /// Currently in order to execute a script, a user has to type at the root; /// prompt; /// ~~~ {.cpp}; /// .X myfunc.C(arg1,arg2); /// ~~~; /// We allow them to type:; /// ~~~ {.cpp}; /// .X myfunc.C++(arg1,arg2); /// ~~~; /// or; /// ~~~ {.cpp}; /// .X myfunc.C+(arg1,arg2); /// ~~~; /// In which case an external compiler will be called t",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:2063,load,loading,2063,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['load'],['loading']
Performance,"tNumber; // Read fEventNumber; /// if (n<10 || n>10) { ... }; /// ~~~; /// is more efficient than; /// ~~~ {.cpp}; /// if (fEventNumber<10 || fEventNumber>10); /// ~~~; /// Also, optionally, the generated selector will also call methods named; /// macrofilename_methodname in each of 6 main selector methods if the method; /// macrofilename_methodname exist (Where macrofilename is stripped of its; /// extension).; ///; /// Concretely, with the script named h1analysisProxy.C,; ///; /// - The method calls the method (if it exist); /// - Begin -> void h1analysisProxy_Begin(TTree*);; /// - SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; /// - Notify -> bool h1analysisProxy_Notify();; /// - Process -> bool h1analysisProxy_Process(Long64_t);; /// - SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; /// - Terminate -> void h1analysisProxy_Terminate();; ///; /// If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; /// it is included before the declaration of the proxy class. This can; /// be used in particular to insure that the include files needed by; /// the macro file are properly loaded.; ///; /// The default histogram is accessible via the variable named 'htemp'.; ///; /// If the library of the classes describing the data in the branch is; /// loaded, the skeleton will add the needed `include` statements and; /// give the ability to access the object stored in the branches.; ///; /// To draw px using the file hsimple.root (generated by the; /// hsimple.C tutorial), we need a file named hsimple.cxx:; /// ~~~ {.cpp}; /// double hsimple() {; /// return px;; /// }; /// ~~~; /// MakeProxy can then be used indirectly via the TTree::Draw interface; /// as follow:; /// ~~~ {.cpp}; /// new TFile(""hsimple.root""); /// ntuple->Draw(""hsimple.cxx"");; /// ~~~; /// A more complete example is available in the tutorials directory:; /// h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; /// which reimplement the selector found in h1analysis.C",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:3968,load,loaded,3968,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,2,['load'],['loaded']
Performance,"tTransform() to get a pointer to the current; /// transform object.; ///; /// \param[out] h_output histogram for the output. If a null pointer is passed, a new histogram is created; /// and returned, otherwise, the provided histogram is used and should be big enough; /// \param[in] option option parameters consists of 3 parts:; /// - option on what to return; /// - ""RE"" - returns a histogram of the real part of the output; /// - ""IM"" - returns a histogram of the imaginary part of the output; /// - ""MAG""- returns a histogram of the magnitude of the output; /// - ""PH"" - returns a histogram of the phase of the output; /// - option of transform type; /// - ""R2C"" - real to complex transforms - default; /// - ""R2HC"" - real to halfcomplex (special format of storing output data,; /// results the same as for R2C); /// - ""DHT"" - discrete Hartley transform; /// real to real transforms (sine and cosine):; /// - ""R2R_0"", ""R2R_1"", ""R2R_2"", ""R2R_3"" - discrete cosine transforms of types I-IV; /// - ""R2R_4"", ""R2R_5"", ""R2R_6"", ""R2R_7"" - discrete sine transforms of types I-IV; /// To specify the type of each dimension of a 2-dimensional real to real; /// transform, use options of form ""R2R_XX"", for example, ""R2R_02"" for a transform,; /// which is of type ""R2R_0"" in 1st dimension and ""R2R_2"" in the 2nd.; /// - option of transform flag; /// - ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; /// performance; /// - ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; /// - ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; /// - ""EX"" (from ""exhaustive"") - the most optimal way is found; /// This option should be chosen depending on how many transforms of the same size and; /// type are going to be done. Planning is only done once, for the first transform of this; /// size and type. Default is ""ES"".; ///; /// Examples of valid options: ""Mag R2C M"" ""Re R2R_11"" ""Im R2C ES"" ""PH R2HC EX""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1757,perform,performance,1757,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['perform'],['performance']
Performance,"tain statistics on how many entries have been accepted and rejected by the filters. See the section on [named filters](#named-filters-and-cutflow-reports) for a more detailed explanation. The method returns a ROOT::RDF::RCutFlowReport instance which can be queried programmatically to get information about the effects of the individual cuts. |; | Stats() | Return a TStatistic object filled with the input columns. |; | StdDev() | Return the unbiased standard deviation of the processed column values. |; | Sum() | Return the sum of the values in the column. If the type of the column is inferred, the return type is `double`, the type of the column otherwise. |; | Take() | Extract a column from the dataset as a collection of values, e.g. a `std::vector<float>` for a column of type `float`. |. | **Instant action** | **Description** |; |---------------------|-----------------|; | Foreach() | Execute a user-defined function on each entry. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled. |; | ForeachSlot() | Same as Foreach(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Foreach() actions when using RDataFrame after ROOT::EnableImplicitMT(). ForeachSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; | Snapshot() | Write the processed dataset to disk, in a new TTree and TFile. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. Snapshot() can be made *lazy* setting the appropriate flag in the snapshot options.|. ### Queries. These operations do not modify the dataframe or book computations but simply return information on the RDataFrame obje",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:9359,multi-thread,multi-threading,9359,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['multi-thread'],['multi-threading']
Performance,"te the value and/or type of an existing column. See DefineSlotEntry() for more information. |; | Vary() | Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). |. ### Actions; Actions aggregate data into a result. Each one is described in more detail in the reference guide. In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters. Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to; produce many different results in one event loop. Instant actions trigger the event loop instantly. | **Lazy action** | **Description** |; |------------------|-----------------|; | Aggregate() | Execute a user-defined accumulation operation on the processed column values. |; | Book() | Book execution of a custom action using a user-defined helper object. |; | Cache() | Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). |; | Count() | Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. |; | Display() | Provides a printable representation of the dataset contents. The method returns a ROOT::RDF::RDisplay() instance which can print a tabular representation of the data or return it as a string. |; | Fill() | Fill a user-defined object with the values of the specified columns, as if by calling `Obj.Fill(col1, col2, ...)`. |; | Graph() | Fills a TGraph with the two columns provided. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; | GraphAsymmErrors() | Fills a TGraphAsymmErrors. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before d",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:6253,Cache,Cache,6253,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,2,['Cache'],['Cache']
Performance,"te, and/or sell copies of; * the Data Files or Software, and to permit persons to whom the Data Files; * or Software are furnished to do so, provided that; * (a) this copyright and permission notice appear with all copies; * of the Data Files or Software,; * (b) this copyright and permission notice appear in associated; * documentation, and; * (c) there is clear notice in each modified Data File or in the Software; * as well as in the documentation associated with the Data File(s) or; * Software that the data or software has been modified.; *; * THE DATA FILES AND SOFTWARE ARE PROVIDED ""AS IS"", WITHOUT WARRANTY OF; * ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE; * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT OF THIRD PARTY RIGHTS.; * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS; * NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL; * DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,; * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER; * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR; * PERFORMANCE OF THE DATA FILES OR SOFTWARE.; *; * Except as contained in this notice, the name of a copyright holder; * shall not be used in advertising or otherwise to promote the sale,; * use or other dealings in these Data Files or Software without prior; * written authorization of the copyright holder.; */; /* ---------------------------------------------------------------------. Conversions between UTF32, UTF-16, and UTF-8. Header file. Several funtions are included here, forming a complete set of; conversions between the three formats. UTF-7 is not included; here, but is handled in a separate source file. Each of these routines takes pointers to input buffers and output; buffers. The input buffers are const. Each routine converts the text between *sourceStart and sourceEnd,; putting the result into the buffer between *targetS",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ConvertUTF.h:2065,PERFORM,PERFORMANCE,2065,interpreter/llvm-project/llvm/include/llvm/Support/ConvertUTF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ConvertUTF.h,1,['PERFORM'],['PERFORMANCE']
Performance,"te, and/or sell copies of; * the Data Files or Software, and to permit persons to whom the Data Files; * or Software are furnished to do so, provided that; * (a) this copyright and permission notice appear with all copies; * of the Data Files or Software,; * (b) this copyright and permission notice appear in associated; * documentation, and; * (c) there is clear notice in each modified Data File or in the Software; * as well as in the documentation associated with the Data File(s) or; * Software that the data or software has been modified.; *; * THE DATA FILES AND SOFTWARE ARE PROVIDED ""AS IS"", WITHOUT WARRANTY OF; * ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE; * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND; * NONINFRINGEMENT OF THIRD PARTY RIGHTS.; * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS; * NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL; * DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,; * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER; * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR; * PERFORMANCE OF THE DATA FILES OR SOFTWARE.; *; * Except as contained in this notice, the name of a copyright holder; * shall not be used in advertising or otherwise to promote the sale,; * use or other dealings in these Data Files or Software without prior; * written authorization of the copyright holder.; */; /* ---------------------------------------------------------------------. Conversions between UTF32, UTF-16, and UTF-8. Source code file.; Author: Mark E. Davis, 1994.; Rev History: Rick McGowan, fixes & updates May 2001.; Sept 2001: fixed const & error conditions per; mods suggested by S. Parent & A. Lillich.; June 2002: Tim Dodd added detection and handling of incomplete; source sequences, enhanced error detection, added casts; to eliminate compiler warnings.; July 2003: slight mods to back out aggressive FFFE detection.; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ConvertUTF.cpp:2065,PERFORM,PERFORMANCE,2065,interpreter/llvm-project/llvm/lib/Support/ConvertUTF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ConvertUTF.cpp,1,['PERFORM'],['PERFORMANCE']
Performance,"te-spaces; //; // Kernel parameters are read-only and accessible only via ld.param; // instruction, directly or via a pointer. Pointers to kernel; // arguments can't be converted to generic address space.; //; // Device function parameters are directly accessible via; // ld.param/st.param, but taking the address of one returns a pointer; // to a copy created in local space which *can't* be used with; // ld.param/st.param.; //; // Copying a byval struct into local memory in IR allows us to enforce; // the param space restrictions, gives the rest of IR a pointer w/o; // param space restrictions, and gives us an opportunity to eliminate; // the copy.; //; // Pointer arguments to kernel functions need more work to be lowered:; //; // 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the; // global address space. This allows later optimizations to emit; // ld.global.*/st.global.* for accessing these pointer arguments. For; // example,; //; // define void @foo(float* %input) {; // %v = load float, float* %input, align 4; // ...; // }; //; // becomes; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %input3 = addrspacecast float addrspace(1)* %input2 to float*; // %v = load float, float* %input3, align 4; // ...; // }; //; // Later, NVPTXInferAddressSpaces will optimize it to; //; // define void @foo(float* %input) {; // %input2 = addrspacecast float* %input to float addrspace(1)*; // %v = load float, float addrspace(1)* %input2, align 4; // ...; // }; //; // 2. Convert pointers in a byval kernel parameter to pointers in the global; // address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,; //; // struct S {; // int *x;; // int *y;; // };; // __global__ void foo(S s) {; // int *b = s.y;; // // use b; // }; //; // ""b"" points to the global address space. In the IR level,; //; // define void @foo({i32*, i32*}* byval %input) {; // %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp:1573,load,load,1573,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp,1,['load'],['load']
Performance,"te; /// reduce elements.; /// Remote Reduce list:; /// Remote Reduce list refers to a collection of remote (relative to; /// the current thread) reduce elements.; ///; /// We distinguish between three states of threads that are important to; /// the implementation of this function.; /// Alive threads:; /// Threads in a warp executing the SIMT instruction, as distinguished from; /// threads that are inactive due to divergent control flow.; /// Active threads:; /// The minimal set of threads that has to be alive upon entry to this; /// function. The computation is correct iff active threads are alive.; /// Some threads are alive but they are not active because they do not; /// contribute to the computation in any useful manner. Turning them off; /// may introduce control flow overheads without any tangible benefits.; /// Effective threads:; /// In order to comply with the argument requirements of the shuffle; /// function, we must keep all lanes holding data alive. But at most; /// half of them perform value aggregation; we refer to this half of; /// threads as effective. The other half is simply handing off their; /// data.; ///; /// Procedure; /// Value shuffle:; /// In this step active threads transfer data from higher lane positions; /// in the warp to lower lane positions, creating Remote Reduce list.; /// Value aggregation:; /// In this step, effective threads combine their thread local Reduce list; /// with Remote Reduce list and store the result in the thread local; /// Reduce list.; /// Value copy:; /// In this step, we deal with the assumption made by algorithm 2; /// (i.e. contiguity assumption). When we have an odd number of lanes; /// active, say 2k+1, only k threads will be effective and therefore k; /// new values will be produced. However, the Reduce list owned by the; /// (2k+1)th thread is ignored in the value aggregation. Therefore; /// we copy the Reduce list from the (2k+1)th lane to (k+1)th lane so; /// that the contiguity assumption still holds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:2427,perform,perform,2427,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['perform'],['perform']
Performance,"tecture behaviours that can't be modelled; // for GenericScheduler:; // . When accessing the result of an SGPR load instruction, you have to wait; // for all the SGPR load instructions before your current instruction to; // have finished.; // . When accessing the result of an VGPR load instruction, you have to wait; // for all the VGPR load instructions previous to the VGPR load instruction; // you are interested in to finish.; // . The less the register pressure, the best load latencies are hidden; //; // Moreover some specifities (like the fact a lot of instructions in the shader; // have few dependencies) makes the generic scheduler have some unpredictable; // behaviours. For example when register pressure becomes high, it can either; // manage to prevent register pressure from going too high, or it can; // increase register pressure even more than if it hadn't taken register; // pressure into account.; //; // Also some other bad behaviours are generated, like loading at the beginning; // of the shader a constant in VGPR you won't need until the end of the shader.; //; // The scheduling problem for SI can distinguish three main parts:; // . Hiding high latencies (texture sampling, etc); // . Hiding low latencies (SGPR constant loading, etc); // . Keeping register usage low for better latency hiding and general; // performance; //; // Some other things can also affect performance, but are hard to predict; // (cache usage, the fact the HW can issue several instructions from different; // wavefronts if different types, etc); //; // This scheduler tries to solve the scheduling problem by dividing it into; // simpler sub-problems. It divides the instructions into blocks, schedules; // locally inside the blocks where it takes care of low latencies, and then; // chooses the order of the blocks by taking care of high latencies.; // Dividing the instructions into blocks helps control keeping register; // usage low.; //; // First the instructions are put into blocks.; // We",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:1107,load,loading,1107,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['load'],['loading']
Performance,"ted events, a counter incremented only up to a; /// certain point, a mean over a subset of the events and so forth).; ///; /// Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running. For; /// example one can draw an up-to-date version of a result histogram every 100 entries like this:; /// \code{.cpp}; /// auto h = tdf.Histo1D(""x"");; /// TCanvas c(""c"",""x hist"");; /// h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; /// h->Draw(); // event loop runs here, this `Draw` is executed after the event loop is finished; /// \endcode; ///; /// A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop.; /// A conveniece definition `kOnce` is provided to make this fact more expressive in user code (see snippet below).; /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; /// be executed sequentially. Callbacks are executed in the order they were registered.; /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; /// \code{.cpp}; /// auto h = tdf.Histo1D(""x"");; /// // h.kOnce is 0; /// // decltype(h)::Value_t is TH1D; /// \endcode; ///; /// When implicit multi-threading is enabled, the callback:; /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; /// one call to the next; /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; /// might change between calls; ///; /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; /// OnPartialResultSlot().; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:2050,multi-thread,multi-threading,2050,tree/dataframe/inc/ROOT/RResultPtr.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx,4,"['concurren', 'multi-thread']","['concurrently', 'multi-thread', 'multi-threading']"
Performance,"ted via a discrete minimum-curvature condition.; <p>; Monte Carlo inputs:; <ul>; <li><tt>xini</tt>: true underlying spectrum (TH1D, n bins); <li><tt>bini</tt>: reconstructed spectrum (TH1D, n bins); <li><tt>Adet</tt>: response matrix (TH2D, nxn bins); </ul>; Consider the unfolding of a measured spectrum <tt>bdat</tt> with covariance matrix <tt>Bcov</tt> (if not passed explicitly, a diagonal covariance will be built given the errors of <tt>bdat</tt>). The corresponding spectrum in the Monte Carlo is given by <tt>bini</tt>, with the true underlying spectrum given by <tt>xini</tt>. The detector response is described by <tt>Adet</tt>, with <tt>Adet</tt> filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis.; <p>; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of <tt>xini</tt> and <tt>Adet</tt>.<br><br>; <p>; The unfolding can be performed by; \code{.cpp}; TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; \endcode; where <tt>kreg</tt> determines the regularisation of the unfolding. In general, overregularisation (too small <tt>kreg</tt>) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large <tt>kreg</tt>) will lead to large fluctuations in the unfolded spectrum. The optimal regularisation can be determined following guidelines in <a href=""http://arXiv.org/abs/hep-ph/9509307"">Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307]</a> using the distribution of the <tt>|d_i|</tt> that can be obtained by <tt>tsvdunf->GetD()</tt> and/or using pseudo-experiments.; <p>; Covariance matrices on the measured spectrum (for either the total uncertainties or individual sources of uncertainties) can be propagated to covariance matrices using the <tt>GetUnfoldCovMatrix</tt> method, which uses pseudo experiment",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:2545,perform,performed,2545,hist/hist/src/TSVDUnfold.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx,1,['perform'],['performed']
Performance,"ted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. - \f$ minpts \f$: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to \f$ 2^n +2n(n+1) +1 \f$ where n is the function dimension; - \f$ maxpts \f$: Maximum number of function evaluations to be allowed.; \f$ maxpts >= 2^n +2n(n+1) +1 \f$; if \f$ maxpts<minpts \f$, \f$ maxpts \f$ is set to \f$ 10minpts \f$; - \f$ epstol \f$, \f$ epsrel \f$ : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function in the desired interval:. - an estimation of the relative accuracy of the result.; - number of function evaluations performed.; - status code:; 0. Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1. maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 2. size is too small for the specified number MAXPTS of function evaluations.; 3. n<2 or n>15. ### Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. ### Notes:. 1..Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2..Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. ### References:. 1. A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimens",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h:1354,perform,performed,1354,math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h,1,['perform'],['performed']
Performance,"ters are applied on glyph pixmaps, if its size exceeds threshold.; * TODO; * implement proper XFontSet support, when used with I18N enabled.; *********/; /****f* libAfterImage/asfont/get_asfont(); * NAME; * get_asfont(); * SYNOPSIS; * ASFont *get_asfont( ASFontManager *fontman,; * const char *font_string,; * int face_no, int size,; * ASFontType type );; * INPUTS; * fontman - pointer to previously created ASFontManager. Needed for; * connection to FreeType library, path to search fonts; * in, and X Server connection.; * font_string - font name or filename of the file containing font's data.; * face_no - number of face within the font file; * size - font size in points. Applicable only to scalable fonts,; * such as TrueType.; * type - specifies the type of the font, or GuessWho for; * autodetection.; * RETURN VALUE; * pointer to Opened ASFont structure, containing all the glyphs of the; * font, as well as other relevant info. On failure returns NULL.; * DESCRIPTION; * This function provides unified interface to font loading. It performs; * search in ASFontManager's list to see if this specific font has been; * loaded already, and if so - returns pointer to relevant structure.; * Otherwise it tryes to load font as FreeType font first, and then; * Xlib font, unless exact font type is specifyed.; *********/; /****f* libAfterImage/asfont/release_font(); * NAME; * release_font(); * SYNOPSIS; * void release_font( ASFont *font );; * INPUTS; * font - pointer to the valid ASFont structure containing loaded font.; * RETURN VALUE; * returns current reference count. -1 means that object has been; * destroyed.; * DESCRIPTION; * This function will decrement reference count on loaded font and if; * reference count will be less then 0 ( meaning that release_font() has; * been called more times then get_asfont() ) it will close the font,; * remove it from ASFontManager's list, destroy all the glyphs and; * generally free everything else used by ASFont.; * Otherwise font will remain in",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h:3311,load,loading,3311,graf2d/asimage/src/libAfterImage/asfont.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h,1,['load'],['loading']
Performance,"the first Tree, the list of branches; in the cache is kept for the following files. - Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning phase is started or restarted when:; - TTree automatically creates a cache.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTreeCache::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; - TTreeCache::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries.; - A 'cached' TChain switches over to a new file. \anchor cachemisses; ## Self-optimization in presence of cache misses. The TTreeCache can optimize its behavior on a cache miss. When; miss optimization is enabled (see the SetOptimizeMisses method),; it tracks all branches utilized after the learning phase which caused a cache; miss.; When one cache miss occurs, all the utilized branches are be prefetched; for that event. This optimization utilizes the observation that infrequently; accessed branches are often accessed together.; An example scenario where such behavior is desirable, is an analysis where; a set of collections are read only for a few events in which a certain; condition is respected, e.g. a trigger fired. ### Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase; by at most a factor two in the case of cache miss.; Additionally, on the first miss of an event, we must iterate through all the; ""active branches"" for the miss cache and find the correct basket.; This can be potentially a CPU-expensive operation compared to, e.g., the; lat",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:4803,optimiz,optimize,4803,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,"['cache', 'optimiz']","['cache', 'optimize']"
Performance,"the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. ## Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandatory steps; that have to be followed in order to be validated by the modeler. There are; general rules : volumes needs media and shapes in order to be created,; both container and containee volumes must be created before linking them together,; and the relative transformation matrix must be provided. All branches must; have an upper link point otherwise they will not be considered as part of the; geometry. Visibility or tracking properties of volumes can be provided both; at build time or after geometry is closed, but global visualization settings; (see TGeoPainter class) should not be provided at build time, otherwise the; drawing package will be loaded. There is also a list of specific rules :; positioned daughters should not extrude their mother or intersect with sisters; unless this is specified (see TGeoVolume::AddNodeOverl",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:6172,load,loaded,6172,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,1,['load'],['loaded']
Performance,"the momentum; // Float_t fPy; //Y component of the momentum; // Float_t fPz; //Z component of the momentum; // Float_t fRandom; //A random track quantity; // Float_t fMass2; //The mass square of this particle; // Float_t fBx; //X intercept at the vertex; // Float_t fBy; //Y intercept at the vertex; // Float_t fMeanCharge; //Mean charge deposition of all hits of this track; // Float_t fXfirst; //X coordinate of the first point; // Float_t fXlast; //X coordinate of the last point; // Float_t fYfirst; //Y coordinate of the first point; // Float_t fYlast; //Y coordinate of the last point; // Float_t fZfirst; //Z coordinate of the first point; // Float_t fZlast; //Z coordinate of the last point; // Double32_t fCharge; //Charge of this track; // Double32_t fVertex[3]; //Track vertex position; // Int_t fNpoint; //Number of points for this track; // Short_t fValid; //Validity criterion; // Int_t fNsp; //Number of points for this track with a special value; // Double32_t *fPointValue; //[fNsp] a special quantity for some point.; // TBits fTriggerBits; //Bits triggered by this track.; //; // An example of a batch program to use the Event/Track classes is given; // in this directory: MainEvent.; // Look also in the same directory at the following macros:; // - eventa.C an example how to read the tree; // - eventb.C how to read events conditionally; //; // During the processing of the event (optionally) also a large number; // of histograms can be filled. The creation and handling of the; // histograms is taken care of by the HistogramManager class.; //; // Note: This version of the class Event (see EventMT.h and EventMT.cxx; // for an alternative) uses static variables to improve performance (by; // reducing the number of memory allocations). Consequently, only one; // instance of the class Event should be in use at a time (a 2nd instance; // would share the array of Tracks with the first instance).; //; ////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/Event.cxx:3006,perform,performance,3006,test/Event.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/Event.cxx,1,['perform'],['performance']
Performance,"thing also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; // element size. Do the same for stores.; // - For each equivalence class, greedily build ""chains"". Each chain has a; // leader instruction, an",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1648,load,loads,1648,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,2,"['load', 'perform']","['loads', 'performance']"
Performance,"this version of the library. The default value is 15 if inflateInit is used; instead. windowBits must be greater than or equal to the windowBits value; provided to deflateInit2() while compressing, or it must be equal to 15 if; deflateInit2() was not used. If a compressed stream with a larger window; size is given as input, inflate() will return with the error code; Z_DATA_ERROR instead of trying to allocate a larger window. windowBits can also be -8..-15 for raw inflate. In this case, -windowBits; determines the window size. inflate() will then process raw deflate data,; not looking for a zlib or gzip header, not generating a check value, and not; looking for any check values for comparison at the end of the stream. This; is for use with other formats that use the deflate compressed data format; such as zip. Those formats provide their own check values. If a custom; format is developed using the raw deflate format for compressed data, it is; recommended that a check value such as an adler32 or a crc32 be applied to; the uncompressed data as is done in the zlib, gzip, and zip formats. For; most applications, the zlib format should be used as is. Note that comments; above on the use in deflateInit2() applies to the magnitude of windowBits. windowBits can also be greater than 15 for optional gzip decoding. Add; 32 to windowBits to enable zlib and gzip decoding with automatic header; detection, or add 16 to decode only the gzip format (the zlib format will; return a Z_DATA_ERROR). If a gzip stream is being decoded, strm->adler is; a crc32 instead of an adler32. inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_STREAM_ERROR if a parameter is invalid (such as a null strm). msg; is set to null if there is no error message. inflateInit2 does not perform; any decompression apart from reading the zlib header if present: this will; be done by inflate(). (So next_in and avail_in may be modified, but next_out; and avail_out are unchanged.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:3380,perform,perform,3380,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['perform'],['perform']
Performance,"thors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooWorkspace.cxx; \class RooWorkspace; \ingroup Roofitcore. Persistable container for RooFit projects. A workspace; can contain and own variables, p.d.f.s, functions and datasets. All objects; that live in the workspace are owned by the workspace. The `import()` method; enforces consistency of objects upon insertion into the workspace (e.g. no; duplicate object with the same name are allowed) and makes sure all objects; in the workspace are connected to each other. Easy accessor methods like; `pdf()`, `var()` and `data()` allow to refer to the contents of the workspace by; object name. The entire RooWorkspace can be saved into a ROOT TFile and organises; the consistent streaming of its contents without duplication.; If a RooWorkspace contains custom classes, i.e. classes not in the; ROOT distribution, portability of workspaces can be enhanced by; storing the source code of those classes in the workspace as well.; This process is also organized by the workspace through the; `importClassCode()` method. ### Seemingly random crashes when reading large workspaces; When reading or loading workspaces with deeply nested PDFs, one can encounter; ouf-of-memory errors if the stack size is too small. This manifests in crashes; at seemingly random locations, or in the process silently ending.; Unfortunately, ROOT neither recover from this situation, nor warn or give useful; instructions. When suspecting to have run out of stack memory, check; ```; ulimit -s; ```; and try reading again.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx:1748,load,loading,1748,roofit/roofitcore/src/RooWorkspace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx,1,['load'],['loading']
Performance,"timisation of signal efficiency for given background; efficiency, applying rectangular minimum and maximum requirements. Also implemented is a ""decorrelate/diagonalized cuts approach"",; which improves over the uncorrelated cuts approach by; transforming linearly the input variables into a diagonal space,; using the square-root of the covariance matrix. Other optimisation criteria, such as maximising the signal significance-; squared, \f$ \frac{S^2}{(S+B)} \f$, with S and B being the signal and background yields,; correspond to a particular point in the optimised background rejection; versus signal efficiency curve. This working point requires the knowledge; of the expected yields, which is not the case in general. Note also that; for rare signals, Poissonian statistics should be used, which modifies; the significance criterion. The rectangular cut of a volume in the variable space is performed using; a binary tree to sort the training events. This provides a significant; reduction in computing time (up to several orders of magnitudes, depending; on the complexity of the problem at hand). Technically, optimisation is achieved in TMVA by two methods:. 1. Monte Carlo generation using uniform priors for the lower cut value,; and the cut width, thrown within the variable ranges. 2. A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; The GA is configurable by many external settings through the option; string. For difficult cases (such as many variables), some tuning; may be necessary to achieve satisfying results. Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; superior results, and often failed due to convergence at local minima. The tests we have performed so far showed that in generic applications,; the GA is superior to MC sampling, and hence GA is the default method.; It is worthwhile trying both anyway. **Decorrelated (or ""diagonalized"") Cuts**. See class description for Method Likelihood for a detailed explanation.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCuts.cxx:3001,perform,performed,3001,tmva/tmva/src/MethodCuts.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCuts.cxx,1,['perform'],['performed']
Performance,"tinue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; ... Here the entry is processed; }; ~~~; #### Always using at least the same two branches. In this example, two branches are always used: in addition, some analysis; functions are invoked and those may trigger the reading of other branches which; are a priori not known.; There is no point in prefetching branches that will be used very rarely: we can; rely on the system to cache the right branches.; ~~~ {.cpp}; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; for (auto i : TSeqL(nentries)) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; // At this point we may call a user function where a few more branches; // will be read conditionally. These branches will be put in the cache; // if they have been used in the first 10 entries; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching the other branches as it might be; // more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... Here the entry is processed; }; ~~~. \anchor checkPerf; ## How can the usage and performance of TTreeCache be verified?. Once the event loop terminated, the number of effective system reads for a; given file can be checked with a code like the following:; ~~~ {.cpp}; printf(""Reading %lld bytes in %d transactions\n"",myTFilePtr->GetBytesRead(), f->GetReadCalls());; ~~~. Another handy command is:; ~~~ {.cpp}; myTreeOrChain.GetTree()->PrintCacheStats();; ~~~. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:10563,cache,cache,10563,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,"['cache', 'perform']","['cache', 'performance']"
Performance,"tion are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned with __msan_poison_alloca() upon function; /// entry and unpoisoned with __msan_unpoison_alloca() before leaving the; /// function;; /// - the pass doesn't declare any global variables or add global constructors; /// to the translation unit.; ///; /// Also, KMSAN currently ignores uninitialized memory passed into inline asm; /// calls, making sure we're on the safe side wrt. possible false positives.; ///; /// KernelMemorySanitizer only supports X86_64 and SystemZ at the moment.; ///; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:8020,scalab,scalable,8020,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['scalab'],['scalable']
Performance,"tion' contains the word 'fast' and nentries is -1, the; /// cloning will be done without unzipping or unstreaming the baskets; /// (i.e., a direct copy of the raw bytes on disk).; ///; /// When 'fast' is specified, 'option' can also contain a sorting; /// order for the baskets in the output file.; ///; /// There are currently 3 supported sorting order:; ///; /// - SortBasketsByOffset (the default); /// - SortBasketsByBranch; /// - SortBasketsByEntry; ///; /// When using SortBasketsByOffset the baskets are written in the; /// output file in the same order as in the original file (i.e. the; /// baskets are sorted by their offset in the original file; Usually; /// this also means that the baskets are sorted by the index/number of; /// the _last_ entry they contain); ///; /// When using SortBasketsByBranch all the baskets of each individual; /// branches are stored contiguously. This tends to optimize reading; /// speed when reading a small number (1->5) of branches, since all; /// their baskets will be clustered together instead of being spread; /// across the file. However it might decrease the performance when; /// reading more branches (or the full entry).; ///; /// When using SortBasketsByEntry the baskets with the lowest starting; /// entry are written first. (i.e. the baskets are sorted by the; /// index/number of the first entry they contain). This means that on; /// the file the baskets will be in the order in which they will be; /// needed when reading the whole tree sequentially.; ///; /// For examples of CloneTree, see tutorials:; ///; /// - copytree.C:; /// A macro to copy a subset of a TTree to a new TTree.; /// The input file has been generated by the program in; /// $ROOTSYS/test/Event with: Event 1000 1 1 1; ///; /// - copytree2.C:; /// A macro to copy a subset of a TTree to a new TTree.; /// One branch of the new Tree is written to a separate file.; /// The input file has been generated by the program in; /// $ROOTSYS/test/Event with: Event 1000 1 1 1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:2143,perform,performance,2143,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['perform'],['performance']
Performance,"tions, some default initial values and limits are set.; /// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; /// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; /// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; /// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; ///; ///; /// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; /// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; ///; /// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; /// un-weighted least-square (chi-square) method.; ///; ///; ///\anchor GFitErrors; /// ### TGraphErrors fit:; ///; /// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; /// is projected along the y-direction by calculating the function at the points `x-ex_low` and; /// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; /// The chi-square is then computed as the sum of the quantity below at each data point:; ///; /// \f[; /// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; /// \f]; ///; /// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; /// function `f(x)`.; ///; /// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; ///; /// The approach used to approximate the uncertainty in y because of the; /// errors in x is to make it equal the error in x times the slope of the lin",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:3225,perform,performed,3225,hist/hist/src/TGraph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx,1,['perform'],['performed']
Performance,"to extract the transverse momenta of the muons satisfying certain; criteria, for example consider only negatively charged muons with a pseudorapidity; smaller or equal to 2 and with a transverse momentum greater than 10 GeV.; Such a selection would require, among the other things, the management of an explicit; loop, for example:; ~~~{.cpp}; std::vector<float> goodMuons_pt;; const auto size = mu_charge.size();; for (size_t i=0; i < size; ++i) {; if (mu_pt[i] > 10 && abs(mu_eta[i]) <= 2. && mu_charge[i] == -1) {; goodMuons_pt.emplace_back(mu_pt[i]);; }; }; ~~~; These operations become straightforward with RVec - we just need to *write what; we mean*:; ~~~{.cpp}; auto goodMuons_pt = mu_pt[ (mu_pt > 10.f && abs(mu_eta) <= 2.f && mu_charge == -1) ]; ~~~; Now the clean collection of transverse momenta can be used within the rest of the data analysis, for; example to fill a histogram. \anchor operationsandfunctions; ## Arithmetic operations, logical operations and mathematical functions; Arithmetic operations on RVec instances can be performed: for example, they can be added, subtracted, multiplied.; ~~~{.cpp}; RVec<double> v1 {1.,2.,3.,4.};; RVec<float> v2 {5.f,6.f,7.f,8.f};; auto v3 = v1+v2;; auto v4 = 3 * v1;; ~~~; The supported operators are ; - +, -, *, /; - +=, -=, *=, /=; - <, >, ==, !=, <=, >=, &&, ||; - ~, !; - &, |, ^; - &=, |=, ^=; - <<=, >>=. The most common mathematical functions are supported. It is possible to invoke them passing ; RVecs as arguments.; - abs, fdim, fmod, remainder; - floor, ceil, trunc, round, lround, llround; - exp, exp2, expm1; - log, log10, log2, log1p; - pow; - sqrt, cbrt; - sin, cos, tan, asin, acos, atan, atan2, hypot; - sinh, cosh, tanh, asinh, acosh; - erf, erfc; - lgamma, tgamma. If the VDT library is available, the following functions can be invoked. Internally the calculations; are vectorized:; - fast_expf, fast_logf, fast_sinf, fast_cosf, fast_tanf, fast_asinf, fast_acosf, fast_atanf; - fast_exp, fast_log, fast_sin, fast_cos, fas",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:3477,perform,performed,3477,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['perform'],['performed']
Performance,"to return them from functions. However, in general each dataframe node will have a different C++ type,; which includes all available compile-time information about what that node does. One way to cope with this complication; is to use template functions and/or C++14 auto return types:; ~~~{.cpp}; template <typename RDF>; auto ApplySomeFilters(RDF df); {; return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; }; ~~~. A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be; converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode:; ~~~{.cpp}; // a function that conditionally adds a Range to an RDataFrame node.; RNode MaybeAddRange(RNode df, bool mustAddRange); {; return mustAddRange ? df.Range(1) : df;; }; // use as :; ROOT::RDataFrame df(10);; auto maybeRangedDF = MaybeAddRange(df, true);; ~~~. The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event; loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function `ROOT.RDF.AsRNode`. \anchor RDFCollections; ### Storing RDataFrame objects in collections. ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a `std::vector<RNode>` or a `std::map<std::string, RNode>`:. ~~~{.cpp}; std::vector<ROOT::RDF::RNode> dfs;; dfs.emplace_back(ROOT::RDataFrame(10));; dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));; ~~~. \anchor callbacks; ### Executing callbacks every N events; It's possible to schedule execution of arbitrary functions (callbacks) during the event loop.; Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running,; drawing a partially-filled histogram every time a certain number of new entries is processed, or; displaying a progress bar while the event loop runs. For example one can draw an up-to-date version of a",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:61410,perform,performance,61410,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['perform'],['performance']
Performance,"to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; ~~~{.cpp}; ROOT::EnableImplicitMT(i); ~~~; replacing `i` with the number of CPUs/slots that were allocated for this job. ### Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads. Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; which eliminates all risks of race conditions. In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; where `slot` will be a number between 0 and `GetNSlots() - 1`.; In other words, within a slot, computation runs sequentially and events are processed sequentially.; Note that the same slot might be associated to different threads over the course of a singl",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:49068,race condition,race conditions,49068,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['race condition'],['race conditions']
Performance,"too many steps on the average 32-bit machine.; *; * For example, these two lines seem similar, and run equally fast on 64-bit:; *; * xxh_u64 x;; * x ^= (x >> 47); // good; * x ^= (x >> 13); // bad; *; * However, to a 32-bit machine, there is a major difference.; *; * x ^= (x >> 47) looks like this:; *; * x.lo ^= (x.hi >> (47 - 32));; *; * while x ^= (x >> 13) looks like this:; *; * // note: funnel shifts are not usually cheap.; * x.lo ^= (x.lo >> 13) | (x.hi << (32 - 13));; * x.hi ^= (x.hi >> 13);; *; * The first one is significantly faster than the second, simply because the; * shift is larger than 32. This means:; * - All the bits we need are in the upper 32 bits, so we can ignore the lower; * 32 bits in the shift.; * - The shift result will always fit in the lower 32 bits, and therefore,; * we can ignore the upper 32 bits in the xor.; *; * Thanks to this optimization, XXH3 only requires these features to be efficient:; *; * - Usable unaligned access; * - A 32-bit or 64-bit ALU; * - If 32-bit, a decent ADC instruction; * - A 32 or 64-bit multiply with a 64-bit result; * - For the 128-bit variant, a decent byteswap helps short inputs.; *; * The first two are already required by XXH32, and almost all 32-bit and 64-bit; * platforms which can run XXH32 can run XXH3 efficiently.; *; * Thumb-1, the classic 16-bit only subset of ARM's instruction set, is one; * notable exception.; *; * First of all, Thumb-1 lacks support for the UMULL instruction which; * performs the important long multiply. This means numerous __aeabi_lmul; * calls.; *; * Second of all, the 8 functional registers are just not enough.; * Setup for __aeabi_lmul, byteshift loads, pointers, and all arithmetic need; * Lo registers, and this shuffling results in thousands more MOVs than A32.; *; * A32 and T32 don't have this limitation. They can access all 14 registers,; * do a 32->64 multiply with UMULL, and the flexible operand allowing free; * shifts is helpful, too.; *; * Therefore, we do a quick sanity c",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:1092,optimiz,optimization,1092,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['optimiz'],['optimization']
Performance,"tr [rsi]; // For the above snippet, haswell just renames rax four times and executes the; // four instructions two at a time on P23 and P0126.; //; // For some instructions, we just need to make sure that the source is; // different from the destination. For example, IDIV8r reads from GPR and; // writes to AX. We just need to ensure that the Var is assigned a; // register which is different from AX:; // idiv bx; // idiv bx; // idiv bx; // idiv bx; // The above snippet will be able to fully saturate the ports, while the same; // with ax would issue one uop every `latency(IDIV8r)` cycles.; //; // Some instructions make this harder because they both read and write from; // the same register:; // inc rax; // inc rax; // inc rax; // inc rax; // This has a data dependency from each instruction to the next, limit the; // number of instructions that can be issued in parallel.; // It turns out that this is not a big issue on recent Intel CPUs because they; // have heuristics to balance port pressure. In the snippet above, subsequent; // instructions will end up evenly distributed on {P0,P1,P5,P6}, but some CPUs; // might end up executing them all on P0 (just because they can), or try; // avoiding P5 because it's usually under high pressure from vector; // instructions.; // This issue is even more important for high-latency instructions because; // they increase the idle time of the CPU, e.g. :; // imul rax, rbx; // imul rax, rbx; // imul rax, rbx; // imul rax, rbx; //; // To avoid that, we do the renaming statically by generating as many; // independent exclusive assignments as possible (until all possible registers; // are exhausted) e.g.:; // imul rax, rbx; // imul rcx, rbx; // imul rdx, rbx; // imul r8, rbx; //; // Some instruction even make the above static renaming impossible because; // they implicitly read and write from the same operand, e.g. ADC16rr reads; // and writes from EFLAGS.; // In that case we just use a greedy register assignment and hope for the; // best.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp:1922,latency,latency,1922,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp,1,['latency'],['latency']
Performance,"tr() const`: return a shared_ptr to the result of this action (of type; /// Result_t). The RResultPtr returned by Book will point to this object. Note that this method can be called; /// _before_ Initialize(), because the RResultPtr is constructed before the event loop is started.; /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; /// or copies of it, might be used for multiple event loops (e.g. in the presence of systematic variations).; /// * `void InitTask(TTreeReader *, unsigned int slot)`: each working thread shall call this method during the event; /// loop, before processing a batch of entries. The pointer passed as argument, if not null, will point to the TTreeReader; /// that RDataFrame has set up to read the task's batch of entries. It is passed to the helper to allow certain advanced optimizations; /// it should not usually serve any purpose for the Helper. This method is often no-op for simple helpers.; /// * `void Exec(unsigned int slot, ColumnTypes...columnValues)`: each working thread shall call this method; /// during the event-loop, possibly concurrently. No two threads will ever call Exec with the same 'slot' value:; /// this parameter is there to facilitate writing thread-safe helpers. The other arguments will be the values of; /// the requested columns for the particular entry being processed.; /// * `void Finalize()`: this method is called at the end of the event loop. Commonly used to finalize the contents of the result.; /// * `std::string GetActionName()`: it returns a string identifier for this type of action that RDataFrame will use in; /// diagnostics, SaveGraph(), etc.; ///; /// ### Optional methods; ///; /// If these methods are implemented they enable extra functionality as per the description below.; ///; /// * `Result_t &PartialUpdate(unsigned int slot)`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:2440,optimiz,optimizations,2440,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['optimiz'],['optimizations']
Performance,"try() is called; for 2 or more indices in a row. ## TTree::Draw() and TChain::Draw(). Use option __entrylist__ to write the results of TTree::Draw and TChain::Draw into; an entry list. Example:; ~~~ {.cpp}; tree->Draw("">>elist"", ""x<0 && y>0"", ""entrylist"");; TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; ~~~; ## Example of Loop on TEntryList with a TChain; ~~~ {.cpp}; void loopChain() {; TFile *fe = TFile::Open(""myelist.root"");; TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; TChain *chain = new TChain(""ntuple"");; chain->Add(""hsimple.root"");; chain->Add(""hsimple2.root"");; Long64_t listEntries = myelist->GetN();; Long64_t chainEntries = chain->GetEntries();; Int_t treenum = 0;; chain->SetEntryList(myelist);. for (entry=start;entry < end;entry++) {; entryNumber = chain->GetEntryNumber(entry);; if (entryNumber < 0) break;; localEntry = chain->LoadTree(entryNumber);; if (localEntry < 0) break;; ....; then either call; branch->GetEntry(localEntry);; or; chain->GetEntry(entryNumber);; In the later case the LoadTree is then somewhat redundant.; ...; }; }; ~~~; When using the TEntryList interface directly, you can get the 'tree number' and entry in; the current tree (i.e. value similar to the return value of LoadTree) from calling; TEntryList::GetEntryAndTree:; ~~~ {.cpp}; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; ~~~; to obtain the entry number within the chain you need to add to it the value of; `treeEntry+ch->GetTreeOffset()[treenum]`; such that the loop in the previous example can also be written as:; ~~~ {.cpp}; for (Long64_t el = 0; el < listEntries; el++) {; Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);. ch->LoadTree(chainEntry); // this also returns treeEntry; needed_branch->GetEntry(treeEntry);; }; ~~~; ## TSelectors. To fill an TEntryList from a TSele",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:2406,Load,LoadTree,2406,tree/tree/src/TEntryList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx,1,['Load'],['LoadTree']
Performance,"ts * 32 bits = 16 bytes) https://en.wikichip.org/w/images/d/d3/i486_MICROPROCESSOR_HARDWARE_REFERENCE_MANUAL_%281990%29.pdf and http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.126.4216&rep=rep1&type=pdf (page 29) |; // | i586/Pentium MMX | 32 | https://www.7-cpu.com/cpu/P-MMX.html |; // | i686/Pentium | 32 | https://www.7-cpu.com/cpu/P6.html |; // | Netburst/Pentium4 | 64 | https://www.7-cpu.com/cpu/P4-180.html |; // | Atom | 64 | https://www.7-cpu.com/cpu/Atom.html |; // | Westmere | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/sandy_bridge_(client) ""Cache Architecture"" |; // | Sandy Bridge | 64 | https://en.wikipedia.org/wiki/Sandy_Bridge and https://www.7-cpu.com/cpu/SandyBridge.html |; // | Ivy Bridge | 64 | https://blog.stuffedcow.net/2013/01/ivb-cache-replacement/ and https://www.7-cpu.com/cpu/IvyBridge.html |; // | Haswell | 64 | https://www.7-cpu.com/cpu/Haswell.html |; // | Broadwell | 64 | https://www.7-cpu.com/cpu/Broadwell.html |; // | Skylake (including skylake-avx512) | 64 | https://www.nas.nasa.gov/hecc/support/kb/skylake-processors_550.html ""Cache Hierarchy"" |; // | Cascade Lake | 64 | https://www.nas.nasa.gov/hecc/support/kb/cascade-lake-processors_579.html ""Cache Hierarchy"" |; // | Skylake | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/kaby_lake ""Memory Hierarchy"" |; // | Ice Lake | 64 | https://www.7-cpu.com/cpu/Ice_Lake.html |; // | Knights Landing | 64 | https://software.intel.com/en-us/articles/intel-xeon-phi-processor-7200-family-memory-management-optimizations ""The Intel® Xeon Phi™ Processor Architecture"" |; // | Knights Mill | 64 | https://software.intel.com/sites/default/files/managed/9e/bc/64-ia-32-architectures-optimization-manual.pdf?countrylabel=Colombia ""2.5.5.2 L1 DCache "" |; // +------------------------------------+-------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:1859,Cache,Cache,1859,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,4,"['Cache', 'optimiz']","['Cache', 'optimization-manual', 'optimizations']"
Performance,"tte. The following; macro gives an example. Begin_Macro(source); {; auto h2 = new TH2F(""h2"",""Example of a resized palette "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2->Fill(px,5*py);; }; gStyle->SetPalette(1);; h2->Draw(""COLZ"");; gPad->Update();; auto palette = (TPaletteAxis*)h2->GetListOfFunctions()->FindObject(""palette"");; palette->SetY2NDC(0.7);; }; End_Macro. `TPaletteAxis` inherits from `TBox` and `TPave`. The methods; allowing to specify the palette position are inherited from these two classes. The palette can be interactively moved and resized. The context menu; can be used to set the axis attributes. It is possible to select a range on the axis to set the min/max in z. As default labels and ticks are drawn by `TGAxis` at equidistant (lin or log); points as controlled by SetNdivisions.; If option ""CJUST"" is given labels and ticks are justified at the; color boundaries defined by the contour levels.; In this case no optimization can be done. It is responsibility of the; user to adjust minimum, maximum of the histogram and/or the contour levels; to get a reasonable look of the plot.; Only overlap of the labels is avoided if too many contour levels are used. This option is especially useful with user defined contours.; An example is shown here:. Begin_Macro(source); {; gStyle->SetOptStat(0);; auto c = new TCanvas(""c"",""exa_CJUST"",300,10,400,400);; auto hpxpy = new TH2F(""hpxpy"",""py vs px"",40,-4,4,40,-4,4);; // Fill histograms randomly; TRandom3 randomNum;; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; randomNum.Rannor(px,py);; hpxpy->Fill(px,py);; }; hpxpy->SetMaximum(200);; Double_t zcontours[5] = {0, 20, 40, 80, 120};; hpxpy->SetContour(5, zcontours);; hpxpy->GetZaxis()->SetTickSize(0.01);; hpxpy->GetZaxis()->SetLabelOffset(0.01);; gPad->SetRightMargin(0.13);; hpxpy->SetTitle(""User contours, CJUST"");; hpxpy->Draw(""COL Z CJUST"");; }; End_Macro; */; ////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPaletteAxis.cxx:1780,optimiz,optimization,1780,hist/histpainter/src/TPaletteAxis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPaletteAxis.cxx,1,['optimiz'],['optimization']
Performance,"ttleneck analysis report for a dot-product on X86 btver2:; ///; /// Cycles with backend pressure increase [ 40.76% ]; /// Throughput Bottlenecks: ; /// Resource Pressure [ 39.34% ]; /// - JFPA [ 39.34% ]; /// - JFPU0 [ 39.34% ]; /// Data Dependencies: [ 1.42% ]; /// - Register Dependencies [ 1.42% ]; /// - Memory Dependencies [ 0.00% ]; ///; /// According to the example, backend pressure increased during the 40.76% of; /// the simulated cycles. In particular, the major cause of backend pressure; /// increases was the contention on floating point adder JFPA accessible from; /// pipeline resource JFPU0.; ///; /// At the end of each cycle, if pressure on the simulated out-of-order buffers; /// has increased, a backend pressure event is reported.; /// In particular, this occurs when there is a delta between the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; /// +----> 2. vhaddps %xmm3, %xmm3, %xmm4 ## REGISTER dependency: %xmm3; /// |; /// | < loop carried > ; /// |; /// +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 73% ]; ///; ///; /// The algorithm that computes the critical sequence is very similar to a; /// critical path analysis.; /// ; /// A dependency graph is used internally to track dependencies between nodes.; /// Nodes of the graph represent instructions from the input assembly sequence,; /// and edges of the graph represent data dependencies or proce",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:1560,bottleneck,bottleneck,1560,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,1,['bottleneck'],['bottleneck']
Performance,"tzerland *; * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; * Jan Therhaag <Jan.Therhaag@cern.ch> - U of Bonn, Germany *; * Eckhard v. Toerne <evt@uni-bonn.de> - U of Bonn, Germany *; * *; * Copyright (c) 2005-2011: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; * *; **********************************************************************************/; /*! \class TMVA::MethodBase; \ingroup TMVA. Virtual base Class for all MVA method. MethodBase hosts several specific evaluation methods. The kind of MVA that provides optimal performance in an analysis strongly; depends on the particular application. The evaluation factory provides a; number of numerical benchmark results to directly assess the performance; of the MVA training on the independent test sample. These are:. - The _signal efficiency_ at three representative background efficiencies; (which is 1 &minus; rejection).; - The _significance_ of an MVA estimator, defined by the difference; between the MVA mean values for signal and background, divided by the; quadratic sum of their root mean squares.; - The _separation_ of an MVA _x_, defined by the integral; \f[; \frac{1}{2} \int \frac{(S(x) - B(x))^2}{(S(x) + B(x))} dx; \f]; where; \f$ S(x) \f$ and \f$ B(x) \f$ are the signal and background distributions,; respectively. The separation is zero for identical signal and background MVA; shapes, and it is one for disjunctive shapes.; - The average, \f$ \int x \mu (S(x)) dx \f$, of the signal \f$ \mu_{transform} \f$.; The \f$ \mu_{transform} \f$ of an MVA denotes the transformation that yields; a uniform background distribution. In this way, the signal distributions; \f$ S(x) \f$ can be directly compared among",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx:1660,perform,performance,1660,tmva/tmva/src/MethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx,1,['perform'],['performance']
Performance,"ubsequent paste operation will insert the contents of the; clipboard at the current cursor location. #### Text Search. The editor uses a standard Search dialog. You can specify a forward; or backward search direction starting from the current cursor; location according to the selection made of a case sensitive mode; or not. The last search can be repeated by pressing F3. #### Text Font. You can change the text font by selecting Edit menu / Set Font.; The Font Dialog pops up and shows the Name, Style, and Size of any; available font. The selected font sample is shown in the preview; area. #### Executing Macros. You can execute the currently loaded macro in the editor by; selecting Tools menu / Execute Macro; by clicking on the; corresponding toolbar button, or by using Ctrl+F5 accelerator keys.; This is identical to the command "".x macro.C"" in the root prompt; command line. #### Compiling Macros. The currently loaded macro can be compiled with ACLiC if you select; Tools menu / Compile Macro; by clicking on the corresponding; toolbar button, or by using Ctrl+F7 accelerator keys.; This is identical to the command "".L macro.C++"" in the root prompt; command line. #### Interrupting a Running Macro. You can interrupt a running macro by selecting the Tools menu /; Interrupt; by clicking on the corresponding toolbar button, or by; using Shift+F5 accelerator keys. #### Interface to CINT Interpreter. Any command entered in the Command combo box will be passed to; the CINT interpreter. This combo box will keep the commands history; and will allow you to re-execute the same commands during an editor; session. #### Keyboard Bindings. The following table lists the keyboard shortcuts and accelerator; keys. | Key: | Action |; |---------------|----------------|; | Up | Move cursor up. |; | Shift+Up | Move cursor up and extend selection. |; | Down | Move cursor down. |; | Shift+Down | Move cursor down and extend selection. |; | Left | Move cursor left. |; | Shift+Left | Move cursor lef",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEditor.cxx:3501,load,loaded,3501,gui/gui/src/TGTextEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEditor.cxx,1,['load'],['loaded']
Performance,"uch that the file is read sequentially. Systems like xrootd, dCache or httpd take advantage of the TTreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. ### Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all; entries such that not all branch buffers are read. \anchor description; ## General Description; This class acts as a file cache, registering automatically the baskets from; the branches being processed via direct manipulation of TTrees or with tools; such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame; when in the learning phase. The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. The usage of a TTreeCache can considerably improve the runtime performance at; the price of a modest investment in memory, in particular when the TTree is; accessed remotely, e.g. via a high latency network. For each TTree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted.; The user can change the size of the cache with the TTree::SetCacheSize method; (by default the size is 30 Megabytes). This feature can be controlled with the; environment variable `ROOT_TTREECACHE_SIZE` or the TTreeCache.Size option.; The entry range for which the cache is active can also be set with the; SetEntryRange method. \anchor changesbehaviour; ## Changes of behavior when using TChain and TEventList. The usage of TChain or TEventList have influence on the behaviour of the cache:. - Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. - Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:2960,perform,performance,2960,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['perform'],['performance']
Performance,"uffer zone in the FFT calculation. If this feature is activated (on by default),; /// the sampling array for the FFT calculation is extended in both directions,; /// and padded with the lowest/highest bin.; /// Example:; /// ```; /// original: -5 -4 -3 -2 -1 0 +1 +2 +3 +4 +5; /// add buffer zones: U U -5 -4 -3 -2 -1 0 +1 +2 +3 +4 +5 O O; /// rotate: 0 +1 +2 +3 +4 +5 O O U U -5 -4 -3 -2 -1; /// ```; /// The buffer bins are stripped away when the FFT output values; /// are transferred back to the p.d.f cache. The default buffer size is 10% of the; /// observable domain size, and can be changed with the `setBufferFraction()` member function.; ///; /// The RooFFTConvPdf uses caching inherited from a RooAbsCachedPdf. If it is; /// evaluated for a particular value of x, the FFT and convolution is calculated; /// for all bins in the observable space for the given choice of parameters,; /// which are also stored in the cache. Subsequent evaluations for different values of the convolution observable and; /// identical parameters will be retrieved from the cache. If one or more; /// of the parameters change, the cache will be updated, *i.e.*, a new FFT runs.; ///; /// The sampling density of the FFT is controlled by the binning of the; /// the convolution observable, which can be changed using RooRealVar::setBins(N).; /// For good results, N should be large (>=1000). Additional interpolation; /// between the bins may improve the result if coarse binnings are chosen. These can be; /// activated in the constructor or by calling `setInterpolationOrder()`.; /// For N >> 1000, interpolation will not substantially improve the accuracy.; ///; /// Additionial information on caching can be displayed by monitoring; /// the message stream with topic ""Caching"" at the INFO level, *i.e.*; /// by calling `RooMsgService::instance().addStream(RooMsgService::INFO,Topic(""Caching""))`; /// to see these message on stdout.; ///; /// Multi-dimensional convolutions are not supported at the moment.; /",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:3282,cache,cache,3282,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['cache'],['cache']
Performance,"ulated,; // the semantics of the inserted CSEL instruction is such that the taint; // register will contain all zero bits.; // One key requirement for this to work is that the conditional branch is; // followed by an execution of the CSEL instruction, where the CSEL; // instruction needs to use the same flags status as the conditional branch.; // This means that the conditional branches must not be implemented as one; // of the AArch64 conditional branches that do not use the flags as input; // (CB(N)Z and TB(N)Z). This is implemented by ensuring in the instruction; // selectors to not produce these instructions when speculation hardening; // is enabled. This pass will assert if it does encounter such an instruction.; // - On function call boundaries, the miss-speculation state is transferred from; // the taint register X16 to be encoded in the SP register as value 0.; //; // For the aspect of automatically hardening loads, using the taint register,; // (a.k.a. speculative load hardening, see; // https://llvm.org/docs/SpeculativeLoadHardening.html), the following; // implementation choices are made for AArch64:; // - Many of the optimizations described at; // https://llvm.org/docs/SpeculativeLoadHardening.html to harden fewer; // loads haven't been implemented yet - but for some of them there are; // FIXMEs in the code.; // - loads that load into general purpose (X or W) registers get hardened by; // masking the loaded data. For loads that load into other registers, the; // address loaded from gets hardened. It is expected that hardening the; // loaded data may be more efficient; but masking data in registers other; // than X or W is not easy and may result in being slower than just; // hardening the X address register loaded from.; // - On AArch64, CSDB instructions are inserted between the masking of the; // register and its first use, to ensure there's no non-control-flow; // speculation that might undermine the hardening mechanism.; //; // Future extensions/impr",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:4095,load,load,4095,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,1,['load'],['load']
Performance,"uld have received a copy of the GNU Library General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /* Color Context module; * Copyright 1994,1995 John L. Cwikla; * Copyright (C) 1997 by Ripley Software Development; * Copyright (C) 1997 by Federico Mena (port to Gtk/Gdk); */; /* Copyright 1994,1995 John L. Cwikla; *; * Permission to use, copy, modify, distribute, and sell this software; * and its documentation for any purpose is hereby granted without fee,; * provided that the above copyright notice appears in all copies and that; * both that copyright notice and this permission notice appear in; * supporting documentation, and that the name of John L. Cwikla or; * Wolfram Research, Inc not be used in advertising or publicity; * pertaining to distribution of the software without specific, written; * prior permission. John L. Cwikla and Wolfram Research, Inc make no; * representations about the suitability of this software for any; * purpose. It is provided ""as is"" without express or implied warranty.; *; * John L. Cwikla and Wolfram Research, Inc disclaim all warranties with; * regard to this software, including all implied warranties of; * merchantability and fitness, in no event shall John L. Cwikla or; * Wolfram Research, Inc be liable for any special, indirect or; * consequential damages or any damages whatsoever resulting from loss of; * use, data or profits, whether in an action of contract, negligence or; * other tortious action, arising out of or in connection with the use or; * performance of this software.; *; * Author:; * John L. Cwikla; * X Programmer; * Wolfram Research Inc.; *; * cwikla@wri.com; */; /*; * Modified by the GTK+ Team and others 1997-1999. See the AUTHORS; * file for a list of people on the GTK+ Team. See the ChangeLog; * files for a list of changes. These files are distributed with; * GTK+ at ftp://ftp.gtk.org/pub/gtk/. ; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c:2266,perform,performance,2266,graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,1,['perform'],['performance']
Performance,"uld only affects rule 4).; /// Essentially, this class doesn't perform any sort alias analysis to; /// identify aliasing loads and stores.; ///; /// To enforce aliasing between loads and stores, flag `AssumeNoAlias` must be; /// set to `false` by the constructor of LSUnit.; ///; /// Note that this class doesn't know about the existence of different memory; /// types for memory operations (example: write-through, write-combining, etc.).; /// Derived classes are responsible for implementing that extra knowledge, and; /// provide different sets of rules for loads and stores by overriding method; /// `isReady()`.; /// To emulate a write-combining memory type, rule 2. must be relaxed in a; /// derived class to enable the reordering of non-aliasing store operations.; ///; /// No assumptions are made by this class on the size of the store buffer. This; /// class doesn't know how to identify cases where store-to-load forwarding may; /// occur.; ///; /// LSUnit doesn't attempt to predict whether a load or store hits or misses; /// the L1 cache. To be more specific, LSUnit doesn't know anything about; /// cache hierarchy and memory types.; /// It only knows if an instruction ""mayLoad"" and/or ""mayStore"". For loads, the; /// scheduling model provides an ""optimistic"" load-to-use latency (which usually; /// matches the load-to-use latency for when there is a hit in the L1D).; /// Derived classes may expand this knowledge.; ///; /// Class MCInstrDesc in LLVM doesn't know about serializing operations, nor; /// memory-barrier like instructions.; /// LSUnit conservatively assumes that an instruction which `mayLoad` and has; /// `unmodeled side effects` behave like a ""soft"" load-barrier. That means, it; /// serializes loads without forcing a flush of the load queue.; /// Similarly, instructions that both `mayStore` and have `unmodeled side; /// effects` are treated like store barriers. A full memory; /// barrier is a 'mayLoad' and 'mayStore' instruction with unmodeled side; /// effect",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:1713,load,load,1713,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,2,"['cache', 'load']","['cache', 'load']"
Performance,"ultiple indices into arithmetic operations:; // BB1:; // %1 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = add i64 %1, %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = add i64 %3, %4; // %6 = add i64 %3, struct_field_3 ; Constant offset; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = add i64 %7, %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = add i64 %9, %10; // %12 = add i64 %11, struct_field_2 ; Constant offset; // %p = inttoptr i64 %12 to i32*; // load %p2; // ...; //; // If the target uses alias analysis in codegen, this pass will lower a GEP; // with multiple indices into multiple GEPs with a single index:; // BB1:; // %1 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = getelementptr i8* %1, i64 %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = getelementptr i8* %3, i64 %4; // %6 = getelementptr i8* %5, struct_field_3 ; Constant offset; // %p = bitcast i8* %6 to i32*; // load %p; // ...; // BB2:; // %7 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = getelementptr i8* %7, i64 %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = getelementptr i8* %9, i64 %10; // %12 = getelementptr i8* %11, struct_field_2 ; Constant offset; // %p2 = bitcast i8* %12 to i32*; // load %p2; // ...; //; // Lowering GEPs can also benefit other passes such as LICM and CGP.; // LICM (Loop Invariant Code Motion) can not hoist/sink a GEP of multiple; // indices if one of the index is variant. If we lower such GEP into invariant; // parts and variant parts, LICM can hoist/sink those invariant parts.; // CGP (CodeGen Prepare) tries to sink addres",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:5266,load,load,5266,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,1,['load'],['load']
Performance,"um Likelihood fit is performed to obtain the yields \f$N_i\f$; of the various species.The fit relies on discriminating variables \f$y\f$; uncorrelated with a control variable \f$x\f$:; the later is therefore totally absent from the fit. 2. The weights \f${_s{\cal P}}\f$ are calculated using Eq.; (2); where the covariance matrix is taken from Minuit. 3. Histograms of \f$x\f$ are filled by weighting the events with \f${_s{\cal P}}\f$ . 4. Error bars per bin are given by Eq. (6). The \f$\hbox {$_s$}{\cal P}lots\f$ reproduce the true distributions of the species; in the control variable \f$x\f$, within the above defined statistical uncertainties. ### Illustrations. To illustrate the technique, one considers an example derived from the analysis where; \f$\hbox {$_s$}{\cal P}lots\f$; have been first used (charmless B decays). One is dealing with a data; sample in which two species are present: the first is termed signal and; the second background. A maximum Likelihood fit is performed to obtain; the two yields \f$N_1\f$ and \f$N_2\f$ . The fit relies on two discriminating; variables collectively denoted \f$y\f$ which are chosen within three possible; variables denoted \f${m_{\rm ES}}\f$ , \f$\Delta E\f$ and \f${\cal F}\f$.; The variable which is not incorporated in \f$y\f$ is used as the control variable; \f$x\f$ . The six distributions of the three variables are assumed to be the ones; depicted in Fig. 1. \image html splot_pdfmesNIM.png Figure 1 width=800. Distributions of the three discriminating variables available to perform the Likelihood fit:; \f${m_{\rm ES}}\f$ , \f$\Delta E\f$ , \f${\cal F}\f$ .; Among the three variables, two are used to perform the fit while one is; kept out of the fit to serve the purpose of a control variable. The; three distributions on the top (resp. bottom) of the figure correspond; to the signal (resp. background). The unit of the vertical axis is; chosen such that it indicates the number of entries per bin, if one; slices the histograms i",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/splot/src/TSPlot.cxx:6641,perform,performed,6641,math/splot/src/TSPlot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/splot/src/TSPlot.cxx,1,['perform'],['performed']
Performance,"umentation directives</a>; <ol><li><a href=""#directive:html""><tt>BEGIN<!-- -->_HTML</tt> <tt>END<!-- -->_HTML</tt>: include 'raw' HTML</a></li>; <li><a href=""#directive:macro""><tt>BEGIN<!-- -->_MACRO</tt> <tt>END<!-- -->_MACRO</tt>: include a picture generated by a macro</a></li>; <li><a href=""#directive:latex""><tt>BEGIN<!-- -->_LATEX</tt> <tt>END<!-- -->_LATEX</tt>: include a latex picture</a></li>; </ol></li>; <li><a href=""#index"">Product and module index</a></li>; <li><a href=""#aux"">Auxiliary files: style sheet, JavaScript, help page</a></li>; <li><a href=""#charts"">Class Charts</a></li>; <li><a href=""#confvar"">Configuration variables</a></li>; <li><a href=""#how"">Behind the scenes</a></li>; </ol>. <h3><a name=""usage"">I. Usage</a></h3>; These are typical things people do with THtml:; <pre>; root[] <a href=""http://root.cern.ch/root/html/THtml.html"">THtml</a> html; // create a <a href=""http://root.cern.ch/root/html/THtml.html"">THtml</a> object; root[] html.LoadAllLibs(); // Load all rootmap'ed libraries; root[] html.MakeAll(); // generate documentation for all changed classes; </pre>; or to run on just a few classes:; <pre>; root[] <a href=""http://root.cern.ch/root/html/THtml.html"">THtml</a> html; // create a <a href=""http://root.cern.ch/root/html/THtml.html"">THtml</a> object; root[] html.MakeIndex(); // create auxiliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only; </pre>; To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:; <pre>; root[] html.Convert( ""hsimple.C"", ""Histogram example"" ); </pre>. <h3><a name=""conf"">II. Configuration</a></h3>; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc. <h4><a name=""conf:input"">II.1 Input files</a></h4>. <p>In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: <a href=""http://root.cern.ch/root/html",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx:3032,Load,LoadAllLibs,3032,html/src/THtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx,2,['Load'],"['Load', 'LoadAllLibs']"
Performance,"umption that EOB is; the longest code (bad assumption).; c12 3 Jan 93 M. Adler make tables for fixed blocks only once.; c13 5 Jan 93 M. Adler allow all zero length codes (pkzip 2.04c; outputs one zero length code for an empty; distance tree).; c14 12 Mar 93 M. Adler made inflate.c standalone with the; introduction of inflate.h.; c14b 16 Jul 93 G. Roelofs added (unsigned) typecast to w at 470.; c14c 19 Jul 93 J. Bush changed v[N_MAX], l[288], ll[28x+3x] arrays; to static for Amiga.; c14d 13 Aug 93 J-l. Gailly de-complicatified Mark's c[*p++]++ thing.; c14e 8 Oct 93 G. Roelofs changed memset() to memzero().; c14f 22 Oct 93 G. Roelofs renamed quietflg to qflag; made Trace(); conditional; added inflate_free().; c14g 28 Oct 93 G. Roelofs changed l/(lx+1) macro to pointer (Cray bug); c14h 7 Dec 93 C. Ghisler huft_build() optimizations.; c14i 9 Jan 94 A. Verheijen set fixed_t{d,l} to NULL after freeing;; G. Roelofs check NEXTBYTE macro for EOF.; c14j 23 Jan 94 G. Roelofs removed Ghisler ""optimizations""; ifdef'd; EOF check.; c14k 27 Feb 94 G. Roelofs added some typecasts to avoid warnings.; c14l 9 Apr 94 G. Roelofs fixed split comments on preprocessor lines; to avoid bug in Encore compiler.; c14m 7 Jul 94 P. Kienitz modified to allow assembler version of; inflate_codes() (define ASM_INFLATECODES); c14n 22 Jul 94 G. Roelofs changed fprintf to FPRINTF for DLL versions; c14o 23 Aug 94 C. Spieler added a newline to a debug statement;; G. Roelofs added another typecast to avoid MSC warning; */; /*; Inflate deflated (PKZIP's method 8 compressed) data. The compression; method searches for as much of the current string of bytes (up to a; length of 258) in the previous 32K bytes. If it doesn't find any; matches (of at least length 3), it codes the next byte. Otherwise, it; codes the length of the matched string and its distance backwards from; the current position. There is a single Huffman code that codes both; single bytes (called ""literals"") and match lengths. A second Huffman; co",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZInflate.c:3301,optimiz,optimizations,3301,core/zip/src/ZInflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZInflate.c,1,['optimiz'],['optimizations']
Performance,"under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of target specific stores for X86.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:1116,load,load,1116,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,6,"['load', 'optimiz']","['load', 'loads', 'optimized']"
Performance,"under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for equivalent functions that are mergable and folds them.; //; // Order relation is defined on set of functions. It was made through; // special function comparison procedure that returns; // 0 when functions are equal,; // -1 when Left function is less than right function, and; // 1 for opposite case. We need total-ordering, so we need to maintain; // four properties on the functions set:; // a <= a (reflexivity); // if a <= b and b <= a then a = b (antisymmetry); // if a <= b and b <= c then a <= c (transitivity).; // for all a and b: a <= b or b <= a (totality).; //; // Comparison iterates through each instruction in each basic block.; // Functions are kept on binary tree. For each new function F we perform; // lookup in binary tree.; // In practice it works the following way:; // -- We define Function* container class with custom ""operator<"" (FunctionPtr).; // -- ""FunctionPtr"" instances are stored in std::set collection, so every; // std::set::insert operation will give you result in log(N) time.; //; // As an optimization, a hash of the function structure is calculated first, and; // two functions are only compared if they have the same hash. This hash is; // cheap to compute, and has the property that if function F == G according to; // the comparison function, then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave tw",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:1112,perform,perform,1112,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,1,['perform'],['perform']
Performance,"upported LOHs are:; // * So called non-ADRP-related:; // - .loh AdrpAddLdr L1, L2, L3:; // L1: adrp xA, sym@PAGE; // L2: add xB, xA, sym@PAGEOFF; // L3: ldr xC, [xB, #imm]; // - .loh AdrpLdrGotLdr L1, L2, L3:; // L1: adrp xA, sym@GOTPAGE; // L2: ldr xB, [xA, sym@GOTPAGEOFF]; // L3: ldr xC, [xB, #imm]; // - .loh AdrpLdr L1, L3:; // L1: adrp xA, sym@PAGE; // L3: ldr xC, [xA, sym@PAGEOFF]; // - .loh AdrpAddStr L1, L2, L3:; // L1: adrp xA, sym@PAGE; // L2: add xB, xA, sym@PAGEOFF; // L3: str xC, [xB, #imm]; // - .loh AdrpLdrGotStr L1, L2, L3:; // L1: adrp xA, sym@GOTPAGE; // L2: ldr xB, [xA, sym@GOTPAGEOFF]; // L3: str xC, [xB, #imm]; // - .loh AdrpAdd L1, L2:; // L1: adrp xA, sym@PAGE; // L2: add xB, xA, sym@PAGEOFF; // For all these LOHs, L1, L2, L3 form a simple chain:; // L1 result is used only by L2 and L2 result by L3.; // L3 LOH-related argument is defined only by L2 and L2 LOH-related argument; // by L1.; // All these LOHs aim at using more efficient load/store patterns by folding; // some instructions used to compute the address directly into the load/store.; //; // * So called ADRP-related:; // - .loh AdrpAdrp L2, L1:; // L2: ADRP xA, sym1@PAGE; // L1: ADRP xA, sym2@PAGE; // L2 dominates L1 and xA is not redifined between L2 and L1; // This LOH aims at getting rid of redundant ADRP instructions.; //; // The overall design for emitting the LOHs is:; // 1. AArch64CollectLOH (this pass) records the LOHs in the AArch64FunctionInfo.; // 2. AArch64AsmPrinter reads the LOHs from AArch64FunctionInfo and it:; // 1. Associates them a label.; // 2. Emits them in a MCStreamer (EmitLOHDirective).; // - The MCMachOStreamer records them into the MCAssembler.; // - The MCAsmStreamer prints them.; // - Other MCStreamers ignore them.; // 3. Closes the MCStreamer:; // - The MachObjectWriter gets them from the MCAssembler and writes; // them in the object file.; // - Other ObjectWriters ignore them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp:3115,load,load,3115,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp,2,['load'],['load']
Performance,"ure.; * root - Window ID of the root window of destination screen; * mask, gcvalues - values for creation of new GC - see XCreateGC() for; * details.; * RETURN VALUE; * New GC created for regular window on success. NULL on failure.; * DESCRIPTION; * create_visual_gc() will create temporary window for the ASVisual; * specific depth and Visual and it will then create GC for such window.; * Obtained GC should be good to be used for manipulation of windows and; * Pixmaps created for the same ASVisual.; *********/; /****f* libAfterImage/create_visual_pixmap(); * NAME; * create_visual_pixmap(); * SYNOPSIS; * Pixmap create_visual_pixmap( ASVisual *asv, Window root,; * unsigned int width, unsigned int height,; * unsigned int depth );; * INPUTS; * asv - pointer to the valid ASVisual structure.; * root - Window ID of the root window of destination screen; * width, height - size of the pixmap to create.; * depth - depth of the pixmap to create. If 0 asv->true_depth; * will be used.; * RETURN VALUE; * ID of the newly created pixmap on success. None on failure.; * DESCRIPTION; * create_visual_pixmap() will perform sanity checks on passed; * parameters, and attempt to create pixmap for the specified ASVisual,; * root and depth.; *********/; /****f* libAfterImage/create_visual_ximage(); * NAME; * create_visual_ximage(); * SYNOPSIS; * XImage* create_visual_ximage( ASVisual *asv,; * unsigned int width, unsigned int height,; * unsigned int depth );; * INPUTS; * asv - pointer to the valid ASVisual structure.; * width, height - size of the XImage to create.; * depth - depth of the XImage to create. If 0 asv->true_depth; * will be used.; * RETURN VALUE; * pointer to newly created XImage on success. NULL on failure.; * DESCRIPTION; * create_visual_ximage() will perform sanity checks on passed; * parameters, and it will attempt to create XImage of sufficient size,; * and specified colordepth. It will also setup hooks for XImage; * deallocation to be handled by custom function.; *********/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.h:2370,perform,perform,2370,graf2d/asimage/src/libAfterImage/asvisual.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.h,2,['perform'],['perform']
Performance,"urrently being typed, then filtering the results; * based on the contents of the token. For example, when code-completing for; * the expression \c p->get, the client should provide the location just after; * the "">"" (e.g., pointing at the ""g"") to this code-completion hook. Then, the; * client can filter the results based on the current token text (""get""), only; * showing those results that start with ""get"". The intent of this interface; * is to separate the relatively high-latency acquisition of code-completion; * results from the filtering of results on a per-character basis, which must; * have a lower latency.; *; * \param TU The translation unit in which code-completion should; * occur. The source files for this translation unit need not be; * completely up-to-date (and the contents of those source files may; * be overridden via \p unsaved_files). Cursors referring into the; * translation unit may be invalidated by this invocation.; *; * \param complete_filename The name of the source file where code; * completion should be performed. This filename may be any file; * included in the translation unit.; *; * \param complete_line The line at which code-completion should occur.; *; * \param complete_column The column at which code-completion should occur.; * Note that the column should point just after the syntactic construct that; * initiated code completion, and not in the middle of a lexical token.; *; * \param unsaved_files the Files that have not yet been saved to disk; * but may be required for parsing or code completion, including the; * contents of those files. The contents and name of these files (as; * specified by CXUnsavedFile) are copied when necessary, so the; * client only needs to guarantee their validity until the call to; * this function returns.; *; * \param num_unsaved_files The number of unsaved file entries in \p; * unsaved_files.; *; * \param options Extra options that control the behavior of code; * completion, expressed as a bitwise OR of the ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:2398,perform,performed,2398,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,1,['perform'],['performed']
Performance,"used; /// to load and execute this file. In particular it will draw the; /// result of a function with the same name as the file. The function; /// will be executed in a context where the name of the branches can; /// be used as a C++ variable.; ///; /// For example draw px using the file hsimple.root (generated by the; /// hsimple.C tutorial), we need a file named hsimple.cxx:; /// ~~~ {.cpp}; /// double hsimple() {; /// return px;; /// }; /// ~~~; /// MakeProxy can then be used indirectly via the TTree::Draw interface; /// as follow:; /// ~~~ {.cpp}; /// new TFile(""hsimple.root""); /// ntuple->Draw(""hsimple.cxx"");; /// ~~~; /// A more complete example is available in the tutorials directory:; /// `h1analysisProxy.cxx`, `h1analysProxy.h` and `h1analysisProxyCut.C`; /// which reimplement the selector found in `h1analysis.C`; ///; /// The main features of this facility are:; ///; /// * on-demand loading of branches; /// * ability to use the 'branchname' as if it was a data member; /// * protection against array out-of-bound; /// * ability to use the branch data as object (when the user code is available); ///; /// See TTree::MakeProxy for more details.; ///; /// ### Making a Profile histogram; ///; /// In case of a 2-Dim expression, one can generate a TProfile histogram; /// instead of a TH2F histogram by specifying option=prof or option=profs; /// or option=profi or option=profg ; the trailing letter select the way; /// the bin error are computed, See TProfile2D::SetErrorOption for; /// details on the differences.; /// The option=prof is automatically selected in case of y:x>>pf; /// where pf is an existing TProfile histogram.; ///; /// ### Making a 2D Profile histogram; ///; /// In case of a 3-Dim expression, one can generate a TProfile2D histogram; /// instead of a TH3F histogram by specifying option=prof or option=profs.; /// or option=profi or option=profg ; the trailing letter select the way; /// the bin error are computed, See TProfile2D::SetErrorOption for; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:19600,load,loading,19600,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['load'],['loading']
Performance,"ust skip; * those) you do the composition math using png_composite or png_composite_16; * below then encode the resultant 8-bit or 16-bit values to match the output; * encoding.; *; * Other cases; * If neither the PNG nor the standard linear encoding work for you because; * of the software or hardware you use then you have a big problem. The PNG; * case will probably result in halos around the image. The linear encoding; * will probably result in a washed out, too bright, image (it's actually too; * contrasty.) Try the ALPHA_OPTIMIZED mode above - this will probably; * substantially reduce the halos. Alternatively try:; *; * png_set_alpha_mode(pp, PNG_ALPHA_BROKEN, PNG_DEFAULT_sRGB);; * This option will also reduce the halos, but there will be slight dark; * halos round the opaque parts of the image where the background is light.; * In the OPTIMIZED mode the halos will be light halos where the background; * is dark. Take your pick - the halos are unavoidable unless you can get; * your hardware/software fixed! (The OPTIMIZED approach is slightly; * faster.); *; * When the default gamma of PNG files doesn't match the output gamma.; * If you have PNG files with no gamma information png_set_alpha_mode allows; * you to provide a default gamma, but it also sets the output gamma to the; * matching value. If you know your PNG files have a gamma that doesn't; * match the output you can take advantage of the fact that; * png_set_alpha_mode always sets the output gamma but only sets the PNG; * default if it is not already set:; *; * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_DEFAULT_sRGB);; * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_GAMMA_MAC);; * The first call sets both the default and the output gamma values, the; * second call overrides the output gamma without changing the default. This; * is easier than achieving the same effect with png_set_gamma. You must use; * PNG_ALPHA_PNG for the first call - internal checking in png_set_alpha will; * fire if more than one call to ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:3116,OPTIMIZ,OPTIMIZED,3116,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['OPTIMIZ'],['OPTIMIZED']
Performance,"variable ""order""; is the order of the tree, and the inclusive upper limit on the indices of; the keys in the interior nodes. The variable ""order2"" is the inclusive; upper limit on the indices of the leaf nodes, and is designed; ~~~ {.cpp}; (1) to keep the sizes of the two kinds of nodes the same;; (2) to keep the expressions involving the arrays of keys looking; somewhat the same: lower limit upper limit; for inner nodes: 1 order; for leaf nodes: 0 order2; Remember that index 0 of the inner nodes is special.; ~~~; Currently, order2 = 2*(order+1).; ~~~ {.cpp}; Picture: (also see Knuth Vol 3 pg 478). +--+--+--+--+--+--...; | | | | | |; parent--->| | | |; | | | |; +*-+*-+*-+--+--+--...; | | |; +----+ | +-----+; | +-----+ |; V | V; +----------+ | +----------+; | | | | |; this->| | | | |<--sib; +----------+ | +----------+; V; data; ~~~; It is conceptually VERY convenient to think of the data as being the; very first element of the sib node. Any primitive that tells sib to; perform some action on n nodes should include this 'hidden' element.; For InnerNodes, the hidden element has (physical) index 0 in the array,; and in LeafNodes, the hidden element has (virtual) index -1 in the array.; Therefore, there are two 'size' primitives for nodes:; ~~~ {.cpp}; Psize - the physical size: how many elements are contained in the; array in the node.; Vsize - the 'virtual' size; if the node is pointed to by; element 0 of the parent node, then Vsize == Psize;; otherwise the element in the parent item that points to this; node 'belongs' to this node, and Vsize == Psize+1;; ~~~; Parent nodes are always InnerNodes. These are the primitive operations on Nodes:; ~~~ {.cpp}; Append(elt) - adds an element to the end of the array of elements in a; node. It must never be called where appending the element; would fill the node.; Split() - divide a node in two, and create two new nodes.; SplitWith(sib) - create a third node between this node and the sib node,; divvying up the elements of their ar",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TBtree.cxx:6104,perform,perform,6104,core/cont/src/TBtree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TBtree.cxx,1,['perform'],['perform']
Performance,"vector elements for each event. You can use the objects returned by actions as if they were pointers to the desired results. There are many other; possible [actions](\ref cheatsheet), and all their results are wrapped in smart pointers; we'll see why in a minute. ### Applying a filter; Let's say we want to cut over the value of branch ""MET"" and count how many events pass this cut. This is one way to do it:; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto c = d.Filter(""MET > 4."").Count(); // computations booked, not run; std::cout << *c << std::endl; // computations run here, upon first access to the result; ~~~; The filter string (which must contain a valid C++ expression) is applied to the specified columns for each event;; the name and types of the columns are inferred automatically. The string expression is required to return a `bool`; which signals whether the event passes the filter (`true`) or not (`false`). You can think of your data as ""flowing"" through the chain of calls, being transformed, filtered and finally used to; perform actions. Multiple Filter() calls can be chained one after another. Using string filters is nice for simple things, but they are limited to specifying the equivalent of a single return; statement or the body of a lambda, so it's cumbersome to use strings with more complex filters. They also add a small; runtime overhead, as ROOT needs to just-in-time compile the string into C++ code. When more freedom is required or; runtime performance is very important, a C++ callable can be specified instead (a lambda in the following snippet,; but it can be any kind of function or even a functor class), together with a list of column names.; This snippet is analogous to the one above:; ~~~{.cpp}; RDataFrame d(""myTree"", ""file.root"");; auto metCut = [](double x) { return x > 4.; }; // a C++11 lambda function checking ""x > 4""; auto c = d.Filter(metCut, {""MET""}).Count();; std::cout << *c << std::endl;; ~~~. An example of a more complex filter ex",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:18793,perform,perform,18793,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['perform'],['perform']
Performance,"vectorised fashion, similarly to Python's NumPy arrays. For example, to fill a histogram with the ""pt"" of selected particles for each event, Define() can be used to create a column that contains the desired array elements as follows:. ~~~{.cpp}; // h is filled with all the elements of `good_pts`, for each event; auto h = df.Define(""good_pts"", [](const ROOT::RVecF &pt) { return pt[pt > 0]; }); .Histo1D(""good_pts"");; ~~~. And in Python:. ~~~{.py}; h = df.Define(""good_pts"", ""pt[pt > 0]"").Histo1D(""good_pts""); ~~~. Learn more at ROOT::VecOps::RVec. \anchor transformations; ## Transformations: manipulating data; \anchor Filters; ### Filters; A filter is created through a call to `Filter(f, columnList)` or `Filter(filterString)`. In the first overload, `f` can; be a function, a lambda expression, a functor class, or any other callable object. It must return a `bool` signalling; whether the event has passed the selection (`true`) or not (`false`). It should perform ""read-only"" operations on the; columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; loop. See the paragraph about ""Just-in-time compilation"" below for more information. RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; each entry: after the first access it simply serves a cached result. \anchor n",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:28719,perform,perform,28719,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['perform'],['perform']
Performance,"ved class; TUnfoldDensity instead of TUnfold. TUnfoldDensity adds various; features to TUnfold, such as:; background subtraction, propagation of systematic uncertainties,; complex multidimensional arrangements of the bins. For innocent; users, the most notable improvement of TUnfoldDensity over TUnfold are; the getter functions. For TUnfold, histograms have to be booked by the; user and the getter functions fill the histogram bins. TUnfoldDensity; simply returns a new, already filled histogram.</b>. If you use this software, please consider the following citation; <br/>; <b>S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]</b>; <br/>; Detailed documentation and updates are available on; http://www.desy.de/~sschmitt. Brief recipy to use TUnfold:; <ul>; <li>a matrix (truth,reconstructed) is given as a two-dimensional histogram; as argument to the constructor of TUnfold</li>; <li>a vector of measurements is given as one-dimensional histogram using; the SetInput() method</li>; <li>The unfolding is performed; <ul>; <li>either once with a fixed parameter tau, method DoUnfold(tau)</li>; <li>or multiple times in a scan to determine the best chouce of tau,; method ScanLCurve()</li>; </ul>; <li>Unfolding results are retrieved using various GetXXX() methods; </ul>. Basic formulae:<br/>; &chi;<sup>2</sup><sub>A</sub>=(Ax-y)<sup>T</sup>V<sub>yy</sub><sup>-1</sup>(Ax-y)<br/>; &chi;<sup>2</sup><sub>L</sub>=(x-f*x<sub>0</sub>)<sup>T</sup>L<sup>T</sup>L(x-f*x<sub>0</sub>)<br/>; &chi;<sup>2</sup><sub>unf</sub>=&chi;<sup>2</sup><sub>A</sub>+&tau;<sup>2</sup>&chi;<sup>2</sup><sub>L</sub>+&lambda;&Sigma;<sub>i</sub>(Ax-y)<sub>i</sub><br/>; x:result, A:probabilities, y:data, V<sub>yy</sub>:data; covariance, f:bias scale, x<sub>0</sub>:bias, L:regularisation conditions,; &tau;:regularisation strength, &lambda;:Lagrangian multiplier<br/>; Without area constraint, &lambda; is set to zero, and; &chi;<sup>2</sup><sub>unf</sub> is minimized to determine x. With area; constraint, both x and &la",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx:3593,perform,performed,3593,hist/unfold/src/TUnfold.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx,1,['perform'],['performed']
Performance,"vel object (eg Event *event) is a tree/graph of many objects,; the normal ROOT Streaming mechanism ensures that only one copy of each object; in the tree/graph is written to the output buffer to avoid circular; dependencies. However if the object event is split into several files or into several; branches of one or more Trees, normal C++ pointers cannot be used because; each I/O operation will write the referenced objects. When a TRef is used to point to a TObject *robj, for example in a class with; ~~~ {.cpp}; TRef fRef;; ~~~; one can do:; ~~~ {.cpp}; fRef = robj; //to set the pointer; ~~~; This TRef and robj can be written with two different I/O calls; in the same or different files, in the same or different branches of a Tree. If the TRef is read and the referenced object has not yet been read,; the TRef will return a null pointer. As soon as the referenced object; will be read, the TRef will point to it. If the referenced object is; contained in a TTree it can be auto-loaded using the TBranchRef mechanism,; which is set up by simply calling TTree::BranchRef(). TRef also supports the complex situation where a TFile is updated; multiple times on the same machine or a different machine. ## How does it work. A TRef is itself a TObject with an additional transient pointer fPID.; When the statement fRef = robj is executed, the following actions happen:. - The pointer fPID is set to the current TProcessID.; - The current ObjectNumber (see below) is incremented by one.; - robj::fUniqueID is set to ObjectNumber.; - In the fPID object, the element fObjects[ObjectNumber] is set to robj; - ref::fUniqueID is also set to ObjectNumber. After having set fRef, one can immediately return the value of robj; using fRef.GetObject(). This function returns directly fObjects[fUniqueID]; from the fPID object. When the TRef is written, the process id number pidf of fPID is written; in addition to the TObject part of TRef (fBits,fUniqueID). When the TRef is read, its pointer fPID is set to",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TRef.cxx:1757,load,loaded,1757,core/base/src/TRef.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TRef.cxx,1,['load'],['loaded']
Performance,"veral ones) :; errorCode = FSE_initDState(&DState, &DStream, DTablePtr);. You can then decode your data, symbol after symbol.; For information the maximum number of bits read by FSE_decodeSymbol() is 'tableLog'.; Keep in mind that symbols are decoded in reverse order, like a LIFO stack (last in, first out).; unsigned char symbol = FSE_decodeSymbol(&DState, &DStream);. You can retrieve any bitfield you eventually stored into the bitStream (in reverse order); Note : maximum allowed nbBits is 25, for 32-bits compatibility; size_t bitField = BIT_readBits(&DStream, nbBits);. All above operations only read from local register (which size depends on size_t).; Refueling the register from memory is manually performed by the reload method.; endSignal = FSE_reloadDStream(&DStream);. BIT_reloadDStream() result tells if there is still some more data to read from DStream.; BIT_DStream_unfinished : there is still some data left into the DStream.; BIT_DStream_endOfBuffer : Dstream reached end of buffer. Its container may no longer be completely filled.; BIT_DStream_completed : Dstream reached its exact end, corresponding in general to decompression completed.; BIT_DStream_tooFar : Dstream went too far. Decompression result is corrupted. When reaching end of buffer (BIT_DStream_endOfBuffer), progress slowly, notably if you decode multiple symbols per loop,; to properly detect the exact end of stream.; After each decoded symbol, check if DStream is fully consumed using this simple test :; BIT_reloadDStream(&DStream) >= BIT_DStream_completed. When it's done, verify decompression is fully completed, by checking both DStream and the relevant states.; Checking if DStream has reached its end is performed by :; BIT_endOfDStream(&DStream);; Check also the states. There might be some symbols left there, if some high probability ones (>50%) are possible.; FSE_endOfDState(&DState);; */; /* *****************************************; * FSE unsafe API; *******************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:2353,perform,performed,2353,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,1,['perform'],['performed']
Performance,"very fast; * averaging/interpolation code. That brings us to the issue of 8 bits; * per channel. Add two pixels together and you get overflow. So all the; * math has to be performed in different colorspace and then converted; * back. On the other side, such a conversion may discard valuable bits,; * so some compensation method has to be implemented.; *; * On the text drawing side of things, there are numerous problems just; * as well. Native X fonts look ugly as soon as you try to show any; * decently sized text. That is supposed to be solved with said Render; * extensions to XFree86, but as experiense has shown, things aren't as; * easy as it looks, besides one wants one's app to run well under any X; * Server. FreeType library provides a solution, but not always; * available. Another problem is that if you keep all your images on the; * client side, you want to draw text on client side as well.; *; * The solution is to provide transparent interface that could use both; * X fonts and FreeType, cache glyphs on the client side and possibly; * perform smoothing of ugly X fonts.; *; * There is no library solving all this problems in one fell swoop,; * except for monstrous ones, like ImLib.; *; * Hence libAfterImage has come to life.; *; * DESCRIPTION; * libAfterStep provides sevarl facilities.; *; * 1. X Visual abstruction layer via ASVisual. This layer handles color; * management, transfer of data to and from X Server, and other screen; * related stuff.; *; * 2. Scanline handling facility via ASScanline. ASScanline is the most; * widely used structure since image handling is implemented on; * per-scanline basis.; *; * 3. Image storage, trasformation and rendering via ASImage. ASImage; * provides for generic container used for any image or text; * manipulation. It incorporates such a robust facilities as in-memory; * RLE compression, separate channel storage of 4 channels ( Alpha, Red,; * Green, and Blue ) with 8 bit per channel.; *; * 4. Simplified font handling facili",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/afterimage.h:2935,cache,cache,2935,graf2d/asimage/src/libAfterImage/afterimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/afterimage.h,2,"['cache', 'perform']","['cache', 'perform']"
Performance,"very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. ## Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandatory steps; that have to be followed in order to be validated by the modeler. There are; general rules : volumes needs media and shapes in order to be created,; both container and containee volumes must be created before linking them together,; and the relative transformation matrix must be provided. All branches must; have an upper link point otherwise they will not be considered as part of the; geometry. Visibility or tracking properties of volumes can be provided both; at build time or after geometry is closed, but global visualization settings; (see TGeoPainter class) should not be provided at build time, otherwise the; drawing package will be loaded. There is also a list of specific rules :; positioned daughters should not extrude their mother or intersect with sisters; unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume; (containing all geometry tree) must be specified before closing the geometry; and must not be positioned - it represents the global reference frame. After; building the full geometry tree, the geometry must be closed; (see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; this process. Below is the general scheme of the manager class. \image html geom_mgr.jpg. ## An interactive session. Provided that a geometry was successfully built and closed (for instance the; previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; itself to ROOT and the logical/physical structures will become immediately browsable.; The ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:6994,load,loaded,6994,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,1,['load'],['loaded']
Performance,"vidually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; // element size. Do the same for stores.; // - For each equivalence class, greedily build ""chains"". Each chain has a; // leader instruction, and every other member of the chain has a known; // constant offset from the first instr in the chain.; // - Break up chains so that they contain only contiguous accesses of legal; // size with no intervening may-alias instrs.; // - Convert each chain to vector instructions.; //; // The O(n^2) behavior of this pass comes from initially building the chains.; // In the worst case we have to compare each new instruction to all of those; // that came before. To limit this, we only calculate the offset to the leaders; // of the N most recently-used chains.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:2433,load,loads,2433,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,2,['load'],"['loaded', 'loads']"
Performance,"w, TTree::Process, TSelector, TTreeReader and RDataFrame; when in the learning phase. The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. The usage of a TTreeCache can considerably improve the runtime performance at; the price of a modest investment in memory, in particular when the TTree is; accessed remotely, e.g. via a high latency network. For each TTree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted.; The user can change the size of the cache with the TTree::SetCacheSize method; (by default the size is 30 Megabytes). This feature can be controlled with the; environment variable `ROOT_TTREECACHE_SIZE` or the TTreeCache.Size option.; The entry range for which the cache is active can also be set with the; SetEntryRange method. \anchor changesbehaviour; ## Changes of behavior when using TChain and TEventList. The usage of TChain or TEventList have influence on the behaviour of the cache:. - Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. - Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning phase is started or restarted when:; - TTree automatically creates a cache.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTreeCache::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; - TTreeCache::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries.; - A 'cached' TChain switches over to a new file. \",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:3747,cache,cache,3747,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The latter can perform more complex address checks to figure out whether; /// it's safe to touch the shadow memory.; /// Like with atomic operations, we call __",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4817,load,load,4817,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['load'],['load']
Performance,"will add histograms (see note) and Trees from a list of root files and write them to a target root file.; The target file is newly created and must not be; identical to one of the source files. Syntax:; ```{.cpp}; hadd targetfile source1 source2 ...; ```; or; ```{.cpp}; hadd -f targetfile source1 source2 ...; ```; (targetfile is overwritten if it exists). \param -a Append to the output; \param -f Force overwriting of output file.; \param -f[0-9] Set target compression level. 0 = uncompressed, 9 = highly compressed. Default is 1 (kDefaultZLIB).; You can also specify the full compresion algorithm, e.g. -f206; \param -fk Sets the target file to contain the baskets with the same compression; as the input files (unless -O is specified). Compresses the meta data; using the compression level specified in the first input or the; compression setting after fk (for example 206 when using -fk206); \param -ff The compression level used is the one specified in the first input; \param -k Skip corrupt or non-existent files, do not exit; \param -O Re-optimize basket size when merging TTree; \param -T Do not merge Trees; \param -v Explicitly set the verbosity level: 0 request no output, 99 is the default; \param -j Parallelise the execution in `J` processes. If the number of processes is not specified, use the system maximum.; \param -dbg Enable verbosity. If -j was specified, do not not delete partial files stored inside working directory.; \param -d Carry out the partial multiprocess execution in the specified directory; \param -n Open at most `N` files at once (use 0 to request to use the system maximum); \param -cachesize Resize the prefetching cache use to speed up I/O operations (use 0 to disable).; \param -experimental-io-features `<feature>` Enables the corresponding experimental feature for output trees. \see ROOT::Experimental::EIOFeatures; \return hadd returns a status code: 0 if OK, -1 otherwise. For example assume 3 files f1, f2, f3 containing histograms hn and Trees Tn; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/main/src/hadd.cxx:1091,optimiz,optimize,1091,main/src/hadd.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/main/src/hadd.cxx,1,['optimiz'],['optimize']
Performance,"will be available through the function; /// TSystem::SetIncludePath().; /// A good default will be provided so that a typical user session should be at; /// most:; /// ~~~ {.cpp}; /// root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; /// -I$HOME/mypackage/include"");; /// root[2] .x myfunc.C++(10,20);; /// ~~~; /// The user may sometimes try to compile a script before it has loaded all the; /// needed shared libraries. In this case we want to be helpful and output a; /// list of the unresolved symbols. So if the loading of the created shared; /// library fails, we will try to build a executable that contains the; /// script. The linker should then output a list of missing symbols.; ///; /// To support this we provide a TSystem::SetMakeExe() function, that sets the; /// directive telling how to create an executable. The loader will need; /// to be informed of all the libraries available. The information about; /// the libraries that has been loaded by .L and TSystem::Load() is accessible; /// to the script compiler. However, the information about; /// the libraries that have been selected at link time by the application; /// builder (like the root libraries for root.exe) are not available and need; /// to be explicitly listed in fLinkedLibs (either by default or by a call to; /// TSystem::SetLinkedLibs()).; ///; /// To simplify customization we could also add to the .rootrc support for the; /// variables; /// ~~~ {.cpp}; /// Unix.*.Root.IncludePath: -I$ROOTSYS/include; /// WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; ///; /// Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; /// WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; /// ~~~; /// And also support for MakeSharedLibs() and MakeExe().; ///; /// (the ... have to be replaced by the actual values and are here only to; /// shorten this comment).; ///; /// Note that the default behavior is to remove libraries when closing ROOT,; /// ie TSystem::CleanCompiledMacros() is called in the TROOT destruc",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:4815,Load,Load,4815,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['Load'],['Load']
Performance,"will be executed in the event loop. RDataFrame is built with a *modular* and *flexible* workflow in mind, summarised as follows:. 1. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, [CSV files](https://root.cern/doc/master/df014__CSVDataSource_8C.html), [SQLite files](https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C.html), [RNTuples](https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTuple.html), and it can be extended to custom data formats. From Python, [NumPy arrays can be imported into RDataFrame](https://root.cern/doc/master/df032__MakeNumpyDataFrame_8py.html) as well. 2. Transform the dataframe by:. - [Applying filters](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). This selects only specific rows of the dataset. - [Creating custom columns](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#transformations). Custom columns can, for example, contain the results of a computation that must be performed for every row of the dataset. 3. [Produce results](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#actions). *Actions* are used to aggregate data into results. Most actions are *lazy*, i.e. they are not executed on the spot, but registered with RDataFrame and executed only when a result is accessed for the first time. Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate work and then produce all results at the same time, upon first access to any of them. The following table shows how analyses based on TTreeReader and TTree::Draw() translate to RDataFrame. Follow the; [crash course](#crash-course) to discover more idiomatic and flexible ways to express analyses with RDataFrame.; <table>; <tr>; <td>; <b>TTreeReader</b>; </td>; <td>; <b>ROOT::RDataFrame</b>; </td>; </tr>; <tr>; <td>; ~~~{.cpp}; TTreeReader reader(""myTree"", file);; TTreeReaderValue<A_t> a(reader, ""A""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:12815,perform,performed,12815,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['perform'],['performed']
Performance,"with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This pass lowers the pseudo control flow instructions to real; /// machine instructions.; ///; /// All control flow is handled using predicated instructions and; /// a predicate stack. Each Scalar ALU controls the operations of 64 Vector; /// ALUs. The Scalar ALU can update the predicate for any of the Vector ALUs; /// by writing to the 64-bit EXEC register (each bit corresponds to a; /// single vector ALU). Typically, for predicates, a vector ALU will write; /// to its bit of the VCC register (like EXEC VCC is 64-bits, one for each; /// Vector ALU) and then the ScalarALU will AND the VCC register with the; /// EXEC to update the predicates.; ///; /// For example:; /// %vcc = V_CMP_GT_F32 %vgpr1, %vgpr2; /// %sgpr0 = SI_IF %vcc; /// %vgpr0 = V_ADD_F32 %vgpr0, %vgpr0; /// %sgpr0 = SI_ELSE %sgpr0; /// %vgpr0 = V_SUB_F32 %vgpr0, %vgpr0; /// SI_END_CF %sgpr0; ///; /// becomes:; ///; /// %sgpr0 = S_AND_SAVEEXEC_B64 %vcc // Save and update the exec mask; /// %sgpr0 = S_XOR_B64 %sgpr0, %exec // Clear live bits from saved exec mask; /// S_CBRANCH_EXECZ label0 // This instruction is an optional; /// // optimization which allows us to; /// // branch if all the bits of; /// // EXEC are zero.; /// %vgpr0 = V_ADD_F32 %vgpr0, %vgpr0 // Do the IF block of the branch; ///; /// label0:; /// %sgpr0 = S_OR_SAVEEXEC_B64 %sgpr0 // Restore the exec mask for the Then; /// // block; /// %exec = S_XOR_B64 %sgpr0, %exec // Update the exec mask; /// S_BRANCH_EXECZ label1 // Use our branch optimization; /// // instruction again.; /// %vgpr0 = V_SUB_F32 %vgpr0, %vgpr // Do the THEN block; /// label1:; /// %exec = S_OR_B64 %exec, %sgpr0 // Re-enable saved exec mask bits; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp:1506,optimiz,optimization,1506,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,2,['optimiz'],['optimization']
Performance,"with fld1) to not break; // instructions like x87.; // Ideally we would like the only limitation on executing instructions to be the; // availability of the CPU resources (e.g. execution ports) needed to execute; // them, instead of the availability of their data dependencies.; // To achieve that, one approach is to generate instructions that do not have; // data dependencies between them.; //; // For some instructions, this is trivial:; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // mov rax, qword ptr [rsi]; // For the above snippet, haswell just renames rax four times and executes the; // four instructions two at a time on P23 and P0126.; //; // For some instructions, we just need to make sure that the source is; // different from the destination. For example, IDIV8r reads from GPR and; // writes to AX. We just need to ensure that the Var is assigned a; // register which is different from AX:; // idiv bx; // idiv bx; // idiv bx; // idiv bx; // The above snippet will be able to fully saturate the ports, while the same; // with ax would issue one uop every `latency(IDIV8r)` cycles.; //; // Some instructions make this harder because they both read and write from; // the same register:; // inc rax; // inc rax; // inc rax; // inc rax; // This has a data dependency from each instruction to the next, limit the; // number of instructions that can be issued in parallel.; // It turns out that this is not a big issue on recent Intel CPUs because they; // have heuristics to balance port pressure. In the snippet above, subsequent; // instructions will end up evenly distributed on {P0,P1,P5,P6}, but some CPUs; // might end up executing them all on P0 (just because they can), or try; // avoiding P5 because it's usually under high pressure from vector; // instructions.; // This issue is even more important for high-latency instructions because; // they increase the idle time of the CPU, e.g. :; // imul rax, rbx; // imul rax, rbx; // imul",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp:1163,latency,latency,1163,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/ParallelSnippetGenerator.cpp,1,['latency'],['latency']
Performance,"x 144 0 y 144 1 z 144 2 t 144 3; ///; /// * parameters :; ///; /// [1] 140 1; /// [2] 140 2; /// etc.; /// ~~~; ///; /// ### Special cases for normalized gaussian or landau distributions; ///; /// the expression ""gaus"" is a substitute for; ///; /// [0]*exp(-0.5*((x-[1])/[2])**2); ///; /// to obtain a standard normalized gaussian, use ""gausn"" instead of ""gaus""; /// the expression ""gausn"" is a substitute for; ///; /// [0]*exp(-0.5*((x-[1])/[2])**2)/(sqrt(2*pi)*[2])); ///; /// WARNING: gaus and gausn are mutually exclusive in the same expression.; ///; /// In the same way the expression ""landau"" is a substitute for; ///; /// [0]*TMath::Landau(x,[1],[2],kFALSE); ///; /// to obtain a standard normalized landau, use ""landaun"" instead of ""landau""; /// the expression ""landaun"" is a substitute for; ///; /// [0]*TMath::Landau(x,[1],[2],kTRUE); ///; /// WARNING: landau and landaun are mutually exclusive in the same expression.; ///; /// ### Boolean optimization (kBoolOptmize) :; ///; /// Those pseudo operation are used to implement lazy evaluation of; /// && and ||. When the left hand of the expression if false; /// (respectively true), the evaluation of the right is entirely skipped; /// (since it would not change the value of the expression).; ///; /// && 142 11 (one operation on right) 142 21 (2 operations on right); /// || 142 12 (one operation on right) 142 22 (2 operations on right); ///; /// * functions calls (kFunctionCall) :; ///; /// f0 145 0 f1 145 1 etc..; ///; /// ### Errors :; ///; /// 1 : Division By Zero; /// 2 : Invalid Floating Point Operation; /// 4 : Empty String; /// 5 : invalid syntax; /// 6 : Too many operators; /// 7 : Too many parameters; /// 10 : z specified but not x and y; /// 11 : z and y specified but not x; /// 12 : y specified but not x; /// 13 : z and x specified but not y; /// 20 : non integer value for parameter number; /// 21 : atan2 requires two arguments; /// 22 : pow requires two arguments; /// 23 : degree of polynomial not specified; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:2885,optimiz,optimization,2885,hist/hist/src/TFormula_v5.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx,1,['optimiz'],['optimization']
Performance,"xmm2; /// [1,2]	. DeE-----R ..	vpermilps $231, %xmm0, %xmm5; /// [1,3]	. D=eeeE--R ..	vaddss %xmm1, %xmm0, %xmm3; /// [1,4]	. D===eeeER ..	vaddss %xmm3, %xmm2, %xmm4; /// [1,5]	. D======eeeER	vaddss %xmm4, %xmm5, %xmm6; ///; /// There is an entry for every instruction in the input assembly sequence.; /// The first field is a pair of numbers obtained from the instruction index.; /// The first element of the pair is the iteration index, while the second; /// element of the pair is a sequence number (i.e. a position in the assembly; /// sequence).; /// The second field of the table is the actual timeline information; each; /// column is the information related to a specific cycle of execution.; /// The timeline of an instruction is described by a sequence of character; /// where each character represents the instruction state at a specific cycle.; ///; /// Possible instruction states are:; /// D: Instruction Dispatched; /// e: Instruction Executing; /// E: Instruction Executed (write-back stage); /// R: Instruction retired; /// =: Instruction waiting in the Scheduler's queue; /// -: Instruction executed, waiting to retire in order.; ///; /// dots ('.') and empty spaces are cycles where the instruction is not; /// in-flight.; ///; /// The last column is the assembly instruction associated to the entry.; ///; /// Based on the timeline view information from the example, instruction 0; /// at iteration 0 was dispatched at cycle 0, and was retired at cycle 3.; /// Instruction [0,1] was also dispatched at cycle 0, and it retired at; /// the same cycle than instruction [0,0].; /// Instruction [0,4] has been dispatched at cycle 2. However, it had to; /// wait for two cycles before being issued. That is because operands; /// became ready only at cycle 5.; ///; /// This view helps further understanding bottlenecks and the impact of; /// resource pressure on the code.; ///; /// To better understand why instructions had to wait for multiple cycles in; /// the scheduler's queue, cla",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h:2292,queue,queue,2292,interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/TimelineView.h,1,['queue'],['queue']
Performance,"xploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, similar to a GPU vectorized load. In theory ARM; // could use this pass (with some modifications), but currently it implements; // its own pass to do something similar to what we do here.; //; // Overview of the algorithm and terminology in this pass:; //; // - Break up each basic block into pseudo-BBs, composed of instructions which; // are guaranteed to transfer control to their successors.; // - Within a single pseudo-BB, find all loads, and group them into; // ""equivalence classes"" according to getUnderlyingObject() and loaded; // element size. Do the same for stores.; // - For each equivalence class, greedily build ""chains"". Each chain has a; // leader instruction, and every other member of the chain has a known; // constant offset from the first instr in the chain.; // - Break up chains so that they contain only con",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:1871,load,loads,1871,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['load'],['loads']
Performance,"y be created with automatic; sizing when a TTree is used:. In some applications, e.g. central processing workflows of experiments, the list; of branches to read is known a priori. For these cases, the TTreeCache can be; instructed about the branches which will be read via explicit calls to the TTree; or TTreeCache interfaces.; In less streamlined applications such as analysis, predicting the branches which; will be read can be difficult. In such cases, ROOT I/O flags used branches; automatically when a branch buffer is read during the learning phase. In the examples below, portions of analysis code are shown.; The few statements involving the TreeCache are marked with `//<<<`. ### ROOT::RDataFrame and TTreeReader Examples. If you use RDataFrame or TTreeReader, the system will automatically cache the; best set of branches: no action is required by the user. ### TTree::Draw Example. The TreeCache is automatically used by TTree::Draw. The method knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also inferred automatically. ### TTree::Process and TSelectors Examples. The user must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case only a subset of the events is processed to avoid wasteful caching. #### Reading all branches. ~~~ {.cpp}; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; ~~~. #### Reading a subset of all branches. In the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; ~~~ {.cpp}; TTree *T;; f->GetObject(T, ""mytree"");;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:7036,cache,cache,7036,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"y of the classes on the file; is read in memory (see TFile::ReadStreamerInfo). When the TStreamerElement; object is read, a TExec object is automatically created with the name; specified after the keyword ""EXEC:"" in case a TExec with a same name does; not already exist. The action to be executed via this TExec can be specified with:. - a call to the TExec constructor, if the constructor is called before; opening the file.; - a call to TExec::SetAction at any time.; One can compute a pointer to an existing TExec with a name with:; ~~~ {.cpp}; TExec *myExec = gROOT->GetExec(execName);; myExec->SetAction(actionCommand);; ~~~; where actionCommand is a string containing a C++ instruction. Examples:; ~~~ {.cpp}; myExec->SetAction(""LoadHits()"");; myExec->SetAction("".x script.C"");; ~~~. When a TRef is dereferenced via TRef::GetObject, its TExec will be; automatically executed. In the function/script being executed, one or more; of the following actions can be executed:. - load a file containing the referenced object. This function typically; looks in the file catalog (GRID).; - compute a pointer to the referenced object and communicate this pointer; back to the calling function TRef::GetObject via:; ~~~ {.cpp}; TRef::SetStaticObject(object).; ~~~; When the TExec is called, it has access to the dereferencing TRef; by calling GetStaticObject() (TRef::GetObject() sets fgObject to ""this""; before the call to TExec). This can be useful for accessing the TRef's; fUniqueID. As soon as an object is returned to GetObject, the fUniqueID of the TRef is set; to the fUniqueID of the referenced object. At the next call to GetObject,; the pointer stored in fPid:fObjects[fUniqueID] will be returned directly. An example of action on demand is shown in $ROOTSYS/test/Event.h with; the member:; ~~~ {.cpp}; TRef fWebHistogram; //EXEC:GetWebHistogram; ~~~; When calling fWebHistogram.GetObject(), the function GetObject; will automatically invoke a script GetWebHistogram.C via the interpreter. An e",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TRef.cxx:6817,load,load,6817,core/base/src/TRef.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TRef.cxx,1,['load'],['load']
Performance,"y; /// if it does not exist yet or the macro file is newer than the shared; /// library.; ///; /// Of course the + and ++ notation is supported in similar way for .x and .L.; ///; /// Through the function TSystem::SetMakeSharedLib(), the user will be able to; /// indicate, with shell commands, how to build a shared library (a good; /// default will be provided). The most common change, namely where to find; /// header files, will be available through the function; /// TSystem::SetIncludePath().; /// A good default will be provided so that a typical user session should be at; /// most:; /// ~~~ {.cpp}; /// root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; /// -I$HOME/mypackage/include"");; /// root[2] .x myfunc.C++(10,20);; /// ~~~; /// The user may sometimes try to compile a script before it has loaded all the; /// needed shared libraries. In this case we want to be helpful and output a; /// list of the unresolved symbols. So if the loading of the created shared; /// library fails, we will try to build a executable that contains the; /// script. The linker should then output a list of missing symbols.; ///; /// To support this we provide a TSystem::SetMakeExe() function, that sets the; /// directive telling how to create an executable. The loader will need; /// to be informed of all the libraries available. The information about; /// the libraries that has been loaded by .L and TSystem::Load() is accessible; /// to the script compiler. However, the information about; /// the libraries that have been selected at link time by the application; /// builder (like the root libraries for root.exe) are not available and need; /// to be explicitly listed in fLinkedLibs (either by default or by a call to; /// TSystem::SetLinkedLibs()).; ///; /// To simplify customization we could also add to the .rootrc support for the; /// variables; /// ~~~ {.cpp}; /// Unix.*.Root.IncludePath: -I$ROOTSYS/include; /// WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; ///; /// Unix.*.Root.Linke",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:4352,load,loading,4352,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['load'],['loading']
Performance,"yTree"", ""file.root"", {""b1""});; auto min = d2.Filter([](double b2) { return b2 > 0; }, {""b2""}) // we can still specify non-default column lists; .Min(); // returns the minimum value of ""b1"" for the filtered entries; ~~~. \anchor helper-cols; ### Special helper columns: rdfentry_ and rdfslot_; Every instance of RDataFrame is created with two special columns called `rdfentry_` and `rdfslot_`. The `rdfentry_`; column is of type `ULong64_t` and it holds the current entry number while `rdfslot_` is an `unsigned int`; holding the index of the current data processing slot.; For backwards compatibility reasons, the names `tdfentry_` and `tdfslot_` are also accepted.; These columns are ignored by operations such as [Cache](classROOT_1_1RDF_1_1RInterface.html#aaaa0a7bb8eb21315d8daa08c3e25f6c9); or [Snapshot](classROOT_1_1RDF_1_1RInterface.html#a233b7723e498967f4340705d2c4db7f8). \warning Note that in multi-thread event loops the values of `rdfentry_` _do not_ correspond to what would be the entry numbers; of a TChain constructed over the same set of ROOT files, as the entries are processed in an unspecified order. \anchor jitting; ### Just-in-time compilation: column type inference and explicit declaration of column types; C++ is a statically typed language: all types must be known at compile-time. This includes the types of the TTree; branches we want to work on. For filters, defined columns and some of the actions, **column types are deduced from the; signature** of the relevant filter function/temporary column expression/action function:; ~~~{.cpp}; // here b1 is deduced to be `int` and b2 to be `double`; df.Filter([](int x, double y) { return x > 0 && y < 0.; }, {""b1"", ""b2""});; ~~~; If we specify an incorrect type for one of the columns, an exception with an informative message will be thrown at; runtime, when the column value is actually read from the dataset: RDataFrame detects type mismatches. The same would; happen if we swapped the order of ""b1"" and ""b2"" in the column",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:64703,multi-thread,multi-thread,64703,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['multi-thread'],['multi-thread']
Performance,"you should either explicitly cast the value or; /// use any intermediary variable:; /// ~~~{.cpp}; /// fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);; /// ~~~; /// Also, optionally, the generated selector will also call methods named; /// macrofilename_methodname in each of 6 main selector methods if the method; /// macrofilename_methodname exist (Where macrofilename is stripped of its; /// extension).; ///; /// Concretely, with the script named h1analysisProxy.C,; ///; /// - The method calls the method (if it exist); /// - Begin -> void h1analysisProxy_Begin(TTree*);; /// - SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; /// - Notify -> bool h1analysisProxy_Notify();; /// - Process -> bool h1analysisProxy_Process(Long64_t);; /// - SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; /// - Terminate -> void h1analysisProxy_Terminate();; ///; /// If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; /// it is included before the declaration of the proxy class. This can; /// be used in particular to insure that the include files needed by; /// the macro file are properly loaded.; ///; /// The default histogram is accessible via the variable named 'htemp'.; ///; /// If the library of the classes describing the data in the branch is; /// loaded, the skeleton will add the needed `include` statements and; /// give the ability to access the object stored in the branches.; ///; /// To draw px using the file `hsimple.root (generated by the; /// hsimple.C tutorial), we need a file named hsimple.cxx:; ///; /// ~~~{.cpp}; /// double hsimple() {; /// return px;; /// }; /// ~~~; /// MakeProxy can then be used indirectly via the TTree::Draw interface; /// as follow:; /// ~~~{.cpp}; /// new TFile(""hsimple.root""); /// ntuple->Draw(""hsimple.cxx"");; /// ~~~; /// A more complete example is available in the tutorials directory:; /// h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; /// which reimplement the selector found in h1analysis.C",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx:5345,load,loaded,5345,tree/treeplayer/src/TTreePlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx,2,['load'],['loaded']
Performance,"ypes. |; | GetColumnNames() | Get the names of all the available columns of the dataset. |; | GetColumnType() | Return the type of a given column as a string. |; | GetColumnTypeNamesList() | Return the list of type names of columns in the dataset. |; | GetDefinedColumnNames() | Get the names of all the defined columns. |; | GetFilterNames() | Return the names of all filters in the computation graph. |; | GetNRuns() | Return the number of event loops run by this RDataFrame instance so far. |; | GetNSlots() | Return the number of processing slots that RDataFrame will use during the event loop (i.e. the concurrency level). |; | SaveGraph() | Store the computation graph of an RDataFrame in [DOT format (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) for easy inspection. See the [relevant section](\ref representgraph) for details. |. \anchor introduction; ## Introduction; Users define their analysis as a sequence of operations to be performed on the dataframe object; the framework; takes care of the management of the loop over entries as well as low-level details such as I/O and parallelization.; RDataFrame provides methods to perform most common operations required by ROOT analyses;; at the same time, users can just as easily specify custom code that will be executed in the event loop. RDataFrame is built with a *modular* and *flexible* workflow in mind, summarised as follows:. 1. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, [CSV files](https://root.cern/doc/master/df014__CSVDataSource_8C.html), [SQLite files](https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C.html), [RNTuples](https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTuple.html), and it can be extended to custom data formats. From Python, [NumPy arrays can be imported into RDataFrame](https://root.cern/doc/master/df032__MakeNumpyDataFrame_8py.html) as well. 2. Transform the dataframe by:. - [Applying filt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:11467,perform,performed,11467,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['perform'],['performed']
Performance,"{.py}; LiveVisualize(plot_callback_dict, write_to_tfile); ~~~. \note The allowed operations to pass to LiveVisualize are:; - Histo1D(), Histo2D(), Histo3D(); - Graph(); - Profile1D(), Profile2D(). \warning The Live Visualization feature is only supported for the Dask backend. \anchor parallel-execution; ## Performance tips and parallel execution; As pointed out before in this document, RDataFrame can transparently perform multi-threaded event loops to speed up; the execution of its actions. Users have to call ROOT::EnableImplicitMT() *before* constructing the RDataFrame; object to indicate that it should take advantage of a pool of worker threads. **Each worker thread processes a distinct; subset of entries**, and their partial results are merged before returning the final values to the user.; There are no guarantees on the order in which threads will process the batches of entries.; In particular, note that this means that, for multi-thread event loops, there is no; guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; ~~~{.cpp}; ROOT::EnableImplicitMT(i); ~~~; replacing `i` with the number of CPUs/slots that were allocated for this job. ### Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them con",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:47707,multi-thread,multi-thread,47707,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['multi-thread'],['multi-thread']
Performance,"}; Text font code = 10*fontnumber + precision; ~~~; Font numbers must be between 1 and 14. The precision can be:. - `precision = 0` fast hardware fonts (steps in the size); - `precision = 1` scalable and rotatable hardware fonts (see below); - `precision = 2` scalable and rotatable hardware fonts; - `precision = 3` scalable and rotatable hardware fonts. Text size; is given in pixels. The text font and precision of any class inheriting from `TAttText` can; be changed using the method `SetTextFont` and retrieved using the; method `GetTextFont`. \anchor ATTTEXT51; ### Font quality and speed. When precision 0 is used, only the original non-scaled X11 system fonts are; used. The fonts have a minimum (4) and maximum (37) size in pixels. These; fonts are fast and are of good quality. Their size varies with large steps; and they cannot be rotated.; Precision 1 and 2 fonts have a different behaviour depending if the; True Type Fonts (TTF) are used or not. If TTF are used, you always get very good; quality scalable and rotatable fonts.; These days TTF fonts are rendered fast enough and can be used in all cases. \anchor ATTTEXT52; ### How to use True Type Fonts. TTF fonts are used by default. They can be deactivated via the following line; in the `.rootrc` file:. ~~~ {.cpp}; Unix.*.Root.UseTTFonts: false; ~~~. \anchor ATTTEXT53; ### List of the currently supported fonts. ~~~ {.cpp}; Font number TTF Names PostScript/PDF Names; 1 : ""Free Serif Italic"" ""Times-Italic""; 2 : ""Free Serif Bold"" ""Times-Bold""; 3 : ""Free Serif Bold Italic"" ""Times-BoldItalic""; 4 : ""Tex Gyre Regular"" ""Helvetica""; 5 : ""Tex Gyre Italic"" ""Helvetica-Oblique""; 6 : ""Tex Gyre Bold"" ""Helvetica-Bold""; 7 : ""Tex Gyre Bold Italic"" ""Helvetica-BoldOblique""; 8 : ""Free Mono"" ""Courier""; 9 : ""Free Mono Oblique"" ""Courier-Oblique""; 10 : ""Free Mono Bold"" ""Courier-Bold""; 11 : ""Free Mono Bold Oblique"" ""Courier-BoldOblique""; 12 : ""Symbol"" ""Symbol""; 13 : ""Free Serif"" ""Times-Roman""; 14 : ""Wingdings"" ""ZapfDingbats""; ~~~. The PostScri",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TAttText.cxx:5430,scalab,scalable,5430,core/base/src/TAttText.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TAttText.cxx,1,['scalab'],['scalable']
Performance,"~ {.cpp}; TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N);; ~~~. where SLICE is the name of the new family representing all slices and 1 is the; slicing axis. The meaning of the axis index is the following: for all volumes; having shapes like box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for; tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; In fact, the division operation has the same effect as positioning volumes; in a given order inside the divided container - the advantage being that the; navigation in such a structure is much faster. When a volume is divided, a; volume family corresponding to the slices is created. In case all slices can; be represented by a single shape, only one volume is added to the family and; positioned N times inside the divided volume, otherwise, each slice will be; represented by a distinct volume in the family.; Divisions can be also performed in a given range of one axis. For that, one; have to specify also the starting coordinate value and the step:. ~~~ {.cpp}; TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N, start, step);; ~~~. A check is always done on the resulting division range : if not fitting into; the container limits, an error message is posted. If we will browse the divided; volume we will notice that it will contain N nodes starting with index 1 upto; N. The first one has the lower X limit at START position, while the last one; will have the upper X limit at START+N*STEP. The resulting slices cannot; be positioned inside an other volume (they are by default positioned inside the; divided one) but can be further divided and may contain other volumes:. ~~~ {.cpp}; TGeoVolume *slicey = slicex->Divide(""SLICEY"", 2, N1);; slicey->AddNode(other_vol, index, some_matrix);; ~~~. When doing that, we have to remember that SLICEY represents a family, therefore; all members of the family will be divided on Y and the other ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoVolume.cxx:14812,perform,performed,14812,geom/geom/src/TGeoVolume.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoVolume.cxx,1,['perform'],['performed']
Safety," ( delta_ik*delta_lk - delta_ik*A_lj - delta_lk*A_ij; // + A_ij * A_lj ) * DB_kj / Norm_j^2 ]; //; // introduce normalized errors: Rsq_kj = DB_kj / Norm_j^2; // after summing over k:; // delta_ik*delta_lk*Rsq_kj -> delta_il*Rsq_ij; // delta_ik*A_lj*Rsq_kj -> A_lj*Rsq_ij; // delta_lk*A_ij*Rsq_kj -> A_ij*Rsq_lj; // A_ij*A_lj*Rsq_kj -> A_ij*A_lj*sum_k(Rsq_kj); //; // introduce sum of normalized errors squared: SRsq_j = sum_k(Rsq_kj); //; // Note: Rsq_ij is stored as fDAinRelSq (excludes extra indices of B); // and SRsq_j is stored as fDAinColRelSq (sum includes all indices of B); //; // Vxx_nm = sum_ijl [ (dX_m / dA_ij) * (dX_n / dA_lj); // (delta_il*Rsq_ij - A_lj*Rsq_ij - A_ij*Rsq_lj + A_ij*A_lj *SRsq_j) ]; //; // Vxx_nm = sum_j [ F_mj * F_nj * SRsq_j; // - sum_j [ G_mj * F_nj ]; // - sum_j [ F_mj * G_nj ]; // + sum_ij [ (dX_m / dA_ij) * (dX_n / dA_lj) * Rsq_ij ]; //; // where:; // F_mj = sum_i [ (dX_m / dA_ij) * A_ij ]; // G_mj = sum_i [ (dX_m / dA_ij) * Rsq_ij ]; //; // In order to avoid explicitly calculating the 3-dimensional tensor; // (dX_m/dA_ij) the sums are evaluated further, using; // dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j; //; // F_mj = M0_mj * (A# Z0)_j - (M1 A)_mj Z1_j; // G_mj = M0_mj * (Rsq# Z0)_j - (M1 Rsq)_mj Z1_j; //; // and; //; // sum_ij [ (dX_m/dA_ij) * (dX_n/dA_ij) * Rsq_ij ] =; // sum_j [ M0_mj * M0_nj * [ sum_i (Z0_i)^2 * Rsq_ij ] ]; // + sum_i [ M1_mi * M1_ni * [ sum_j (Z1_j)^2 * Rsq_ij ] ]; // - sum_i [ M1_mi * H_ni + M1_ni * H_mi]; // where:; // H_mi = Z0_i * sum_j [ M0_mj * Z1_j * Rsq_ij ]; //; // collect all contributions:; // Vxx_nm = r0 -r1 -r2 +r3 +r4 -r5 -r6; // r0 = sum_j [ F_mj * F_nj * SRsq_j ]; // r1 = sum_j [ G_mj * F_nj ]; // r2 = sum_j [ F_mj * G_nj ]; // r3 = sum_j [ M0_mj * M0_nj * [ sum_i (Z0_i)^2 * Rsq_ij ] ]; // r4 = sum_i [ M1_mi * M1_ni * [ sum_j (Z1_j)^2 * Rsq_ij ] ]; // r5 = sum_i [ M1_mi * H_ni ]; // r6 = sum_i [ M1_ni * H_mi ]; //======================================================; // calculate contributions co",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx:2230,avoid,avoid,2230,hist/unfold/src/TUnfoldSys.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx,1,['avoid'],['avoid']
Safety," * write to, error); *; * @param pipes set of pipes to check; * @param timeout timeout in milliseconds; * @returns positive number: number of pipes which have; * status changes, 0: timeout, or no pipes with; * status changed, -1 on error; *; * Timeout can be zero (check for specified events, and return), finite; * (wait at most timeout milliseconds before returning), or -1; * (infinite). The poll method returns when the timeout has elapsed,; * or if an event occurs on one of the pipes being polled, whichever; * happens earlier.; *; * Pipes is a vector of one or more PollEntries, which each list a pipe; * and events to poll for. If events is left empty (zero), all; * conditions are polled for, otherwise only the indicated ones. On; * return, the revents fields contain the events that occurred for each; * pipe; error Error, EndOfFile or Invalid events are always set,; * regardless of whether they were in the set of requested events.; *; * poll may block slightly longer than specified by timeout due to OS; * timer granularity and OS scheduling. Due to its implementation, the; * poll call can also return early if the remote end of the page sends; * a free page while polling (which is put on that pipe's freelist),; * while that pipe is polled for e.g Reading. The status of the pipe is; * indicated correctly in revents, and the caller can simply poll; * again. (The reason this is done this way is because it helps to; * replenish the pool of free pages and queue busy pages without; * blocking.); *; * Here's a piece of example code waiting on two pipes; if they become; * readable they are read:; * @code; * #include <unistd.h>; * #include <cstdlib>; * #include <string>; * #include <sstream>; * #include <iostream>; *; * #include ""BidirMMapPipe.h""; *; * // what to execute in the child; * int randomchild(BidirMMapPipe& pipe); * {; * ::srand48(::getpid());; * for (int i = 0; i < 5; ++i) {; * // sleep a random time between 0 and .9 seconds; * ::usleep(int(1e6 * ::drand48()));; * s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h:1072,timeout,timeout,1072,roofit/roofitcore/src/BidirMMapPipe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h,1,['timeout'],['timeout']
Safety," / n) << std::endl;; ~~~; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; thread will execute the expression concurrently.; The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; this is probably too much head-scratch for such a simple operation. ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; ~~~{.cpp}; // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; const unsigned int nSlots = df.GetNSlots();; std::vector<double> sumSqs(nSlots, 0.);; std::vector<unsigned int> ns(nSlots, 0);. df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares; unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; Notice how we created one `double` variable for each processing slot and later merged their results via `std::accumulate`. \anchor friends; ### Dataset joins with friend trees. Vertically concatenating multiple trees that have the same columns (creating a logical dataset with the same columns and; more rows) is trivial in RDataFrame: just pass the tree name and a list of file names to RDataFrame's constructor, or create a TChain; out of the desired trees and pass that to RDataFrame. Horizon",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:70820,safe,safe,70820,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['safe'],['safe']
Safety," // +-------------+ +----+ | |; // | | | |; // V V | |; // +-------------+ | |; // | AND | | |; // +-------------+ | |; // | | |; // +-----+ | |; // | | |; // V V V; // +-------------+; // | CMP |; // +-------------+; //; // The AND node may be safely removed for some combinations of inputs. In; // particular we need to take into account the extension type of the Input,; // the exact values of AddConstant, CompConstant, and CC, along with the nominal; // width of the input (this can work for any width inputs, the above graph is; // specific to 8 bits.; //; // The specific equations were worked out by generating output tables for each; // AArch64CC value in terms of and AddConstant (w1), CompConstant(w2). The; // problem was simplified by working with 4 bit inputs, which means we only; // needed to reason about 24 distinct bit patterns: 8 patterns unique to zero; // extension (8,15), 8 patterns unique to sign extensions (-8,-1), and 8; // patterns present in both extensions (0,7). For every distinct set of; // AddConstant and CompConstants bit patterns we can consider the masked and; // unmasked versions to be equivalent if the result of this function is true for; // all 16 distinct bit patterns of for the current extension type of Input (w0).; //; // sub w8, w0, w1; // and w10, w8, #0x0f; // cmp w8, w2; // cset w9, AArch64CC; // cmp w10, w2; // cset w11, AArch64CC; // cmp w9, w11; // cset w0, eq; // ret; //; // Since the above function shows when the outputs are equivalent it defines; // when it is safe to remove the AND. Unfortunately it only runs on AArch64 and; // would be expensive to run during compiles. The equations below were written; // in a test harness that confirmed they gave equivalent outputs to the above; // for all inputs function, so they can be used determine if the removal is; // legal instead.; //; // isEquivalentMaskless() is the code for testing if the AND can be removed; // factored out of the DAG recognition as the DAG can take several forms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:1981,safe,safe,1981,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['safe'],['safe']
Safety," 9 | maximal compression level but slower and might use more memory.; /// (For the currently supported algorithms, the maximum level is 9); /// If compress is negative it indicates the compression level is not set yet.; /// The enumeration ROOT::RCompressionSetting::EAlgorithm associates each; /// algorithm with a number. There is a utility function to help; /// to set the value of compress. For example,; /// ROOT::CompressionSettings(ROOT::kLZMA, 1); /// will build an integer which will set the compression to use; /// the LZMA algorithm and compression level 1. These are defined; /// in the header file <em>Compression.h</em>.; /// Note that the compression settings may be changed at any time.; /// The new compression settings will only apply to branches created; /// or attached after the setting is changed and other objects written; /// after the setting is changed.; /// In case the file does not exist or is not a valid ROOT file,; /// it is made a Zombie. One can detect this situation with a code like:; /// ~~~{.cpp}; /// TFile f(""file.root"");; /// if (f.IsZombie()) {; /// std::cout << ""Error opening file"" << std::endl;; /// exit(-1);; /// }; /// ~~~; /// If you open a file instead with TFile::Open(""file.root"") use rather; /// the following code as a nullptr is returned.; /// ~~~{.cpp}; /// TFile* f = TFile::Open(""file.root"");; /// if (!f) {; /// std::cout << ""Error opening file"" << std::endl;; /// exit(-1);; /// }; /// ~~~; /// When opening the file, the system checks the validity of this directory.; /// If something wrong is detected, an automatic Recovery is performed. In; /// this case, the file is scanned sequentially reading all logical blocks; /// and attempting to rebuild a correct directory (see TFile::Recover).; /// One can disable the automatic recovery procedure when reading one; /// or more files by setting the environment variable ""TFile.Recover: 0""; /// in the system.rootrc file.; ///; /// A bit `TFile::kReproducible` can be enabled specifying; /// t",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:4583,detect,detect,4583,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['detect'],['detect']
Safety," = 0;; df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; thread will execute the expression concurrently.; The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; this is probably too much head-scratch for such a simple operation. ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; ~~~{.cpp}; // Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; ROOT::EnableImplicitMT();; const unsigned int nSlots = df.GetNSlots();; std::vector<double> sumSqs(nSlots, 0.);; std::vector<unsigned int> ns(nSlots, 0);. df.ForeachSlot([&sumSqs, &ns](unsigned int slot, double x) { sumSqs[slot] += x*x; ns[slot] += 1; }, {""x""});; double sumSq = std::accumulate(sumSqs.begin(), sumSqs.end(), 0.); // sum all squares; unsigned int n = std::accumulate(ns.begin(), ns.end(), 0); // sum all counts; std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; ~~~; Notice how we created one `double` variable for each processing slot and later merged their results via `std::accumulate`. \anchor friends; ### Dataset joins with friend trees. Vertically concatenating multiple trees that have the same columns (creating a logical dataset with the same columns and; more rows) is trivial in RDataFrame: just pass the tree name and a list of file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:70761,safe,safe,70761,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['safe'],['safe']
Safety," = null;; bool _call_try_exit = true;. objc_exception_try_enter(&d);; if (!setjmp(d.jmp_buf)) {; ... try body ...; } else {; // exception path; id _caught = objc_exception_extract(&d);. // enter new try scope for handlers; if (!setjmp(d.jmp_buf)) {; ... match exception and execute catch blocks ... // fell off end, rethrow.; _rethrow = _caught;; ... jump-through-finally to finally_rethrow ...; } else {; // exception in catch block; _rethrow = objc_exception_extract(&d);; _call_try_exit = false;; ... jump-through-finally to finally_rethrow ...; }; }; ... jump-through-finally to finally_end ... finally:; if (_call_try_exit); objc_exception_try_exit(&d);. ... finally block ....; ... dispatch to finally destination ... finally_rethrow:; objc_exception_throw(_rethrow);. finally_end:; }. This framework differs slightly from the one gcc uses, in that gcc; uses _rethrow to determine if objc_exception_try_exit should be called; and if the object should be rethrown. This breaks in the face of; throwing nil and introduces unnecessary branches. We specialize this framework for a few particular circumstances:. - If there are no catch blocks, then we avoid emitting the second; exception handling context. - If there is a catch-all catch block (i.e. @catch(...) or @catch(id; e)) we avoid emitting the code to rethrow an uncaught exception. - FIXME: If there is no @finally block we can do a few more; simplifications. Rethrows and Jumps-Through-Finally; --. '@throw;' is supported by pushing the currently-caught exception; onto ObjCEHStack while the @catch blocks are emitted. Branches through the @finally block are handled with an ordinary; normal cleanup. We do not register an EH cleanup; fragile-ABI ObjC; exceptions are not compatible with C++ exceptions, and this is; hardly the only place where this will go wrong. @synchronized(expr) { stmt; } is emitted as if it were:; id synch_value = expr;; objc_sync_enter(synch_value);; @try { stmt; } @finally { objc_sync_exit(synch_value); }; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:2659,avoid,avoid,2659,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,2,['avoid'],['avoid']
Safety," A ""std::vector""-like collection of values implementing handy operation to analyse them; \tparam T The type of the contained objects. A RVec is a container designed to make analysis of values' collections fast and easy.; Its storage is contiguous in memory and its interface is designed such to resemble to the one; of the stl vector. In addition the interface features methods and; [external functions](https://root.cern/doc/master/namespaceROOT_1_1VecOps.html) to ease the manipulation and analysis; of the data in the RVec. \note ROOT::VecOps::RVec can also be spelled simply ROOT::RVec. Shorthand aliases such as ROOT::RVecI or ROOT::RVecD; are also available as template instantiations of RVec of fundamental types. The full list of available aliases:; - RVecB (`bool`); - RVecC (`char`); - RVecD (`double`); - RVecF (`float`); - RVecI (`int`); - RVecL (`long`); - RVecLL (`long long`); - RVecU (`unsigned`); - RVecUL (`unsigned long`); - RVecULL (`unsigned long long`). \note RVec does not attempt to be exception safe. Exceptions thrown by element constructors during insertions, swaps or; other operations will be propagated potentially leaving the RVec object in an invalid state. \note RVec methods (e.g. `at` or `size`) follow the STL naming convention instead of the ROOT naming convention in order; to make RVec a drop-in replacement for `std::vector`. \htmlonly; <a href=""https://doi.org/10.5281/zenodo.1253756""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.1253756.svg"" alt=""DOI""></a>; \endhtmlonly. ## Table of Contents; - [Example](\ref example); - [Arithmetic operations, logical operations and mathematical functions](\ref operationsandfunctions); - [Owning and adopting memory](\ref owningandadoptingmemory); - [Sorting and manipulation of indices](\ref sorting); - [Usage in combination with RDataFrame](\ref usagetdataframe); - [Reference for the RVec class](\ref RVecdoxyref); - [Reference for RVec helper functions](https://root.cern/doc/master/namespaceROOT_1_1VecOps",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:1079,safe,safe,1079,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['safe'],['safe']
Safety," A program has excellent documentation that ANYONE can read.; 2) A program when released has no strange ""features"" or bugs.; 3) A program is robust and handles ALL extreme and unusual cases.; 4) A program is written in phases and modules with hard tests for each one.; 5) A program is written for any user who doesn't need special knowledge; to use the program.; 6) A program has well defined user requirements and functional specifications.; 7) A program is written with regard to future expansion and integreation; with other systems (portability). When programming following these additional principles make programs easier; to maintain. A) Choose variable names that accurately describes what the variable does/is.; B) Write comments to inform someone faced with the task of modifying your code.; C) Avoid excessive comments. Write the code so that it says what it does.; D) Follow a strict one-in, one-out flow of control structues except in the; case of fatal error conditions.; E) Avoid using global variables.; F) Do not cause side effects to variables that were not parameters to a; function.; G) Have a single function perform a single purpose.; H) Select a single indentation style and stick with it.; I) Use a consistent naming convention. The following principles help me when I try optimizing code:. a) If optimizing, use a profiler to determine which sections of code most of; the time is spent in. Spend most of your effort in the most used sections.; Don't bother optimizing a procedure using less than 10% of the time. b) High level optimizations are far more effective than cycle shaving.; (e.g. use quick sort instead of optimizing a bubble sort.). c) Be flexible in your approach to solving a problem. List exactly what you; need as a result at a minimum. Get rid of unnecessary assumptions. d) Become familiar with sets of operations that are equivalent, or nearly so.; Learn the relative expense of basic operations. e) If possible, be careful not to needlessly sacrifice signi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/x3d.c:2461,Avoid,Avoid,2461,graf3d/x3d/src/x3d.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/x3d/src/x3d.c,1,['Avoid'],['Avoid']
Safety," ARM |; /// +-------------------------+--------+-----+; /// | Call overhead in Bytes | 4 | 4 |; /// | Frame overhead in Bytes | 0 | 0 |; /// | Stack fixup required | No | No |; /// +-------------------------+--------+-----+; ///; /// \p MachineOutlinerNoLRSave implies that the function should be called using; /// a BL instruction, but doesn't require LR to be saved and restored. This; /// happens when LR is known to be dead.; ///; /// That is,; ///; /// I1 OUTLINED_FUNCTION:; /// I2 --> BL OUTLINED_FUNCTION I1; /// I3 I2; /// I3; /// BX LR; ///; /// +-------------------------+--------+-----+; /// | | Thumb2 | ARM |; /// +-------------------------+--------+-----+; /// | Call overhead in Bytes | 4 | 4 |; /// | Frame overhead in Bytes | 2 | 4 |; /// | Stack fixup required | No | No |; /// +-------------------------+--------+-----+; ///; /// \p MachineOutlinerRegSave implies that the function should be called with a; /// save and restore of LR to an available register. This allows us to avoid; /// stack fixups. Note that this outlining variant is compatible with the; /// NoLRSave case.; ///; /// That is,; ///; /// I1 Save LR OUTLINED_FUNCTION:; /// I2 --> BL OUTLINED_FUNCTION I1; /// I3 Restore LR I2; /// I3; /// BX LR; ///; /// +-------------------------+--------+-----+; /// | | Thumb2 | ARM |; /// +-------------------------+--------+-----+; /// | Call overhead in Bytes | 8 | 12 |; /// | Frame overhead in Bytes | 2 | 4 |; /// | Stack fixup required | No | No |; /// +-------------------------+--------+-----+; ///; /// \p MachineOutlinerDefault implies that the function should be called with; /// a save and restore of LR to the stack.; ///; /// That is,; ///; /// I1 Save LR OUTLINED_FUNCTION:; /// I2 --> BL OUTLINED_FUNCTION I1; /// I3 Restore LR I2; /// I3; /// BX LR; ///; /// +-------------------------+--------+-----+; /// | | Thumb2 | ARM |; /// +-------------------------+--------+-----+; /// | Call overhead in Bytes | 8 | 12 |; /// | Frame overhead in Bytes | 2 | 4 |;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:2188,avoid,avoid,2188,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['avoid'],['avoid']
Safety," Adler-32 checksum of the dictionary; chosen by the compressor and returns Z_NEED_DICT; otherwise it sets; strm->adler to the Adler-32 checksum of all output produced so far (that is,; total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described; below. At the end of the stream, inflate() checks that its computed adler32; checksum is equal to that saved by the compressor and returns Z_STREAM_END; only if the checksum is correct. inflate() can decompress and check either zlib-wrapped or gzip-wrapped; deflate data. The header type is detected automatically, if requested when; initializing with inflateInit2(). Any information contained in the gzip; header is not retained, so applications that need that information should; instead use raw inflate, see inflateInit2() below, or inflateBack() and; perform their own processing of the gzip header and trailer. When processing; gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output; producted so far. The CRC-32 is checked against the gzip trailer. inflate() returns Z_OK if some progress has been made (more input processed; or more output produced), Z_STREAM_END if the end of the compressed data has; been reached and all uncompressed output has been produced, Z_NEED_DICT if a; preset dictionary is needed at this point, Z_DATA_ERROR if the input data was; corrupted (input stream not conforming to the zlib format or incorrect check; value), Z_STREAM_ERROR if the stream structure was inconsistent (for example; next_in or next_out was Z_NULL), Z_MEM_ERROR if there was not enough memory,; Z_BUF_ERROR if no progress is possible or if there was not enough room in the; output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and; inflate() can be called again with more input and more output space to; continue decompressing. If Z_DATA_ERROR is returned, the application may; then call inflateSync() to look for a good compression block if a partial; recovery of the data is desired.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:6932,recover,recovery,6932,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['recover'],['recovery']
Safety," At the same time there are 4 different quality levels of output; * implemented. They differ in the way special technics, like error; * diffusion and interpolation are applyed, and allow for fine grained; * selection of quality/speed ratio. ASIMAGE_QUALITY_GOOD should be good; * enough for most applications.; * The following additional output features are implemented :; * 1) Filling of the missing channels with supplied values.; * 2) Error diffusion to improve quality while converting from internal; * 	 24.8 format to 8 bit format.; * 3) Tiling of the output. If tiling_step is greater then 0, then each; * 	 scanlines will be copied into lines found tiling_step one from; * 	 another, upto the edge of the image.; * 4) Reverse order of output. Output image will be mirrored along y; * 	 axis if bottom_to_top is set to True.; * NOTES; * The output_image_scanline method should be called for each scanline; * to be stored. Convenience functions listed below should be used to; * safely alter state of the output instead of direct manipulation of; * the data members. (makes you pity you don't write in C++ doesn't it ?); *; * Also There is a trick in the way how output_image_scanline handles; * empty scanlines while writing ASImage. If back_color of empty scanline; * matches back_color of ASImageOutput - then particular line is erased!; * If back_colors are same - then particular line of ASImage gets filled; * with the back_color of ASScanline. First approach is usefull when; * resulting image will be used in subsequent call to merge_layers - in; * such case knowing back_color of image is good enough and we don't need; * to store lines with the same color. In case where ASImage will be; * converted into Pixmap/XImage - second approach is preferable, since; * that conversion does not take into consideration image's back color -; * we may want to change it in the future.; *; * SEE ALSO; * start_image_output(); * set_image_output_back_color(); * toggle_image_output_direction(); * ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/imencdec.h:1455,safe,safely,1455,graf2d/asimage/src/libAfterImage/imencdec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/imencdec.h,1,['safe'],['safely']
Safety," Developed by The ROOT Team, CERN and Fermilab""; !define DESCRIPTION ""Interactive C++ interpreter""; !define INSTALLER_NAME ""%s""; !define MAIN_APP_EXE ""cling.exe""; !define INSTALL_TYPE ""SetShellVarContext current""; !define PRODUCT_ROOT_KEY ""HKLM""; !define PRODUCT_KEY ""Software\\Cling"". ###############################################################################. VIProductVersion ""%s.0.0""; VIAddVersionKey ""ProductName"" ""${APP_NAME}""; VIAddVersionKey ""CompanyName"" ""${COMP_NAME}""; VIAddVersionKey ""LegalCopyright"" ""${COPYRIGHT}""; VIAddVersionKey ""FileDescription"" ""${DESCRIPTION}""; VIAddVersionKey ""FileVersion"" ""${VERSION}"". ###############################################################################. SetCompressor /SOLID Lzma; Name ""${APP_NAME}""; Caption ""${APP_NAME}""; OutFile ""${INSTALLER_NAME}""; BrandingText ""${APP_NAME}""; XPStyle on; InstallDir ""C:\\Cling\\cling-${VERSION}"". ###############################################################################; ; MUI settings; !include ""MUI.nsh"". !define MUI_ABORTWARNING; !define MUI_UNABORTWARNING; !define MUI_HEADERIMAGE. ; Theme; !define MUI_ICON ""%s\\LLVM.ico""; !define MUI_UNICON ""%s\\Contrib\\Graphics\\Icons\\orange-uninstall.ico"". !insertmacro MUI_PAGE_WELCOME. !define MUI_LICENSEPAGE_TEXT_BOTTOM ""The source code for Cling is freely redistributable under the terms of the GNU Lesser General Public License (LGPL) as published by the Free Software Foundation.""; !define MUI_LICENSEPAGE_BUTTON ""Next >""; !insertmacro MUI_PAGE_LICENSE ""%s"". !insertmacro MUI_PAGE_DIRECTORY. !insertmacro MUI_PAGE_INSTFILES. !define MUI_FINISHPAGE_RUN ""$INSTDIR\\bin\\${MAIN_APP_EXE}""; !insertmacro MUI_PAGE_FINISH. !insertmacro MUI_UNPAGE_CONFIRM. !insertmacro MUI_UNPAGE_INSTFILES. !insertmacro MUI_UNPAGE_FINISH. !insertmacro MUI_LANGUAGE ""English"". ###############################################################################. Function .onInit; Call DetectWinVer; Call CheckPrevVersion; FunctionEnd. ; file section; Section ""MainFiles""; '''",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/cpt.py:2116,Detect,DetectWinVer,2116,interpreter/cling/tools/packaging/cpt.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/cpt.py,1,['Detect'],['DetectWinVer']
Safety," E Brotzman; * MR = Martin Reinecke; * WDP = William D Pence; * -- Kevin McCarty, for Debian (19 Dec. 2005) */; /*******; Modifications:; Oct 1997: Changed symbol name extname to appendus (PDW/HSTX); (Conflicted with a common variable name in FTOOLS); Nov 1997: If g77Fortran defined, also define f2cFortran (PDW/HSTX); Feb 1998: Let VMS see the NUM_ELEMS code. Lets programs treat; single strings as vectors with single elements; Nov 1999: If macintoxh defined, also define f2cfortran (for Mac OS-X); Apr 2000: If WIN32 defined, also define PowerStationFortran and; VISUAL_CPLUSPLUS (Visual C++); Jun 2000: If __GNUC__ and linux defined, also define f2cFortran; (linux/gcc environment detection); Apr 2002: If __CYGWIN__ is defined, also define f2cFortran; Nov 2002: If __APPLE__ defined, also define f2cfortran (for Mac OS-X). Nov 2003: If __INTEL_COMPILER or INTEL_COMPILER defined, also define; f2cFortran (KMCCARTY); Dec 2005: If f2cFortran is defined, enforce REAL functions in FORTRAN; returning ""double"" in C. This was one of the items on; Burkhard's TODO list. (KMCCARTY); Dec 2005: Modifications to support 8-byte integers. (MR); USE AT YOUR OWN RISK!; Feb 2006 Added logic to typedef the symbol 'LONGLONG' to an appropriate; intrinsic 8-byte integer datatype (WDP); Apr 2006: Modifications to support gfortran (and g77 with -fno-f2c flag); since by default it returns ""float"" for FORTRAN REAL function.; (KMCCARTY); May 2008: Revert commenting out of ""extern"" in COMMON_BLOCK_DEF macro.; Add braces around do-nothing "";"" in 3 empty while blocks to; get rid of compiler warnings. Thanks to ROOT developers; Jacek Holeczek and Rene Brun for these suggestions. (KMCCARTY); *******/; /*; Avoid symbols already used by compilers and system *.h:; __ - OSF1 zukal06 V3.0 347 alpha, cc -c -std1 cfortest.c. */; /*; Determine what 8-byte integer data type is available.; 'long long' is now supported by most compilers, but older; MS Visual C++ compilers before V7.0 use '__int64' instead. (WDP); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/cfortran.h:1576,RISK,RISK,1576,montecarlo/eg/inc/cfortran.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/cfortran.h,2,"['Avoid', 'RISK']","['Avoid', 'RISK']"
Safety," Gailly de-complicatified Mark's c[*p++]++ thing.; c14e 8 Oct 93 G. Roelofs changed memset() to memzero().; c14f 22 Oct 93 G. Roelofs renamed quietflg to qflag; made Trace(); conditional; added inflate_free().; c14g 28 Oct 93 G. Roelofs changed l/(lx+1) macro to pointer (Cray bug); c14h 7 Dec 93 C. Ghisler huft_build() optimizations.; c14i 9 Jan 94 A. Verheijen set fixed_t{d,l} to NULL after freeing;; G. Roelofs check NEXTBYTE macro for EOF.; c14j 23 Jan 94 G. Roelofs removed Ghisler ""optimizations""; ifdef'd; EOF check.; c14k 27 Feb 94 G. Roelofs added some typecasts to avoid warnings.; c14l 9 Apr 94 G. Roelofs fixed split comments on preprocessor lines; to avoid bug in Encore compiler.; c14m 7 Jul 94 P. Kienitz modified to allow assembler version of; inflate_codes() (define ASM_INFLATECODES); c14n 22 Jul 94 G. Roelofs changed fprintf to FPRINTF for DLL versions; c14o 23 Aug 94 C. Spieler added a newline to a debug statement;; G. Roelofs added another typecast to avoid MSC warning; */; /*; Inflate deflated (PKZIP's method 8 compressed) data. The compression; method searches for as much of the current string of bytes (up to a; length of 258) in the previous 32K bytes. If it doesn't find any; matches (of at least length 3), it codes the next byte. Otherwise, it; codes the length of the matched string and its distance backwards from; the current position. There is a single Huffman code that codes both; single bytes (called ""literals"") and match lengths. A second Huffman; code codes the distance information, which follows a length code. Each; length or distance code actually represents a base value and a number; of ""extra"" (sometimes zero) bits to get to add to the base value. At; the end of each deflated block is a special end-of-block (EOB) literal/; length code. The decoding process is basically: get a literal/length; code; if EOB then done; if a literal, emit the decoded byte; if a; length then get the distance and emit the referred-to bytes from the; sliding window",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZInflate.c:3789,avoid,avoid,3789,core/zip/src/ZInflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZInflate.c,1,['avoid'],['avoid']
Safety," ID of the dispatch; /// packet being executed.; ///; /// Flat Scratch Init (enable_sgpr_flat_scratch_init):; /// Number of User SGPR registers: 2. This is 2 SGPRs.; ///; /// For CI/VI:; /// The first SGPR is a 32 bit byte offset from SH_MEM_HIDDEN_PRIVATE_BASE; /// to base of memory for scratch for this dispatch. This is the same offset; /// used in computing the Scratch Segment Buffer base address. The value of; /// Scratch Wave Offset must be added by the kernel code and moved to; /// SGPRn-4 for use as the FLAT SCRATCH BASE in flat memory instructions.; ///; /// The second SGPR is 32 bit byte size of a single work-item's scratch; /// memory usage. This is directly loaded from the dispatch packet Private; /// Segment Byte Size and rounded up to a multiple of DWORD.; ///; /// \todo [Does CP need to round this to >4 byte alignment?]; ///; /// The kernel code must move to SGPRn-3 for use as the FLAT SCRATCH SIZE in; /// flat memory instructions. Having CP load it once avoids loading it at; /// the beginning of every wavefront.; ///; /// For PI:; /// This is the 64 bit base address of the scratch backing memory for; /// allocated by CP for this dispatch.; ///; /// Private Segment Size (enable_sgpr_private_segment_size):; /// Number of User SGPR registers: 1. The 32 bit byte size of a single; /// work-item's scratch memory allocation. This is the value from the dispatch; /// packet. Private Segment Byte Size rounded up by CP to a multiple of DWORD.; ///; /// \todo [Does CP need to round this to >4 byte alignment?]; ///; /// Having CP load it once avoids loading it at the beginning of every; /// wavefront.; ///; /// \todo [This will not be used for CI/VI since it is the same value as; /// the second SGPR of Flat Scratch Init. However, it is need for PI which; /// changes meaning of Flat Scratchg Init..]; ///; /// Grid Work-Group Count X (enable_sgpr_grid_workgroup_count_x):; /// Number of User SGPR registers: 1. 32 bit count of the number of; /// work-groups in the X di",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:4367,avoid,avoids,4367,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,1,['avoid'],['avoids']
Safety," This pass tries to remove unnecessary VGPR live ranges in divergent if-else; /// structures and waterfall loops.; ///; /// When we do structurization, we usually transform an if-else into two; /// successive if-then (with a flow block to do predicate inversion). Consider a; /// simple case after structurization: A divergent value %a was defined before; /// if-else and used in both THEN (use in THEN is optional) and ELSE part:; /// bb.if:; /// %a = ...; /// ...; /// bb.then:; /// ... = op %a; /// ... // %a can be dead here; /// bb.flow:; /// ...; /// bb.else:; /// ... = %a; /// ...; /// bb.endif; ///; /// As register allocator has no idea of the thread-control-flow, it will just; /// assume %a would be alive in the whole range of bb.then because of a later; /// use in bb.else. On AMDGPU architecture, the VGPR is accessed with respect; /// to exec mask. For this if-else case, the lanes active in bb.then will be; /// inactive in bb.else, and vice-versa. So we are safe to say that %a was dead; /// after the last use in bb.then until the end of the block. The reason is; /// the instructions in bb.then will only overwrite lanes that will never be; /// accessed in bb.else.; ///; /// This pass aims to tell register allocator that %a is in-fact dead,; /// through inserting a phi-node in bb.flow saying that %a is undef when coming; /// from bb.then, and then replace the uses in the bb.else with the result of; /// newly inserted phi.; ///; /// Two key conditions must be met to ensure correctness:; /// 1.) The def-point should be in the same loop-level as if-else-endif to make; /// sure the second loop iteration still get correct data.; /// 2.) There should be no further uses after the IF-ELSE region.; ///; ///; /// Waterfall loops get inserted around instructions that use divergent values; /// but can only be executed with a uniform value. For example an indirect call; /// to a divergent address:; /// bb.start:; /// %a = ...; /// %fun = ...; /// ...; /// bb.loop:; /// call %f",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp:1369,safe,safe,1369,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp,1,['safe'],['safe']
Safety," Version 17.2, initial version, numbered in parallel to TUnfold; /** \class TUnfoldBinningXML; XML interfate to binning schemes, for use with the unfolding algorithm; TUnfoldDensity. Binning schemes are used to map analysis bins on a single histogram; axis and back. The analysis bins may include unconnected bins (e.g; nuisances for background normalisation) or various multidimensional; histograms (signal bins, differential background normalisation bins, etc).; <br/>; If you use this software, please consider the following citation; <br/>; <b>S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]</b>; <br/>; Detailed documentation and updates are available on; http://www.desy.de/~sschmitt. Please consult the documentation of the class TUnfoldBinning about how to use; binning schemes. This class provides methods to read and write binning; schemes in the XML language. There is also a method which writes out; a dtd file for validation.; <h3>Example XML code</h3>; The example below encodes two binning schemes, <em>detector</em> and; <em>generator</em>. The detecor scheme consists of a single,; three-dimensional distribution (pt,eta,discriminator). The generator; scheme consists of two two-dimensional distributions, signal and background.; <pre>; <?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>; <!DOCTYPE TUnfoldBinning SYSTEM ""tunfoldbinning.dtd"">; <TUnfoldBinning>; <BinningNode name=""detector"" firstbin=""1"" factor=""1"">; <BinningNode name=""detectordistribution"" firstbin=""1"" factor=""1"">; <Axis name=""pt"" lowEdge=""3.5"">; <Bin repeat=""3"" width=""0.5"" />; <Bin repeat=""3"" width=""1"" />; <Bin width=""2"" />; <Bin width=""3"" />; <Bin location=""overflow""/>; <Axis name=""eta"" lowEdge=""-3"">; <Bin repeat=""2"" width=""0.5"" />; <Bin width=""1"" />; <Bin repeat=""4"" width=""0.5"" />; <Bin width=""1"" />; <Bin repeat=""2"" width=""0.5"" />; <Axis name=""discriminator"" lowEdge=""0"">; <Bin width=""0.15"" />; <Bin repeat=""2"" width=""0.35"" />; <Bin width=""0.15"" />; </Axis>; </Axis>; </Axis>; </BinningNode>; </Bin",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldBinningXML.cxx:1456,detect,detector,1456,hist/unfold/src/TUnfoldBinningXML.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldBinningXML.cxx,1,['detect'],['detector']
Safety," a global exists independent of simultaneous execution of the same kernel; // - the address of the global may be different from different kernels as they; // do not alias, which permits only allocating variables they use; // - if the address is allowed to differ, functions need help to find it; //; // Uses from kernels are implemented here by grouping them in a per-kernel; // struct instance. This duplicates the variables, accurately modelling their; // aliasing properties relative to a single global representation. It also; // permits control over alignment via padding.; //; // Uses from functions are more complicated and the primary purpose of this; // IR pass. Several different lowering are chosen between to meet requirements; // to avoid allocating any LDS where it is not necessary, as that impacts; // occupancy and may fail the compilation, while not imposing overhead on a; // feature whose primary advantage over global memory is performance. The basic; // design goal is to avoid one kernel imposing overhead on another.; //; // Implementation.; //; // LDS variables with constant annotation or non-undef initializer are passed; // through unchanged for simplification or error diagnostics in later passes.; // Non-undef initializers are not yet implemented for LDS.; //; // LDS variables that are always allocated at the same address can be found; // by lookup at that address. Otherwise runtime information/cost is required.; //; // The simplest strategy possible is to group all LDS variables in a single; // struct and allocate that struct in every kernel such that the original; // variables are always at the same address. LDS is however a limited resource; // so this strategy is unusable in practice. It is not implemented here.; //; // Strategy | Precise allocation | Zero runtime cost | General purpose |; // --------+--------------------+-------------------+-----------------+; // Module | No | Yes | Yes |; // Table | Yes | No | Yes |; // Kernel | Yes | Yes | No |; // ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:2482,avoid,avoid,2482,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['avoid'],['avoid']
Safety," a second buffer is created to; /// hold the compressed buffer.; ///; /// - Reservation of the corresponding space in the file by looking; /// in the TFree list of free blocks of the file.; ///; /// - The buffer is written to the file.; ///; /// Bufsize can be given to force a given buffer size to write this object.; /// By default, the buffersize will be taken from the average buffer size; /// of all objects written to the current file so far.; ///; /// If a name is specified, it will be the name of the key.; /// If name is not given, the name of the key will be the name as returned; /// by GetName().; ///; /// The option can be a combination of: kSingleKey, kOverwrite or kWriteDelete; /// Using the kOverwrite option a previous key with the same name is; /// overwritten. The previous key is deleted before writing the new object.; /// Using the kWriteDelete option a previous key with the same name is; /// deleted only after the new object has been written. This option; /// is safer than kOverwrite but it is slower.; /// NOTE: Neither kOverwrite nor kWriteDelete reduces the size of a TFile--; /// the space is simply freed up to be overwritten; in the case of a TTree,; /// it is more complicated. If one opens a TTree, appends some entries,; /// then writes it out, the behaviour is effectively the same. If, however,; /// one creates a new TTree and writes it out in this way,; /// only the metadata is replaced, effectively making the old data invisible; /// without deleting it. TTree::Delete() can be used to mark all disk space; /// occupied by a TTree as free before overwriting its metadata this way.; /// The kSingleKey option is only used by TCollection::Write() to write; /// a container with a single key instead of each object in the container; /// with its own key.; ///; /// An object is read from the file into memory via TKey::Read() or; /// via TObject::Read().; ///; /// The function returns the total number of bytes written to the file.; /// It returns 0 if the o",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx:1610,safe,safer,1610,core/base/src/TObject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx,1,['safe'],['safer']
Safety," arbitrary 'detail' string. The resulting trace will include 'Total'; // entries summing the time spent for each name. Thus, it's best to choose; // names to be fairly generic, and rely on the detail field to capture; // everything else of interest.; //; // To avoid lifetime issues name and detail strings are copied into the event; // entries at their time of creation. Care should be taken to make string; // construction cheap to prevent 'Heisenperf' effects. In particular, the; // 'detail' argument may be a string-returning closure:; //; // \code; // int n;; // {; // TimeTraceScope scope(""my_event_name"",; // [n]() { return (Twine(""x="") + Twine(n)).str(); });; // ...my code...; // }; // \endcode; // The closure will not be called if tracing is disabled. Otherwise, the; // resulting string will be directly moved into the entry.; //; // The main process should begin with a timeTraceProfilerInitialize, and; // finish with timeTraceProfileWrite and timeTraceProfilerCleanup calls.; // Each new thread should begin with a timeTraceProfilerInitialize, and; // finish with a timeTraceProfilerFinishThread call.; //; // Timestamps come from std::chrono::stable_clock. Note that threads need; // not see the same time from that clock, and the resolution may not be; // the best available.; //; // Currently, there are a number of compatible viewers:; // - chrome://tracing is the original chromium trace viewer.; // - http://ui.perfetto.dev is the replacement for the above, under active; // development by Google as part of the 'Perfetto' project.; // - https://www.speedscope.app/ has also been reported as an option.; //; // Future work:; // - Support akin to LLVM_DEBUG for runtime enable/disable of named tracing; // families for non-debug builds which wish to support optional tracing.; // - Evaluate the detail closures at profile write time to avoid; // stringification costs interfering with tracing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TimeProfiler.h:2985,avoid,avoid,2985,interpreter/llvm-project/llvm/include/llvm/Support/TimeProfiler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TimeProfiler.h,1,['avoid'],['avoid']
Safety," argument to any call; /// or returned. Unrelocated pointer may be safely compared against another; /// unrelocated pointer or against a pointer exclusively derived from null.; /// Poisoned pointers are produced when we somehow derive pointer from relocated; /// and unrelocated pointers (e.g. phi, select). This pointers may be safely; /// used in a very limited number of situations. Currently the only way to use; /// it is comparison against constant exclusively derived from null. All; /// limitations arise due to their undefined state: this pointers should be; /// treated as relocated and unrelocated simultaneously.; /// Rules of deriving:; /// R + U = P - that's where the poisoned pointers come from; /// P + X = P; /// U + U = U; /// R + R = R; /// X + C = X; /// Where ""+"" - any operation that somehow derive pointer, U - unrelocated,; /// R - relocated and P - poisoned, C - constant, X - U or R or P or C or; /// nothing (in case when ""+"" is unary operation).; /// Deriving of pointers by itself is always safe.; /// NOTE: when we are making decision on the status of instruction's result:; /// a) for phi we need to check status of each input *at the end of; /// corresponding predecessor BB*.; /// b) for other instructions we need to check status of each input *at the; /// current point*.; ///; /// FIXME: This works fairly well except one case; /// bb1:; /// p = *some GC-ptr def*; /// p1 = gep p, offset; /// / |; /// / |; /// bb2: |; /// safepoint |; /// \ |; /// \ |; /// bb3:; /// p2 = phi [p, bb2] [p1, bb1]; /// p3 = phi [p, bb2] [p, bb1]; /// here p and p1 is unrelocated; /// p2 and p3 is poisoned (though they shouldn't be); ///; /// This leads to some weird results:; /// cmp eq p, p2 - illegal instruction (false-positive); /// cmp eq p1, p2 - illegal instruction (false-positive); /// cmp eq p, p3 - illegal instruction (false-positive); /// cmp eq p, p1 - ok; /// To fix this we need to introduce conception of generations and be able to; /// check if two values belo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:1381,safe,safe,1381,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['safe'],['safe']
Safety," as its; /// terminator. For example, if terminator stops at newline, the hunk; /// will consist of a line of data; if terminator stops at two; /// newlines, it can be used to read the head of an HTTP response.; /// Upon determining the boundary, the function returns the data (up to; /// the terminator) in hunk.; ///; /// In case of read error, -1 is returned. In case of having read some; /// data, but encountering EOF before seeing the terminator, the data; /// that has been read is returned, but it will (obviously) not contain the; /// terminator.; ///; /// The TERMINATOR function is called with three arguments: the; /// beginning of the data read so far, the beginning of the current; /// block of peeked-at data, and the length of the current block.; /// Depending on its needs, the function is free to choose whether to; /// analyze all data or just the newly arrived data. If TERMINATOR; /// returns 0, it means that the terminator has not been seen.; /// Otherwise it should return a pointer to the character immediately; /// following the terminator.; ///; /// The idea is to be able to read a line of input, or otherwise a hunk; /// of text, such as the head of an HTTP request, without crossing the; /// boundary, so that the next call to RecvRaw() etc. reads the data; /// after the hunk. To achieve that, this function does the following:; ///; /// 1. Peek at incoming data.; ///; /// 2. Determine whether the peeked data, along with the previously; /// read data, includes the terminator.; ///; /// 3a. If yes, read the data until the end of the terminator, and; /// exit.; ///; /// 3b. If no, read the peeked data and goto 1.; ///; /// The function is careful to assume as little as possible about the; /// implementation of peeking. For example, every peek is followed by; /// a read. If the read returns a different amount of data, the; /// process is retried until all data arrives safely.; ///; /// Reads at most one less than the number of characters specified by maxsize.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx:2121,safe,safely,2121,net/net/src/TWebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx,1,['safe'],['safely']
Safety," be forwarded to the hasher type:; /// * decltype(std::declval<HasherT &>().final()) final(); /// * decltype(std::declval<HasherT &>().result()) result(); ///; /// From a user point of view, the interface provides the following:; /// * `template<typename T> add(const T &Value)`; /// The `add` function implements hashing of various types.; /// * `template <typename ItT> void addRange(ItT First, ItT Last)`; /// The `addRange` function is designed to aid hashing a range of values.; /// It explicitly adds the size of the range in the hash.; /// * `template <typename ItT> void addRangeElements(ItT First, ItT Last)`; /// The `addRangeElements` function is also designed to aid hashing a range of; /// values. In contrast to `addRange`, it **ignores** the size of the range,; /// behaving as if elements were added one at a time with `add`.; ///; /// User-defined `struct` types can participate in this interface by providing; /// an `addHash` templated function. See the associated template specialization; /// for details.; ///; /// This interface does not impose requirements on the hasher; /// `update(ArrayRef<uint8_t> Data)` method. We want to avoid collisions for; /// variable-size types; for example for; /// ```; /// builder.add({1});; /// builder.add({2, 3});; /// ```; /// and; /// ```; /// builder.add({1, 2});; /// builder.add({3});; /// ```; /// . Thus, specializations of `add` and `addHash` for variable-size types must; /// not assume that the hasher type considers the size as part of the hash; they; /// must explicitly add the size to the hash. See for example specializations; /// for `ArrayRef` and `StringRef`.; ///; /// Additionally, since types are eventually forwarded to the hasher's; /// `void update(ArrayRef<uint8_t>)` method, endianness plays a role in the hash; /// computation (for example when computing `add((int)123)`).; /// Specifiying a non-`native` `Endianness` template parameter allows to compute; /// stable hash across platforms with different endianness.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h:1628,avoid,avoid,1628,interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,1,['avoid'],['avoid']
Safety," can; /// guarantee that anything that the user will do to an object of type A can; /// also be done to an object of type B. This is trivially true if the two; /// types are the same, or if B is a subclass of A. It becomes more complex; /// in cases where protocols are involved.; ///; /// Object types in Objective-C describe the minimum requirements for an; /// object, rather than providing a complete description of a type. For; /// example, if A is a subclass of B, then B* may refer to an instance of A.; /// The principle of substitutability means that we may use an instance of A; /// anywhere that we may use an instance of B - it will implement all of the; /// ivars of B and all of the methods of B.; ///; /// This substitutability is important when type checking methods, because; /// the implementation may have stricter type definitions than the interface.; /// The interface specifies minimum requirements, but the implementation may; /// have more accurate ones. For example, a method may privately accept; /// instances of B, but only publish that it accepts instances of A. Any; /// object passed to it will be type checked against B, and so will implicitly; /// by a valid A*. Similarly, a method may return a subclass of the class that; /// it is declared as returning.; ///; /// This is most important when considering subclassing. A method in a; /// subclass must accept any object as an argument that its superclass's; /// implementation accepts. It may, however, accept a more general type; /// without breaking substitutability (i.e. you can still use the subclass; /// anywhere that you can use the superclass, but not vice versa). The; /// converse requirement applies to return types: the return type for a; /// subclass method must be a valid object of the kind that the superclass; /// advertises, but it may be specified more accurately. This avoids the need; /// for explicit down-casting by callers.; ///; /// Note: This is a stricter requirement than for assignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:1948,avoid,avoids,1948,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['avoid'],['avoids']
Safety," e.g. a trigger fired. ### Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase; by at most a factor two in the case of cache miss.; Additionally, on the first miss of an event, we must iterate through all the; ""active branches"" for the miss cache and find the correct basket.; This can be potentially a CPU-expensive operation compared to, e.g., the; latency of a SSD. This is why the miss cache is currently disabled by default. \anchor examples; ## Example usages of TTreeCache. A few use cases are discussed below. A cache may be created with automatic; sizing when a TTree is used:. In some applications, e.g. central processing workflows of experiments, the list; of branches to read is known a priori. For these cases, the TTreeCache can be; instructed about the branches which will be read via explicit calls to the TTree; or TTreeCache interfaces.; In less streamlined applications such as analysis, predicting the branches which; will be read can be difficult. In such cases, ROOT I/O flags used branches; automatically when a branch buffer is read during the learning phase. In the examples below, portions of analysis code are shown.; The few statements involving the TreeCache are marked with `//<<<`. ### ROOT::RDataFrame and TTreeReader Examples. If you use RDataFrame or TTreeReader, the system will automatically cache the; best set of branches: no action is required by the user. ### TTree::Draw Example. The TreeCache is automatically used by TTree::Draw. The method knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also inferred automatically. ### TTree::Process and TSelectors Examples. The user must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case only a subset of the events is processed to avoid wasteful caching. #### ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:6366,predict,predicting,6366,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['predict'],['predicting']
Safety," estimate code size due to large alignment and; // inline assembly. Usually it causes larger computed branch offset.; // But sometimes it may also causes smaller computed branch offset; // than actual branch offset. If the offset is close to the limit of; // encoding, it may cause problem at run time.; // Following is a simplified example.; //; // actual estimated; // address address; // ...; // bne Far 100 10c; // .p2align 4; // Near: 110 110; // ...; // Far: 8108 8108; //; // Actual offset: 0x8108 - 0x100 = 0x8008; // Computed offset: 0x8108 - 0x10c = 0x7ffc; //; // This example also shows when we can get the largest gap between; // estimated offset and actual offset. If there is an aligned block; // ABB between branch and target, assume its alignment is <align>; // bits. Now consider the accumulated function size FSIZE till the end; // of previous block PBB. If the estimated FSIZE is multiple of; // 2^<align>, we don't need any padding for the estimated address of; // ABB. If actual FSIZE at the end of PBB is 4 bytes more than; // multiple of 2^<align>, then we need (2^<align> - 4) bytes of; // padding. It also means the actual branch offset is (2^<align> - 4); // larger than computed offset. Other actual FSIZE needs less padding; // bytes, so causes smaller gap between actual and computed offset.; //; // On the other hand, if the inline asm or large alignment occurs; // between the branch block and destination block, the estimated address; // can be <delta> larger than actual address. If padding bytes are; // needed for a later aligned block, the actual number of padding bytes; // is at most <delta> more than estimated padding bytes. So the actual; // aligned block address is less than or equal to the estimated aligned; // block address. So the actual branch offset is less than or equal to; // computed branch offset.; //; // The computed offset is at most ((1 << alignment) - 4) bytes smaller; // than actual offset. So we add this number to the offset for safety.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp:2011,safe,safety,2011,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp,1,['safe'],['safety']
Safety," every time a new TTree is; attached. - void TSelector::SlaveBegin(). Create e.g. histograms in this method.; This method is called (with or without PROOF) before looping on the; entries in the Tree. When using PROOF, this method is called on; each worker node. - void TSelector::Begin(). Mostly for backward compatibility; use; SlaveBegin() instead. Both methods are called before looping on the; entries in the Tree. When using PROOF, Begin() is called on the; client only. - bool TSelector::Notify(). This method is called at the first entry; of a new file in a chain. - bool TSelector::Process(Long64_t entry). This method is called; to process an entry. It is the user's responsibility to read; the corresponding entry in memory (may be just a partial read).; Once the entry is in memory one can apply a selection and if the; entry is selected histograms can be filled. Processing stops; when this function returns false. This function combines the; next two functions in one, avoiding to have to maintain state; in the class to communicate between these two functions.; See WARNING below about entry.; This method is used by PROOF. - bool TSelector::ProcessCut(Long64_t entry). This method is called; before processing entry. It is the user's responsibility to read; the corresponding entry in memory (may be just a partial read).; The function returns true if the entry must be processed,; false otherwise. This method is obsolete, use Process().; See WARNING below about entry. - void TSelector::ProcessFill(Long64_t entry). This method is called; for all selected entries. User fills histograms in this function.; This method is obsolete, use Process().; See WARNING below about entry. - void TSelector::SlaveTerminate(). This method is called at the end of; the loop on all PROOF worker nodes. In local mode this method is; called on the client too. - void TSelector::Terminate(). This method is called at the end of; the loop on all entries. When using PROOF Terminate() is call on; the cl",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:1633,avoid,avoiding,1633,tree/tree/src/TSelector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx,1,['avoid'],['avoiding']
Safety," exist, they are coded using one bit each (0 and 1).; 5. There is no way of sending zero distance codes--a dummy must be; sent if there are none. (History: a pre 2.0 version of PKZIP would; store blocks with no distance codes, but this was discovered to be; too harsh a criterion.) Valid only for 1.93a. 2.04c does allow; zero distance codes, which is sent as one code of zero bits in; length.; 6. There are up to 286 literal/length codes. Code 256 represents the; end-of-block. Note however that the static length tree defines; 288 codes just to fill out the Huffman codes. Codes 286 and 287; cannot be used though, since there is no length base or extra bits; defined for them. Similarily, there are up to 30 distance codes.; However, static trees define 32 codes (all 5 bits) to fill out the; Huffman codes, but the last two had better not show up in the data.; 7. Unzip can check dynamic Huffman blocks for complete code sets.; The exception is that a single code would not be complete (see #4).; 8. The five bits following the block type is really the number of; literal codes sent minus 257.; 9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits; (1+6+6). Therefore, to output three times the length, you output; three codes (1+1+1), whereas to output four times the same length,; you only need two codes (1+3). Hmm.; 10. In the tree reconstruction algorithm, Code = Code + Increment; only if BitLength(i) is not zero. (Pretty obvious.); 11. Correction: 4 Bits: # of Bit Length codes - 4 (4 - 19); 12. Note: length code 284 can represent 227-258, but length code 285; really is 258. The last length deserves its own, short code; since it gets used a lot in very redundant files. The length; 258 is special since 258 - 3 (the min match length) is 255.; 13. The literal/length and distance code bit lengths are read as a; single stream of lengths. It is possible (and advantageous) for; a repeat code (16, 17, or 18) to go across the boundary between; the two sets of lengths.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZInflate.c:8461,redund,redundant,8461,core/zip/src/ZInflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZInflate.c,1,['redund'],['redundant']
Safety," existing replacements. Callers must; /// explicitly check the Error returned, and the returned error can be; /// converted to a string message with `llvm::toString()`. This prevents users; /// from adding order-dependent replacements. To control the order in which; /// order-dependent replacements are applied, use merge({R}) with R referring; /// to the changed code after applying all existing replacements.; /// Two replacements A and B are considered order-independent if applying them; /// in either order produces the same result. Note that the range of the; /// replacement that is applied later still refers to the original code.; /// These include (but not restricted to) replacements that:; /// - don't overlap (being directly adjacent is fine) and; /// - are overlapping deletions.; /// - are insertions at the same offset and applying them in either order; /// has the same effect, i.e. X + Y = Y + X when inserting X and Y; /// respectively.; /// - are identical replacements, i.e. applying the same replacement twice; /// is equivalent to applying it once.; /// Examples:; /// 1. Replacement A(0, 0, ""a"") and B(0, 0, ""aa"") are order-independent since; /// applying them in either order gives replacement (0, 0, ""aaa"").; /// However, A(0, 0, ""a"") and B(0, 0, ""b"") are order-dependent since; /// applying A first gives (0, 0, ""ab"") while applying B first gives (B, A,; /// ""ba"").; /// 2. Replacement A(0, 2, ""123"") and B(0, 2, ""123"") are order-independent; /// since applying them in either order gives (0, 2, ""123"").; /// 3. Replacement A(0, 3, ""123"") and B(2, 3, ""321"") are order-independent; /// since either order gives (0, 5, ""12321"").; /// 4. Replacement A(0, 3, ""ab"") and B(0, 3, ""ab"") are order-independent since; /// applying the same replacement twice is equivalent to applying it once.; /// Replacements with offset UINT_MAX are special - we do not detect conflicts; /// for such replacements since users may add them intentionally as a special; /// category of replacements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:2279,detect,detect,2279,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,1,['detect'],['detect']
Safety," exposed by the reassociation.; //; // A motivating example:; //; // void foo(int a, int b) {; // bar(a + b);; // bar((a + 2) + b);; // }; //; // An ideal compiler should reassociate (a + 2) + b to (a + b) + 2 and simplify; // the above code to; //; // int t = a + b;; // bar(t);; // bar(t + 2);; //; // However, the Reassociate pass is unable to do that because it processes each; // instruction individually and believes (a + 2) + b is the best form according; // to its rank system.; //; // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites; // ((a + c) + b) + d into ((a + c) + d) + b.; //; // Finally, the above dominator-based algorithm may need to be run multiple; // iterations before emitting optimal code. One source of this need is that we; // only split an operand when it is used only once. The above algorithm can; // eliminate an instruction and decrease the usage count of its operands. As a; // result, an instruction that previously had multiple uses may become a; // single-use instru",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h:1496,redund,redundancy,1496,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h,2,['redund'],['redundancy']
Safety," file during the next TFile::Write command. Example: create a two-dimensional TEfficiency object with; - name = ""eff""; - title = ""my efficiency""; - axis titles: x, y and LaTeX-formatted epsilon as a label for Z axis; - 10 bins with constant bin width (= 1) along X axis starting at 0 (lower edge; from the first bin) up to 10 (upper edge of last bin); - 20 bins with constant bin width (= 0.5) along Y axis starting at -5 (lower; edge from the first bin) up to 5 (upper edge of last bin). TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;y;#epsilon"",10,0,10,20,-5,5);. If you already have two histograms filled with the number of passed and total; events, you will use the constructor TEfficiency(const TH1& passed,const TH1& total); to construct the TEfficiency object. The histograms ""passed"" and ""total"" have; to fulfill the conditions mentioned in TEfficiency::CheckConsistency, otherwise the construction will fail.; As the histograms already exist, the new TEfficiency is by default **not** attached; to the current directory to avoid duplication of data. If you want to store the; new object anyway, you can either write it directly by calling TObject::Write or attach it to a directory using TEfficiency::SetDirectory.; This also applies to TEfficiency objects created by the copy constructor TEfficiency::TEfficiency(const TEfficiency& rEff). \anchor EFF02a; ### Example 1. ~~~~~~~~~~~~~~~{.cpp}; TEfficiency* pEff = 0;; TFile* pFile = new TFile(""myfile.root"",""recreate"");. //h_pass and h_total are valid and consistent histograms; if(TEfficiency::CheckConsistency(h_pass,h_total)); {; pEff = new TEfficiency(h_pass,h_total);; // this will write the TEfficiency object to ""myfile.root""; // AND pEff will be attached to the current directory; pEff->Write();; }; ~~~~~~~~~~~~~~~. \anchor EFF02b; ### Example 2. ~~~~~~~~~~~~~~~{.cpp}; TEfficiency* pEff = 0;; TFile* pFile = new TFile(""myfile.root"",""recreate"");. //h_pass and h_total are valid and consistent histograms; if(TEfficiency:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:3884,avoid,avoid,3884,hist/hist/src/TEfficiency.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx,1,['avoid'],['avoid']
Safety," for future use; * gamma - gamma value to be used to correct image; * compression - compression level of the resulting ASImage; * ... - NULL terminated list of strings, representing; * arbitrary number of directories to be searched each.; * RETURN VALUE; * Pointer to ASImage structure holding image data on success.; * NULL on failure; * DESCRIPTION; * file2ASImage will attempt to interpret filename in the following way:; * 1)It will try to find file using unmodified filename in all the; * provided search paths.; * 2)It will attempt to append .gz and then .Z to the filename and; * find such file in all the provided search paths.; * 3)If filename ends with extension consisting of digits only - it will; * attempt to find file with this extension stripped off. On success; * this extension will be used to load subimage from the file with that; * number. Subimages are supported only for XCF, GIF, BMP, ICO and CUR; * files.; * After the file is found file2ASImage() attempts to detect file format,; * and if it is known it will load it into new ASImage structure.; * EXAMPLE; * asview.c: ASView.2; *********/; /****f* libAfterImage/import/get_asimage(); * NAME; * get_asimage() - increment reference counter if file is already loaded,; * or load image from file.; * SYNOPSIS; * ASImage *get_asimage( ASImageManager* imageman, const char *file,; * ASFlagType what, unsigned int compression );; * INPUTS; * imageman - pointer to valid ASVisual structure.; * file - root window ID for the destination screen.; * what - full image file's name with path.; * compression -; * RETURN VALUE; * Pointer to ASImage structure holding image data on success.; * NULL on failure; * DESCRIPTION; * get_asimage will attempt check with the ASImageManager's list of load; * images, and if image with requested filename already exists - it will; * increment its reference count and return its pointer.; * Otherwise it will call file2ASImage() to load image from file. It will; * use PATH and gamma values from th",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.h:1286,detect,detect,1286,graf2d/asimage/src/libAfterImage/import.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.h,1,['detect'],['detect']
Safety," in zlib.h; */; /*; * Change history:; *; * 1.2.beta0 24 Nov 2002; * - First version -- complete rewrite of inflate to simplify code, avoid; * creation of window when not needed, minimize use of window when it is; * needed, make inffast.c even faster, implement gzip decoding, and to; * improve code readability and style over the previous zlib inflate code; *; * 1.2.beta1 25 Nov 2002; * - Use pointers for available input and output checking in inffast.c; * - Remove input and output counters in inffast.c; * - Change inffast.c entry and loop from avail_in >= 7 to >= 6; * - Remove unnecessary second byte pull from length extra in inffast.c; * - Unroll direct copy to three copies per loop in inffast.c; *; * 1.2.beta2 4 Dec 2002; * - Change external routine names to reduce potential conflicts; * - Correct filename to inffixed.h for fixed tables in inflate.c; * - Make hbuf[] unsigned char to match parameter type in inflate.c; * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset); * to avoid negation problem on Alphas (64 bit) in inflate.c; *; * 1.2.beta3 22 Dec 2002; * - Add comments on state->bits assertion in inffast.c; * - Add comments on op field in inftrees.h; * - Fix bug in reuse of allocated window after inflateReset(); * - Remove bit fields--back to byte structure for speed; * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths; * - Change post-increments to pre-increments in inflate_fast(), PPC biased?; * - Add compile time option, POSTINC, to use post-increments instead (Intel?); * - Make MATCH copy in inflate() much faster for when inflate_fast() not used; * - Use local copies of stream next and avail values, as well as local bit; * buffer and bit count in inflate()--for speed when inflate_fast() not used; *; * 1.2.beta4 1 Jan 2003; * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings; * - Move a comment on output buffer sizes from inffast.c to inflate.c; * - Add comments in inffast.c to in",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c:1154,avoid,avoid,1154,builtins/zlib/inflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c,2,['avoid'],['avoid']
Safety," is transmitted binary (i.e. no; * formatting to strings like std::cout does). There are also overloads to; * support C-style zero terminated strings and std::string. In terms of; * performance, the former is to be preferred.; *; * If the caller needs to multiplex input and output to/from several pipes, the; * class provides the poll() method which allows to block until an event occurs; * on any of the polled pipes.; *; * After the BidirMMapPipe is closed, no further operations may be performed on; * that object, save for the destructor which may still be called.; *; * If the BidirMMapPipe has not properly been closed, the destructor will call; * close. However, the exit code of the child is lost in that case.; *; * Closing the object causes the mmapped memory to be unmapped and the two; * pipes to be closed. We also install an atexit handler in the process of; * creating BidirMMapPipes. This ensures that when the current process; * terminates, a SIGTERM signal is sent to the child processes created for all; * unclosed pipes to avoid leaving zombie processes in the OS's process table.; *; * BidirMMapPipe creation, closing and destruction are thread safe. If the; * BidirMMapPipe is used in more than one thread, the other operations have to; * be protected with a mutex (or something similar), though.; *; * End of file (other end closed its pipe, or died) is indicated with the eof(); * method, serious I/O errors set a flags (bad(), fail()), and also throw; * exceptions. For normal read/write operations, they can be suppressed (i.e.; * error reporting only using flags) with a constructor argument.; *; * Technicalities:; * - there is a pool of mmapped pages, half the pages are allocated to the; * parent process, half to the child; * - when one side has accumulated enough data (or a flush forces dirty pages; * out to the other end), it sends these pages to the other end by writing a; * byte containing the page number into the pipe; * - the other end (which has the pages mm",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h:2830,avoid,avoid,2830,roofit/roofitcore/src/BidirMMapPipe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h,1,['avoid'],['avoid']
Safety," is_winnt; is_winnt:; StrCpy $1 $0 1; StrCmp $1 4 is_error ; Aborting installation for Windows versions older than Windows 2000; StrCmp $0 ""5.0"" is_error ; Removing Windows 2000 as supported Windows version; StrCmp $0 ""5.1"" is_winnt_XP; StrCmp $0 ""5.2"" is_winnt_2003; StrCmp $0 ""6.0"" is_winnt_vista; StrCmp $0 ""6.1"" is_winnt_7; StrCmp $0 ""6.2"" is_winnt_8; StrCmp $1 6 is_winnt_8 ; Checking for future versions of Windows 8; Goto is_error. is_winnt_XP:; is_winnt_2003:; is_winnt_vista:; is_winnt_7:; is_winnt_8:; Goto done; is_error:; StrCpy $1 $0; ReadRegStr $0 HKLM ""SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"" ProductName; IfErrors 0 +4; ReadRegStr $0 HKLM ""SOFTWARE\\Microsoft\\Windows\\CurrentVersion"" Version; IfErrors 0 +2; StrCpy $0 ""Unknown""; MessageBox MB_ICONSTOP|MB_OK ""This version of Cling cannot be installed on this system. Cling is supported only on Windows NT systems. Current system: $0 (version: $1)""; Abort; done:; Pop $1; Pop $0; FunctionEnd. ; Function to check any previously installed version of Cling in the system; Function CheckPrevVersion; Push $0; Push $1; Push $2; IfFileExists ""$INSTDIR\\bin\\cling.exe"" 0 otherver; MessageBox MB_OK|MB_ICONSTOP ""Another Cling installation (with the same version) has been detected. Please uninstall it first.""; Abort; otherver:; StrCpy $0 0; StrCpy $2 """"; loop:; EnumRegKey $1 ${PRODUCT_ROOT_KEY} ""${PRODUCT_KEY}"" $0; StrCmp $1 """" loopend; IntOp $0 $0 + 1; StrCmp $2 """" 0 +2; StrCpy $2 ""$1""; StrCpy $2 ""$2, $1""; Goto loop; loopend:; ReadRegStr $1 ${PRODUCT_ROOT_KEY} ""${PRODUCT_KEY}"" ""Version""; IfErrors finalcheck; StrCmp $2 """" 0 +2; StrCpy $2 ""$1""; StrCpy $2 ""$2, $1""; finalcheck:; StrCmp $2 """" done; MessageBox MB_YESNO|MB_ICONEXCLAMATION ""Another Cling installation (version $2) has been detected. It is recommended to uninstall it if you intend to use the same installation directory. Do you want to proceed with the installation anyway?"" IDYES done IDNO 0; Abort; done:; ClearErrors; Pop $2; Pop $1; Pop $0; FunctionEnd; '''",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/cpt.py:1498,detect,detected,1498,interpreter/cling/tools/packaging/cpt.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/cpt.py,4,"['Abort', 'detect']","['Abort', 'detected']"
Safety," it allocates. For the module scope lds,; // this is via metadata indicating whether the variable is not required. If a; // pass deletes that metadata, a fatal error on disagreement with the absolute; // symbol metadata will occur. For kernel scope and dynamic, this is by _name_; // correspondence between the function and the variable. It requires the; // kernel to have a name (which is only a limitation for tests in practice) and; // for nothing to rename the corresponding symbols. This is a hazard if the pass; // is run multiple times during debugging. Alternative schemes considered all; // involve bespoke metadata.; //; // If the name correspondence can be replaced, multiple distinct kernels that; // have the same memory layout can map to the same kernel id (as the address; // itself is handled by the absolute symbol metadata) and that will allow more; // uses of the ""kernel"" style faster lowering and reduce the size of the lookup; // tables.; //; // There is a test that checks this does not fire for a graphics shader. This; // lowering is expected to work for graphics if the isKernel test is changed.; //; // The current markUsedByKernel is sufficient for PromoteAlloca but is elided; // before codegen. Replacing this with an equivalent intrinsic which lasts until; // shortly after the machine function lowering of LDS would help break the name; // mapping. The other part needed is probably to amend PromoteAlloca to embed; // the LDS variables it creates in the same struct created here. That avoids the; // current hazard where a PromoteAlloca LDS variable might be allocated before; // the kernel scope (and thus error on the address check). Given a new invariant; // that no LDS variables exist outside of the structs managed here, and an; // intrinsic that lasts until after the LDS frame lowering, it should be; // possible to drop the name mapping and fold equivalent memory layouts.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:10065,avoid,avoids,10065,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,2,"['avoid', 'hazard']","['avoids', 'hazard']"
Safety," make tests for your own application to find a compromise; /// between speed and the quantity of information you may loose in case of; /// a job crash.; ///; /// In case your program crashes before closing the file holding this tree,; /// the file will be automatically recovered when you will connect the file; /// in UPDATE mode.; /// The Tree will be recovered at the status corresponding to the last AutoSave.; ///; /// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; /// This allows another process to analyze the Tree while the Tree is being filled.; ///; /// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; /// the current basket are closed-out and written to disk individually.; ///; /// By default the previous header is deleted after having written the new header.; /// if option contains ""Overwrite"", the previous Tree header is deleted; /// before written the new header. This option is slightly faster, but; /// the default option is safer in case of a problem (disk quota exceeded); /// when writing the new header.; ///; /// The function returns the number of bytes written to the file.; /// if the number of bytes is null, an error has occurred while writing; /// the header to the file.; ///; /// ## How to write a Tree in one process and view it from another process; ///; /// The following two scripts illustrate how to do this.; /// The script treew.C is executed by process1, treer.C by process2; ///; /// script treew.C:; /// ~~~ {.cpp}; /// void treew() {; /// TFile f(""test.root"",""recreate"");; /// TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; /// Float_t px, py, pz;; /// for ( Int_t i=0; i<10000000; i++) {; /// gRandom->Rannor(px,py);; /// pz = px*px + py*py;; /// Float_t random = gRandom->Rndm(1);; /// ntuple->Fill(px,py,pz,random,i);; /// if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; /// }; /// }; /// ~~~; /// script treer.C:; /// ~~~ {.cpp}; /// void treer() {; /// TFile f(""test.root"");; /// TTre",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1927,safe,safer,1927,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['safe'],['safer']
Safety," method is especially useful when used with a simultaneous PDF, since each component will automatically be wrapped,; * depending on the value of `precision`:; * - `precision < 0.`: None of the PDFs are touched, bin sampling is off.; * - `precision = 0.`: Continuous PDFs that are fit to a RooDataHist are wrapped into a RooBinSamplingPdf. The target precision; * forwarded to the integrator is 1.E-4 (the default argument of the constructor).; * - `precision > 0.`: All continuous PDFs are automatically wrapped into a RooBinSamplingPdf, regardless of what data they are; * fit to (see next paragraph). The same `'precision'` is used for all integrators.; *; * ### Simulating a binned fit using RooDataSet; * Some frameworks use unbinned data (RooDataSet) to simulate binned datasets. By adding one entry for each bin centre with the; * appropriate weight, one can achieve the same result as fitting with RooDataHist. In this case, however, RooFit cannot; * auto-detect that a binned fit is running, and that an integration over the bin is desired (note that there are no bins to; * integrate over in this kind of dataset).; *; * In this case, `IntegrateBins(>0.)` needs to be used, and the desired binning needs to be assigned to the observable; * of the dataset:; * ```; * RooRealVar x(""x"", ""x"", 0., 5.);; * x.setBins(10);; *; * // <create dataset and model>; *; * model.fitTo(data, IntegrateBins(>0.));; * ```; *; * \see RooAbsPdf::fitTo(); * \see IntegrateBins(); *; * \note This feature is currently limited to one-dimensional PDFs.; *; *; * \htmlonly <style>div.image img[src=""RooBinSamplingPdf_OFF.png""]{width:12cm;}</style> \endhtmlonly; * \htmlonly <style>div.image img[src=""RooBinSamplingPdf_ON.png"" ]{width:12cm;}</style> \endhtmlonly; * <table>; * <tr><th> Binned fit without %RooBinSamplingPdf <th> Binned fit with %RooBinSamplingPdf </td></tr>; * <tr><td> \image html RooBinSamplingPdf_OFF.png """"; * </td>; * <td> \image html RooBinSamplingPdf_ON.png """"; * </td></tr>; * </table>; *; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx:3389,detect,detect,3389,roofit/roofitcore/src/RooBinSamplingPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx,1,['detect'],['detect']
Safety," new / delete are expensive operations in; terms of CPU time. Without entering into technical details, TClonesArray allows you to; ""reuse"" the same portion of memory for new/delete avoiding memory; fragmentation and memory growth and improving the performance by; orders of magnitude. Every time the memory of the TClonesArray has; to be reused, the Clear() method is used. To provide its benefits,; each TClonesArray must be allocated *once* per process and disposed; of (deleted) *only when not needed any more*. So a job should see *only one* deletion for each TClonesArray,; which should be Clear()ed during the job several times. Deleting a; TClonesArray is a double waste. Not only you do not avoid memory; fragmentation, but you worsen it because the TClonesArray itself; is a rather heavy structure, and there is quite some code in the; destructor, so you have more memory fragmentation and slower code. ### NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. - Use Clear() or Clear(""C"") instead of Delete(). This will improve; program execution time.; - TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used; for clearing TClonesArray. When option ""C"" is specified, ROOT; automatically executes the Clear() method (by default it is; empty contained in TObject). This method must be overridden in; the relevant TClonesArray object class, implementing the reset; procedure for pointer objects.; - If the objects are added using the placement new then the Clear must; deallocate the memory.; - If the objects are added using TClonesArray::ConstructedAt then the; heap-based memory can stay allocated and reused as the constructor is; not called for already constructed/added object.; - To reduce memory fragmentation, please make sure that the; TClonesArrays are not destroyed and created on every event. They; must only be constructed/destructed at the beginning/end of the; run.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClonesArray.cxx:4145,avoid,avoid,4145,core/cont/src/TClonesArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClonesArray.cxx,1,['avoid'],['avoid']
Safety," note:; //; // A positive value of autoflush determines the size (in number of entries) of; // a cluster of baskets.; //; // If the value of autoflush is changed over time (this happens in; // particular when the TTree results from fast merging many trees),; // we record the values of fAutoFlush in the data members:; // fClusterRangeEnd and fClusterSize.; // In the code we refer to a range of entries where the size of the; // cluster of baskets is the same (i.e the value of AutoFlush was; // constant) is called a ClusterRange.; //; // The 2 arrays (fClusterRangeEnd and fClusterSize) have fNClusterRange; // active (used) values and have fMaxClusterRange allocated entries.; //; // fClusterRangeEnd contains the last entries number of a cluster range.; // In particular this means that the 'next' cluster starts at fClusterRangeEnd[]+1; // fClusterSize contains the size in number of entries of all the cluster; // within the given range.; // The last range (and the only one if fNClusterRange is zero) start at; // fNClusterRange[fNClusterRange-1]+1 and ends at the end of the TTree. The; // size of the cluster in this range is given by the value of fAutoFlush.; //; // For example printing the beginning and end of each the ranges can be done by:; //; // Printf(""%-16s %-16s %-16s %5s"",; // ""Cluster Range #"", ""Entry Start"", ""Last Entry"", ""Size"");; // Int_t index= 0;; // Long64_t clusterRangeStart = 0;; // if (fNClusterRange) {; // for( ; index < fNClusterRange; ++index) {; // Printf(""%-16d %-16lld %-16lld %5lld"",; // index, clusterRangeStart, fClusterRangeEnd[index], fClusterSize[index]);; // clusterRangeStart = fClusterRangeEnd[index] + 1;; // }; // }; // Printf(""%-16d %-16lld %-16lld %5lld"",; // index, prevEntry, fEntries - 1, fAutoFlush);; //; // Note: We store the entry number corresponding to the end of the cluster; // rather than its start in order to avoid using the array if the cluster; // size never varies (If there is only one value of AutoFlush for the whole TTree).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1895,avoid,avoid,1895,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['avoid'],['avoid']
Safety," of a dirty argument, if an; /// instruction has one.; ///; /// Every 4 aligned, consecutive bytes of application memory have one origin; /// value associated with them. If these bytes contain uninitialized data; /// coming from 2 different allocations, the last store wins. Because of this,; /// MemorySanitizer reports can show unrelated origins, but this is unlikely in; /// practice.; ///; /// Origins are meaningless for fully initialized values, so MemorySanitizer; /// avoids storing origin to memory when a fully initialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, alwa",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3876,safe,safe,3876,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['safe'],['safe']
Safety," of entries.; In particular, note that this means that, for multi-thread event loops, there is no; guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs. \warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; ~~~{.cpp}; ROOT::EnableImplicitMT(i); ~~~; replacing `i` with the number of CPUs/slots that were allocated for this job. ### Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads. Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; which eliminates all risks of race conditions. In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; concurrently, RDataFrame guarantees that different threads will employ diffe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:48715,safe,safe,48715,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['safe'],['safe']
Safety," prob(S->Pred).; // At this point, 2 blocks can be placed after BB: Pred or Succ. If we; // choose Pred, we will have a topological ordering as shown on the left; // in the picture below. If we choose Succ, we have the solution as shown; // on the right:; //; // topo-order:; //; // S----- ---S; // | | | |; // ---BB | | BB; // | | | |; // | Pred-- | Succ--; // | | | |; // ---Succ ---Pred--; //; // cost = freq(S->Pred) + freq(BB->Succ) cost = 2 * freq (S->Pred); // = freq(S->Pred) + freq(S->BB); //; // If we have profile data (i.e, branch probabilities can be trusted), the; // cost (number of taken branches) with layout S->BB->Succ->Pred is 2 *; // freq(S->Pred) while the cost of topo order is freq(S->Pred) + freq(S->BB).; // We know Prob(S->BB) > Prob(S->Pred), so freq(S->BB) > freq(S->Pred), which; // means the cost of topological order is greater.; // When profile data is not available, however, we need to be more; // conservative. If the branch prediction is wrong, breaking the topo-order; // will actually yield a layout with large cost. For this reason, we need; // strong biased branch at block S with Prob(S->BB) in order to select; // BB->Succ. This is equivalent to looking the CFG backward with backward; // edge: Prob(Succ->BB) needs to >= HotProb in order to be selected (without; // profile data).; // --------------------------------------------------------------------------; // Case 3: forked diamond; // S; // / \; // / \; // BB Pred; // | \ / |; // | \ / |; // | X |; // | / \ |; // | / \ |; // S1 S2; //; // The current block is BB and edge BB->S1 is now being evaluated.; // As above S->BB was already selected because; // prob(S->BB) > prob(S->Pred). Assume that prob(BB->S1) >= prob(BB->S2).; //; // topo-order:; //; // S-------| ---S; // | | | |; // ---BB | | BB; // | | | |; // | Pred----| | S1----; // | | | |; // --(S1 or S2) ---Pred--; // |; // S2; //; // topo-cost = freq(S->Pred) + freq(BB->S1) + freq(BB->S2); // + min(freq(Pred->S1), freq(Pred->S2)); // No",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:2685,predict,prediction,2685,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['predict'],['prediction']
Safety," ps->NewPage();; c1->cd(1);; hpxpy->Draw();; c1->cd(2);; ntuple->Draw(""px"");; c1->Update();; ps->Close();. // invoke Postscript viewer; gSystem->Exec(""gs file.ps"");; }; ~~~. ## Making several pictures in the same Postscript file: case 3; This is the recommended way. If the Postscript file name finishes with; ""("", the file remains opened (it is not closed). If the Postscript file name; finishes with "")"" and the file has been opened with ""("", the file is closed. Example:; ~~~ {.cpp}; {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); // write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); // canvas is added to ""c1.ps""; h3.Draw();; c1.Print(""c1.ps)""); // canvas is added to ""c1.ps"" and ps file is closed; }; ~~~; The `TCanvas::Print(""file.ps("")` mechanism is very useful, but it can; be a little inconvenient to have the action of opening/closing a file being; atomic with printing a page. Particularly if pages are being generated in some; loop one needs to detect the special cases of first and last page and then; munge the argument to Print() accordingly.; The ""["" and ""]"" can be used instead of ""("" and "")"" as shown below. Example:; ~~~ {.cpp}; c1.Print(""file.ps[""); // No actual print, just open file.ps. for (int i=0; i<10; ++i) {; // fill canvas for context i; // ... c1.Print(""file.ps""); // Actually print canvas to the file; }. c1.Print(""file.ps]""); // No actual print, just close the file; ~~~. ## Color Model. TPostScript support two color model RGB and CMYK. CMY and CMYK models are; subtractive color models unlike RGB which is an additive. They are mainly; used for printing purposes. CMY means Cyan Magenta Yellow to convert RGB; to CMY it is enough to do: C=1-R, M=1-G and Y=1-B. CMYK has one more; component K (black). The conversion from RGB to CMYK is:. ~~~ {.cpp}; Double_t Black = TMath::Min(TMath::Min(1-Red,1-Green),1-Blue);; Double_t Cyan = (1-Red-Black)/(1-Black);; Double_t Magenta = (1-Green-Black)/(1-Black);; Double_t Yellow = (1-Blue-Black)/(1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TPostScript.cxx:6148,detect,detect,6148,graf2d/postscript/src/TPostScript.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TPostScript.cxx,1,['detect'],['detect']
Safety," speed when inflate_fast() not used; *; * 1.2.beta4 1 Jan 2003; * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings; * - Move a comment on output buffer sizes from inffast.c to inflate.c; * - Add comments in inffast.c to introduce the inflate_fast() routine; * - Rearrange window copies in inflate_fast() for speed and simplification; * - Unroll last copy for window match in inflate_fast(); * - Use local copies of window variables in inflate_fast() for speed; * - Pull out common wnext == 0 case for speed in inflate_fast(); * - Make op and len in inflate_fast() unsigned for consistency; * - Add FAR to lcode and dcode declarations in inflate_fast(); * - Simplified bad distance check in inflate_fast(); * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new; * source file infback.c to provide a call-back interface to inflate for; * programs like gzip and unzip -- uses window as output buffer to avoid; * window copying; *; * 1.2.beta5 1 Jan 2003; * - Improved inflateBack() interface to allow the caller to provide initial; * input in strm.; * - Fixed stored blocks bug in inflateBack(); *; * 1.2.beta6 4 Jan 2003; * - Added comments in inffast.c on effectiveness of POSTINC; * - Typecasting all around to reduce compiler warnings; * - Changed loops from while (1) or do {} while (1) to for (;;), again to; * make compilers happy; * - Changed type of window in inflateBackInit() to unsigned char *; *; * 1.2.beta7 27 Jan 2003; * - Changed many types to unsigned or unsigned short to avoid warnings; * - Added inflateCopy() function; *; * 1.2.0 9 Mar 2003; * - Changed inflateBack() interface to provide separate opaque descriptors; * for the in() and out() functions; * - Changed inflateBack() argument and in_func typedef to swap the length; * and buffer address return values for the input function; * - Check next_in and next_out for Z_NULL on entry to inflate(); *; * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c:3421,avoid,avoid,3421,builtins/zlib/inflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c,1,['avoid'],['avoid']
Safety," speed when inflate_fast() not used; *; * 1.2.beta4 1 Jan 2003; * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings; * - Move a comment on output buffer sizes from inffast.c to inflate.c; * - Add comments in inffast.c to introduce the inflate_fast() routine; * - Rearrange window copies in inflate_fast() for speed and simplification; * - Unroll last copy for window match in inflate_fast(); * - Use local copies of window variables in inflate_fast() for speed; * - Pull out common write == 0 case for speed in inflate_fast(); * - Make op and len in inflate_fast() unsigned for consistency; * - Add FAR to lcode and dcode declarations in inflate_fast(); * - Simplified bad distance check in inflate_fast(); * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new; * source file infback.c to provide a call-back interface to inflate for; * programs like gzip and unzip -- uses window as output buffer to avoid; * window copying; *; * 1.2.beta5 1 Jan 2003; * - Improved inflateBack() interface to allow the caller to provide initial; * input in strm.; * - Fixed stored blocks bug in inflateBack(); *; * 1.2.beta6 4 Jan 2003; * - Added comments in inffast.c on effectiveness of POSTINC; * - Typecasting all around to reduce compiler warnings; * - Changed loops from while (1) or do {} while (1) to for (;;), again to; * make compilers happy; * - Changed type of window in inflateBackInit() to unsigned char *; *; * 1.2.beta7 27 Jan 2003; * - Changed many types to unsigned or unsigned short to avoid warnings; * - Added inflateCopy() function; *; * 1.2.0 9 Mar 2003; * - Changed inflateBack() interface to provide separate opaque descriptors; * for the in() and out() functions; * - Changed inflateBack() argument and in_func typedef to swap the length; * and buffer address return values for the input function; * - Check next_in and next_out for Z_NULL on entry to inflate(); *; * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inflate.c:3421,avoid,avoid,3421,graf2d/asimage/src/libAfterImage/zlib/inflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inflate.c,1,['avoid'],['avoid']
Safety," the bin; /// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); /// (i.e the errors are the standard error on the bin content of the profile); /// - 's' Errors are the standard deviation of Y, S(Y); /// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); /// The only difference is only when the standard deviation in Y is zero.; /// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; /// 1./SQRT(12*N).; /// This approximation assumes that the Y values are integer (e.g. ADC counts); /// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; /// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); /// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; /// W is obtained as from TProfile::GetBinEntries(ibin); /// This errors corresponds to the standard deviation of weighted mean where each; /// measurement Y is uncorrelated and has an error sigma, which is expressed in the; /// weight used to fill the Profile: w = 1/sigma^2; /// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); ///; /// In the case of Profile filled weights and with TProfile::Sumw2() called,; /// STD(Y) is the standard deviation of the weighted sample Y and N is in this case the; /// number of effective entries (TProfile::GetBinEffectiveEntries(ibin) ); ///; /// If a bin has N data points all with the same value Y (especially; /// possible when dealing with integers), the spread in Y for that bin; /// is zero, and the uncertainty assigned is also zero, and the bin is; /// ignored in making subsequent fits.; /// To avoid this problem one can use an approximation for the standard deviation S(Y),; /// by using the average of all the S(Y) of the other Profile bins. To use this approximation; /// one must call before TProfile::Approximate; /// This approximation applies only for the default and the 's' options",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:2349,avoid,avoid,2349,hist/hist/src/TProfile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx,1,['avoid'],['avoid']
Safety," the bootstrap process the deferred actions are attached to a final; // ""complete-bootstrap"" graph that causes them to be run.; //; // The bootstrap steps are as follows:; //; // 1. Request the graph containing the mach header. This graph is guaranteed; // not to have any metadata so the fact that the registration functions; // are not available yet is not a problem.; //; // 2. Look up the registration functions and discard the results. This will; // trigger linking of the graph containing these functions, and; // consequently any graphs that it depends on. We do not use the lookup; // result to find the addresses of the functions requested (as described; // above the lookup will return too late for that), instead we capture the; // addresses in a post-allocation pass injected by the platform runtime; // during bootstrap only.; //; // 3. During bootstrap the MachOPlatformPlugin keeps a count of the number of; // graphs being linked (potentially concurrently), and we block until all; // of these graphs have completed linking. This is to avoid a race on the; // deferred-actions vector: the lookup for the runtime registration; // functions may return while some functions (those that are being; // incidentally linked in, but aren't reachable via the runtime functions); // are still being linked, and we need to capture any allocation actions; // for this incidental code before we proceed.; //; // 4. Once all active links are complete we transfer the deferred actions to; // a newly added CompleteBootstrap graph and then request a symbol from; // the CompleteBootstrap graph to trigger materialization. This will cause; // all deferred actions to be run, and once this lookup returns we can; // proceed.; //; // 5. Finally, we associate runtime support methods in MachOPlatform with; // the corresponding jit-dispatch tag variables in the ORC runtime to make; // the support methods callable. The bootstrap is now complete.; // Step (1) Add header materialization unit and request.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:2262,avoid,avoid,2262,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,1,['avoid'],['avoid']
Safety," then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to fold such functions.; //; // * be smarter about bitcasts.; //; // In order to fold functions, we will sometimes add either bitcast instructions; // or bitcast constant expressions. Unfortunately, this can confound further; // analysis since the two functions differ where one has a bitcast and the; // other doesn't. We should learn to look through bitcasts.; //; // * Compare complex types with pointer types inside.; // * Compare cross-reference cases.; // * Compare complex expressions.; //; // All the three issues above could be described as ability to prove that; // fA == fB == fC == fE == fF == fG in example below:; //; // void fA() {; // fB();; // }; // void fB() {; // fA();; // }; //; // void fE() {; // fF();; // }; // void fF() {; // fG();; // }; // void fG() {; // fE();; // }; //; // Simplest cross-reference case (fA <--> fB) was implemented in previous; // versions of MergeFunctions, though it presented only in two function pairs; // in test-suite (that counts >50k functions); // Though possibility to detect complex cross-referencing (e.g.: A->B->C->D->A); // could cover much more cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:3514,detect,detect,3514,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,1,['detect'],['detect']
Safety," to be written as the next byte after; the next deflate block is completed. In this case, the decompressor may not; be provided enough bits at this point in order to complete decompression of; the data provided so far to the compressor. It may need to wait for the next; block to be emitted. This is for advanced applications that need to control; the emission of deflate blocks. If flush is set to Z_FULL_FLUSH, all output is flushed as with; Z_SYNC_FLUSH, and the compression state is reset so that decompression can; restart from this point if previous compressed data has been damaged or if; random access is desired. Using Z_FULL_FLUSH too often can seriously degrade; compression. If deflate returns with avail_out == 0, this function must be called again; with the same value of the flush parameter and more output space (updated; avail_out), until the flush is complete (deflate returns with non-zero; avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that; avail_out is greater than six to avoid repeated flush markers due to; avail_out == 0 on return. If the parameter flush is set to Z_FINISH, pending input is processed,; pending output is flushed and deflate returns with Z_STREAM_END if there was; enough output space; if deflate returns with Z_OK, this function must be; called again with Z_FINISH and more output space (updated avail_out) but no; more input data, until it returns with Z_STREAM_END or an error. After; deflate has returned Z_STREAM_END, the only possible operations on the stream; are deflateReset or deflateEnd. Z_FINISH can be used immediately after deflateInit if all the compression; is to be done in a single step. In this case, avail_out must be at least the; value returned by deflateBound (see below). Then deflate is guaranteed to; return Z_STREAM_END. If not enough output space is provided, deflate will; not return Z_STREAM_END, and it must be called again as described above. deflate() sets strm->adler to the adler32 checksum of all in",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:4013,avoid,avoid,4013,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['avoid'],['avoid']
Safety," to prevent a; /// forbidden slot hazard, offset of some branches may go out of range. In that; /// case it is necessary to check again if there is some branch that needs; /// expansion. On the other hand, expanding some branch may cause a control; /// transfer instruction to appear in the forbidden slot, which is a hazard that; /// should be fixed. This pass alternates between this two tasks untill no; /// changes are made. Only then we can be sure that all branches are expanded; /// properly, and no hazard situations exist.; ///; /// Regarding branch expanding:; ///; /// When branch instruction like beqzc or bnezc has offset that is too large; /// to fit into its immediate field, it has to be expanded to another; /// instruction or series of instructions.; ///; /// FIXME: Fix pc-region jump instructions which cross 256MB segment boundaries.; /// TODO: Handle out of range bc, b (pseudo) instructions.; ///; /// Regarding compact branch hazard prevention:; ///; /// Hazards handled: forbidden slots for MIPSR6, FPU slots for MIPS3 and below,; /// load delay slots for MIPS1.; ///; /// A forbidden slot hazard occurs when a compact branch instruction is executed; /// and the adjacent instruction in memory is a control transfer instruction; /// such as a branch or jump, ERET, ERETNC, DERET, WAIT and PAUSE.; ///; /// For example:; ///; /// 0x8004 bnec a1,v0,<P+0x18>; /// 0x8008 beqc a1,a2,<P+0x54>; ///; /// In such cases, the processor is required to signal a Reserved Instruction; /// exception.; ///; /// Here, if the instruction at 0x8004 is executed, the processor will raise an; /// exception as there is a control transfer instruction at 0x8008.; ///; /// There are two sources of forbidden slot hazards:; ///; /// A) A previous pass has created a compact branch directly.; /// B) Transforming a delay slot branch into compact branch. This case can be; /// difficult to process as lookahead for hazards is insufficient, as; /// backwards delay slot fillling can also produce haza",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:1845,hazard,hazard,1845,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,2,"['Hazard', 'hazard']","['Hazards', 'hazard']"
Safety," to trace execution; // time around arbitrary code. Two API flavors are available.; //; // The primary API uses a RAII object to trigger tracing:; //; // \code; // {; // TimeTraceScope scope(""my_event_name"");; // ...my code...; // }; // \endcode; //; // If the code to be profiled does not have a natural lexical scope then; // it is also possible to start and end events with respect to an implicit; // per-thread stack of profiling entries:; //; // \code; // timeTraceProfilerBegin(""my_event_name"");; // ...my code...; // timeTraceProfilerEnd(); // must be called on all control flow paths; // \endcode; //; // Time profiling entries can be given an arbitrary name and, optionally,; // an arbitrary 'detail' string. The resulting trace will include 'Total'; // entries summing the time spent for each name. Thus, it's best to choose; // names to be fairly generic, and rely on the detail field to capture; // everything else of interest.; //; // To avoid lifetime issues name and detail strings are copied into the event; // entries at their time of creation. Care should be taken to make string; // construction cheap to prevent 'Heisenperf' effects. In particular, the; // 'detail' argument may be a string-returning closure:; //; // \code; // int n;; // {; // TimeTraceScope scope(""my_event_name"",; // [n]() { return (Twine(""x="") + Twine(n)).str(); });; // ...my code...; // }; // \endcode; // The closure will not be called if tracing is disabled. Otherwise, the; // resulting string will be directly moved into the entry.; //; // The main process should begin with a timeTraceProfilerInitialize, and; // finish with timeTraceProfileWrite and timeTraceProfilerCleanup calls.; // Each new thread should begin with a timeTraceProfilerInitialize, and; // finish with a timeTraceProfilerFinishThread call.; //; // Timestamps come from std::chrono::stable_clock. Note that threads need; // not see the same time from that clock, and the resolution may not be; // the best available.; //; // Currentl",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TimeProfiler.h:1389,avoid,avoid,1389,interpreter/llvm-project/llvm/include/llvm/Support/TimeProfiler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TimeProfiler.h,1,['avoid'],['avoid']
Safety," write; * out single scanline. Each written scanlines moves internal pointer to; * the next image line, and possibly writes several scanlines at once if; * tiling_step member is not 0.; **********/; /****f* libAfterImage/asimage/set_image_output_back_color(); * NAME; * set_image_output_back_color() - changes background color of output; * SYNOPSIS; * void set_image_output_back_color ( ASImageOutput *imout,; * ARGB32 back_color );; * INPUTS; * imout		- ASImageOutput structure, previously created with; * 			 start_image_output();; * back_color	- new background color value in ARGB format. This color; * 			 will be used to fill empty parts of outgoing scanlines.; *********/; /****f* libAfterImage/asimage/toggle_image_output_direction(); * NAME; * toggle_image_output_direction() - reverses vertical direction of output; * SYNOPSIS; * void toggle_image_output_direction( ASImageOutput *imout );; * INPUTS; * imout		- ASImageOutput structure, previously created with; * 			 start_image_output();; * DESCRIPTION; * reverses vertical direction output. If previously scanlines has; * been written from top to bottom, for example, after this function is; * called they will be written in opposite direction. Current line does; * not change, unless it points to the very first or the very last; * image line. In this last case it will be moved to the opposing end of; * the image.; *********/; /****f* libAfterImage/asimage/stop_image_output(); * NAME; * stop_image_output() - finishes output, frees all the allocated memory.; * SYNOPSIS; * void stop_image_output( ASImageOutput **pimout );; * INPUTS; * pimout		- pointer to pointer to ASImageOutput structure,; * 			 previously created with call to	start_image_output().; * RETURN VALUE; * pimout		- pointer to ASImageOutput will be reset to NULL.; * DESCRIPTION; * Completes image output process. Flushes all the internal buffers.; * Deallocates all the allocated memory. Resets pointer to NULL to; * avoid dereferencing invalid pointers.; *********/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/imencdec.h:3124,avoid,avoid,3124,graf2d/asimage/src/libAfterImage/imencdec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/imencdec.h,1,['avoid'],['avoid']
Safety,"""""""; Allow branches to be accessed as attributes of a tree. Allow access to branches/leaves as if they were Python data attributes of; the tree (e.g. mytree.branch). To avoid using the CPyCppyy API, any necessary cast is done here on the; Python side. The GetBranchAttr() function encodes a necessary cast in the; second element of the output tuple, which is a string with the required; type name. Parameters:; self (TTree): The instance of the TTree object from which the attribute is being retrieved.; key (str): The name of the branch to retrieve from the TTree object.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_ttree.py:169,avoid,avoid,169,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_ttree.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_ttree.py,1,['avoid'],['avoid']
Safety,"""""""; Checks if the provided callback function is safe for live visualization, ; (does not contain blocked actions). Args:; callback (function): The callback function to check. Returns:; bool: True if the callback function is safe, ; False otherwise.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/LiveVisualize.py:49,safe,safe,49,bindings/experimental/distrdf/python/DistRDF/LiveVisualize.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/LiveVisualize.py,2,['safe'],['safe']
Safety,"""""""; Contains constants needed for _rdf_pyz to convert datatypes for numba declarable types.; It is in a separate module so as to avoid a numpy dependency for ROOT.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_rdf_conversion_maps.py:130,avoid,avoid,130,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_rdf_conversion_maps.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_rdf_conversion_maps.py,1,['avoid'],['avoid']
Safety,"""""""; Detects and tags code cells that use the C++ language.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/jupyroot/python/JupyROOT/html/cpphighlighter.py:5,Detect,Detects,5,bindings/jupyroot/python/JupyROOT/html/cpphighlighter.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/jupyroot/python/JupyROOT/html/cpphighlighter.py,1,['Detect'],['Detects']
Safety,"""""""; Entries corresponding to each tree assigned to a certain task, plus the; actual number of entries that task will be processing. This information will; be aggregated along with the main mergeable results in distributed; execution. It serves as a sanity check that exactly the total amount of; entries in the dataset is processed in the application.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Ranges.py:250,sanity check,sanity check,250,bindings/experimental/distrdf/python/DistRDF/Ranges.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Ranges.py,1,['sanity check'],['sanity check']
Safety,"""""""; Execute the tests in the run using up to the specified number of; parallel tasks, and inform the caller of each individual result. The; provided tests should be a subset of the tests available in this run; object. The progress_callback will be invoked for each completed test. If timeout is non-None, it should be a time in seconds after which to; stop executing tests. Returns the elapsed testing time. Upon completion, each test in the run will have its result; computed. Tests which were not actually executed (for any reason) will; be marked SKIPPED.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/run.py:285,timeout,timeout,285,interpreter/llvm-project/llvm/utils/lit/lit/run.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/run.py,1,['timeout'],['timeout']
Safety,"""""""; Object used to helper manage enforcing a timeout in; _executeShCmd(). It is passed through recursive calls; to collect processes that have been executed so that when; the timeout happens they can be killed.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:46,timeout,timeout,46,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,2,['timeout'],['timeout']
Safety,"""""""; Remove the reference to the local RDataFrame object as soon as this; object is garbage collected. This helps avoiding conflicts between; the garbage collector, the cppyy memory regulator and the C++ object; destructor.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py:114,avoid,avoiding,114,bindings/experimental/distrdf/python/DistRDF/HeadNode.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py,1,['avoid'],['avoiding']
Safety,"""""""; The Snapshot operation can be made lazy by supplying an RSnapshotOptions; object with the 'fLazy' data member set to 'True'. Furthermore, the current; range id needs to be appended to the input file name so that the output data; from different tasks can be distinguished. Note:; Since the file name from the original operation needs to be changed, this; function makes a deep copy of it and returns the modified copy. This is; needed in order to avoid that a task may receive as input an operation that; was previously modified by another task. In that case, the file name would; contain the range id from the other task, thus leading to create a wrong; file name in this function.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/ComputationGraphGenerator.py:451,avoid,avoid,451,bindings/experimental/distrdf/python/DistRDF/ComputationGraphGenerator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/ComputationGraphGenerator.py,1,['avoid'],['avoid']
Safety,"""""""; Trigger the execution of multiple RDataFrame computation graphs on a certain; distributed backend. If the backend doesn't support multiple job; submissions concurrently, the distributed computation graphs will be; executed sequentially. Args:; proxies(list): List of action proxies that should be triggered. Only; actions belonging to different RDataFrame graphs will be; triggered to avoid useless calls. Return:; (int): The number of unique computation graphs executed by this call. Example:. @code{.py}; import ROOT; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; RunGraphs = ROOT.RDF.Experimental.Distributed.RunGraphs. # Create 3 different dataframes and book an histogram on each one; histoproxies = [; RDataFrame(100); .Define(""x"", ""rdfentry_""); .Histo1D((""name"", ""title"", 10, 0, 100), ""x""); for _ in range(4); ]. # Execute the 3 computation graphs; n_graphs_run = RunGraphs(histoproxies); # Retrieve all the histograms in one go; histos = [histoproxy.GetValue() for histoproxy in histoproxies]; @endcode. """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/__init__.py:390,avoid,avoid,390,bindings/experimental/distrdf/python/DistRDF/__init__.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/__init__.py,1,['avoid'],['avoid']
Safety,"""""""; Wrapper around _executeShCmd that handles; timeout; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:48,timeout,timeout,48,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,1,['timeout'],['timeout']
Safety,"""""""; pre-push git hook integration; =============================. This script is intended to be setup as a pre-push hook, from the root of the; repo run:. ln -sf ../../llvm/utils/git/pre-push.py .git/hooks/pre-push. From the git doc:. The pre-push hook runs during git push, after the remote refs have been; updated but before any objects have been transferred. It receives the name; and location of the remote as parameters, and a list of to-be-updated refs; through stdin. You can use it to validate a set of ref updates before a push; occurs (a non-zero exit code will abort the push).; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/git/pre-push.py:573,abort,abort,573,interpreter/llvm-project/llvm/utils/git/pre-push.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/git/pre-push.py,1,['abort'],['abort']
Safety,"""""""A linter that detects potential typos in FileCheck directive names. Consider a broken test foo.cpp:. // RUN: clang -cc1 -ast-dump %s | FileCheck %s --check-prefix=NEW; // RUN: clang -cc1 -ast-dump %s -std=c++98 | FileCheck %s --check-prefix=OLD; auto x = 42;; // NEWW: auto is a c++11 extension; // ODL-NOT: auto is a c++11 extension. We first detect the locally valid FileCheck directive prefixes by parsing the; --check-prefix flags. Here we get {CHECK, NEW, OLD}, so our directive names are; {CHECK, NEW, OLD, CHECK-NOT, NEW-NOT, ...}. Then we look for lines that look like directives. These are of the form 'FOO:',; usually at the beginning of a line or a comment. If any of these are a; ""near-miss"" for a directive name, then we suspect this is a typo and report it. Usage: filecheck_lint path/to/test/file/1 ... path/to/test/file/n; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/filecheck_lint/filecheck_lint.py:17,detect,detects,17,interpreter/llvm-project/llvm/utils/filecheck_lint/filecheck_lint.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/filecheck_lint/filecheck_lint.py,2,['detect'],"['detect', 'detects']"
Safety,"""""""Check CFC - Check Compile Flow Consistency. This is a compiler wrapper for testing that code generation is consistent with; different compilation processes. It checks that code is not unduly affected by; compiler options or other changes which should not have side effects. To use:; -Ensure that the compiler under test (i.e. clang, clang++) is on the PATH; -On Linux copy this script to the name of the compiler; e.g. cp check_cfc.py clang && cp check_cfc.py clang++; -On Windows use setup.py to generate check_cfc.exe and copy that to clang.exe; and clang++.exe; -Enable the desired checks in check_cfc.cfg (in the same directory as the; wrapper); e.g.; [Checks]; dash_g_no_change = true; dash_s_no_change = false. -The wrapper can be run using its absolute path or added to PATH before the; compiler under test; e.g. export PATH=<path to check_cfc>:$PATH; -Compile as normal. The wrapper intercepts normal -c compiles and will return; non-zero if the check fails.; e.g.; $ clang -c test.cpp; Code difference detected with -g; --- /tmp/tmp5nv893.o; +++ /tmp/tmp6Vwjnc.o; @@ -1 +1 @@; - 0: 48 8b 05 51 0b 20 00 mov 0x200b51(%rip),%rax; + 0: 48 39 3d 51 0b 20 00 cmp %rdi,0x200b51(%rip). -To run LNT with Check CFC specify the absolute path to the wrapper to the --cc; and --cxx options; e.g.; lnt runtest nt --cc <path to check_cfc>/clang \\; --cxx <path to check_cfc>/clang++ ... To add a new check:; -Create a new subclass of WrapperCheck; -Implement the perform_check() method. This should perform the alternate compile; and do the comparison.; -Add the new check to check_cfc.cfg. The check has the same name as the; subclass.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py:1014,detect,detected,1014,interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/check_cfc/check_cfc.py,1,['detect'],['detected']
Safety,"""""""Checks for reverts of commits across a given git commit. To clarify the meaning of 'across' with an example, if we had the following; commit history (where `a -> b` notes that `b` is a direct child of `a`):. 123abc -> 223abc -> 323abc -> 423abc -> 523abc. And where 423abc is a revert of 223abc, this revert is considered to be 'across'; 323abc. More generally, a revert A of a parent commit B is considered to be; 'across' a commit C if C is a parent of A and B is a parent of C. Please note that revert detection in general is really difficult, since merge; conflicts/etc always introduce _some_ amount of fuzziness. This script just; uses a bundle of heuristics, and is bound to ignore / incorrectly flag some; reverts. The hope is that it'll easily catch the vast majority (>90%) of them,; though. This is designed to be used in one of two ways: an import in Python, or run; directly from a shell. If you want to import this, the `find_reverts`; function is the thing to look at. If you'd rather use this from a shell, have a; usage example:. ```; ./revert_checker.py c47f97169 origin/main origin/release/12.x; ```. This checks for all reverts from the tip of origin/main to c47f97169, which are; across the latter. It then does the same for origin/release/12.x to c47f97169.; Duplicate reverts discovered when walking both roots (origin/main and; origin/release/12.x) are deduplicated in output.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/revert_checker.py:508,detect,detection,508,interpreter/llvm-project/llvm/utils/revert_checker.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/revert_checker.py,1,['detect'],['detection']
Safety,"""""""Conversion from abortive signals to Python exceptions""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_fragile.py:19,abort,abortive,19,bindings/pyroot/cppyy/cppyy/test/test_fragile.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_fragile.py,1,['abort'],['abortive']
Safety,"""""""Detects if the current (or given) clang and external definition mapping; executables are CTU compatible.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py:3,Detect,Detects,3,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/clang.py,1,['Detect'],['Detects']
Safety,"""""""Detects potential typos in FileCheck directives. Args:; content: the content of the file; filepath: the path to the file to check for typos in directives; threshold: the (inclusive) maximum edit distance between a potential; directive and an actual directive, such that the potential directive is; classified as a typo. Yields:; Diagnostics, in order from the top of the file.; """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/filecheck_lint/filecheck_lint.py:3,Detect,Detects,3,interpreter/llvm-project/llvm/utils/filecheck_lint/filecheck_lint.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/filecheck_lint/filecheck_lint.py,1,['Detect'],['Detects']
Safety,"""""""Execute command ``command`` (list of arguments or string) with. * working directory ``cwd`` (str), use None to use the current; working directory; * environment ``env`` (dict), use None for none; * Input to the command ``input`` (str), use string to pass; no input.; * Max execution time ``timeout`` (int) seconds. Use 0 for no timeout.; * ``redirect_stderr`` (bool), use True if redirect stderr to stdout. Returns a tuple (out, err, exitCode) where; * ``out`` (str) is the standard output of running the command; * ``err`` (str) is the standard error of running the command; * ``exitCode`` (int) is the exitCode of running the command. If the timeout is hit an ``ExecuteCommandTimeoutException``; is raised. """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/util.py:293,timeout,timeout,293,interpreter/llvm-project/llvm/utils/lit/lit/util.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/util.py,3,['timeout'],['timeout']
Safety,"""""""Extend existing compilation database with new entries.; Duplicate entries are detected and not present in the final output.; The output is not continuously updated, it's done when the build; command finished. """"""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py:81,detect,detected,81,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/arguments.py,1,['detect'],['detected']
Safety,"""""""Library-based interposition will fail silently if SIP is enabled,; so this should be detected. You can detect whether SIP is enabled on; Darwin by checking whether (1) there is a binary called 'csrutil' in; the path and, if so, (2) whether the output of executing 'csrutil status'; contains 'System Integrity Protection status: enabled'. :param platform: name of the platform (returned by sys.platform),; :return: True if library preload will fail by the dynamic linker.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py:88,detect,detected,88,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,2,['detect'],"['detect', 'detected']"
Safety,"""""""Make safe this values to embed into HTML.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py:8,safe,safe,8,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/report.py,2,['safe'],['safe']
Safety,"""""""Predicate to detect duplicated entries. Unique hash method can be use to detect duplicates. Entries are; represented as dictionaries, which has no default hash method.; This implementation uses a set datatype to store the unique hash values. This method returns a method which can detect the duplicate values.""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py:16,detect,detect,16,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/__init__.py,3,['detect'],['detect']
Safety,"""""""Script to bisect over files in an rsp file. This is mostly used for detecting which file contains a miscompile between two; compiler revisions. It does this by bisecting over an rsp file. Between two; build directories, this script will make the rsp file reference the current; build directory's version of some set of the rsp's object files/libraries, and; reference the other build directory's version of the same files for the; remaining set of object files/libraries. Build the target in two separate directories with the two compiler revisions,; keeping the rsp file around since ninja by default deletes the rsp file after; building.; $ ninja -d keeprsp mytarget. Create a script to build the target and run an interesting test. Get the; command to build the target via; $ ninja -t commands | grep mytarget; The command to build the target should reference the rsp file.; This script doesn't care if the test script returns 0 or 1 for specifically the; successful or failing test, just that the test script returns a different; return code for success vs failure.; Since the command that `ninja -t commands` is run from the build directory,; usually the test script cd's to the build directory. $ rsp_bisect.py --test=path/to/test_script --rsp=path/to/build/target.rsp; --other_rel_path=../Other; where --other_rel_path is the relative path from the first build directory to; the other build directory. This is prepended to files in the rsp. For a full example, if the foo target is suspected to contain a miscompile in; some file, have two different build directories, buildgood/ and buildbad/ and; run; $ ninja -d keeprsp foo; in both so we have two versions of all relevant object files that may contain a; miscompile, one built by a good compiler and one by a bad compiler. In buildgood/, run; $ ninja -t commands | grep '-o .*foo'; to get the command to link the files together. It may look something like; clang -o foo @foo.rsp. Now create a test script that runs the link step and what",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/rsp_bisect.py:71,detect,detecting,71,interpreter/llvm-project/llvm/utils/rsp_bisect.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/rsp_bisect.py,1,['detect'],['detecting']
Safety,"""""""Script to find missing formal dependencies in a build.ninja file. Suppose you have a header file that's autogenerated by (for example) Tablegen.; If a C++ compilation step needs to include that header, then it must be; executed after the Tablegen build step that generates the header. So the; dependency graph in build.ninja should have the Tablegen build step as an; ancestor of the C++ one. If it does not, then there's a latent build-failure; bug, because depending on the order that ninja chooses to schedule its build; steps, the C++ build step could run first, and fail because the header it needs; does not exist yet. But because that kind of bug can easily be latent or intermittent, you might; not notice, if your local test build happens to succeed. What you'd like is a; way to detect problems of this kind reliably, even if they _didn't_ cause a; failure on your first test. This script tries to do that. It's specific to the 'ninja' build tool, because; ninja has useful auxiliary output modes that produce the necessary data:. - 'ninja -t graph' emits the full DAG of formal dependencies derived from; build.ninja (in Graphviz format). - 'ninja -t deps' dumps the database of dependencies discovered at build time; by finding out which headers each source file actually included. By cross-checking these two sources of data against each other, you can find; true dependencies shown by 'deps' that are not reflected as formal dependencies; in 'graph', i.e. a generated header that is required by a given source file but; not forced to be built first. To run it:. - set up a build directory using ninja as the build tool (cmake -G Ninja). - in that build directory, run ninja to perform an actual build (populating; the dependency database). - then, in the same build directory, run this script. No arguments are needed; (but -C and -f are accepted, and propagated to ninja for convenience). Requirements outside core Python: the 'pygraphviz' module, available via pip or; as the 'pytho",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/check_ninja_deps.py:792,detect,detect,792,interpreter/llvm-project/llvm/utils/check_ninja_deps.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/check_ninja_deps.py,1,['detect'],['detect']
Safety,"""""""Timeout: %s\n""""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:3,Timeout,Timeout,3,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,1,['Timeout'],['Timeout']
Safety,"""b"" horizontal; ///; /// option = ""o"" original axis range of the target axes will be; /// kept, but only bins inside the selected range will be filled.; ///; /// If option contains the string ""e"", errors are computed; ///; /// The projection is made for the selected bins only.; /// To select a bin range along an axis, use TAxis::SetRange, eg; /// h3.GetYaxis()->SetRange(23,56);; ///; /// NOTE 1: The generated histogram is named th3name + option; /// eg if the TH3* h histogram is named ""myhist"", then; /// h->Project3D(""xy""); produces a TH2D histogram named ""myhist_xy""; /// if a histogram of the same type already exists, it is overwritten.; /// The following sequence; /// h->Project3D(""xy"");; /// h->Project3D(""xy2"");; /// will generate two TH2D histograms named ""myhist_xy"" and ""myhist_xy2""; /// A different name can be generated by attaching a string to the option; /// For example h->Project3D(""name_xy"") will generate an histogram with the name: h3dname_name_xy.; ///; /// NOTE 2: If an histogram of the same type and with the same name already exists in current Directory,; /// the histogram is reset and filled again with the projected contents of the TH3.; ///; /// NOTE 3: The number of entries in the projected histogram is estimated from the number of; /// effective entries for all the cells included in the projection.; ///; /// NOTE 4: underflow/overflow are included by default in the projection; /// To exclude underflow and/or overflow (for both axis in case of a projection to a 1D histogram) use option ""NUF"" and/or ""NOF""; /// With SetRange() you can have all bins except underflow/overflow only if you set the axis bit range as; /// following after having called SetRange: axis->SetRange(1, axis->GetNbins());; ///; /// NOTE 5: If TH1::AddDirectory is set to false, a new histogram is always created and the ownership of the; /// returned pointer is delegated to the user. Be sure in this case to call `delete` on it after it's no longer needed,; /// to avoid memory leaks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:2926,avoid,avoid,2926,hist/hist/src/TH3.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx,1,['avoid'],['avoid']
Safety,"# 'NOTE' and 'TODO' are not directives, but are likely to be false positives; # if encountered and to generate noise as a result. We filter them out also to; # avoid this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/filecheck_lint/filecheck_lint.py:160,avoid,avoid,160,interpreter/llvm-project/llvm/utils/filecheck_lint/filecheck_lint.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/filecheck_lint/filecheck_lint.py,1,['avoid'],['avoid']
Safety,"# Always either returns the tuple (out, err, exitCode, timeoutInfo) or raises a; # ScriptFatal exception.; #; # If debug is True (the normal lit behavior), err is empty, and out contains an; # execution trace, including stdout and stderr shown per command executed.; #; # If debug is False (set by some custom lit test formats that call this; # function), out contains only stdout from the script, err contains only stderr; # from the script, and there is no execution trace.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:55,timeout,timeoutInfo,55,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,1,['timeout'],['timeoutInfo']
Safety,"# Always returns the tuple (out, err, exitCode, timeoutInfo, status).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:48,timeout,timeoutInfo,48,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,1,['timeout'],['timeoutInfo']
Safety,# Avoid CRLFs when writing bash scripts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:2,Avoid,Avoid,2,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,1,['Avoid'],['Avoid']
Safety,"# Avoid Windows heuristics which try to detect potential installer; # programs (which may need to run with elevated privileges) and ask; # if the user wants to run them in that way. This heuristic may; # match for executables containing the substrings ""patch"" (which is; # a substring of ""dispatch""), ""update"", ""setup"", etc. Set this; # environment variable indicating that we want to execute them with; # the current user.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestingConfig.py:2,Avoid,Avoid,2,interpreter/llvm-project/llvm/utils/lit/lit/TestingConfig.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestingConfig.py,2,"['Avoid', 'detect']","['Avoid', 'detect']"
Safety,# Avoid ambiguity when opcodes end in numbers,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/update_mir_test_checks.py:2,Avoid,Avoid,2,interpreter/llvm-project/llvm/utils/update_mir_test_checks.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/update_mir_test_checks.py,1,['Avoid'],['Avoid']
Safety,"# Avoid circular imports",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Node.py:2,Avoid,Avoid,2,bindings/experimental/distrdf/python/DistRDF/Node.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Node.py,1,['Avoid'],['Avoid']
Safety,"# Avoid creating tasks that will do nothing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Ranges.py:2,Avoid,Avoid,2,bindings/experimental/distrdf/python/DistRDF/Ranges.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Ranges.py,1,['Avoid'],['Avoid']
Safety,"# Avoid flashing an ugly, ugly cmd prompt on Windows when invoking clang-format.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py:2,Avoid,Avoid,2,interpreter/llvm-project/clang/tools/clang-format/clang-format.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/clang-format.py,1,['Avoid'],['Avoid']
Safety,# Avoid freeing our giant cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:2,Avoid,Avoid,2,interpreter/llvm-project/clang/utils/token-delta.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py,1,['Avoid'],['Avoid']
Safety,# Avoid generating different checks for 32- and 64-bit because of 'retl' vs 'retq'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/UpdateTestChecks/asm.py:2,Avoid,Avoid,2,interpreter/llvm-project/llvm/utils/UpdateTestChecks/asm.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/UpdateTestChecks/asm.py,1,['Avoid'],['Avoid']
Safety,# Avoid re-entering the lock by finding out if kill needs to be run; # again here but call it if necessary once we have left the lock.; # We could use a reentrant lock here instead but this code seems; # clearer to me.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:2,Avoid,Avoid,2,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,1,['Avoid'],['Avoid']
Safety,# Avoid remarks withoug debug location or if they are duplicated,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/opt-viewer/optrecord.py:2,Avoid,Avoid,2,interpreter/llvm-project/llvm/tools/opt-viewer/optrecord.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/opt-viewer/optrecord.py,1,['Avoid'],['Avoid']
Safety,# Avoid various singularities,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/Enumeration.py:2,Avoid,Avoid,2,interpreter/llvm-project/clang/utils/ABITest/Enumeration.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/Enumeration.py,1,['Avoid'],['Avoid']
Safety,"# Avoid wrapping the , or ; to the new line",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/update_options_td_flags.py:2,Avoid,Avoid,2,interpreter/llvm-project/clang/utils/update_options_td_flags.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/update_options_td_flags.py,1,['Avoid'],['Avoid']
Safety,"# Changing directory into another file can be safely done through a TContext; # context manager.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/pyroot006_tcontext_context_manager.py:46,safe,safely,46,tutorials/pyroot/pyroot006_tcontext_context_manager.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/pyroot006_tcontext_context_manager.py,1,['safe'],['safely']
Safety,"# Check the substitution's name.; #; # Do not extend this to permit '.' or any sequence that's special in a; # python pattern. We could escape that automatically for; # DEFINE/REDEFINE directives in test files. However, lit configuration; # file authors would still have to remember to escape them manually in; # substitution names but not in values. Moreover, the manually chosen; # and automatically chosen escape sequences would have to be consistent; # (e.g., '\.' vs. '[.]') in order for REDEFINE to successfully redefine; # a substitution previously defined by a lit configuration file. All; # this seems too error prone and confusing to be worthwhile. If you; # want your name to express structure, use ':' instead of '.'.; #; # Actually, '{' and '}' are special if they contain only digits possibly; # separated by a comma. Requiring a leading letter avoids that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:859,avoid,avoids,859,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,1,['avoid'],['avoids']
Safety,"# Clean the data entries: remove the first (header) row.; # Ensure empty strings are tagged as such since; # ROOT doesn't differentiate between different types; # of white space. Therefore, we change all of these; # entries to 'empty'. Also, avoiding any lines that begin; # with '#'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/parse_CSV_file_with_TTree_ReadStream.py:242,avoid,avoiding,242,tutorials/pyroot/parse_CSV_file_with_TTree_ReadStream.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/parse_CSV_file_with_TTree_ReadStream.py,1,['avoid'],['avoiding']
Safety,"# Clear the ""fitrange"" attribute of the PDF. Otherwise, the fitrange would be; # automatically taken as the NormRange() for plotting. We want to avoid this,; # because the point of this tutorial is to show what can go wrong when the; # NormRange() is not specified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf212_plottingInRanges_blinding.py:145,avoid,avoid,145,tutorials/roofit/rf212_plottingInRanges_blinding.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf212_plottingInRanges_blinding.py,1,['avoid'],['avoid']
Safety,"# Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf612_recoverFromInvalidParameters.py:157,recover,recovery,157,tutorials/roofit/rf612_recoverFromInvalidParameters.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf612_recoverFromInvalidParameters.py,1,['recover'],['recovery']
Safety,"# Convert the keyword and line to UTF-8 strings and yield the; # command. Note that we take care to return regular strings in; # Python 2, to avoid other code having to differentiate between the; # str and unicode types.; #; # Opening the file in binary mode prevented Windows \r newline; # characters from being converted to Unix \n newlines, so manually; # strip those from the yielded lines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:142,avoid,avoid,142,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,1,['avoid'],['avoid']
Safety,"# Create a new ROOT binary machine independent file.; # Note that this file may contain any kind of ROOT objects, histograms,; # pictures, graphics objects, detector geometries, tracks, events, etc..; # This file is now becoming the current directory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/hsimple.py:157,detect,detector,157,tutorials/pyroot/hsimple.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/hsimple.py,1,['detect'],['detector']
Safety,"# Create a temp directory inside the normal temp directory so that we can; # try to avoid temporary test file leaks. The user can avoid this behavior; # by setting LIT_PRESERVES_TMP in the environment, so they can easily use; # their own temp directory to monitor temporary file leaks or handle them at; # the buildbot level.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/main.py:84,avoid,avoid,84,interpreter/llvm-project/llvm/utils/lit/lit/main.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/main.py,2,['avoid'],['avoid']
Safety,"# Create file.root to avoid errors in the RDF constructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/string_view.py:22,avoid,avoid,22,bindings/pyroot/pythonizations/test/string_view.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/string_view.py,1,['avoid'],['avoid']
Safety,"# Define predict function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/pytorch/ApplicationClassificationPyTorch.py:9,predict,predict,9,tutorials/tmva/pytorch/ApplicationClassificationPyTorch.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/pytorch/ApplicationClassificationPyTorch.py,5,['predict'],['predict']
Safety,# Detect Ctrl-C in subprocess.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:2,Detect,Detect,2,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,2,['Detect'],['Detect']
Safety,# Detect shuffle asm comments and hide the operands in favor of the comments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/UpdateTestChecks/asm.py:2,Detect,Detect,2,interpreter/llvm-project/llvm/utils/UpdateTestChecks/asm.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/UpdateTestChecks/asm.py,1,['Detect'],['Detect']
Safety,# Detect stack spills and reloads and hide their exact offset and whether; # they used the stack pointer or frame pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/UpdateTestChecks/asm.py:2,Detect,Detect,2,interpreter/llvm-project/llvm/utils/UpdateTestChecks/asm.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/UpdateTestChecks/asm.py,1,['Detect'],['Detect']
Safety,# Disable symbolization if it's not required to avoid slow symbolization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py:48,avoid,avoid,48,interpreter/llvm-project/clang/utils/creduce-clang-crash.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/creduce-clang-crash.py,1,['avoid'],['avoid']
Safety,# Do some late initialisation that's only needed; # if there is a timeout set,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:66,timeout,timeout,66,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,1,['timeout'],['timeout']
Safety,"# Enable thread safety for the whole mapper function. We need to do; # this since two tasks could be invoking the C++ interpreter; # simultaneously, given that this function will release the GIL; # before calling into C++ to run the event loop. Dask multi-threaded; # or even multi-process workers could trigger such a scenario.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Base.py:16,safe,safety,16,bindings/experimental/distrdf/python/DistRDF/Backends/Base.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Base.py,1,['safe'],['safety']
Safety,"# Extensions will be detected anyway by set_ext()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/cpt.py:21,detect,detected,21,interpreter/cling/tools/packaging/cpt.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/cpt.py,1,['detect'],['detected']
Safety,"# Extract symbols from libraries in parallel. This is a huge time saver when; # doing a debug build, as there are hundreds of thousands of symbols in each; # library.; # FIXME: On AIX, the default pool size can be too big for a logical; # partition's allocated memory, and can lead to an out of memory; # IO error. We are setting the pool size to 8 to avoid such; # errors at the moment, and will look for a graceful solution later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/extract_symbols.py:352,avoid,avoid,352,interpreter/llvm-project/llvm/utils/extract_symbols.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/extract_symbols.py,1,['avoid'],['avoid']
Safety,"# Extract the relevant columns once and avoid repeated calls",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf618_mixture_models.py:40,avoid,avoid,40,tutorials/roofit/rf618_mixture_models.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf618_mixture_models.py,1,['avoid'],['avoid']
Safety,"# Fit again, but pass recovery information to the minimiser:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf612_recoverFromInvalidParameters.py:22,recover,recovery,22,tutorials/roofit/rf612_recoverFromInvalidParameters.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf612_recoverFromInvalidParameters.py,1,['recover'],['recovery']
Safety,"# Fully recursive, just avoid top-level arrays.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py:24,avoid,avoid,24,interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/ABITest/ABITestGen.py,1,['avoid'],['avoid']
Safety,"# Generate the appropriate checks for each function. We need to emit; # these in the order according to the generated output so that CHECK-LABEL; # works properly. func_order provides that.; # We can't predict where various passes might insert functions so we can't; # be sure the input function order is maintained. Therefore, first spit; # out all the source lines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/update_llc_test_checks.py:202,predict,predict,202,interpreter/llvm-project/llvm/utils/update_llc_test_checks.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/update_llc_test_checks.py,2,['predict'],['predict']
Safety,"# GpuOptions=""allow_growth=True"",; # ) # needed for RTX NVidia card and to avoid TF allocates all GPU memory; ## Train Methods; # Here we train all the previously booked methods.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_Higgs_Classification.py:75,avoid,avoid,75,tutorials/tmva/TMVA_Higgs_Classification.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_Higgs_Classification.py,1,['avoid'],['avoid']
Safety,"# If the description of an issue/pull request is empty, the Github API; # library returns None instead of an empty string. Handle this here to; # avoid failures from trying to manipulate None.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/git/github-automation.py:146,avoid,avoid,146,interpreter/llvm-project/llvm/utils/git/github-automation.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/git/github-automation.py,1,['avoid'],['avoid']
Safety,"# If the user explicitly passes an argument using numba CPointer, the regex match is used; # to detect the pass by reference since the dispatcher always returns typeref[val*]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/numba_ext.py:96,detect,detect,96,bindings/pyroot/cppyy/cppyy/python/cppyy/numba_ext.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/numba_ext.py,1,['detect'],['detect']
Safety,"# If we have multiple block_texts, try to break them down further to avoid; # the case where we have very similar block_texts repeated after each; # other.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/update_mca_test_checks.py:69,avoid,avoid,69,interpreter/llvm-project/llvm/utils/update_mca_test_checks.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/update_mca_test_checks.py,1,['avoid'],['avoid']
Safety,"# Ignoring potential typos that will not be matched later due to a too low; # threshold, in order to avoid potentially long computation times.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/filecheck_lint/filecheck_lint.py:101,avoid,avoid,101,interpreter/llvm-project/llvm/utils/filecheck_lint/filecheck_lint.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/filecheck_lint/filecheck_lint.py,1,['avoid'],['avoid']
Safety,"# Import here to avoid circular dependencies in main module",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/__init__.py:17,avoid,avoid,17,bindings/experimental/distrdf/python/DistRDF/__init__.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/__init__.py,1,['avoid'],['avoid']
Safety,"# Improving numerical stability; # -----------------------------; # There is one more problem with binned fits that is related to the binning; # effects because often, a binned fit is affected by both problems.; #; # The issue is numerical stability for fits with a greatly different number; # of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; # the NLL, where \f[n\f] is the number of observations in the bin, and; # \f[p\f] the predicted probability to have an event in that bin. The; # difference in the logarithms for each bin is small, but the difference in; # \f[n\f] can be orders of magnitudes! Therefore, when summing these terms,; # lots of numerical precision is lost for the bins with less events.; # We can study this with the example of an exponential plus a Gaussian. The; # Gaussian is only a faint signal in the tail of the exponential where; # there are not so many events. And we can't afford any precision loss for; # these bins, otherwise we can't fit the Gaussian.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf614_binned_fit_problems.py:452,predict,predicted,452,tutorials/roofit/rf614_binned_fit_problems.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf614_binned_fit_problems.py,1,['predict'],['predicted']
Safety,"# In a git bash terminal, the writes to sys.stderr aren't visible; # on screen immediately. Flush them here to avoid broken/misoredered; # output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/LitConfig.py:111,avoid,avoid,111,interpreter/llvm-project/llvm/utils/lit/lit/LitConfig.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/LitConfig.py,1,['avoid'],['avoid']
Safety,"# It may happen that the user is connected to a batch system. We try; # to import the 'dask_jobqueue' module lazily to avoid a dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py:119,avoid,avoid,119,bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Backends/Dask/Backend.py,1,['avoid'],['avoid']
Safety,# Itanium manglings are of the form _Z<identifier_mangling><type_mangling>. We; # demangle the identifier mangling to identify symbols that can be safely; # discarded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/extract_symbols.py:147,safe,safely,147,interpreter/llvm-project/llvm/utils/extract_symbols.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/extract_symbols.py,1,['safe'],['safely']
Safety,"# Keep mangled llvm:: and clang:: function symbols. How we detect these is a; # bit of a mess and imprecise, but that avoids having to completely demangle; # the symbol name. The outermost namespace is at the end of the identifier; # mangling, and the identifier mangling is followed by the type mangling, so; # we look for (llvm|clang)@@ followed by something that looks like a; # function type mangling. To spot a function type we use (this is derived; # from clang/lib/AST/MicrosoftMangle.cpp):; # <function-type> ::= <function-class> <this-cvr-qualifiers>; # <calling-convention> <return-type>; # <argument-list> <throw-spec>; # <function-class> ::= [A-Z]; # <this-cvr-qualifiers> ::= [A-Z0-9_]*; # <calling-convention> ::= [A-JQ]; # <return-type> ::= .+; # <argument-list> ::= X (void); # ::= .+@ (list of types); # ::= .*Z (list of types, varargs); # <throw-spec> ::= exceptions are not allowed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/extract_symbols.py:59,detect,detect,59,interpreter/llvm-project/llvm/utils/extract_symbols.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/extract_symbols.py,2,"['avoid', 'detect']","['avoids', 'detect']"
Safety,"# Larger timeouts (one year, positive infinity) don't work on Windows.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/run.py:9,timeout,timeouts,9,interpreter/llvm-project/llvm/utils/lit/lit/run.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/run.py,1,['timeout'],['timeouts']
Safety,"# Make prediction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/tmva102_Testing.py:7,predict,prediction,7,tutorials/tmva/tmva102_Testing.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/tmva102_Testing.py,1,['predict'],['prediction']
Safety,"# Make prediction and calculate accuracy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/RBatchGenerator_PyTorch.py:7,predict,prediction,7,tutorials/tmva/RBatchGenerator_PyTorch.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/RBatchGenerator_PyTorch.py,1,['predict'],['prediction']
Safety,"# Make prediction and calculate loss",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/RBatchGenerator_PyTorch.py:7,predict,prediction,7,tutorials/tmva/RBatchGenerator_PyTorch.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/RBatchGenerator_PyTorch.py,1,['predict'],['prediction']
Safety,"# Make prediction of GNN",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_SOFIE_GNN.py:7,predict,prediction,7,tutorials/tmva/TMVA_SOFIE_GNN.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_SOFIE_GNN.py,1,['predict'],['prediction']
Safety,"# Make prediction of GNN. This will initialize the GNN with weights",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_SOFIE_GNN_Parser.py:7,predict,prediction,7,tutorials/tmva/TMVA_SOFIE_GNN_Parser.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_SOFIE_GNN_Parser.py,1,['predict'],['prediction']
Safety,"# Make sure the initial test passes, if not then (a) either; # the user doesn't expect monotonicity, and we may end up; # doing O(N^2) tests, or (b) the test is wrong. Avoid the; # O(N^2) case unless user requests it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py:168,Avoid,Avoid,168,interpreter/llvm-project/clang/utils/token-delta.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/token-delta.py,1,['Avoid'],['Avoid']
Safety,"# Make sure we don't do any redundant pythonization, e.g. if we; # use a version of cppyy that caches both in the namespace and; # in the _instantiations attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/__init__.py:28,redund,redundant,28,bindings/pyroot/pythonizations/python/ROOT/_pythonization/__init__.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/__init__.py,1,['redund'],['redundant']
Safety,# On OS X the 'cc' and 'c++' compilers are wrappers for; # 'clang' therefore both call would be logged. To avoid; # this the hash does not contain the first word of the; # command.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py:107,avoid,avoid,107,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/intercept.py,1,['avoid'],['avoid']
Safety,"# Parameters:; # klass: class to be pythonized; # name: string containing the name of the class; # Pythonizations that are common to TTree and its subclasses.; # To avoid duplicating the same logic in the pythonizors of; # the subclasses, inject the pythonizations for all the target; # classes here.; # Pythonic iterator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_ttree.py:165,avoid,avoid,165,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_ttree.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_ttree.py,1,['avoid'],['avoid']
Safety,"# Plot ""physics"" slice of simultaneous pdf.; # NB: You *must* project the sample index category with data using ProjWData as; # a RooSimultaneous makes no prediction on the shape in the index category and; # can thus not be integrated. In other words: Since the PDF doesn't know the; # number of events in the different category states, it doesn't know how much; # of each component it has to project out. This info is read from the data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf501_simultaneouspdf.py:155,predict,prediction,155,tutorials/roofit/rf501_simultaneouspdf.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf501_simultaneouspdf.py,1,['predict'],['prediction']
Safety,"# Pretty printers for gdb; # \author: Stephan Hageboeck, CERN; # These pretty printers will make ROOT objects more readable when printed in gdb.; # If the pretty-printed output is not sufficient, one can always use ""print /r <object>""; # for raw printing.; #; # When a debug build is used, they will be installed next to the ROOT libraries.; # gdb will load them automatically if the auto-load-safe-path is set to ROOT's library directory.; # For this, one has to add `add-auto-load-safe-path <ROOT lib dir>` to .gdbinit; #; # If loaded successfully, typing `info pretty-printer` at the gdb prompt should list the; # printers registered at the end of this file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/gdbPrinters/libCore.so-gdb.py:394,safe,safe-path,394,misc/gdbPrinters/libCore.so-gdb.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/gdbPrinters/libCore.so-gdb.py,4,['safe'],['safe-path']
Safety,# Prevent further recursion if the timeout has been hit; # as we should try avoid launching more processes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:35,timeout,timeout,35,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,2,"['avoid', 'timeout']","['avoid', 'timeout']"
Safety,"# PyTorch has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_CNN_Classification.py:44,avoid,avoid,44,tutorials/tmva/TMVA_CNN_Classification.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_CNN_Classification.py,1,['avoid'],['avoid']
Safety,# Pygment lexer are sometimes out of date (when parsing LLVM for example) or; # wrong. Suppress the warning so the build doesn't abort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py:129,abort,abort,129,interpreter/llvm-project/llvm/docs/conf.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/conf.py,1,['abort'],['abort']
Safety,# Recover namedtuple from json when coming from analyze-cc or analyze-c++,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py:2,Recover,Recover,2,interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/lib/libscanbuild/analyze.py,1,['Recover'],['Recover']
Safety,"# Reopen stdout in binary mode to avoid CRLF translation. The versions; # of echo we are replacing on Windows all emit plain LF, and the LLVM; # tests now depend on this.; # When we open as binary, however, this also means that we have to write; # 'bytes' objects to stdout instead of 'str' objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:34,avoid,avoid,34,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,1,['avoid'],['avoid']
Safety,"# Request a the pull plot of mean. The pulls will be one-sided because; # `mean` is limited to 1.8.; # Note that RooFit will have trouble to compute the pulls because the parameters; # are called `mean` in the fit, but `mean2` in the generator model. It is not obvious; # that these are related. RooFit will nevertheless compute pulls, but complain that; # this is risky.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf802_mcstudy_addons.py:365,risk,risky,365,tutorials/roofit/rf802_mcstudy_addons.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf802_mcstudy_addons.py,1,['risk'],['risky']
Safety,"# RooFit before ROOT 6.24; # --------------------------------; # Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; # the starting values of the parameters without finding any improvement.; # Set up the parameters such that the PDF would come out negative. The PDF is now undefined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf612_recoverFromInvalidParameters.py:100,recover,recover,100,tutorials/roofit/rf612_recoverFromInvalidParameters.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf612_recoverFromInvalidParameters.py,1,['recover'],['recover']
Safety,"# Slice to avoid the dummy column of 10's",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/tf_pycallables.py:11,avoid,avoid,11,bindings/pyroot/pythonizations/test/tf_pycallables.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/tf_pycallables.py,1,['avoid'],['avoid']
Safety,"# So a small sanity check:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/histfactory/makeQuickModel.py:13,sanity check,sanity check,13,tutorials/histfactory/makeQuickModel.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/histfactory/makeQuickModel.py,1,['sanity check'],['sanity check']
Safety,"# Somehow redundant, but good to test with real syntax",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/titer_iterator.py:10,redund,redundant,10,bindings/pyroot/pythonizations/test/titer_iterator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/titer_iterator.py,1,['redund'],['redundant']
Safety,"# Split pattern avoiding multiple slash problem",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/main/python/cmdLineUtils.py:16,avoid,avoiding,16,main/python/cmdLineUtils.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/main/python/cmdLineUtils.py,1,['avoid'],['avoiding']
Safety,# Suite names are not necessarily unique. Include object identity in sort; # key to avoid mixing tests of different suites.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/reports.py:84,avoid,avoid,84,interpreter/llvm-project/llvm/utils/lit/lit/reports.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/reports.py,1,['avoid'],['avoid']
Safety,# Summary file - contains the summary of the failures. Ex: This info can be be; # displayed when buildbot detects a build failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:106,detect,detects,106,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,1,['detect'],['detects']
Safety,"# TContext and TFile context managers can also be used in conjunction, allowing; # for safely:; # - Opening a file, creating, modifying, writing and reading objects in it.; # - Closing the file, storing it on disk.; # - Restoring the previous value of gDirectory to the latest file opened before; # this context, rather than to the global ROOT.gROOT; # Remember that the TContext must be initialized before the TFile, otherwise the; # current directory would already be set to the file opened for this context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/pyroot006_tcontext_context_manager.py:87,safe,safely,87,tutorials/pyroot/pyroot006_tcontext_context_manager.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/pyroot006_tcontext_context_manager.py,1,['safe'],['safely']
Safety,# TODO Remove the str form which is used by update_test_checks.py and; # update_llc_test_checks.py; # The safer list form is used by update_cc_test_checks.py,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/UpdateTestChecks/common.py:106,safe,safer,106,interpreter/llvm-project/llvm/utils/UpdateTestChecks/common.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/UpdateTestChecks/common.py,1,['safe'],['safer']
Safety,"# TODO: This shouldn't be triggered if entries == 1. The current minimum; # amount of partitions is 2. We need a robust reducer that smartly; # becomes no-op if npartitions == 1 to avoid this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py:181,avoid,avoid,181,bindings/experimental/distrdf/python/DistRDF/HeadNode.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/HeadNode.py,1,['avoid'],['avoid']
Safety,"# The RBatchGenerator will create a separate C++ thread for I/O.; # Enable thread safety in ROOT from here, to make sure there is no; # interference between the main Python thread (which might call into; # cling via cppyy) and the I/O thread.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py:82,safe,safety,82,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_tmva/_batchgenerator.py,1,['safe'],['safety']
Safety,# The current implementation needs psutil on some platforms to set; # a timeout per test. Check it's available.; # See lit.util.killProcessAndChildren(),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/LitConfig.py:72,timeout,timeout,72,interpreter/llvm-project/llvm/utils/lit/lit/LitConfig.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/LitConfig.py,1,['timeout'],['timeout']
Safety,"# The histogram model can be passed as the keyword argument 'model'. All; # Histo*D specializations have the same name for this argument. If it is; # present, we know the execution can proceed safely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Operation.py:193,safe,safely,193,bindings/experimental/distrdf/python/DistRDF/Operation.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/python/DistRDF/Operation.py,1,['safe'],['safely']
Safety,"# The initial call to _kill() from the timer thread already happened so; # we need to call it again from this thread, otherwise this process; # will be left to run even though the timeout was already hit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:180,timeout,timeout,180,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,1,['timeout'],['timeout']
Safety,"# The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf612_recoverFromInvalidParameters.py:23,recover,recovery,23,tutorials/roofit/rf612_recoverFromInvalidParameters.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf612_recoverFromInvalidParameters.py,2,['recover'],['recovery']
Safety,# This avoids pretty-printing huge statements such as CompoundStmt.; # Such statements show up only at [Pre|Post]StmtPurgeDeadSymbols,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py:7,avoid,avoids,7,interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/exploded-graph-rewriter.py,1,['avoid'],['avoids']
Safety,"# This could be selectively enabled with an optional invocation argument.; # Disabled for now: better to check everything. Be safe rather than sorry.; # Handle the first line of the function body as a special case because; # it's often just noise (a useless asm comment or entry label).; # if func_body[0].startswith(""#"") or func_body[0].startswith(""entry:""):; # is_blank_line = True; # else:; # output_lines.append('%s %s: %s' % (comment_marker, checkprefix, func_body[0])); # is_blank_line = False",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/UpdateTestChecks/common.py:126,safe,safe,126,interpreter/llvm-project/llvm/utils/UpdateTestChecks/common.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/UpdateTestChecks/common.py,1,['safe'],['safe']
Safety,# This shouldn't happen when the sanity check works...; # Maybe link_test isn't deterministic?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/abtest.py:33,sanity check,sanity check,33,interpreter/llvm-project/llvm/utils/abtest.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/abtest.py,1,['sanity check'],['sanity check']
Safety,"# To avoid deadlock, we use a single stderr stream for piped; # output. This is null until we have seen some output using; # stderr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:5,avoid,avoid,5,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,1,['avoid'],['avoid']
Safety,# Tweak the PATH to include the tools dir and the scripts dir.; # Put Clang first to avoid LLVM from overriding out-of-tree clang; # builds.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/llvm/config.py:85,avoid,avoid,85,interpreter/llvm-project/llvm/utils/lit/lit/llvm/config.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/llvm/config.py,1,['avoid'],['avoid']
Safety,# Use the helper even when no timeout is required to make; # other code simpler (i.e. avoid bunch of ``!= None`` checks),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:30,timeout,timeout,30,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,2,"['avoid', 'timeout']","['avoid', 'timeout']"
Safety,"# Used to shut down the thread safely at teardown time",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_application.py:31,safe,safely,31,bindings/pyroot/pythonizations/python/ROOT/_application.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_application.py,1,['safe'],['safely']
Safety,"# We use b to run square_vec where the values must be < 4 to avoid exceeding longs max value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_numba.py:61,avoid,avoid,61,bindings/pyroot/cppyy/cppyy/test/test_numba.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_numba.py,1,['avoid'],['avoid']
Safety,"# We will control the output level in a few places to avoid; # verbose progress messages. We start by keeping track; # of the current threshold on messages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/HybridInstructional.py:54,avoid,avoid,54,tutorials/roostats/HybridInstructional.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/HybridInstructional.py,2,['avoid'],['avoid']
Safety,"# XGBoost has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/rbdt_xgboost.py:44,avoid,avoid,44,tmva/tmva/test/rbdt_xgboost.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/rbdt_xgboost.py,1,['avoid'],['avoid']
Safety,"# avoid printing duplicated entries, for C macros!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/gen_std.py:2,avoid,avoid,2,interpreter/llvm-project/clang/tools/include-mapping/gen_std.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/include-mapping/gen_std.py,1,['avoid'],['avoid']
Safety,"# can only recover once from each error on Windows, which is functionally; # enough, but precludes further testing here (change: now drop all, see above,; # as on some MSVC builds, no signals are caught ??)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_fragile.py:11,recover,recover,11,bindings/pyroot/cppyy/cppyy/test/test_fragile.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_fragile.py,1,['recover'],['recover']
Safety,"# check if type mismatch is correctly detected",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/ttree_setbranchaddress.py:38,detect,detected,38,bindings/pyroot/pythonizations/test/ttree_setbranchaddress.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/ttree_setbranchaddress.py,2,['detect'],['detected']
Safety,# early exit to avoid wasting time on lines without; # conditional substitutions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:16,avoid,avoid,16,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,1,['avoid'],['avoid']
Safety,"# env calling an in-process builtin is useless, so we take the safe; # approach of complaining.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:63,safe,safe,63,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,1,['safe'],['safe']
Safety,"# https://github.com/root-project/root/issues/12817; # The threshold for the memory used is generously chosen to avoid tests; # spuriously failing b/c of fluctuations and is also well below the; # memory needed before the fix to the issue mentioned above, i.e. about; # 4 GB and several minutes to complete (!)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/pretty_printing.py:113,avoid,avoid,113,bindings/pyroot/pythonizations/test/pretty_printing.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/pretty_printing.py,1,['avoid'],['avoid']
Safety,"# join the thread with a timeout after 0.1s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_concurrent.py:25,timeout,timeout,25,bindings/pyroot/cppyy/cppyy/test/test_concurrent.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/test_concurrent.py,1,['timeout'],['timeout']
Safety,"# needed for RTX NVidia card and to avoid TF allocates all GPU memory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_CNN_Classification.py:36,avoid,avoid,36,tutorials/tmva/TMVA_CNN_Classification.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_CNN_Classification.py,1,['avoid'],['avoid']
Safety,"# ninja -t deps output consists of stanzas of the following form,; # separated by a blank line:; #; # target: [other information we don't need]; # some_file.cpp; # some_header.h; # other_header.h; #; # We parse this ad-hoc by detecting the four leading spaces in a; # source-file line, and the colon in a target line. 'currtarget' stores; # the last target name we saw.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/check_ninja_deps.py:226,detect,detecting,226,interpreter/llvm-project/llvm/utils/check_ninja_deps.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/check_ninja_deps.py,1,['detect'],['detecting']
Safety,"# noqa: avoid PEP8 F841",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/test_callable_generator.py:8,avoid,avoid,8,bindings/experimental/distrdf/test/test_callable_generator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/test_callable_generator.py,11,['avoid'],['avoid']
Safety,"# noqa: avoid PEP8 F841; # After the change of reference, it becomes; # [1, 2, 2, 3, 2, 2]; # that is, the Filter is appended at the end of the list, it is fine; # because it holds a reference to the ID of the father.; # Generate and execute the mapper",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/test_callable_generator.py:8,avoid,avoid,8,bindings/experimental/distrdf/test/test_callable_generator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/test_callable_generator.py,1,['avoid'],['avoid']
Safety,"# noqa: avoid PEP8 F841; # Generate and execute the mapper",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/test_callable_generator.py:8,avoid,avoid,8,bindings/experimental/distrdf/test/test_callable_generator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/test_callable_generator.py,4,['avoid'],['avoid']
Safety,"# noqa: avoid PEP8 F841; # Remove references from n2 (which shouldn't affect the graph)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/test_callable_generator.py:8,avoid,avoid,8,bindings/experimental/distrdf/test/test_callable_generator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/test_callable_generator.py,1,['avoid'],['avoid']
Safety,"# noqa: avoid PEP8 F841; # Remove user references from n4, n3, n2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/test_callable_generator.py:8,avoid,avoid,8,bindings/experimental/distrdf/test/test_callable_generator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/test_callable_generator.py,1,['avoid'],['avoid']
Safety,"# noqa: avoid PEP8 F841; # Transformation pruning, n5 was earlier a transformation node",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/test_callable_generator.py:8,avoid,avoid,8,bindings/experimental/distrdf/test/test_callable_generator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/test_callable_generator.py,1,['avoid'],['avoid']
Safety,"# noqa: avoid PEP8 F841; # Until here the graph would be:; # [1, 2, 2, 3, 3, 2]; # Reason for pruning (change of reference)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/test_callable_generator.py:8,avoid,avoid,8,bindings/experimental/distrdf/test/test_callable_generator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/test_callable_generator.py,1,['avoid'],['avoid']
Safety,"# realpath variants; # Windows paths with substitute drives are not expanded by default; # as they are used to avoid MAX_PATH issues, but sometimes we do; # need the fully expanded path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py:111,avoid,avoid,111,interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/TestRunner.py,1,['avoid'],['avoid']
Safety,"# runners should never have root permissions but be on the safe side",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/.github/workflows/root-ci-config/build_root.py:59,safe,safe,59,.github/workflows/root-ci-config/build_root.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/.github/workflows/root-ci-config/build_root.py,1,['safe'],['safe']
Safety,"# some reverse-computation that can't be avoided with the current C++ RooDataHist interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_roofit/_roodatahist.py:41,avoid,avoided,41,bindings/pyroot/pythonizations/python/ROOT/_pythonization/_roofit/_roodatahist.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_pythonization/_roofit/_roodatahist.py,1,['avoid'],['avoided']
Safety,"# switch off MT in OpenBLAS to avoid conflict with tbb",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_RNN_Classification.py:31,avoid,avoid,31,tutorials/tmva/TMVA_RNN_Classification.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_RNN_Classification.py,1,['avoid'],['avoid']
Safety,# the 2 is a safety factor; # Importing the resource module will likely fail on Windows.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/run.py:13,safe,safety,13,interpreter/llvm-project/llvm/utils/lit/lit/run.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/lit/run.py,1,['safe'],['safety']
Safety,"# to avoid clipping the bottom zero, redraw a small axis",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/ratioplot.py:5,avoid,avoid,5,tutorials/pyroot/ratioplot.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/ratioplot.py,1,['avoid'],['avoid']
Safety,"# typing package doesn't have a separate type for Queue, but has a generic stub; # We still want to have a type-safe checked project queue, for this reason,; # we specify generic type for mypy.; #; # It is a common workaround for this situation:; # https://mypy.readthedocs.io/en/stable/common_issues.html#using-classes-that-are-generic-in-stubs-but-not-at-runtime",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py:112,safe,safe,112,interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/analyzer/SATestBuild.py,1,['safe'],['safe']
Safety,"#!/usr/bin/env python; ## \file; ## \ingroup tutorial_tmva_pytorch; ## \notebook -nodraw; ## This tutorial shows how to apply a trained model to new data (regression).; ##; ## \macro_code; ##; ## \date 2020; ## \author Anirudh Dagar <anirudhdagar6@gmail.com> - IIT, Roorkee; # PyTorch has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/pytorch/ApplicationRegressionPyTorch.py:319,avoid,avoid,319,tutorials/tmva/pytorch/ApplicationRegressionPyTorch.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/pytorch/ApplicationRegressionPyTorch.py,1,['avoid'],['avoid']
Safety,"#!/usr/bin/env python; ## \file; ## \ingroup tutorial_tmva_pytorch; ## \notebook -nodraw; ## This tutorial shows how to apply a trained model to new data.; ##; ## \macro_code; ##; ## \date 2020; ## \author Anirudh Dagar <anirudhdagar6@gmail.com> - IIT, Roorkee; # PyTorch has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/pytorch/ApplicationClassificationPyTorch.py:306,avoid,avoid,306,tutorials/tmva/pytorch/ApplicationClassificationPyTorch.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/pytorch/ApplicationClassificationPyTorch.py,1,['avoid'],['avoid']
Safety,"#!/usr/bin/env python; ## \file; ## \ingroup tutorial_tmva_pytorch; ## \notebook -nodraw; ## This tutorial shows how to do classification in TMVA with neural networks; ## trained with PyTorch.; ##; ## \macro_code; ##; ## \date 2020; ## \author Anirudh Dagar <anirudhdagar6@gmail.com> - IIT, Roorkee; # PyTorch has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/pytorch/ClassificationPyTorch.py:344,avoid,avoid,344,tutorials/tmva/pytorch/ClassificationPyTorch.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/pytorch/ClassificationPyTorch.py,1,['avoid'],['avoid']
Safety,"#!/usr/bin/env python; ## \file; ## \ingroup tutorial_tmva_pytorch; ## \notebook -nodraw; ## This tutorial shows how to do multiclass classification in TMVA with neural; ## networks trained with PyTorch.; ##; ## \macro_code; ##; ## \date 2020; ## \author Anirudh Dagar <anirudhdagar6@gmail.com> - IIT, Roorkee; # PyTorch has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/pytorch/MulticlassPyTorch.py:355,avoid,avoid,355,tutorials/tmva/pytorch/MulticlassPyTorch.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/pytorch/MulticlassPyTorch.py,1,['avoid'],['avoid']
Safety,"#!/usr/bin/env python; ## \file; ## \ingroup tutorial_tmva_pytorch; ## \notebook -nodraw; ## This tutorial shows how to do regression in TMVA with neural networks; ## trained with PyTorch.; ##; ## \macro_code; ##; ## \date 2020; ## \author Anirudh Dagar <anirudhdagar6@gmail.com> - IIT, Roorkee; # PyTorch has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/pytorch/RegressionPyTorch.py:340,avoid,avoid,340,tutorials/tmva/pytorch/RegressionPyTorch.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/pytorch/RegressionPyTorch.py,1,['avoid'],['avoid']
Safety,"## Create TMVA Factory; # Create the Factory class. Later you can choose the methods; # whose performance you'd like to investigate.; # The factory is the major TMVA object you have to interact with. Here is the list of parameters you need to pass; # - The first argument is the base of the name of all the output; # weight files in the directory weight/ that will be created with the; # method parameters; # - The second argument is the output file for the training results; # - The third argument is a string option defining some general configuration for the TMVA session.; # For example all TMVA output can be suppressed by removing the ""!"" (not) in front of the ""Silent"" argument in the; # option string; # - note that we disable any pre-transformation of the input variables and we avoid computing correlations between; # input variables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_CNN_Classification.py:788,avoid,avoid,788,tutorials/tmva/TMVA_CNN_Classification.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/TMVA_CNN_Classification.py,1,['avoid'],['avoid']
Safety,"## Restricting the fit range; The fit range can be restricted through. fit->SetRangeX(first bin #, last bin #);; and freed using. fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using. fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also. fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through. fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding. fit->IncludeBin(bin #);. ## Weights histograms; Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through. fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. ## Obtaining fit results; The fit is carried out through. Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through. fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by. TH1* result = fit->GetPlot();; ## Using different histograms; It is possible to change the histogram being fitted through. fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through. fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). ## Errors; Any serious inconsistency results in an error.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:4667,predict,prediction,4667,hist/hist/src/TFractionFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx,1,['predict'],['prediction']
Safety,"## \file; ## \ingroup tutorial_dataframe; ## \notebook -draw; ## A single top analysis using the ATLAS Open Data release of 2020, with RDataFrame.; ##; ## This tutorial is the analysis of single top production adapted from the ATLAS Open Data release in 2020; ## (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector; ## during 2016 at a center-of-mass energy of 13 TeV. Top quarks with a mass of about 172 GeV are mostly; ## produced in pairs but also appear alone, dominantly from the decays of a W boson in association with a light jet.; ##; ## The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data.; ## By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with; ## the --full-dataset argument and you can also run only on a fraction of the original dataset using the argument --lumi-scale.; ##; ## See the [corresponding spec json file](https://github.com/root-project/root/blob/master/tutorials/dataframe/df107_SingleTopAnalysis.json).; ##; ## \macro_image; ## \macro_code; ## \macro_output; ##; ## \date July 2020; ## \author Stefan Wunsch (KIT, CERN)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df107_SingleTopAnalysis.py:358,detect,detector,358,tutorials/dataframe/df107_SingleTopAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df107_SingleTopAnalysis.py,1,['detect'],['detector']
Safety,"## \file; ## \ingroup tutorial_dataframe; ## \notebook -draw; ## An example of complex analysis with RDataFrame: reconstructing the Higgs boson.; ##; ## This tutorial is a simplified but yet complex example of an analysis reconstructing the Higgs boson decaying to two Z; ## bosons from events with four leptons. The data and simulated events are taken from CERN OpenData representing a; ## subset of the data recorded in 2012 with the CMS detector at the LHC. The tutorials follows the Higgs to four leptons; ## analysis published on CERN Open Data portal ([10.7483/OPENDATA.CMS.JKB8.RR42](http://opendata.cern.ch/record/5500)).; ## The resulting plots show the invariant mass of the selected four lepton systems in different decay modes (four muons,; ## four electrons and two of each kind) and in a combined plot indicating the decay of the Higgs boson with a mass of; ## about 125 GeV.; ##; ## The following steps are performed for each sample with data and simulated events in order to reconstruct the Higgs; ## boson from the selected muons and electrons:; ## 1. Select interesting events with multiple cuts on event properties, e.g., number of leptons, kinematics of the; ## leptons and quality of the tracks.; ## 2. Reconstruct two Z bosons of which only one on the mass shell from the selected events and apply additional cuts on; ## the reconstructed objects.; ## 3. Reconstruct the Higgs boson from the remaining Z boson candidates and calculate its invariant mass.; ##; ## Another aim of this version of the tutorial is to show a way to blend C++ and Python code. All the functions that; ## make computations on data to define new columns or filter existing ones in a precise way, better suited to be written; ## in C++, have been moved to a header that is then declared to the ROOT C++ interpreter. The functions that instead; ## create nodes of the computational graph (e.g. Filter, Define) remain inside the main Python script.; ##; ## The tutorial has the fast mode enabled by default,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df103_NanoAODHiggsAnalysis.py:440,detect,detector,440,tutorials/dataframe/df103_NanoAODHiggsAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df103_NanoAODHiggsAnalysis.py,1,['detect'],['detector']
Safety,"## \file; ## \ingroup tutorial_dataframe; ## \notebook -draw; ## The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame.; ##; ## This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020; ## (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector; ## during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson; ## to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads; ## to a narrow invariant mass peak on top a relatively smooth and small background, revealing; ## the Higgs at 125 GeV.; ## Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting.; ## The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; ##; ## See the [corresponding spec json file](https://github.com/root-project/root/blob/master/tutorials/dataframe/df106_HiggsToFourLeptons_spec.json).; ##; ## \macro_image; ## \macro_code; ## \macro_output; ##; ## \date March 2020, August 2022, August 2023; ## \authors Stefan Wunsch (KIT, CERN), Julia Mathe (CERN), Marta Czurylo (CERN)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df106_HiggsToFourLeptons.py:354,detect,detector,354,tutorials/dataframe/df106_HiggsToFourLeptons.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df106_HiggsToFourLeptons.py,1,['detect'],['detector']
Safety,"## \file; ## \ingroup tutorial_dataframe; ## \notebook -draw; ## The Higgs to two photons analysis from the ATLAS Open Data 2020 release, with RDataFrame.; ##; ## This tutorial is the Higgs to two photons analysis from the ATLAS Open Data release in 2020; ## (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector; ## during 2016 at a center-of-mass energy of 13 TeV. Although the Higgs to two photons decay is very rare,; ## the contribution of the Higgs can be seen as a narrow peak around 125 GeV because of the excellent; ## reconstruction and identification efficiency of photons at the ATLAS experiment.; ##; ## The analysis is translated to a RDataFrame workflow processing 1.7 GB of simulated events and data.; ##; ## \macro_image; ## \macro_code; ## \macro_output; ##; ## \date February 2020; ## \author Stefan Wunsch (KIT, CERN)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df104_HiggsToTwoPhotons.py:351,detect,detector,351,tutorials/dataframe/df104_HiggsToTwoPhotons.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df104_HiggsToTwoPhotons.py,1,['detect'],['detector']
Safety,"## \file; ## \ingroup tutorial_dataframe; ## \notebook -draw; ## The W boson mass analysis from the ATLAS Open Data release of 2020, with RDataFrame.; ##; ## This tutorial is the analysis of the W boson mass taken from the ATLAS Open Data release in 2020; ## (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector; ## during 2016 at a center-of-mass energy of 13 TeV. W bosons are produced frequently at the LHC and; ## are an important background to studies of Standard Model processes, for example the Higgs boson analyses.; ##; ## The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data.; ## By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with; ## the --full-dataset argument and you can also run only on a fraction of the original dataset using the argument --lumi-scale.; ##; ## See the [corresponding spec json file](https://github.com/root-project/root/blob/master/tutorials/dataframe/df105_WBosonAnalysis.json).; ##; ## \macro_image; ## \macro_code; ## \macro_output; ##; ## \date March 2020; ## \author Stefan Wunsch (KIT, CERN)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df105_WBosonAnalysis.py:354,detect,detector,354,tutorials/dataframe/df105_WBosonAnalysis.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/df105_WBosonAnalysis.py,1,['detect'],['detector']
Safety,"## \file; ## \ingroup tutorial_pyroot; ## This macro generates two views of the NA49 detector.; ##; ## To have a better and dynamic view of any of these pads,; ## you can click with the middle button of your mouse to select it.; ## Then select ""View with x3d"" in the VIEW menu of the Canvas.; ## Once in x3d, you are in wireframe mode by default.; ## You can switch to:; ## - Hidden Line mode by typing E; ## - Solid mode by typing R; ## - Wireframe mode by typing W; ## - Stereo mode by clicking S (and you need special glasses); ## - To leave x3d type Q; ##; ## \macro_code; ##; ## \author Wim Lavrijsen",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/na49view.py:85,detect,detector,85,tutorials/pyroot/na49view.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/na49view.py,1,['detect'],['detector']
Safety,"## \file; ## \ingroup tutorial_pyroot; ## \notebook; ## This macro is an example of graphs in log scales with annotations.; ##; ## The presented results; ## are predictions of invariant cross-section of Direct Photons produced; ## at RHIC energies, based on the universality of scaling function H(z).; ##; ##; ## These Figures were published in JINR preprint E2-98-64, Dubna,; ## 1998 and submitted to CPC.; ##; ## \macro_image; ## \macro_code; ##; ## \authors Michael Tokarev, Elena Potrebenikova (JINR Dubna)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/zdemo.py:161,predict,predictions,161,tutorials/pyroot/zdemo.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/pyroot/zdemo.py,1,['predict'],['predictions']
Safety,"## \file; ## \ingroup tutorial_rcanvas; ## The Higgs to two photons analysis from the ATLAS Open Data 2020 release, with RDataFrame.; ##; ## This tutorial is the Higgs to two photons analysis from the ATLAS Open Data release in 2020; ## (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector; ## during 2016 at a center-of-mass energy of 13 TeV. Although the Higgs to two photons decay is very rare,; ## the contribution of the Higgs can be seen as a narrow peak around 125 GeV because of the excellent; ## reconstruction and identification efficiency of photons at the ATLAS experiment.; ##; ## The analysis is translated to a RDataFrame workflow processing 1.7 GB of simulated events and data.; ##; ## This macro is replica of tutorials/dataframe/df104_HiggsToTwoPhotons.py, but with usage of ROOT7 graphics; ## Run macro with python3 -i df104.py command to get interactive canvas; ##; ## \macro_image (df104.png); ## \macro_code; ##; ## \date 2021-06-15; ## \authors Stefan Wunsch (KIT, CERN) Sergey Linev (GSI)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/rcanvas/df104.py:329,detect,detector,329,tutorials/rcanvas/df104.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/rcanvas/df104.py,1,['detect'],['detector']
Safety,"## \file; ## \ingroup tutorial_rcanvas; ## The W boson mass analysis from the ATLAS Open Data release of 2020, with RDataFrame.; ##; ## This tutorial is the analysis of the W boson mass taken from the ATLAS Open Data release in 2020; ## (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector; ## during 2016 at a center-of-mass energy of 13 TeV. W bosons are produced frequently at the LHC and; ## are an important background to studies of Standard Model processes, for example the Higgs boson analyses.; ##; ## The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data.; ## By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with; ## the --full-dataset argument and you can also run only on a fraction of the original dataset using the argument --lumi-scale.; ##; ## This macro is replica of tutorials/dataframe/df105_WBosonAnalysis.py, but with usage of ROOT7 graphics; ## Run macro with python3 -i df105.py command to get interactive canvas; ##; ## \macro_image (rcanvas_js); ## \macro_code; ##; ## \date March 2020; ## \authors Stefan Wunsch (KIT, CERN) Sergey Linev (GSI)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/rcanvas/df105.py:332,detect,detector,332,tutorials/rcanvas/df105.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/rcanvas/df105.py,1,['detect'],['detector']
Safety,"## \file; ## \ingroup tutorial_roofit; ## \notebook -nodraw; ## This macro demonstrates how to set up a fit in two ranges for plain; ## likelihoods and extended likelihoods.; ##; ## ### 1. Shape fits (plain likelihood); ##; ## If you fit a non-extended pdf in two ranges, e.g. `pdf.fitTo(data,Range=""Range1,Range2"")`,; ## it will fit the shapes in the two selected ranges and also take into account the relative; ## predicted yields in those ranges.; ##; ## This is useful for example to represent a full-range fit, but with a; ## blinded signal region inside it.; ##; ##; ## ### 2. Shape+rate fits (extended likelihood); ##; ## If your pdf is extended, i.e. measuring both the distribution in the observable as well; ## as the event count in the fitted region, some intervention is needed to make fits in ranges; ## work in a way that corresponds to intuition.; ##; ## If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence; ## the expected event count will converge to a number that is smaller than what's visible in a plot.; ## In such cases, it is often preferred to interpret the extended term with respect to the full range; ## that's plotted, i.e., apply a correction to the extended likelihood term in such a way; ## that the interpretation of the expected event count remains that of the full range. This can; ## be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the; ## fitted range) in the Poisson term that represents the extended likelihood term.; ##; ## If an extended likelihood fit is performed over *two* sub-ranges, this correction is; ## even more important: without it, each component likelihood would have a different interpretation; ## of the expected event count (each corresponding to the count in its own region), and a joint; ## fit of these regions with different interpretations of the same model parameter results; ## in a number that is not easily interpreted.; ##; ## If both re",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf204b_extendedLikelihood_rangedFit.py:416,predict,predicted,416,tutorials/roofit/rf204b_extendedLikelihood_rangedFit.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf204b_extendedLikelihood_rangedFit.py,1,['predict'],['predicted']
Safety,"## \file; ## \ingroup tutorial_roofit; ## \notebook; ## Likelihood and minimization: Recover from regions where the function is not defined.; ##; ## We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form; ## \f[; ## \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; ## \f]; ## where \f$ \mathcal{N} \f$ is a normalisation factor. Unless the parameters are chosen carefully,; ## this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes; ## an error to the minimiser, which might try to recover.; ##; ## \macro_code; ## \macro_output; ##; ## \date June 2021; ## \author Harshal Shende, Stephan Hageboeck (C++ version)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf612_recoverFromInvalidParameters.py:85,Recover,Recover,85,tutorials/roofit/rf612_recoverFromInvalidParameters.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roofit/rf612_recoverFromInvalidParameters.py,3,"['Recover', 'recover']","['Recover', 'recover', 'recovery']"
Safety,"## \file; ## \ingroup tutorial_tmva; ## \notebook -nodraw; ## This tutorial show how you can train a machine learning model with any package; ## reading the training data directly from ROOT files. Using XGBoost, we illustrate; ## how you can convert an externally trained model in a format serializable and readable; ## with the fast tree inference engine offered by TMVA.; ##; ## \macro_code; ## \macro_output; ##; ## \date August 2019; ## \author Stefan Wunsch; # XGBoost has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/tmva101_Training.py:508,avoid,avoid,508,tutorials/tmva/tmva101_Training.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/tmva101_Training.py,1,['avoid'],['avoid']
Safety,"### Stack painting. By default, histograms are shown stacked:; - the first histogram is painted; - then the sum of the first and second histograms is painted, and so on. The axis ranges are computed automatically along the X and Y axes to display the complete; histogram collection. Warning: Histogram bins with negative content may produce wrong plots. ### Stack's drawing options. The specific stack's drawing options are:. - **NOSTACK** If option ""nostack"" is specified, histograms are all painted in the same pad; as if the option ""same"" had been specified. - **NOSTACKB** If the option ""nostackb"" is specified histograms are all painted on the same pad; next to each other as bar plots. - **PADS** if option ""pads"" is specified, the current pad/canvas is subdivided into; a number of pads equal to the number of histograms and each histogram; is painted into a separate pad. - **NOCLEAR** By default the background of the histograms is erased before drawing the; histograms. The option ""noclear"" avoids this behavior. This is useful when drawing a; THStack on top of another plot. If the patterns used to draw the histograms in the; stack are transparent, then the plot behind will be visible. See the THistPainter class for the list of valid histograms' painting options. Example;. Begin_Macro(source); {; auto hs = new THStack(""hs"","""");; auto h1 = new TH1F(""h1"",""test hstack"",10,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs->Add(h1);; auto h2 = new TH1F(""h2"",""test hstack"",10,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs->Add(h2);; auto h3 = new TH1F(""h3"",""test hstack"",10,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs->Add(h3);; auto cs = new TCanvas(""cs"",""cs"",10,10,700,900);; TText T; T.SetTextFont(42); T.SetTextAlign(21);; cs->Divide(2,2);; cs->cd(1); hs->Draw(); T.DrawTextNDC(.5,.95,""Default drawing option"");; cs->cd(2); hs->Draw(""nostack""); T.DrawTextNDC(.5,.95,""Option \""nostack\"""");; cs->cd(3); hs->Draw(""nostackb"")",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx:1469,avoid,avoids,1469,hist/hist/src/THStack.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx,1,['avoid'],['avoids']
Safety,"#-----------------------------------------------------------------------------; # Minimal Python version sanity check; #-----------------------------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/Jupyter/kernel/setup.py:105,sanity check,sanity check,105,interpreter/cling/tools/Jupyter/kernel/setup.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/Jupyter/kernel/setup.py,1,['sanity check'],['sanity check']
Safety,"#; # Deleting the modules after use runs the risk of GC running on; # stuff we are using, such as ctypes.c_int.; #",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/bindings_utils.py:45,risk,risk,45,bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/bindings_utils.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/bindings_utils.py,1,['risk'],['risk']
Safety,"#; # Ideally, the HybridCalculator would be able to inspect the full; # model $Pois(x | s+b) * Pois(y | tau b )$ and be given the original; # prior $\eta(b)$ to form $\pi(b) = Pois(y|tau*b) * \eta(b)$.; # This is not yet implemented because in the general case; # it is not easy to identify the terms in the PDF that correspond; # to the auxiliary measurement. So for now, it must be set; # explicitly with:; # - ForcePriorNuisanceNull(); # - ForcePriorNuisanceAlt(); # the name ""ForcePriorNuisance"" was chosen because we anticipate; # this to be auto-detected, but will leave the option open; # to force to a different prior for the nuisance parameters.; # Part 3d : Construct and configure the HybridCalculator; # -------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/HybridInstructional.py:552,detect,detected,552,tutorials/roostats/HybridInstructional.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/HybridInstructional.py,1,['detect'],['detected']
Safety,"#; # Ideally, the HybridCalculator would be able to inspect the full; # model Pois(x | s+b) * Pois(y | tau b ) and be given the original; # prior $\eta(b)$ to form $\pi(b) = Pois(y|tau*b) * \eta(b)$.; # This is not yet implemented because in the general case; # it is not easy to identify the terms in the PDF that correspond; # to the auxiliary measurement. So for now, it must be set; # explicitly with:; # - ForcePriorNuisanceNull(); # - ForcePriorNuisanceAlt(); # the name ""ForcePriorNuisance"" was chosen because we anticipate; # this to be auto-detected, but will leave the option open; # to force to a different prior for the nuisance parameters.; # Part 3d : Construct and configure the HybridCalculator; # -------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/HybridStandardForm.py:550,detect,detected,550,tutorials/roostats/HybridStandardForm.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/roostats/HybridStandardForm.py,1,['detect'],['detected']
Safety,"#; # We expect to be run over hundreds of files. Any parsing issues are likely to be very repetitive.; # So, to avoid bothering the user, we suppress duplicates.; #",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/_cppyy_generator.py:112,avoid,avoid,112,bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/_cppyy_generator.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/python/cppyy_backend/_cppyy_generator.py,1,['avoid'],['avoid']
Safety,"#TODO : Remove the redundancy of __overload__ matching and use this function to only obtain the address given the matched overload",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/numba_ext.py:19,redund,redundancy,19,bindings/pyroot/cppyy/cppyy/python/cppyy/numba_ext.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/python/cppyy/numba_ext.py,1,['redund'],['redundancy']
Safety,"$Id$; // Author: Andrei Gheata 31/01/02; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TGeoShape; \ingroup Shapes_classes; Base abstract class for all shapes. Shapes are geometrical objects that provide the basic modelling; functionality. They provide the definition of the LOCAL frame of coordinates,; with respect to which they are defined. Any implementation of a shape deriving; from the base TGeoShape class has to provide methods for :. - finding out if a point defined in their local frame is or not contained; inside;; - computing the distance from a local point to getting outside/entering the; shape, given a known direction;; - computing the maximum distance in any direction from a local point that; does NOT result in a boundary crossing of the shape (safe distance);; - computing the cosines of the normal vector to the crossed shape surface,; given a starting local point and an ongoing direction.; All the features above are globally managed by the modeller in order to; provide navigation functionality. In addition to those, shapes have also to; implement additional specific abstract methods :; - computation of the minimal box bounding the shape, given that this box have; to be aligned with the local coordinates;; - algorithms for dividing the shape along a given axis and producing resulting; divisions volumes. The modeler currently provides a set of 16 basic shapes, which we will call; primitives. It also provides a special class allowing the creation of shapes; made as a result of boolean operations between primitives. These are called; composite shapes and the composition operation can be recursive (composition; of composites). This allows the ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoShape.cxx:1105,safe,safe,1105,geom/geom/src/TGeoShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoShape.cxx,1,['safe'],['safe']
Safety,"'''; Decorator for making Python callables accessible in C++ by just-in-time compilation; with numba and cling. The decorator takes the given Python callable and just-in-time compiles (jits); wrapper functions with the given C++ types for input and return types. Eventually,; the Python callable is accessible in the Numba namespace in C++. The implementation first jits with numba the Python callable. We support fundamental types and; ROOT::VecOps::RVecs thereof. Note that you can get the jitted Python callable by the attribute; numba_func. The C++ types are converted to the respective numba types and RVecs are accessible; in Python by numpy arrays. After jitting the actual Python callable, we jit another Python wrapper,; which converts the Python signature to a C-friendly signature. The wrapper code is accessible by; the attribute __py_wrapper__. Next, the Python wrapper is given to cling to jit a C++ wrapper function,; making the original Python callable accessible in C++. The wrapper code in C++ is accessible by; the attribute __cpp_wrapper__. Note that the callable is fully compiled without side-effects. The numba jitting uses the nopython; option which does not allow interaction with the Python interpreter. This means that you can use; the resulting function also safely in multi-threaded environments.; '''",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_numbadeclare.py:1287,safe,safely,1287,bindings/pyroot/pythonizations/python/ROOT/_numbadeclare.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/python/ROOT/_numbadeclare.py,1,['safe'],['safely']
Safety,"'''; SectionEnd. ; Function to detect Windows version and abort if Cling is unsupported in the current platform; Function DetectWinVer; Push $0; Push $1; ReadRegStr $0 HKLM ""SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"" CurrentVersion; IfErrors is_error is_winnt; is_winnt:; StrCpy $1 $0 1; StrCmp $1 4 is_error ; Aborting installation for Windows versions older than Windows 2000; StrCmp $0 ""5.0"" is_error ; Removing Windows 2000 as supported Windows version; StrCmp $0 ""5.1"" is_winnt_XP; StrCmp $0 ""5.2"" is_winnt_2003; StrCmp $0 ""6.0"" is_winnt_vista; StrCmp $0 ""6.1"" is_winnt_7; StrCmp $0 ""6.2"" is_winnt_8; StrCmp $1 6 is_winnt_8 ; Checking for future versions of Windows 8; Goto is_error. is_winnt_XP:; is_winnt_2003:; is_winnt_vista:; is_winnt_7:; is_winnt_8:; Goto done; is_error:; StrCpy $1 $0; ReadRegStr $0 HKLM ""SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"" ProductName; IfErrors 0 +4; ReadRegStr $0 HKLM ""SOFTWARE\\Microsoft\\Windows\\CurrentVersion"" Version; IfErrors 0 +2; StrCpy $0 ""Unknown""; MessageBox MB_ICONSTOP|MB_OK ""This version of Cling cannot be installed on this system. Cling is supported only on Windows NT systems. Current system: $0 (version: $1)""; Abort; done:; Pop $1; Pop $0; FunctionEnd. ; Function to check any previously installed version of Cling in the system; Function CheckPrevVersion; Push $0; Push $1; Push $2; IfFileExists ""$INSTDIR\\bin\\cling.exe"" 0 otherver; MessageBox MB_OK|MB_ICONSTOP ""Another Cling installation (with the same version) has been detected. Please uninstall it first.""; Abort; otherver:; StrCpy $0 0; StrCpy $2 """"; loop:; EnumRegKey $1 ${PRODUCT_ROOT_KEY} ""${PRODUCT_KEY}"" $0; StrCmp $1 """" loopend; IntOp $0 $0 + 1; StrCmp $2 """" 0 +2; StrCpy $2 ""$1""; StrCpy $2 ""$2, $1""; Goto loop; loopend:; ReadRegStr $1 ${PRODUCT_ROOT_KEY} ""${PRODUCT_KEY}"" ""Version""; IfErrors finalcheck; StrCmp $2 """" 0 +2; StrCpy $2 ""$1""; StrCpy $2 ""$2, $1""; finalcheck:; StrCmp $2 """" done; MessageBox MB_YESNO|MB_ICONEXCLAMATION ""Another Cling installation (vers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/cpt.py:31,detect,detect,31,interpreter/cling/tools/packaging/cpt.py,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/cpt.py,4,"['Abort', 'Detect', 'abort', 'detect']","['Aborting', 'DetectWinVer', 'abort', 'detect']"
Safety,"'url'.; /// If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; /// sequentially in the specified order until a successful open.; /// If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; /// will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; /// etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; /// for regular expressions that will be checked) and as last a local file will; /// be tried.; /// Before opening a file via TNetFile a check is made to see if the URL; /// specifies a local file. If that is the case the file will be opened; /// via a normal TFile. To force the opening of a local file via a; /// TNetFile use either TNetFile directly or specify as host ""localhost"".; /// The netopt argument is only used by TNetFile. For the meaning of the; /// options and other arguments see the constructors of the individual; /// file classes. In case of error, it returns a nullptr.; ///; /// For TFile implementations supporting asynchronous file open, see; /// TFile::AsyncOpen(...), it is possible to request a timeout with the; /// option <b>`TIMEOUT=<secs>`</b>: the timeout must be specified in seconds and; /// it will be internally checked with granularity of one millisec.; /// For remote files there is the option: <b>CACHEREAD</b> opens an existing; /// file for reading through the file cache. The file will be downloaded to; /// the cache and opened from there. If the download fails, it will be opened remotely.; /// The file will be downloaded to the directory specified by SetCacheFileDir().; ///; /// *The caller is responsible for deleting the pointer.*; /// In READ mode, a nullptr is returned if the file does not exist or cannot be opened.; /// In CREATE mode, a nullptr is returned if the file already exists or cannot be created.; /// In RECREATE mode, a nullptr is returned if the file can not be created.; /// In UPDATE mode, a nullptr is returned if the file cannot be created or opened.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:1527,timeout,timeout,1527,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,3,"['TIMEOUT', 'timeout']","['TIMEOUT', 'timeout']"
Safety,"). And, so,; // we might produce code like this:; //; // .Ltmp526:; // addis 3, 2, .LC12@toc@ha; // .Ltmp1628:; // std 2, 40(1); // ld 5, 0(27); // ld 2, 8(27); // ld 11, 16(27); // ld 3, .LC12@toc@l(3); // rldicl 4, 4, 0, 32; // mtctr 5; // bctrl; // ld 2, 40(1); //; // And there is nothing wrong with this code, as such, but there is a linker bug; // in binutils (https://sourceware.org/bugzilla/show_bug.cgi?id=18414) that will; // misoptimize this code sequence to this:; // nop; // std r2,40(r1); // ld r5,0(r27); // ld r2,8(r27); // ld r11,16(r27); // ld r3,-32472(r2); // clrldi r4,r4,32; // mtctr r5; // bctrl; // ld r2,40(r1); // because the linker does not know (and does not check) that the value in r2; // changed in between the instruction using the .LC12@toc@ha (TOC-relative); // relocation and the instruction using the .LC12@toc@l(3) relocation.; // Because it finds these instructions using the relocations (and not by; // scanning the instructions), it has been asserted that there is no good way; // to detect the change of r2 in between. As a result, this bug may never be; // fixed (i.e. it may become part of the definition of the ABI). GCC was; // updated to add extra dependencies on r2 to instructions using the @toc@l; // relocations to avoid this problem, and we'll do the same here.; //; // This is done as a separate pass because:; // 1. These extra r2 dependencies are not really properties of the; // instructions, but rather due to a linker bug, and maybe one day we'll be; // able to get rid of them when targeting linkers without this bug (and,; // thus, keeping the logic centralized here will make that; // straightforward).; // 2. There are ISel-level peephole optimizations that propagate the @toc@l; // relocations to some user instructions, and so the exta dependencies do; // not apply only to a fixed set of instructions (without undesirable; // definition replication).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:1871,avoid,avoid,1871,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,1,['avoid'],['avoid']
Safety,"* processes are inner loops and need to be as fast as possible. On most; * machines, particularly CPUs with pipelines or instruction prefetch,; * a (subscript-check-less) C table lookup; *		x = sample_range_limit[x];; * is faster than explicit tests; *		if (x < 0) x = 0;; *		else if (x > MAXJSAMPLE) x = MAXJSAMPLE;; * These processes all use a common table prepared by the routine below.; *; * For most steps we can mathematically guarantee that the initial value; * of x is within MAXJSAMPLE+1 of the legal range, so a table running from; * -(MAXJSAMPLE+1) to 2*MAXJSAMPLE+1 is sufficient. But for the initial; * limiting step (just after the IDCT), a wildly out-of-range value is ; * possible if the input data is corrupt. To avoid any chance of indexing; * off the end of memory and getting a bad-pointer trap, we perform the; * post-IDCT limiting thus:; *		x = range_limit[x & MASK];; * where MASK is 2 bits wider than legal sample data, ie 10 bits for 8-bit; * samples. Under normal circumstances this is more than enough range and; * a correct output will be generated; with bogus input data the mask will; * cause wraparound, and we will safely generate a bogus-but-in-range output.; * For the post-IDCT step, we want to convert the data from signed to unsigned; * representation by adding CENTERJSAMPLE at the same time that we limit it.; * So the post-IDCT limiting table ends up looking like this:; * CENTERJSAMPLE,CENTERJSAMPLE+1,...,MAXJSAMPLE,; * MAXJSAMPLE (repeat 2*(MAXJSAMPLE+1)-CENTERJSAMPLE times),; * 0 (repeat 2*(MAXJSAMPLE+1)-CENTERJSAMPLE times),; * 0,1,...,CENTERJSAMPLE-1; * Negative inputs select values from the upper half of the table after; * masking.; *; * We can save some space by overlapping the start of the post-IDCT table; * with the simpler range limiting table. The post-IDCT table begins at; * sample_range_limit + CENTERJSAMPLE.; *; * Note that the table is allocated in near data space on PCs; it's small; * enough and used often enough to justify this.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c:1368,safe,safely,1368,graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmaster.c,1,['safe'],['safely']
Safety,"* x.lo ^= (x.lo >> 13) | (x.hi << (32 - 13));; * x.hi ^= (x.hi >> 13);; *; * The first one is significantly faster than the second, simply because the; * shift is larger than 32. This means:; * - All the bits we need are in the upper 32 bits, so we can ignore the lower; * 32 bits in the shift.; * - The shift result will always fit in the lower 32 bits, and therefore,; * we can ignore the upper 32 bits in the xor.; *; * Thanks to this optimization, XXH3 only requires these features to be efficient:; *; * - Usable unaligned access; * - A 32-bit or 64-bit ALU; * - If 32-bit, a decent ADC instruction; * - A 32 or 64-bit multiply with a 64-bit result; * - For the 128-bit variant, a decent byteswap helps short inputs.; *; * The first two are already required by XXH32, and almost all 32-bit and 64-bit; * platforms which can run XXH32 can run XXH3 efficiently.; *; * Thumb-1, the classic 16-bit only subset of ARM's instruction set, is one; * notable exception.; *; * First of all, Thumb-1 lacks support for the UMULL instruction which; * performs the important long multiply. This means numerous __aeabi_lmul; * calls.; *; * Second of all, the 8 functional registers are just not enough.; * Setup for __aeabi_lmul, byteshift loads, pointers, and all arithmetic need; * Lo registers, and this shuffling results in thousands more MOVs than A32.; *; * A32 and T32 don't have this limitation. They can access all 14 registers,; * do a 32->64 multiply with UMULL, and the flexible operand allowing free; * shifts is helpful, too.; *; * Therefore, we do a quick sanity check.; *; * If compiling Thumb-1 for a target which supports ARM instructions, we will; * emit a warning, as it is not a ""sane"" platform to compile for.; *; * Usually, if this happens, it is because of an accident and you probably need; * to specify -march, as you likely meant to compile for a newer architecture.; *; * Credit: large sections of the vectorial and asm source code paths; * have been contributed by @easyaspi314; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:2215,sanity check,sanity check,2215,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['sanity check'],['sanity check']
Safety,"**********************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TVirtualFFT; \ingroup Base. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. ## Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. ## Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available. - DCT-I (REDFT00 in FFTW3 notation)- kind=0; - DCT-II (REDFT01 in FFTW3 notation)- kind=1; - DCT-III(REDFT10 in FFTW3 notation)- kind=2; - DCT-IV (REDFT11 in FFTW3 notation)- kind=3; - DST-I (RODFT00 in FFTW3 notation)- kind=4; - DST-II (RODFT01 in FFTW3 notation)- kind=5; - DST-III(RODFT10 in FFT",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualFFT.cxx:1273,redund,redundant,1273,core/base/src/TVirtualFFT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualFFT.cxx,1,['redund'],['redundant']
Safety,"********************/; /** \class TRobustEstimator; \note Despite being in the group of Legacy statistics classes, TRobustEstimator is still useful and no drop-in replacement exists for it.; \ingroup Physics; Minimum Covariance Determinant Estimator - a Fast Algorithm; invented by Peter J.Rousseeuw and Katrien Van Dreissen; ""A Fast Algorithm for the Minimum covariance Determinant Estimator""; Technometrics, August 1999, Vol.41, NO.3. What are robust estimators?; ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recognise them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is effective when less than (n+nvar+1)/2 variables are outliers.; The algorithm also allows for exact fit situations - that is",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TRobustEstimator.cxx:1473,detect,detected,1473,math/physics/src/TRobustEstimator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TRobustEstimator.cxx,1,['detect'],['detected']
Safety,"****************; * Project: RooStats; * Package: RooFit/RooStats; * @(#)root/roofit/roostats:$Id$; * Authors:; * Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke, Sven Kreiss; *; *****************************************************************************/; /** \class RooStats::HypoTestResult; \ingroup Roostats. HypoTestResult is a base class for results from hypothesis tests.; Any tool inheriting from HypoTestCalculator can return a HypoTestResult.; As such, it stores a p-value for the null-hypothesis (eg. background-only); and an alternate hypothesis (eg. signal+background).; The p-values can also be transformed into confidence levels; (\f$CL_{b}\f$, \f$CL_{s+b}\f$) in a trivial way.; The ratio of the \f$CL_{s+b}\f$ to \f$CL_{b}\f$ is often called; \f$CL_{s}\f$, and is considered useful, though it is not a probability.; Finally, the p-value of the null can be transformed into a number of; equivalent Gaussian sigma using the Significance method. The p-value of the null for a given test statistic is rigorously defined and; this is the starting point for the following conventions. ### Conventions used in this class. The p-value for the null and alternate are on the **same side** of the; observed value of the test statistic. This is the more standard; convention and avoids confusion when doing inverted tests. For exclusion, we also want the formula \f$CL_{s} = CL_{s+b} / CL_{b}\f$; to hold which therefore defines our conventions for \f$CL_{s+b}\f$ and; \f$CL_{b}\f$. \f$CL_{s}\f$ was specifically invented for exclusion; and therefore all quantities need be related through the assignments; as they are for exclusion: \f$CL_{s+b} = p_{s+b}\f$; \f$CL_{b} = p_{b}\f$. This; is derived by considering the scenarios of a powerful and not powerful; inverted test, where for the not so powerful test, \f$CL_{s}\f$ must be; close to one. For results of Hypothesis tests,; \f$CL_{s}\f$ has no similar direct interpretation as for exclusion and can; be larger than one. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestResult.cxx:1834,avoid,avoids,1834,roofit/roostats/src/HypoTestResult.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestResult.cxx,1,['avoid'],['avoids']
Safety,"*; * white_scale = 1/white-y; * white-X = white-x * white-scale; * white-Y = 1.0; * white-Z = (1 - white-x - white-y) * white_scale; *; * white-C = red-C + green-C + blue-C; * = red-c*red-scale + green-c*green-scale + blue-c*blue-scale; *; * This gives us three equations in (red-scale,green-scale,blue-scale) where; * all the coefficients are now known:; *; * red-x*red-scale + green-x*green-scale + blue-x*blue-scale; * = white-x/white-y; * red-y*red-scale + green-y*green-scale + blue-y*blue-scale = 1; * red-z*red-scale + green-z*green-scale + blue-z*blue-scale; * = (1 - white-x - white-y)/white-y; *; * In the last equation color-z is (1 - color-x - color-y) so we can add all; * three equations together to get an alternative third:; *; * red-scale + green-scale + blue-scale = 1/white-y = white-scale; *; * So now we have a Cramer's rule solution where the determinants are just; * 3x3 - far more tractible. Unfortunately 3x3 determinants still involve; * multiplication of three coefficients so we can't guarantee to avoid; * overflow in the libpng fixed point representation. Using Cramer's rule in; * floating point is probably a good choice here, but it's not an option for; * fixed point. Instead proceed to simplify the first two equations by; * eliminating what is likely to be the largest value, blue-scale:; *; * blue-scale = white-scale - red-scale - green-scale; *; * Hence:; *; * (red-x - blue-x)*red-scale + (green-x - blue-x)*green-scale =; * (white-x - blue-x)*white-scale; *; * (red-y - blue-y)*red-scale + (green-y - blue-y)*green-scale =; * 1 - blue-y*white-scale; *; * And now we can trivially solve for (red-scale,green-scale):; *; * green-scale =; * (white-x - blue-x)*white-scale - (red-x - blue-x)*red-scale; * -----------------------------------------------------------; * green-x - blue-x; *; * red-scale =; * 1 - blue-y*white-scale - (green-y - blue-y) * green-scale; * ---------------------------------------------------------; * red-y - blue-y; *; * Hence:; *; * r",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:4385,avoid,avoid,4385,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['avoid'],['avoid']
Safety,",-1,""#pi"");; f->Draw();; }; End_Macro. \anchor GA11; ## Number of divisions optimisation. By default the number of divisions on axis is optimised to show a coherent; labelling of the main tick marks. The number of division (`ndiv`) is a; composite integer given by:. ` ndiv = N1 + 100*N2 + 10000*N3`. - `N1` = number of 1st divisions.; - `N2` = number of 2nd divisions.; - `N3` = number of 3rd divisions. by default the value of `N1`, `N2` and `N3` are maximum; values. After optimisation the real number of divisions will be smaller or; equal to these value. If one wants to bypass the optimisation, the option `""N""`; should be given when the `TGaxis` is created. The option `""I""`; also act on the number of division as it will force an integer labelling of; the axis. On an histogram pointer `h` the number of divisions can be set in different ways:. - Directly on the histogram. The following will set the number of division; to 510 on the X axis of `h`. To avoid optimization the number of divisions; should be negative (ie: -510);; ~~~ {.cpp}; h->SetNdivisions(510, ""X"");; ~~~; - On the axis itself:; ~~~ {.cpp}; h->GetXaxis()->SetNdivisions(510, kTRUE);; ~~~. The first parameter is the number of division. If it is negative of if the; second parameter is kFALSE then the number of divisions is not optimised.; And other signature is also allowed:; ~~~ {.cpp}; h->GetXaxis()->SetNdivisions(10, 5, 0, kTRUE);; ~~~; \anchor GA12; ## Maximum Number of Digits for the axis labels. The static method `TGaxis::SetMaxDigits` sets the maximum number of; digits permitted for the axis labels above which the notation with 10^N is used.; For example, to accept 6 digits number like 900000 on an axis call; `TGaxis::SetMaxDigits(6)`. The default value is 5.; `fgMaxDigits` must be greater than 0.; Warning: even when called on a particular TGaxis* instance, this static function; changes globally the number of digits for all axes (X, Y, ...) in the canvas.; If you want to change the maximum number of di",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TGaxis.cxx:11279,avoid,avoid,11279,graf2d/graf/src/TGaxis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TGaxis.cxx,1,['avoid'],['avoid']
Safety,"- TrailingObjects.h - Variable-length classes ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This header defines support for implementing classes that have; /// some trailing object (or arrays of objects) appended to them. The; /// main purpose is to make it obvious where this idiom is being used,; /// and to make the usage more idiomatic and more difficult to get; /// wrong.; ///; /// The TrailingObject template abstracts away the reinterpret_cast,; /// pointer arithmetic, and size calculations used for the allocation; /// and access of appended arrays of objects, and takes care that they; /// are all allocated at their required alignment. Additionally, it; /// ensures that the base type is final -- deriving from a class that; /// expects data appended immediately after it is typically not safe.; ///; /// Users are expected to derive from this template, and provide; /// numTrailingObjects implementations for each trailing type except; /// the last, e.g. like this sample:; ///; /// \code; /// class VarLengthObj : private TrailingObjects<VarLengthObj, int, double> {; /// friend TrailingObjects;; ///; /// unsigned NumInts, NumDoubles;; /// size_t numTrailingObjects(OverloadToken<int>) const { return NumInts; }; /// };; /// \endcode; ///; /// You can access the appended arrays via 'getTrailingObjects', and; /// determine the size needed for allocation via; /// 'additionalSizeToAlloc' and 'totalSizeToAlloc'.; ///; /// All the methods implemented by this class are intended for use; /// by the implementation of the class, not as part of its interface; /// (thus, private inheritance is suggested).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TrailingObjects.h:1105,safe,safe,1105,interpreter/llvm-project/llvm/include/llvm/Support/TrailingObjects.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TrailingObjects.h,1,['safe'],['safe']
Safety,"-------------------------------------------------===//; ///; /// \file; /// This file implements the loop fusion pass.; /// The implementation is largely based on the following document:; ///; /// Code Transformations to Augment the Scope of Loop Fusion in a; /// Production Compiler; /// Christopher Mark Barton; /// MSc Thesis; /// https://webdocs.cs.ualberta.ca/~amaral/thesis/ChristopherBartonMSc.pdf; ///; /// The general approach taken is to collect sets of control flow equivalent; /// loops and test whether they can be fused. The necessary conditions for; /// fusion are:; /// 1. The loops must be adjacent (there cannot be any statements between; /// the two loops).; /// 2. The loops must be conforming (they must execute the same number of; /// iterations).; /// 3. The loops must be control flow equivalent (if one loop executes, the; /// other is guaranteed to execute).; /// 4. There cannot be any negative distance dependencies between the loops.; /// If all of these conditions are satisfied, it is safe to fuse the loops.; ///; /// This implementation creates FusionCandidates that represent the loop and the; /// necessary information needed by fusion. It then operates on the fusion; /// candidates, first confirming that the candidate is eligible for fusion. The; /// candidates are then collected into control flow equivalent sets, sorted in; /// dominance order. Each set of control flow equivalent candidates is then; /// traversed, attempting to fuse pairs of candidates in the set. If all; /// requirements for fusion are met, the two candidates are fused, creating a; /// new (fused) candidate which is then added back into the set to consider for; /// additional fusion.; ///; /// This implementation currently does not make any modifications to remove; /// conditions for fusion. Code transformations to make loops conform to each of; /// the conditions for fusion are discussed in more detail in the document; /// above. These can be added to the current implementation i",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:1336,safe,safe,1336,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['safe'],['safe']
Safety,"---------------------===//; //; /// \file; /// Copies from VGPR to SGPR registers are illegal and the register coalescer; /// will sometimes generate these illegal copies in situations like this:; ///; /// Register Class <vsrc> is the union of <vgpr> and <sgpr>; ///; /// BB0:; /// %0 <sgpr> = SCALAR_INST; /// %1 <vsrc> = COPY %0 <sgpr>; /// ...; /// BRANCH %cond BB1, BB2; /// BB1:; /// %2 <vgpr> = VECTOR_INST; /// %3 <vsrc> = COPY %2 <vgpr>; /// BB2:; /// %4 <vsrc> = PHI %1 <vsrc>, <%bb.0>, %3 <vrsc>, <%bb.1>; /// %5 <vgpr> = VECTOR_INST %4 <vsrc>; ///; ///; /// The coalescer will begin at BB0 and eliminate its copy, then the resulting; /// code will look like this:; ///; /// BB0:; /// %0 <sgpr> = SCALAR_INST; /// ...; /// BRANCH %cond BB1, BB2; /// BB1:; /// %2 <vgpr> = VECTOR_INST; /// %3 <vsrc> = COPY %2 <vgpr>; /// BB2:; /// %4 <sgpr> = PHI %0 <sgpr>, <%bb.0>, %3 <vsrc>, <%bb.1>; /// %5 <vgpr> = VECTOR_INST %4 <sgpr>; ///; /// Now that the result of the PHI instruction is an SGPR, the register; /// allocator is now forced to constrain the register class of %3 to; /// <sgpr> so we end up with final code like this:; ///; /// BB0:; /// %0 <sgpr> = SCALAR_INST; /// ...; /// BRANCH %cond BB1, BB2; /// BB1:; /// %2 <vgpr> = VECTOR_INST; /// %3 <sgpr> = COPY %2 <vgpr>; /// BB2:; /// %4 <sgpr> = PHI %0 <sgpr>, <%bb.0>, %3 <sgpr>, <%bb.1>; /// %5 <vgpr> = VECTOR_INST %4 <sgpr>; ///; /// Now this code contains an illegal copy from a VGPR to an SGPR.; ///; /// In order to avoid this problem, this pass searches for PHI instructions; /// which define a <vsrc> register and constrains its definition class to; /// <vgpr> if the user of the PHI's definition register is a vector instruction.; /// If the PHI's definition class is constrained to <vgpr> then the coalescer; /// will be unable to perform the COPY removal from the above example which; /// ultimately led to the creation of an illegal COPY.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFixSGPRCopies.cpp:1838,avoid,avoid,1838,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFixSGPRCopies.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFixSGPRCopies.cpp,1,['avoid'],['avoid']
Safety,"-----------===//; //; // This pass flattens pairs nested loops into a single loop.; //; // The intention is to optimise loop nests like this, which together access an; // array linearly:; //; // for (int i = 0; i < N; ++i); // for (int j = 0; j < M; ++j); // f(A[i*M+j]);; //; // into one loop:; //; // for (int i = 0; i < (N*M); ++i); // f(A[i]);; //; // It can also flatten loops where the induction variables are not used in the; // loop. This is only worth doing if the induction variables are only used in an; // expression like i*M+j. If they had any other uses, we would have to insert a; // div/mod to reconstruct the original values, so this wouldn't be profitable.; //; // We also need to prove that N*M will not overflow. The preferred solution is; // to widen the IV, which avoids overflow checks, so that is tried first. If; // the IV cannot be widened, then we try to determine that this new tripcount; // expression won't overflow.; //; // Q: Does LoopFlatten use SCEV?; // Short answer: Yes and no.; //; // Long answer:; // For this transformation to be valid, we require all uses of the induction; // variables to be linear expressions of the form i*M+j. The different Loop; // APIs are used to get some loop components like the induction variable,; // compare statement, etc. In addition, we do some pattern matching to find the; // linear expressions and other loop components like the loop increment. The; // latter are examples of expressions that do use the induction variable, but; // are safe to ignore when we check all uses to be of the form i*M+j. We keep; // track of all of this in bookkeeping struct FlattenInfo.; // We assume the loops to be canonical, i.e. starting at 0 and increment with; // 1. This makes RHS of the compare the loop tripcount (with the right; // predicate). We use SCEV to then sanity check that this tripcount matches; // with the tripcount as computed by SCEV.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:1870,safe,safe,1870,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,2,"['safe', 'sanity check']","['safe', 'sanity check']"
Safety,"-------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy b <-- cross-bank copy; // =>; // b = copy A <-- cross-bank copy; // C = copy A <-- same-bank copy; //; // E.g., for bitcast:; // b = bitcast A <-- cross-bank copy; // C = bitcast b <-- cross-bank copy; // =>; // b = bitcast A <-- cross-bank copy; // C = copy A <-- same-bank copy; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:1791,avoid,avoid,1791,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['avoid'],['avoid']
Safety,"---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1086,safe,safe,1086,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,1,['safe'],['safe']
Safety,"-15 .fNode; +----------------------------------+; ~~~. The adjusted time stamp is split into three fields, and the; clockSeq is split into two fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; ~~~ {.cpp}; MSB <---; Version 4-Bit Code Description; ------------------------------------------------------------; | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value; ------------------------------------------------------------; ~~~. ## Clock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicated UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. ## Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremente",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUUID.cxx:2954,detect,detects,2954,core/base/src/TUUID.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUUID.cxx,1,['detect'],['detects']
Safety,"-7 3 4 -8; // -9 -10 -11 -12 <- No regular bins on the overflow line of axis 1; //; // As we go to higher dimensions, the geometry becomes more complex, but; // if we replace ""line"" with ""plane"", we get a similar picture in 3D when we; // slide along axis 2:; //; // No regular bins on the Some of them on the No regular bins again; // UF plane of axis 2 regular planes of ax.2 on the OF plane of ax.2; //; // -1 -2 -3 -4 -17 -18 -19 -20 -29 -30 -31 -32; // -5 -6 -7 -8 -21 1 2 -22 -33 -34 -35 -36; // -9 -10 -11 -12 -23 3 4 -24 -37 -37 -39 -40; // -13 -14 -15 -16 -25 -26 -27 -28 -41 -42 -43 -44; //; // We can generalize this to N dimensions by saying that as we slide along; // the last axis of an N-d histogram, we see an hyperplane full of overflow; // bins, then some hyperplanes with regular bins in the ""middle"" surrounded; // by overflow bins, then a last hyperplane full of overflow bins.; //; // From this, we can devise a recursive algorithm to recover the number of; // regular bins before the overflow bin we're currently looking at:; //; // - Start by processing the last histogram axis.; // - Ignore the first and last hyperplane on this axis, which only contain; // underflow and overflow bins respectively.; // - Count how many complete hyperplanes of regular bins lie before us on; // this axis, which we can do indirectly in our overflow bin based; // reasoning by computing the perimeter of the regular region and dividing; // our ""regular"" overflow bin count by that amount.; // - Now we counted previous hyperplanes on this last histogram axis, but; // we need to process the hyperplane that our bin is located in, if any.; // * For this, we reduce our overflow bin count to a count of; // _unaccounted_ overflow bins in the current hyperplane...; // * ...which allows us to recursively continue the computation by; // processing the next (well, previous) histogram axis in the context; // of this hyperplane, in the same manner as above.; //; // Alright, now that the general ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:1373,recover,recover,1373,hist/histv7/inc/ROOT/RHistImpl.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx,1,['recover'],['recover']
Safety,".0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // When alias analysis is uncertain about the aliasing between any two accesses,; // it will return MayAlias. This uncertainty from alias analysis restricts LICM; // from proceeding further. In cases where alias analysis is uncertain we might; // use loop versioning as an alternative.; //; // Loop Versioning will create a version of the loop with aggressive aliasing; // assumptions in addition to the original with conservative (default) aliasing; // assumptions. The version of the loop making aggressive aliasing assumptions; // will have all the memory accesses marked as no-alias. These two versions of; // loop will be preceded by a memory runtime check. This runtime check consists; // of bound checks for all unique memory accessed in loop, and it ensures the; // lack of memory aliasing. The result of the runtime check determines which of; // the loop versions is executed: If the runtime check detects any memory; // aliasing, then the original loop is executed. Otherwise, the version with; // aggressive aliasing assumptions is used.; //; // Following are the top level steps:; //; // a) Perform LoopVersioningLICM's feasibility check.; // b) If loop is a candidate for versioning then create a memory bound check,; // by considering all the memory accesses in loop body.; // c) Clone original loop and set all memory accesses as no-alias in new loop.; // d) Set original loop & versioned loop as a branch target of the runtime check; // result.; //; // It transforms loop as shown below:; //; // +----------------+; // |Runtime Memcheck|; // +----------------+; // |; // +----------+----------------+----------+; // | |; // +---------+----------+ +-----------+----------+; // |Orig Loop Preheader | |Cloned Loop Preheader |; // +--------------------+ +----------------------+; // | |; // +--------------------+ +----------------------+; // |Orig Loop Body | |Cloned Loop ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:1287,detect,detects,1287,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,1,['detect'],['detects']
Safety,".; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines the Pass Instrumentation classes that provide; /// instrumentation points into the pass execution by PassManager.; ///; /// There are two main classes:; /// - PassInstrumentation provides a set of instrumentation points for; /// pass managers to call on.; ///; /// - PassInstrumentationCallbacks registers callbacks and provides access; /// to them for PassInstrumentation.; ///; /// PassInstrumentation object is being used as a result of; /// PassInstrumentationAnalysis (so it is intended to be easily copyable).; ///; /// Intended scheme of use for Pass Instrumentation is as follows:; /// - register instrumentation callbacks in PassInstrumentationCallbacks; /// instance. PassBuilder provides helper for that.; ///; /// - register PassInstrumentationAnalysis with all the PassManagers.; /// PassBuilder handles that automatically when registering analyses.; ///; /// - Pass Manager requests PassInstrumentationAnalysis from analysis manager; /// and gets PassInstrumentation as its result.; ///; /// - Pass Manager invokes PassInstrumentation entry points appropriately,; /// passing StringRef identification (""name"") of the pass currently being; /// executed and IRUnit it works on. There can be different schemes of; /// providing names in future, currently it is just a name() of the pass.; ///; /// - PassInstrumentation wraps address of IRUnit into llvm::Any and passes; /// control to all the registered callbacks. Note that we specifically wrap; /// 'const IRUnitT*' so as to avoid any accidental changes to IR in; /// instrumenting callbacks.; ///; /// - Some instrumentation points (BeforePass) allow to control execution; /// of a pass. For those callbacks returning false means pass will not be; /// executed.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassInstrumentation.h:1897,avoid,avoid,1897,interpreter/llvm-project/llvm/include/llvm/IR/PassInstrumentation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassInstrumentation.h,1,['avoid'],['avoid']
Safety,".; Some predefined RDataSources are natively provided by ROOT such as the ROOT::RDF::RCsvDS which allows to read comma separated files:; ~~~{.cpp}; auto tdf = ROOT::RDF::FromCSV(""MuRun2010B.csv"");; auto filteredEvents =; tdf.Filter(""Q1 * Q2 == -1""); .Define(""m"", ""sqrt(pow(E1 + E2, 2) - (pow(px1 + px2, 2) + pow(py1 + py2, 2) + pow(pz1 + pz2, 2)))"");; auto h = filteredEvents.Histo1D(""m"");; h->Draw();; ~~~. See also FromNumpy (Python-only), FromRNTuple(), FromArrow(), FromSqlite(). \anchor callgraphs; ### Computation graphs (storing and reusing sets of transformations). As we saw, transformed dataframes can be stored as variables and reused multiple times to create modified versions of the dataset. This implicitly defines a **computation graph** in which; several paths of filtering/creation of columns are executed simultaneously, and finally aggregated results are produced. RDataFrame detects when several actions use the same filter or the same defined column, and **only evaluates each; filter or defined column once per event**, regardless of how many times that result is used down the computation graph.; Objects read from each column are **built once and never copied**, for maximum efficiency.; When ""upstream"" filters are not passed, subsequent filters, temporary column expressions and actions are not evaluated,; so it might be advisable to put the strictest filters first in the graph. \anchor representgraph; ### Visualizing the computation graph; It is possible to print the computation graph from any node to obtain a [DOT (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) representation either on the standard output; or in a file. Invoking the function ROOT::RDF::SaveGraph() on any node that is not the head node, the computation graph of the branch; the node belongs to is printed. By using the head node, the entire computation graph is printed. Following there is an example of usage:; ~~~{.cpp}; // First, a sample computational graph is built;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:75204,detect,detects,75204,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['detect'],['detects']
Safety,"/ propagate the shadow bits through some of the arithmetic; /// instruction (including MOV), store the shadow bits on every memory; /// write, report a bug on some other instructions (e.g. JMP) if the; /// associated shadow is poisoned.; ///; /// But there are differences too. The first and the major one:; /// compiler instrumentation instead of binary instrumentation. This; /// gives us much better register allocation, possible compiler; /// optimizations and a fast start-up. But this brings the major issue; /// as well: msan needs to see all program events, including system; /// calls and reads/writes in system libraries, so we either need to; /// compile *everything* with msan or use a binary translation; /// component (e.g. DynamoRIO) to instrument pre-built libraries.; /// Another difference from Memcheck is that we use 8 shadow bits per; /// byte of application memory and use a direct shadow mapping. This; /// greatly simplifies the instrumentation code and avoids races on; /// shadow updates (Memcheck is single-threaded so races are not a; /// concern there. Memcheck uses 2 shadow bits per byte with a slow; /// path storage that uses 8 bits per byte).; ///; /// The default value of shadow is 0, which means ""clean"" (not poisoned).; ///; /// Every module initializer should call __msan_init to ensure that the; /// shadow memory is ready. On error, __msan_warning is called. Since; /// parameters and return values may be passed via registers, we have a; /// specialized thread-local shadow for return values; /// (__msan_retval_tls) and parameters (__msan_param_tls).; ///; /// Origin tracking.; ///; /// MemorySanitizer can track origins (allocation points) of all uninitialized; /// values. This behavior is controlled with a flag (msan-track-origins) and is; /// disabled by default.; ///; /// Origins are 4-byte values created and interpreted by the runtime library.; /// They are stored in a second shadow mapping, one 4-byte value for 4 bytes; /// of application memor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:1726,avoid,avoids,1726,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['avoid'],['avoids']
Safety,"/*	register int i ;*/; /* we want to open the input file before doing anything else,; 	 * so that the setjmp() error recovery below can assume the file is open.; 	 * VERY IMPORTANT: use ""b"" option to fopen() if you are on a machine that; 	 * requires it in order to read binary files.; 	 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.c:117,recover,recovery,117,graf2d/asimage/src/libAfterImage/import.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.c,1,['recover'],['recovery']
Safety,/* !! Just to avoid unused code elimination */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c:14,avoid,avoid,14,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/jitprofiling.c,1,['avoid'],['avoid']
Safety,/* 'E': PLUS 1 TOTAL 2+precision */; /* The following use of an unsigned temporary avoids ambiguities in; * the signed arithmetic on exp_b10 and permits GCC at least to do; * better optimization.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:83,avoid,avoids,83,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['avoid'],['avoids']
Safety,"/* 'uLong' is defined in zlib.h as unsigned long; this means that on some; * systems it is a 64-bit value. crc32, however, returns 32 bits so the; * following cast is safe. 'uInt' may be no more than 16 bits, so it is; * necessary to perform a loop here.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:167,safe,safe,167,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['safe'],['safe']
Safety,/* ******************************************************************; Supporting functions: bundled here to avoid depending on a library; ****************************************************************** */; // Dean Edwards/Matthias Miller/John Resig; /* for Mozilla/Opera9 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js:109,avoid,avoid,109,interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js,3,['avoid'],['avoid']
Safety,"/* **************************************************************; * Templates; ****************************************************************/; /*; designed to be included; for type-specific functions (template emulation in C); Objective is to write these functions only once, for improved maintenance; */; /* safety checks */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse_decompress.c:313,safe,safety,313,builtins/zstd/common/fse_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse_decompress.c,2,['safe'],['safety']
Safety,"/* *************************************; * Tuning parameters; ***************************************/; /*!; * XXH_FORCE_MEMORY_ACCESS:; * By default, access to unaligned memory is controlled by `memcpy()`, which is; * safe and portable.; *; * Unfortunately, on some target/compiler combinations, the generated assembly; * is sub-optimal.; *; * The below switch allow selection of a different access method; * in the search for improved performance.; * Method 0 (default):; * Use `memcpy()`. Safe and portable. Default.; * Method 1:; * `__attribute__((packed))` statement. It depends on compiler extensions; * and is therefore not portable.; * This method is safe if your compiler supports it, and *generally* as; * fast or faster than `memcpy`.; * Method 2:; * Direct access via cast. This method doesn't depend on the compiler but; * violates the C standard.; * It can generate buggy code on targets which do not support unaligned; * memory accesses.; * But in some circumstances, it's the only known way to get the most; * performance (example: GCC + ARMv6); * Method 3:; * Byteshift. This can generate the best code on old compilers which don't; * inline small `memcpy()` calls, and it might also be faster on big-endian; * systems which lack a native byteswap instruction.; * See https://stackoverflow.com/a/32095106/646947 for details.; * Prefer these methods in priority order (0 > 1 > 2 > 3); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:220,safe,safe,220,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,3,"['Safe', 'safe']","['Safe', 'safe']"
Safety,"/* - When there is no dictionary : loadedDictEnd == 0.; In which case, the test (blockEndIdx > maxDist) is merely to avoid; overflowing next operation `newLowLimit = blockEndIdx - maxDist`.; - When there is a standard dictionary :; Index referential is copied from the dictionary,; which means it starts from 0.; In which case, loadedDictEnd == dictSize,; and it makes sense to compare `blockEndIdx > maxDist + dictSize`; since `blockEndIdx` also starts from zero.; - When there is an attached dictionary :; loadedDictEnd is expressed within the referential of the context,; so it can be directly compared against blockEndIdx.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress_internal.h:117,avoid,avoid,117,builtins/zstd/compress/zstd_compress_internal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress_internal.h,1,['avoid'],['avoid']
Safety,"/* --- simple histogram functions --- */; /*! HIST_count():; * Provides the precise count of each byte within a table 'count'.; * 'count' is a table of unsigned int, of minimum size (*maxSymbolValuePtr+1).; * Updates *maxSymbolValuePtr with actual largest symbol value detected.; * @return : count of the most frequent symbol (which isn't identified).; * or an error code, which can be tested using HIST_isError().; * note : if return == srcSize, there is only one symbol.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/hist.h:269,detect,detected,269,builtins/zstd/compress/hist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/hist.h,1,['detect'],['detected']
Safety,"/* --------------------------------------------------------------------- */; /* The interface converts a whole buffer to avoid function-call overhead.; * Constants have been gathered. Loops & conditionals have been removed as; * much as possible for efficiency, in favor of drop-through switches.; * (See ""Note A"" at the bottom of the file for equivalent code.); * If your compiler supports it, the ""isLegalUTF8"" call can be turned; * into an inline function.; */; /* --------------------------------------------------------------------- */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ConvertUTF.cpp:121,avoid,avoid,121,interpreter/llvm-project/llvm/lib/Support/ConvertUTF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ConvertUTF.cpp,1,['avoid'],['avoid']
Safety,"/* ---------------------------------------------------------------------; The following 4 definitions are compiler-specific.; The C standard does not guarantee that wchar_t has at least; 16 bits, so wchar_t is no less portable than unsigned short!; All should be unsigned values to avoid sign extension during; bit mask & shift operations.; ------------------------------------------------------------------------ */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ConvertUTF.h:282,avoid,avoid,282,interpreter/llvm-project/llvm/include/llvm/Support/ConvertUTF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ConvertUTF.h,1,['avoid'],['avoid']
Safety,/* 10 second timeout */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:13,timeout,timeout,13,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['timeout'],['timeout']
Safety,"/* 32 on 64 bits (goal), 16 on 32 bits.; Just to avoid some static analyzer complaining about shift by 32 on 32-bits target.; Note that this code path is never triggered in 32-bits mode. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:49,avoid,avoid,49,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,1,['avoid'],['avoid']
Safety,/* <= exponent to base 10 */; /* Avoid underflow here. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:33,Avoid,Avoid,33,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['Avoid'],['Avoid']
Safety,/* <setjmp.h> is used for the optional error recovery mechanism */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/export.c:45,recover,recovery,45,graf2d/asimage/src/libAfterImage/export.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/export.c,2,['recover'],['recovery']
Safety,"/* === XXH3 streaming === */; /*; * Malloc's a pointer that is always aligned to align.; *; * This must be freed with `XXH_alignedFree()`.; *; * malloc typically guarantees 16 byte alignment on 64-bit systems and 8 byte; * alignment on 32-bit. This isn't enough for the 32 byte aligned loads in AVX2; * or on 32-bit, the 16 byte aligned loads in SSE2 and NEON.; *; * This underalignment previously caused a rather obvious crash which went; * completely unnoticed due to XXH3_createState() not actually being tested.; * Credit to RedSpah for noticing this bug.; *; * The alignment is done manually: Functions like posix_memalign or _mm_malloc; * are avoided: To maintain portability, we would have to write a fallback; * like this anyways, and besides, testing for the existence of library; * functions without relying on external build tools is impossible.; *; * The method is simple: Overallocate, manually align, and store the offset; * to the original behind the returned pointer.; *; * Align must be a power of 2 and 8 <= align <= 128.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:649,avoid,avoided,649,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['avoid'],['avoided']
Safety,/* ==========================================; * Vectorization detection; * ========================================== */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:63,detect,detection,63,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['detect'],['detection']
Safety,"/* ==========================================; * XXH3 128 bits (a.k.a XXH128); * ==========================================; * XXH3's 128-bit variant has better mixing and strength than the 64-bit variant,; * even without counting the significantly larger output size.; *; * For example, extra steps are taken to avoid the seed-dependent collisions; * in 17-240 byte inputs (See XXH3_mix16B and XXH128_mix32B).; *; * This strength naturally comes at the cost of some speed, especially on short; * lengths. Note that longer hashes are about as fast as the 64-bit version; * due to it using only a slight modification of the 64-bit loop.; *; * XXH128 is also more oriented towards 64-bit machines. It is still extremely; * fast for a _128-bit_ hash on 32-bit (it usually clears XXH64).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:313,avoid,avoid,313,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['avoid'],['avoid']
Safety,/* =========================================================================; * Flush as much pending output as possible. All deflate() output goes; * through this function so some applications may wish to modify it; * to avoid allocating a large strm->next_out buffer and copying into it.; * (See also read_buf()).; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:222,avoid,avoid,222,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,3,['avoid'],['avoid']
Safety,"/* ===========================================================================; * Copy without compression as much as possible from the input stream, return; * the current block state.; * This function does not insert new strings in the dictionary since; * uncompressible data is probably not useful. This function is used; * only for the level=0 compression option.; * NOTE: this function should be optimized to avoid extra copying from; * window to pending_buf.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:413,avoid,avoid,413,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,3,['avoid'],['avoid']
Safety,"/* ===========================================================================; * Initialize the ""longest match"" routines for a new file; *; * IN assertion: window_size is > 0 if the input file is already read or; * mmap'ed in the window[] array, 0 otherwise. In the first case,; * window_size is sufficient to contain the whole input file plus; * MIN_LOOKAHEAD bytes (to avoid referencing memory beyond the end; * of window[] when looking for matches towards the end).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c:372,avoid,avoid,372,core/zip/src/ZDeflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c,1,['avoid'],['avoid']
Safety,/* ===========================================================================; * Initialize the hash table (avoiding 64K overflow for 16 bit systems).; * prev[] will be initialized on the fly.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:109,avoid,avoiding,109,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,2,['avoid'],['avoiding']
Safety,"/* ===========================================================================; * Read a new buffer from the current input stream, update the adler32; * and total number of bytes read. All deflate() input goes through; * this function so some applications may wish to modify it to avoid; * allocating a large strm->next_in buffer and copying from it.; * (See also flush_pending()).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:281,avoid,avoid,281,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,3,['avoid'],['avoid']
Safety,"/* ===========================================================================; Returns 1 when EOF has previously been detected reading the given; input stream, otherwise zero.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/gzio.c:119,detect,detected,119,graf2d/asimage/src/libAfterImage/zlib/gzio.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/gzio.c,1,['detect'],['detected']
Safety,/* ?PROTO */; /* Avoid using const if compiler does not support it */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Tailor.h:17,Avoid,Avoid,17,core/zip/src/Tailor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Tailor.h,1,['Avoid'],['Avoid']
Safety,/* A thread-safe copy of ldmState.window */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c:12,safe,safe,12,builtins/zstd/compress/zstdmt_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c,1,['safe'],['safe']
Safety,/* Abort conversion. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ConvertUTF.cpp:3,Abort,Abort,3,interpreter/llvm-project/llvm/lib/Support/ConvertUTF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ConvertUTF.cpp,1,['Abort'],['Abort']
Safety,"/* Add a filler byte on read, or remove a filler or alpha byte on write.; * The filler type has changed in v0.95 to allow future 2-byte fillers; * for 48-bit input data, as well as to avoid problems with some compilers; * that don't like bytes as parameters.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngtrans.c:184,avoid,avoid,184,graf2d/asimage/src/libAfterImage/libpng/pngtrans.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngtrans.c,1,['avoid'],['avoid']
Safety,/* Added in libpng-1.6.0; this can be used to detect a read structure if; * required (it will be zero in a write structure.); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:46,detect,detect,46,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['detect'],['detect']
Safety,"/* Align the virtual buffers for the components used in this scan.; * NB: during first pass, this is safe only because the buffers will; * already be aligned properly, so jmemmgr.c won't need to do any I/O.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c:101,safe,safe,101,graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jccoefct.c,1,['safe'],['safe']
Safety,"/* Allocate space for script.; * We need to put it in the permanent pool in case the application performs; * multiple compressions without changing the settings. To avoid a memory; * leak if jpeg_simple_progression is called repeatedly for the same JPEG; * object, we try to re-use previously allocated space, and we allocate; * enough space to handle YCbCr even if initially asked for grayscale.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c:165,avoid,avoid,165,graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c,1,['avoid'],['avoid']
Safety,"/* An older compiler, or one not detected (erroneously) above,; * if necessary override on the command line to get the correct; * variants for the compiler.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngconf.h:33,detect,detected,33,graf2d/asimage/src/libAfterImage/libpng/pngconf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngconf.h,1,['detect'],['detected']
Safety,"/* And simply copy these bytes. Some optimization is possible here,; * depending on the value of 'bytes_to_copy'. Special case the low; * byte counts, which we know to be frequent.; *; * Notice that these cases all 'return' rather than 'break' - this; * avoids an unnecessary test on whether to restore the last byte; * below.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:254,avoid,avoids,254,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['avoid'],['avoids']
Safety,/* And the following is always safe because the crc is only 32 bits. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:31,safe,safe,31,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['safe'],['safe']
Safety,"/* Application errors (new in 1.6); use these functions (declared below) for; * errors in the parameters or order of API function calls on read. The; * 'warning' should be used for an error that can be handled completely; the; * 'error' for one which can be handled safely but which may lose application; * information or settings.; *; * By default these both result in a png_error call prior to release, while in a; * released version the 'warning' is just a warning. However if the application; * explicitly disables benign errors (explicitly permitting the code to lose; * information) they both turn into warnings.; *; * If benign errors aren't supported they end up as the corresponding base call; * (png_warning or png_error.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:266,safe,safely,266,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['safe'],['safely']
Safety,"/* As above but libpng will ignore the call, or attempt some other partial; * recovery from the error.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:78,recover,recovery,78,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['recover'],['recovery']
Safety,/* Attempt sane error recovery */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c:22,recover,recovery,22,graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,1,['recover'],['recovery']
Safety,/* Avoid Visual Studio warning if USE_SERVER_STATS is not; 	 * defined */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,Avoid,Avoid,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['Avoid'],['Avoid']
Safety,/* Avoid an endless loop that could occur when using an older version; of localcharset.c. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/iconv.c:3,Avoid,Avoid,3,graf2d/win32gdk/gdk/src/iconv/iconv.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/iconv.c,6,['Avoid'],['Avoid']
Safety,/* Avoid calling time() except for the first time.; * GetTickCount() should be pretty fast and low-level?; * I could also use ftime() but it seems unnecessarily overheady.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.c:3,Avoid,Avoid,3,graf2d/win32gdk/gdk/src/glib/gmain.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.c,1,['Avoid'],['Avoid']
Safety,/* Avoid overflow by doing the negate in a png_alloc_size_t: */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngerror.c:3,Avoid,Avoid,3,graf2d/asimage/src/libAfterImage/libpng/pngerror.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngerror.c,1,['Avoid'],['Avoid']
Safety,/* Avoid overflow here on the minimum integer. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:3,Avoid,Avoid,3,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['Avoid'],['Avoid']
Safety,/* Avoid overflow in pow() */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,Avoid,Avoid,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,3,['Avoid'],['Avoid']
Safety,/* Avoid unused warning if NO_SSL is set and DEBUG_TRACE is not; 	 used */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,Avoid,Avoid,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['Avoid'],['Avoid']
Safety,/* Avoid using the value 64K on 16 bit machines */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZTrees.c:3,Avoid,Avoid,3,core/zip/src/ZTrees.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZTrees.c,1,['Avoid'],['Avoid']
Safety,/* Avoid warnings for Xcode 7. It seems it does no longer exist in Xcode 8 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,Avoid,Avoid,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['Avoid'],['Avoid']
Safety,"/* Avoids a danger in threaded situations (calling close(); * on a file descriptor twice, and another thread has; * re-opened it since the first close); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gspawn-win32.c:3,Avoid,Avoids,3,graf2d/win32gdk/gdk/src/glib/gspawn-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gspawn-win32.c,2,['Avoid'],['Avoids']
Safety,/* Avoids the FORCE_INLINE of the _body() function. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/entropy_common.c:3,Avoid,Avoids,3,builtins/zstd/common/entropy_common.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/entropy_common.c,4,['Avoid'],['Avoids']
Safety,/* Basic sanity checks */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:9,sanity check,sanity checks,9,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['sanity check'],['sanity checks']
Safety,"/* Because of the limit checks above we know that the new,; * expanded, size will fit in a size_t (let alone an; * png_alloc_size_t). Use png_malloc_base here to avoid an; * extra OOM message.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:162,avoid,avoid,162,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['avoid'],['avoid']
Safety,"/* Byte arrays, an array of guint8. Implemented as a GArray,; * but type-safe.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/garray.h:73,safe,safe,73,graf2d/win32gdk/gdk/src/glib/garray.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/garray.h,1,['safe'],['safe']
Safety,"/* CGAL uses the name PTR as member name in its Handle class; * but its a macro defined in mmalloc.h of ROOT; * Safe it, disable it and then re-enable it later on*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Delaunay2D.h:112,Safe,Safe,112,math/mathcore/inc/Math/Delaunay2D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Delaunay2D.h,1,['Safe'],['Safe']
Safety,"/* Calculate the maximum bytes needed, adding a byte and a pixel; * for safety's sake; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:72,safe,safety,72,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['safe'],['safety']
Safety,"/* Calculations moved outside switch in an attempt to stop different; * compiler warnings. 'padding' is in *bits* within the last byte, it is; * an 'int' because pixel_depth becomes an 'int' in the expression below,; * and this calculation is used because it avoids warnings that other; * forms produced on either GCC or MSVC.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngtrans.c:259,avoid,avoids,259,graf2d/asimage/src/libAfterImage/libpng/pngtrans.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngtrans.c,1,['avoid'],['avoids']
Safety,"/* Call poll, but only for a maximum time of a few seconds.; 	 * This will allow to stop the server after some seconds, instead; 	 * of having to wait for a long socket timeout. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:169,timeout,timeout,169,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['timeout'],['timeout']
Safety,/* Callback < 0: Error. Abort init. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:24,Abort,Abort,24,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['Abort'],['Abort']
Safety,/* Cancel this because otherwise it would be used if the transforms; * require it. Don't cancel the 'valid' flag because this would prevent; * detection of duplicate chunks.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:143,detect,detection,143,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['detect'],['detection']
Safety,/* Case 2: not enough bytes available to detect anything */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/loop_unicode.h:41,detect,detect,41,graf2d/win32gdk/gdk/src/iconv/loop_unicode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/loop_unicode.h,1,['detect'],['detect']
Safety,"/* Changed in libpng-1.5.4 to limit the values to ensure overflow can't; * occur. Since the fixed point representation is asymmetrical it is; * possible for 1/gamma to overflow the limit of 21474 and this means the; * gamma value must be at least 5/100000 and hence at most 20000.0. For; * safety the limits here are a little narrower. The values are 0.00016 to; * 6250.0, which are truly ridiculous gamma values (and will produce; * displays that are all black or all white.); *; * In 1.6.0 this test replaces the ones in pngrutil.c, in the gAMA chunk; * handling code, which only required the value to be >0.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:290,safe,safety,290,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['safe'],['safety']
Safety,"/* Check the magicword and magicbyte, and if either is corrupted then; call the emergency abort function specified for the heap in use. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mmcheck.c:90,abort,abort,90,core/clib/src/mmcheck.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mmcheck.c,1,['abort'],['abort']
Safety,"/* Check xy and, implicitly, z. Note that wide gamut color spaces typically; * have end points with 0 tristimulus values (these are impossible end; * points, but they are used to cover the possible colors). We check; * xy->whitey against 5, not 0, to avoid a possible integer overflow.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:251,avoid,avoid,251,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['avoid'],['avoid']
Safety,"/* Close all backing store, release all memory.; * Releasing pools in reverse order might help avoid fragmentation; * with some (brain-damaged) malloc libraries.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:95,avoid,avoid,95,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,1,['avoid'],['avoid']
Safety,"/* Compute symbols and rankStart given rankVal:; *; * rankVal already contains the number of values of each weight.; *; * symbols contains the symbols ordered by weight. First are the rankVal[0]; * weight 0 symbols, followed by the rankVal[1] weight 1 symbols, and so on.; * symbols[0] is filled (but unused) to avoid a branch.; *; * rankStart contains the offset where each rank belongs in the DTable.; * rankStart[0] is not filled because there are no entries in the table for; * weight 0.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/huf_decompress.c:312,avoid,avoid,312,builtins/zstd/decompress/huf_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/huf_decompress.c,1,['avoid'],['avoid']
Safety,"/* Constants for known chunk types. If you need to add a chunk, define the name; * here. For historical reasons these constants have the form png_<name>; i.e.; * the prefix is lower case. Please use decimal values as the parameters to; * match the ISO PNG specification and to avoid relying on the C locale; * interpretation of character values.; *; * Prior to 1.5.6 these constants were strings, as of 1.5.6 png_uint_32 values; * are computed and a new macro (PNG_STRING_FROM_CHUNK) added to allow a string; * to be generated if required.; *; * PNG_32b correctly produces a value shifted by up to 24 bits, even on; * architectures where (int) is only 16 bits.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:277,avoid,avoid,277,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['avoid'],['avoid']
Safety,"/* Constants for known chunk types.; *; * MAINTAINERS: If you need to add a chunk, define the name here.; * For historical reasons these constants have the form png_<name>; i.e.; * the prefix is lower case. Please use decimal values as the parameters to; * match the ISO PNG specification and to avoid relying on the C locale; * interpretation of character values. Please keep the list sorted.; *; * Notice that PNG_U32 is used to define a 32-bit value for the 4 byte chunk; * type. In fact the specification does not express chunk types this way,; * however using a 32-bit value means that the chunk type can be read from the; * stream using exactly the same code as used for a 32-bit unsigned value and; * can be examined far more efficiently (using one arithmetic compare).; *; * Prior to 1.5.6 the chunk type constants were expressed as C strings. The; * libpng API still uses strings for 'unknown' chunks and a macro,; * PNG_STRING_FROM_CHUNK, allows a string to be generated if required. Notice; * that for portable code numeric values must still be used; the string ""IHDR""; * is not portable and neither is PNG_U32('I', 'H', 'D', 'R').; *; * In 1.7.0 the definitions will be made public in png.h to avoid having to; * duplicate the same definitions in application code.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:296,avoid,avoid,296,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,2,['avoid'],['avoid']
Safety,"/* Continue, append next wchar_t, but avoid buffer overrun. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/loop_wchar.h:38,avoid,avoid,38,graf2d/win32gdk/gdk/src/iconv/loop_wchar.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/loop_wchar.h,1,['avoid'],['avoid']
Safety,"/* Copy the control structure so that the original, allocated, version can be; * safely freed. Notice that a png_error here stops the remainder of the; * cleanup, but this is probably fine because that would indicate bad memory; * problems anyway.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:81,safe,safely,81,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['safe'],['safely']
Safety,/* Count the number of repeats. Each time the; * 2-bit repeat code is 0b11 there is another; * repeat.; * Avoid UB by setting the high bit to 1.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/entropy_common.c:106,Avoid,Avoid,106,builtins/zstd/common/entropy_common.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/entropy_common.c,1,['Avoid'],['Avoid']
Safety,/* Critical chunks can be safely discarded at this point. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:26,safe,safely,26,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['safe'],['safely']
Safety,/* DYN_ALLOC */; /* Initialize the hash table (avoiding 64K overflow for 16 bit systems).; * prev[] will be initialized on the fly.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c:47,avoid,avoiding,47,core/zip/src/ZDeflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c,1,['avoid'],['avoiding']
Safety,/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/win32/config.h:26,safe,safely,26,graf2d/asimage/src/libAfterImage/win32/config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/win32/config.h,1,['safe'],['safely']
Safety,"/* Define to 1 if you want getc etc. to use unlocked I/O if available.; Unlocked I/O can improve performance in unithreaded apps, but it is not; safe for multithreaded apps. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/config.h:145,safe,safe,145,graf2d/win32gdk/gdk/src/iconv/config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/config.h,1,['safe'],['safe']
Safety,"/* Detect gray background and attempt to enable optimization for; * gray --> RGB case.; *; * Note: if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or; * RGB_ALPHA (in which case need_expand is superfluous anyway), the; * background color might actually be gray yet not be flagged as such.; * This is not a problem for the current code, which uses; * PNG_BACKGROUND_IS_GRAY only to decide when to do the; * png_do_gray_to_rgb() transformation.; *; * TODO: this code needs to be revised to avoid the complexity and; * interdependencies. The color type of the background should be recorded in; * png_set_background, along with the bit depth, then the code has a record; * of exactly what color space the background is currently in.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:3,Detect,Detect,3,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,2,"['Detect', 'avoid']","['Detect', 'avoid']"
Safety,/* DetectVirtual=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp:3,Detect,DetectVirtual,3,interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,1,['Detect'],['DetectVirtual']
Safety,/* Detected in the extension string or strings */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/src/glew.c:3,Detect,Detected,3,builtins/glew/src/glew.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/src/glew.c,1,['Detect'],['Detected']
Safety,/* Detected via extension string or experimental mode */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/src/glew.c:3,Detect,Detected,3,builtins/glew/src/glew.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/src/glew.c,1,['Detect'],['Detected']
Safety,"/* Do all the *safe* initialization - 'safe' means that png_error won't be; * called, so setting up the jmp_buf is not required. This means that anything; * called from here must *not* call png_malloc - it has to call png_malloc_warn; * instead so that control is returned safely back to this routine.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:15,safe,safe,15,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,3,['safe'],"['safe', 'safely']"
Safety,"/* Do the main body of a 'png_image_begin_read' function; read the PNG file; * header and fill in all the information. This is executed in a safe context,; * unlike the init routine above.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:141,safe,safe,141,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['safe'],['safe']
Safety,"/* Do this first in case of an error below; if the app implements its own; * memory management this can lead to png_free calling png_error, which; * will abort this routine and return control to the app error handler.; * An infinite loop may result if it then tries to free the same info; * ptr.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:154,abort,abort,154,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['abort'],['abort']
Safety,/* Do this for safety; we won't read any more into this row. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:15,safe,safety,15,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['safe'],['safety']
Safety,"/* Don't validate for NULL encoding, binary safe */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c:44,safe,safe,44,graf2d/win32gdk/gdk/src/glib/giochannel.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c,1,['safe'],['safe']
Safety,/* ERROR_TEXT */; /* Utility to safely appends strings to a buffer. This never errors out so; * error checking is not required in the caller.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngerror.c:32,safe,safely,32,graf2d/asimage/src/libAfterImage/libpng/pngerror.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngerror.c,1,['safe'],['safely']
Safety,/* Each memory allocation is bounded by a header structure and a trailer; byte. I.E. <size><magicword><user's allocation><magicbyte>. The pointer returned to the user points to the first byte in the; user's allocation area. The magic word can be tested to detect; buffer underruns and the magic byte can be tested to detect overruns. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mmcheck.c:256,detect,detect,256,core/clib/src/mmcheck.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mmcheck.c,2,['detect'],['detect']
Safety,"/* Emit DRI if required --- note that DRI value could change for each scan.; * We avoid wasting space with unnecessary DRIs, however.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmarker.c:82,avoid,avoid,82,graf2d/asimage/src/libAfterImage/libjpeg/jcmarker.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmarker.c,1,['avoid'],['avoid']
Safety,/* Escape all unsafe characters */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gconvert.c:14,unsafe,unsafe,14,graf2d/win32gdk/gdk/src/glib/gconvert.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gconvert.c,1,['unsafe'],['unsafe']
Safety,/* FIXME error detection? */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giowin32.c:15,detect,detection,15,graf2d/win32gdk/gdk/src/glib/giowin32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giowin32.c,2,['detect'],['detection']
Safety,/* Fastpath check: Avoids a branch in LZ4_wildCopy32 if true */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:19,Avoid,Avoids,19,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,1,['Avoid'],['Avoids']
Safety,/* Fatal error - abort start. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:17,abort,abort,17,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,6,['abort'],['abort']
Safety,"/* Fatal error - abort start. However, this situation should never; 		 * occur in practice. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:17,abort,abort,17,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['abort'],['abort']
Safety,"/* Figure C.3: generate encoding tables */; /* These are code and size indexed by symbol value */; /* Set all codeless symbols to have code length 0;; * this lets us detect duplicate VAL entries here, and later; * allows emit_bits to detect any attempt to emit such symbols.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c:166,detect,detect,166,graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,2,['detect'],['detect']
Safety,"/* Fill the buffer, but not more than what we can dump out in one go. */; /* Note we rely on the upsampler to detect bottom of image. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdpostct.c:110,detect,detect,110,graf2d/asimage/src/libAfterImage/libjpeg/jdpostct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdpostct.c,1,['detect'],['detect']
Safety,"/* Find the best predictor, the least of pa, pb, pc favoring the earlier; * ones in the case of a tie.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:17,predict,predictor,17,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['predict'],['predictor']
Safety,"/* First time. Ensure we have a temporary buffer for compression and; * trim the buffer list if it has more than one entry to free memory.; * If 'WRITE_COMPRESSED_TEXT' is not set the list will never have been; * created at this point, but the check here is quick and safe.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c:268,safe,safe,268,graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,1,['safe'],['safe']
Safety,"/* First, ensure we have YCbCr or grayscale data, and that the source's; * Y channel is full resolution. (No reasonable person would make Y; * be less than full resolution, so actually coping with that case; * isn't worth extra code space. But we check it to avoid crashing.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/transupp.c:259,avoid,avoid,259,graf2d/asimage/src/libAfterImage/libjpeg/transupp.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/transupp.c,1,['avoid'],['avoid']
Safety,"/* For pixel depths up to 4 bpp the 8-pixel mask can be expanded to fit; * into 32 bits, then a single loop over the bytes using the four byte; * values in the 32-bit mask can be used. For the 'display' option the; * expanded mask may also not require any masking within a byte. To; * make this work the PACKSWAP option must be taken into account - it; * simply requires the pixels to be reversed in each byte.; *; * The 'regular' case requires a mask for each of the first 6 passes,; * the 'display' case does a copy for the even passes in the range; * 0..6. This has already been handled in the test above.; *; * The masks are arranged as four bytes with the first byte to use in; * the lowest bits (little-endian) regardless of the order (PACKSWAP or; * not) of the pixels in each byte.; *; * NOTE: the whole of this logic depends on the caller of this function; * only calling it on rows appropriate to the pass. This function only; * understands the 'x' logic; the 'y' logic is handled by the caller.; *; * The following defines allow generation of compile time constant bit; * masks for each pixel depth and each possibility of swapped or not; * swapped bytes. Pass 'p' is in the range 0..6; 'x', a pixel index,; * is in the range 0..7; and the result is 1 if the pixel is to be; * copied in the pass, 0 if not. 'S' is for the sparkle method, 'B'; * for the block method.; *; * With some compilers a compile time expression of the general form:; *; * (shift >= 32) ? (a >> (shift-32)) : (b >> shift); *; * Produces warnings with values of 'shift' in the range 33 to 63; * because the right hand side of the ?: expression is evaluated by; * the compiler even though it isn't used. Microsoft Visual C (various; * versions) and the Intel C compiler are known to do this. To avoid; * this the following macros are used in 1.5.6. This is a temporary; * solution to avoid destabilizing the code during the release process.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:1777,avoid,avoid,1777,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,2,['avoid'],['avoid']
Safety,"/* For safety clear out the input and output pointers (currently zlib; * doesn't use them on Init, but it might in the future).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c:7,safe,safety,7,graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,1,['safe'],['safety']
Safety,/* For safety kill the local buffer pointer now */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:7,safe,safety,7,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['safe'],['safety']
Safety,"/* For some reason WTEnable and/or WTClose tend to crash here.; * Protect with __try/__except to avoid a message box.; * When compiling with gcc, we cannot use __try/__except, so; * don't call WTClose. I think this means that we'll; * eventually run out of Wintab contexts, sigh.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkinput-win32.c:97,avoid,avoid,97,graf2d/win32gdk/gdk/src/gdk/win32/gdkinput-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkinput-win32.c,1,['avoid'],['avoid']
Safety,/* GCC requires a DLL entry point even without any standard library included. */; /* Types extracted from windows.h to avoid polluting the rest of the file. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/src/glew.c:119,avoid,avoid,119,builtins/glew/src/glew.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/src/glew.c,1,['avoid'],['avoid']
Safety,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * GAsyncQueue: asynchronous queue implementation, based on Gqueue.; * Copyright (C) 2000 Sebastian Wilhelmi; University of Karlsruhe; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /*; * MT safe; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c:1022,safe,safe,1022,graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gasyncqueue.c,1,['safe'],['safe']
Safety,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * GAsyncQueue: thread pool implementation.; * Copyright (C) 2000 Sebastian Wilhelmi; University of Karlsruhe; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /*; * MT safe; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.c:998,safe,safe,998,graf2d/win32gdk/gdk/src/glib/gthreadpool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.c,1,['safe'],['safe']
Safety,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * GHook: Callback maintenance functions; * Copyright (C) 1998 Tim Janik; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /*; * Modified by the GLib Team and others 1997-2000. See the AUTHORS; * file for a list of people on the GLib Team. See the ChangeLog; * files for a list of changes. These files are distributed with; * GLib at ftp://ftp.gtk.org/pub/gtk/. ; */; /* ; * MT safe; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/ghook.c:1208,safe,safe,1208,graf2d/win32gdk/gdk/src/glib/ghook.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/ghook.c,1,['safe'],['safe']
Safety,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * GNode: N-way tree implementation.; * Copyright (C) 1998 Tim Janik; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /*; * Modified by the GLib Team and others 1997-2000. See the AUTHORS; * file for a list of people on the GLib Team. See the ChangeLog; * files for a list of changes. These files are distributed with; * GLib at ftp://ftp.gtk.org/pub/gtk/. ; */; /* ; * MT safe; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gnode.c:1204,safe,safe,1204,graf2d/win32gdk/gdk/src/glib/gnode.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gnode.c,1,['safe'],['safe']
Safety,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * GQueue: Double ended queue implementation, piggy backed on GList.; * Copyright (C) 1998 Tim Janik; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /*; * MT safe; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gqueue.c:989,safe,safe,989,graf2d/win32gdk/gdk/src/glib/gqueue.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gqueue.c,1,['safe'],['safe']
Safety,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * GScanner: Flexible lexical scanner for general purpose.; * Copyright (C) 1997, 1998 Tim Janik; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /*; * Modified by the GLib Team and others 1997-2000. See the AUTHORS; * file for a list of people on the GLib Team. See the ChangeLog; * files for a list of changes. These files are distributed with; * GLib at ftp://ftp.gtk.org/pub/gtk/. ; */; /* ; * MT safe; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gscanner.c:1232,safe,safe,1232,graf2d/win32gdk/gdk/src/glib/gscanner.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gscanner.c,1,['safe'],['safe']
Safety,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /*; * Modified by the GLib Team and others 1997-2000. See the AUTHORS; * file for a list of people on the GLib Team. See the ChangeLog; * files for a list of changes. These files are distributed with; * GLib at ftp://ftp.gtk.org/pub/gtk/. ; */; /* ; * MT safe; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gcompletion.c:1132,safe,safe,1132,graf2d/win32gdk/gdk/src/glib/gcompletion.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gcompletion.c,5,['safe'],['safe']
Safety,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /*; * Modified by the GLib Team and others 1997-2000. See the AUTHORS; * file for a list of people on the GLib Team. See the ChangeLog; * files for a list of changes. These files are distributed with; * GLib at ftp://ftp.gtk.org/pub/gtk/. ; */; /*; * MT safe; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gstrfuncs.c:1131,safe,safe,1131,graf2d/win32gdk/gdk/src/glib/gstrfuncs.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gstrfuncs.c,1,['safe'],['safe']
Safety,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the Free; * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.; */; /*; * Modified by the GLib Team and others 1997-2000. See the AUTHORS; * file for a list of people on the GLib Team. See the ChangeLog; * files for a list of changes. These files are distributed with; * GLib at ftp://ftp.gtk.org/pub/gtk/. ; */; /* ; * MT safe; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/grel.c:1111,safe,safe,1111,graf2d/win32gdk/gdk/src/glib/grel.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/grel.c,1,['safe'],['safe']
Safety,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /* Originally developed and coded by Makoto Matsumoto and Takuji; * Nishimura. Please mail <matumoto@math.keio.ac.jp>, if you're using; * code from this file in your own programs or libraries.; * Further information on the Mersenne Twister can be found at; * http://www.math.keio.ac.jp/~matumoto/emt.html; * This code was adapted to glib by Sebastian Wilhelmi <wilhelmi@ira.uka.de>.; */; /*; * Modified by the GLib Team and others 1997-2000. See the AUTHORS; * file for a list of people on the GLib Team. See the ChangeLog; * files for a list of changes. These files are distributed with; * GLib at ftp://ftp.gtk.org/pub/gtk/. ; */; /* ; * MT safe; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/grand.c:1519,safe,safe,1519,graf2d/win32gdk/gdk/src/glib/grand.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/grand.c,1,['safe'],['safe']
Safety,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /*; * Modified by the GLib Team and others 1997-2000. See the AUTHORS; * file for a list of people on the GLib Team. See the ChangeLog; * files for a list of changes. These files are distributed with; * GLib at ftp://ftp.gtk.org/pub/gtk/. ; */; /* ; * MT safe ; except for g_on_error_stack_trace, but who wants thread safety ; * then; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gbacktrace.c:1131,safe,safe,1131,graf2d/win32gdk/gdk/src/glib/gbacktrace.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gbacktrace.c,2,['safe'],"['safe', 'safety']"
Safety,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /*; * Modified by the GLib Team and others 1997-2000. See the AUTHORS; * file for a list of people on the GLib Team. See the ChangeLog; * files for a list of changes. These files are distributed with; * GLib at ftp://ftp.gtk.org/pub/gtk/. ; */; /* ; * MT safe; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/garray.c:1131,safe,safe,1131,graf2d/win32gdk/gdk/src/glib/garray.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/garray.c,8,['safe'],['safe']
Safety,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * gdataset.c: Generic dataset mechanism, similar to GtkObject data.; * Copyright (C) 1998 Tim Janik; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the Free Software; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.; */; /*; * Modified by the GLib Team and others 1997-2000. See the AUTHORS; * file for a list of people on the GLib Team. See the ChangeLog; * files for a list of changes. These files are distributed with; * GLib at ftp://ftp.gtk.org/pub/gtk/. ; */; /* ; * MT safe ; FIXME: might still freeze, watch out, not thoroughly; * looked at yet. ; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gdataset.c:1231,safe,safe,1231,graf2d/win32gdk/gdk/src/glib/gdataset.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gdataset.c,1,['safe'],['safe']
Safety,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * giochannel.c: IO Channel abstraction; * Copyright 1998 Owen Taylor; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /*; * Modified by the GLib Team and others 1997-2000. See the AUTHORS; * file for a list of people on the GLib Team. See the ChangeLog; * files for a list of changes. These files are distributed with; * GLib at ftp://ftp.gtk.org/pub/gtk/. ; */; /* ; * MT safe; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c:1205,safe,safe,1205,graf2d/win32gdk/gdk/src/glib/giochannel.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c,1,['safe'],['safe']
Safety,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * giounix.c: IO Channels using unix file descriptors; * Copyright 1998 Owen Taylor; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /*; * Modified by the GLib Team and others 1997-2000. See the AUTHORS; * file for a list of people on the GLib Team. See the ChangeLog; * files for a list of changes. These files are distributed with; * GLib at ftp://ftp.gtk.org/pub/gtk/. ; */; /* ; * MT safe; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giounix.c:1219,safe,safe,1219,graf2d/win32gdk/gdk/src/glib/giounix.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giounix.c,1,['safe'],['safe']
Safety,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * gmain.c: Main loop abstraction, timeouts, and idle functions; * Copyright 1998 Owen Taylor; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /*; * Modified by the GLib Team and others 1997-2000. See the AUTHORS; * file for a list of people on the GLib Team. See the ChangeLog; * files for a list of changes. These files are distributed with; * GLib at ftp://ftp.gtk.org/pub/gtk/. ; */; /* ; * MT safe; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.c:169,timeout,timeouts,169,graf2d/win32gdk/gdk/src/glib/gmain.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.c,2,"['safe', 'timeout']","['safe', 'timeouts']"
Safety,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * gmutex.c: MT safety related functions; * Copyright 1998 Sebastian Wilhelmi; University of Karlsruhe; * Owen Taylor; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /*; * Modified by the GLib Team and others 1997-2000. See the AUTHORS; * file for a list of people on the GLib Team. See the ChangeLog; * files for a list of changes. These files are distributed with; * GLib at ftp://ftp.gtk.org/pub/gtk/. ; */; /* ; * MT safe; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthread.c:150,safe,safety,150,graf2d/win32gdk/gdk/src/glib/gthread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthread.c,2,['safe'],"['safe', 'safety']"
Safety,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1998 Peter Mattis, Spencer Kimball and Josh MacDonald; * Copyright (C) 1998-1999 Tor Lillqvist; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /*; * Modified by the GLib Team and others 1997-2000. See the AUTHORS; * file for a list of people on the GLib Team. See the ChangeLog; * files for a list of changes. These files are distributed with; * GLib at ftp://ftp.gtk.org/pub/gtk/. ; */; /* ; * MT safe for the unix part, FIXME: make the win32 part MT safe as well.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gwin32.c:1173,safe,safe,1173,graf2d/win32gdk/gdk/src/glib/gwin32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gwin32.c,2,['safe'],['safe']
Safety,"/* GLIB - Library of useful routines for C programming; * Copyright (C) 1995-1998 Peter Mattis, Spencer Kimball and Josh MacDonald; *; * This library is free software; you can redistribute it and/or; * modify it under the terms of the GNU Lesser General Public; * License as published by the Free Software Foundation; either; * version 2 of the License, or (at your option) any later version.; *; * This library is distributed in the hope that it will be useful,; * but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU; * Lesser General Public License for more details.; *; * You should have received a copy of the GNU Lesser General Public; * License along with this library; if not, write to the; * Free Software Foundation, Inc., 59 Temple Place - Suite 330,; * Boston, MA 02111-1307, USA.; */; /*; * Modified by the GLib Team and others 1997-2000. See the AUTHORS; * file for a list of people on the GLib Team. See the ChangeLog; * files for a list of changes. These files are distributed with; * GLib at ftp://ftp.gtk.org/pub/gtk/. ; */; /* ; * MT safe for the unix part, FIXME: make the win32 part MT safe as well.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutils.c:1132,safe,safe,1132,graf2d/win32gdk/gdk/src/glib/gutils.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutils.c,2,['safe'],['safe']
Safety,"/* Gamma correct the image, avoiding the alpha channel. Make sure; * you do this after you deal with the transparency issue on grayscale; * or RGB images. If your bit depth is 8, use gamma_table, if it; * is 16, use gamma_16_table and gamma_shift. Build these with; * build_gamma_table().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:28,avoid,avoiding,28,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,1,['avoid'],['avoiding']
Safety,"/* Get a copy of the background color (this avoids repeating the checks; * below.) The encoding is 8-bit sRGB or 16-bit linear, depending on the; * output format.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:44,avoid,avoids,44,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['avoid'],['avoids']
Safety,/* Get timeout in seconds */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:7,timeout,timeout,7,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['timeout'],['timeout']
Safety,/* Helper class to avoid compiler warning about casting function pointer; ** to void pointer.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/RtypesImp.h:19,avoid,avoid,19,core/base/inc/RtypesImp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/RtypesImp.h,1,['avoid'],['avoid']
Safety,/* Here neither threads nor tasks are queued and we didn't; 	 * just return from a timed wait. We now wait for a limited; 	 * time at this pool for new tasks to avoid costly context; 	 * switches. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.c:161,avoid,avoid,161,graf2d/win32gdk/gdk/src/glib/gthreadpool.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gthreadpool.c,1,['avoid'],['avoid']
Safety,/* Here we just do minimal validation of the counts to avoid walking; * off the end of our table space. jdhuff.c will check more carefully.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c:55,avoid,avoid,55,graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c,1,['avoid'],['avoid']
Safety,/* High water mark offset in window for initialized bytes -- bytes above; * this are set to zero in order to avoid memory check warnings when; * longest match routines access bytes past the input. This is then; * updated to the new high water mark.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.h:109,avoid,avoid,109,builtins/zlib/deflate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.h,2,['avoid'],['avoid']
Safety,/* How to detect NEON? */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_dispatch.c:10,detect,detect,10,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_dispatch.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_dispatch.c,1,['detect'],['detect']
Safety,"/* I'm not sure if fstat on a non-file (e.g., socket) works; * it should be safe to say if it fails, the fd isn't seekable.; */; /* Newer UNIX versions support S_ISSOCK(), fstat() will probably; * succeed in most cases.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giounix.c:76,safe,safe,76,graf2d/win32gdk/gdk/src/glib/giounix.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giounix.c,1,['safe'],['safe']
Safety,"/* IRIGHT_SHIFT is like RIGHT_SHIFT, but works on int rather than INT32.; * We assume that int right shift is unsigned if INT32 right shift is,; * which should be safe.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c:163,safe,safe,163,graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,2,['safe'],['safe']
Safety,/* Idles and timeouts */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.h:13,timeout,timeouts,13,graf2d/win32gdk/gdk/src/glib/gmain.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.h,1,['timeout'],['timeouts']
Safety,"/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a; * smaller value of window_bits if it can do so safely.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:117,safe,safely,117,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,4,['safe'],['safely']
Safety,"/* If control reaches this point, png_longjmp() must not return. The only; * choice is to terminate the whole process (or maybe the thread); to do; * this the ANSI-C abort() function is used unless a different method is; * implemented by overriding the default configuration setting for; * PNG_ABORT().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngerror.c:166,abort,abort,166,graf2d/asimage/src/libAfterImage/libpng/pngerror.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngerror.c,1,['abort'],['abort']
Safety,"/* If eparm is NULL, the parm string is invalid, and we should; 			 * abort processing. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/afterbase.c:70,abort,abort,70,graf2d/asimage/src/libAfterImage/afterbase.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/afterbase.c,1,['abort'],['abort']
Safety,"/* If the WIN_INIT bytes after the end of the current data have never been; * written, then zero those bytes in order to avoid memory check reports of; * the use of uninitialized (or uninitialised as Julian writes) bytes by; * the longest match routines. Update the high water mark for the next; * time through here. WIN_INIT is set to MAX_MATCH since the longest match; * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:121,avoid,avoid,121,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,4,['avoid'],['avoid']
Safety,"/* If the table hasn't been used, it's guaranteed to be zeroed out, and is; * therefore safe to use no matter what mode we're in. Otherwise, we figure; * out if it's safe to leave as is or whether it needs to be reset.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:88,safe,safe,88,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,2,['safe'],['safe']
Safety,"/* If we don't want to use the data from an ancillary chunk,; * we have two options: an error abort, or a warning and we; * ignore the data in this chunk (which should be OK, since; * it's considered ancillary for a RGB or RGBA image).; *; * IMPLEMENTATION NOTE: this is only here because png_crc_finish uses the; * chunk type to determine whether to check the ancillary or the critical; * flags.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:94,abort,abort,94,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['abort'],['abort']
Safety,"/* In case of checking C code, or when the corresponding headers are not; * included, we might end up query the identifier table every time when this; * function is called instead of early returning it. To avoid this, a bool; * variable (IdentifierInfoInitialized) is used and the function will be run; * only once. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BlockInCriticalSectionChecker.cpp:206,avoid,avoid,206,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BlockInCriticalSectionChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BlockInCriticalSectionChecker.cpp,1,['avoid'],['avoid']
Safety,"/* In fact it is an error if it isn't supported, but checking is; * the safe way.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:72,safe,safe,72,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['safe'],['safe']
Safety,"/* In principle, we can safely assume that each attribute key is associated to a single value,; * i.e. one extent per I/O descriptor; and that the corresponding data is copied to exactly one; * I/O vector. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx:24,safe,safely,24,tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx,1,['safe'],['safely']
Safety,"/* In the current implementation, we don't actually need to examine the; * option flag here; we just copy everything that got saved.; * But to avoid confusion, we do not output JFIF and Adobe APP14 markers; * if the encoder library already wrote one.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/transupp.c:143,avoid,avoid,143,graf2d/asimage/src/libAfterImage/libjpeg/transupp.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/transupp.c,1,['avoid'],['avoid']
Safety,/* Infinite timeout; 		 * -> WaitMessage; 		 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.c:12,timeout,timeout,12,graf2d/win32gdk/gdk/src/glib/gmain.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.c,1,['timeout'],['timeout']
Safety,"/* Initial wild guess at how far apart the farthest pixel; * pair we will be eliminating will be. Larger; * numbers mean more areas will be allocated, Smaller; * numbers run the risk of not saving enough data, and; * having to do this all over again.; *; * I have not done extensive checking on this number.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:178,risk,risk,178,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,1,['risk'],['risk']
Safety,/* Initialize DC predictions to 0 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c:17,predict,predictions,17,graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c,6,['predict'],['predictions']
Safety,/* Initialize full table for safety. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c:29,safe,safety,29,graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c,2,['safe'],['safety']
Safety,"/* Initialize locking callbacks, needed for thread safety.; 	 * http://www.openssl.org/support/faq.html#PROG1; 	 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:51,safe,safety,51,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['safe'],['safety']
Safety,"/* Initialize the default malloc descriptor if this is the first time; a request has been made to use the default sbrk'd region. Since no alignment guarantees are made about the initial value returned; by sbrk, test the initial value and (if necessary) sbrk enough additional; memory to start off with alignment to BLOCKSIZE. We actually only need; it aligned to an alignment suitable for any object, so this is overkill.; But at most it wastes just part of one BLOCKSIZE chunk of memory and; minimizes portability problems by avoiding us having to figure out; what the actual minimal alignment is. The rest of the malloc code; avoids this as well, by always aligning to the minimum of the requested; size rounded up to a power of two, or to BLOCKSIZE. Note that we are going to use some memory starting at this initial sbrk; address for the sbrk region malloc descriptor, which is a struct, so the; base address must be suitably aligned. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/sbrksup.c:527,avoid,avoiding,527,core/clib/src/sbrksup.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/sbrksup.c,2,['avoid'],"['avoiding', 'avoids']"
Safety,"/* Initialize this library. This should be called once before any other; * function from this library. This function is not guaranteed to be; * thread safe.; * Parameters:; * features: bit mask for features to be initialized.; * Note: The TLS libraries (like OpenSSL) is initialized; * only if the MG_FEATURES_TLS bit is set.; * Currently the other bits do not influence; * initialization, but this may change in future; * versions.; * Return value:; * initialized features; * 0: error; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.h:151,safe,safe,151,net/http/civetweb/civetweb.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.h,1,['safe'],['safe']
Safety,/* Initialize total-height counter for detecting bottom of image */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcprepct.c:39,detect,detecting,39,graf2d/asimage/src/libAfterImage/libjpeg/jcprepct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcprepct.c,3,['detect'],['detecting']
Safety,/* Is this a build of a DLL where compilation of the object modules requires; * different preprocessor settings to those required for a simple library? If; * so PNG_BUILD_DLL must be set.; *; * If libpng is used inside a DLL but that DLL does not export the libpng APIs; * PNG_BUILD_DLL must not be set. To avoid the code below kicking in build a; * static library of libpng then link the DLL against that.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:307,avoid,avoid,307,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['avoid'],['avoid']
Safety,"/* It's necessary to reset the context,; * and not just continue it with prepareTable(); * to avoid any risk of generating overflowing matchIndex; * when compressing using this dictionary */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:94,avoid,avoid,94,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,2,"['avoid', 'risk']","['avoid', 'risk']"
Safety,/* Join all worker threads to avoid leaking threads. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:30,avoid,avoid,30,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['avoid'],['avoid']
Safety,"/* LZ4HC_encodeSequence() :; * @return : 0 if ok,; * 1 if buffer issue detected */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4hc.c:71,detect,detected,71,builtins/lz4/lz4hc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4hc.c,1,['detect'],['detected']
Safety,/* LZ4_DISTANCE_MAX can be safely replaced by srcSize when it's smaller */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:27,safe,safely,27,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['safe'],['safely']
Safety,"/* LZ4_H_2983827168210 */; /*^*************************************; * !!!!!! STATIC LINKING ONLY !!!!!!; ***************************************/; /*-****************************************************************************; * Experimental section; *; * Symbols declared in this section must be considered unstable. Their; * signatures or semantics may change, or they may be removed altogether in the; * future. They are therefore only safe to depend on when the caller is; * statically linked against the library.; *; * To protect against unsafe usage, not only are the declarations guarded,; * the definitions are hidden by default; * when building LZ4 as a shared/dynamic library.; *; * In order to access these declarations,; * define LZ4_STATIC_LINKING_ONLY in your application; * before including LZ4's headers.; *; * In order to make their implementations accessible dynamically, you must; * define LZ4_PUBLISH_STATIC_FUNCTIONS when building the LZ4 library.; ******************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:441,safe,safe,441,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"/* Likewise */; /* We would like to #include any system header file which could define; iconv_t, 1. in order to eliminate the risk that the user gets compilation; errors because some other system header file includes /usr/include/iconv.h; which defines iconv_t or declares iconv after this file, 2. when compiling; for LIBICONV_PLUG, we need the proper iconv_t type in order to produce; binary compatible code.; But gcc's #include_next is not portable. Thus, once libiconv's iconv.h; has been installed in /usr/local/include, there is no way any more to; include the original /usr/include/iconv.h. We simply have to get away; without it.; Ad 1. The risk that a system header file does; #include ""iconv.h"" or #include_next ""iconv.h""; is small. They all do #include <iconv.h>.; Ad 2. The iconv_t type is a pointer type in all cases I have seen. (It; has to be a scalar type because (iconv_t)(-1) is a possible return value; from iconv_open().) */; /* Define iconv_t ourselves. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/iconv.h:126,risk,risk,126,graf2d/win32gdk/gdk/src/iconv/iconv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/iconv.h,2,['risk'],['risk']
Safety,/* Load up working state.; * We can avoid loading/saving bitread state if in an EOB run.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c:36,avoid,avoid,36,graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,1,['avoid'],['avoid']
Safety,"/* MAX_CORR_BITS is the number of bits the AC refinement correction-bit; * buffer can hold. Larger sizes may slightly improve compression, but; * 1000 is already well into the realm of overkill.; * The minimum safe size is 64 bits.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c:210,safe,safe,210,graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,2,['safe'],['safe']
Safety,"/* Make sure there is something to do and avoid duplicate consecutive; * flushes. For repeated and useless calls with Z_FINISH, we keep; * returning Z_STREAM_END instead of Z_BUF_ERROR.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:42,avoid,avoid,42,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,3,['avoid'],['avoid']
Safety,/* Make sure to avoid that in the master control logic!; * We are fully adaptive here and need no extra; * statistics gathering pass!; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c:16,avoid,avoid,16,graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c,1,['avoid'],['avoid']
Safety,/* Mark in_error_handler to avoid recursion and call user callback. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:28,avoid,avoid,28,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['avoid'],['avoid']
Safety,/* Mechanisms to advise users to avoid legacy functions and classes that will not be removed */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RConfig.hxx:33,avoid,avoid,33,core/foundation/inc/ROOT/RConfig.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RConfig.hxx,1,['avoid'],['avoid']
Safety,"/* N.B. Create a separate function instead of using (call function, function; value here) because in order to create the variables needed for the input; arg.'s which may be const.'s one has to do the creation within {}, but these; can never be placed within ()'s. Therefore one must create wrapper functions.; gcc, on the other hand may be able to avoid the wrapper functions. */; /* Prototypes are needed to correctly handle the value returned correctly. N.B.; Can only have prototype arg.'s with difficulty, a la G... table since FORTRAN; functions returning strings have extra arg.'s. Don't bother, since this only; causes a compiler warning to come up when one uses FCALLSCFUNn and CCALLSFFUNn; for the same function in the same source code. Something done by the experts in; debugging only.*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/cfortran.h:348,avoid,avoid,348,montecarlo/eg/inc/cfortran.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/cfortran.h,1,['avoid'],['avoid']
Safety,"/* NOTE: Uncomment the following #define if you want to use the; * given formula for calculating the AC conditioning parameter Kx; * for spectral selection progressive coding in section G.1.3.2; * of the spec (Kx = Kmin + SRL (8 + Se - Kmin) 4).; * Although the spec and P&M authors claim that this ""has proven; * to give good results for 8 bit precision samples"", I'm not; * convinced yet that this is really beneficial.; * Early tests gave only very marginal compression enhancements; * (a few - around 5 or so - bytes even for very large files),; * which would turn out rather negative if we'd suppress the; * DAC (Define Arithmetic Conditioning) marker segments for; * the default parameters in the future.; * Note that currently the marker writing module emits 12-byte; * DAC segments for a full-component scan in a color image.; * This is not worth worrying about IMHO. However, since the; * spec defines the default values to be used if the tables; * are omitted (unlike Huffman tables, which are required; * anyway), one might optimize this behaviour in the future,; * and then it would be disadvantageous to use custom tables if; * they don't provide sufficient gain to exceed the DAC size.; *; * On the other hand, I'd consider it as a reasonable result; * that the conditioning has no significant influence on the; * compression performance. This means that the basic; * statistical model is already rather stable.; *; * Thus, at the moment, we use the default conditioning values; * anyway, and do not use the custom formula.; *; #define CALCULATE_SPECTRAL_CONDITIONING; */; /* IRIGHT_SHIFT is like RIGHT_SHIFT, but works on int rather than INT32.; * We assume that int right shift is unsigned if INT32 right shift is,; * which should be safe.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c:1750,safe,safe,1750,graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c,1,['safe'],['safe']
Safety,"/* NOTE: this code is radically different from the read side in the; * matter of handling an ancillary unknown chunk. In the read side; * the default behavior is to discard it, in the code below the default; * behavior is to write it. Critical chunks are, however, only; * written if explicitly listed or if the default is set to write all; * unknown chunks.; *; * The default handling is also slightly weird - it is not possible to; * stop the writing of all unsafe-to-copy chunks!; *; * TODO: REVIEW: this would seem to be a bug.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c:460,unsafe,unsafe-to-copy,460,graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,1,['unsafe'],['unsafe-to-copy']
Safety,/* Need a minimum to safely represent all symbol values */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/fse_compress.c:21,safe,safely,21,builtins/zstd/compress/fse_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/fse_compress.c,1,['safe'],['safely']
Safety,/* New in 1.6.0 this avoids the bug of doing the initializations twice */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:21,avoid,avoids,21,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,2,['avoid'],['avoids']
Safety,/* No risk of overwrite. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c:6,risk,risk,6,builtins/zstd/decompress/zstd_decompress_block.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c,1,['risk'],['risk']
Safety,"/* Normalize by scaling so the sum of the end-point Y values is PNG_FP_1.; * IMPLEMENTATION NOTE: ANSI requires signed overflow not to occur, therefore; * relying on addition of two positive values producing a negative one is not; * safe.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:233,safe,safe,233,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['safe'],['safe']
Safety,"/* Note: since we use |=, repeating the assignment later is safe */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c:60,safe,safe,60,graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,1,['safe'],['safe']
Safety,"/* Now read the rows. Do this here if it is possible to read directly into; * the output buffer, otherwise allocate a local row buffer of the maximum; * size libpng requires and call the relevant processing routine safely.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:215,safe,safely,215,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['safe'],['safely']
Safety,/* Now set the IO functions to read from the memory buffer and; * store it into io_ptr. Again do this in-place to avoid calling a; * libpng function that requires error handling.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:114,avoid,avoid,114,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['avoid'],['avoid']
Safety,"/* Now we know that our FIN is ACK-ed, safe to close */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:39,safe,safe,39,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['safe'],['safe']
Safety,"/* Now we spread those positions across the table.; * The benefit of doing it in two stages is that we avoid the the; * variable size inner loop, which caused lots of branch misses.; * Now we can run through all the positions without any branch misses.; * We unroll the loop twice, since that is what emperically worked best.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse_decompress.c:103,avoid,avoid,103,builtins/zstd/common/fse_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse_decompress.c,2,['avoid'],['avoid']
Safety,"/* Now we use g_rand_double_range (), which will set 52 bits for; us, so that it is safe to round and still get a decent; distribution */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/grand.c:84,safe,safe,84,graf2d/win32gdk/gdk/src/glib/grand.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/grand.c,1,['safe'],['safe']
Safety,/* Number of bytes after end of data in window to initialize in order to avoid; memory checker errors from longest match routines */; /* in trees.c */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.h:73,avoid,avoid,73,builtins/zlib/deflate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.h,2,['avoid'],['avoid']
Safety,"/* Only in case n=0 (timeout), repeat calling the write function */; /* If send failed, wait before retry */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:21,timeout,timeout,21,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['timeout'],['timeout']
Safety,"/* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect; * this.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:71,detect,detect,71,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,2,['detect'],['detect']
Safety,"/* Originally (mid-1990s), this file contained copy/pasted assembler from RH6.0's; * version of <bits/byteswap.h>. Hence, we keep a copy of the FSF copyright below.; * I believe all the original code has been excised, perhaps with exception of the; * R__bswap_constant_* functions. To be on the safe side, we are keeping the; * copyright below.; * -- Brian Bockelman, August 2018; */; /* Copyright (C) 1997 Free Software Foundation, Inc.; This file is part of the GNU C Library. The GNU C Library is free software; you can redistribute it and/or; modify it under the terms of the GNU Library General Public License as; published by the Free Software Foundation; either version 2 of the; License, or (at your option) any later version. The GNU C Library is distributed in the hope that it will be useful,; but WITHOUT ANY WARRANTY; without even the implied warranty of; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; Library General Public License for more details. You should have received a copy of the GNU Library General Public; License along with the GNU C Library; see the file COPYING.LIB. If not,; write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,; Boston, MA 02111-1307, USA. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/Byteswap.h:295,safe,safe,295,core/base/inc/Byteswap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/Byteswap.h,1,['safe'],['safe']
Safety,/* Overflow error detected */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:18,detect,detected,18,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,1,['detect'],['detected']
Safety,"/* Part 1 - Physical context:; 	 * This holds threads, ports, timeouts, ...; 	 * set for the entire server, independent from the; 	 * addressed hostname.; 	 */; /* Connection related */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:62,timeout,timeouts,62,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['timeout'],['timeouts']
Safety,"/* Place a 16-bit number into a buffer in PNG byte order.; * The parameter is declared unsigned int, not png_uint_16,; * just to avoid potential problems on pre-ANSI C compilers.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:129,avoid,avoid,129,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,2,['avoid'],['avoid']
Safety,"/* Pointer to the function that causes an abort when the memory checking; features are activated. By default this is set to abort(), but can; be set to another function by the application using mmalloc(). FIXME: For mapped regions shared by more than one process, this; needs to be maintained on a per-process basis. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmprivate.h:42,abort,abort,42,core/clib/res/mmprivate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmprivate.h,2,['abort'],['abort']
Safety,/* Poll returned timeout (0). */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:17,timeout,timeout,17,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['timeout'],['timeout']
Safety,"/* Prepare the reader to ignore all recognized chunks whose data will not; * be used, i.e., all chunks recognized by libpng except for those; * involved in basic image reading:; *; * IHDR, PLTE, IDAT, IEND; *; * Or image data handling:; *; * tRNS, bKGD, gAMA, cHRM, sRGB, [iCCP] and sBIT.; *; * This provides a small performance improvement and eliminates any; * potential vulnerability to security problems in the unused chunks.; *; * At present the iCCP chunk data isn't used, so iCCP chunk can be ignored; * too. This allows the simplified API to be compiled without iCCP support,; * however if the support is there the chunk is still checked to detect; * errors (which are unfortunately quite common.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:649,detect,detect,649,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['detect'],['detect']
Safety,/* Prepended CONFIG_ to avoid conflict with the; 	 * socket option typedef TCP_NODELAY. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:24,avoid,avoid,24,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['avoid'],['avoid']
Safety,/* Process the first pixel in the row completely (this is the same as 'up'; * because there is only one candidate predictor for the first row).; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:114,predict,predictor,114,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['predict'],['predictor']
Safety,"/* READ APIs; * ---------; *; * The png_image passed to the read APIs must have been initialized by setting; * the png_controlp field 'opaque' to NULL (or, safer, memset the whole thing.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:156,safe,safer,156,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['safe'],['safer']
Safety,/* Re-initialize DC predictions to 0 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c:20,predict,predictions,20,graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,5,['predict'],['predictions']
Safety,/* Releasing pools in reverse order might help avoid fragmentation; * with some (brain-damaged) malloc libraries.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcomapi.c:47,avoid,avoid,47,graf2d/asimage/src/libAfterImage/libjpeg/jcomapi.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcomapi.c,1,['avoid'],['avoid']
Safety,"/* Render a 24-bit RGB image in buf into the GdkImage, without dithering.; This assumes native byte ordering - what should really be done is to; check whether static_image->byte_order is consistent with the _ENDIAN; config flag, and if not, use a different function. This routine is faster than the one included with Gtk 1.0 for a number; of reasons:. 1. Shifting instead of lookup tables (less memory traffic). 2. Much less register pressure, especially because shifts are; in the code. 3. A memcpy is avoided (i.e. the transfer function). 4. On big-endian architectures, byte swapping is avoided. That said, it wouldn't be hard to make it even faster - just make an; inner loop that reads 3 words (i.e. 4 24-bit pixels), does a lot of; shifting and masking, then writes 2 words.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkrgb.c:503,avoid,avoided,503,graf2d/win32gdk/gdk/src/gdk/gdkrgb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdkrgb.c,2,['avoid'],['avoided']
Safety,"/* Replace the (error and abort), and warning functions with user; * supplied functions. If no messages are to be printed you must still; * write and use replacement functions. The replacement error_fn should; * still do a longjmp to the last setjmp location if you are using this; * method of error handling. If error_fn or warning_fn is NULL, the; * default function will be used.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:26,abort,abort,26,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['abort'],['abort']
Safety,/* Report a recoverable issue in chunk data. On read this is used to report; * a problem found while reading a particular chunk and the; * png_chunk_benign_error or png_chunk_warning function is used as; * appropriate. On write this is used to report an error that comes from; * data set via an application call to a png_set_ API and png_app_error or; * png_app_warning is used as appropriate.; *; * The 'error' parameter must have one of the following values:; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:12,recover,recoverable,12,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['recover'],['recoverable']
Safety,/* Request is directed to another server: The server name; 				 * is longer than the request name.; 				 * Drop this case here to avoid overflows in the; 				 * following checks. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:130,avoid,avoid,130,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['avoid'],['avoid']
Safety,/* Reset DC predictions to 0 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c:12,predict,predictions,12,graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c,2,['predict'],['predictions']
Safety,"/* Reset out-of-data flag, unless read_restart_marker left us smack up; * against a marker. In that case we will end up treating the next data; * segment as empty, and we can avoid producing bogus output pixels by; * leaving the flag set.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c:175,avoid,avoid,175,graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,1,['avoid'],['avoid']
Safety,"/* Reset to start state; it would be safer to require the application to; * call jpeg_abort, but we can't change it now for compatibility reasons.; * A side effect is to free any temporary memory (there shouldn't be any).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdapimin.c:37,safe,safer,37,graf2d/asimage/src/libAfterImage/libjpeg/jdapimin.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdapimin.c,1,['safe'],['safer']
Safety,"/* Return flags indicating compile-time options. Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:; 1.0: size of uInt; 3.2: size of uLong; 5.4: size of voidpf (pointer); 7.6: size of z_off_t. Compiler, assembler, and debug options:; 8: DEBUG; 9: ASMV or ASMINF -- use ASM code; 10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention; 11: 0 (reserved). One-time table building (smaller code, but not thread-safe if true):; 12: BUILDFIXED -- build static block decoding tables when needed; 13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed; 14,15: 0 (reserved). Library content (indicates missing functionality):; 16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking; deflate code when not needed); 17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect; and decode gzip streams (to avoid linking crc code); 18-19: 0 (reserved). Operation variations (changes in library functionality):; 20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate; 21: FASTEST -- deflate algorithm with only one, lowest compression level; 22,23: 0 (reserved). The sprintf variant used by gzprintf (zero is best):; 24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format; 25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!; 26: 0 = returns value, 1 = void -- 1 means inferred string length returned. Remainder:; 27-31: 0 (reserved); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:444,safe,safe,444,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,4,"['avoid', 'detect', 'safe']","['avoid', 'detect', 'safe']"
Safety,"/* Return flags indicating compile-time options. Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:; 1.0: size of uInt; 3.2: size of uLong; 5.4: size of voidpf (pointer); 7.6: size of z_off_t. Compiler, assembler, and debug options:; 8: DEBUG; 9: ASMV or ASMINF -- use ASM code; 10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention; 11: 0 (reserved). One-time table building (smaller code, but not thread-safe if true):; 12: BUILDFIXED -- build static block decoding tables when needed; 13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed; 14,15: 0 (reserved). Library content (indicates missing functionality):; 16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking; deflate code when not needed); 17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect; and decode gzip streams (to avoid linking crc code); 18-19: 0 (reserved). Operation variations (changes in library functionality):; 20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate; 21: FASTEST -- deflate algorithm with only one, lowest compression level; 22,23: 0 (reserved). The sprintf variant used by gzprintf (zero is best):; 24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format; 25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!; 26: 0 = returns value, 1 = void -- 1 means inferred string length returned. Remainder:; 27-31: 0 (reserved); */; /* utility functions */; /*; The following utility functions are implemented on top of the; basic stream-oriented functions. To simplify the interface, some; default options are assumed (compression level and memory usage,; standard memory allocation functions). The source code of these; utility functions can easily be modified if you need special options.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:444,safe,safe,444,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,4,"['avoid', 'detect', 'safe']","['avoid', 'detect', 'safe']"
Safety,"/* Returns the number of bytes to move the current read position back by. Only non-zero; * if we ended up splitting a sequence. Otherwise, it may return a ZSTD error if something; * went wrong.; *; * This function will attempt to scan through blockSize bytes represented by the sequences; * in inSeqs, storing any (partial) sequences.; *; * Occasionally, we may want to change the actual number of bytes we consumed from inSeqs to; * avoid splitting a match, or to avoid splitting a match such that it would produce a match; * smaller than MINMATCH. In this case, we return the number of bytes that we didn't read from this block.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:434,avoid,avoid,434,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,2,['avoid'],['avoid']
Safety,/* Reuse the request timeout for the SSL_Accept/SSL_connect timeout */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:21,timeout,timeout,21,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,2,['timeout'],['timeout']
Safety,"/* SAFE, does not exceed 8 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpread.c:3,SAFE,SAFE,3,graf2d/asimage/src/libAfterImage/libpng/pngpread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpread.c,1,['SAFE'],['SAFE']
Safety,/* SAFE; pixel_depth does not exceed 64 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:3,SAFE,SAFE,3,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['SAFE'],['SAFE']
Safety,"/* SECURITY and SAFETY:; *; * libpng is built with support for internal limits on image dimensions and; * memory usage. These are documented in scripts/pnglibconf.dfa of the; * source and recorded in the machine generated header file pnglibconf.h.; */; /* If you are running on a machine where you cannot allocate more; * than 64K of memory at once, uncomment this. While libpng will not; * normally need that much memory in a chunk (unless you load up a very; * large file), zlib needs to know how big of a chunk it can use, and; * libpng thus makes sure to check any memory allocation to verify it; * will fit into memory.; *; * zlib provides 'MAXSEG_64K' which, if defined, indicates the; * same limit and pngconf.h (already included) sets the limit; * if certain operating systems are detected.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:16,SAFE,SAFETY,16,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,2,"['SAFE', 'detect']","['SAFETY', 'detected']"
Safety,"/* SIMPLIFIED_{READ|WRITE} */; /*******************************************************************************; * Section 6: IMPLEMENTATION OPTIONS; *******************************************************************************; *; * Support for arbitrary implementation-specific optimizations. The API allows; * particular options to be turned on or off. 'Option' is the number of the; * option and 'onoff' is 0 (off) or non-0 (on). The value returned is given; * by the PNG_OPTION_ defines below.; *; * HARDWARE: normally hardware capabilities, such as the Intel SSE instructions,; * are detected at run time, however sometimes it may be impossible; * to do this in user mode, in which case it is necessary to discover; * the capabilities in an OS specific way. Such capabilities are; * listed here when libpng has support for them and must be turned; * ON by the application if present.; *; * SOFTWARE: sometimes software optimizations actually result in performance; * decrease on some architectures or systems, or with some sets of; * PNG images. 'Software' options allow such optimizations to be; * selected at run time.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:592,detect,detected,592,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['detect'],['detected']
Safety,"/* Safe, because the result can't have more than 20 bits: */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:3,Safe,Safe,3,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['Safe'],['Safe']
Safety,"/* Safely call the real function, but only if doing so is safe at this point; * (if not inside an error handling context). Otherwise assume; * png_safe_execute will call this API after the return.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:3,Safe,Safely,3,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,2,"['Safe', 'safe']","['Safely', 'safe']"
Safety,/* Safely execute function(arg) with png_error returning to this function. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngerror.c:3,Safe,Safely,3,graf2d/asimage/src/libAfterImage/libpng/pngerror.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngerror.c,1,['Safe'],['Safely']
Safety,/* Safety check to ensure start_compress not called yet. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c:3,Safe,Safety,3,graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c,5,['Safe'],['Safety']
Safety,/* Safety limit on quality factor. Convert 0 to 1 to avoid zero divide. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c:3,Safe,Safety,3,graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c,2,"['Safe', 'avoid']","['Safety', 'avoid']"
Safety,/* Sanity Checks */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse_decompress.c:3,Sanity Check,Sanity Checks,3,builtins/zstd/common/fse_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse_decompress.c,2,['Sanity Check'],['Sanity Checks']
Safety,/* Sanity check */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c:3,Sanity check,Sanity check,3,builtins/zstd/decompress/zstd_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c,1,['Sanity check'],['Sanity check']
Safety,/* Sanity check on image dimensions */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c:3,Sanity check,Sanity check,3,graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmaster.c,1,['Sanity check'],['Sanity check']
Safety,/* Sanity check the offset */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,Sanity check,Sanity check,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['Sanity check'],['Sanity check']
Safety,/* Sanity checks */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse_decompress.c:3,Sanity check,Sanity checks,3,builtins/zstd/common/fse_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse_decompress.c,3,['Sanity check'],['Sanity checks']
Safety,"/* Scaling decisions are generally the same as in the LL&M algorithm;; * see jidctint.c for more details. However, we choose to descale; * (right shift) multiplication products as soon as they are formed,; * rather than carrying additional fractional bits into subsequent additions.; * This compromises accuracy slightly, but it lets us save a few shifts.; * More importantly, 16-bit arithmetic is then adequate (for 8-bit samples); * everywhere except in the multiplications proper; this saves a good deal; * of work on 16-bit-int machines.; *; * The dequantized coefficients are not integers because the AA&N scaling; * factors have been incorporated. We represent them scaled up by PASS1_BITS,; * so that the first and second IDCT rounds have the same input scaling.; * For 8-bit JSAMPLEs, we choose IFAST_SCALE_BITS = PASS1_BITS so as to; * avoid a descaling shift; this compromises accuracy rather drastically; * for small quantization table entries, but it saves a lot of shifts.; * For 12-bit JSAMPLEs, there's no hope of using 16x16 multiplies anyway,; * so we use a much larger scaling factor to preserve accuracy.; *; * A final compromise is to represent the multiplicative constants to only; * 8 fractional bits, rather than 13. This saves some shifting work on some; * machines, and may also reduce the cost of multiplication (since there; * are fewer one-bits in the constants).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctfst.c:845,avoid,avoid,845,graf2d/asimage/src/libAfterImage/libjpeg/jidctfst.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctfst.c,1,['avoid'],['avoid']
Safety,"/* See if another task is already doing this (not thread-safe, but better; than nothing -- significantly reduces duration of vulnerability in; case the advice about DYNAMIC_CRC_TABLE is ignored) */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/crc32.c:57,safe,safe,57,builtins/zlib/crc32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/crc32.c,3,['safe'],['safe']
Safety,"/* Set IPv6 only option, but don't abort on errors. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:35,abort,abort,35,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,2,['abort'],['abort']
Safety,/* Set linger option to avoid socket hanging out after close. This; 		 * prevent ephemeral port exhaust problem under high QPS. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:24,avoid,avoid,24,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['avoid'],['avoid']
Safety,/* Set linger timeout */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:14,timeout,timeout,14,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['timeout'],['timeout']
Safety,/* Set login timeout to 5 seconds. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/sql/odbc/src/TODBCServer.cxx:13,timeout,timeout,13,sql/odbc/src/TODBCServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/sql/odbc/src/TODBCServer.cxx,1,['timeout'],['timeout']
Safety,"/* Set out_color_components and conversion method based on requested space.; * Also clear the component_needed flags for any unused components,; * so that earlier pipeline stages can avoid useless computation.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdcolor.c:183,avoid,avoid,183,graf2d/asimage/src/libAfterImage/libjpeg/jdcolor.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdcolor.c,1,['avoid'],['avoid']
Safety,"/* Set reuse option, but don't abort on errors. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:31,abort,abort,31,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,2,['abort'],['abort']
Safety,"/* Set the channel to blocking, to avoid a busy loop; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c:35,avoid,avoid,35,graf2d/win32gdk/gdk/src/glib/giochannel.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c,2,['avoid'],['avoid']
Safety,"/* Set the next chunk's repcodes based on the repcodes of the beginning; * of the last match, and the last sequence. This avoids us having to; * update them while traversing the sequences.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c:122,avoid,avoids,122,builtins/zstd/compress/zstd_opt.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c,1,['avoid'],['avoids']
Safety,/* Set the time the request was received. This value should be used for; 	 * timeouts. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:77,timeout,timeouts,77,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['timeout'],['timeouts']
Safety,"/* Set up the compression buffers, we need a loop here to avoid overflowing a; * uInt. Use ZLIB_IO_MAX to limit the input. The output is always limited; * by the output buffer size, so there is no need to check that. Since this; * is ANSI-C we know that an 'int', hence a uInt, is always at least 16 bits; * in size.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c:58,avoid,avoid,58,graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,1,['avoid'],['avoid']
Safety,"/* Shift len to the left to ensure it is even, this avoids even multiplies. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:52,avoid,avoids,52,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['avoid'],['avoids']
Safety,"/* Should not be required, but is safe */; /* Ensure the error message pointer is always set: */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:34,safe,safe,34,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['safe'],['safe']
Safety,"/* Slide the hash table (could be avoided with 32 bit values; at the expense of memory usage). We slide even when level == 0; to keep the hash table consistent if we switch back to level > 0; later. (Using level 0 permanently is not an optimal usage of; zlib, so we don't care about this pathological case.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:34,avoid,avoided,34,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,2,['avoid'],['avoided']
Safety,"/* Slide the hash table (could be avoided with 32 bit values; at the expense of memory usage). We slide even when level == 0; to keep the hash table consistent if we switch back to level > 0; later. (Using level 0 permanently is not an optimal usage of; zlib, so we don't care about this pathological case.); */; /* %%% avoid this when Z_RLE */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/deflate.c:34,avoid,avoided,34,graf2d/asimage/src/libAfterImage/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/deflate.c,2,['avoid'],"['avoid', 'avoided']"
Safety,"/* Slow, but safe */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.c:13,safe,safe,13,graf2d/win32gdk/gdk/src/glib/gmain.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.c,1,['safe'],['safe']
Safety,/* So 'value' is at most 4 bytes and the following cast is safe */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:59,safe,safe,59,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['safe'],['safe']
Safety,"/* Some typedefs to get us started. These should be safe on most of the common; * platforms.; *; * png_uint_32 and png_int_32 may, currently, be larger than required to hold a; * 32-bit value however this is not normally advisable.; *; * png_uint_16 and png_int_16 should always be two bytes in size - this is; * verified at library build time.; *; * png_byte must always be one byte in size.; *; * The checks below use constants from limits.h, as defined by the ISOC90; * standard.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngconf.h:52,safe,safe,52,graf2d/asimage/src/libAfterImage/libpng/pngconf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngconf.h,1,['safe'],['safe']
Safety,"/* Specialized symbol spreading for the case when there are; * no low probability (-1 count) symbols. When compressing; * small blocks we avoid low probability symbols to hit this; * case, since header decoding speed matters more.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c:138,avoid,avoid,138,builtins/zstd/decompress/zstd_decompress_block.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c,1,['avoid'],['avoid']
Safety,"/* Start by invoking BIT_initDStream().; * A chunk of the bitStream is then stored into a local register.; * Local register size is 64-bits on 64-bits systems, 32-bits on 32-bits systems (size_t).; * You can then retrieve bitFields stored into the local register, **in reverse order**.; * Local register is explicitly reloaded from memory by the BIT_reloadDStream() method.; * A reload guarantee a minimum of ((8*sizeof(bitD->bitContainer))-7) bits when its result is BIT_DStream_unfinished.; * Otherwise, it can be less than that, so proceed accordingly.; * Checking if DStream has reached its end can be performed with BIT_endOfDStream().; */; /*-****************************************; * unsafe API; ******************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h:693,unsafe,unsafe,693,builtins/zstd/common/bitstream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h,1,['unsafe'],['unsafe']
Safety,"/* Start with initCStream, providing the size of buffer to write into.; * bitStream will never write outside of this buffer.; * `dstCapacity` must be >= sizeof(bitD->bitContainer), otherwise @return will be an error code.; *; * bits are first added to a local register.; * Local register is size_t, hence 64-bits on 64-bits systems, or 32-bits on 32-bits systems.; * Writing data into memory is an explicit operation, performed by the flushBits function.; * Hence keep track how many bits are potentially stored into local register to avoid register overflow.; * After a flushBits, a maximum of 7 bits might still be stored into local register.; *; * Avoid storing elements of more than 24 bits if you want compatibility with 32-bits bitstream readers.; *; * Last operation is to close the bitStream.; * The function returns the final size of CStream in bytes.; * If data couldn't fit into `dstBuffer`, it will return a 0 ( == not storable); */; /*-********************************************; * bitStream decoding API (read backward); **********************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h:535,avoid,avoid,535,builtins/zstd/common/bitstream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h,2,"['Avoid', 'avoid']","['Avoid', 'avoid']"
Safety,/* Step 7: Finish decompression */; /* we must abort the decompress if not all lines were read */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.c:47,abort,abort,47,graf2d/asimage/src/libAfterImage/import.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.c,1,['abort'],['abort']
Safety,/* TODO (low): check if this is still required */; /* EAGAIN/EWOULDBLOCK:; 			 * standard case if called from close_socket_gracefully; 			 * => should return -1 */; /* or timeout occurred; 			 * => the code must stay in the while loop */; /* EINTR can be generated on a socket with a timeout set even; 			 * when SA_RESTART is effective for all relevant signals; 			 * (see signal(7)).; 			 * => stay in the while loop */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:171,timeout,timeout,171,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,2,['timeout'],['timeout']
Safety,/* TODO (low): check if this is still required */; /* timeout is handled by the while loop */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:54,timeout,timeout,54,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['timeout'],['timeout']
Safety,"/* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 		 * if the timeout is reached and if the socket was set to non-; 		 * blocking in close_socket_gracefully, so we can not distinguish; 		 * here. We have to wait for the timeout in both cases for now.; 		 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:80,timeout,timeout,80,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,2,['timeout'],['timeout']
Safety,"/* TODO: These opcodes can be added safely, but we may want to justify; their inclusion for different reasons (better for reg-alloc).; case X86ISD::OR:; case X86ISD::XOR:; case X86ISD::AND:; */; // Value 1 is the flag output of the node - verify it's not dead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:36,safe,safely,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['safe'],['safely']
Safety,/* TODO: add a safe function which takes a png_ptr argument and raises; * a png_error if the ttime argument is invalid and the call to gmtime; * fails as a consequence.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c:15,safe,safe,15,graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,1,['safe'],['safe']
Safety,/* TODO: avoid memset? */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:9,avoid,avoid,9,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,2,['avoid'],['avoid']
Safety,"/* TODO: delay this, it can be done in png_init_io (if the app doesn't; * do it itself) avoiding setting the default function if it is not; * required.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:88,avoid,avoiding,88,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['avoid'],['avoiding']
Safety,"/* TODO: delay this, it can be done in png_init_io() (if the app doesn't; * do it itself) avoiding setting the default function if it is not; * required.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c:90,avoid,avoiding,90,graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,1,['avoid'],['avoiding']
Safety,"/* Temporarily fake out the longjmp information until we have; * successfully completed this function. This only works if we have; * setjmp() support compiled in, but it is safe - this stuff should; * never happen.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:173,safe,safe,173,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['safe'],['safe']
Safety,"/* Test to detect irregular behaviour in the table, and; eventually omit a part of the table by adjusting the value of; n. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx:11,detect,detect,11,roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,1,['detect'],['detect']
Safety,"/* The IBM double-double semantics. Such a number consists of a pair of IEEE; 64-bit doubles (Hi, Lo), where |Hi| > |Lo|, and if normal,; (double)(Hi + Lo) == Hi. The numeric value it's modeling is Hi + Lo.; Therefore it has two 53-bit mantissa parts that aren't necessarily adjacent; to each other, and two 11-bit exponents. Note: we need to make the value different from semBogus as otherwise; an unsafe optimization may collapse both values to a single address,; and we heavily rely on them having distinct addresses. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:399,unsafe,unsafe,399,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['unsafe'],['unsafe']
Safety,/* The Microsoft C Run-Time Library for Windows CE doesn't have; * errno. We define it as a global variable to simplify porting.; * Its value is always 0 and should not be used. We rename it to; * avoid conflict with other libraries that use the same workaround.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zutil.h:197,avoid,avoid,197,graf2d/asimage/src/libAfterImage/zlib/zutil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zutil.h,1,['avoid'],['avoid']
Safety,/* The abort codes below this threshold are reserved for machine use. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmintrin.h:7,abort,abort,7,interpreter/llvm-project/clang/lib/Headers/htmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/htmintrin.h,1,['abort'],['abort']
Safety,"/* The actual parser. This can be called repeatedly. It updates; * the index into the string and the state variable (which must; * be initialized to 0). It returns a result code, as above. There; * is no point calling the parser any more if it fails to advance to; * the end of the string - it is stuck on an invalid character (or; * terminated by '\0').; *; * Note that the pointer will consume an E or even an E+ and then leave; * a 'maybe' state even though a preceding integer.fraction is valid.; * The PNG_FP_WAS_VALID flag indicates that a preceding substring was; * a valid number. It's possible to recover from this by calling; * the parser again (from the start, with state 0) but with a string; * that omits the last character (i.e. set the size to the index of; * the problem character.) This has not been tested within libpng.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:606,recover,recover,606,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['recover'],['recover']
Safety,"/* The application provided invalid parameters to an API function or called; * an API function at the wrong time, libpng can completely recover.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:136,recover,recover,136,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['recover'],['recover']
Safety,/* The cast is safe because 'location' is a bit mask and only the low four; * bits are significant.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngset.c:15,safe,safe,15,graf2d/asimage/src/libAfterImage/libpng/pngset.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngset.c,1,['safe'],['safe']
Safety,/* The cast is safe because the crc is a 32-bit value. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:15,safe,safe,15,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['safe'],['safe']
Safety,/* The division by two is safe because the caller passed in a; * stride which was multiplied by 2 (below) to get row_bytes.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:26,safe,safe,26,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['safe'],['safe']
Safety,"/* The following block like the normal cpuid branch below, but gcc; * reserves ebx for use of its pic register so we must specially; * handle the save and restore to avoid clobbering the register; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/cpu.h:166,avoid,avoid,166,builtins/zstd/common/cpu.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/cpu.h,1,['avoid'],['avoid']
Safety,"/* The following code is redundant, but it should avoid; 					 * false positives in static source code analyzers and; 					 * vulnerability scanners.; 					 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:25,redund,redundant,25,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"/* The following gives 1.0 for an alpha of 0, which is fine, otherwise if 0/0; * is represented as some other value there is more likely to be a; * discontinuity which will probably damage compression when moving from a; * fully transparent area to a nearly transparent one. (The assumption here; * is that opaque areas tend not to be 0 intensity.); *; * There is a rounding problem here; if alpha is less than 128 it will end up; * as 0 when scaled to 8 bits. To avoid introducing spurious colors into the; * output change for this too.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c:464,avoid,avoid,464,graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,1,['avoid'],['avoid']
Safety,/* The following has to be safe; this function only gets called on PNG data; * and if we get here that data is invalid. 0 is the most safe value and; * if not then an attacker would surely just generate a PNG with 0 instead.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:27,safe,safe,27,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,2,['safe'],['safe']
Safety,/* The following is safe because of the PNG_SIZE_MAX init above */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:20,safe,safe,20,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['safe'],['safe']
Safety,"/* The following silently ignores cases where fixed point (times 100,000); * gamma values are passed to the floating point API. This is safe and it; * means the fixed point constants work just fine with the floating point; * API. The alternative would just lead to undetected errors and spurious; * bug reports. Negative values fail inside the _fixed API unless they; * correspond to the flag values.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c:136,safe,safe,136,graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrtran.c,1,['safe'],['safe']
Safety,"/* The following static variable is declared 'volatile' to avoid a; possible multithread problem in the function get_charset_aliases. If we; are running in a threaded environment, and if two threads initialize; 'charset_aliases' simultaneously, both will produce the same value,; and everything will be ok if the two assignments to 'charset_aliases'; are atomic. But I don't know what will happen if the two assignments mix. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/localcharset.c:59,avoid,avoid,59,graf2d/win32gdk/gdk/src/iconv/localcharset.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/localcharset.c,1,['avoid'],['avoid']
Safety,"/* The following two API calls simply set fields in png_struct, so it is safe; * to do them now even though error handling is not yet set up.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:73,safe,safe,73,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['safe'],['safe']
Safety,/* The gl2ps context. gl2ps is not thread safe (we should create a; local GL2PScontext during gl2psBeginPage) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/gl2ps.cxx:42,safe,safe,42,graf3d/gl/src/gl2ps.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/gl2ps.cxx,1,['safe'],['safe']
Safety,"/* The inter-value distance for this color is MAXJSAMPLE/(ncolors-1).; * Hence the dither value for the matrix cell with fill order f; * (f=0..N-1) should be (N-1-2*f)/(2*N) * MAXJSAMPLE/(ncolors-1).; * On 16-bit-int machine, be careful to avoid overflow.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c:240,avoid,avoid,240,graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,1,['avoid'],['avoid']
Safety,"/* The intersection point lies slightly to the left of the sweep line,; * so move it until it''s slightly to the right of the sweep line.; * (If we had perfect numerical precision, this would never happen; * in the first place). The easiest and safest thing to do is; * replace the intersection by tess->event.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/sweep.c:245,safe,safest,245,graf3d/eve7/glu/sweep.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/sweep.c,1,['safe'],['safest']
Safety,"/* The lengths of the bit length codes are sent in order of decreasing; * probability, to avoid transmitting the lengths for unused bit length codes.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZTrees.c:90,avoid,avoid,90,core/zip/src/ZTrees.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZTrees.c,2,['avoid'],['avoid']
Safety,"/* The lengths of the bit length codes are sent in order of decreasing; * probability, to avoid transmitting the lengths for unused bit length codes.; */; /* ===========================================================================; * Local data. These are initialized only once.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/trees.c:90,avoid,avoid,90,builtins/zlib/trees.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/trees.c,2,['avoid'],['avoid']
Safety,/* The number of uncompressed bytes in the PNG byte encoding of the image;; * uncompressing the PNG IDAT data will give this number of bytes.; *; * NOTE: while PNG_IMAGE_SIZE cannot overflow for an image in memory this; * macro can because of the extra bytes used in the PNG byte encoding. You; * need to avoid this macro if your image size approaches 2^30 in width or; * height. The same goes for the remainder of these macros; they all produce; * bigger numbers than the actual in-memory image size.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:305,avoid,avoid,305,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['avoid'],['avoid']
Safety,"/* The old code would overflow at the end and this would cause the; * 'pow' function to return a result >1, resulting in an; * arithmetic error. This code follows the spec exactly; ig is; * the recovered input sample, it always has 8-16 bits.; *; * We want input * 65535/max, rounded, the arithmetic fits in 32; * bits (unsigned) so long as max <= 32767.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:194,recover,recovered,194,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['recover'],['recovered']
Safety,/* The order of these checks doesn't matter much; it just affects which; * possible error might be detected if multiple things go wrong at once.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c:99,detect,detected,99,graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,1,['detect'],['detected']
Safety,"/* The pkzip format requires that at least one distance code exists,; * and that at least one bit should be sent even if there is only one; * possible code. So to avoid special checks later on we force at least; * two codes of non zero frequency.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/trees.c:163,avoid,avoid,163,builtins/zlib/trees.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/trees.c,4,['avoid'],['avoid']
Safety,"/* The png_set_<chunk> functions are for storing values in the png_info_struct.; * Similarly, the png_get_<chunk> calls are used to read values from the; * png_info_struct, either storing the parameters in the passed variables, or; * setting pointers into the png_info_struct where the data is stored. The; * png_get_<chunk> functions return a non-zero value if the data was available; * in info_ptr, or return zero and do not change any of the parameters if the; * data was not available.; *; * These functions should be used instead of directly accessing png_info; * to avoid problems with future changes in the size and internal layout of; * png_info_struct.; */; /* Returns ""flag"" if chunk data is valid in info_ptr. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:572,avoid,avoid,572,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['avoid'],['avoid']
Safety,"/* The prediction method we use is to find which method provides the; * smallest value when summing the absolute values of the distances; * from zero, using anything >= 128 as negative numbers. This is known; * as the ""minimum sum of absolute differences"" heuristic. Other; * heuristics are the ""weighted minimum sum of absolute differences""; * (experimental and can in theory improve compression), and the ""zlib; * predictive"" method (not implemented yet), which does test compressions; * of lines using different filter methods, and then chooses the; * (series of) filter(s) that give minimum compressed data size (VERY; * computationally expensive).; *; * GRR 980525: consider also; *; * (1) minimum sum of absolute differences from running average (i.e.,; * keep running sum of non-absolute differences & count of bytes); * [track dispersion, too? restart average if dispersion too large?]; *; * (1b) minimum sum of absolute differences from sliding average, probably; * with window size <= deflate window (usually 32K); *; * (2) minimum sum of squared differences from zero or running average; * (i.e., ~ root-mean-square approach); */; /* We don't need to test the 'no filter' case if this is the only filter; * that has been chosen, as it doesn't actually do anything to the data.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c:7,predict,prediction,7,graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,2,['predict'],"['prediction', 'predictive']"
Safety,"/* The quick check is to verify just the MD5 signature and trust the; * rest of the data. Because the profile has already been verified for; * correctness this is safe. png_colorspace_set_sRGB will check the 'intent'; * field too, so if the profile has been edited with an intent not defined; * by sRGB (but maybe defined by a later ICC specification) the read of; * the profile will fail at that point.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:163,safe,safe,163,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['safe'],['safe']
Safety,"/* The request sent by the client could not be understood by; 			 * the server, or it was incomplete or a timeout. Send an; 			 * error message and close the connection. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:106,timeout,timeout,106,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['timeout'],['timeout']
Safety,"/* The rest of these check to see if the valid field has the appropriate; * flag set, and if it does, writes the chunk.; *; * 1.6.0: COLORSPACE support controls the writing of these chunks too, and; * the chunks will be written if the WRITE routine is there and; * information * is available in the COLORSPACE. (See; * png_colorspace_sync_info in png.c for where the valid flags get set.); *; * Under certain circumstances the colorspace can be invalidated without; * syncing the info_struct 'valid' flags; this happens if libpng detects; * an error and calls png_error while the color space is being set, yet; * the application continues writing the PNG. So check the 'invalid'; * flag here too.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c:530,detect,detects,530,graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,1,['detect'],['detects']
Safety,/* The rotator is modified from fig 4-8 to avoid extra negations. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctflt.c:43,avoid,avoid,43,graf2d/asimage/src/libAfterImage/libjpeg/jfdctflt.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctflt.c,8,['avoid'],['avoid']
Safety,"/* The size in bytes of this structure, used as a sanity check when reusing; a previously created mapped file. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmprivate.h:50,sanity check,sanity check,50,core/clib/res/mmprivate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/res/mmprivate.h,1,['sanity check'],['sanity check']
Safety,"/* The size of the row must be within the limits of this architecture.; * Because the read code can perform arbitrary transformations the; * maximum size is checked here. Because the code in png_read_start_row; * adds extra space ""for safety's sake"" in several places a conservative; * limit is used here.; *; * NOTE: it would be far better to check the size that is actually used,; * but the effect in the real world is minor and the changes are more; * extensive, therefore much more dangerous and much more difficult to; * write in a way that avoids compiler warnings.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:235,safe,safety,235,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,2,"['avoid', 'safe']","['avoids', 'safety']"
Safety,"/* The source object and input buffer are made permanent so that a series; * of JPEG images can be read from the same file by calling jpeg_stdio_src; * only before the first one. (If we discarded the buffer at the end of; * one image, we'd likely lose the start of the next one.); * This makes it unsafe to use this manager and a different source; * manager serially with the same JPEG object. Caveat programmer.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatasrc.c:297,unsafe,unsafe,297,graf2d/asimage/src/libAfterImage/libjpeg/jdatasrc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatasrc.c,1,['unsafe'],['unsafe']
Safety,"/* The system time has been set backwards, so we; 	 * reset the expiration time to now + timeout_source->interval;; 	 * this at least avoids hanging for long periods of time.; 	 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.c:134,avoid,avoids,134,graf2d/win32gdk/gdk/src/glib/gmain.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.c,1,['avoid'],['avoids']
Safety,"/* There are several different allowed syntax variants:; 		 * - ""80"" for a single port using every network interface; 		 * - ""localhost:80"" for a single port using only localhost; 		 * - ""80,localhost:8080"" for two ports, one bound to localhost; 		 * - ""80,127.0.0.1:8084,[::1]:8086"" for three ports, one bound; 		 * to IPv4 localhost, one to IPv6 localhost; 		 * - ""+80"" use port 80 for IPv4 and IPv6; 		 * - ""+80r,+443s"" port 80 (HTTP) is a redirect to port 443 (HTTPS),; 		 * for both: IPv4 and IPv4; 		 * - ""+443s,localhost:8080"" port 443 (HTTPS) for every interface,; 		 * additionally port 8080 bound to localhost connections; 		 *; 		 * If we just look for 's' anywhere in the string, ""localhost:80""; 		 * will be detected as SSL (false positive).; 		 * Looking for 's' after a digit may cause false positives in; 		 * ""my24service:8080"".; 		 * Looking from 's' backward if there are only ':' and numbers; 		 * before will not work for ""24service:8080"" (non SSL, port 8080); 		 * or ""24s"" (SSL, port 24).; 		 *; 		 * Remark: Initially hostnames were not allowed to start with a; 		 * digit (according to RFC 952), this was allowed later (RFC 1123,; 		 * Section 2.1).; 		 *; 		 * To get this correct, the entire string must be parsed as a whole,; 		 * reading it as a list element for element and parsing with an; 		 * algorithm equivalent to parse_port_string.; 		 *; 		 * In fact, we use local interface names here, not arbitrary; 		 * hostnames, so in most cases the only name will be ""localhost"".; 		 *; 		 * So, for now, we use this simple algorithm, that may still return; 		 * a false positive in bizarre cases.; 		 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:721,detect,detected,721,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['detect'],['detected']
Safety,"/* This code is not really all that safe, but it works fine for testing. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c:36,safe,safe,36,interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/c-index-test.c,1,['safe'],['safe']
Safety,"/* This file is arranged in several sections:; *; * 1. [omitted]; * 2. Any configuration options that can be specified by for the application; * code when it is built. (Build time configuration is in pnglibconf.h); * 3. Type definitions (base types are defined in pngconf.h), structure; * definitions.; * 4. Exported library functions.; * 5. Simplified API.; * 6. Implementation options.; *; * The library source code has additional files (principally pngpriv.h) that; * allow configuration of the library.; */; /* Section 1: [omitted] */; /* Section 2: run time configuration; * See pnglibconf.h for build time configuration; *; * Run time configuration allows the application to choose between; * implementations of certain arithmetic APIs. The default is set; * at build time and recorded in pnglibconf.h, but it is safe to; * override these (and only these) settings. Note that this won't; * change what the library does, only application code, and the; * settings can (and probably should) be made on a per-file basis; * by setting the #defines before including png.h; *; * Use macros to read integers from PNG data or use the exported; * functions?; * PNG_USE_READ_MACROS: use the macros (see below) Note that; * the macros evaluate their argument multiple times.; * PNG_NO_USE_READ_MACROS: call the relevant library function.; *; * Use the alternative algorithm for compositing alpha samples that; * does not use division?; * PNG_READ_COMPOSITE_NODIV_SUPPORTED: use the 'no division'; * algorithm.; * PNG_NO_READ_COMPOSITE_NODIV: use the 'division' algorithm.; *; * How to handle benign errors if PNG_ALLOW_BENIGN_ERRORS is; * false?; * PNG_ALLOW_BENIGN_ERRORS: map calls to the benign error; * APIs to png_warning.; * Otherwise the calls are mapped to png_error.; */; /* Section 3: type definitions, including structures and compile time; * constants.; * See pngconf.h for base types that vary by machine/system; */; /* This triggers a compiler error in png.c, if png.c and png.h; * do not agr",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:819,safe,safe,819,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['safe'],['safe']
Safety,/* This function must be safe (non-segfaulting) on invalid UTF8 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmarkup.c:25,safe,safe,25,graf2d/win32gdk/gdk/src/glib/gmarkup.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmarkup.c,1,['safe'],['safe']
Safety,"/* This header is distributed to simplify porting x86_64 code that; makes explicit use of Intel intrinsics to powerpc64le.; It is the user's responsibility to determine if the results are; acceptable and make additional changes as necessary.; Note that much code that uses Intel intrinsics can be rewritten in; standard C or GNU C extensions, which are more portable and better; optimized across multiple targets. In the specific case of X86 SSE3 intrinsics, the PowerPC VMX/VSX ISA; is a good match for most SIMD operations. However the Horizontal; add/sub requires the data pairs be permuted into a separate; registers with vertical even/odd alignment for the operation.; And the addsub operation requires the sign of only the even numbered; elements be flipped (xored with -0.0).; For larger blocks of code using these intrinsic implementations,; the compiler be should be able to schedule instructions to avoid; additional latency. In the specific case of the monitor and mwait instructions there are; no direct equivalent in the PowerISA at this time. So those; intrinsics are not implemented. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h:909,avoid,avoid,909,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/pmmintrin.h,1,['avoid'],['avoid']
Safety,"/* This is a bad internal error. The recovery assigns to the zstream msg; * pointer, which is not owned by the caller, but this is safe; it's only; * used on errors!; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:37,recover,recovery,37,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,2,"['recover', 'safe']","['recovery', 'safe']"
Safety,"/* This is an internal error in libpng: somehow we have been left; * with a stack allocated jmp_buf when the application regained; * control. It's always possible to fix this up, but for the moment; * this is a png_error because that makes it easy to detect.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngerror.c:251,detect,detect,251,graf2d/asimage/src/libAfterImage/libpng/pngerror.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngerror.c,1,['detect'],['detect']
Safety,"/* This is recoverable, but make it unconditionally an app_error on write to; * avoid writing invalid ICC profiles into PNG files (i.e., we handle them; * on read, with a warning, but on write unless the app turns off; * application errors the PNG won't be written.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:11,recover,recoverable,11,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,2,"['avoid', 'recover']","['avoid', 'recoverable']"
Safety,/* This is redundant if we can be sure that the info_ptr values were all; * assigned in png_set_IHDR(). We do the check anyhow in case an; * application has ignored our advice not to mess with the members; * of info_ptr directly.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngget.c:11,redund,redundant,11,graf2d/asimage/src/libAfterImage/libpng/pngget.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngget.c,1,['redund'],['redundant']
Safety,"/* This is slightly evil, but png_init_io doesn't do anything other; * than this and we haven't changed the standard IO functions so; * this saves a 'safe' function.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:150,safe,safe,150,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,2,['safe'],['safe']
Safety,"/* This is to avoid an infinite loop if a program segfaults in; an atexit() handler (and yes, it does happen, especially if a program; has trounced over memory too badly for even g_message to work) */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdk.c:14,avoid,avoid,14,graf2d/win32gdk/gdk/src/gdk/gdk.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/gdk.c,1,['avoid'],['avoid']
Safety,/* This is to give the caller an easier error detection in the NULL; * case and guard against uninitialized variable problems:; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c:46,detect,detection,46,graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,1,['detect'],['detection']
Safety,"/* This is ugly and needs cleaning up, but I don't immediately see; how whilst remaining safe. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:89,safe,safe,89,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['safe'],['safe']
Safety,"/* This must match the function definition in <setjmp.h>, and the application; * must include this before png.h to obtain the definition of jmp_buf. The; * function is required to be PNG_NORETURN, but this is not checked. If the; * function does return the application will crash via an abort() or similar; * system level call.; *; * If you get a warning here while building the library you may need to make; * changes to ensure that pnglibconf.h records the calling convention used by; * your compiler. This may be very difficult - try using a different compiler; * to build the library!; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:287,abort,abort,287,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['abort'],['abort']
Safety,"/* This uses (char), not (png_byte) to avoid warnings on systems where (char) is; * signed and the argument is a (char[]) This macro will fail miserably on; * systems where (char) is more than 8 bits.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:39,avoid,avoid,39,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['avoid'],['avoid']
Safety,"/* This verifies 'check', the absolute value of the actual stride; * passed in and detects overflow in the application calculation (i.e.; * if the app did actually pass in a non-zero 'row_stride'.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:83,detect,detects,83,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['detect'],['detects']
Safety,/* Thread-safe - used by mtctx and (all) workers */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c:10,safe,safe,10,builtins/zstd/compress/zstdmt_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c,4,['safe'],['safe']
Safety,/* Thread-safe - used by mtctx and worker */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c:10,safe,safe,10,builtins/zstd/compress/zstdmt_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstdmt_compress.c,2,['safe'],['safe']
Safety,/* Timeout */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,Timeout,Timeout,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,2,['Timeout'],['Timeout']
Safety,/* Timeout for current iteration */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.c:3,Timeout,Timeout,3,graf2d/win32gdk/gdk/src/glib/gmain.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.c,1,['Timeout'],['Timeout']
Safety,/* Timeout in s: */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,Timeout,Timeout,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['Timeout'],['Timeout']
Safety,"/* Timeout occurred, but no data available. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,Timeout,Timeout,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['Timeout'],['Timeout']
Safety,/* Timeout: should retry */; /* TODO: get timeout def */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,Timeout,Timeout,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,2,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,/* Timeout: should retry */; /* TODO: retry condition */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,Timeout,Timeout,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['Timeout'],['Timeout']
Safety,/* To avoid the overflow do the conversion directly in floating; * point.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngget.c:6,avoid,avoid,6,graf2d/asimage/src/libAfterImage/libpng/pngget.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngget.c,2,['avoid'],['avoid']
Safety,"/* To avoid the trouble of installing a file that is shared by many; 	 GNU packages -- many packaging systems have problems with this --,; 	 simply inline the aliases here. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/localcharset.c:6,avoid,avoid,6,graf2d/win32gdk/gdk/src/iconv/localcharset.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/localcharset.c,1,['avoid'],['avoid']
Safety,"/* To avoid the troubles of an extra file charset.alias_vms in the; 	 sources of many GNU packages, simply inline the aliases here. */; /* The list of encodings is taken from the OpenVMS 7.3-1 documentation; 	 ""Compaq C Run-Time Library Reference Manual for OpenVMS systems""; 	 section 10.7 ""Handling Different Character Sets"". */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/localcharset.c:6,avoid,avoid,6,graf2d/win32gdk/gdk/src/iconv/localcharset.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/localcharset.c,1,['avoid'],['avoid']
Safety,"/* To avoid the troubles of installing a separate file in the same; 	 directory as the DLL and of retrieving the DLL's directory at; 	 runtime, simply inline the aliases here. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/localcharset.c:6,avoid,avoid,6,graf2d/win32gdk/gdk/src/iconv/localcharset.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/localcharset.c,1,['avoid'],['avoid']
Safety,"/* To simplify the code, we prevent matches with the string; * of window index 0 (in particular we have to avoid a match; * of the string with itself at the start of the input file).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:107,avoid,avoid,107,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,8,['avoid'],['avoid']
Safety,"/* To validate that the table re-use logic is sound, and that we don't; * access table space that we haven't cleaned, we re-""poison"" the table; * space every time we mark it dirty.; *; * This function however is intended to operate on those dirty tables and; * re-clean them. So when this function is used correctly, we can unpoison; * the memory it operated on. This introduces a blind spot though, since; * if we now try to operate on __actually__ poisoned memory, we will not; * detect that. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:482,detect,detect,482,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,1,['detect'],['detect']
Safety,"/* Turn on default checking for mmalloc/mrealloc/mfree, for the heap specified; by MD. If FUNC is non-NULL, it is a pointer to the function to call; to abort whenever memory corruption is detected. By default, this is the; standard library function abort(). Note that we disallow installation of initial checking hooks if mmalloc; has been called at any time for this particular heap, since if any region; that is allocated prior to installation of the hooks is subsequently; reallocated or freed after installation of the hooks, it is guaranteed; to trigger a memory corruption error. We do this by checking the state; of the MMALLOC_INITIALIZED flag. However, we can call this function at any time after the initial call,; to update the function pointers to the checking routines and to the; user defined corruption handler routine, as long as these function pointers; have been previously extablished by the initial call. Note that we; do this automatically when remapping an previously used heap, to ensure; that the hooks get updated to the correct values, although the corruption; handler pointer gets set back to the default. The application can then; call mmcheck to use a different corruption handler if desired. Returns non-zero if checking is successfully enabled, zero otherwise. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mmcheck.c:152,abort,abort,152,core/clib/src/mmcheck.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mmcheck.c,3,"['abort', 'detect']","['abort', 'detected']"
Safety,"/* Two strategies here - 1 - the fast one - we try to allocate new slot ; 	 * and avoid copying the body of the data over - we can do that only if; 	 * there is enough space in its block, otherwise we have to relocate it ; 	 * into different block, which is slower.; 	 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asstorage.c:82,avoid,avoid,82,graf2d/asimage/src/libAfterImage/asstorage.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asstorage.c,1,['avoid'],['avoid']
Safety,"/* Utility to safely execute a piece of libpng code catching and logging any; * errors that might occur. Returns true on success, false on failure (either; * of the function or as a result of a png_error.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:14,safe,safely,14,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['safe'],['safely']
Safety,/* VMS */; /* Open the old zip file in exclusive mode if possible (to avoid adding; * zip file to itself).; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Tailor.h:70,avoid,avoid,70,core/zip/src/Tailor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Tailor.h,1,['avoid'],['avoid']
Safety,"/* Validate symbols as being reasonable.; * For AC tables, we make no check, but accept all byte values 0..255.; * For DC tables, we require the symbols to be in range 0..15.; * (Tighter bounds could be applied depending on the data depth and mode,; * but this is sufficient to ensure safe decoding.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c:285,safe,safe,285,graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,1,['safe'],['safe']
Safety,"/* Validate the counts. We do this here mainly so we can copy the right; * number of symbols from the val[] array, without risking marching off; * the end of memory. jchuff.c will do a more thorough test later.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c:123,risk,risking,123,graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcparam.c,1,['risk'],['risking']
Safety,/* Verify DC & first 5 AC quantizers are nonzero to avoid zero-divide. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdcoefct.c:52,avoid,avoid,52,graf2d/asimage/src/libAfterImage/libjpeg/jdcoefct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdcoefct.c,1,['avoid'],['avoid']
Safety,"/* Wait for a response from the server; Parameters:; conn: connection; ebuf, ebuf_len: error message placeholder.; timeout: time to wait for a response in milliseconds (if < 0 then wait; forever). Return:; On success, >= 0; On error/timeout, < 0; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.h:115,timeout,timeout,115,net/http/civetweb/civetweb.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.h,2,['timeout'],['timeout']
Safety,"/* Waiting just for messages, some timeout; 		 * -> Set a timer, wait for message,; 		 * kill timer, use PeekMessage; 		 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.c:35,timeout,timeout,35,graf2d/win32gdk/gdk/src/glib/gmain.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.c,1,['timeout'],['timeout']
Safety,"/* Waiting just for messages, zero timeout.; 		 * If we got here, there was no message; 		 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.c:35,timeout,timeout,35,graf2d/win32gdk/gdk/src/glib/gmain.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.c,1,['timeout'],['timeout']
Safety,"/* We are not actually using AVX, but checking for AVX is the best; way we can detect SSE4.1 and SSSE3 on MSVC.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:79,detect,detect,79,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['detect'],['detect']
Safety,/* We avoid equality with LIT_BUFSIZE because of wraparound at 64K; * on 16 bit machines and because stored blocks are restricted to; * 64K-1 bytes.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZTrees.c:6,avoid,avoid,6,core/zip/src/ZTrees.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZTrees.c,1,['avoid'],['avoid']
Safety,/* We avoid equality with lit_bufsize because of wraparound at 64K; * on 16 bit machines and because stored blocks are restricted to; * 64K-1 bytes.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/trees.c:6,avoid,avoid,6,builtins/zlib/trees.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/trees.c,3,['avoid'],['avoid']
Safety,"/* We build gspawn-win32-helper.exe as a Windows GUI application; * to avoid any temporarily flashing console windows in case; * the gspawn function is invoked by a GUI program. Thus, no main(); * but a WinMain(). We do, however, still use argc and argv tucked; * away in the global __argc and __argv by the C runtime startup code.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gspawn-win32-helper.c:71,avoid,avoid,71,graf2d/win32gdk/gdk/src/glib/gspawn-win32-helper.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gspawn-win32-helper.c,1,['avoid'],['avoid']
Safety,/* We can finally safely perform the max-exponent check. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:18,safe,safely,18,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['safe'],['safely']
Safety,"/* We can safely set or update the abort function at any time, regardless; of whether or not we successfully do anything else. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mmcheck.c:10,safe,safely,10,core/clib/src/mmcheck.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clib/src/mmcheck.c,2,"['abort', 'safe']","['abort', 'safely']"
Safety,/* We cheat a bit and cast type values to (char *). We detect these; using the &0xff trick. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gunibreak.c:55,detect,detect,55,graf2d/win32gdk/gdk/src/glib/gunibreak.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gunibreak.c,3,['detect'],['detect']
Safety,"/* We could a use a for loop here, but that combined with; -funroll-loops can expand to a lot of code. The while; loop avoids unrolling and the compiler commons the xor; from clearing the mask bit with the (m != 0) test. The; result is a more compact loop setup and body. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h:119,avoid,avoids,119,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/bmi2intrin.h,1,['avoid'],['avoids']
Safety,"/* We currently handle outer loops like this:; |; ForeFirst <------\ }; Blocks | } ForeBlocks of L; ForeLast | }; | |; ... |; | |; ForeFirst <----\ | }; Blocks | | } ForeBlocks of a inner loop of L; ForeLast | | }; | | |; JamLoopFirst <\ | | }; Blocks | | | } JamLoopBlocks of the innermost loop; JamLoopLast -/ | | }; | | |; AftFirst | | }; Blocks | | } AftBlocks of a inner loop of L; AftLast ------/ | }; | |; ... |; | |; AftFirst | }; Blocks | } AftBlocks of L; AftLast --------/ }; |. There are (theoretically) any number of blocks in ForeBlocks, SubLoopBlocks; and AftBlocks, providing that there is one edge from Fores to SubLoops,; one edge from SubLoops to Afts and a single outer loop exit (from Afts).; In practice we currently limit Aft blocks to a single block, and limit; things further in the profitablility checks of the unroll and jam pass. Because of the way we rearrange basic blocks, we also require that; the Fore blocks of L on all unrolled iterations are safe to move before the; blocks of the direct child of L of all iterations. So we require that the; phi node looping operands of ForeHeader can be moved to at least the end of; ForeEnd, so that we can arrange cloned Fore Blocks before the subloop and; match up Phi's correctly. i.e. The old order of blocks used to be; (F1)1 (F2)1 J1_1 J1_2 (A2)1 (A1)1 (F1)2 (F2)2 J2_1 J2_2 (A2)2 (A1)2.; It needs to be safe to transform this to; (F1)1 (F1)2 (F2)1 (F2)2 J1_1 J1_2 J2_1 J2_2 (A2)1 (A2)2 (A1)1 (A1)2. There are then a number of checks along the lines of no calls, no; exceptions, inner loop IV is consistent, etc. Note that for loops requiring; runtime unrolling, UnrollRuntimeLoopRemainder can also fail in; UnrollAndJamLoop if the trip count cannot be easily calculated.; */; // Split blocks into Fore/SubLoop/Aft based on dominators",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:978,safe,safe,978,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,2,['safe'],['safe']
Safety,/* We depend here on the fact that dictCtx'es (produced by; * LZ4_loadDict) guarantee that their tables contain no references; * to offsets between dictCtx->currentOffset - 64 KB and; * dictCtx->currentOffset - dictCtx->dictSize. This makes it safe; * to use noDictIssue even when the dict isn't a full 64 KB.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:244,safe,safe,244,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,1,['safe'],['safe']
Safety,"/* We don't need to include the actual price of the literals because; * it is static for the duration of the forward pass, and is included; * in every price. We include the literal length to avoid negative; * prices when we subtract the previous literal length.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c:191,avoid,avoid,191,builtins/zstd/compress/zstd_opt.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c,1,['avoid'],['avoid']
Safety,"/* We don't really expect to get here because of the setjmp handling; * above, but this is safe.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngtest.c:91,safe,safe,91,graf2d/asimage/src/libAfterImage/libpng/pngtest.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngtest.c,1,['safe'],['safe']
Safety,"/* We don't support files in which the image height is initially specified */; /* as 0 and is later redefined by DNL. As long as we have to check that, */; /* might as well have a general sanity check. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c:188,sanity check,sanity check,188,graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c,1,['sanity check'],['sanity check']
Safety,"/* We need to get the client thread out of the select/recv call; 		 * here. */; /* Since we use a sleep quantum of some seconds to check for recv; 		 * timeouts, we will just wait a few seconds in mg_join_thread. */; /* join worker thread */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:152,timeout,timeouts,152,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['timeout'],['timeouts']
Safety,/* We only understand '0' compression - deflate - so if we get a; * different value we can't safely decode the chunk.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:93,safe,safely,93,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['safe'],['safely']
Safety,"/* We probably would not be called any more, so lets clean 	 */; /* everything before we return: need to flush out all rest of */; /* image until empty block (size 0) detected. We use GetCodeNext.*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libungif/dgif_lib.c:167,detect,detected,167,graf2d/asimage/src/libAfterImage/libungif/dgif_lib.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libungif/dgif_lib.c,1,['detect'],['detected']
Safety,"/* We should subtract the time used in select from remaining; 	 * ""milliseconds"", in particular if called from mg_poll with a; 	 * timeout quantum.; 	 * Unfortunately, the remaining time is not stored in ""tv"" in all; 	 * implementations, so the result in ""tv"" must be considered undefined.; 	 * See http://man7.org/linux/man-pages/man2/select.2.html */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:131,timeout,timeout,131,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['timeout'],['timeout']
Safety,"/* We use our private extension JPEG error handler.; 	 * Note that this struct must live as long as the main JPEG parameter; 	 * struct, to avoid dangling-pointer problems.; 	 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.c:140,avoid,avoid,140,graf2d/asimage/src/libAfterImage/import.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.c,1,['avoid'],['avoid']
Safety,"/* When the ref_count is 0, there can be nobody else using the; * loop, so it is safe to unlock before destroying.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.c:81,safe,safe,81,graf2d/win32gdk/gdk/src/glib/gmain.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.c,1,['safe'],['safe']
Safety,"/* Whether to report invalid palette index; added at libng-1.5.10.; * It is possible for an indexed (color-type==3) PNG file to contain; * pixels with invalid (out-of-range) indexes if the PLTE chunk has; * fewer entries than the image's bit-depth would allow. We recover; * from this gracefully by filling any incomplete palette with zeros; * (opaque black). By default, when this occurs libpng will issue; * a benign error. This API can be used to override that behavior.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngset.c:264,recover,recover,264,graf2d/asimage/src/libAfterImage/libpng/pngset.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngset.c,1,['recover'],['recover']
Safety,"/* With these routines we avoid an integer divide, which will be slower on; * most machines. However, it does take more operations than the corresponding; * divide method, so it may be slower on a few RISC systems. There are two; * shifts (by 8 or 16 bits) and an addition, versus a single integer divide.; *; * Note that the rounding factors are NOT supposed to be the same! 128 and; * 32768 are correct for the NODIV code; 127 and 32767 are correct for the; * standard method.; *; * [Optimized code by Greg Roelofs and Mark Adler...blame us for bugs. :-) ]; */; /* fg and bg should be in `gamma 1.0' space; alpha is the opacity */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:26,avoid,avoid,26,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['avoid'],['avoid']
Safety,/* Would like to use Vector Shift Left Double by Octet; Immediate here to use the immediate form and avoid; load of __N * 8 value into a separate VR. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h:101,avoid,avoid,101,interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ppc_wrappers/emmintrin.h,1,['avoid'],['avoid']
Safety,"/* Write a PNG chunk all at once. The type is an array of ASCII characters; * representing the chunk name. The array must be at least 4 bytes in; * length, and does not need to be null terminated. To be safe, pass the; * pre-defined chunk names here, and if you need a new one, define it; * where the others are defined. The length is the length of the data.; * All the data must be present. If that is not possible, use the; * png_write_chunk_start(), png_write_chunk_data(), and png_write_chunk_end(); * functions instead.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c:203,safe,safe,203,graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,1,['safe'],['safe']
Safety,/* ZDICT_flatLit() :; * rewrite `countLit` to contain a mostly flat but still compressible distribution of literals.; * necessary to avoid generating a non-compressible distribution that HUF_writeCTable() cannot encode.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/zdict.c:133,avoid,avoid,133,builtins/zstd/dictBuilder/zdict.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/zdict.c,1,['avoid'],['avoid']
Safety,"/* ZLIB_VERNUM >= 0x1240 */; /* Set this for safety, just in case the previous owner left pointers to; * memory allocations.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:45,safe,safety,45,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['safe'],['safety']
Safety,"/* ZSTD_c_stableInBuffer; * Experimental parameter.; * Default is 0 == disabled. Set to 1 to enable.; *; * Tells the compressor that the ZSTD_inBuffer will ALWAYS be the same; * between calls, except for the modifications that zstd makes to pos (the; * caller must not modify pos). This is checked by the compressor, and; * compression will fail if it ever changes. This means the only flush; * mode that makes sense is ZSTD_e_end, so zstd will error if ZSTD_e_end; * is not used. The data in the ZSTD_inBuffer in the range [src, src + pos); * MUST not be modified during compression or you will get data corruption.; *; * When this flag is enabled zstd won't allocate an input window buffer,; * because the user guarantees it can reference the ZSTD_inBuffer until; * the frame is complete. But, it will still allocate an output buffer; * large enough to fit a block (see ZSTD_c_stableOutBuffer). This will also; * avoid the memcpy() from the input buffer to the input window buffer.; *; * NOTE: ZSTD_compressStream2() will error if ZSTD_e_end is not used.; * That means this flag cannot be used with ZSTD_compressStream().; *; * NOTE: So long as the ZSTD_inBuffer always points to valid memory, using; * this flag is ALWAYS memory safe, and will never access out-of-bounds; * memory. However, compression WILL fail if you violate the preconditions.; *; * WARNING: The data in the ZSTD_inBuffer in the range [dst, dst + pos) MUST; * not be modified during compression or you will get data corruption. This; * is because zstd needs to reference data in the ZSTD_inBuffer to find; * matches. Normally zstd maintains its own window buffer for this purpose,; * but passing this flag tells zstd to use the user provided buffer.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:915,avoid,avoid,915,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"/* ZSTD_d_stableOutBuffer; * Experimental parameter.; * Default is 0 == disabled. Set to 1 to enable.; *; * Tells the decompressor that the ZSTD_outBuffer will ALWAYS be the same; * between calls, except for the modifications that zstd makes to pos (the; * caller must not modify pos). This is checked by the decompressor, and; * decompression will fail if it ever changes. Therefore the ZSTD_outBuffer; * MUST be large enough to fit the entire decompressed frame. This will be; * checked when the frame content size is known. The data in the ZSTD_outBuffer; * in the range [dst, dst + pos) MUST not be modified during decompression; * or you will get data corruption.; *; * When this flags is enabled zstd won't allocate an output buffer, because; * it can write directly to the ZSTD_outBuffer, but it will still allocate; * an input buffer large enough to fit any compressed block. This will also; * avoid the memcpy() from the internal output buffer to the ZSTD_outBuffer.; * If you need to avoid the input buffer allocation use the buffer-less; * streaming API.; *; * NOTE: So long as the ZSTD_outBuffer always points to valid memory, using; * this flag is ALWAYS memory safe, and will never access out-of-bounds; * memory. However, decompression WILL fail if you violate the preconditions.; *; * WARNING: The data in the ZSTD_outBuffer in the range [dst, dst + pos) MUST; * not be modified during decompression or you will get data corruption. This; * is because zstd needs to reference data in the ZSTD_outBuffer to regenerate; * matches. Normally zstd maintains its own buffer for this purpose, but passing; * this flag tells zstd to use the user provided buffer.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:902,avoid,avoid,902,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,3,"['avoid', 'safe']","['avoid', 'safe']"
Safety,/* ZSTD_readMINMATCH() :; * function safe only for comparisons; * assumption : memPtr must be at least 4 bytes before end of buffer */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c:37,safe,safe,37,builtins/zstd/compress/zstd_opt.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c,1,['safe'],['safe']
Safety,"/* ZSTD_rescaleFreqs() :; * if first block (detected by optPtr->litLengthSum == 0) : init statistics; * take hints from dictionary if there is one; * or init from zero, using src for literals stats, or flat 1 for match symbols; * otherwise downscale existing stats, to be used as seed for next block.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c:44,detect,detected,44,builtins/zstd/compress/zstd_opt.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c,1,['detect'],['detected']
Safety,/* Zero at the end to avoid modular arithmetic when adding one; used; when rounding up during hexadecimal output. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:22,avoid,avoid,22,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['avoid'],['avoid']
Safety,"/* _UNIX */; /*; * Needed for ptrdiff_t in turn needed by VBO. This is defined by ISO; * C. On my system, this amounts to _3 lines_ of included code, all of; * them pretty much harmless. If you know of a way of detecting 32 vs; * 64 _targets_ at compile time you are free to replace this with; * something that's portable. For now, _this_ is the portable solution.; * (mem, 2004-01-04); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/inc/GL/glew.h:211,detect,detecting,211,builtins/glew/inc/GL/glew.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/inc/GL/glew.h,1,['detect'],['detecting']
Safety,"/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */; /* currently only defined for gcc and icc */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:27,safe,safer,27,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,2,['safe'],['safer']
Safety,"/* a gap between an attached dict and the current window is not safe,; * they must remain adjacent,; * and when that stops being the case, the dict must be unset */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:64,safe,safe,64,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,1,['safe'],['safe']
Safety,/* abort scan as soon as one malformed character is found */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,abort,abort,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['abort'],['abort']
Safety,"/* all values are pretty poor;; probably incompressible data (should have already been detected);; find max, then give all remaining points to max */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/fse_compress.c:87,detect,detected,87,builtins/zstd/compress/fse_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/fse_compress.c,1,['detect'],['detected']
Safety,/* auto detect */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c:8,detect,detect,8,graf2d/win32gdk/gdk/src/glib/giochannel.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c,1,['detect'],['detect']
Safety,/* avoid %e formatting */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/gl2ps.cxx:3,avoid,avoid,3,graf3d/gl/src/gl2ps.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/gl2ps.cxx,3,['avoid'],['avoid']
Safety,"/* avoid BUF_ERROR at next call, see above */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:3,avoid,avoid,3,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,3,['avoid'],['avoid']
Safety,"/* avoid BUF_ERROR next call, see above */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:3,avoid,avoid,3,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,3,['avoid'],['avoid']
Safety,/* avoid compiler complaints */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/sweep.c:3,avoid,avoid,3,graf3d/eve7/glu/sweep.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/sweep.c,1,['avoid'],['avoid']
Safety,"/* avoid computing Adler-32 in read_buf */; /* if dictionary would fill window, just replace the history */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:3,avoid,avoid,3,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,2,['avoid'],['avoid']
Safety,/* avoid const char * -> char * conversion warning */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:3,avoid,avoid,3,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,1,['avoid'],['avoid']
Safety,/* avoid const char * -> char * conversion warning :( */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4hc.c:3,avoid,avoid,3,builtins/lz4/lz4hc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4hc.c,1,['avoid'],['avoid']
Safety,/* avoid double def */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:3,avoid,avoid,3,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,1,['avoid'],['avoid']
Safety,/* avoid double definition */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c:3,avoid,avoid,3,builtins/lz4/lz4frame.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c,1,['avoid'],['avoid']
Safety,/* avoid error pileups */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gspawn.c:3,avoid,avoid,3,graf2d/win32gdk/gdk/src/glib/gspawn.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gspawn.c,1,['avoid'],['avoid']
Safety,/* avoid extra function call in case we use fread (TVT) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libungif/dgif_lib.c:3,avoid,avoid,3,graf2d/asimage/src/libAfterImage/libungif/dgif_lib.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libungif/dgif_lib.c,1,['avoid'],['avoid']
Safety,/* avoid index overflow */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:3,avoid,avoid,3,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,1,['avoid'],['avoid']
Safety,/* avoid macro redef */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:3,avoid,avoid,3,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['avoid'],['avoid']
Safety,/* avoid making error situations worse */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regcomp.c:3,avoid,avoid,3,interpreter/llvm-project/llvm/lib/Support/regcomp.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regcomp.c,5,['avoid'],['avoid']
Safety,/* avoid modulos if none remaining */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/adler32.c:3,avoid,avoid,3,builtins/zlib/adler32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/adler32.c,3,['avoid'],['avoid']
Safety,/* avoid overflow */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4hc.c:3,avoid,avoid,3,builtins/lz4/lz4hc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4hc.c,3,['avoid'],['avoid']
Safety,/* avoid precision loss (we use floats!) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/gl2ps.cxx:3,avoid,avoid,3,graf3d/gl/src/gl2ps.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/gl2ps.cxx,1,['avoid'],['avoid']
Safety,/* avoid redefinition when sources are coalesced */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c:3,avoid,avoid,3,builtins/lz4/lz4frame.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c,2,['avoid'],['avoid']
Safety,/* avoid std::vector<bool> */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:3,avoid,avoid,3,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,3,['avoid'],['avoid']
Safety,/* avoid the MS-DOS specific includes */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Tailor.h:3,avoid,avoid,3,core/zip/src/Tailor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Tailor.h,1,['avoid'],['avoid']
Safety,/* avoid the processor specific parts */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c:3,avoid,avoid,3,core/zip/src/ZDeflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c,1,['avoid'],['avoid']
Safety,/* avoid unused lambda capture warning if PARAMCACHE is disabled */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h:3,avoid,avoid,3,math/mathcore/inc/Fit/FitUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h,1,['avoid'],['avoid']
Safety,/* avoid unused variable warning */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Tools.h:3,avoid,avoid,3,tmva/tmva/inc/TMVA/Tools.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Tools.h,1,['avoid'],['avoid']
Safety,/* avoids ambiguity */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gdate.c:3,avoid,avoids,3,graf2d/win32gdk/gdk/src/glib/gdate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gdate.c,1,['avoid'],['avoids']
Safety,/* be safe if jpeg_destroy is called twice */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcomapi.c:6,safe,safe,6,graf2d/asimage/src/libAfterImage/libjpeg/jcomapi.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcomapi.c,1,['safe'],['safe']
Safety,"/* best possible, avoids read overflow on next attempt */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_lazy.c:18,avoid,avoids,18,builtins/zstd/compress/zstd_lazy.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_lazy.c,4,['avoid'],['avoids']
Safety,/* build fixed huffman tables if first call (may not be thread safe) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/infback.c:63,safe,safe,63,builtins/zlib/infback.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/infback.c,4,['safe'],['safe']
Safety,/* colors[i] is only zero if the pixel at that location hasn't; * been allocated yet. This is a sanity check required for proper; * color allocation by the progressive image loader; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c:96,sanity check,sanity check,96,graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,1,['sanity check'],['sanity check']
Safety,/* concat my correction bits to older ones */; /* We force out the EOB if we risk either:; * 1. overflow of the EOB counter;; * 2. overflow of the correction bit buffer during the next MCU.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c:77,risk,risk,77,graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,2,['risk'],['risk']
Safety,/* counts iMCU rows to detect image top/bot */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c:23,detect,detect,23,graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmainct.c,1,['detect'],['detect']
Safety,/* create fake symbol to avoid empty translation unit warning */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/threading.c:25,avoid,avoid,25,builtins/zstd/common/threading.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/threading.c,1,['avoid'],['avoid']
Safety,"/* default method, safe and standard.; can sometimes prove slower */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/mem.h:19,safe,safe,19,builtins/zstd/common/mem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/mem.h,1,['safe'],['safe']
Safety,"/* define NO_GZIP when compiling if you want to disable gzip header and; trailer creation by deflate(). NO_GZIP would be used to avoid linking in; the crc code when it is not needed. For shared libraries, gzip encoding; should be left enabled. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.h:129,avoid,avoid,129,builtins/zlib/deflate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.h,2,['avoid'],['avoid']
Safety,"/* deflate.c -- compress data using the deflation algorithm; * Copyright (C) 1995-2005 Jean-loup Gailly.; * For conditions of distribution and use, see copyright notice in zlib.h; */; /*; * ALGORITHM; *; * The ""deflation"" process depends on being able to identify portions; * of the input text which are identical to earlier input (within a; * sliding window trailing behind the input currently being processed).; *; * The most straightforward technique turns out to be the fastest for; * most input files: try all possible matches and select the longest.; * The key feature of this algorithm is that insertions into the string; * dictionary are very simple and thus fast, and deletions are avoided; * completely. Insertions are performed at each input character, whereas; * string matches are performed only when the previous match ends. So it; * is preferable to spend more time in matches to allow very fast string; * insertions and avoid deletions. The matching algorithm for small; * strings is inspired from that of Rabin & Karp. A brute force approach; * is used to find longer strings when a small match has been found.; * A similar algorithm is used in comic (by Jan-Mark Wams) and freeze; * (by Leonid Broukhis).; * A previous version of this file used a more sophisticated algorithm; * (by Fiala and Greene) which is guaranteed to run in linear amortized; * time, but has a larger average cost, uses more memory and is patented.; * However the F&G algorithm may be faster for some highly redundant; * files if the parameter max_chain_length (described below) is too large.; *; * ACKNOWLEDGEMENTS; *; * The idea of lazy evaluation of matches is due to Jan-Mark Wams, and; * I found it in 'freeze' written by Leonid Broukhis.; * Thanks to many people for bug reports and testing.; *; * REFERENCES; *; * Deutsch, L.P.,""DEFLATE Compressed Data Format Specification"".; * Available in http://www.ietf.org/rfc/rfc1951.txt; *; * A description of the Rabin and Karp algorithm is given in the book; *",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/deflate.c:691,avoid,avoided,691,graf2d/asimage/src/libAfterImage/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/deflate.c,2,['avoid'],"['avoid', 'avoided']"
Safety,"/* deflate.c -- compress data using the deflation algorithm; * Copyright (C) 1995-2013 Jean-loup Gailly and Mark Adler; * For conditions of distribution and use, see copyright notice in zlib.h; */; /*; * ALGORITHM; *; * The ""deflation"" process depends on being able to identify portions; * of the input text which are identical to earlier input (within a; * sliding window trailing behind the input currently being processed).; *; * The most straightforward technique turns out to be the fastest for; * most input files: try all possible matches and select the longest.; * The key feature of this algorithm is that insertions into the string; * dictionary are very simple and thus fast, and deletions are avoided; * completely. Insertions are performed at each input character, whereas; * string matches are performed only when the previous match ends. So it; * is preferable to spend more time in matches to allow very fast string; * insertions and avoid deletions. The matching algorithm for small; * strings is inspired from that of Rabin & Karp. A brute force approach; * is used to find longer strings when a small match has been found.; * A similar algorithm is used in comic (by Jan-Mark Wams) and freeze; * (by Leonid Broukhis).; * A previous version of this file used a more sophisticated algorithm; * (by Fiala and Greene) which is guaranteed to run in linear amortized; * time, but has a larger average cost, uses more memory and is patented.; * However the F&G algorithm may be faster for some highly redundant; * files if the parameter max_chain_length (described below) is too large.; *; * ACKNOWLEDGEMENTS; *; * The idea of lazy evaluation of matches is due to Jan-Mark Wams, and; * I found it in 'freeze' written by Leonid Broukhis.; * Thanks to many people for bug reports and testing.; *; * REFERENCES; *; * Deutsch, L.P.,""DEFLATE Compressed Data Format Specification"".; * Available in http://tools.ietf.org/html/rfc1951; *; * A description of the Rabin and Karp algorithm is given i",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c:705,avoid,avoided,705,builtins/zlib/deflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/deflate.c,4,['avoid'],"['avoid', 'avoided']"
Safety,/* detect continuity */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_internal.h:3,detect,detect,3,builtins/zstd/decompress/zstd_decompress_internal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_internal.h,1,['detect'],['detect']
Safety,/* detects whether we are being compiled under asan */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/compiler.h:3,detect,detects,3,builtins/zstd/common/compiler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/compiler.h,1,['detect'],['detects']
Safety,/* detects whether we are being compiled under msan */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/compiler.h:3,detect,detects,3,builtins/zstd/common/compiler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/compiler.h,1,['detect'],['detects']
Safety,"/* display a table content,; * listing each element, its frequency, and its predicted bit cost */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress_internal.h:76,predict,predicted,76,builtins/zstd/compress/zstd_compress_internal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress_internal.h,1,['predict'],['predicted']
Safety,/* do it slow to avoid memcpy() overlap */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZInflate.c:17,avoid,avoid,17,core/zip/src/ZInflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZInflate.c,1,['avoid'],['avoid']
Safety,/* done in long arith to avoid oflo */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c:25,avoid,avoid,25,graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant1.c,1,['avoid'],['avoid']
Safety,/* early update abort; gets ~+10% speed for about -0.01 ratio loss */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c:16,abort,abort,16,builtins/zstd/compress/zstd_opt.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c,1,['abort'],['abort']
Safety,"/* evil, but safe */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:13,safe,safe,13,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['safe'],['safe']
Safety,"/* exception in constructor, avoid memory leak */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx:29,avoid,avoid,29,roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,6,['avoid'],['avoid']
Safety,"/* extra accuracy */; /* When it matters (small blocks), this is a; * predictable branch, because we don't use -1.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/entropy_common.c:70,predict,predictable,70,builtins/zstd/common/entropy_common.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/entropy_common.c,1,['predict'],['predictable']
Safety,/* extra entries for safety in decoder */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jutils.c:21,safe,safety,21,graf2d/asimage/src/libAfterImage/libjpeg/jutils.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jutils.c,7,['safe'],['safety']
Safety,/* fail safe code - if any of the alloc fails - colormap entry will still have; 	 * most suitable valid value ( black or white in 1bpp mode for example ) : */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.c:8,safe,safe,8,graf2d/asimage/src/libAfterImage/asvisual.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.c,1,['safe'],['safe']
Safety,/* fake a zero as the safest result */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c:22,safe,safest,22,graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdhuff.c,1,['safe'],['safest']
Safety,/* farthest referenced position of any match => detects repetitive patterns */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c:48,detect,detects,48,builtins/zstd/compress/zstd_opt.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_opt.c,1,['detect'],['detects']
Safety,/* fast variant (unsafe : won't check if src contains values beyond count[] limit) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/hist.c:17,unsafe,unsafe,17,builtins/zstd/compress/hist.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/hist.c,1,['unsafe'],['unsafe']
Safety,/* fill all offset symbols to avoid garbage at end of table */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:30,avoid,avoid,30,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,1,['avoid'],['avoid']
Safety,/* for safety */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jerror.c:7,safe,safety,7,graf2d/asimage/src/libAfterImage/libjpeg/jerror.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jerror.c,1,['safe'],['safety']
Safety,/* for safety */; /* Free the text pointer (this is the old read_buffer on; * success); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:7,safe,safety,7,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['safe'],['safety']
Safety,"/* for safety if init fails */; /* Check for configuration errors.; * SIZEOF(ALIGN_TYPE) should be a power of 2; otherwise, it probably; * doesn't reflect any real hardware alignment requirement.; * The test is a little tricky: for X>0, X and X-1 have no one-bits; * in common if and only if X is a power of 2, ie has only one one-bit.; * Some compilers may give an ""unreachable code"" warning here; ignore it.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:7,safe,safety,7,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,1,['safe'],['safety']
Safety,"/* for small input: avoid automatic flush on reaching end of block, since; * it would require to add a 3-bytes null block to end frame; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:20,avoid,avoid,20,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,1,['avoid'],['avoid']
Safety,/* force compiler to avoid strict-aliasing */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/huf_decompress.c:21,avoid,avoid,21,builtins/zstd/decompress/huf_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/huf_decompress.c,1,['avoid'],['avoid']
Safety,/* force it out to avoid overflow */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c:19,avoid,avoid,19,graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,2,['avoid'],['avoid']
Safety,/* fpont 12/99 */; /* pont.net */; /* udpserver.c */; /* Converted to echo client/server with select() (timeout option).; See testTUDPSocket.C */; /* Compile with: gcc udpserver.c -o udpserver */; /* on Windows: cl -nologo -Z7 -MD -GR -EHsc udpserver.c */; /* 3/30/05 John Schultz */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/net/udpserver.c:104,timeout,timeout,104,tutorials/net/udpserver.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/net/udpserver.c,1,['timeout'],['timeout']
Safety,/* from libAfterBase/safemalloc.h : */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asim_afterbase.h:21,safe,safemalloc,21,graf2d/asimage/src/libAfterImage/asim_afterbase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asim_afterbase.h,1,['safe'],['safemalloc']
Safety,/* function for printing errors and aborting */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngstruct.h:36,abort,aborting,36,graf2d/asimage/src/libAfterImage/libpng/pngstruct.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngstruct.h,1,['abort'],['aborting']
Safety,/* greater than 0 to avoid futile looping */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:21,avoid,avoid,21,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,1,['avoid'],['avoid']
Safety,/* gzclose() is in a separate file so that it is linked in only if it is used.; That way the other gzclose functions can be used instead to avoid linking in; unneeded compression or decompression routines. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzclose.c:140,avoid,avoid,140,builtins/zlib/gzclose.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzclose.c,1,['avoid'],['avoid']
Safety,"/* gzio.c -- IO on .gz files; * Copyright (C) 1995-2005 Jean-loup Gailly.; * For conditions of distribution and use, see copyright notice in zlib.h; *; * Compile this file with -DNO_GZCOMPRESS to avoid the compression code.; */; /* @(#) $Id$ */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/gzio.c:196,avoid,avoid,196,graf2d/asimage/src/libAfterImage/zlib/gzio.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/gzio.c,1,['avoid'],['avoid']
Safety,/* helper macro to avoid signed overflow for value comparisions */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gbsearcharray.h:19,avoid,avoid,19,graf2d/win32gdk/gdk/src/glib/gbsearcharray.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gbsearcharray.h,1,['avoid'],['avoid']
Safety,"/* http://msdn.microsoft.com/en-us/library/ms739165(v=vs.85).aspx:; 	 * ""Note that enabling a nonzero timeout on a nonblocking socket; 	 * is not recommended."", so set it to blocking now */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:102,timeout,timeout,102,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['timeout'],['timeout']
Safety,"/* http://www.webdav.org/specs/rfc4918.html, 9.1:; * Some PROPFIND results MAY be cached, with care,; * as there is no cache validation mechanism for; * most properties. This method is both safe and; * idempotent (see Section 9.1 of [RFC2616]). */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:190,safe,safe,190,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['safe'],['safe']
Safety,"/* http://www.webdav.org/specs/rfc4918.html, 9.1:; * When MKCOL is invoked without a request body,; * the newly created collection SHOULD have no; * members. A MKCOL request message may contain; * a message body. The precise behavior of a MKCOL; * request when the body is present is undefined,; * ... ==> We do not support MKCOL with body data.; * This method is idempotent, but not safe (see; * Section 9.1 of [RFC2616]). Responses to this; * method MUST NOT be cached. */; /* Methods for write access to files on WEBDAV (RFC 2518) */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:384,safe,safe,384,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['safe'],['safe']
Safety,"/* if (dctx->dStage == dstage_storeSuffix) */; /* case dstage_checkSuffix: */; /* no direct entry, avoid initialization risks */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c:99,avoid,avoid,99,builtins/lz4/lz4frame.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c,2,"['avoid', 'risk']","['avoid', 'risks']"
Safety,/* if (dest) *dest = src; also has some sanity checks.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gerror.h:40,sanity check,sanity checks,40,graf2d/win32gdk/gdk/src/glib/gerror.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gerror.h,1,['sanity check'],['sanity checks']
Safety,"/* if (err) *err = g_error_new(domain, code, format, ...), also has; * some sanity checks.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gerror.h:76,sanity check,sanity checks,76,graf2d/win32gdk/gdk/src/glib/gerror.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gerror.h,1,['sanity check'],['sanity checks']
Safety,/* if (n_fds || timeout != 0) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.c:16,timeout,timeout,16,graf2d/win32gdk/gdk/src/glib/gmain.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmain.c,1,['timeout'],['timeout']
Safety,"/* if len is zero, avoid unnecessary operations */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c:19,avoid,avoid,19,builtins/zlib/gzread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c,2,['avoid'],['avoid']
Safety,"/* iin < PNG_MAX_ERROR_TEXT, so the following is safe: */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngerror.c:49,safe,safe,49,graf2d/asimage/src/libAfterImage/libpng/pngerror.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngerror.c,1,['safe'],['safe']
Safety,"/* in addition to avoiding checking any; * further in this loop, make sure we; * skip checking in the dictionary. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_lazy.c:18,avoid,avoiding,18,builtins/zstd/compress/zstd_lazy.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_lazy.c,1,['avoid'],['avoiding']
Safety,"/* in both cases, abort processing CGI */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:18,abort,abort,18,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['abort'],['abort']
Safety,/* indexed by 2-zlib_error */; /* (size given to avoid silly warnings with Visual C++) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zutil.h:49,avoid,avoid,49,builtins/zlib/zutil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zutil.h,2,['avoid'],['avoid']
Safety,"/* inflate.c -- zlib decompression; * Copyright (C) 1995-2005 Mark Adler; * For conditions of distribution and use, see copyright notice in zlib.h; */; /*; * Change history:; *; * 1.2.beta0 24 Nov 2002; * - First version -- complete rewrite of inflate to simplify code, avoid; * creation of window when not needed, minimize use of window when it is; * needed, make inffast.c even faster, implement gzip decoding, and to; * improve code readability and style over the previous zlib inflate code; *; * 1.2.beta1 25 Nov 2002; * - Use pointers for available input and output checking in inffast.c; * - Remove input and output counters in inffast.c; * - Change inffast.c entry and loop from avail_in >= 7 to >= 6; * - Remove unnecessary second byte pull from length extra in inffast.c; * - Unroll direct copy to three copies per loop in inffast.c; *; * 1.2.beta2 4 Dec 2002; * - Change external routine names to reduce potential conflicts; * - Correct filename to inffixed.h for fixed tables in inflate.c; * - Make hbuf[] unsigned char to match parameter type in inflate.c; * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset); * to avoid negation problem on Alphas (64 bit) in inflate.c; *; * 1.2.beta3 22 Dec 2002; * - Add comments on state->bits assertion in inffast.c; * - Add comments on op field in inftrees.h; * - Fix bug in reuse of allocated window after inflateReset(); * - Remove bit fields--back to byte structure for speed; * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths; * - Change post-increments to pre-increments in inflate_fast(), PPC biased?; * - Add compile time option, POSTINC, to use post-increments instead (Intel?); * - Make MATCH copy in inflate() much faster for when inflate_fast() not used; * - Use local copies of stream next and avail values, as well as local bit; * buffer and bit count in inflate()--for speed when inflate_fast() not used; *; * 1.2.beta4 1 Jan 2003; * - Split ptr - 257 statements in inflate_table(",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inflate.c:270,avoid,avoid,270,graf2d/asimage/src/libAfterImage/zlib/inflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inflate.c,1,['avoid'],['avoid']
Safety,"/* inflate.c -- zlib decompression; * Copyright (C) 1995-2012 Mark Adler; * For conditions of distribution and use, see copyright notice in zlib.h; */; /*; * Change history:; *; * 1.2.beta0 24 Nov 2002; * - First version -- complete rewrite of inflate to simplify code, avoid; * creation of window when not needed, minimize use of window when it is; * needed, make inffast.c even faster, implement gzip decoding, and to; * improve code readability and style over the previous zlib inflate code; *; * 1.2.beta1 25 Nov 2002; * - Use pointers for available input and output checking in inffast.c; * - Remove input and output counters in inffast.c; * - Change inffast.c entry and loop from avail_in >= 7 to >= 6; * - Remove unnecessary second byte pull from length extra in inffast.c; * - Unroll direct copy to three copies per loop in inffast.c; *; * 1.2.beta2 4 Dec 2002; * - Change external routine names to reduce potential conflicts; * - Correct filename to inffixed.h for fixed tables in inflate.c; * - Make hbuf[] unsigned char to match parameter type in inflate.c; * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset); * to avoid negation problem on Alphas (64 bit) in inflate.c; *; * 1.2.beta3 22 Dec 2002; * - Add comments on state->bits assertion in inffast.c; * - Add comments on op field in inftrees.h; * - Fix bug in reuse of allocated window after inflateReset(); * - Remove bit fields--back to byte structure for speed; * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths; * - Change post-increments to pre-increments in inflate_fast(), PPC biased?; * - Add compile time option, POSTINC, to use post-increments instead (Intel?); * - Make MATCH copy in inflate() much faster for when inflate_fast() not used; * - Use local copies of stream next and avail values, as well as local bit; * buffer and bit count in inflate()--for speed when inflate_fast() not used; *; * 1.2.beta4 1 Jan 2003; * - Split ptr - 257 statements in inflate_table(",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c:270,avoid,avoid,270,builtins/zlib/inflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c,1,['avoid'],['avoid']
Safety,"/* inflate.h -- internal inflate state definition; * Copyright (C) 1995-2004 Mark Adler; * For conditions of distribution and use, see copyright notice in zlib.h; */; /* WARNING: this file should *not* be used by applications. It is; part of the implementation of the compression library and is; subject to change. Applications should only use zlib.h.; */; /* define NO_GZIP when compiling if you want to disable gzip header and; trailer decoding by inflate(). NO_GZIP would be used to avoid linking in; the crc code when it is not needed. For shared libraries, gzip decoding; should be left enabled. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inflate.h:486,avoid,avoid,486,graf2d/asimage/src/libAfterImage/zlib/inflate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inflate.h,1,['avoid'],['avoid']
Safety,"/* inflate.h -- internal inflate state definition; * Copyright (C) 1995-2009 Mark Adler; * For conditions of distribution and use, see copyright notice in zlib.h; */; /* WARNING: this file should *not* be used by applications. It is; part of the implementation of the compression library and is; subject to change. Applications should only use zlib.h.; */; /* define NO_GZIP when compiling if you want to disable gzip header and; trailer decoding by inflate(). NO_GZIP would be used to avoid linking in; the crc code when it is not needed. For shared libraries, gzip decoding; should be left enabled. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.h:486,avoid,avoid,486,builtins/zlib/inflate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.h,1,['avoid'],['avoid']
Safety,/* initializing padding into 0 to avoid any garbadge carry-over; 	 * bugs with diffusion: */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.c:34,avoid,avoid,34,graf2d/asimage/src/libAfterImage/scanline.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.c,1,['avoid'],['avoid']
Safety,"/* jtransform_execute_transform used to be called; * jtransform_execute_transformation, but some compilers complain about; * routine names that long. This macro is here to avoid breaking any; * old source code that uses the original name...; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/transupp.h:172,avoid,avoid,172,graf2d/asimage/src/libAfterImage/libjpeg/transupp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/transupp.h,1,['avoid'],['avoid']
Safety,/* just so we can safely cast void* to query magic number :*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asim_afterbase.h:18,safe,safely,18,graf2d/asimage/src/libAfterImage/asim_afterbase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asim_afterbase.h,1,['safe'],['safely']
Safety,/* libgcc and libunwind __register_frame behave differently. We use the presence; * of __unw_add_dynamic_fde to detect libunwind. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp:112,detect,detect,112,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp,1,['detect'],['detect']
Safety,/* libgcc and libunwind __register_frame behave differently. We use the; * presence of __unw_add_dynamic_fde to detect libunwind. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/RegisterEHFrames.cpp:112,detect,detect,112,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/RegisterEHFrames.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/RegisterEHFrames.cpp,1,['detect'],['detect']
Safety,/* local static not thread safe */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/cmake/win/w32pragma.h:27,safe,safe,27,cmake/win/w32pragma.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/cmake/win/w32pragma.h,1,['safe'],['safe']
Safety,/* lose a little precision to avoid overflow */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:30,avoid,avoid,30,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,3,['avoid'],['avoid']
Safety,/* making it sign safe */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asim_afterbase.h:18,safe,safe,18,graf2d/asimage/src/libAfterImage/asim_afterbase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asim_afterbase.h,1,['safe'],['safe']
Safety,"/* max msg_level that will be displayed */; /* For recoverable corrupt-data errors, we emit a warning message,; * but keep going unless emit_message chooses to abort. emit_message; * should count warnings in num_warnings. The surrounding application; * can check for bad data by seeing if num_warnings is nonzero at the; * end of processing.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jpeglib.h:51,recover,recoverable,51,graf2d/asimage/src/libAfterImage/libjpeg/jpeglib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jpeglib.h,2,"['abort', 'recover']","['abort', 'recoverable']"
Safety,/* no timeout */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gspawn.c:6,timeout,timeout,6,graf2d/win32gdk/gdk/src/glib/gspawn.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gspawn.c,1,['timeout'],['timeout']
Safety,"/* note : it's safe to invoke PREFETCH() on any memory address, including invalid ones */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c:15,safe,safe,15,builtins/zstd/decompress/zstd_decompress_block.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c,2,['safe'],['safe']
Safety,"/* note that CHadd and CHsub are unsafe, and CHIN doesn't yield 0/1 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regex2.h:33,unsafe,unsafe,33,interpreter/llvm-project/llvm/lib/Support/regex2.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regex2.h,1,['unsafe'],['unsafe']
Safety,"/* number of printable ascii chars minus \ and "" for string compat; * and ? to avoid ANSI trigraphs. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/xpm.c:79,avoid,avoid,79,graf2d/asimage/src/libAfterImage/xpm.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/xpm.c,1,['avoid'],['avoid']
Safety,"/* op values as set by inflate_table():; 00000000 - literal; 0000tttt - table link, tttt != 0 is the number of table index bits; 0001eeee - length or distance, eeee is the number of extra bits; 01100000 - end of block; 01000000 - invalid code; */; /* Maximum size of dynamic tree. The maximum found in a long but non-; exhaustive search was 1444 code structures (852 for length/literals; and 592 for distances, the latter actually the result of an; exhaustive search). The true maximum is not known, but the value; below is more than safe. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inftrees.h:534,safe,safe,534,graf2d/asimage/src/libAfterImage/zlib/inftrees.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inftrees.h,1,['safe'],['safe']
Safety,/* overflow detected */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h:12,detect,detected,12,builtins/zstd/common/bitstream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h,1,['detect'],['detected']
Safety,"/* overflow detected, like end of stream */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h:12,detect,detected,12,builtins/zstd/common/bitstream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h,1,['detect'],['detected']
Safety,/* overflow detection */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:12,detect,detection,12,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,7,['detect'],['detection']
Safety,/* overflow detection */; /* copy literals */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:12,detect,detection,12,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,1,['detect'],['detection']
Safety,/* png_handle_PLTE() may have canceled a valid tRNS chunk but left the; * 'valid' flag for the detection of duplicate chunks. Do not report a; * valid tRNS chunk in this case.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngget.c:95,detect,detection,95,graf2d/asimage/src/libAfterImage/libpng/pngget.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngget.c,1,['detect'],['detection']
Safety,"/* png_text holds the contents of a text/ztxt/itxt chunk in a PNG file,; * and whether that contents is compressed or not. The ""key"" field; * points to a regular zero-terminated C string. The ""text"" fields can be a; * regular C string, an empty string, or a NULL pointer.; * However, the structure returned by png_get_text() will always contain; * the ""text"" field as a regular zero-terminated C string (possibly; * empty), never a NULL pointer, so it can be safely used in printf() and; * other string-handling functions. Note that the ""itxt_length"", ""lang"", and; * ""lang_key"" members of the structure only exist when the library is built; * with iTXt chunk support. Prior to libpng-1.4.0 the library was built by; * default without iTXt support. Also note that when iTXt *is* supported,; * the ""lang"" and ""lang_key"" fields contain NULL pointers when the; * ""compression"" field contains * PNG_TEXT_COMPRESSION_NONE or; * PNG_TEXT_COMPRESSION_zTXt. Note that the ""compression value"" is not the; * same as what appears in the PNG tEXt/zTXt/iTXt chunk's ""compression flag""; * which is always 0 or 1, or its ""compression method"" which is always 0.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h:459,safe,safely,459,graf2d/asimage/src/libAfterImage/libpng/png.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.h,1,['safe'],['safely']
Safety,"/* pngtest.c - a simple test program to test libpng; *; * Copyright (c) 2018-2019 Cosmin Truta; * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson; * Copyright (c) 1996-1997 Andreas Dilger; * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.; *; * This code is released under the libpng license.; * For conditions of distribution and use, see the disclaimer; * and license in png.h; *; * This program reads in a PNG image, writes it out again, and then; * compares the two files. If the files are identical, this shows that; * the basic chunk handling, filtering, and (de)compression code is working; * properly. It does not currently test all of the transforms, although; * it probably should.; *; * The program will report ""FAIL"" in certain legitimate cases:; * 1) when the compression level or filter selection method is changed.; * 2) when the maximum IDAT size (PNG_ZBUF_SIZE in pngconf.h) is not 8192.; * 3) unknown unsafe-to-copy ancillary chunks or unknown critical chunks; * exist in the input file.; * 4) others not listed here...; * In these cases, it is best to check with another tool such as ""pngcheck""; * to see what the differences between the two files are.; *; * If a filename is given on the command-line, then this file is used; * for the input, rather than the default ""pngtest.png"". This allows; * testing a wide variety of files easily. You can also test a number; * of files at once by typing ""pngtest -m file1.png file2.png ...""; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngtest.c:942,unsafe,unsafe-to-copy,942,graf2d/asimage/src/libAfterImage/libpng/pngtest.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngtest.c,1,['unsafe'],['unsafe-to-copy']
Safety,/* pollres = 0 means timeout */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:21,timeout,timeout,21,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,3,['timeout'],['timeout']
Safety,/* posix assumed ; need a better detection method */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/threading.h:33,detect,detection,33,builtins/zstd/common/threading.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/threading.h,1,['detect'],['detection']
Safety,"/* preemptive overflow correction:; * 1. correction is large enough:; * lowLimit > (3<<29) ==> current > 3<<29 + 1<<windowLog; * 1<<windowLog <= newCurrent < 1<<chainLog + 1<<windowLog; *; * current - newCurrent; * > (3<<29 + 1<<windowLog) - (1<<windowLog + 1<<chainLog); * > (3<<29) - (1<<chainLog); * > (3<<29) - (1<<30) (NOTE: chainLog <= 30); * > 1<<29; *; * 2. (ip+ZSTD_CHUNKSIZE_MAX - cctx->base) doesn't overflow:; * After correction, current is less than (1<<chainLog + 1<<windowLog).; * In 64-bit mode we are safe, because we have 64-bit ptrdiff_t.; * In 32-bit mode we are safe, because (chainLog <= 29), so; * ip+ZSTD_CHUNKSIZE_MAX - cctx->base < 1<<32.; * 3. (cctx->lowLimit + 1<<windowLog) < 1<<32:; * windowLog <= 31 ==> 3<<29 + 1<<windowLog < 7<<29 < 1<<32.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress_internal.h:518,safe,safe,518,builtins/zstd/compress/zstd_compress_internal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress_internal.h,2,['safe'],['safe']
Safety,/* provides the minimum logSize to safely represent a distribution */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/fse_compress.c:35,safe,safely,35,builtins/zstd/compress/fse_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/fse_compress.c,1,['safe'],['safely']
Safety,"/* public fields */; /* Color conversion buffer. When using separate upsampling and color; * conversion steps, this buffer holds one upsampled row group until it; * has been color converted and output.; * Note: we do not allocate any storage for component(s) which are full-size,; * ie do not need rescaling. The corresponding entry of color_buf[] is; * simply set to point to the input data array, thereby avoiding copying.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdsample.c:407,avoid,avoiding,407,graf2d/asimage/src/libAfterImage/libjpeg/jdsample.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdsample.c,1,['avoid'],['avoiding']
Safety,/* recover only the easy case */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regcomp.c:3,recover,recover,3,interpreter/llvm-project/llvm/lib/Support/regcomp.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regcomp.c,1,['recover'],['recover']
Safety,/* repcode detected */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_lazy.c:11,detect,detected,11,builtins/zstd/compress/zstd_lazy.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_lazy.c,2,['detect'],['detected']
Safety,/* repcode detected we should take it */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_lazy.c:11,detect,detected,11,builtins/zstd/compress/zstd_lazy.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_lazy.c,2,['detect'],['detected']
Safety,"/* result is at most 19 bits, so this cast is safe: */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:46,safe,safe,46,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,1,['safe'],['safe']
Safety,/* risk : address space overflow (32-bits) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c:3,risk,risk,3,builtins/zstd/decompress/zstd_decompress_block.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c,1,['risk'],['risk']
Safety,/* risk : address space underflow on oend=NULL */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c:3,risk,risk,3,builtins/zstd/decompress/zstd_decompress_block.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c,1,['risk'],['risk']
Safety,/* risk of rounding to zero */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/fse_compress.c:3,risk,risk,3,builtins/zstd/compress/fse_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/fse_compress.c,1,['risk'],['risk']
Safety,/* risk reading beyond src buffer with wildcopy */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c:3,risk,risk,3,builtins/zstd/decompress/zstd_decompress_block.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c,1,['risk'],['risk']
Safety,/* safe and portable access using memcpy() */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:3,safe,safe,3,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,1,['safe'],['safe']
Safety,/* safe because it is initialized */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngset.c:3,safe,safe,3,graf2d/asimage/src/libAfterImage/libpng/pngset.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngset.c,1,['safe'],['safe']
Safety,/* safe because of the check */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c:3,safe,safe,3,graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,1,['safe'],['safe']
Safety,/* safe-to-copy overrides everything */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c:3,safe,safe-to-copy,3,graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwrite.c,1,['safe'],['safe-to-copy']
Safety,/* safe: < ZLIB_IO_MAX */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:3,safe,safe,3,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['safe'],['safe']
Safety,/* safe: < than ZLIB_IO_MAX */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:3,safe,safe,3,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['safe'],['safe']
Safety,/* safety */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c:3,safe,safety,3,graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,2,['safe'],['safety']
Safety,/* safety */; /* Now clear everything out for safety; the following may not have been; * done.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:3,safe,safety,3,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,2,['safe'],['safety']
Safety,/* safety check */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmarker.c:3,safe,safety,3,graf2d/asimage/src/libAfterImage/libjpeg/jcmarker.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmarker.c,6,['safe'],['safety']
Safety,/* safety check */; /* get control block */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:3,safe,safety,3,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,2,['safe'],['safety']
Safety,/* safety check: shouldn't happen given limited correction-bit buffer */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c:3,safe,safety,3,graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jchuff.c,2,['safe'],['safety']
Safety,/* safety checks */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/hist.c:3,safe,safety,3,builtins/zstd/compress/hist.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/hist.c,2,['safe'],['safety']
Safety,/* safety: set below */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c:3,safe,safety,3,graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngrutil.c,1,['safe'],['safety']
Safety,/* sanity check */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c:3,sanity check,sanity check,3,graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatadst.c,2,['sanity check'],['sanity check']
Safety,"/* since an int is returned, make sure len fits in one, otherwise return; with an error (this avoids the flaw in the interface) */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c:94,avoid,avoids,94,builtins/zlib/gzread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/gzread.c,2,['avoid'],['avoids']
Safety,/* so we can detect potential overflow of the; running sum */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c:13,detect,detect,13,graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngwutil.c,1,['detect'],['detect']
Safety,/* somewhere `safe' */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx:14,safe,safe,14,graf2d/x11/src/Rotated.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx,1,['safe'],['safe']
Safety,"/* sscanf() is safe here, since send_ssi_file() also uses buffer; 	 * of size MG_BUF_LEN to get the tag. So strlen(tag) is; 	 * always < MG_BUF_LEN. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:15,safe,safe,15,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['safe'],['safe']
Safety,"/* text, sPLT or unknown chunks */; /* Magic to create a struct when there is no struct to call the user supplied; * memory allocators. Because error handling has not been set up the memory; * handlers can't safely call png_error, but this is an obscure and undocumented; * restriction so libpng has to assume that the 'free' handler, at least, might; * call png_error.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h:208,safe,safely,208,graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngpriv.h,1,['safe'],['safely']
Safety,"/* the dictSize param is an int, avoid truncation / sign issues */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c:33,avoid,avoid,33,builtins/lz4/lz4frame.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4frame.c,2,['avoid'],['avoid']
Safety,/* the following is likely just redundant */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:32,redund,redundant,32,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['redund'],['redundant']
Safety,"/* the variable is only declared,; it actually lives in debug.c,; and is shared by the whole process.; It's not thread-safe.; It's useful when enabling very verbose levels; on selective conditions (such as position in src) */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/debug.h:119,safe,safe,119,builtins/zstd/common/debug.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/debug.h,1,['safe'],['safe']
Safety,/* this is where we can safely include GLU */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/inc/GL/glew.h:24,safe,safely,24,builtins/glew/inc/GL/glew.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/inc/GL/glew.h,1,['safe'],['safely']
Safety,/* timeout */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,timeout,timeout,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['timeout'],['timeout']
Safety,/* timeout in ms */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.cpp:3,timeout,timeout,3,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.cpp,1,['timeout'],['timeout']
Safety,/* timeout: return 0 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:3,timeout,timeout,3,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['timeout'],['timeout']
Safety,/* to avoid another reload */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c:6,avoid,avoid,6,builtins/zstd/decompress/zstd_decompress_block.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c,1,['avoid'],['avoid']
Safety,/* to avoid double gamma correction bug */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c:6,avoid,avoid,6,graf2d/asimage/src/libAfterImage/libpng/pngread.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/pngread.c,1,['avoid'],['avoid']
Safety,/* to avoid double redirection */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ascmap.c:6,avoid,avoid,6,graf2d/asimage/src/libAfterImage/ascmap.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ascmap.c,1,['avoid'],['avoid']
Safety,/* to avoid needing a zero byte */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:6,avoid,avoid,6,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,1,['avoid'],['avoid']
Safety,/* to avoid one more if() in loop we moved tail part out of the loop : */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/transform.c:6,avoid,avoid,6,graf2d/asimage/src/libAfterImage/transform.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/transform.c,2,['avoid'],['avoid']
Safety,/* try adding some safety padding */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmessages.c:19,safe,safety,19,graf2d/win32gdk/gdk/src/glib/gmessages.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmessages.c,2,['safe'],['safety']
Safety,/* unsafe version; does not check buffer overflow */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h:3,unsafe,unsafe,3,builtins/zstd/common/bitstream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h,1,['unsafe'],['unsafe']
Safety,"/* up->Dst is on the left. It is safe to form triangles from lo->Org.; * The EdgeGoesLeft test guarantees progress even when some triangles; * are CW, given that the upper and lower chains are truly monotone.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/tessmono.c:33,safe,safe,33,graf3d/eve7/glu/tessmono.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/tessmono.c,1,['safe'],['safe']
Safety,/* use a local state to memcpy() in order to avoid strict-aliasing warnings */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:45,avoid,avoid,45,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['avoid'],['avoid']
Safety,/* use long arithmetic here to avoid overflow & unsigned problems */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c:31,avoid,avoid,31,graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jmemmgr.c,2,['avoid'],['avoid']
Safety,/* use the same thread safe buffer */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:23,safe,safe,23,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,2,['safe'],['safe']
Safety,/* use thread safe buffer */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:14,safe,safe,14,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['safe'],['safe']
Safety,/* used[i] is only -1 if the pixel at that location hasn't; * been allocated yet. This is a sanity check required for proper; * color allocation by the progressive image loader.; * When colors[i] == 0 it indicates the slot is available for; * allocation.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c:92,sanity check,sanity check,92,graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/gdk/win32/gdkcc-win32.c,1,['sanity check'],['sanity check']
Safety,/* using a local state to memcpy() in order to avoid strict-aliasing warnings */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:47,avoid,avoid,47,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['avoid'],['avoid']
Safety,/* verifier will print to stderr and abort() */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Analysis.h:37,abort,abort,37,interpreter/llvm-project/llvm/include/llvm-c/Analysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Analysis.h,1,['abort'],['abort']
Safety,"/* very crude algorithm, detecting biggest spans of the same color :*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/transform.c:25,detect,detecting,25,graf2d/asimage/src/libAfterImage/transform.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/transform.c,1,['detect'],['detecting']
Safety,/* we have to operate with 14 bit values in order to avoid overflow */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.c:53,avoid,avoid,53,graf2d/asimage/src/libAfterImage/scanline.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/scanline.c,1,['avoid'],['avoid']
Safety,/* we must have colormap so that we can safely create windows; 	 * with different visuals even if we are in TrueColor mode : */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.h:40,safe,safely,40,graf2d/asimage/src/libAfterImage/asvisual.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.h,1,['safe'],['safely']
Safety,/* we want to avoid memory overflow : */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ascmap.c:14,avoid,avoid,14,graf2d/asimage/src/libAfterImage/ascmap.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/ascmap.c,1,['avoid'],['avoid']
Safety,"/* we want to open the input file before doing anything else,; 	 * so that the setjmp() error recovery below can assume the file is open.; 	 * VERY IMPORTANT: use ""b"" option to fopen() if you are on a machine that; 	 * requires it in order to read binary files.; 	 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.c:94,recover,recovery,94,graf2d/asimage/src/libAfterImage/import.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/import.c,1,['recover'],['recovery']
Safety,"/* while (totalCost > 0) */; /* If we've removed too much weight, then we have to add it back.; * To avoid overshooting again, we only adjust the smallest rank.; * We take the largest nodes from the lowest rank 0 and move them; * to rank 1. There's guaranteed to be enough rank 0 symbols because; * TODO.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/huf_compress.c:101,avoid,avoid,101,builtins/zstd/compress/huf_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/huf_compress.c,1,['avoid'],['avoid']
Safety,/* write in buffer is safe */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/fse_compress.c:22,safe,safe,22,builtins/zstd/compress/fse_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/fse_compress.c,1,['safe'],['safe']
Safety,"/*! BIT_flushBits() :; * assumption : bitContainer has not overflowed; * safe version; check for buffer overflow, and prevents it.; * note : does not signal buffer overflow.; * overflow will be revealed later on using BIT_closeCStream() */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h:73,safe,safe,73,builtins/zstd/common/bitstream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h,1,['safe'],['safe']
Safety,/*! BIT_flushBitsFast() :; * assumption : bitContainer has not overflowed; * unsafe version; does not check buffer overflow */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h:77,unsafe,unsafe,77,builtins/zstd/common/bitstream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h,1,['unsafe'],['unsafe']
Safety,/*! BIT_lookBitsFast() :; * unsafe version; only works if nbBits >= 1 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h:28,unsafe,unsafe,28,builtins/zstd/common/bitstream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h,1,['unsafe'],['unsafe']
Safety,/*! BIT_readBitsFast() :; * unsafe version; only works only if nbBits >= 1 */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h:28,unsafe,unsafe,28,builtins/zstd/common/bitstream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h,1,['unsafe'],['unsafe']
Safety,"/*! BIT_reloadDStream() :; * Refill `bitD` from buffer previously set in BIT_initDStream() .; * This function is safe, it guarantees it will not read beyond src buffer.; * @return : status of `BIT_DStream_t` internal register.; * when status == BIT_DStream_unfinished, internal register is filled with at least 25 or 57 bits */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h:113,safe,safe,113,builtins/zstd/common/bitstream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h,1,['safe'],['safe']
Safety,/*! Compute the neural network prediction obtained from applying the output; * function f to the activation of the last layer in the network. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Net.h:31,predict,prediction,31,tmva/tmva/inc/TMVA/DNN/Net.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Net.h,1,['predict'],['prediction']
Safety,/*! Compute the neural network prediction obtained from forwarding the; * batch X through the neural network and applying the output function; * f to the activation of the last layer in the network. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Net.h:31,predict,prediction,31,tmva/tmva/inc/TMVA/DNN/Net.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Net.h,1,['predict'],['prediction']
Safety,"/*! FSE_decodeSymbolFast() :; unsafe, only works if no symbol has a probability > 50% */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h:30,unsafe,unsafe,30,builtins/zstd/common/fse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/fse.h,1,['unsafe'],['unsafe']
Safety,"/*! Generate a conv net, get the predictios */; //______________________________________________________________________________",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestConvNet.h:33,predict,predictios,33,tmva/tmva/test/DNN/CNN/TestConvNet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestConvNet.h,1,['predict'],['predictios']
Safety,"/*! HIST_count_simple() :; * Same as HIST_countFast(), this function is unsafe,; * and will segfault if any value within `src` is `> *maxSymbolValuePtr`.; * It is also a bit slower for large inputs.; * However, it does not need any additional memory (not even on stack).; * @return : count of the most frequent symbol.; * Note this function doesn't produce any error (i.e. it must succeed).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/hist.h:72,unsafe,unsafe,72,builtins/zstd/compress/hist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/hist.h,1,['unsafe'],['unsafe']
Safety,"/*! LZ4_compress_fast_extState_fastReset() :; * A variant of LZ4_compress_fast_extState().; *; * Using this variant avoids an expensive initialization step.; * It is only safe to call if the state buffer is known to be correctly initialized already; * (see above comment on LZ4_resetStream_fast() for a definition of ""correctly initialized"").; * From a high level, the difference is that; * this function initializes the provided state with a call to something like LZ4_resetStream_fast(); * while LZ4_compress_fast_extState() starts with a call to LZ4_resetStream().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:116,avoid,avoids,116,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,2,"['avoid', 'safe']","['avoids', 'safe']"
Safety,"/*! LZ4_decompress_*_continue() :; * These decoding functions allow decompression of consecutive blocks in ""streaming"" mode.; * A block is an unsplittable entity, it must be presented entirely to a decompression function.; * Decompression functions only accepts one block at a time.; * The last 64KB of previously decoded data *must* remain available and unmodified at the memory position where they were decoded.; * If less than 64KB of data has been decoded, all the data must be present.; *; * Special : if decompression side sets a ring buffer, it must respect one of the following conditions :; * - Decompression buffer size is _at least_ LZ4_decoderRingBufferSize(maxBlockSize).; * maxBlockSize is the maximum size of any single block. It can have any value > 16 bytes.; * In which case, encoding and decoding buffers do not need to be synchronized.; * Actually, data can be produced by any source compliant with LZ4 format specification, and respecting maxBlockSize.; * - Synchronized mode :; * Decompression buffer size is _exactly_ the same as compression buffer size,; * and follows exactly same update rule (block boundaries at same positions),; * and decoding function is provided with exact decompressed size of each block (exception for last block of the stream),; * _then_ decoding & encoding ring buffer can have any size, including small ones ( < 64 KB).; * - Decompression buffer is larger than encoding buffer, by a minimum of maxBlockSize more bytes.; * In which case, encoding and decoding buffers do not need to be synchronized,; * and encoding ring buffer can have any size, including small ones ( < 64 KB).; *; * Whenever these conditions are not possible,; * save the last 64KB of decoded data into a safe buffer where it can't be modified during decompression,; * then indicate where this data is saved using LZ4_setStreamDecode(), before decompressing next block.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:1726,safe,safe,1726,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['safe'],['safe']
Safety,"/*! LZ4_decompress_safe() :; * compressedSize : is the exact complete size of the compressed block.; * dstCapacity : is the size of destination buffer (which must be already allocated), presumed an upper bound of decompressed size.; * @return : the number of bytes decompressed into destination buffer (necessarily <= dstCapacity); * If destination buffer is not large enough, decoding will stop and output an error code (negative value).; * If the source stream is detected malformed, the function will stop decoding and return a negative result.; * Note 1 : This function is protected against malicious data packets :; * it will never writes outside 'dst' buffer, nor read outside 'source' buffer,; * even if the compressed block is maliciously modified to order the decoder to do these actions.; * In such case, the decoder stops immediately, and considers the compressed block malformed.; * Note 2 : compressedSize and dstCapacity must be provided to the function, the compressed block does not contain them.; * The implementation is free to send / store / derive this information in whichever way is most beneficial.; * If there is a need for a different format which bundles together both compressed data and its metadata, consider looking at lz4frame.h instead.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:466,detect,detected,466,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['detect'],['detected']
Safety,"/*! LZ4_decompress_safe_partial() :; * Decompress an LZ4 compressed block, of size 'srcSize' at position 'src',; * into destination buffer 'dst' of size 'dstCapacity'.; * Up to 'targetOutputSize' bytes will be decoded.; * The function stops decoding on reaching this objective.; * This can be useful to boost performance; * whenever only the beginning of a block is required.; *; * @return : the number of bytes decoded in `dst` (necessarily <= targetOutputSize); * If source stream is detected malformed, function returns a negative result.; *; * Note 1 : @return can be < targetOutputSize, if compressed block contains less data.; *; * Note 2 : targetOutputSize must be <= dstCapacity; *; * Note 3 : this function effectively stops decoding on reaching targetOutputSize,; * so dstCapacity is kind of redundant.; * This is because in older versions of this function,; * decoding operation would still write complete sequences.; * Therefore, there was no guarantee that it would stop writing at exactly targetOutputSize,; * it could write more bytes, though only up to dstCapacity.; * Some ""margin"" used to be required for this operation to work properly.; * Thankfully, this is no longer necessary.; * The function nonetheless keeps the same signature, in an effort to preserve API compatibility.; *; * Note 4 : If srcSize is the exact size of the block,; * then targetOutputSize can be any value,; * including larger than the block's decompressed size.; * The function will, at most, generate block's decompressed size.; *; * Note 5 : If srcSize is _larger_ than block's compressed size,; * then targetOutputSize **MUST** be <= block's decompressed size.; * Otherwise, *silent corruption will occur*.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:486,detect,detected,486,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,2,"['detect', 'redund']","['detected', 'redundant']"
Safety,"/*! LZ4_resetStream_fast() : v1.9.0+; * Use this to prepare an LZ4_stream_t for a new chain of dependent blocks; * (e.g., LZ4_compress_fast_continue()).; *; * An LZ4_stream_t must be initialized once before usage.; * This is automatically done when created by LZ4_createStream().; * However, should the LZ4_stream_t be simply declared on stack (for example),; * it's necessary to initialize it first, using LZ4_initStream().; *; * After init, start any new stream with LZ4_resetStream_fast().; * A same LZ4_stream_t can be re-used multiple times consecutively; * and compress multiple streams,; * provided that it starts each new stream with LZ4_resetStream_fast().; *; * LZ4_resetStream_fast() is much faster than LZ4_initStream(),; * but is not compatible with memory regions containing garbage data.; *; * Note: it's only useful to call LZ4_resetStream_fast(); * in the context of streaming compression.; * The *extState* functions perform their own resets.; * Invoking LZ4_resetStream_fast() before is redundant, and even counterproductive.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:1006,redund,redundant,1006,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['redund'],['redundant']
Safety,"/*! LZ4_saveDict() :; * If last 64KB data cannot be guaranteed to remain available at its current memory location,; * save it into a safer place (char* safeBuffer).; * This is schematically equivalent to a memcpy() followed by LZ4_loadDict(),; * but is much faster, because LZ4_saveDict() doesn't need to rebuild tables.; * @return : saved dictionary size in bytes (necessarily <= maxDictSize), or 0 if error.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:133,safe,safer,133,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,2,['safe'],"['safeBuffer', 'safer']"
Safety,"/*! LZ4_streamDecode_t :; * information structure to track an LZ4 stream during decompression.; * init this structure using LZ4_setStreamDecode() before first use.; * note : only use in association with static linking !; * this definition is not API/ABI safe,; * and may change in a future version !; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:254,safe,safe,254,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['safe'],['safe']
Safety,"/*! LZ4_stream_t :; * Do not use below internal definitions directly !; * Declare or allocate an LZ4_stream_t instead.; * LZ4_stream_t can also be created using LZ4_createStream(), which is recommended.; * The structure definition can be convenient for static allocation; * (on stack, or as part of larger structure).; * Init this structure with LZ4_initStream() before first use.; * note : only use this definition in association with static linking !; * this definition is not API/ABI safe, and may change in future versions.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:487,safe,safe,487,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['safe'],['safe']
Safety,"/*! Obsolete LZ4_decompress_fast variants (since v1.9.0) :; * These functions used to be faster than LZ4_decompress_safe(),; * but this is no longer the case. They are now slower.; * This is because LZ4_decompress_fast() doesn't know the input size,; * and therefore must progress more cautiously into the input buffer to not read beyond the end of block.; * On top of that `LZ4_decompress_fast()` is not protected vs malformed or malicious inputs, making it a security liability.; * As a consequence, LZ4_decompress_fast() is strongly discouraged, and deprecated.; *; * The last remaining LZ4_decompress_fast() specificity is that; * it can decompress a block without knowing its compressed size.; * Such functionality can be achieved in a more secure manner; * by employing LZ4_decompress_safe_partial().; *; * Parameters:; * originalSize : is the uncompressed size to regenerate.; * `dst` must be already allocated, its size must be >= 'originalSize' bytes.; * @return : number of bytes read from source buffer (== compressed size).; * The function expects to finish at block's end exactly.; * If the source stream is detected malformed, the function stops decoding and returns a negative result.; * note : LZ4_decompress_fast*() requires originalSize. Thanks to this information, it never writes past the output buffer.; * However, since it doesn't know its 'src' size, it may read an unknown amount of input, past input buffer bounds.; * Also, since match offsets are not validated, match reads from 'src' may underflow too.; * These issues never happen if input (compressed) data is correct.; * But they may happen if input data is invalid (error or intentional tampering).; * As a consequence, use these functions in trusted environments with trusted data **only**.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:1121,detect,detected,1121,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['detect'],['detected']
Safety,/*! Prediction based on activations stored in the last layer. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/DeepNet.h:4,Predict,Prediction,4,tmva/tmva/inc/TMVA/DNN/DeepNet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/DeepNet.h,1,['Predict'],['Prediction']
Safety,"/*! Prediction for the given inputs, based on what network learned. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/DeepNet.h:4,Predict,Prediction,4,tmva/tmva/inc/TMVA/DNN/DeepNet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/DeepNet.h,1,['Predict'],['Prediction']
Safety,"/*! ZSTD_compress_usingCDict_advanced() :; * Note : this function is now REDUNDANT.; * It can be replaced by ZSTD_compress2(), in combination with ZSTD_CCtx_loadDictionary() and other parameter setters.; * This prototype will be marked as deprecated and generate compilation warning in some future version */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:73,REDUND,REDUNDANT,73,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['REDUND'],['REDUNDANT']
Safety,/*! ZSTD_reduceIndex() :; * rescale all indexes to avoid future overflow (indexes are U32) */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:51,avoid,avoid,51,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,1,['avoid'],['avoid']
Safety,"/*! ZSTD_safecopy() :; * Specialized version of memcpy() that is allowed to READ up to WILDCOPY_OVERLENGTH past the input buffer; * and write up to 16 bytes past oend_w (op >= oend_w is allowed).; * This function is only called in the uncommon case where the sequence is near the end of the block. It; * should be fast for a single long sequence, but can be slow for several short sequences.; *; * @param ovtype controls the overlap detection; * - ZSTD_no_overlap: The source and destination are guaranteed to be at least WILDCOPY_VECLEN bytes apart.; * - ZSTD_overlap_src_before_dst: The src and dst may overlap and may be any distance apart.; * The src buffer must be before the dst buffer.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c:433,detect,detection,433,builtins/zstd/decompress/zstd_decompress_block.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress_block.c,1,['detect'],['detection']
Safety,"/*! ZSTD_wildcopy() :; * Custom version of ZSTD_memcpy(), can over read/write up to WILDCOPY_OVERLENGTH bytes (if length==0); * @param ovtype controls the overlap detection; * - ZSTD_no_overlap: The source and destination are guaranteed to be at least WILDCOPY_VECLEN bytes apart.; * - ZSTD_overlap_src_before_dst: The src and dst may overlap, but they MUST be at least 8 bytes apart.; * The src buffer must be before the dst buffer.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/zstd_internal.h:163,detect,detection,163,builtins/zstd/common/zstd_internal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/zstd_internal.h,1,['detect'],['detection']
Safety,"/*!; * XXH32():; * Calculate the 32-bit hash of sequence ""length"" bytes stored at memory address ""input"".; * The memory between input & input+length must be valid (allocated and read-accessible).; * ""seed"" can be used to alter the result predictably.; * Speed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark): 5.4 GB/s; *; * Note: XXH3 provides competitive speed for both 32-bit and 64-bit systems,; * and offers true 64/128 bit hash results. It provides a superior level of; * dispersion, and greatly reduces the risks of collisions.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:238,predict,predictably,238,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,"['predict', 'risk']","['predictably', 'risks']"
Safety,"/*!; * XXH64():; * Returns the 64-bit hash of sequence of length @length stored at memory; * address @input.; * @seed can be used to alter the result predictably.; *; * This function usually runs faster on 64-bit systems, but slower on 32-bit; * systems (see benchmark).; *; * Note: XXH3 provides competitive speed for both 32-bit and 64-bit systems,; * and offers true 64/128 bit hash results. It provides a superior level of; * dispersion, and greatly reduces the risks of collisions.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:150,predict,predictably,150,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,"['predict', 'risk']","['predictably', 'risks']"
Safety,"/*!; * XXH_NAMESPACE, aka Namespace Emulation:; *; * If you want to include _and expose_ xxHash functions from within your own; * library, but also want to avoid symbol collisions with other libraries which; * may also include xxHash, you can use XXH_NAMESPACE to automatically prefix; * any public symbol from xxhash library with the value of XXH_NAMESPACE; * (therefore, avoid empty or numeric values).; *; * Note that no change is required within the calling program as long as it; * includes `xxhash.h`: Regular symbol names will be automatically translated; * by this header.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:156,avoid,avoid,156,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,['avoid'],['avoid']
Safety,"/** @brief poll a set of pipes for events (ready to read from, ready to; * write to, error); *; * @param pipes set of pipes to check; * @param timeout timeout in milliseconds; * @returns positive number: number of pipes which have; * status changes, 0: timeout, or no pipes with; * status changed, -1 on error; *; * Timeout can be zero (check for specified events, and return), finite; * (wait at most timeout milliseconds before returning), or -1; * (infinite). The poll method returns when the timeout has elapsed,; * or if an event occurs on one of the pipes being polled, whichever; * happens earlier.; *; * Pipes is a vector of one or more PollEntries, which each list a pipe; * and events to poll for. If events is left empty (zero), all; * conditions are polled for, otherwise only the indicated ones. On; * return, the revents fields contain the events that occurred for each; * pipe; error Error, EndOfFile or Invalid events are always set,; * regardless of whether they were in the set of requested events.; *; * poll may block slightly longer than specified by timeout due to OS; * timer granularity and OS scheduling. Due to its implementation, the; * poll call can also return early if the remote end of the page sends; * a free page while polling (which is put on that pipe's freelist),; * while that pipe is polled for e.g Reading. The status of the pipe is; * indicated correctly in revents, and the caller can simply poll; * again. (The reason this is done this way is because it helps to; * replenish the pool of free pages and queue busy pages without; * blocking.); *; * Here's a piece of example code waiting on two pipes; if they become; * readable they are read:; * @code; * #include <unistd.h>; * #include <cstdlib>; * #include <string>; * #include <sstream>; * #include <iostream>; *; * #include ""BidirMMapPipe.h""; *; * // what to execute in the child; * int randomchild(BidirMMapPipe& pipe); * {; * ::srand48(::getpid());; * for (int i = 0; i < 5; ++i) {; * // sleep a random",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h:143,timeout,timeout,143,roofit/roofitcore/src/BidirMMapPipe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h,6,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,"/** @name --- Other Functions --- */; /**; Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/SMatrix.h:181,avoid,avoid,181,math/smatrix/inc/Math/SMatrix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/SMatrix.h,1,['avoid'],['avoid']
Safety,/** @name GCRoot Specific Properties; * These properties and overrides only apply to collector strategies using; * GCRoot.; */; ///@{; /// True if safe points need to be inferred on call sites,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GCStrategy.h:147,safe,safe,147,interpreter/llvm-project/llvm/include/llvm/IR/GCStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GCStrategy.h,1,['safe'],['safe']
Safety,/** @summary Analyze TGeo node kind; * @desc 0 - TGeoNode; * 1 - TEveGeoNode; * -1 - unsupported; * @return detected node kind; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:108,detect,detected,108,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['detect'],['detected']
Safety,"/** @summary Call 3D rendering of the geometry; * @param tmout - specifies delay, after which actual rendering will be invoked; * @param [measure] - when true, for the first time printout rendering time; * @return {Promise} when tmout bigger than 0 is specified; * @desc Timeout used to avoid multiple rendering of the picture when several 3D drawings; * superimposed with each other. If tmout <= 0, rendering performed immediately; * Several special values are used:; * -1 - force recheck of rendering order based on camera position */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:271,Timeout,Timeout,271,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,"['Timeout', 'avoid']","['Timeout', 'avoid']"
Safety,/** @summary Checks if draw elements were resized and drawing should be updated; * @return {boolean} true if resize was detected; * @protected; * @abstract */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:120,detect,detected,120,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['detect'],['detected']
Safety,/** @summary Convert ROOT TDatime object into Date; * @desc Always use UTC to avoid any variation between timezones */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:78,avoid,avoid,78,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"/** @summary Create a single regex to detect any symbol to replace, apply longer symbols first; * @private */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:38,detect,detect,38,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['detect'],['detect']
Safety,/** @summary Detect mouse right button; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,Detect,Detect,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Detect'],['Detect']
Safety,"/** @summary Display progress message in the left bottom corner.; * @desc Previous message will be overwritten; * if no argument specified, any shown messages will be removed; * @param {string} msg - message to display; * @param {number} [tmout] - optional timeout in milliseconds, after message will disappear; * @param {function} [click_handle] - optional handle to process click events; * @private */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:257,timeout,timeout,257,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['timeout'],['timeout']
Safety,/** @summary Handle openui5 resize glitch; * @desc onAfterRendering method does not provide valid dimension of the HTML element; * One should wait either resize event or timeout and check if valid size is there; * Only then normal rendering can be started; * Method also used to check resize events */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/canv/controller/CanvasPanel.controller.js:170,timeout,timeout,170,ui5/canv/controller/CanvasPanel.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/canv/controller/CanvasPanel.controller.js,1,['timeout'],['timeout']
Safety,/** @summary Let detect and solve problem when server returns wrong Content-Length header; * @desc See [jsroot#189]{@link https://github.com/root-project/jsroot/issues/189} for more info; * Can be enabled by adding 'wrong_http_response' parameter to URL when using JSROOT UI; * @default false */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:17,detect,detect,17,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['detect'],['detect']
Safety,/** @summary Location of JSROOT modules; * @desc Automatically detected and used to dynamically load other modules; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:63,detect,detected,63,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['detect'],['detected']
Safety,/** @summary Main function in geometry creation loop; * @desc Returns:; * - false when nothing todo; * - true if one could perform next action immediately; * - 1 when call after short timeout required; * - 2 when call must be done from processWorkerReply */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:184,timeout,timeout,184,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['timeout'],['timeout']
Safety,"/** @summary Prefer to use saved points in TF1/TF2, avoids eval() and Function() when possible */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:52,avoid,avoids,52,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoids']
Safety,/** @summary Safely remove all drawings from specified element; * @param {string|object} dom - id or DOM element; * @public; * @example; * import { cleanup } from 'https://root.cern/js/latest/modules/base/ObjectPainter.mjs';; * cleanup('drawing');; * cleanup(document.querySelector('#drawing')); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,Safe,Safely,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Safe'],['Safely']
Safety,"/** @summary Scan content of 1-D histogram; * @desc Detect min/max values for x and y axis; * @param {boolean} when_axis_changed - true when zooming was changed, some checks may be skipped */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:52,Detect,Detect,52,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Detect'],['Detect']
Safety,/** @summary Send only last message of specified kind during defined time interval.; * @desc Idea is to prevent sending multiple messages of similar kind and overload connection; * Instead timeout is started after which only last specified message will be send; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:189,timeout,timeout,189,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,1,['timeout'],['timeout']
Safety,/** @summary Try to detect and create font handler for SVG text node; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:20,detect,detect,20,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['detect'],['detect']
Safety,/** @summary browser detection flags; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:21,detect,detection,21,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['detect'],['detection']
Safety,"/** @summary call 3D rendering of the frame; * @param {number} tmout - specifies delay, after which actual rendering will be invoked; * @desc Timeout used to avoid multiple rendering of the picture when several 3D drawings; * superimposed with each other.; * If tmout <= 0, rendering performed immediately; * If tmout === -1111, immediate rendering with SVG renderer is performed; * @private */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:142,Timeout,Timeout,142,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,"['Timeout', 'avoid']","['Timeout', 'avoid']"
Safety,/** @summary call this function to abort processing */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:35,abort,abort,35,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['abort'],['abort']
Safety,"/** @summary handler for configuration changes,; * @desc after short timeout send updated config to the server */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/controller/GeomViewer.controller.js:69,timeout,timeout,69,ui5/geom/controller/GeomViewer.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/controller/GeomViewer.controller.js,1,['timeout'],['timeout']
Safety,/** @summary method used to avoid duplication of warnings; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:28,avoid,avoid,28,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"/** @summary set, test or reset timeout of specified name; * @desc Used to prevent overloading of websocket for specific function */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:32,timeout,timeout,32,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['timeout'],['timeout']
Safety,/** A compact GC layout. Emit this data structure:; *; * struct {; * int16_t PointCount;; * void *SafePointAddress[PointCount];; * int16_t StackFrameSize; (in words); * int16_t StackArity;; * int16_t LiveCount;; * int16_t LiveOffsets[LiveCount];; * } __gcmap_<FUNCTIONNAME>;; **/; // Align to address width.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp:98,Safe,SafePointAddress,98,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,1,['Safe'],['SafePointAddress']
Safety,"/** Check if file is requested, thread safe */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/inc/THttpServer.h:39,safe,safe,39,net/http/inc/THttpServer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/inc/THttpServer.h,1,['safe'],['safe']
Safety,/** Check whether LLVM is executing in thread-safe mode or not.; @see llvm::llvm_is_multithreaded */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:46,safe,safe,46,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['safe'],['safe']
Safety,"/** Custom ""builtins,"" detectable by type, for pass by ref and improved; performance.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CustomPyTypes.h:23,detect,detectable,23,bindings/pyroot/cppyy/CPyCppyy/src/CustomPyTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CustomPyTypes.h,1,['detect'],['detectable']
Safety,"/** HIST_countFast() :; * same as HIST_count(), but blindly trusts that all byte values within src are <= *maxSymbolValuePtr.; * This function is unsafe, and will segfault if any value within `src` is `> *maxSymbolValuePtr`; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/hist.h:146,unsafe,unsafe,146,builtins/zstd/compress/hist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/hist.h,1,['unsafe'],['unsafe']
Safety,"/** HUF_buildCTable() :; * @return : maxNbBits; * Note : count is used before tree is written, so they can safely overlap; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/huf_compress.c:107,safe,safely,107,builtins/zstd/compress/huf_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/huf_compress.c,1,['safe'],['safely']
Safety,/** Set abort behaviour when global instruction selection fails to lower/select; * an instruction. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:8,abort,abort,8,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,1,['abort'],['abort']
Safety,/** Set preference of offline operations.; * Server provides more info to client from the begin on to avoid communication */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/inc/ROOT/RGeomData.hxx:102,avoid,avoid,102,geom/webviewer/inc/ROOT/RGeomData.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/inc/ROOT/RGeomData.hxx,1,['avoid'],['avoid']
Safety,"/** \class REveGeoManagerHolder; \ingroup REve; Exception safe wrapper for setting gGeoManager.; Functionality to lock-unlock via setting of a static lock in; TGeoManager should be added (new feature of TGeoManager).; */; ////////////////////////////////////////////////////////////////////////////////; /// Constructor.; /// If n_seg is specified and larger than 2, the new geo-manager's; /// NSegments is set to this value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveUtil.cxx:58,safe,safe,58,graf3d/eve7/src/REveUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveUtil.cxx,1,['safe'],['safe']
Safety,"/** \class REveManager; \ingroup REve; \ingroup webwidgets. \brief Central application manager for web-based REve. Manages elements, GUI, GL scenes and GL viewers. Following parameters can be specified in .rootrc file. WebEve.GLViewer: Three # kind of GLViewer, either Three, JSRoot or RCore; WebEve.DisableShow: 1 # do not start new web browser when REveManager::Show is called; WebEve.HTimeout: 200 # timeout in ms for elements highlight; WebEve.DblClick: Off # mouse double click handling in GL viewer: Off or Reset; WebEve.TableRowHeight: 33 # size of each row in pixels in the Table view, can be used to make design more compact; */; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveManager.cxx:403,timeout,timeout,403,graf3d/eve7/src/REveManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveManager.cxx,1,['timeout'],['timeout']
Safety,"/** \class REvePathMarkT; \ingroup REve; Special-point on track:. - kDaughter : daughter creation; fP is momentum of the daughter, it is subtracted from; momentum of the track; - kReference : position/momentum reference; - kDecay : decay point, fP not used; - kCluster2D : measurement with large error in one direction (like strip detectors):; - fP - normal to detector plane,; - fE - large error direction, must be normalized.; - Track is propagated to plane and correction in fE direction is discarded.; - kLineSegment : line segment with vertex fV and vector fE; - fV - first point of line segment; - fP - normal to detector plane,; - fE - vector from fV to the second vertex of line segment; */; ////////////////////////////////////////////////////////////////////////////////; /// Return the name of path-mark type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REvePathMark.cxx:331,detect,detectors,331,graf3d/eve7/src/REvePathMark.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REvePathMark.cxx,3,['detect'],"['detector', 'detectors']"
Safety,"/** \class ROOT::Experimental::RDisplayHistStat; \ingroup GrafROOT7; \brief Object send to client for display of RHistStat, required to avoid sending histogram to the client; \author Sergey Linev <s.linev@gsi.de>; \date 2020-04-17; \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome!; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistStatBox.hxx:136,avoid,avoid,136,hist/histdrawv7/inc/ROOT/RHistStatBox.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistStatBox.hxx,1,['avoid'],['avoid']
Safety,/** \class StatError; * \ingroup HistFactory; * Statistical error of Monte Carlo predictions.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/inc/RooStats/HistFactory/Systematics.h:81,predict,predictions,81,roofit/histfactory/inc/RooStats/HistFactory/Systematics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/inc/RooStats/HistFactory/Systematics.h,1,['predict'],['predictions']
Safety,"/** \class TContext; \ingroup Base. TDirectory::TContext keeps track and restore the current directory.; With this tool C++ exceptions will be guaranteed to properly restore the; current directory pointer. For example code like:. ~~~ {.cpp}; TDirectory *sav = gDirectory;; mydirectory->cd();; if (...) {; ....; sav->cd();; return;; } else if (...) {; ....; sav->cd();; return;; }; sav->cd;; return;; ~~~. can be replaced with the simpler and exception safe:. ~~~ {.cpp}; TDirectory::TContext context(gDirectory, mydirectory);; if (...) {; ....; return;; } else if (...) {; ....; return;; }; return;; ~~~. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TDirectory.h:452,safe,safe,452,core/base/inc/TDirectory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TDirectory.h,1,['safe'],['safe']
Safety,/** \class TEveGeoManagerHolder; \ingroup TEve; Exception safe wrapper for setting gGeoManager.; Functionality to lock-unlock via setting of a static lock in; TGeoManager should be added (new feature of TGeoManager).; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveUtil.cxx:58,safe,safe,58,graf3d/eve/src/TEveUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveUtil.cxx,1,['safe'],['safe']
Safety,/** \class TEvePadHolder; \ingroup TEve; Exception safe wrapper for setting gPad.; Optionally calls gPad->Modified()/Update() in destructor.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveUtil.cxx:51,safe,safe,51,graf3d/eve/src/TEveUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveUtil.cxx,1,['safe'],['safe']
Safety,"/** \class TEvePathMarkT; \ingroup TEve; Special-point on track:. - kDaughter : daughter creation; fP is momentum of the daughter, it is subtracted from; momentum of the track; - kReference : position/momentum reference; - kDecay : decay point, fP not used; - kCluster2D : measurement with large error in one direction (like strip detectors):; - fP - normal to detector plane,; - fE - large error direction, must be normalized.; - Track is propagated to plane and correction in fE direction is discarded.; - kLineSegment : line segment with vertex fV and vector fE; - fV - first point of line segment; - fP - normal to detector plane,; - fE - vector from fV to the second vertex of line segment; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEvePathMark.cxx:331,detect,detectors,331,graf3d/eve/src/TEvePathMark.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEvePathMark.cxx,3,['detect'],"['detector', 'detectors']"
Safety,"/** \class TGL5DDataSetEditor; \ingroup opengl; GUI editor for OpenGL 5D Painter.; Exception safety and ROOT's GUI are two; mutually exclusive things. So, only ROOT's GUI here.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGL5DDataSetEditor.cxx:93,safe,safety,93,graf3d/gl/src/TGL5DDataSetEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGL5DDataSetEditor.cxx,1,['safe'],['safety']
Safety,"/** \class TGLLogicalShape; \ingroup opengl; Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :. - Sphere A - Radius r1, center v1; - Sphere B - Radius r2, center v2; - Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes do not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:; ~~~ {.cpp}; * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod.; ~~~; Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx:811,detect,detector,811,graf3d/gl/src/TGLLogicalShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx,1,['detect'],['detector']
Safety,"/** \class TGeoHype; \ingroup Shapes_classes. A hyperboloid is represented as a solid limited by two planes; perpendicular to the Z axis (top and bottom planes) and two hyperbolic; surfaces of revolution about Z axis (inner and outer surfaces). The; class describing hyperboloids is TGeoHype has 5 input parameters:. ~~~ {.cpp}; TGeoHype(Double_t rin,Double_t stin,Double_t rout,; Double_t stout,Double_t dz);; ~~~. Begin_Macro; {; TCanvas *c = new TCanvas(""c"", ""c"",0,0,600,600);; new TGeoManager(""hype"", ""hyperboloid"");; TGeoMaterial *mat = new TGeoMaterial(""Al"", 26.98,13,2.7);; TGeoMedium *med = new TGeoMedium(""MED"",1,mat);; TGeoVolume *top = gGeoManager->MakeBox(""TOP"",med,100,100,100);; gGeoManager->SetTopVolume(top);; TGeoVolume *vol = gGeoManager->MakeHype(""HYPE"",med,10, 45 ,20,45,40);; TGeoHype *hype = (TGeoHype*)vol->GetShape();; top->AddNode(vol,1);; gGeoManager->CloseGeometry();; gGeoManager->SetNsegments(80);; top->Draw();; TView *view = gPad->GetView();; view->ShowAxis();; }; End_Macro. The hyperbolic surface equation is taken in the form:. ~~~{.cpp}; r^2 - z^2 * tan(st)^2 = rmin^2; ~~~. - `r,z:` cylindrical coordinates for a point on the surface; - `st:` stereo angle between the hyperbola asymptotic lines and Z axis; - `rmin:` minimum distance between hyperbola and Z axis (at `z=0`). The input parameters for a hyperboloid represent:. - `rin, stin:` minimum radius and stereo angle in degrees for the inner surface; - `rout, stout:` minimum radius and stereo angle in degrees for the outer surface; - `dz:` half length in Z (bounding planes positions at `+/-dz`). The following conditions are mandatory in order to avoid intersections; between the inner and outer hyperbolic surfaces in the range `+/-dz`:. - `rin < rout`; - `rout > 0`; - `rin^2 + dz^2 * tan(stin)^2 > rout^2 + dz^2 * tan(stout)^2`. Particular cases:. - `rin=0, stin0:` the inner surface is conical; - `stin=0 / stout=0:` cylindrical surface(s). */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoHype.cxx:1642,avoid,avoid,1642,geom/geom/src/TGeoHype.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoHype.cxx,1,['avoid'],['avoid']
Safety,"/** \class TGeometry; \ingroup g3d; TGeometry description. The Geometry class describes the geometry of a detector.; The current implementation supports the GEANT3 style description.; A special program provided in the ROOT utilities (toroot) can be used; to automatically translate a GEANT detector geometry into a ROOT geometry. a Geometry object is entered into the list of geometries into the; ROOT main object (see TROOT description) when the TGeometry; constructor is invoked.; Several geometries may coexist in memory.; /; A Geometry object consist of the following linked lists:. - the TMaterial list (material definition only).; - the TRotmatrix list (Rotation matrices definition only).; - the TShape list (volume definition only).; - the TNode list assembling all detector elements. Only the Build and Draw functions for a geometry are currently supported. The conversion program from Geant to Root has been added in the list; of utilities in utils directory.(see g2root); The executable module of g2root can be found in $ROOTSYS/bin/g2root. To use this conversion program, type the shell command:. ~~~ {.cpp}; g2root geant_rzfile macro_name; ~~~. for example. ~~~ {.cpp}; g2root na49.geom na49.C; ~~~. will convert the GEANT RZ file na49.geom into a ROOT macro na49.C. To generate the Geometry structure within Root, do:. ~~~ {.cpp}; Root > .x na49.C; Root > na49.Draw(); Root > wh.x3d() (this invokes the 3-d Root viewer); Root > TFile gna49(""na49.root"",""NEW"") //open a new root file; Root > na49.Write() //Write the na49 geometry structure; Root > gna49.Write() //Write all keys (in this case only one); ~~~. Note: all keys are also written on closing of the file, gna49.Close or; when the program exits, Root closes all open files correctly.; Once this file has been written, in a subsequent session, simply do:. ~~~ {.cpp}; Root > TFile gna49(""na49.root""); Root > na49.Draw(); ~~~. The figure below shows the geometry above using the x3d viewer.; This x3d viewer is invoked by selecting",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TGeometry.cxx:106,detect,detector,106,graf3d/g3d/src/TGeometry.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TGeometry.cxx,3,['detect'],['detector']
Safety,"/** \class TMaterial; \ingroup g3d; Manages a detector material. See class TGeometry; */; ////////////////////////////////////////////////////////////////////////////////; /// Material default constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TMaterial.cxx:46,detect,detector,46,graf3d/g3d/src/TMaterial.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TMaterial.cxx,1,['detect'],['detector']
Safety,"/** \class TMixture; \ingroup g3d; Manages a detector mixture. See class TGeometry.; */; ////////////////////////////////////////////////////////////////////////////////; /// Mixture default constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TMixture.cxx:45,detect,detector,45,graf3d/g3d/src/TMixture.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TMixture.cxx,1,['detect'],['detector']
Safety,/** \class TObjectRefSpy; \class TObjectSpy; \ingroup Base. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/gui/src/TObjectSpy.cxx:229,avoid,avoids,229,core/gui/src/TObjectSpy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/gui/src/TObjectSpy.cxx,2,"['avoid', 'unsafe']","['avoids', 'unsafe']"
Safety,"/** \class TPad; \ingroup gpad. The most important graphics class in the ROOT system. A Pad is contained in a Canvas. A Pad may contain other pads (unlimited pad hierarchy). A pad is a linked list of primitives of any type (graphics objects,; histograms, detectors, tracks, etc.). Adding a new element into a pad is in general performed by the Draw; member function of the object classes. It is important to realize that the pad is a linked list of references; to the original object.; For example, in case of a histogram, the histogram.Draw() operation; only stores a reference to the histogram object and not a graphical; representation of this histogram.; When the mouse is used to change (say the bin content), the bin content; of the original histogram is changed. The convention used in ROOT is that a Draw operation only adds; a reference to the object. The effective drawing is performed; when the canvas receives a signal to be painted. \image html gpad_pad1.png. This signal is generally sent when typing carriage return in the; command input or when a graphical operation has been performed on one; of the pads of this canvas.; When a Canvas/Pad is repainted, the member function Paint for all; objects in the Pad linked list is invoked. \image html gpad_pad2.png. When the mouse is moved on the Pad, The member function DistancetoPrimitive; is called for all the elements in the pad. DistancetoPrimitive returns; the distance in pixels to this object. When the object is within the distance window, the member function; ExecuteEvent is called for this object. In ExecuteEvent, move, changes can be performed on the object. For examples of DistancetoPrimitive and ExecuteEvent functions,; see classes; ~~~ {.cpp}; TLine::DistancetoPrimitive, TLine::ExecuteEvent; TBox::DistancetoPrimitive, TBox::ExecuteEvent; TH1::DistancetoPrimitive, TH1::ExecuteEvent; ~~~; A Pad supports linear and log scales coordinate systems.; The transformation coefficients are explained in TPad::ResizePad.; */; /",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx:255,detect,detectors,255,graf2d/gpad/src/TPad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx,1,['detect'],['detectors']
Safety,"/** \class TRotMatrix; \ingroup g3d; Manages a detector rotation matrix. See class TGeometry.; */; ////////////////////////////////////////////////////////////////////////////////; /// RotMatrix default constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TRotMatrix.cxx:47,detect,detector,47,graf3d/g3d/src/TRotMatrix.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TRotMatrix.cxx,1,['detect'],['detector']
Safety,"/** \class TXTRU; \ingroup g3d; A poly-extrusion. \image html g3d_xtru.png. XTRU is a poly-extrusion with fixed outline shape in x-y,; a sequence of z extents (segments) and two end faces perpendicular; to the z axis. The x-y outline is defined by an ordered list of; points; the overall scale of the outline scales linearly between; z points and the center can have an x-y offset specified; at each segment end. A TXTRU has the following parameters:. - name: name of the shape; - title: shape's title; - material: (see TMaterial); - nxy: number of x-y vertex points constituting the outline --; this number should be at least 3; - nz: number of planes perpendicular to the z axis where; the scaling dimension of the section is given --; this number should be at least 2; - Xvtx: array [nxy] of X coordinates of vertices; - Yvtx: array [nxy] of Y coordinates of vertices; - z: array [nz] of z plane positions; - scale: array [nz] of scale factors; - x0: array [nz] of x offsets; - y0: array [nz] of y offsets. All XTRU shapes are correctly rendered in wire mode but can encounter; difficulty when rendered as a solid with hidden surfaces. These; exceptions occur if the outline shape is not a convex polygon.; Both the X3D and OpenGL renderers expect polygons to be convex.; The OpenGL spec specifies that points defining a polygon using the; GL_POLYGON primitive may be rendered as the convex hull of that set. Solid rendering under X3D can also give unexpected artifacts if; the combination of x-y-z offsets and scales for the segments are; chosen in such a manner that they represent a concave shape when; sliced along a plane parallel to the z axis. Choosing sets of point that represent a malformed polygon is; not supported, but testing for such a condition is not implemented; and thus it is left to the user to avoid this mistake. \image html g3d_polytype.png; */; ////////////////////////////////////////////////////////////////////////////////; /// TXTRU shape - default constructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TXTRU.cxx:1819,avoid,avoid,1819,graf3d/g3d/src/TXTRU.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TXTRU.cxx,1,['avoid'],['avoid']
Safety,"/** \class ZeroMQPoller; * \brief Wrapper class for polling ZeroMQ sockets; *; * This class simplifies calls to poll or ppoll ZeroMQ sockets. It stores the; * list of sockets to be polled, which means they don't have to be separately; * carried around by the user. It also parses output and returns an easily; * digestible vector of events.; */; /**; * \brief Poll the sockets; *; * \param[in] timeo Timeout in milliseconds. 0 means return immediately. -1 means wait for an event indefinitely.; * \return A vector of pairs of index and flags; index is the index of the registered fd or socket and flags are 0 (no; * events), ZMQ_POLLIN or ZMQ_POLLOUT.; *; * \note This function can throw (from inside zmq::poll), so wrap in try-catch!; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/src/ZeroMQPoller.cpp:400,Timeout,Timeout,400,roofit/roofitZMQ/src/ZeroMQPoller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/src/ZeroMQPoller.cpp,1,['Timeout'],['Timeout']
Safety,"/** \defgroup CINDEX libclang: C Interface to Clang; *; * The C Interface to Clang provides a relatively small API that exposes; * facilities for parsing source code into an abstract syntax tree (AST),; * loading already-parsed ASTs, traversing the AST, associating; * physical source locations with elements within the AST, and other; * facilities that support Clang-based development tools.; *; * This C interface to Clang will never provide all of the information; * representation stored in Clang's C++ AST, nor should it: the intent is to; * maintain an API that is relatively stable from one release to the next,; * providing only the basic functionality needed to support development tools.; *; * To avoid namespace pollution, data types are prefixed with ""CX"" and; * functions are prefixed with ""clang_"".; *; * @{; */; /**; * An ""index"" that consists of a set of translation units that would; * typically be linked together into an executable or library.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:707,avoid,avoid,707,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,1,['avoid'],['avoid']
Safety,"/** constructors from a TCpuBuffer and a shape */; //unsafe method for backwards compatibility, const not promised. A view.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuTensor.h:53,unsafe,unsafe,53,tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuTensor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuTensor.h,1,['unsafe'],['unsafe']
Safety,"/** constructors from a TCpuMatrix. Memory layout is forced to be same as matrix (i.e. columnlayout) */; //unsafe method for backwards compatibility, const not promised. A view of underlying data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuTensor.h:107,unsafe,unsafe,107,tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuTensor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuTensor.h,1,['unsafe'],['unsafe']
Safety,"/**************** RGB -> YCbCr conversion: most common case **************/; /*; * YCbCr is defined per CCIR 601-1, except that Cb and Cr are; * normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.; * The conversion equations to be implemented are therefore; *	Y = 0.29900 * R + 0.58700 * G + 0.11400 * B; *	Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B + CENTERJSAMPLE; *	Cr = 0.50000 * R - 0.41869 * G - 0.08131 * B + CENTERJSAMPLE; * (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.); * Note: older versions of the IJG code used a zero offset of MAXJSAMPLE/2,; * rather than CENTERJSAMPLE, for Cb and Cr. This gave equal positive and; * negative swings for Cb/Cr, but meant that grayscale values (Cb=Cr=0); * were not represented exactly. Now we sacrifice exact representation of; * maximum red and maximum blue in order to get exact grayscales.; *; * To avoid floating-point arithmetic, we represent the fractional constants; * as integers scaled up by 2^16 (about 4 digits precision); we have to divide; * the products by 2^16, with appropriate rounding, to get the correct answer.; *; * For even more speed, we avoid doing any multiplications in the inner loop; * by precalculating the constants times R,G,B for all possible values.; * For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);; * for 12-bit samples it is still acceptable. It's not very reasonable for; * 16-bit samples, but if you want lossless storage you shouldn't be changing; * colorspace anyway.; * The CENTERJSAMPLE offsets and the rounding fudge-factor of 0.5 are included; * in the tables to save adding them separately in the inner loop.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jccolor.c:889,avoid,avoid,889,graf2d/asimage/src/libAfterImage/libjpeg/jccolor.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jccolor.c,2,['avoid'],['avoid']
Safety,"/**************** YCbCr -> RGB conversion: most common case **************/; /*; * YCbCr is defined per CCIR 601-1, except that Cb and Cr are; * normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.; * The conversion equations to be implemented are therefore; *	R = Y + 1.40200 * Cr; *	G = Y - 0.34414 * Cb - 0.71414 * Cr; *	B = Y + 1.77200 * Cb; * where Cb and Cr represent the incoming values less CENTERJSAMPLE.; * (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.); *; * To avoid floating-point arithmetic, we represent the fractional constants; * as integers scaled up by 2^16 (about 4 digits precision); we have to divide; * the products by 2^16, with appropriate rounding, to get the correct answer.; * Notice that Y, being an integral input, does not contribute any fraction; * so it need not participate in the rounding.; *; * For even more speed, we avoid doing any multiplications in the inner loop; * by precalculating the constants times Cb and Cr for all possible values.; * For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);; * for 12-bit samples it is still acceptable. It's not very reasonable for; * 16-bit samples, but if you want lossless storage you shouldn't be changing; * colorspace anyway.; * The Cr=>R and Cb=>B values can be rounded to integers in advance; the; * values for the G calculation are left scaled up, since we must add them; * together before rounding.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdcolor.c:507,avoid,avoid,507,graf2d/asimage/src/libAfterImage/libjpeg/jdcolor.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdcolor.c,2,['avoid'],['avoid']
Safety,/******************************************************************************/; // Exception-safe global variable holders; /******************************************************************************/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveUtil.h:95,safe,safe,95,graf3d/eve/inc/TEveUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveUtil.h,1,['safe'],['safe']
Safety,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooDirItem.cxx; \class RooDirItem; \ingroup Roofitcore. Utility base class for \ref Roofitmain objects that are to be attached; to ROOT directories. Concrete classes inherit the appendToDir and removeToDir; methods that can be used to safely attach and detach one self from a TDirectory.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDirItem.cxx:941,safe,safely,941,roofit/roofitcore/src/RooDirItem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDirItem.cxx,1,['safe'],['safely']
Safety,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooGenContext.cxx; \class RooGenContext; \ingroup Roofitcore. Implements a universal generator context for all; RooAbsPdf classes that do not have or need a specialized generator; context. This generator context queries the input p.d.f which observables; it can generate internally and delegates generation of those observables; to the p.d.f if it deems that safe. The other observables are generated; use a RooAcceptReject sampling technique.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenContext.cxx:1065,safe,safe,1065,roofit/roofitcore/src/RooGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenContext.cxx,1,['safe'],['safe']
Safety,"/*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooNormSetCache.cxx; \class RooNormSetCache; \ingroup Roofitcore. Class RooNormSet cache manage the bookkeeping of multiple instances; of sets of integration and normalization observables that effectively; have the same definition. In complex function expression many; RooArgSets with the same contents may be passed to an object that; caches intermediate results dependent on the normalization/integration set; To avoid unnecessary cache faulting, This class tracks all instances; with the same contents and reports to the owner if the present nset/iset; is truly different from the current reference. Class RooNormSet only; evaluates each RooArgSet pointer once, it therefore assumes that; RooArgSets with normalization and/or integration sets are not changes; during their lifetime.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNormSetCache.cxx:1121,avoid,avoid,1121,roofit/roofitcore/src/RooNormSetCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNormSetCache.cxx,1,['avoid'],['avoid']
Safety,"/*************************************************************************; * *; * Old RConfig.h forwarding to ROOT/RConfig.hxx *; * *; * Please #include ROOT/RConfig.hxx instead, e.g. to avoid clashes with *; * R's Rconfig.h *; * *; *************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/RConfig.h:188,avoid,avoid,188,core/base/inc/RConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/RConfig.h,1,['avoid'],['avoid']
Safety,"/*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; // ----------------------------------------------------------------------; // HEP coherent system of Units; //; // This file has been provided to CLHEP by Geant4 (simulation toolkit for HEP).; // Adapted to TGeo units base by Marko Petric; //; // The basic units are :; // millimeter (millimeter); // nanosecond (nanosecond); // Mega electron Volt (MeV); // positron charge (eplus); // degree Kelvin (kelvin); // the amount of substance (mole); // luminous intensity (candela); // radian (radian); // steradian (steradian); //; // Below is a non exhaustive list of derived and pratical units; // (i.e. mostly the SI units).; // You can add your own units.; //; // The SI numerical value of the positron charge is defined here,; // as it is needed for conversion factor : positron charge = e_SI (coulomb); //; // The others physical constants are defined in the header file :; // PhysicalConstants.h; //; // Authors: M.Maire, S.Giani; //; // History:; //; // 06.02.96 Created.; // 28.03.96 Added miscellaneous constants.; // 05.12.97 E.Tcherniaev: Redefined pascal (to avoid warnings on WinNT); // 20.05.98 names: meter, second, gram, radian, degree; // (from Brian.Lasiuk@yale.edu (STAR)). Added luminous units.; // 05.08.98 angstrom, picobarn, microsecond, picosecond, petaelectronvolt; // 01.03.01 parsec; // 31.01.06 kilogray, milligray, microgray; // 29.04.08 use PDG 2006 value of e_SI; // 03.11.08 use PDG 2008 value of e_SI; // 19.08.15 added liter and its sub units (mma); // 12.01.16 added symbols for microsecond (us) and picosecond (ps) (mma); // 02.10.17 addopted units from CLHEP 2.3.4.3 and converted to TGeo unit base",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeant4SystemOfUnits.h:1426,avoid,avoid,1426,geom/geom/inc/TGeant4SystemOfUnits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeant4SystemOfUnits.h,2,['avoid'],['avoid']
Safety,"/********************************************************************; * Advanced streaming functions; * Warning : most of these functions are now redundant with the Advanced API.; * Once Advanced API reaches ""stable"" status,; * redundant functions will be deprecated, and then at some point removed.; ********************************************************************/; /*===== Advanced Streaming compression functions =====*/; /*! ZSTD_initCStream_srcSize() :; * This function is deprecated, and equivalent to:; * ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);; * ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any); * ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);; * ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);; *; * pledgedSrcSize must be correct. If it is not known at init time, use; * ZSTD_CONTENTSIZE_UNKNOWN. Note that, for compatibility with older programs,; * ""0"" also disables frame content size field. It may be enabled in the future.; * Note : this prototype will be marked as deprecated and generate compilation warnings on reaching v1.5.x; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:147,redund,redundant,147,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,2,['redund'],['redundant']
Safety,"/***************************************; * Advanced compression API; ***************************************/; /* API design :; * Parameters are pushed one by one into an existing context,; * using ZSTD_CCtx_set*() functions.; * Pushed parameters are sticky : they are valid for next compressed frame, and any subsequent frame.; * ""sticky"" parameters are applicable to `ZSTD_compress2()` and `ZSTD_compressStream*()` !; * __They do not apply to ""simple"" one-shot variants such as ZSTD_compressCCtx()__ .; *; * It's possible to reset all parameters to ""default"" using ZSTD_CCtx_reset().; *; * This API supercedes all other ""advanced"" API entry points in the experimental section.; * In the future, we expect to remove from experimental API entry points which are redundant with this API.; */; /* Compression strategies, listed from fastest to strongest */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:763,redund,redundant,763,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['redund'],['redundant']
Safety,"/********/; /****d* libAfterImage/asimage/tint; * FUNCTION; * We use 32 bit ARGB values to define how tinting should be done.; * The formula for tinting particular channel data goes like that:; * tinted_data = (image_data * tint)/128; * So if tint channel value is greater then 127 - same channel will be; * brighter in destination image; if it is lower then 127 - same channel; * will be darker in destination image. Tint channel value of 127; * ( or 0x7F hex ) does not change anything.; * Alpha channel is tinted as well, allowing for creation of; * semitransparent images. Calculations are performed in 24.8 format -; * with 8 bit precision. Result is saturated to avoid overflow, and; * precision is carried over to next pixel ( error diffusion ), when con; * verting 24.8 to 8 bit format.; * NAME; * TINT_NONE special value that disables tinting; * NAME; * TINT_LEAVE_SAME also disables tinting.; * SOURCE; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h:669,avoid,avoid,669,graf2d/asimage/src/libAfterImage/asimage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asimage.h,1,['avoid'],['avoid']
Safety,"/****f* libAfterImage/create_visual_window(); * NAME; * create_visual_window(); * SYNOPSIS; * Window create_visual_window( ASVisual *asv, Window parent,; * int x, int y,; * unsigned int width, unsigned int height,; * unsigned int border_width,; * unsigned int wclass,; * unsigned long mask,; * XSetWindowAttributes *attributes );; * INPUTS; * asv - pointer to the valid ASVisual structure.; * parent - Window ID of the parent the window.; * x, y - initial position of the new window.; * width, height - initial size of the new window.; * border_width - initial border width of the new window.; * wclass - Window class - InputOnly or InputOutput.; * mask - defines what attributes are set.; * attributes - different window attributes.; * RETURN VALUE; * ID of the newly created window on success. None on failure.; * DESCRIPTION; * create_visual_window() will do sanity checks on passed parameters,; * it will then add mandatory attributes if needed, and attempt to; * create window for the specified ASVisual.; *********/; /****f* libAfterImage/create_visual_gc(); * NAME; * create_visual_gc(); * SYNOPSIS; * GC create_visual_gc( ASVisual *asv, Window root,; * unsigned long mask, XGCValues *gcvalues );; * INPUTS; * asv - pointer to the valid ASVisual structure.; * root - Window ID of the root window of destination screen; * mask, gcvalues - values for creation of new GC - see XCreateGC() for; * details.; * RETURN VALUE; * New GC created for regular window on success. NULL on failure.; * DESCRIPTION; * create_visual_gc() will create temporary window for the ASVisual; * specific depth and Visual and it will then create GC for such window.; * Obtained GC should be good to be used for manipulation of windows and; * Pixmaps created for the same ASVisual.; *********/; /****f* libAfterImage/create_visual_pixmap(); * NAME; * create_visual_pixmap(); * SYNOPSIS; * Pixmap create_visual_pixmap( ASVisual *asv, Window root,; * unsigned int width, unsigned int height,; * unsigned int depth );; * INP",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.h:862,sanity check,sanity checks,862,graf2d/asimage/src/libAfterImage/asvisual.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asvisual.h,1,['sanity check'],['sanity checks']
Safety,"/****h* libAfterImage/asfont.h; * NAME; * asfont; * DESCRIPTION; * Text drawing functionality.; * Text is drawn as an ASImage with only alpha channel. Since alpha; * channel is 8 bit widths that allows for 256 shades to be used in; * rendered glyphs. That in turn allows for smoothing and antialiasing; * of the drawn text. Such an approcah allows for easy manipulation of; * the drawn text, such as changing color, making it transparent,; * texturizing, rotation, etc.; *; * libAfterImage supports two types of fonts :; * Fonts that could be rendered using standard Xlib functionality, and; * fonts rendered by FreeType 2 library. That may include TrueType; * fonts. When fonts are obtained via Xlib special processing is; * performed in order to smooth its shape and leverage 256 shades; * palette available.; *; * Any font being used is has to be opened first. At that time its; * properties are analysed and glyphs are cached in clients memory.; * Special RLE compression method is used for font glyphs, significantly; * reducing memory utilization without any effect on performance.; *; * Font management and drawing functionality has been designed with; * internatiolization in mind, althou support for locales is not; * complete yet.; * SEE ALSO; * Structures :; * ASFontManager; * ASFont; * ASGlyph; * ASGlyphRange; *; * Functions :; * create_font_manager(), destroy_font_manager(),; * open_freetype_font(), open_X11_font(), get_asfont(),; * destroy_font(), print_asfont(), print_asglyph(),; * draw_text(),; * get_asfont_glyph_spacing(), set_asfont_glyph_spacing(); *; * Other libAfterImage modules :; * ascmap.h asfont.h asimage.h asvisual.h blender.h export.h; * import.h transform.h ximage.h; * AUTHOR; * Sasha Vasko <sasha at aftercode dot net>; ******************/; /****d* libAfterImage/MAX_GLYPHS_PER_FONT; * NAME; * MAX_GLYPHS_PER_FONT - Max value of glyphs per font allowed. ; * We need that so we can detect and avoid broken fonts somehow.; * SOURCE; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h:1919,detect,detect,1919,graf2d/asimage/src/libAfterImage/asfont.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/asfont.h,2,"['avoid', 'detect']","['avoid', 'detect']"
Safety,"/**. Class implementing the standard chi square function, which; is the sum of the squares of the figures-of-merit calculated for each measurement; point, the individual figures-of-merit being: (the Value predicted by the; model-measured Value)/standard deviation. @author Andras Zsenei and Lorenzo Moneta, Creation date: 31 Aug 2004. @see FumiliChi2FCN. @ingroup Minuit. \todo nice formula for the documentation... */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FumiliStandardChi2FCN.h:205,predict,predicted,205,math/minuit2/inc/Minuit2/FumiliStandardChi2FCN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FumiliStandardChi2FCN.h,1,['predict'],['predicted']
Safety,"/**. Evaluates the model function for the different measurement points and; the Parameter values supplied, calculates a figure-of-merit for each; measurement and returns a vector containing the result of this; evaluation. The figure-of-merit is (Value predicted by the model; function-measured Value)/standard deviation. @param par vector of Parameter values to feed to the model function. @return A vector containing the figures-of-merit for the model function evaluated; for each set of measurements. \todo What to do when the variances are 0???!! (right now just pushes back 0...). */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FumiliStandardChi2FCN.h:252,predict,predicted,252,math/minuit2/inc/Minuit2/FumiliStandardChi2FCN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FumiliStandardChi2FCN.h,1,['predict'],['predicted']
Safety,"/**. Extension of the FCNBase for the Fumili method. Fumili applies only to; minimization problems used for fitting. The method is based on a; linearization of the model function negleting second derivatives.; User needs to provide the model function. The figure-of-merit describing; the difference between the model function and the actual measurements in; the case of chi-square is the sum of the squares of the figures-of-merit; calculated for each measurement point, which is implemented by the; operator() member function. The user still has to implement the calculation; of the individual figures-of-merit (which in the majority of the cases; will be the (measured Value - the Value predicted by the model)/standard deviation; implemented by the FumiliStandardChi2FCN;; however this form can become more complicated (see for an example Numerical Recipes'; section on ""Straight-Line Data with Errors in Both Coordinates"")). @author Andras Zsenei and Lorenzo Moneta, Creation date: 24 Aug 2004. @see <A HREF=""http://www.cern.ch/winkler/minuit/tutorial/mntutorial.pdf"">MINUIT Tutorial</A> on function minimization,; section 5. @see FumiliStandardChi2FCN. @ingroup Minuit. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FumiliChi2FCN.h:689,predict,predicted,689,math/minuit2/inc/Minuit2/FumiliChi2FCN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/FumiliChi2FCN.h,1,['predict'],['predicted']
Safety,"/**; 	 * Changes this controller into a dropdown of options.; 	 *; 	 * Calling this method on an option controller will simply update the options. However, if this; 	 * controller was not already an option controller, old references to this controller are; 	 * destroyed, and a new controller is added to the end of the GUI.; 	 * @example; 	 * // safe usage; 	 *; 	 * gui.add( obj, 'prop1' ).options( [ 'a', 'b', 'c' ] );; 	 * gui.add( obj, 'prop2' ).options( { Big: 10, Small: 1 } );; 	 * gui.add( obj, 'prop3' );; 	 *; 	 * // danger; 	 *; 	 * const ctrl1 = gui.add( obj, 'prop1' );; 	 * gui.add( obj, 'prop2' );; 	 *; 	 * // calling options out of order adds a new controller to the end...; 	 * const ctrl2 = ctrl1.options( [ 'a', 'b', 'c' ] );; 	 *; 	 * // ...and ctrl1 now references a controller that doesn't exist; 	 * assert( ctrl2 !== ctrl1 ); 	 * @param {object|Array} options; 	 * @returns {Controller}; 	 */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:347,safe,safe,347,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['safe'],['safe']
Safety,/**; * @addtogroup LLVMCCore; *; * @{; */; /**; * This function permanently loads the dynamic library at the given path.; * It is safe to call this function multiple times for the same library.; *; * @see sys::DynamicLibrary::LoadLibraryPermanently(); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h:130,safe,safe,130,interpreter/llvm-project/llvm/include/llvm-c/Support.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h,1,['safe'],['safe']
Safety,/**; * @brief Called by Parser::workhorse() for each Option that has been successfully; * parsed (including unknown; * options if they have a Descriptor whose Descriptor::check_arg does not return; * @ref ARG_ILLEGAL.; *; * Returns @c false iff a fatal error has occured and the parse should be aborted.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h:295,abort,aborted,295,core/dictgen/res/OptionParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h,1,['abort'],['aborted']
Safety,"/**; * @brief Export an object from the workspace to a JSONNode.; *; * This function exports an object, represented by the provided RooAbsArg, from the workspace to a JSONNode.; * The object's information is added to the JSONNode as key-value pairs.; *; * @param func The RooAbsArg representing the object to be exported.; * @param exportedObjectNames A set of strings containing names of previously exported objects to avoid duplicates.; * This set is updated with the name of the newly exported object.; * @return void; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/RooJSONFactoryWSTool.cxx:420,avoid,avoid,420,roofit/hs3/src/RooJSONFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/RooJSONFactoryWSTool.cxx,1,['avoid'],['avoid']
Safety,/**; * @brief Perform prediction using int as spectator variable; * @param method Path to a method weight file.; * This tests check if issue #9115 is fixed since it uses an integer; * type in TMVA::Reader; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/crossvalidation/TestCrossValidationIntVar.cxx:22,predict,prediction,22,tmva/tmva/test/crossvalidation/TestCrossValidationIntVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/crossvalidation/TestCrossValidationIntVar.cxx,1,['predict'],['prediction']
Safety,"/**; * @brief Returns @c true if an unrecoverable error occurred while parsing options.; *; * An illegal argument to an option (i.e. CheckArg returns @ref ARG_ILLEGAL) is an; * unrecoverable error that aborts the parse. Unknown options are only an error if; * their CheckArg function returns @ref ARG_ILLEGAL. Otherwise they are collected.; * In that case if you want to exit the program if either an illegal argument; * or an unknown option has been passed, use code like this; *; * @code; * if (parser.error() || options[UNKNOWN]); * exit(1);; * @endcode; *; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h:202,abort,aborts,202,core/dictgen/res/OptionParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h,1,['abort'],['aborts']
Safety,"/**; * @brief The long option name (without the leading @c -- ).; *; * If this Descriptor should not have a long option name, use the empty; * string """". NULL is not permitted here!; *; * While @ref shortopt allows multiple short option characters, each; * Descriptor can have only a single long option name. If you have multiple; * long option names referring to the same option use separate Descriptors; * that have the same @ref index and @ref type. You may repeat; * short option characters in such an alias Descriptor but there's no need to.; *; * @par Dummy Descriptors:; * You can use dummy Descriptors with an; * empty string for both @ref shortopt and @ref longopt to add text to; * the usage that is not related to a specific option. See @ref help.; * The first dummy Descriptor will be used for unknown options (see below).; *; * @par Unknown Option Descriptor:; * The first dummy Descriptor in the list of Descriptors,; * whose @ref shortopt and @ref longopt are both the empty string, will be used; * as the Descriptor for unknown options. An unknown option is a string in; * the argument vector that is not a lone minus @c '-' but starts with a minus; * character and does not match any Descriptor's @ref shortopt or @ref longopt. @n; * Note that the dummy descriptor's @ref check_arg function @e will be called and; * its return value will be evaluated as usual. I.e. if it returns @ref ARG_ILLEGAL; * the parsing will be aborted with <code>Parser::error()==true</code>. @n; * if @c check_arg does not return @ref ARG_ILLEGAL the descriptor's; * @ref index @e will be used to pick the linked list into which; * to put the unknown option. @n; * If there is no dummy descriptor, unknown options will be dropped silently.; *; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h:1437,abort,aborted,1437,core/dictgen/res/OptionParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h,1,['abort'],['aborted']
Safety,"/**; * @defgroup LLVMC LLVM-C: C interface to LLVM; *; * This module exposes parts of the LLVM library as a C API.; *; * @{; */; /**; * @defgroup LLVMCTransforms Transforms; */; /**; * @defgroup LLVMCCore Core; *; * This modules provide an interface to libLLVMCore, which implements; * the LLVM intermediate representation as well as other related types; * and utilities.; *; * Many exotic languages can interoperate with C code but have a harder time; * with C++ due to name mangling. So in addition to C, this interface enables; * tools written in such languages.; *; * @{; */; /**; * @defgroup LLVMCCoreTypes Types and Enumerations; *; * @{; */; /// External users depend on the following values being stable. It is not safe; /// to reorder them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:723,safe,safe,723,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['safe'],['safe']
Safety,"/**; * @defgroup LLVMCCoreContext Contexts; *; * Contexts are execution states for the core LLVM IR system.; *; * Most types are tied to a context instance. Multiple contexts can; * exist simultaneously. A single context is not thread safe. However,; * different contexts can execute on different threads simultaneously.; *; * @{; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:235,safe,safe,235,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['safe'],['safe']
Safety,"/**; * @} // endgoup LLVMCTLTO; * @defgroup LLVMCTLTO_CACHING ThinLTO Cache Control; * @ingroup LLVMCTLTO; *; * These entry points control the ThinLTO cache. The cache is intended to; * support incremental builds, and thus needs to be persistent across builds.; * The client enables the cache by supplying a path to an existing directory.; * The code generator will use this to store objects files that may be reused; * during a subsequent build.; * To avoid filling the disk space, a few knobs are provided:; * - The pruning interval limits the frequency at which the garbage collector; * will try to scan the cache directory to prune expired entries.; * Setting to a negative number disables the pruning.; * - The pruning expiration time indicates to the garbage collector how old an; * entry needs to be to be removed.; * - Finally, the garbage collector can be instructed to prune the cache until; * the occupied space goes below a threshold.; * @{; */; /**; * Sets the path to a directory to use as a cache storage for incremental build.; * Setting this activates caching.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:453,avoid,avoid,453,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['avoid'],['avoid']
Safety,/**; * @}; */; /**; * @defgroup LLVMCCoreThreading Threading; *; * Handle the structures needed to make LLVM safe for multithreading.; *; * @{; */; /** Deprecated: Multi-threading can only be enabled/disabled with the compile; time define LLVM_ENABLE_THREADS. This function always returns; LLVMIsMultithreaded(). */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:109,safe,safe,109,interpreter/llvm-project/llvm/include/llvm-c/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h,1,['safe'],['safe']
Safety,/**; * COVER_best_t is used for two purposes:; * 1. Synchronizing threads.; * 2. Saving the best parameters and dictionary.; *; * All of the methods except COVER_best_init() are thread safe if zstd is; * compiled with multithreaded support.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/cover.h:185,safe,safe,185,builtins/zstd/dictBuilder/cover.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/cover.h,1,['safe'],['safe']
Safety,"/**; * Called periodically to check whether indexing should be aborted.; * Should return 0 to continue, and non-zero to abort.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:63,abort,aborted,63,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,2,['abort'],"['abort', 'aborted']"
Safety,"/**; * Centripetal CatmullRom Curve - which is useful for avoiding; * cusps and self-intersections in non-uniform catmull rom curves.; * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf; *; * curve.type accepts centripetal(default), chordal and catmullrom; * curve.tension is used for catmullrom which defaults to 0.5; */; /*; Based on an optimized c++ solution in; - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/; - http://ideone.com/NoEbVM. This CubicPoly class could be used for reusing some variables and calculations,; but for three.js curve use, it could be possible inlined and flatten into a single function call; which can be placed in CurveUtils.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:58,avoid,avoiding,58,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoiding']
Safety,/**; * Create a JITTargetMachineBuilder by detecting the host.; *; * On success the client owns the resulting JITTargetMachineBuilder. It must be; * passed to a consuming operation (e.g.; * LLVMOrcLLJITBuilderSetJITTargetMachineBuilder) or disposed of by calling; * LLVMOrcDisposeJITTargetMachineBuilder.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:43,detect,detecting,43,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h,1,['detect'],['detecting']
Safety,/**; * Creates a remark parser that can be used to parse the buffer located in \p; * Buf of size \p Size bytes.; *; * \p Buf cannot be `NULL`.; *; * This function should be paired with LLVMRemarkParserDispose() to avoid; * leaking resources.; *; * \since REMARKS_API_VERSION=0; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:214,avoid,avoid,214,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,1,['avoid'],['avoid']
Safety,/**; * Creates a remark parser that can be used to parse the buffer located in \p; * Buf of size \p Size bytes.; *; * \p Buf cannot be `NULL`.; *; * This function should be paired with LLVMRemarkParserDispose() to avoid; * leaking resources.; *; * \since REMARKS_API_VERSION=1; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:214,avoid,avoid,214,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,1,['avoid'],['avoid']
Safety,"/**; * Enable/disable crash recovery.; *; * \param isEnabled Flag to indicate if crash recovery is enabled. A non-zero; * value enables crash recovery, while 0 disables it.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:28,recover,recovery,28,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,3,['recover'],['recovery']
Safety,/**; * Ensure that triangulation conforms to constraints (fixed edges); * @note For each fixed edge that is not present in the triangulation its; * midpoint is recursively added until the original edge is represented by a; * sequence of its pieces. <b> New vertices are inserted.</b>; * @note If some edge appears more than once the input this; * means that multiple boundaries overlap at the edge and impacts how hole; * detection algorithm of Triangulation::eraseOuterTrianglesAndHoles works.; * <b>Make sure there are no erroneous duplicates.</b>; * @tparam TEdgeIter iterator that dereferences to custom edge type; * @tparam TGetEdgeVertexStart function object getting start vertex index; * from an edge.; * Getter signature: const TEdgeIter::value_type& -> CDT::VertInd; * @tparam TGetEdgeVertexEnd function object getting end vertex index from; * an edge. Getter signature: const TEdgeIter::value_type& -> CDT::VertInd; * @param first beginning of the range of edges to add; * @param last end of the range of edges to add; * @param getStart getter of edge start vertex index; * @param getEnd getter of edge end vertex index; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:422,detect,detection,422,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,1,['detect'],['detection']
Safety,/**; * Ensure that triangulation conforms to constraints (fixed edges); * @note For each fixed edge that is not present in the triangulation its; * midpoint is recursively added until the original edge is represented by a; * sequence of its pieces. <b> New vertices are inserted.</b>; * @note If some edge appears more than once the input this; * means that multiple boundaries overlap at the edge and impacts how hole; * detection algorithm of Triangulation::eraseOuterTrianglesAndHoles works.; * <b>Make sure there are no erroneous duplicates.</b>; * @tparam edges edges to conform to; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:422,detect,detection,422,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,1,['detect'],['detection']
Safety,/**; * Erase triangles outside of constrained boundary and auto-detected holes; *; * @note detecting holes relies on layer peeling based on layer depth; * @note supports overlapping or touching boundaries; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:64,detect,detected,64,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,2,['detect'],"['detected', 'detecting']"
Safety,/**; * Error thrown when duplicate vertex is detected during vertex insertion; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:45,detect,detected,45,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,1,['detect'],['detected']
Safety,"/**; * Error thrown when intersecting constraint edges are detected, but; * triangulation is not configured to attempt to resolve them; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:59,detect,detected,59,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,1,['detect'],['detected']
Safety,"/**; * Index initialization options.; *; * 0 is the default value of each member of this struct except for Size.; * Initialize the struct in one of the following three ways to avoid adapting; * code each time a new member is added to it:; * \code; * CXIndexOptions Opts;; * memset(&Opts, 0, sizeof(Opts));; * Opts.Size = sizeof(CXIndexOptions);; * \endcode; * or explicitly initialize the first data member and zero-initialize the rest:; * \code; * CXIndexOptions Opts = { sizeof(CXIndexOptions) };; * \endcode; * or to prevent the -Wmissing-field-initializers warning for the above version:; * \code; * CXIndexOptions Opts{};; * Opts.Size = sizeof(CXIndexOptions);; * \endcode; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:176,avoid,avoid,176,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,1,['avoid'],['avoid']
Safety,"/**; * Index the given source file and the translation unit corresponding; * to that file via callbacks implemented through #IndexerCallbacks.; *; * \param client_data pointer data supplied by the client, which will; * be passed to the invoked callbacks.; *; * \param index_callbacks Pointer to indexing callbacks that the client; * implements.; *; * \param index_callbacks_size Size of #IndexerCallbacks structure that gets; * passed in index_callbacks.; *; * \param index_options A bitmask of options that affects how indexing is; * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.; *; * \param[out] out_TU pointer to store a \c CXTranslationUnit that can be; * reused after indexing is finished. Set to \c NULL if you do not require it.; *; * \returns 0 on success or if there were errors from which the compiler could; * recover. If there is a failure from which there is no recovery, returns; * a non-zero \c CXErrorCode.; *; * The rest of the parameters are the same as #clang_parseTranslationUnit.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:844,recover,recover,844,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,2,['recover'],"['recover', 'recovery']"
Safety,"/**; * Index the given translation unit via callbacks implemented through; * #IndexerCallbacks.; *; * The order of callback invocations is not guaranteed to be the same as; * when indexing a source file. The high level order will be:; *; * -Preprocessor callbacks invocations; * -Declaration/reference callbacks invocations; * -Diagnostic callback invocations; *; * The parameters are the same as #clang_indexSourceFile.; *; * \returns If there is a failure from which there is no recovery, returns; * non-zero, otherwise returns 0.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:481,recover,recovery,481,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,1,['recover'],['recovery']
Safety,"/**; * Insert constraint edges into triangulation; * @note Each fixed edge is inserted by deleting the triangles it crosses,; * followed by the triangulation of the polygons on each side of the edge.; * <b> No new vertices are inserted.</b>; * @note If some edge appears more than once in the input this means that; * multiple boundaries overlap at the edge and impacts how hole detection; * algorithm of Triangulation::eraseOuterTrianglesAndHoles works.; * <b>Make sure there are no erroneous duplicates.</b>; * @tparam edges constraint edges; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:379,detect,detection,379,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,1,['detect'],['detection']
Safety,"/**; * Insert constraints (custom-type fixed edges) into triangulation; * @note Each fixed edge is inserted by deleting the triangles it crosses,; * followed by the triangulation of the polygons on each side of the edge.; * <b> No new vertices are inserted.</b>; * @note If some edge appears more than once in the input this means that; * multiple boundaries overlap at the edge and impacts how hole detection; * algorithm of Triangulation::eraseOuterTrianglesAndHoles works.; * <b>Make sure there are no erroneous duplicates.</b>; * @tparam TEdgeIter iterator that dereferences to custom edge type; * @tparam TGetEdgeVertexStart function object getting start vertex index; * from an edge.; * Getter signature: const TEdgeIter::value_type& -> CDT::VertInd; * @tparam TGetEdgeVertexEnd function object getting end vertex index from; * an edge. Getter signature: const TEdgeIter::value_type& -> CDT::VertInd; * @param first beginning of the range of edges to add; * @param last end of the range of edges to add; * @param getStart getter of edge start vertex index; * @param getEnd getter of edge end vertex index; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:400,detect,detection,400,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,1,['detect'],['detection']
Safety,"/**; * Install a fatal error handler. By default, if LLVM detects a fatal error, it; * will call exit(1). This may not be appropriate in many contexts. For example,; * doing exit(1) will bypass many crash reporting/tracing system tools. This; * function allows you to install a callback that will be invoked prior to the; * call to exit(1).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:58,detect,detects,58,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,1,['detect'],['detects']
Safety,/**; * Installs error handler that prints error message to stderr and calls abort().; * Replaces currently installed error handler (if any).; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h:76,abort,abort,76,interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h,1,['abort'],['abort']
Safety,"/**; * Loads an object file in its own context.; *; * Loads an object file in its own LLVMContext. This function call is; * thread-safe. However, modules created this way should not be merged into an; * lto_code_gen_t using \a lto_codegen_add_module().; *; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=11; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:131,safe,safe,131,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['safe'],['safe']
Safety,/**; * Loads an object file in the codegen context.; *; * Loads an object file into the same context as \c cg. The module is safe to; * add using \a lto_codegen_add_module().; *; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=11; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:125,safe,safe,125,interpreter/llvm-project/llvm/include/llvm-c/lto.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h,1,['safe'],['safe']
Safety,/**; * Macro for inlining non-template functions when in header-only mode to; * avoid multiple declaration errors.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/CDTUtils.h:80,avoid,avoid,80,math/mathcore/src/CDT/CDTUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/CDTUtils.h,1,['avoid'],['avoid']
Safety,"/**; * Marks a memory region (<c>[addr, addr+size)</c>) as addressable.; *; * This memory must be previously allocated by your program. Accessing; * addresses in this region is allowed until this region is poisoned again.; * This function could unpoison a super-region of <c>[addr, addr+size)</c> due; * to ASan alignment restrictions.; *; * \note This function is not thread-safe because no two threads can; * poison or unpoison memory in the same memory region simultaneously.; *; * \param addr Start of memory region.; * \param size Size of memory region. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/compiler.h:376,safe,safe,376,builtins/zstd/common/compiler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/compiler.h,1,['safe'],['safe']
Safety,"/**; * Marks a memory region (<c>[addr, addr+size)</c>) as unaddressable.; *; * This memory must be previously allocated by your program. Instrumented; * code is forbidden from accessing addresses in this region until it is; * unpoisoned. This function is not guaranteed to poison the entire region -; * it could poison only a subregion of <c>[addr, addr+size)</c> due to ASan; * alignment restrictions.; *; * \note This function is not thread-safe because no two threads can poison or; * unpoison memory in the same memory region simultaneously.; *; * \param addr Start of memory region.; * \param size Size of memory region. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/compiler.h:444,safe,safe,444,builtins/zstd/common/compiler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/compiler.h,1,['safe'],['safe']
Safety,/**; * Perform prediction using float as spectator variable; * @param method Path to a method weight file.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/crossvalidation/TestCrossValidationIntVar.cxx:15,predict,prediction,15,tmva/tmva/test/crossvalidation/TestCrossValidationIntVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/crossvalidation/TestCrossValidationIntVar.cxx,1,['predict'],['prediction']
Safety,"/**; * Provides a shared context for creating translation units.; *; * It provides two options:; *; * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of ""local""; * declarations (when loading any new translation units). A ""local"" declaration; * is one that belongs in the translation unit itself and not in a precompiled; * header that was used by the translation unit. If zero, all declarations; * will be enumerated.; *; * Here is an example:; *; * \code; * // excludeDeclsFromPCH = 1, displayDiagnostics=1; * Idx = clang_createIndex(1, 1);; *; * // IndexTest.pch was produced with the following command:; * // ""clang -x c IndexTest.h -emit-ast -o IndexTest.pch""; * TU = clang_createTranslationUnit(Idx, ""IndexTest.pch"");; *; * // This will load all the symbols from 'IndexTest.pch'; * clang_visitChildren(clang_getTranslationUnitCursor(TU),; * TranslationUnitVisitor, 0);; * clang_disposeTranslationUnit(TU);; *; * // This will load all the symbols from 'IndexTest.c', excluding symbols; * // from 'IndexTest.pch'.; * char *args[] = { ""-Xclang"", ""-include-pch=IndexTest.pch"" };; * TU = clang_createTranslationUnitFromSourceFile(Idx, ""IndexTest.c"", 2, args,; * 0, 0);; * clang_visitChildren(clang_getTranslationUnitCursor(TU),; * TranslationUnitVisitor, 0);; * clang_disposeTranslationUnit(TU);; * \endcode; *; * This process of creating the 'pch', loading it separately, and using it (via; * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks; * (which gives the indexer the same performance benefit as the compiler).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1463,redund,redundant,1463,interpreter/llvm-project/clang/include/clang-c/Index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h,1,['redund'],['redundant']
Safety,"/**; * Replace '/', '(', and ')' with pdf-safe versions; *; * Doing to8bitStream does NOT make this PDF display unicode text. For that; * we also need to reference a unicode font and embed it - royal pain in the rear.; *; * There is still a benefit to to8bitStream - PDF simply cannot handle 16bit chars,; * which JavaScript Strings are happy to provide. So, while we still cannot display; * 2-byte characters property, at least CONDITIONALLY converting (entire string containing); * 16bit chars to (USC-2-BE) 2-bytes per char + BOM streams we ensure that entire PDF; * is still parseable.; * This will allow immediate support for unicode in document properties strings.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:42,safe,safe,42,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['safe'],['safe']
Safety,"/**; * Reverses the adjustment applied to cparams when enabling dedicated dict; * search. This is used to recover the params set to be used in the working; * context. (Otherwise, those tables would also grow.); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c:106,recover,recover,106,builtins/zstd/compress/zstd_compress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_compress.c,1,['recover'],['recover']
Safety,/**; * Set the JITTargetMachineBuilder to be used when constructing the LLJIT; * instance. Calling this function is optional: if it is not called then the; * LLJITBuilder will use JITTargeTMachineBuilder::detectHost to construct a; * JITTargetMachineBuilder.; *; * This function takes ownership of the JTMB argument: clients should not; * dispose of the JITTargetMachineBuilder after calling this function.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h:205,detect,detectHost,205,interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h,1,['detect'],['detectHost']
Safety,"/**; * Similar to ZSTD_nextSrcSizeToDecompress(), but when when a block input can be streamed,; * we allow taking a partial block as the input. Currently only raw uncompressed blocks can; * be streamed.; *; * For blocks that can be streamed, this allows us to reduce the latency until we produce; * output, and avoid copying the input.; *; * @param inputSize - The total amount of input that the caller currently has.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c:311,avoid,avoid,311,builtins/zstd/decompress/zstd_decompress.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/decompress/zstd_decompress.c,1,['avoid'],['avoid']
Safety,/**; * The function detected that the arguments violate the function; * contract.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h:20,detect,detected,20,interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h,1,['detect'],['detected']
Safety,/**; * This diagnostic indicates that the code is ill-formed such; * that future parser recovery is unlikely to produce useful; * results.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h:88,recover,recovery,88,interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,1,['recover'],['recovery']
Safety,/**; * Tries a set of parameters and updates the COVER_best_t with the results.; * This function is thread safe if zstd is compiled with multithreaded support.; * It takes its parameters as an *OWNING* opaque pointer to support threading.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/cover.c:107,safe,safe,107,builtins/zstd/dictBuilder/cover.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/dictBuilder/cover.c,2,['safe'],['safe']
Safety,/**; * ZSTD_ldm_skipSequences():; *; * Skip past `srcSize` bytes worth of sequences in `rawSeqStore`.; * Avoids emitting matches less than `minMatch` bytes.; * Must be called for data with is not passed to ZSTD_ldm_blockCompress().; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_ldm.h:105,Avoid,Avoids,105,builtins/zstd/compress/zstd_ldm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/compress/zstd_ldm.h,1,['Avoid'],['Avoids']
Safety,"/**; * \brief A Thread-safe cache for strings.; *; * This is used to generically store strings that are created in the computation; * graph machinery, for example when adding a new node.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:23,safe,safe,23,tree/dataframe/inc/ROOT/RDF/Utils.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx,1,['safe'],['safe']
Safety,"/**; * \brief Inserts the input string in the cache and returns an iterator to the cached string.; *; * The function implements the following strategy for thread-safety:; * 1. Take a shared lock and early return if the string is already in the cache.; * 2. Release the shared lock and take an exclusive lock.; * 3. Check again if another thread filled the cache meanwhile. If so, return the cached value.; * 4. Insert the new value in the cache and return.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:162,safe,safety,162,tree/dataframe/inc/ROOT/RDF/Utils.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx,1,['safe'],['safety']
Safety,"/**; * \brief Poll the sockets with ppoll; *; * By polling with ppoll instead of poll, one can pass along a signal mask to; * handle POSIX signals properly. See the zmq_ppoll documentation for examples; * of when this is useful: http://api.zeromq.org/; *; * \param[in] timeo Timeout in milliseconds. 0 means return immediately. -1 means wait for an event indefinitely.; * \param[in] sigmask A non-nullptr pointer to a signal mask must be constructed and passed to 'sigmask'. See the man page; * of sigprocmask(2) for more details on this. \return A vector of pairs of index and flags; index is the index of the; * registered fd or socket and flags are 0 (no events), ZMQ_POLLIN or ZMQ_POLLOUT.; *; * \note This function can throw (from inside ZMQ::ppoll), so wrap in try-catch!; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/src/ZeroMQPoller.cpp:275,Timeout,Timeout,275,roofit/roofitZMQ/src/ZeroMQPoller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/src/ZeroMQPoller.cpp,1,['Timeout'],['Timeout']
Safety,"/**; * \class ROOT::Internal::RDF::RColumnRegister; * \ingroup dataframe; * \brief A binder for user-defined columns, variations and aliases.; *; * The storage is copy-on-write and shared between all instances of the class that have the same values.; *; * Several components of an RDF computation graph make use of a column register. It keeps track of which columns have; * been defined, varied or aliased at each point of the computation graph.; * In many cases, the contents of the different column register instances are the same or only differ by a single; * extra defined/varied/aliased column. For this reason, in order to avoid unnecessary data duplication, fDefines,; * fAliases, fVariations and fColumnNames are all shared_ptr<const T> that (whenever possible) are shared across; * RColumnRegister instances that are part of the same computation graph. If a new column, alias or variation is added; * between one node and the next, then the new node contains a new instance of a RColumnRegister that shares all data; * members with the previous instance except for the one data member that needed updating, which is replaced with a new; * updated instance.; *; * The contents of the collections that keep track of other objects of the computation graph are not owned by the; * RColumnRegister object. They are registered centrally by the RLoopManager and only accessed via reference in the; * RColumnRegister.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RColumnRegister.hxx:629,avoid,avoid,629,tree/dataframe/inc/ROOT/RDF/RColumnRegister.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RColumnRegister.hxx,1,['avoid'],['avoid']
Safety,"/**; * \class RRawFile RRawFile.hxx; * \ingroup IO; *; * The RRawFile provides read-only access to local and remote files. Data can be read either byte-wise or line-wise.; * The RRawFile base class provides line-wise access and buffering for byte-wise access. Derived classes provide the; * low-level read operations, e.g. from a local file system or from a web server. The RRawFile is used for non-ROOT; * RDataSource implementations and for RNTuple.; *; * Files are addressed by URL consisting of a transport protocol part and a location, like file:///path/to/data; * If the transport protocol part and the :// separator are missing, the default protocol is local file. Files are; * opened when required (on reading, getting file size) and closed on object destruction.; *; * RRawFiles manage system resources and are therefore made non-copyable. They can be explicitly cloned though.; *; * RRawFile objects are conditionally thread safe. See the user manual for further details:; * https://root.cern/manual/thread_safety/; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/RRawFile.hxx:935,safe,safe,935,io/io/inc/ROOT/RRawFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/RRawFile.hxx,1,['safe'],['safe']
Safety,"/**; * \defgroup Options setters; * @{; */; /**; * \defgroup Cache controlling options; *; * These entry points control the ThinLTO cache. The cache is intended to; * support incremental build, and thus needs to be persistent accross build.; * The client enabled the cache by supplying a path to an existing directory.; * The code generator will use this to store objects files that may be reused; * during a subsequent build.; * To avoid filling the disk space, a few knobs are provided:; * - The pruning interval limit the frequency at which the garbage collector; * will try to scan the cache directory to prune it from expired entries.; * Setting to -1 disable the pruning (default). Setting to 0 will force; * pruning to occur.; * - The pruning expiration time indicates to the garbage collector how old; * an entry needs to be to be removed.; * - Finally, the garbage collector can be instructed to prune the cache till; * the occupied space goes below a threshold.; * @{; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:433,avoid,avoid,433,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,1,['avoid'],['avoid']
Safety,"/**; * \fn bool ZeroMQSvc::send(zmq::socket_t &socket, const char *item, zmq::send_flags flags) const; * \brief Send message over a socket; *; * \param[in] socket Socket.; * \param[in] item Message to send over.; * \param[in] flags Flags to send. See http://api.zeromq.org/master:zmq-send for possible flags and the cppzmq API for; * the type-safe equivalents in the zmq::send_flags enum class.; * \return An optional of type zmq::send_result_t that contains the number of bytes sent if successful, and is empty if; * EAGAIN was received, which probably means you should try again.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/src/ZeroMQSvc.cpp:343,safe,safe,343,roofit/roofitZMQ/src/ZeroMQSvc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/src/ZeroMQSvc.cpp,1,['safe'],['safe']
Safety,"/**; * \test TBufferMerger, SetMaxTreeSize; * \brief Test to avoid issue #6523.; * ; * `TTree`'s default behaviour of changing the file it is attached to when reaching; * a size greater than `fgMaxTreeSize` doesn't fit in the design of TBufferMerger.; * The `TTree::Fill` method has been modified accordingly, avoiding this behaviour; * when the tree is attached to a TMemFile (thus also a TBufferMergerFile). This; * test tries to trigger the behaviour forcedly by calling `TTree::SetMaxTreeSize`; * but the TBufferMergerFile is never detached from the tree.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/test/TBufferMerger.cxx:61,avoid,avoid,61,io/io/test/TBufferMerger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/test/TBufferMerger.cxx,2,['avoid'],"['avoid', 'avoiding']"
Safety,"/**; * g_get_charset:; * @charset: return location for character set name; * ; * Obtains the character set for the current locale; you might use; * this character set as an argument to g_convert(), to convert from; * the current locale's encoding to some other encoding. (Frequently; * g_locale_to_utf8() and g_locale_from_utf8() are nice shortcuts,; * though.); *; * The return value is %TRUE if the locale's encoding is UTF-8, in that; * case you can perhaps avoid calling g_convert().; *; * The string returned in @charset is not allocated, and should not be; * freed.; * ; * Return value: %TRUE if the returned charset is UTF-8; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutf8.c:461,avoid,avoid,461,graf2d/win32gdk/gdk/src/glib/gutf8.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gutf8.c,1,['avoid'],['avoid']
Safety,"/**; * g_io_channel_get_encoding:; * @channel: a #GIOChannel; *; * Get the encoding for the input/output of the channel. The internal; * encoding is always UTF-8. The encoding %NULL makes the; * channel safe for binary data.; *; * Return value: A string containing the encoding, this string is; * owned by GLib and must not be freed.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c:203,safe,safe,203,graf2d/win32gdk/gdk/src/glib/giochannel.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c,1,['safe'],['safe']
Safety,/**; * g_io_channel_get_line_term:; * @channel: a #GIOChannel; * @length: a location to return the length of the line terminator; *; * This returns the string that #GIOChannel uses to determine; * where in the file a line break occurs. A value of %NULL; * indicates auto detection.; *; * Return value: The line termination string. This value; * is owned by GLib and must not be freed.; **/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c:271,detect,detection,271,graf2d/win32gdk/gdk/src/glib/giochannel.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c,1,['detect'],['detection']
Safety,"/**; * g_io_channel_set_buffered:; * @channel: a #GIOChannel; * @buffered: whether to set the channel buffered or unbuffered; *; * The buffering state can only be set if the channel's encoding; * is %NULL. For any other encoding, the channel must be buffered.; *; * A buffered channel can only be set unbuffered if the channel's; * internal buffers have been flushed. Newly created channels or; * channels which have returned G_IO_STATUS_EOF; * not require such a flush. For write-only channels, a call to; * g_io_channel_flush () is sufficient. For all other channels,; * the buffers may be flushed by a call to g_io_channel_seek_position ().; * This includes the possibility of seeking with seek type %G_SEEK_CUR; * and an offset of zero. Note that this means that socket-based; * channels cannot be set unbuffered once they have had data; * read from them.; *; * On unbuffered channels, it is safe to mix read and write; * calls from the new and old APIs, if this is necessary for; * maintaining old code.; *; * The default state of the channel is buffered.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c:896,safe,safe,896,graf2d/win32gdk/gdk/src/glib/giochannel.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c,1,['safe'],['safe']
Safety,"/**; * g_io_channel_set_encoding:; * @channel: a #GIOChannel; * @encoding: the encoding type; * @error: location to store an error of type #GConvertError.; *; * Set the encoding for the input/output of the channel. The internal; * encoding is always UTF-8. The default encoding for the; * external file is UTF-8.; *; * The encoding %NULL is safe to use with binary data.; *; * The encoding can only be set under the following conditions:; *; * 1. The channel was just created, and has not been written to; * or read from yet.; *; * 2. The channel is write-only.; *; * 3. The channel is a file, and the file pointer was just; * repositioned by a call to g_io_channel_seek_position().; * (This flushes all the internal buffers.); *; * 4. The current encoding is %NULL or UTF-8.; *; * 5. One of the (new API) read functions has just returned G_IO_STATUS_EOF; * (or, in the case of g_io_channel_read_to_end (), G_IO_STATUS_NORMAL).; *; * 6. One of the functions g_io_channel_read_chars () or g_io_channel_read_unichar (); * has returned G_IO_STATUS_AGAIN or G_IO_STATUS_ERROR. This may be; * useful in the case of G_CONVERT_ERROR_ILLEGAL_SEQUENCE.; * Returning one of these statuses from g_io_channel_read_line (),; * g_io_channel_read_line_string (), or g_io_channel_read_to_end (); * does _not_ guarantee that the encoding can be changed.; *; * Channels which do not meet the above conditions cannot call; * g_io_channel_seek_position () with an offset of %G_SEEK_CUR,; * and if they are ""seekable"" cannot; * call g_io_channel_write_chars () after calling one; * of the API ""read"" functions.; *; * Return Value: %G_IO_STATUS_NORMAL if the encoding was succesfully set.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c:341,safe,safe,341,graf2d/win32gdk/gdk/src/glib/giochannel.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c,1,['safe'],['safe']
Safety,"/**; * g_io_channel_set_line_term:; * @channel: a #GIOChannel; * @line_term: The line termination string. Use %NULL for auto detect.; * Auto detection breaks on ""\n"", ""\r\n"", ""\r"", ""\0"", and; * the unicode paragraph separator. Auto detection should; * not be used for anything other than file-based channels.; * @length: The length of the termination string. If -1 is passed, the; * string is assumed to be null terminated. This option allows; * termination strings with embeded nulls.; *; * This sets the string that #GIOChannel uses to determine; * where in the file a line break occurs.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c:125,detect,detect,125,graf2d/win32gdk/gdk/src/glib/giochannel.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/giochannel.c,3,['detect'],"['detect', 'detection']"
Safety,"/**; * g_markup_parse_context_parse:; * @context: a #GMarkupParseContext; * @text: chunk of text to parse; * @text_len: length of @text in bytes; * @error: return location for a #GError; * ; * Feed some data to the #GMarkupParseContext. The data need not; * be valid UTF-8; an error will be signaled if it's invalid.; * The data need not be an entire document; you can feed a document; * into the parser incrementally, via multiple calls to this function.; * Typically, as you receive data from a network connection or file,; * you feed each received chunk of data into this function, aborting; * the process if an error occurs. Once an error is reported, no further; * data may be fed to the #GMarkupParseContext; all errors are fatal.; * ; * Return value: %FALSE if an error occurred, %TRUE on success; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmarkup.c:585,abort,aborting,585,graf2d/win32gdk/gdk/src/glib/gmarkup.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmarkup.c,1,['abort'],['aborting']
Safety,"/**; * g_mem_is_system_malloc; * ; * Checks whether the allocator used by g_malloc() is the system's; * malloc implementation. If it returns %TRUE memory allocated with; * malloc() can be used interchangeable with memory allocated using; * g_malloc(). This function is useful for avoiding an extra copy; * of allocated memory returned by a non-GLib-based API.; *; * A different allocator can be set using g_mem_set_vtable().; *; * Return value: if %TRUE, malloc() and g_malloc() can be mixed.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmem.c:280,avoid,avoiding,280,graf2d/win32gdk/gdk/src/glib/gmem.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/glib/gmem.c,1,['avoid'],['avoiding']
Safety,/**; Destructor.; Make it virtual in case users derive from Fitter class to extend it by adding new methods.; This is needed to avoid a warning seen when doing from Python; (see ROOT issue [#12391](https://github.com/root-project/root/issues/12391) ).; Note that the Fitter class does not provide virtual functions to be re-implemented by derived classes.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h:128,avoid,avoid,128,math/mathcore/inc/Fit/Fitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h,1,['avoid'],['avoid']
Safety,/**; Directly apply the inverse affine transformation on points; (first inverse translation then inverse rotation).; Avoids having to calculate the inverse as an intermediate result.; This is possible since the inverse of a rotation is its transpose.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Transform3D.h:117,Avoid,Avoids,117,math/genvector/inc/Math/GenVector/Transform3D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Transform3D.h,1,['Avoid'],['Avoids']
Safety,/**; Directly apply the inverse affine transformation on vectors.; Avoids having to calculate the inverse as an intermediate result.; This is possible since the inverse of a rotation is its transpose.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Transform3D.h:67,Avoid,Avoids,67,math/genvector/inc/Math/GenVector/Transform3D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Transform3D.h,1,['Avoid'],['Avoids']
Safety,/**; Dummy Structure which flags an error to avoid assignment from expression based on a; general matrix to a symmetric matrix; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/HelperOps.h:45,avoid,avoid,45,math/smatrix/inc/Math/HelperOps.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/HelperOps.h,1,['avoid'],['avoid']
Safety,/**; Fit a binned data set using a least square fit.; Note that the provided input data are copied in the Fitter class.; Use the next function (passing a `shared_ptr` to the BinData class if you want to avoid; copying.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h:203,avoid,avoid,203,math/mathcore/inc/Fit/Fitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h,1,['avoid'],['avoid']
Safety,/**; Fit an un-binned data set using the negative log-likelihood method.; This function uses a `shared_ptr` to avoid copying the input data.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h:111,avoid,avoid,111,math/mathcore/inc/Fit/Fitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h,1,['avoid'],['avoid']
Safety,"/**; Function to check if a vector is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the vector is in use, for example in operations; like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically; created when evaluating the expression. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/SVector.h:143,avoid,avoid,143,math/smatrix/inc/Math/SVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/SVector.h,1,['avoid'],['avoid']
Safety,"/**; Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IParamFunction.h:86,avoid,avoid,86,math/mathcore/inc/Math/IParamFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IParamFunction.h,2,['avoid'],['avoid']
Safety,/**; Specialization for symmetric matrices.; Evaluate the expression performing a -= operation for symmetric matrices; Need to have a separate functions to avoid to modify two times the off-diagonal; elements (i.e applying two times the expression); Need to check whether creating a temporary object with the expression result; (like in op: A -= A + B ); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/HelperOps.h:156,avoid,avoid,156,math/smatrix/inc/Math/HelperOps.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/HelperOps.h,1,['avoid'],['avoid']
Safety,/**; Specialization for symmetric matrices; Evaluate the expression performing a += operation for symmetric matrices; Need to have a separate functions to avoid to modify two times the off-diagonal; elements (i.e applying two times the expression); Need to check whether creating a temporary object with the expression result; (like in op: A += A * B ); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/HelperOps.h:155,avoid,avoid,155,math/smatrix/inc/Math/HelperOps.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/HelperOps.h,1,['avoid'],['avoid']
Safety,/**; Template class to wrap any C++ callable object which takes one argument; i.e. implementing operator() (double x) in a One-dimensional function interface.; It provides a ROOT::Math::IGenFunction-like signature. Note: If you want to wrap just the reference (to avoid copying) you need to use; Func& or const Func & as template parameter. The former should be used when the; operator() is not a const method of Func. @ingroup GenFunc. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/WrappedFunction.h:264,avoid,avoid,264,math/mathcore/inc/Math/WrappedFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/WrappedFunction.h,1,['avoid'],['avoid']
Safety,"/**; Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points this routine fills the arrays x and w; of length num, containing the abscissa and weight of the Gauss-Legendre; n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. num is the number of sampling points (>0); x and w are arrays of size num; eps is the relative precision. If num<=0 or eps<=0 no action is done. Reference: Numerical Recipes in C, Second Edition; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GaussLegendreIntegrator.h:11,unsafe,unsafe,11,math/mathcore/inc/Math/GaussLegendreIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GaussLegendreIntegrator.h,1,['unsafe'],['unsafe']
Safety,"/**; \class ROOT::Experimental::RNTupleParallelWriter; \ingroup NTuple; \brief A writer to fill an RNTuple from multiple contexts. Compared to the sequential RNTupleWriter, a parallel writer enables the creation of multiple RNTupleFillContext (see; RNTupleParallelWriter::CreateFillContext). Each fill context prepares independent clusters that are appended to the; common ntuple with internal synchronization. Before destruction, all fill contexts must have flushed their data and; been destroyed (or data could be lost!). For user convenience, RNTupleParallelWriter::CreateFillContext is thread-safe and may be called from multiple threads; in parallel at any time, also after some data has already been written. Internally, the original model is cloned and; ownership is passed to a newly created RNTupleFillContext. For that reason, it is recommended to use; RNTupleModel::CreateBare when creating the model for parallel writing and avoid the allocation of a useless default; REntry per context. Note that the sequence of independently prepared clusters is indeterminate and therefore entries are only partially; ordered: Entries from one context are totally ordered as they were filled. However, there is no orderering with other; contexts and the entries may be appended to the ntuple either before or after other entries written in parallel into; other contexts. In addition, two consecutive entries in one fill context can end up separated in the final ntuple, if; they happen to fall onto a cluster boundary and other contexts append more entries before the next cluster is full. At the moment, the parallel writer does not (yet) support incremental updates of the underlying model. Please refer to; RNTupleWriter::CreateModelUpdater if required for your use case.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx:597,safe,safe,597,tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,/**; return the type; (need to be called GetType to avoid a conflict with typedef); */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMCIntegrator.h:52,avoid,avoid,52,math/mathmore/inc/Math/GSLMCIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMCIntegrator.h,1,['avoid'],['avoid']
Safety,"/**; return true if a range has been set in any of the coordinates; i.e. when it is not [-inf,+inf] for all coordinates; Avoid in case of multi-dim to loop on all the coordinated and ask the size; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/DataRange.h:121,Avoid,Avoid,121,math/mathcore/inc/Fit/DataRange.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/DataRange.h,1,['Avoid'],['Avoid']
Safety,"/**< 1: generate a 32-bits checksum using XXH64 algorithm at end of frame, for error detection */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:85,detect,detection,85,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['detect'],['detection']
Safety,"/**< maxCompressedSize is generally LZ4_COMPRESSBOUND(inputSize), but can be set to any lower value, with the risk that compression can fail (return code 0(zero)) */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h:110,risk,risk,110,builtins/lz4/lz4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.h,1,['risk'],['risk']
Safety,"/**< recommended size for output buffer. Guarantee to successfully flush at least one complete compressed block. */; /* *****************************************************************************; * This following is a legacy streaming API.; * It can be replaced by ZSTD_CCtx_reset() and ZSTD_compressStream2().; * It is redundant, but remains fully supported.; * Advanced parameters and dictionary compression can only be used through the; * new API.; ******************************************************************************/; /*!; * Equivalent to:; *; * ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);; * ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any); * ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:323,redund,redundant,323,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['redund'],['redundant']
Safety,/*-**************************************************************; * Memory I/O API; *****************************************************************/; /*=== Static platform detection ===*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/mem.h:175,detect,detection,175,builtins/zstd/common/mem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/mem.h,1,['detect'],['detection']
Safety,"/*-**************************************************************; * Memory I/O Implementation; *****************************************************************/; /* MEM_FORCE_MEMORY_ACCESS :; * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.; * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.; * The below switch allow to select different access method for improved performance.; * Method 0 (default) : use `memcpy()`. Safe and portable.; * Method 1 : `__packed` statement. It depends on compiler extension (i.e., not portable).; * This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.; * Method 2 : direct access. This method is portable but violate C standard.; * It can generate buggy code on targets depending on alignment.; * In some circumstances, it's the only known way to get the most performance (i.e. GCC + ARMv6); * See http://fastcompression.blogspot.fr/2015/08/accessing-unaligned-memory.html for details.; * Prefer these methods in priority order (0 > 1 > 2); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/mem.h:273,safe,safe,273,builtins/zstd/common/mem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/mem.h,3,"['Safe', 'safe']","['Safe', 'safe']"
Safety,"/*-********************************************************; * bitStream decoding; **********************************************************/; /*! BIT_initDStream() :; * Initialize a BIT_DStream_t.; * `bitD` : a pointer to an already allocated BIT_DStream_t structure.; * `srcSize` must be the *exact* size of the bitStream, in bytes.; * @return : size of stream (== srcSize), or an errorCode if a problem is detected; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h:410,detect,detected,410,builtins/zstd/common/bitstream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/common/bitstream.h,1,['detect'],['detected']
Safety,/*----------------------------------------------------------------------------*\; |* Interlocked And; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Interlock,Interlocked,85,interpreter/llvm-project/clang/lib/Headers/intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h,1,['Interlock'],['Interlocked']
Safety,/*----------------------------------------------------------------------------*\; |* Interlocked Compare Exchange HLE; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:85,Interlock,Interlocked,85,interpreter/llvm-project/clang/lib/Headers/immintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h,1,['Interlock'],['Interlocked']
Safety,/*----------------------------------------------------------------------------*\; |* Interlocked Compare Exchange; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Interlock,Interlocked,85,interpreter/llvm-project/clang/lib/Headers/intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h,1,['Interlock'],['Interlocked']
Safety,/*----------------------------------------------------------------------------*\; |* Interlocked Decrement; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Interlock,Interlocked,85,interpreter/llvm-project/clang/lib/Headers/intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h,1,['Interlock'],['Interlocked']
Safety,/*----------------------------------------------------------------------------*\; |* Interlocked Exchange Add; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Interlock,Interlocked,85,interpreter/llvm-project/clang/lib/Headers/intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h,1,['Interlock'],['Interlocked']
Safety,/*----------------------------------------------------------------------------*\; |* Interlocked Exchange HLE; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:85,Interlock,Interlocked,85,interpreter/llvm-project/clang/lib/Headers/immintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h,1,['Interlock'],['Interlocked']
Safety,/*----------------------------------------------------------------------------*\; |* Interlocked Exchange; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Interlock,Interlocked,85,interpreter/llvm-project/clang/lib/Headers/intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h,1,['Interlock'],['Interlocked']
Safety,/*----------------------------------------------------------------------------*\; |* Interlocked Increment; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Interlock,Interlocked,85,interpreter/llvm-project/clang/lib/Headers/intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h,1,['Interlock'],['Interlocked']
Safety,/*----------------------------------------------------------------------------*\; |* Interlocked Or; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Interlock,Interlocked,85,interpreter/llvm-project/clang/lib/Headers/intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h,1,['Interlock'],['Interlocked']
Safety,/*----------------------------------------------------------------------------*\; |* Interlocked Xor; \*----------------------------------------------------------------------------*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h:85,Interlock,Interlocked,85,interpreter/llvm-project/clang/lib/Headers/intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/intrin.h,1,['Interlock'],['Interlocked']
Safety,"/*. Objective-C setjmp-longjmp (sjlj) Exception Handling; --. A catch buffer is a setjmp buffer plus:; - a pointer to the exception that was caught; - a pointer to the previous exception data buffer; - two pointers of reserved storage; Therefore catch buffers form a stack, with a pointer to the top; of the stack kept in thread-local storage. objc_exception_try_enter pushes a catch buffer onto the EH stack.; objc_exception_try_exit pops the given catch buffer, which is; required to be the top of the EH stack.; objc_exception_throw pops the top of the EH stack, writes the; thrown exception into the appropriate field, and longjmps; to the setjmp buffer. It crashes the process (with a printf; and an abort()) if there are no catch buffers on the stack.; objc_exception_extract just reads the exception pointer out of the; catch buffer. There's no reason an implementation couldn't use a light-weight; setjmp here --- something like __builtin_setjmp, but API-compatible; with the heavyweight setjmp. This will be more important if we ever; want to implement correct ObjC/C++ exception interactions for the; fragile ABI. Note that for this use of setjmp/longjmp to be correct in the presence of; optimization, we use inline assembly on the set of local variables to force; flushing locals to memory immediately before any protected calls and to; inhibit optimizing locals across the setjmp->catch edge. The basic framework for a @try-catch-finally is as follows:; {; objc_exception_data d;; id _rethrow = null;; bool _call_try_exit = true;. objc_exception_try_enter(&d);; if (!setjmp(d.jmp_buf)) {; ... try body ...; } else {; // exception path; id _caught = objc_exception_extract(&d);. // enter new try scope for handlers; if (!setjmp(d.jmp_buf)) {; ... match exception and execute catch blocks ... // fell off end, rethrow.; _rethrow = _caught;; ... jump-through-finally to finally_rethrow ...; } else {; // exception in catch block; _rethrow = objc_exception_extract(&d);; _call_try_exit = fals",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:705,abort,abort,705,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['abort'],['abort']
Safety,"/*; * @see http://www.w3.org/TR/PNG-Chunks.html; *; Color Allowed Interpretation; Type Bit Depths. 0 1,2,4,8,16 Each pixel is a grayscale sample. 2 8,16 Each pixel is an R,G,B triple. 3 1,2,4,8 Each pixel is a palette index;; a PLTE chunk must appear. 4 8,16 Each pixel is a grayscale sample,; followed by an alpha sample. 6 8,16 Each pixel is an R,G,B triple,; followed by an alpha sample.; */; /*; * PNG filter method types; *; * @see http://www.w3.org/TR/PNG-Filters.html; * @see http://www.libpng.org/pub/png/book/chapter09.html; *; * This is what the value 'Predictor' in decode params relates to; *; * 15 is ""optimal prediction"", which means the prediction algorithm can change from line to line.; * In that case, you actually have to read the first byte off each line for the prediction algorthim (which should be 0-4, corresponding to PDF 10-14) and select the appropriate unprediction algorithm based on that byte.; *; 0 None; 1 Sub; 2 Up; 3 Average; 4 Paeth; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:563,Predict,Predictor,563,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,8,"['Predict', 'predict']","['Predictor', 'prediction']"
Safety,"/*; * Abort processing of a JPEG compression operation,; * but don't destroy the object itself.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcapimin.c:6,Abort,Abort,6,graf2d/asimage/src/libAfterImage/libjpeg/jcapimin.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcapimin.c,1,['Abort'],['Abort']
Safety,"/*; * Abort processing of a JPEG compression or decompression operation,; * but don't destroy the object itself.; *; * For this, we merely clean up all the nonpermanent memory pools.; * Note that temp files (virtual arrays) are not allowed to belong to; * the permanent pool, so we will be able to close all temp files here.; * Closing a data source or destination, if necessary, is the application's; * responsibility.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcomapi.c:6,Abort,Abort,6,graf2d/asimage/src/libAfterImage/libjpeg/jcomapi.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcomapi.c,1,['Abort'],['Abort']
Safety,"/*; * Abort processing of a JPEG decompression operation,; * but don't destroy the object itself.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdapimin.c:6,Abort,Abort,6,graf2d/asimage/src/libAfterImage/libjpeg/jdapimin.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdapimin.c,1,['Abort'],['Abort']
Safety,/*; * Allow additional definitions and implementation-defined values on Apple; * platforms. This is done after #include <math.h> to avoid depcycle conflicts; * between libcxx and darwin in C++ modules builds.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tgmath.h:132,avoid,avoid,132,interpreter/llvm-project/clang/lib/Headers/tgmath.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tgmath.h,1,['avoid'],['avoid']
Safety,"/*; * An additional method that can be provided by data source modules is the; * resync_to_restart method for error recovery in the presence of RST markers.; * For the moment, this source module just uses the default resync method; * provided by the JPEG library. That method assumes that no backtracking; * is possible.; */; /*; * Terminate source --- called by jpeg_finish_decompress; * after all data has been read. Often a no-op.; *; * NB: *not* called by jpeg_abort or jpeg_destroy; surrounding; * application must deal with any cleanup that should happen even; * for error exit.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatasrc.c:116,recover,recovery,116,graf2d/asimage/src/libAfterImage/libjpeg/jdatasrc.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdatasrc.c,1,['recover'],['recovery']
Safety,"/*; * Check the upper and lower edge of ""regUp"", to make sure that the; * eUp->Org is above eLo, or eLo->Org is below eUp (depending on which; * origin is leftmost).; *; * The main purpose is to splice right-going edges with the same; * dest vertex and nearly identical slopes (ie. we can't distinguish; * the slopes numerically). However the splicing can also help us; * to recover from numerical errors. For example, suppose at one; * point we checked eUp and eLo, and decided that eUp->Org is barely; * above eLo. Then later, we split eLo into two edges (eg. from; * a splice operation like this one). This can change the result of; * our test so that now eUp->Org is incident to eLo, or barely below it.; * We must correct this condition to maintain the dictionary invariants.; *; * One possibility is to check these edges for intersection again; * (ie. CheckForIntersect). This is what we do if possible. However; * CheckForIntersect requires that tess->event lies between eUp and eLo,; * so that it has something to fall back on when the intersection; * calculation gives us an unusable answer. So, for those cases where; * we can't check for intersection, this routine fixes the problem; * by just splicing the offending vertex into the other edge.; * This is a guaranteed solution, no matter how degenerate things get.; * Basically this is a combinatorial solution to a numerical problem.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/sweep.c:375,recover,recover,375,graf3d/eve7/glu/sweep.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/sweep.c,1,['recover'],['recover']
Safety,"/*; * Compression initialization.; * Before calling this, all parameters and a data destination must be set up.; *; * We require a write_all_tables parameter as a failsafe check when writing; * multiple datastreams from the same compression object. Since prior runs; * will have left all the tables marked sent_table=TRUE, a subsequent run; * would emit an abbreviated stream (no tables) by default. This may be what; * is wanted, but for safety's sake it should not be the default behavior:; * programmers should have to make a deliberate choice to emit abbreviated; * images. Therefore the documentation and examples should encourage people; * to pass write_all_tables=TRUE; then it will take active thought to do the; * wrong thing.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcapistd.c:439,safe,safety,439,graf2d/asimage/src/libAfterImage/libjpeg/jcapistd.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcapistd.c,1,['safe'],['safety']
Safety,"/*; * Copyright (C) 1999-2001, 2008 Free Software Foundation, Inc.; * This file is part of the GNU LIBICONV Library.; *; * The GNU LIBICONV Library is free software; you can redistribute it; * and/or modify it under the terms of the GNU Library General Public; * License as published by the Free Software Foundation; either version 2; * of the License, or (at your option) any later version.; *; * The GNU LIBICONV Library is distributed in the hope that it will be; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty of; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; * Library General Public License for more details.; *; * You should have received a copy of the GNU Library General Public; * License along with the GNU LIBICONV Library; see the file COPYING.LIB.; * If not, write to the Free Software Foundation, Inc., 51 Franklin Street,; * Fifth Floor, Boston, MA 02110-1301, USA.; */; /*; * ISO-2022-KR; */; /* Specification: RFC 1557 */; /* Note: CJK.INF says the SO designator needs to appear only once at the; beginning of a text, but to decrease the risk of ambiguities, when; producing ISO-2022-KR, we repeat the designator in every line containing; SO characters. RFC 1557 does not mandate this. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/iso2022_kr.h:1100,risk,risk,1100,graf2d/win32gdk/gdk/src/iconv/iso2022_kr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/iso2022_kr.h,1,['risk'],['risk']
Safety,"/*; * Decide whether to emit a trace or warning message.; * msg_level is one of:; * -1: recoverable corrupt-data warning, may want to abort.; * 0: important advisory messages (always display to user).; * 1: first level of tracing detail.; * 2,3,...: successively more detailed tracing messages.; * An application might override this method if it wanted to abort on warnings; * or change the policy about which messages to display.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jerror.c:88,recover,recoverable,88,graf2d/asimage/src/libAfterImage/libjpeg/jerror.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jerror.c,3,"['abort', 'recover']","['abort', 'recoverable']"
Safety,"/*; * Determine whether block smoothing is applicable and safe.; * We also latch the current states of the coef_bits[] entries for the; * AC coefficients; otherwise, if the input side of the decompressor; * advances into a new scan, we might think the coefficients are known; * more accurately than they really are.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdcoefct.c:58,safe,safe,58,graf2d/asimage/src/libAfterImage/libjpeg/jdcoefct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdcoefct.c,1,['safe'],['safe']
Safety,"/*; * Downcast + upcast is usually better than masking on older compilers like; * GCC 4.2 (especially 32-bit ones), all without affecting newer compilers.; *; * The other method, (x & 0xFFFFFFFF) * (y & 0xFFFFFFFF), will AND both operands; * and perform a full 64x64 multiply -- entirely redundant on 32-bit.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:288,redund,redundant,288,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['redund'],['redundant']
Safety,/*; * Emit a restart marker & resynchronize predictions.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c:44,predict,predictions,44,graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcarith.c,3,['predict'],['predictions']
Safety,"/*; * For the simple (no-context-row) case, we just need to buffer one; * row group's worth of pixels for the downsampling step. At the bottom of; * the image, we pad to a full row group by replicating the last pixel row.; * The downsampler's last output row is then replicated if needed to pad; * out to a full iMCU row.; *; * When providing context rows, we must buffer three row groups' worth of; * pixels. Three row groups are physically allocated, but the row pointer; * arrays are made five row groups high, with the extra pointers above and; * below ""wrapping around"" to point to the last and first real row groups.; * This allows the downsampler to access the proper context rows.; * At the top and bottom of the image, we create dummy context rows by; * copying the first or last real pixel row. This copying could be avoided; * by pointer hacking as is done in jdmainct.c, but it doesn't seem worth the; * trouble on the compression side.; */; /* Private buffer controller object */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcprepct.c:827,avoid,avoided,827,graf2d/asimage/src/libAfterImage/libjpeg/jcprepct.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcprepct.c,1,['avoid'],['avoided']
Safety,"/*; * GLEW does not include <windows.h> to avoid name space pollution.; * GL needs GLAPI and GLAPIENTRY, GLU needs APIENTRY, CALLBACK, and wchar_t; * defined properly.; */; /* <windef.h> and <gl.h>*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/inc/GL/glew.h:43,avoid,avoid,43,builtins/glew/inc/GL/glew.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/glew/inc/GL/glew.h,1,['avoid'],['avoid']
Safety,"/*; * Initialize the error-limiting transfer function (lookup table).; * The raw F-S error computation can potentially compute error values of up to; * +- MAXJSAMPLE. But we want the maximum correction applied to a pixel to be; * much less, otherwise obviously wrong pixels will be created. (Typical; * effects include weird fringes at color-area boundaries, isolated bright; * pixels in a dark area, etc.) The standard advice for avoiding this problem; * is to ensure that the ""corners"" of the color cube are allocated as output; * colors; then repeated errors in the same direction cannot cause cascading; * error buildup. However, that only prevents the error from getting; * completely out of hand; Aaron Giles reports that error limiting improves; * the results even with corner colors allocated.; * A simple clamping of the error values to about +- MAXJSAMPLE/8 works pretty; * well, but the smoother transfer function used below is even better. Thanks; * to Aaron Giles for this idea.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c:431,avoid,avoiding,431,graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jquant2.c,1,['avoid'],['avoiding']
Safety,"/*; * It's important for performance that XXH3_hashLong is not inlined.; * Since the function is not inlined, the compiler may not be able to understand that,; * in some scenarios, its `secret` argument is actually a compile time constant.; * This variant enforces that the compiler can detect that,; * and uses this opportunity to streamline the generated code for better performance.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:287,detect,detect,287,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['detect'],['detect']
Safety,/*; * Module initialization routine for merged upsampling/color conversion.; *; * NB: this is called under the conditions determined by use_merged_upsample(); * in jdmaster.c. That routine MUST correspond to the actual capabilities; * of this module; no safety checks are made here.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmerge.c:254,safe,safety,254,graf2d/asimage/src/libAfterImage/libjpeg/jdmerge.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmerge.c,1,['safe'],['safety']
Safety,"/*; * On GCC & Clang, marking 'dest' as modified will cause the compiler:; * - do not extract the secret from sse registers in the internal loop; * - use less common registers, and avoid pushing these reg into stack; * The asm hack causes Clang to assume that XXH3_kSecretPtr aliases with; * customSecret, and on aarch64, this prevented LDP from merging two; * loads together for free. Putting the loads together before the stores; * properly generates LDP.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:181,avoid,avoid,181,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['avoid'],['avoid']
Safety,"/*; * On GCC & Clang, marking 'dest' as modified will cause the compiler:; * - do not extract the secret from sse registers in the internal loop; * - use less common registers, and avoid pushing these reg into stack; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:181,avoid,avoid,181,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['avoid'],['avoid']
Safety,/*; * Portable and safe solution. Generally efficient.; * see: https://stackoverflow.com/a/32095106/646947; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:19,safe,safe,19,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,['safe'],['safe']
Safety,"/*; * Portable scalar method. Optimized for 32-bit and 64-bit ALUs.; *; * This is a fast and simple grade school multiply, which is shown below; * with base 10 arithmetic instead of base 0x100000000.; *; * 9 3 // D2 lhs = 93; * x 7 5 // D2 rhs = 75; * ----------; * 1 5 // D2 lo_lo = (93 % 10) * (75 % 10) = 15; * 4 5 | // D2 hi_lo = (93 / 10) * (75 % 10) = 45; * 2 1 | // D2 lo_hi = (93 % 10) * (75 / 10) = 21; * + 6 3 | | // D2 hi_hi = (93 / 10) * (75 / 10) = 63; * ---------; * 2 7 | // D2 cross = (15 / 10) + (45 % 10) + 21 = 27; * + 6 7 | | // D2 upper = (27 / 10) + (45 / 10) + 63 = 67; * ---------; * 6 9 7 5 // D4 res = (27 * 10) + (15 % 10) + (67 * 100) = 6975; *; * The reasons for adding the products like this are:; * 1. It avoids manual carry tracking. Just like how; * (9 * 9) + 9 + 9 = 99, the same applies with this for UINT64_MAX.; * This avoids a lot of complexity.; *; * 2. It hints for, and on Clang, compiles to, the powerful UMAAL; * instruction available in ARM's Digital Signal Processing extension; * in 32-bit ARMv6 and later, which is shown below:; *; * void UMAAL(xxh_u32 *RdLo, xxh_u32 *RdHi, xxh_u32 Rn, xxh_u32 Rm); * {; * xxh_u64 product = (xxh_u64)*RdLo * (xxh_u64)*RdHi + Rn + Rm;; * *RdLo = (xxh_u32)(product & 0xFFFFFFFF);; * *RdHi = (xxh_u32)(product >> 32);; * }; *; * This instruction was designed for efficient long multiplication, and; * allows this to be calculated in only 4 instructions at speeds; * comparable to some 64-bit ALUs.; *; * 3. It isn't terrible on other platforms. Usually this will be a couple; * of 32-bit ADD/ADCs.; */; /* First calculate all of the cross products. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:736,avoid,avoids,736,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,['avoid'],['avoids']
Safety,"/*; * Read a restart marker, which is expected to appear next in the datastream;; * if the marker is not there, take appropriate recovery action.; * Returns FALSE if suspension is required.; *; * This is called by the entropy decoder after it has read an appropriate; * number of MCUs. cinfo->unread_marker may be nonzero if the entropy decoder; * has already read a marker from the data source. Under normal conditions; * cinfo->unread_marker will be reset to 0 before returning; if not reset,; * it holds a marker which the decoder will be unable to read past.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c:129,recover,recovery,129,graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c,1,['recover'],['recovery']
Safety,"/*; * Routines to process JPEG markers.; *; * Entry condition: JPEG marker itself has been read and its code saved; * in cinfo->unread_marker; input restart point is just after the marker.; *; * Exit: if return TRUE, have read and processed any parameters, and have; * updated the restart point to point after the parameters.; * If return FALSE, was forced to suspend before reaching end of; * marker parameters; restart point has not been moved. Same routine; * will be called again after application supplies more input data.; *; * This approach to suspension assumes that all of a marker's parameters; * can fit into a single input bufferload. This should hold for ""normal""; * markers. Some COM/APPn markers might have large parameter segments; * that might not fit. If we are simply dropping such a marker, we use; * skip_input_data to get past it, and thereby put the problem on the; * source manager's shoulders. If we are saving the marker's contents; * into memory, we use a slightly different convention: when forced to; * suspend, the marker processor updates the restart point to the end of; * what it's consumed (ie, the end of the buffer) before returning FALSE.; * On resumption, cinfo->unread_marker still contains the marker code,; * but the data source will point to the next chunk of marker data.; * The marker processor must retain internal state to deal with this.; *; * Note that we don't bother to avoid duplicate trace messages if a; * suspension occurs within marker parameters. Other side effects; * require more care.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c:1420,avoid,avoid,1420,graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c,1,['avoid'],['avoid']
Safety,"/*; * Some identifiers (enums, type names) are not symbols, but they must; * still be renamed to avoid redeclaration.; * Alternative solution: do not redeclare them.; * However, this requires some #ifdefs, and is a more dispersed action.; * Meanwhile, renaming can be achieved in a single block; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:97,avoid,avoid,97,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['avoid'],['avoid']
Safety,"/*; * The poop on this scaling stuff is as follows:; *; * Each 1-D DCT step produces outputs which are a factor of sqrt(N); * larger than the true DCT outputs. The final outputs are therefore; * a factor of N larger than desired; since N=8 this can be cured by; * a simple right shift at the end of the algorithm. The advantage of; * this arrangement is that we save two multiplications per 1-D DCT,; * because the y0 and y4 outputs need not be divided by sqrt(N).; * In the IJG code, this factor of 8 is removed by the quantization step; * (in jcdctmgr.c), NOT in this module.; *; * We have to do addition and subtraction of the integer inputs, which; * is no problem, and multiplication by fractional constants, which is; * a problem to do in integer arithmetic. We multiply all the constants; * by CONST_SCALE and convert them to integer constants (thus retaining; * CONST_BITS bits of precision in the constants). After doing a; * multiplication we have to divide the product by CONST_SCALE, with proper; * rounding, to produce the correct output. This division can be done; * cheaply as a right shift of CONST_BITS bits. We postpone shifting; * as long as possible so that partial sums can be added together with; * full fractional precision.; *; * The outputs of the first pass are scaled up by PASS1_BITS bits so that; * they are represented to better-than-integral precision. These outputs; * require BITS_IN_JSAMPLE + PASS1_BITS + 3 bits; this fits in a 16-bit word; * with the recommended scaling. (For 12-bit sample data, the intermediate; * array is INT32 anyway.); *; * To avoid overflow of the 32-bit intermediate results in pass 2, we must; * have BITS_IN_JSAMPLE + CONST_BITS + PASS1_BITS <= 26. Error analysis; * shows that the values given below are the most effective.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c:1586,avoid,avoid,1586,graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jfdctint.c,1,['avoid'],['avoid']
Safety,"/*; * The poop on this scaling stuff is as follows:; *; * Each 1-D IDCT step produces outputs which are a factor of sqrt(N); * larger than the true IDCT outputs. The final outputs are therefore; * a factor of N larger than desired; since N=8 this can be cured by; * a simple right shift at the end of the algorithm. The advantage of; * this arrangement is that we save two multiplications per 1-D IDCT,; * because the y0 and y4 inputs need not be divided by sqrt(N).; *; * We have to do addition and subtraction of the integer inputs, which; * is no problem, and multiplication by fractional constants, which is; * a problem to do in integer arithmetic. We multiply all the constants; * by CONST_SCALE and convert them to integer constants (thus retaining; * CONST_BITS bits of precision in the constants). After doing a; * multiplication we have to divide the product by CONST_SCALE, with proper; * rounding, to produce the correct output. This division can be done; * cheaply as a right shift of CONST_BITS bits. We postpone shifting; * as long as possible so that partial sums can be added together with; * full fractional precision.; *; * The outputs of the first pass are scaled up by PASS1_BITS bits so that; * they are represented to better-than-integral precision. These outputs; * require BITS_IN_JSAMPLE + PASS1_BITS + 3 bits; this fits in a 16-bit word; * with the recommended scaling. (To scale up 12-bit sample data further, an; * intermediate INT32 array would be needed.); *; * To avoid overflow of the 32-bit intermediate results in pass 2, we must; * have BITS_IN_JSAMPLE + CONST_BITS + PASS1_BITS <= 26. Error analysis; * shows that the values given below are the most effective.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c:1496,avoid,avoid,1496,graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jidctint.c,1,['avoid'],['avoid']
Safety,"/*; * The state is structured as follows:; * bit 1..0: shift; * bit 7..2: data; * Precise meaning:; * shift data; * 0 0 not inside base64 encoding; * 1 0 inside base64, no pending bits; * 2 XX00 inside base64, 2 bits known for 2nd byte; * 3 XXXX inside base64, 4 bits known for 3rd byte; */; /* Define this to 1 if you want the so-called ""optional direct"" characters; ! "" # $ % & * ; < = > @ [ ] ^ _ ` { | }; to be encoded. Define to 0 if you want them to be passed straight through,; like the so-called ""direct"" characters.; We set this to 1 because it's safer.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/utf7.h:556,safe,safer,556,graf2d/win32gdk/gdk/src/iconv/utf7.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/gdk/src/iconv/utf7.h,1,['safe'],['safer']
Safety,"/*; * These are the routines invoked by sep_upsample to upsample pixel values; * of a single component. One row group is processed per call.; */; /*; * For full-size components, we just make color_buf[ci] point at the; * input buffer, and thus avoid copying any data. Note that this is; * safe only because sep_upsample doesn't declare the input row group; * ""consumed"" until we are done color converting and emitting it.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdsample.c:244,avoid,avoid,244,graf2d/asimage/src/libAfterImage/libjpeg/jdsample.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdsample.c,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"/*; * This code is derived from (original license follows):; *; * This is an OpenSSL-compatible implementation of the RSA Data Security, Inc.; * MD5 Message-Digest Algorithm (RFC 1321).; *; * Homepage:; * http://openwall.info/wiki/people/solar/software/public-domain-source-code/md5; *; * Author:; * Alexander Peslyak, better known as Solar Designer <solar at openwall.com>; *; * This software was written by Alexander Peslyak in 2001. No copyright is; * claimed, and the software is hereby placed in the public domain.; * In case this attempt to disclaim copyright and place the software in the; * public domain is deemed null and void, then the software is; * Copyright (c) 2001 Alexander Peslyak and it is hereby released to the; * general public under the following terms:; *; * Redistribution and use in source and binary forms, with or without; * modification, are permitted.; *; * There's ABSOLUTELY NO WARRANTY, express or implied.; *; * (This is a heavily cut-down ""BSD license"".); *; * This differs from Colin Plumb's older public domain implementation in that; * no exactly 32-bit integer data type is required (any 32-bit or wider; * unsigned integer data type will do), there's no compile-time endianness; * configuration, and the function prototypes match OpenSSL's. No code from; * Colin Plumb's implementation has been reused; this comment merely compares; * the properties of the two independent implementations.; *; * The primary goals of this implementation are portability and ease of use.; * It is meant to be fast, but not as fast as possible. Some known; * optimizations are not included to reduce source code size and avoid; * compile-time configuration.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/MD5.cpp:1642,avoid,avoid,1642,interpreter/llvm-project/llvm/lib/Support/MD5.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/MD5.cpp,1,['avoid'],['avoid']
Safety,"/*; * This is the default resync_to_restart method for data source managers; * to use if they don't have any better approach. Some data source managers; * may be able to back up, or may have additional knowledge about the data; * which permits a more intelligent recovery strategy; such managers would; * presumably supply their own resync method.; *; * read_restart_marker calls resync_to_restart if it finds a marker other than; * the restart marker it was expecting. (This code is *not* used unless; * a nonzero restart interval has been declared.) cinfo->unread_marker is; * the marker code actually found (might be anything, except 0 or FF).; * The desired restart marker number (0..7) is passed as a parameter.; * This routine is supposed to apply whatever error recovery strategy seems; * appropriate in order to position the input stream to the next data segment.; * Note that cinfo->unread_marker is treated as a marker appearing before; * the current data-source input point; usually it should be reset to zero; * before returning.; * Returns FALSE if suspension is required.; *; * This implementation is substantially constrained by wanting to treat the; * input as a data stream; this means we can't back up. Therefore, we have; * only the following actions to work with:; * 1. Simply discard the marker and let the entropy decoder resume at next; * byte of file.; * 2. Read forward until we find another marker, discarding intervening; * data. (In theory we could look ahead within the current bufferload,; * without having to discard data if we don't find the desired marker.; * This idea is not implemented here, in part because it makes behavior; * dependent on buffer size and chance buffer-boundary positions.); * 3. Leave the marker unread (by failing to zero cinfo->unread_marker).; * This will cause the entropy decoder to process an empty data segment,; * inserting dummy zeroes, and then we will reprocess the marker.; *; * #2 is appropriate if we think the desired marker lies ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c:263,recover,recovery,263,graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdmarker.c,2,['recover'],['recovery']
Safety,"/*; * This part deals with the special case where a unit wants to inline xxHash,; * but ""xxhash.h"" has previously been included without XXH_INLINE_ALL, such; * as part of some previously included *.h header file.; * Without further action, the new include would just be ignored,; * and functions would effectively _not_ be inlined (silent failure).; * The following macros solve this situation by prefixing all inlined names,; * avoiding naming collision with previous inclusions.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:429,avoid,avoiding,429,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['avoid'],['avoiding']
Safety,"/*; * Try to detect endianness automatically, to avoid the nonstandard behavior; * in `XXH_isLittleEndian()`; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:13,detect,detect,13,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,"['avoid', 'detect']","['avoid', 'detect']"
Safety,"/*; * UGLY HACK:; * Clang for ARMv7-A tries to vectorize this loop, similar to GCC x86.; * In everywhere else, it uses scalar code.; *; * For 64->128-bit multiplies, even if the NEON was 100% optimal, it; * would still be slower than UMAAL (see XXH_mult64to128).; *; * Unfortunately, Clang doesn't handle the long multiplies properly and; * converts them to the nonexistent ""vmulq_u64"" intrinsic, which is then; * scalarized into an ugly mess of VMOV.32 instructions.; *; * This mess is difficult to avoid without turning autovectorization; * off completely, but they are usually relatively minor and/or not; * worth it to fix.; *; * This loop is the easiest to fix, as unlike XXH32, this pragma; * _actually works_ because it is a loop vectorization instead of an; * SLP vectorization.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:500,avoid,avoid,500,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['avoid'],['avoid']
Safety,"/*; * UGLY HACK:; * This inline assembly hack forces acc into a normal register. This is the; * only thing that prevents GCC and Clang from autovectorizing the XXH32; * loop (pragmas and attributes don't work for some resason) without globally; * disabling SSE4.1.; *; * The reason we want to avoid vectorization is because despite working on; * 4 integers at a time, there are multiple factors slowing XXH32 down on; * SSE4:; * - There's a ridiculous amount of lag from pmulld (10 cycles of latency on; * newer chips!) making it slightly slower to multiply four integers at; * once compared to four integers independently. Even when pmulld was; * fastest, Sandy/Ivy Bridge, it is still not worth it to go into SSE; * just to multiply unless doing a long operation.; *; * - Four instructions are required to rotate,; * movqda tmp, v // not required with VEX encoding; * pslld tmp, 13 // tmp <<= 13; * psrld v, 19 // x >>= 19; * por v, tmp // x |= tmp; * compared to one for scalar:; * roll v, 13 // reliably fast across the board; * shldl v, v, 13 // Sandy Bridge and later prefer this for some reason; *; * - Instruction level parallelism is actually more beneficial here because; * the SIMD actually serializes this operation: While v1 is rotating, v2; * can load data, while v3 can multiply. SSE forces them to operate; * together.; *; * How this hack works:; * __asm__("""" // Declare an assembly block but don't declare any instructions; * : // However, as an Input/Output Operand,; * ""+r"" // constrain a read/write operand (+) as a general purpose register (r).; * (acc) // and set acc as the operand; * );; *; * Because of the 'r', the compiler has promised that seed will be in a; * general purpose register and the '+' says that it will be 'read/write',; * so it has to assume it has changed. It is like volatile without all the; * loads and stores.; *; * Since the argument has to be in a normal register (not an SSE register),; * each time XXH32_round is called, it is impossible to vectorize",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:293,avoid,avoid,293,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['avoid'],['avoid']
Safety,"/*; * We add two sentinel edges above and below all other edges,; * to avoid special cases at the top and bottom.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/sweep.c:71,avoid,avoid,71,graf3d/eve7/glu/sweep.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/glu/sweep.c,1,['avoid'],['avoid']
Safety,"/*; * Write frame header.; * This consists of DQT and SOFn markers, and a conditional pseudo SOS marker.; * Note that we do not emit the SOF until we have emitted the DQT(s).; * This avoids compatibility problems with incorrect implementations that; * try to error-check the quant table numbers as soon as they see the SOF.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmarker.c:183,avoid,avoids,183,graf2d/asimage/src/libAfterImage/libjpeg/jcmarker.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcmarker.c,1,['avoid'],['avoids']
Safety,"/*; * XXH3_64bits_withSecret():; * It's possible to provide any blob of bytes as a ""secret"" to generate the hash.; * This makes it more difficult for an external actor to prepare an intentional collision.; * The main condition is that secretSize *must* be large enough (>= XXH3_SECRET_SIZE_MIN).; * However, the quality of produced hash values depends on secret's entropy.; * Technically, the secret must look like a bunch of random bytes.; * Avoid ""trivial"" or structured data such as repeated sequences or a text document.; * Whenever unsure about the ""randomness"" of the blob of bytes,; * consider relabelling it as a ""custom seed"" instead,; * and employ ""XXH3_generateSecret()"" (see below); * to generate a high entropy secret derived from the custom seed.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:443,Avoid,Avoid,443,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['Avoid'],['Avoid']
Safety,"/*; * XXH3_hashLong_64b_withSeed():; * Generate a custom key based on alteration of default XXH3_kSecret with the seed,; * and then use this key for long mode hashing.; *; * This operation is decently fast but nonetheless costs a little bit of time.; * Try to avoid it whenever possible (typically when seed==0).; *; * It's important for performance that XXH3_hashLong is not inlined. Not sure; * why (uop cache maybe?), but the difference is large and easily measurable.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:260,avoid,avoid,260,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['avoid'],['avoid']
Safety,"/*; * XXH3_scrambleAcc: Scrambles the accumulators to improve mixing.; *; * Multiplication isn't perfect, as explained by Google in HighwayHash:; *; * // Multiplication mixes/scrambles bytes 0-7 of the 64-bit result to; * // varying degrees. In descending order of goodness, bytes; * // 3 4 2 5 1 6 0 7 have quality 228 224 164 160 100 96 36 32.; * // As expected, the upper and lower bytes are much worse.; *; * Source: https://github.com/google/highwayhash/blob/0aaf66b/highwayhash/hh_avx2.h#L291; *; * Since our algorithm uses a pseudorandom secret to add some variance into the; * mix, we don't need to (or want to) mix as often or as much as HighwayHash does.; *; * This isn't as tight as XXH3_accumulate, but still written in SIMD to avoid; * extraction.; *; * Both XXH3_64bits and XXH3_128bits use this subroutine.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:740,avoid,avoid,740,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['avoid'],['avoid']
Safety,"/*; * __pack instructions are safer but compiler specific, hence potentially; * problematic for some compilers.; *; * Currently only defined for GCC and ICC.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:30,safe,safer,30,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['safe'],['safer']
Safety,"/*; * __pack instructions are safer, but compiler specific, hence potentially; * problematic for some compilers.; *; * Currently only defined for GCC and ICC.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:30,safe,safer,30,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,1,['safe'],['safer']
Safety,"/*; * bits.c by Jean-loup Gailly and Kai Uwe Rommel.; *; * This is a new version of im_bits.c originally written by Richard B. Wales; *; * PURPOSE; *; * Output variable-length bit strings. Compression can be done; * to a file or to memory.; *; * DISCUSSION; *; * The PKZIP ""deflate"" file format interprets compressed file data; * as a sequence of bits. Multi-bit strings in the file may cross; * byte boundaries without restriction.; *; * The first bit of each byte is the low-order bit.; *; * The routines in this file allow a variable-length bit value to; * be output right-to-left (useful for literal values). For; * left-to-right output (useful for code strings from the tree routines),; * the bits must have been reversed first with R__bi_reverse().; *; * For in-memory compression, the compressed bit stream goes directly; * into the requested output buffer. The input data is read in blocks; * by the R__mem_read() function. The buffer is limited to 64K on 16 bit; * machines.; *; * INTERFACE; *; * void R__bi_init (bits_internal_state *state); * Initialize the bit string routines.; *; * void R__send_bits (int value, int length); * Write out a bit string, taking the source bits right to; * left.; *; * int R__bi_reverse (int value, int length); * Reverse the bits of a bit string, taking the source bits left to; * right and emitting them right to left.; *; * void R__bi_windup (void); * Write out any remaining bits in an incomplete byte.; *; * void R__copy_block(char far *buf, unsigned len, int header); * Copy a stored block to the zip file, storing first the length and; * its one's complement if requested.; *; * int R__seekable(void); * Return true if the zip file can be seeked.; *; * ulg R__memcompress (char *tgt, ulg tgtsize, char *src, ulg srcsize);; * Compress the source buffer src into the target buffer tgt.; */; // Global value of the compression level for the old compression algorithm.; // NOTE: Not thread-safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Bits.c:1936,safe,safe,1936,core/zip/src/Bits.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Bits.c,1,['safe'],['safe']
Safety,"/*; * deflate.c by Jean-loup Gailly.; *; * PURPOSE; *; * Identify new text as repetitions of old text within a fixed-; * length sliding window trailing behind the new text.; *; * DISCUSSION; *; * The ""deflation"" process depends on being able to identify portions; * of the input text which are identical to earlier input (within a; * sliding window trailing behind the input currently being processed).; *; * The most straightforward technique turns out to be the fastest for; * most input files: try all possible matches and select the longest.; * The key feature of this algorithm is that insertions into the string; * dictionary are very simple and thus fast, and deletions are avoided; * completely. Insertions are performed at each input character, whereas; * string matches are performed only when the previous match ends. So it; * is preferable to spend more time in matches to allow very fast string; * insertions and avoid deletions. The matching algorithm for small; * strings is inspired from that of Rabin & Karp. A brute force approach; * is used to find longer strings when a small match has been found.; * A similar algorithm is used in comic (by Jan-Mark Wams) and freeze; * (by Leonid Broukhis).; * A previous version of this file used a more sophisticated algorithm; * (by Fiala and Greene) which is guaranteed to run in linear amortized; * time, but has a larger average cost, uses more memory and is patented.; * However the F&G algorithm may be faster for some highly redundant; * files if the parameter max_chain_length (described below) is too large.; *; * ACKNOWLEDGEMENTS; *; * The idea of lazy evaluation of matches is due to Jan-Mark Wams, and; * I found it in 'freeze' written by Leonid Broukhis.; * Thanks to many info-zippers for bug reports and testing.; *; * REFERENCES; *; * APPNOTE.TXT documentation file in PKZIP 1.93a distribution.; *; * A description of the Rabin and Karp algorithm is given in the book; * ""Algorithms"" by R. Sedgewick, Addison-Wesley, p252.; *; *",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c:681,avoid,avoided,681,core/zip/src/ZDeflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/ZDeflate.c,2,['avoid'],"['avoid', 'avoided']"
Safety,"/*; * jcapistd.c; *; * Copyright (C) 1994-1996, Thomas G. Lane.; * This file is part of the Independent JPEG Group's software.; * For conditions of distribution and use, see the accompanying README file.; *; * This file contains application interface code for the compression half; * of the JPEG library. These are the ""standard"" API routines that are; * used in the normal full-compression case. They are not used by a; * transcoding-only application. Note that if an application links in; * jpeg_start_compress, it will end up linking in the entire compressor.; * We thus must separate this file from jcapimin.c to avoid linking the; * whole compression library into a transcoder.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcapistd.c:617,avoid,avoid,617,graf2d/asimage/src/libAfterImage/libjpeg/jcapistd.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jcapistd.c,1,['avoid'],['avoid']
Safety,"/*; * jdapistd.c; *; * Copyright (C) 1994-1996, Thomas G. Lane.; * This file is part of the Independent JPEG Group's software.; * For conditions of distribution and use, see the accompanying README file.; *; * This file contains application interface code for the decompression half; * of the JPEG library. These are the ""standard"" API routines that are; * used in the normal full-decompression case. They are not used by a; * transcoding-only application. Note that if an application links in; * jpeg_start_decompress, it will end up linking in the entire decompressor.; * We thus must separate this file from jdapimin.c to avoid linking the; * whole decompression library into a transcoder.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdapistd.c:625,avoid,avoid,625,graf2d/asimage/src/libAfterImage/libjpeg/jdapistd.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libjpeg/jdapistd.c,1,['avoid'],['avoid']
Safety,"/*; * parse structure, passed up and down to avoid global variables and; * other clumsinesses; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regcomp.c:45,avoid,avoid,45,interpreter/llvm-project/llvm/lib/Support/regcomp.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regcomp.c,1,['avoid'],['avoid']
Safety,"/*; * prod_hi = (data_key >> 32) * XXH_PRIME32_1;; *; * Avoid vmul_u32 + vshll_n_u32 since Clang 6 and 7 will; * incorrectly ""optimize"" this:; * tmp = vmul_u32(vmovn_u64(a), vmovn_u64(b));; * shifted = vshll_n_u32(tmp, 32);; * to this:; * tmp = ""vmulq_u64""(a, b); // no such thing!; * shifted = vshlq_n_u64(tmp, 32);; *; * However, unlike SSE, Clang lacks a 64-bit multiply routine; * for NEON, and it scalarizes two 64-bit multiplies instead.; *; * vmull_u32 has the same timing as vmul_u32, and it avoids; * this bug completely.; * See https://bugs.llvm.org/show_bug.cgi?id=39967; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h:56,Avoid,Avoid,56,builtins/xxhash/xxhash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/xxhash/xxhash.h,2,"['Avoid', 'avoid']","['Avoid', 'avoids']"
Safety,"/*; *_continue() :; These decoding functions allow decompression of multiple blocks in ""streaming"" mode.; Previously decoded blocks must still be available at the memory position where they were decoded.; If it's not possible, save the relevant part of decoded data into a safe buffer,; and indicate where it stands using LZ4_setStreamDecode(); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c:273,safe,safe,273,builtins/lz4/lz4.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/lz4/lz4.c,1,['safe'],['safe']
Safety,"/*; - p_bre - BRE parser top level, anchoring and concatenation; * Giving end1 as OUT essentially eliminates the end1/end2 check.; *; * This implementation is a bit of a kludge, in that a trailing $ is first; * taken as an ordinary character and then revised to be an anchor. The; * only undesirable side effect is that '$' gets included as a character; * category in such cases. This is fairly harmless; not worth fixing.; * The amount of lookahead needed to avoid this kludge is excessive.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regcomp.c:460,avoid,avoid,460,interpreter/llvm-project/llvm/lib/Support/regcomp.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/regcomp.c,1,['avoid'],['avoid']
Safety,"/*; Computation of p-values according to ; ""K-Sample Anderson-Darling Tests"" by F.W. Scholz ; and M.A. Stephens (1987), Journal of the American Statistical Association, ; Vol 82, No. 399, pp 918-924.; Code from kSamples package from R (author F. Scholtz). This function uses the upper T_m quantiles as obtained via simulation of; the Anderson-Darling test statistics (Nsim = 2*10^6) with sample sizes n=500; for each sample, and after standardization, in order to emulate the Table 1 ; values given in the above reference. However, here we estimate p-quantiles; for p = .00001,.00005,.0001,.0005,.001,.005,.01,.025,.05,.075,; .1,.2,.3,.4,.5,.6,.7,.8,.9,.925,.95,.975,.99,.9925,.995,.9975,.999,; .99925,.9995,.99975,.9999,.999925,.99995,.999975,.99999; First the appropriate p-quantiles are determined from those simulated; for ms = 1,2,3,4,6,8,10, Inf, interpolating to the given value of m. ; Since we use only m=2 we avoid this interpolation. . Next linear inetrpolation to find the observed p value given the observed test statistic value. ; We use interpolation in the test statistic -> log((1-p)/p) domain; and we extrapolatelinearly) beyond p = .00001 and .99999.; */; // sample values ; //double ms[] = { 1, 2, 3, 4, 6, 8, 10, TMath::Infinity() };; //int ns = ms.size();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/GoFTest.cxx:919,avoid,avoid,919,math/mathcore/src/GoFTest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/GoFTest.cxx,1,['avoid'],['avoid']
Safety,"/*; Decode literal, length, and distance codes and write out the resulting; literal and match bytes until either not enough input or output is; available, an end-of-block is encountered, or a data error is encountered.; When large enough input and output buffers are supplied to inflate(), for; example, a 16K input buffer and a 64K output buffer, more than 95% of the; inflate execution time is spent in this routine. Entry assumptions:. state->mode == LEN; strm->avail_in >= 6; strm->avail_out >= 258; start >= strm->avail_out; state->bits < 8. On return, state->mode is one of:. LEN -- ran out of enough output space or enough available input; TYPE -- reached end of block code, inflate() to interpret next block; BAD -- error in block data. Notes:. - The maximum input bits used by a length/distance pair is 15 bits for the; length code, 5 bits for the length extra, 15 bits for the distance code,; and 13 bits for the distance extra. This totals 48 bits, or six bytes.; Therefore if strm->avail_in >= 6, then there is enough input to avoid; checking for available input while decoding. - The maximum bytes that a single length/distance pair can output is 258; bytes, which is the maximum length that can be coded. inflate_fast(); requires strm->avail_out >= 258 for each loop to avoid checking for; output space.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inffast.c:1039,avoid,avoid,1039,builtins/zlib/inffast.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inffast.c,4,['avoid'],['avoid']
Safety,"/*; Initializes the compression dictionary from the given byte sequence; without producing any compressed output. This function must be called; immediately after deflateInit, deflateInit2 or deflateReset, before any; call of deflate. The compressor and decompressor must use exactly the same; dictionary (see inflateSetDictionary). The dictionary should consist of strings (byte sequences) that are likely; to be encountered later in the data to be compressed, with the most commonly; used strings preferably put towards the end of the dictionary. Using a; dictionary is most useful when the data to be compressed is short and can be; predicted with good accuracy; the data can then be compressed better than; with the default empty dictionary. Depending on the size of the compression data structures selected by; deflateInit or deflateInit2, a part of the dictionary may in effect be; discarded, for example if the dictionary is larger than the window size in; deflate or deflate2. Thus the strings most likely to be useful should be; put at the end of the dictionary, not at the front. In addition, the; current implementation of deflate will use at most the window size minus; 262 bytes of the provided dictionary. Upon return of this function, strm->adler is set to the adler32 value; of the dictionary; the decompressor may later use this value to determine; which dictionary has been used by the compressor. (The adler32 value; applies to the whole dictionary even if only a subset of the dictionary is; actually used by the compressor.) If a raw deflate was requested, then the; adler32 value is not computed and strm->adler is not set. deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a; parameter is invalid (such as NULL dictionary) or the stream state is; inconsistent (for example if deflate has already been called for this stream; or if the compression method is bsort). deflateSetDictionary does not; perform any compression: this will be done by deflate().; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:635,predict,predicted,635,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['predict'],['predicted']
Safety,"/*; Initializes the compression dictionary from the given byte sequence; without producing any compressed output. When using the zlib format, this; function must be called immediately after deflateInit, deflateInit2 or; deflateReset, and before any call of deflate. When doing raw deflate, this; function must be called either before any call of deflate, or immediately; after the completion of a deflate block, i.e. after all input has been; consumed and all output has been delivered when using any of the flush; options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH. The; compressor and decompressor must use exactly the same dictionary (see; inflateSetDictionary). The dictionary should consist of strings (byte sequences) that are likely; to be encountered later in the data to be compressed, with the most commonly; used strings preferably put towards the end of the dictionary. Using a; dictionary is most useful when the data to be compressed is short and can be; predicted with good accuracy; the data can then be compressed better than; with the default empty dictionary. Depending on the size of the compression data structures selected by; deflateInit or deflateInit2, a part of the dictionary may in effect be; discarded, for example if the dictionary is larger than the window size; provided in deflateInit or deflateInit2. Thus the strings most likely to be; useful should be put at the end of the dictionary, not at the front. In; addition, the current implementation of deflate will use at most the window; size minus 262 bytes of the provided dictionary. Upon return of this function, strm->adler is set to the adler32 value; of the dictionary; the decompressor may later use this value to determine; which dictionary has been used by the compressor. (The adler32 value; applies to the whole dictionary even if only a subset of the dictionary is; actually used by the compressor.) If a raw deflate was requested, then the; adler32 value is not computed and strm->adler is n",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:982,predict,predicted,982,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['predict'],['predicted']
Safety,"/*; Reads the given number of uncompressed bytes from the compressed file. If; the input file is not in gzip format, gzread copies the given number of; bytes into the buffer directly from the file. After reaching the end of a gzip stream in the input, gzread will continue; to read, looking for another gzip stream. Any number of gzip streams may be; concatenated in the input file, and will all be decompressed by gzread().; If something other than a gzip stream is encountered after a gzip stream,; that remaining trailing garbage is ignored (and no error is returned). gzread can be used to read a gzip file that is being concurrently written.; Upon reaching the end of the input, gzread will return with the available; data. If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then; gzclearerr can be used to clear the end of file indicator in order to permit; gzread to be tried again. Z_OK indicates that a gzip stream was completed; on the last gzread. Z_BUF_ERROR indicates that the input file ended in the; middle of a gzip stream. Note that gzread does not return -1 in the event; of an incomplete gzip stream. This error is deferred until gzclose(), which; will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip; stream. Alternatively, gzerror can be used before gzclose to detect this; case. gzread returns the number of uncompressed bytes actually read, less than; len for end of file, or -1 for error.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:1313,detect,detect,1313,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['detect'],['detect']
Safety,"/*; Return from inflate(), updating the total counts and the check value.; If there was no progress during the inflate() call, return a buffer; error. Call updatewindow() to create and/or update the window state.; Note: a memory error from inflate() is non-recoverable.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c:257,recover,recoverable,257,builtins/zlib/inflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c,2,['recover'],['recoverable']
Safety,"/*; Return state with length and distance decoding tables and index sizes set to; fixed code decoding. Normally this returns fixed tables from inffixed.h.; If BUILDFIXED is defined, then instead this routine builds the tables the; first time it's called, and returns those tables the first time and; thereafter. This reduces the size of the code by about 2K bytes, in; exchange for a little execution time. However, BUILDFIXED should not be; used for threaded applications, since the rewriting of the tables and virgin; may not be thread-safe.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/infback.c:538,safe,safe,538,builtins/zlib/infback.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/infback.c,4,['safe'],['safe']
Safety,"/*; Returns 1 when EOF has previously been detected reading the given; input stream, otherwise zero.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:43,detect,detected,43,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['detect'],['detected']
Safety,"/*; Returns true (1) if the end-of-file indicator has been set while reading,; false (0) otherwise. Note that the end-of-file indicator is set only if the; read tried to go past the end of the input, but came up short. Therefore,; just like feof(), gzeof() may return false even if there is no more data to; read, in the event that the last read request was for the exact number of; bytes remaining in the input file. This will happen if the input file size; is an exact multiple of the buffer size. If gzeof() returns true, then the read functions will return no more data,; unless the end-of-file indicator is reset by gzclearerr() and the input file; has grown since the previous end of file was detected.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:699,detect,detected,699,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['detect'],['detected']
Safety,"/*; Returns true if inflate is currently at the end of a block generated by; Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP; implementation to provide an additional safety check. PPP uses; Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored; block. When decompressing, PPP checks that at the end of input packet,; inflate is waiting for these length bytes.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c:181,safe,safety,181,builtins/zlib/inflate.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inflate.c,2,['safe'],['safety']
Safety,"/*; RooNLLVar* nll = new RooNLLVar(""nll"","""",*pdf,*data, Extended(),Constrain(*constrainedParams));; RooProfileLL* profile = new RooProfileLL(""pll"","""",*nll, *fPOI);; profile->addOwnedComponents(*nll) ; // to avoid memory leak; */; // do a global fit cloning the data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ProfileLikelihoodCalculator.cxx:207,avoid,avoid,207,roofit/roostats/src/ProfileLikelihoodCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ProfileLikelihoodCalculator.cxx,1,['avoid'],['avoid']
Safety,"/*; Same as gzclose(), but gzclose_r() is only for use when reading, and; gzclose_w() is only for use when writing or appending. The advantage to; using these instead of gzclose() is that they avoid linking in zlib; compression or decompression code that is not used when only reading or only; writing respectively. If gzclose() is used, then both compression and; decompression code will be included the application when linking to a static; zlib library.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:193,avoid,avoid,193,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['avoid'],['avoid']
Safety,"/*; The application must update next_in and avail_in when avail_in has dropped; to zero. It must update next_out and avail_out when avail_out has dropped; to zero. The application must initialize zalloc, zfree and opaque before; calling the init function. All other fields are set by the compression; library and must not be updated by the application. The opaque value provided by the application will be passed as the first; parameter for calls of zalloc and zfree. This can be useful for custom; memory management. The compression library attaches no meaning to the; opaque value. zalloc must return Z_NULL if there is not enough memory for the object.; If zlib is used in a multi-threaded application, zalloc and zfree must be; thread safe. On 16-bit systems, the functions zalloc and zfree must be able to allocate; exactly 65536 bytes, but will not be required to allocate more than this if; the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS, pointers; returned by zalloc for objects of exactly 65536 bytes *must* have their; offset normalized to zero. The default allocation function provided by this; library ensures this (see zutil.c). To reduce memory requirements and avoid; any allocation of 64K objects, at the expense of compression ratio, compile; the library with -DMAX_WBITS=14 (see zconf.h). The fields total_in and total_out can be used for statistics or progress; reports. After compression, total_in holds the total size of the; uncompressed data and may be saved for use in the decompressor (particularly; if the decompressor wants to decompress everything in a single step).; */; /* constants */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:739,safe,safe,739,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"/*; The application must update next_in and avail_in when avail_in has; dropped to zero. It must update next_out and avail_out when avail_out; has dropped to zero. The application must initialize zalloc, zfree and; opaque before calling the init function. All other fields are set by the; compression library and must not be updated by the application. The opaque value provided by the application will be passed as the first; parameter for calls of zalloc and zfree. This can be useful for custom; memory management. The compression library attaches no meaning to the; opaque value. zalloc must return Z_NULL if there is not enough memory for the object.; If zlib is used in a multi-threaded application, zalloc and zfree must be; thread safe. On 16-bit systems, the functions zalloc and zfree must be able to allocate; exactly 65536 bytes, but will not be required to allocate more than this; if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,; pointers returned by zalloc for objects of exactly 65536 bytes *must*; have their offset normalized to zero. The default allocation function; provided by this library ensures this (see zutil.c). To reduce memory; requirements and avoid any allocation of 64K objects, at the expense of; compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h). The fields total_in and total_out can be used for statistics or; progress reports. After compression, total_in holds the total size of; the uncompressed data and may be saved for use in the decompressor; (particularly if the decompressor wants to decompress everything in; a single step).; */; /* constants */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:739,safe,safe,739,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"/*; The following code does a BFS traversal of the `PtrAssignmentGraph`; considering all unsafe vars as starting nodes and constructs an undirected; graph `DependenciesMap`. Constructing the `DependenciesMap` in this manner; elimiates all variables that are unreachable from any unsafe var. In other; words, this removes all dependencies that don't include any unsafe variable; and consequently don't need any fixit generation.; Note: A careful reader would observe that the code traverses; `PtrAssignmentGraph` using `CurrentVar` but adds edges between `Var` and; `Adj` and not between `CurrentVar` and `Adj`. Both approaches would; achieve the same result but the one used here dramatically cuts the; amount of hoops the second part of the algorithm needs to jump, given that; a lot of these connections become ""direct"". The reader is advised not to; imagine how the graph is transformed because of using `Var` instead of; `CurrentVar`. The reader can continue reading as if `CurrentVar` was used,; and think about why it's equivalent later.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:89,unsafe,unsafe,89,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,3,['unsafe'],['unsafe']
Safety,"/*; The logic here is the following - we have bool name - it shows if we have read (or are reading) an attribute name; bool equalfound - shows if we have found the = symbol after the name; bool value - shows if we have found or are reading the attribute value; bool newattr - do we have other attributes to read; char lastsymbol - I use it to detect a situation like name = xx""value""; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/XMLReader.cxx:343,detect,detect,343,core/dictgen/src/XMLReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/XMLReader.cxx,1,['detect'],['detect']
Safety,"/*; ToDo list for expanding this check in the future, the list is not exhaustive.; There are also cases where calling super is suggested but not ""mandatory"".; In addition to be able to check the classes and methods below, architectural; improvements like being able to allow for the super-call to be done in a called; method would be good too. UIDocument subclasses; - finishedHandlingError:recovered: (is multi-arg); - finishedHandlingError:recovered: (is multi-arg). UIViewController subclasses; - loadView (should *never* call super); - transitionFromViewController:toViewController:; duration:options:animations:completion: (is multi-arg). UICollectionViewController subclasses; - loadView (take care because UIViewController subclasses should NOT call super; in loadView, but UICollectionViewController subclasses should). NSObject subclasses; - doesNotRecognizeSelector (it only has to call super if it doesn't throw). UIPopoverBackgroundView subclasses (some of those are class methods); - arrowDirection (should *never* call super); - arrowOffset (should *never* call super); - arrowBase (should *never* call super); - arrowHeight (should *never* call super); - contentViewInsets (should *never* call super). UITextSelectionRect subclasses (some of those are properties); - rect (should *never* call super); - range (should *never* call super); - writingDirection (should *never* call super); - isVertical (should *never* call super); - containsStart (should *never* call super); - containsEnd (should *never* call super); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp:391,recover,recovered,391,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCMissingSuperCallChecker.cpp,2,['recover'],['recovered']
Safety,"/*; gzdopen associates a gzFile with the file descriptor fd. File descriptors; are obtained from calls like open, dup, creat, pipe or fileno (if the file; has been previously opened with fopen). The mode parameter is as in gzopen. The next call of gzclose on the returned gzFile will also close the file; descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor; fd. If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,; mode);. The duplicated descriptor should be saved to avoid a leak, since; gzdopen does not close fd if it fails. If you are using fileno() to get the; file descriptor from a FILE *, then you will have to use dup() to avoid; double-close()ing the file descriptor. Both gzclose() and fclose() will; close the associated file descriptor, so they need to have different file; descriptors. gzdopen returns NULL if there was insufficient memory to allocate the; gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not; provided, or '+' was provided), or if fd is -1. The file descriptor is not; used until the next gz* read, write, seek, or close operation, so gzdopen; will not detect if fd is invalid (unless fd is -1).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:510,avoid,avoid,510,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,3,"['avoid', 'detect']","['avoid', 'detect']"
Safety,"/*; inflateBack() does a raw inflate with a single call using a call-back; interface for input and output. This is more efficient than inflate() for; file i/o applications in that it avoids copying between the output and the; sliding window by simply making the window itself the output buffer. This; function trusts the application to not change the output buffer passed by; the output function, at least until inflateBack() returns. inflateBackInit() must be called first to allocate the internal state; and to initialize the state with the user-provided window buffer.; inflateBack() may then be used multiple times to inflate a complete, raw; deflate stream with each call. inflateBackEnd() is then called to free; the allocated state. A raw deflate stream is one with no zlib or gzip header or trailer.; This routine would normally be used in a utility that reads zip or gzip; files and writes out uncompressed files. The utility would decode the; header and process the trailer on its own, hence this routine expects; only the raw deflate stream to decompress. This is different from the; normal behavior of inflate(), which expects either a zlib or gzip header and; trailer around the deflate stream. inflateBack() uses two subroutines supplied by the caller that are then; called by inflateBack() for input and output. inflateBack() calls those; routines until it reads a complete deflate stream and writes out all of the; uncompressed data, or until it encounters an error. The function's; parameters and return types are defined above in the in_func and out_func; typedefs. inflateBack() will call in(in_desc, &buf) which should return the; number of bytes of provided input, and a pointer to that input in buf. If; there is no input available, in() must return zero--buf is ignored in that; case--and inflateBack() will return a buffer error. inflateBack() will call; out(out_desc, buf, len) to write the uncompressed data buf[0..len-1]. out(); should return zero on success, or non-zero on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h:183,avoid,avoids,183,graf2d/asimage/src/libAfterImage/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/zlib.h,1,['avoid'],['avoids']
Safety,"/*; inflateBack() does a raw inflate with a single call using a call-back; interface for input and output. This is potentially more efficient than; inflate() for file i/o applications, in that it avoids copying between the; output and the sliding window by simply making the window itself the output; buffer. inflate() can be faster on modern CPUs when used with large; buffers. inflateBack() trusts the application to not change the output; buffer passed by the output function, at least until inflateBack() returns. inflateBackInit() must be called first to allocate the internal state; and to initialize the state with the user-provided window buffer.; inflateBack() may then be used multiple times to inflate a complete, raw; deflate stream with each call. inflateBackEnd() is then called to free the; allocated state. A raw deflate stream is one with no zlib or gzip header or trailer.; This routine would normally be used in a utility that reads zip or gzip; files and writes out uncompressed files. The utility would decode the; header and process the trailer on its own, hence this routine expects only; the raw deflate stream to decompress. This is different from the normal; behavior of inflate(), which expects either a zlib or gzip header and; trailer around the deflate stream. inflateBack() uses two subroutines supplied by the caller that are then; called by inflateBack() for input and output. inflateBack() calls those; routines until it reads a complete deflate stream and writes out all of the; uncompressed data, or until it encounters an error. The function's; parameters and return types are defined above in the in_func and out_func; typedefs. inflateBack() will call in(in_desc, &buf) which should return the; number of bytes of provided input, and a pointer to that input in buf. If; there is no input available, in() must return zero--buf is ignored in that; case--and inflateBack() will return a buffer error. inflateBack() will call; out(out_desc, buf, len) to write the un",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h:196,avoid,avoids,196,builtins/zlib/zlib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/zlib.h,1,['avoid'],['avoids']
Safety,"/*; inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):; - Using bit fields for code structure; - Different op definition to avoid & for extra bits (do & for table bits); - Three separate decoding do-loops for direct, window, and wnext == 0; - Special case for distance > 1 copies to do overlapped load and store copy; - Explicit branch predictions (based on measured branch probabilities); - Deferring match copy and interspersed it with decoding subsequent codes; - Swapping literal/length else; - Swapping window/direct else; - Larger unrolled copy loops (three is about right); - Moving len -= 3 statement into middle of loop; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inffast.c:146,avoid,avoid,146,builtins/zlib/inffast.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zlib/inffast.c,2,"['avoid', 'predict']","['avoid', 'predictions']"
Safety,"/*; inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):; - Using bit fields for code structure; - Different op definition to avoid & for extra bits (do & for table bits); - Three separate decoding do-loops for direct, window, and write == 0; - Special case for distance > 1 copies to do overlapped load and store copy; - Explicit branch predictions (based on measured branch probabilities); - Deferring match copy and interspersed it with decoding subsequent codes; - Swapping literal/length else; - Swapping window/direct else; - Larger unrolled copy loops (three is about right); - Moving len -= 3 statement into middle of loop; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inffast.c:146,avoid,avoid,146,graf2d/asimage/src/libAfterImage/zlib/inffast.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/zlib/inffast.c,2,"['avoid', 'predict']","['avoid', 'predictions']"
Safety,/*===-- llvm-c/blake3.h - BLAKE3 C Interface ----------------------*- C -*-===*\; |* *|; |* Released into the public domain with CC0 1.0 *|; |* See 'llvm/lib/Support/BLAKE3/LICENSE' for info. *|; |* SPDX-License-Identifier: CC0-1.0 *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to LLVM's BLAKE3 implementation. *|; |* Original BLAKE3 C API: https://github.com/BLAKE3-team/BLAKE3/tree/1.3.1/c *|; |* *|; |* Symbols are prefixed with 'llvm' to avoid a potential conflict with *|; |* another BLAKE3 version within the same program. *|; |* *|; \*===----------------------------------------------------------------------===*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h:536,avoid,avoid,536,interpreter/llvm-project/llvm/include/llvm-c/blake3.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h,1,['avoid'],['avoid']
Safety,"/*===---- builtins.h - Standard header for extra builtins -----------------===*\; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; \*===----------------------------------------------------------------------===*/; /// Some legacy compilers have builtin definitions in a file named builtins.h.; /// This header file has been added to allow compatibility with code that was; /// written for those compilers. Code may have an include line for this file; /// and to avoid an error an empty file with this name is provided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/builtins.h:619,avoid,avoid,619,interpreter/llvm-project/clang/lib/Headers/builtins.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/builtins.h,1,['avoid'],['avoid']
Safety,"/*===---- cpuid.h - X86 cpu model detection --------------------------------===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cpuid.h:34,detect,detection,34,interpreter/llvm-project/clang/lib/Headers/cpuid.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cpuid.h,1,['detect'],['detection']
Safety,"/*===---- openmp_wrapper/math.h -------- OpenMP math.h intercept ------ c++ -===; *; * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; * See https://llvm.org/LICENSE.txt for license information.; * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; *; *===-----------------------------------------------------------------------===; */; // If we are in C++ mode and include <math.h> (not <cmath>) first, we still need; // to make sure <cmath> is read first. The problem otherwise is that we haven't; // seen the declarations of the math.h functions when the system math.h includes; // our cmath overlay. However, our cmath overlay, or better the underlying; // overlay, e.g. CUDA, uses the math.h functions. Since we haven't declared them; // yet we get errors. CUDA avoids this by eagerly declaring all math functions; // (in the __device__ space) but we cannot do this. Instead we break the; // dependence by forcing cmath to go first. While our cmath will in turn include; // this file, the cmath guards will prevent recursion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h:803,avoid,avoids,803,interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/openmp_wrappers/math.h,1,['avoid'],['avoids']
Safety,"/*===== Streaming decompression functions =====*/; /* This function is redundant with the advanced API and equivalent to:; *; * ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);; * ZSTD_DCtx_refDDict(zds, NULL);; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h:71,redund,redundant,71,builtins/zstd/zstd.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/zstd/zstd.h,1,['redund'],['redundant']
Safety,/*Abort=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:2,Abort,Abort,2,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,1,['Abort'],['Abort']
Safety,/*AbortOnError=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/ReducerWorkItem.cpp:2,Abort,AbortOnError,2,interpreter/llvm-project/llvm/tools/llvm-reduce/ReducerWorkItem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/ReducerWorkItem.cpp,2,['Abort'],['AbortOnError']
Safety,/*AvoidBinPacking=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:2,Avoid,AvoidBinPacking,2,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,2,['Avoid'],['AvoidBinPacking']
Safety,/*AvoidPartialAvailabilityChecks=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:2,Avoid,AvoidPartialAvailabilityChecks,2,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['Avoid'],['AvoidPartialAvailabilityChecks']
Safety,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingBaseClassInfo.cxx:2,Detect,DetectVirtual,2,core/metacling/src/TClingBaseClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingBaseClassInfo.cxx,24,['Detect'],['DetectVirtual']
Safety,/*Recover*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:2,Recover,Recover,2,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,3,['Recover'],['Recover']
Safety,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:2,Recover,RecoverUncorrectedTypos,2,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,9,['Recover'],['RecoverUncorrectedTypos']
Safety,/*RecoverableErrorHandler=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp:2,Recover,RecoverableErrorHandler,2,interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-gsymutil/llvm-gsymutil.cpp,1,['Recover'],['RecoverableErrorHandler']
Safety,/*SAFE*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c:2,SAFE,SAFE,2,graf2d/asimage/src/libAfterImage/libpng/png.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/libpng/png.c,10,['SAFE'],['SAFE']
Safety,/*abort*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/test/TClingCallFuncTests.cxx:2,abort,abort,2,core/metacling/test/TClingCallFuncTests.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/test/TClingCallFuncTests.cxx,4,['abort'],['abort']
Safety,/*auto-detect base*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/RTaskArena.cxx:7,detect,detect,7,core/imt/src/RTaskArena.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/RTaskArena.cxx,1,['detect'],['detect']
Safety,"/*avoid ""unsigned >= 0"" condition*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/Getline_color.cxx:2,avoid,avoid,2,core/textinput/src/Getline_color.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/Getline_color.cxx,1,['avoid'],['avoid']
Safety,/*bool DetectVirtual=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:7,Detect,DetectVirtual,7,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['Detect'],['DetectVirtual']
Safety,/*safe*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoArb8.cxx:2,safe,safe,2,geom/geom/src/TGeoArb8.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoArb8.cxx,5,['safe'],['safe']
Safety,/*timeout*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx:2,timeout,timeout,2,tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx,2,['timeout'],['timeout']
Safety,/*timeout=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp:2,timeout,timeout,2,interpreter/llvm-project/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp,1,['timeout'],['timeout']
Safety,/*unsafe*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:2,unsafe,unsafe,2,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['unsafe'],['unsafe']
Safety,"// !_WIN32; // Generic POSIX implementation.; //; // This implementation relies on synchronous signals being delivered to the; // current thread. We use a thread local object to keep track of the active; // crash recovery context, and install signal handlers to invoke HandleCrash on; // the active object.; //; // This implementation does not attempt to chain signal handlers in any; // reliable fashion -- if we get a signal outside of a crash recovery context we; // simply disable crash recovery and raise the signal again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp:213,recover,recovery,213,interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,3,['recover'],['recovery']
Safety,"// !annotation metadata does not impact semantics.; // !range, !nonnull and !align produce poison, so they are safe to speculate.; // !noundef and various AA metadata must be dropped, as it generally produces; // immediate undefined behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp:111,safe,safe,111,interpreter/llvm-project/llvm/lib/IR/Instruction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instruction.cpp,1,['safe'],['safe']
Safety,"// !isSigned to avoid strings beginning with ""-+""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx:16,avoid,avoid,16,core/base/src/TString.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx,1,['avoid'],['avoid']
Safety,"// "".abort""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:5,abort,abort,5,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,1,['abort'],['abort']
Safety,"// ""C:\dir"" becomes ""C:::dir"".; // fname corresponds to whatever is stated after #include and; // a full path name usually means that it's not a regular #include; // but e.g. a "".L"", so we can assume that this is not a header of; // a class in a namespace (a global-namespace class would have been; // detected already before).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:302,detect,detected,302,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['detect'],['detected']
Safety,"// ""Loopers"" are blocks that are in a loop. We detect these by finding blocks; // that can reach themselves.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:47,detect,detect,47,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,1,['detect'],['detect']
Safety,"// ""Under /fp:strict, the compiler generates code that allows the; // program to safely unmask floating-point exceptions, read or write; // floating-point status registers, or change rounding modes.""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp:81,safe,safely,81,interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp,1,['safe'],['safely']
Safety,"// ""do {} while (0)"" is common in macros, avoid extra blocks. Be sure; // to correctly handle break/continue though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp:42,avoid,avoid,42,interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,1,['avoid'],['avoid']
Safety,"// ""goto *&&lbl;"" is a special case which we treat as equivalent; // to a normal goto. In addition, we don't calculate scope in the; // operand (to avoid recording the address-of-label use), which; // works only because of the restricted set of expressions which; // we detect as constant targets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:148,avoid,avoid,148,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,2,"['avoid', 'detect']","['avoid', 'detect']"
Safety,"// ""mov lr, pc; b _foo"" to avoid confusing the RSP",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:27,avoid,avoid,27,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// ""va-arg"" from a pointer is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:30,safe,safe,30,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,2,['safe'],['safe']
Safety,"// #### Couldn't parallelize this part (filtering events from mother node to daughter nodes); // #### ... would need to avoid the push_back or use some threadsafe mutex locked version...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DecisionTree.cxx:120,avoid,avoid,120,tmva/tmva/src/DecisionTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DecisionTree.cxx,1,['avoid'],['avoid']
Safety,"// ##TODO; // Lex the argument identifiers so we can know if this is a declaration; // RVAL IDENT(A,B,C) -> could be:; //; // T inst(a,b,c); -> class instance; // T func(T0 a, T1 b, T2 c); -> func declaration; //; // Without macro expansion it's difficult to distinguish cases, but as the; // detection can fail because of macros already, would it be enough to check; // that there are two idents not separated by commas between parenthesis?; // It still wouldn't work for RVAL IDENT(), but -Wno-vexing-parse could be; // passed to clang in initialization.; //; // Maybe the best would be to lookup the Decl IDENT to see if its a class?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp:293,detect,detection,293,interpreter/cling/lib/Utils/SourceNormalization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp,1,['detect'],['detection']
Safety,"// #define R__CHECK_COLLECTION_MULTI_ACCESS; // When R__CHECK_COLLECTION_MULTI_ACCESS is turned on (defined),; // the normal (not locked) ROOT TCollections are instrumented with a; // pseudo read-write lock which does not halt the execution but detects; // and report concurrent access to the same collections.; // Multiple readers are allowed.; // Multiple concurrent writer is reported as a Conflict; // Readers access while a write is running is reported as Conflict; // Re-entrant writing call by the same Writer thread are allowed.; // Entering a writing section by a single Reader thread is allowed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollection.h:245,detect,detects,245,core/cont/inc/TCollection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollection.h,1,['detect'],['detects']
Safety,// %vreg = COPY $physreg; // Avoid using a datastructure which can track multiple live non-allocatable; // phys->virt copies since LLVM doesn't seem to do this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:29,Avoid,Avoid,29,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['Avoid'],['Avoid']
Safety,"// 'Consume' the baskets (i.e. avoid looking at it during a subsequent pass)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:31,avoid,avoid,31,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['avoid'],['avoid']
Safety,"// 'Insure' gROOT is created before initializing the Thread safe behavior; // (to make sure we do not have two attempting to create it).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx:60,safe,safe,60,core/thread/src/TThread.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx,1,['safe'],['safe']
Safety,"// 'TStreamerInfo::' avoids going via a virtual function.; // Check that the buffer position corresponds to the byte count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:21,avoid,avoids,21,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,2,['avoid'],['avoids']
Safety,"// 'inline' must appear on the original definition, but not necessarily; // on all extension definitions, so the note should point to the first; // definition to avoid confusion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:162,avoid,avoid,162,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['avoid'],['avoid']
Safety,"// 'move %FramePtr, SP' will not be recognized as an epilogue sequence.; // However, we may use this sequence if we have a frame pointer because the; // effects of the prologue can safely be undone.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:181,safe,safely,181,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,1,['safe'],['safely']
Safety,// (A*B)/C --> A*(B/C) if safe and B/C can be folded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:26,safe,safe,26,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['safe'],['safe']
Safety,// (A+B)/C --> (A/C + B/C) if safe and A/C and B/C can be folded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:30,safe,safe,30,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['safe'],['safe']
Safety,// (A/B)/C --> A/(B*C) if safe and B*C can be folded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:26,safe,safe,26,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['safe'],['safe']
Safety,// (Repeatedly) merging blocks into their predecessors can create redundant; // debug intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:66,redund,redundant,66,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['redund'],['redundant']
Safety,"// (X & Y) != 0 --> (X & Y) == Y iff Y is power-of-2.; // Revert part of the simplifySetCCWithAnd combine, to avoid an invert.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:110,avoid,avoid,110,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// (X | C1) & C2 --> (X & C2^(C1&C2)) | (C1&C2); // NOTE: This reduces the number of bits set in the & mask, which; // can expose opportunities for store narrowing for scalars.; // NOTE: SimplifyDemandedBits should have already removed bits from C1; // that aren't set in C2. Meaning we can replace (C1&C2) with C1 in; // above, but this feels safer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:344,safe,safer,344,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['safe'],['safer']
Safety,"// (a): Very fast checks against top box and global caching; // (b): Use voxel cached best safety; // (c): Use voxel candidates (fetch them if they are not yet initialized)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:91,safe,safety,91,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['safe'],['safety']
Safety,"// (gep X, ...) - (gep X, ...); //; // Avoid duplicating the arithmetic if there are more than one non-constant; // indices between the two GEPs and either GEP has a non-constant index and; // multiple users. If zero non-constant index, the result is a constant and; // there is no duplication. If one non-constant index, the result is an add; // or sub with a constant, which is no larger than the original code, and; // there's no duplicated arithmetic, even if either GEP has multiple; // users. If more than one non-constant indices combined, as long as the GEP; // with at least one non-constant index doesn't have multiple users, there; // is no duplication.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:39,Avoid,Avoid,39,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['Avoid'],['Avoid']
Safety,"// (tbz (any_ext x), b) -> (tbz x, b) if we don't use the extended bits.; //; // (tbz (trunc x), b) -> (tbz x, b) is always safe, because the bit number; // on the truncated x is the same as the bit number on x.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:124,safe,safe,124,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['safe'],['safe']
Safety,// (~A | B) ^ (A & B) --> ~A -- There are 8 commuted variants.; // The 'not' op must contain a complete -1 operand (no undef elements for; // vector) for the transform to be safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:174,safe,safe,174,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['safe'],['safe']
Safety,// * Use LDE instead of LE/LEY for z13 to avoid partial register; // dependencies (LDE only supports small offsets).; // * Utilize the vector registers to hold floating point; // values (vector load / store instructions only support small; // offsets).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:42,avoid,avoid,42,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// *** Predictor step ***",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TGondzioSolver.cxx:7,Predict,Predictor,7,math/quadp/src/TGondzioSolver.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TGondzioSolver.cxx,2,['Predict'],['Predictor']
Safety,"// ***************************************************************************; // Look for obvious safe cases to perform tail call optimization that do not; // require ABI changes.; // ***************************************************************************; // If this is a tail call via a function pointer, then don't do it!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:100,safe,safe,100,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['safe'],['safe']
Safety,"// ***************************************************; // Warning: Here, everything needs to be thread safe:; // ***************************************************",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:104,safe,safe,104,tree/dataframe/inc/ROOT/RDFHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx,1,['safe'],['safe']
Safety,"// - For left shifts, do the transform as long as the shift; // amount is still legal for i32, so when ShiftAmt < 32 (<= 31); // - For right shift, do it if ShiftAmt <= (32 - Size) to avoid; // losing information stored in the high bits when truncating.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:184,avoid,avoid,184,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// - Instructions including RST register class operands are not relevant; // for memory folding (for further details check the explanation in; // lib/Target/X86/X86InstrFPStack.td file).; // - Some instructions (listed in the manual map above) use the register; // class ptr_rc_tailcall, which can be of a size 32 or 64, to ensure; // safe mapping of these instruction we manually map them and exclude; // them from the automation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86FoldTablesEmitter.cpp:335,safe,safe,335,interpreter/llvm-project/llvm/utils/TableGen/X86FoldTablesEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86FoldTablesEmitter.cpp,1,['safe'],['safe']
Safety,"// -(X-Y) -> (Y-X) is unsafe because when X==Y, -0.0 != +0.0; // FIXME: This is duplicated in getNegatibleCost, but getNegatibleCost doesn't; // know it was called from a context with a nsz flag if the input fsub does; // not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:22,unsafe,unsafe,22,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['unsafe'],['unsafe']
Safety,"// -- Elide the base-class sub-branches of a split TClonesArray or STL container.; //; // Note: We are eliding the base class here, that is, we never; // create a branch for it, so the branch hierarchy is not; // complete.; // Note: The clParent parameter is the value class of the; // container which we are splitting. It does not; // appear in the branch hierarchy either.; // Note: We can use parent class (clParent) != branch class (elemClass) to detection elision.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:451,detect,detection,451,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['detect'],['detection']
Safety,"// -- If the branch's name is the same as the base class name,; // which happens when we are a child branch of a top-level; // branch whose name does not end in a dot and also has no; // internal dots, elide the branch name, and keep the branch; // hierarchy rooted at the ultimate parent, this keeps the base; // class part of the branch name from propagating downwards.; // FIXME: We are eliding the base class here, creating a break in the branch hierarchy.; // Note: We can use parent class (cltop) != branch class (elemClass) to detection elision.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:534,detect,detection,534,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['detect'],['detection']
Safety,"// -- The interleave heuristics --; // We interleave the loop in order to expose ILP and reduce the loop overhead.; // There are many micro-architectural considerations that we can't predict; // at this level. For example, frontend pressure (on decode or fetch) due to; // code size, or the number and capabilities of the execution ports.; //; // We use the following heuristics to select the interleave count:; // 1. If the code has reductions, then we interleave to break the cross; // iteration dependency.; // 2. If the loop is really small, then we interleave to reduce the loop; // overhead.; // 3. We don't interleave if we think that we will spill registers to memory; // due to the increased register pressure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:183,predict,predict,183,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['predict'],['predict']
Safety,"// ------ Operations combining two vectors ------; // -- need to have the specialized version in order to avoid; /**; Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/DisplacementVector2D.h:106,avoid,avoid,106,math/genvector/inc/Math/GenVector/DisplacementVector2D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/DisplacementVector2D.h,2,['avoid'],['avoid']
Safety,"// -----------------------------------------------------------------------------; // Class that describes an ACLE intrinsic implemented as a macro.; //; // This class is used when the intrinsic is polymorphic in 2 or 3 types, but we; // want to avoid a combinatorial explosion by reinterpreting the arguments to; // fixed types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:245,avoid,avoid,245,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,1,['avoid'],['avoid']
Safety,"// -1 means no longjmp happened, continue normally (will hit the default; // switch case). 0 means a longjmp that is not ours to handle, needs a; // rethrow. Otherwise the index is the same as the index in P+1 (to avoid; // 0).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:214,avoid,avoid,214,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,2,['avoid'],['avoid']
Safety,"// -fno-pic sets dso_local on a function declaration to allow direct; // accesses when taking its address (similar to a data symbol). If the; // function is not defined in the executable, a canonical PLT entry will be; // needed at link time. -fno-direct-access-external-data can avoid the; // canonical PLT entry. We don't generalize this condition to -fpie/-fpic as; // it could just cause trouble without providing perceptible benefits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:280,avoid,avoid,280,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['avoid'],['avoid']
Safety,// -fsanitize-trap= overrides -fsanitize-recover=.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:41,recover,recover,41,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['recover'],['recover']
Safety,"// -fsanitize=function and -fsanitize=kcfi instrument indirect function calls; // to load a type hash before the function label. Ensure functions are aligned; // by a least 4 to avoid unaligned access, which is especially important for; // -mno-unaligned-access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:178,avoid,avoid,178,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,1,['avoid'],['avoid']
Safety,"// -mkernel and -fapple-kext imply no exceptions, so claim exception related; // arguments now to avoid warnings about unused arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:98,avoid,avoid,98,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['avoid'],['avoid']
Safety,// -rdynamic is a no-op with Haiku. Claim argument to avoid warning.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Haiku.cpp:54,avoid,avoid,54,interpreter/llvm-project/clang/lib/Driver/ToolChains/Haiku.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Haiku.cpp,1,['avoid'],['avoid']
Safety,// -rdynamic is a no-op with Solaris ld. Claim argument to avoid warning.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp:59,avoid,avoid,59,interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,1,['avoid'],['avoid']
Safety,"// ... Unless the CS is local or is in the sole predecessor block; // and it also defines the physical register which is not clobbered; // in between and the physical register uses were not clobbered.; // This can never be the case if the instruction both uses and; // defines the same physical register, which was detected above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:315,detect,detected,315,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['detect'],['detected']
Safety,"// .comm Foo, 0 is undefined, avoid it.; // .comm _foo, 42, 4",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:30,avoid,avoid,30,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['avoid'],['avoid']
Safety,"// .comm Foo, 0 is undefined, avoid it.; // Use .lcomm only if it supports user-specified alignment.; // Otherwise, while it would still be correct to use .lcomm in some; // cases (e.g. when Align == 1), the external assembler might enfore; // some -unknown- default alignment behavior, which could cause; // spurious differences between external and integrated assembler.; // Prefer to simply fall back to .local / .comm in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:30,avoid,avoid,30,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['avoid'],['avoid']
Safety,"// 0 && RHS: If it is safe, just elide the RHS, and return 0/false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:22,safe,safe,22,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['safe'],['safe']
Safety,"// 0 - X (doesn't simplify, but it is safe)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h:38,safe,safe,38,interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,1,['safe'],['safe']
Safety,// 0 signifies that there are no hazards that need to be waited on,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/CustomBehaviour.cpp:33,hazard,hazards,33,interpreter/llvm-project/llvm/lib/MCA/CustomBehaviour.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/CustomBehaviour.cpp,1,['hazard'],['hazards']
Safety,"// 0.0 - X (doesn't simplify, but it is safe)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h:40,safe,safe,40,interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,1,['safe'],['safe']
Safety,"// 0.0 / X (doesn't simplify, but it is safe)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h:40,safe,safe,40,interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,1,['safe'],['safe']
Safety,"// 0.99; TODO Look at - avoid removing clipping + manip objs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLPerspectiveCamera.cxx:24,avoid,avoid,24,graf3d/gl/src/TGLPerspectiveCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLPerspectiveCamera.cxx,1,['avoid'],['avoid']
Safety,"// 1 || RHS: If it is safe, just elide the RHS, and return 1/true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:22,safe,safe,22,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['safe'],['safe']
Safety,"// 1) Can't reorder two inf-loop calls, even if readonly; // 2) Also can't reorder an inf-loop call below a instruction which isn't; // safe to speculative execute. (Inverse of above)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:136,safe,safe,136,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['safe'],['safe']
Safety,"// 1) Set up a diagnostic handler to avoid errors being printed out to; // stderr.; // 2) Use the stream to print the error with the associated node.; // 3) The stream will use the source manager to print the error, which will; // call the diagnostic handler.; // 4) The diagnostic handler will stream the error directly into this object's; // Message member, which is used when logging is asked for.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.cpp:37,avoid,avoid,37,interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.cpp,1,['avoid'],['avoid']
Safety,"// 1. If the Idx has been completely eliminated and this subvector's size is; // a vector register or a multiple thereof, or the surrounding elements are; // undef, then this is a subvector insert which naturally aligns to a vector; // register. These can easily be handled using subregister manipulation.; // 2. If the subvector is smaller than a vector register, then the insertion; // must preserve the undisturbed elements of the register. We do this by; // lowering to an EXTRACT_SUBVECTOR grabbing the nearest LMUL=1 vector type; // (which resolves to a subregister copy), performing a VSLIDEUP to place the; // subvector within the vector register, and an INSERT_SUBVECTOR of that; // LMUL=1 type back into the larger vector (resolving to another subregister; // operation). See below for how our VSLIDEUP works. We go via a LMUL=1 type; // to avoid allocating a large register group to hold our subvector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:851,avoid,avoid,851,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// 1. dr<0 => approximate safety with distance to tangent to hyperbola in z = |point[2]|",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoHype.cxx:26,safe,safety,26,geom/geom/src/TGeoHype.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoHype.cxx,1,['safe'],['safety']
Safety,// 128 bit and smaller inputs should avoid truncate all together and; // just use a build_vector that will become a shuffle.; // TODO: Widen and use a shuffle directly?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:37,avoid,avoid,37,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// 16 byte ByVal alignment not due to a vector member is not honoured by XL; // on AIX. Emit a warning here that users are generating binary incompatible; // code to be safe.; // Here we try to get information about the alignment of the struct member; // from the struct passed to the caller function. We only warn when the struct; // is passed byval, hence the series of checks and early returns if we are a not; // passing a struct byval.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:169,safe,safe,169,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['safe'],['safe']
Safety,"// 16-bit types are reported as legal for 32-bit registers. We need to do; // a 32-bit copy, and truncate to avoid the verifier complaining about it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp:109,avoid,avoid,109,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp,1,['avoid'],['avoid']
Safety,// 16-bit types are reported as legal for 32-bit registers. We need to; // extend and do a 32-bit copy to avoid the verifier complaining about it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp:106,avoid,avoid,106,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp,1,['avoid'],['avoid']
Safety,"// 2. dr>0 => approximate safety with distance from point to segment P1(r(z0),z0) and P2(r0, z(r0))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoHype.cxx:26,safe,safety,26,geom/geom/src/TGeoHype.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoHype.cxx,1,['safe'],['safety']
Safety,// 256-bit AVX can use the vinsertf128 instruction; // to create 256-bit vectors from two other 128-bit ones.; // TODO: Detect subvector broadcast here instead of DAG combine?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:120,Detect,Detect,120,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Detect'],['Detect']
Safety,"// 256-bit PACK(ARG0, ARG1) leaves us with ((LO0,LO1),(HI0,HI1)),; // so we need to shuffle to get ((LO0,HI0),(LO1,HI1)).; // Scale shuffle mask to avoid bitcasts and help ComputeNumSignBits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:148,avoid,avoid,148,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// 2i64 vector logical shifts can efficiently avoid scalarization - do the; // shifts per-lane and then shuffle the partial results back together.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:46,avoid,avoid,46,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// 3 bytes if a PrintMethod is needed: 0xFF, the MCInst operand; // number, and which of our pre-detected Methods to call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp:97,detect,detected,97,interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp,1,['detect'],['detected']
Safety,// 3. Apply Edge Detection Pass,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/OutlinePassEve.js:17,Detect,Detection,17,ui5/eve7/lib/OutlinePassEve.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/OutlinePassEve.js,1,['Detect'],['Detection']
Safety,// 32-bit SEH filters need to be careful about FP recovery. The end of the; // EH registration is passed in as the EBP physical register. We can; // recover that with llvm.frameaddress(1).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:50,recover,recovery,50,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,2,['recover'],"['recover', 'recovery']"
Safety,"// 4th priority is bounded unrolling.; // We can unroll by the upper bound amount if it's generally allowed or if; // we know that the loop is executed either the upper bound or zero times.; // (MaxOrZero unrolling keeps only the first loop test, so the number of; // loop tests remains the same compared to the non-unrolled version, whereas; // the generic upper bound unrolling keeps all but the last loop test so the; // number of loop tests goes up which may end up being worse on targets with; // constrained branch predictor resources so is controlled by an option.); // In addition we only unroll small upper bounds.; // Note that the cost of bounded unrolling is always strictly greater than; // cost of exact full unrolling. As such, if we have an exact count and; // found it unprofitable, we'll never chose to bounded unroll.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:521,predict,predictor,521,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['predict'],['predictor']
Safety,"// 50% printable for ASCII files should be a safe guess.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/MetaProcessor/MetaProcessor.cpp:45,safe,safe,45,interpreter/cling/lib/MetaProcessor/MetaProcessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/MetaProcessor/MetaProcessor.cpp,1,['safe'],['safe']
Safety,"// :NOTE: Clang should not promote any i8 into i16 but for safety the; // following code will handle zexts or sexts generated by other; // front ends. Otherwise:; // If this is an 8 bit value, it is really passed promoted; // to 16 bits. Insert an assert[sz]ext to capture this, then; // truncate to the right size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:59,safe,safety,59,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,1,['safe'],['safety']
Safety,"// @(#)root/base:$Id$; // Author: Fons Rademakers 14/02/2002; /*************************************************************************; * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TVirtualMutex; \ingroup Base. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; ~~~ {.cpp}; {; TLockGuard guard(mutex);; ... // do something; }; ~~~; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualMutex.cxx:692,safe,safe,692,core/base/src/TVirtualMutex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualMutex.cxx,2,['safe'],['safe']
Safety,"// @(#)root/base:$Id$; // Author: Fons Rademakers 28/11/96; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TTimer; \ingroup Base. Handles synchronous and a-synchronous timer events.; 1. synchronous timer is registered into TSystem and is processed; within the standard ROOT event-loop.; 2. asynchronous timer is passed to the operating system which sends; an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; - Sub-class TTimer and override the Notify() method.; - Re-implement the TObject::HandleTimer() method in your class; and pass a pointer to this object to timer, see the SetObject(); method.; - Pass an interpreter command to timer, see SetCommand() method.; - Create a TTimer, connect its Timeout() signal to the; appropriate methods. Then when the time is up it will emit a; Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as; `kItimerResolution` (currently 10 ms). Signal/slots example:; ~~~{.cpp}; TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot; ~~~; To emit the Timeout signal repeatedly with minimum timeout:; ~~~ {.cpp}; timer->Start(0, kFALSE);; ~~~; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TTimer.cxx:1084,Timeout,Timeout,1084,core/base/src/TTimer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TTimer.cxx,6,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,"// @(#)root/base:$Id: 0daf41ec24086ee7af29fdc2f9f2f848b150dcc8 $; // Author: Fons Rademakers 22/09/95; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TEnv; \ingroup Base. The TEnv class reads config files, by default named `.rootrc`.; Three types of config files are read: global, user and local files. The; global file is `$ROOTSYS/etc/system<name>` (or `ROOTETCDIR/system<name>`); the user file is `$HOME/<name>` and the local file is `./<name>`.; By setting the shell variable `ROOTENV_NO_HOME=1` the reading of; the `$HOME/<name>` resource file will be skipped. This might be useful; in case the home directory resides on an auto-mounted remote file; system and one wants to avoid this file system from being mounted. The format of the `.rootrc` file is similar to the `.Xdefaults` format:; ~~~ {.cpp}; [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value>; ~~~; Where `<SystemName>` is either Unix, WinNT, MacOS or Vms,; `<RootName>` the name as given in the TApplication ctor (or ""RootApp""; in case no explicit TApplication derived object was created),; `<ProgName>` the current program name and `<name>` the resource name,; with optionally a type specification. `<value>` can be either a; string, an integer, a float/double or a boolean with the values; TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as; an integer 0 or 1. The options [+] allows the concatenation of; values to the same resource name. E.g.:; ~~~ {.cpp}; Unix.Rint.Root.DynamicPath: .:$(ROOTSYS)/lib:~/lib; myapp.Root.Debug: FALSE; TH.Root.Debug: YES; *.Root.ObjStat: 1; ~~~; `<SystemName>` and `<ProgName>` or `<RootName>` may be the wildcard ""*"".; A # in the first column starts",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TEnv.cxx:1001,avoid,avoid,1001,core/base/src/TEnv.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TEnv.cxx,1,['avoid'],['avoid']
Safety,"// @(#)root/build:$Id$; // Author: Axel Naumann 21/03/06; /*************************************************************************; * Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; // ROOT wrapper around ROOT's mkdepend incarnation + wrapper script,; // known as depends.sh in earlier days.; // If the first(!) argument is '-R' it triggers a few special; // routines:; // * dependencies for .d files use $(wildcard ...), so gmake doesn't; // bail out if one of the dependencies doesn't exist.; // * output files starting with '/G__' and ending on "".d"" are assumed to; // be dictionaries. rmkdepend generates rules for these dictionaries ; // covering the .d file, and the .cxx file itself, ; // so the dictionaries get re-egenerated when an included header ; // file gets changed.; // * the detection / wildcarding of a dictionary file can be changed ; // by specifying -R=[tag]%[ext] as parameter to -R. The default is ; // ""-R=/G__%.d"".; // * remove output file if we encounter an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rmkdepend/mainroot.cxx:1026,detect,detection,1026,misc/rmkdepend/mainroot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rmkdepend/mainroot.cxx,1,['detect'],['detection']
Safety,"// @(#)root/cont:$Id$; // Author: Fons Rademakers 11/08/95; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TClassTable; \ingroup Containers; This class registers for all classes their name, id and dictionary; function in a hash table. Classes are automatically added by the; ctor of a special init class when a global of this init class is; initialized when the program starts (see the ClassImp macro). All functions in TClassTable are thread-safe.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClassTable.cxx:765,safe,safe,765,core/cont/src/TClassTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClassTable.cxx,1,['safe'],['safe']
Safety,"// @(#)root/cont:$Id$; // Author: Rene Brun 28/09/2001; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TRef; \ingroup Base. Persistent Reference link to a TObject; A TRef is a lightweight object pointing to any TObject.; This object can be used instead of normal C++ pointers in case. - the referenced object R and the pointer P are not written to the same file; - P is read before R; - R and P are written to different Tree branches. When a top level object (eg Event *event) is a tree/graph of many objects,; the normal ROOT Streaming mechanism ensures that only one copy of each object; in the tree/graph is written to the output buffer to avoid circular; dependencies. However if the object event is split into several files or into several; branches of one or more Trees, normal C++ pointers cannot be used because; each I/O operation will write the referenced objects. When a TRef is used to point to a TObject *robj, for example in a class with; ~~~ {.cpp}; TRef fRef;; ~~~; one can do:; ~~~ {.cpp}; fRef = robj; //to set the pointer; ~~~; This TRef and robj can be written with two different I/O calls; in the same or different files, in the same or different branches of a Tree. If the TRef is read and the referenced object has not yet been read,; the TRef will return a null pointer. As soon as the referenced object; will be read, the TRef will point to it. If the referenced object is; contained in a TTree it can be auto-loaded using the TBranchRef mechanism,; which is set up by simply calling TTree::BranchRef(). TRef also supports the complex situation where a TFile is updated; multiple times on the same machine or a different machine. ## How does it work. A T",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TRef.cxx:965,avoid,avoid,965,core/base/src/TRef.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TRef.cxx,1,['avoid'],['avoid']
Safety,"// @(#)root/csg:$Id$; // Author: Timur Pocheptsov 01/04/2005; /*; CSGLib - Software Library for Constructive Solid Geometry; Copyright (C) 2003-2004 Laurence Bourn. This library is free software; you can redistribute it and/or; modify it under the terms of the GNU Library General Public; License as published by the Free Software Foundation; either; version 2 of the License, or (at your option) any later version. This library is distributed in the hope that it will be useful,; but WITHOUT ANY WARRANTY; without even the implied warranty of; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; Library General Public License for more details. You should have received a copy of the GNU Library General Public; License along with this library; if not, write to the Free; Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. Please send remarks, questions and bug reports to laurencebourn@hotmail.com; */; /*; SOLID - Software Library for Interference Detection; Copyright (C) 1997-1998 Gino van den Bergen. This library is free software; you can redistribute it and/or; modify it under the terms of the GNU Library General Public; License as published by the Free Software Foundation; either; version 2 of the License, or (at your option) any later version. This library is distributed in the hope that it will be useful,; but WITHOUT ANY WARRANTY; without even the implied warranty of; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; Library General Public License for more details. You should have received a copy of the GNU Library General Public; License along with this library; if not, write to the Free; Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. Please send remarks, questions and bug reports to gino@win.tue.nl,; or write to:; Gino van den Bergen; Department of Mathematics and Computing Science; Eindhoven University of Technology; P.O. Box 513, 5600 MB Eindhoven, The Netherlands; */; /*; This file contains compressed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/csg/src/CsgOps.cxx:981,Detect,Detection,981,graf3d/csg/src/CsgOps.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/csg/src/CsgOps.cxx,1,['Detect'],['Detection']
Safety,"// @(#)root/eg:$Id$; // Author: Rene Brun , Federico Carminati 26/04/99; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TParticle; \ingroup eg. Description of the dynamic properties of a particle. A dynamic particle class created by event generators and used during; the propagation in detectors. The static attributes of a TParticle; are described by TParticlePDG. \verbatim; Int_t fPdgCode; // PDG code of the particle; Int_t fStatusCode; // generation status code; Int_t fMother[2]; // Indices of the mother particles; Int_t fDaughter[2]; // Indices of the daughter particles; Float_t fWeight; // particle weight. Double_t fCalcMass; // Calculated mass. Double_t fPx; // x component of momentum; Double_t fPy; // y component of momentum; Double_t fPz; // z component of momentum; Double_t fE; // Energy. Double_t fVx; // x of production vertex; Double_t fVy; // y of production vertex; Double_t fVz; // z of production vertex; Double_t fVt; // t of production vertex. Double_t fPolarTheta; // Polar angle of polarisation; Double_t fPolarPhi; // azymutal angle of polarisation. TParticlePDG* fParticlePDG; //! reference to the particle record in PDG database; \endverbatim; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/src/TParticle.cxx:608,detect,detectors,608,montecarlo/eg/src/TParticle.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/src/TParticle.cxx,1,['detect'],['detectors']
Safety,"// @(#)root/eve7:$Id$; // Authors: Matevz Tadel & Alja Mrak-Tadel: 2006, 2007, 2018; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; // This is a minimal-change import of GLU libtess from:; // git://anongit.freedesktop.org/git/mesa/glu; //; // Changes to make it build in the horrible one-file-hack way:; // - remove include gl.h from glu.h (and replace with the mini-gl defs below);; // - comment out clashing typedef EdgePair in tess.c;; // - use -Wno-unused-parameter for this cxx file.; // Sergey: first include gl code before any normal ROOT includes,; // try to avoid clash with other system includes through Rtypes.h",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveGluTess.cxx:878,avoid,avoid,878,graf3d/eve7/src/REveGluTess.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveGluTess.cxx,1,['avoid'],['avoid']
Safety,"// @(#)root/fft:$Id$; // Author: Anna Kreshuk 07/4/2006; /*************************************************************************; * Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////////////////; /// \class TFFTComplexReal; ///; /// One of the interface classes to the FFTW package, can be used directly; /// or via the TVirtualFFT class. Only the basic interface of FFTW is implemented.; ///; /// Computes the inverse of the real-to-complex transforms (class TFFTRealComplex); /// taking complex input (storing the non-redundant half of a logically Hermitian array); /// to real output (see FFTW manual for more details); ///; /// How to use it:; /// 1. Create an instance of TFFTComplexReal - this will allocate input and output; /// arrays (unless an in-place transform is specified); /// 2. Run the Init() function with the desired flags and settings; /// 3. Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); /// 4. Run the Transform() function; /// 5. Get the output (via GetPoints(), GetPoint() or GetPointReal() functions); /// 6. Repeat steps 3)-5) as needed; ///; /// For a transform of the same size, but with different flags, rerun the Init(); /// function and continue with steps 3)-5); ///; /// NOTE:; /// 1. running Init() function will overwrite the input array! Don't set any data; /// before running the Init() function; /// 2. FFTW computes unnormalized transform, so doing a transform followed by; /// its inverse will lead to the original array scaled by the transform size; /// 3. In Complex to Real transform the input array is destroyed. It cannot then; /// be retrieved when using the Get's methods.; ///; /////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fftw/src/TFFTComplexReal.cxx:821,redund,redundant,821,math/fftw/src/TFFTComplexReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fftw/src/TFFTComplexReal.cxx,1,['redund'],['redundant']
Safety,"// @(#)root/geom:$Id$; // Author: Andrei Gheata 17/02/04; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TGeoPhysicalNode; \ingroup Geometry_classes. Physical nodes are the actual 'touchable' objects in the geometry, representing; a path of positioned volumes starting with the top node:; path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of; branches in the geometry hierarchy. In case of detector geometries and; specially for calorimeters this number can be of the order 1e6-1e9, therefore; it is impossible to create all physical nodes as objects in memory. In TGeo,; physical nodes are represented by the class TGeoPhysicalNode and can be created; on demand for alignment purposes:. ~~~ {.cpp}; TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""); ~~~. Once created, a physical node can be misaligned, meaning that its position; or even shape can be changed:. ~~~ {.cpp}; pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE); ~~~; */; /** \class TGeoPNEntry; \ingroup Geometry_classes. The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can however; create 'symbolic links' to any complex path to make it more representable; for the object it designates:. ~~~ {.cpp}; TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; pne->SetPhysicalNode(pn); ~~~. Such a symbolic link hides the complexity of the path to the align object and; replaces it with a more meaningful name. In addition, TGeoPNEntry objects are; faster to search by name and they may option",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPhysicalNode.cxx:798,detect,detector,798,geom/geom/src/TGeoPhysicalNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPhysicalNode.cxx,1,['detect'],['detector']
Safety,"// @(#)root/geom:$Id$; // Author: Andrei Gheata 25/10/01; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TGeoManager; \ingroup Geometry_classes. The manager class for any TGeo geometry. Provides user; interface for geometry creation, navigation, state querying,; visualization, IO, geometry checking and other utilities. ## General architecture. The ROOT geometry package is a tool designed for building, browsing,; tracking and visualizing a detector geometry. The code is independent from; other external MC for simulation, therefore it does not contain any; constraints related to physics. However, the package defines a number of; hooks for tracking, such as media, materials, magnetic field or track state flags,; in order to allow interfacing to tracking MC's. The final goal is to be; able to use the same geometry for several purposes, such as tracking,; reconstruction or visualization, taking advantage of the ROOT features; related to bookkeeping, I/O, histogramming, browsing and GUI's. The geometrical modeler is the most important component of the package and; it provides answers to the basic questions like ""Where am I ?"" or ""How far; from the next boundary ?"", but also to more complex ones like ""How far from; the closest surface ?"" or ""Which is the next crossing along a helix ?"". The architecture of the modeler is a combination between a GEANT-like; containment scheme and a normal CSG binary tree at the level of shapes. An; important common feature of all detector geometry descriptions is the; mother-daughter concept. This is the most natural approach when tracking; is concerned and imposes a set of constraints to the way geometry is defined.; Construc",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:765,detect,detector,765,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,1,['detect'],['detector']
Safety,"// @(#)root/geom:$Id$; // Author: Mihaela Gheata 5/01/04; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TGeoPolygon; \ingroup Shapes_classes. An arbitrary polygon defined by vertices. The vertices; have to be defined CLOCKWISE in the XY plane, making either a convex; or concave polygon. No test for malformed polygons is performed. A polygon is a 2D shape defined by vertices in the XY plane. It is used by; TGeoXtru class for computing Contains() and Safety(). Only the pointers to; the actual lists of XY values are used - these are not owned by the class. To check if a point in XY plane is contained by a polygon, this is split; into an outscribed convex polygon and the remaining polygons of its subtraction; from the outscribed one. A point is INSIDE if it is; contained by the outscribed polygon but NOT by the remaining ones. Since these; can also be arbitrary polygons at their turn, a tree structure is formed:. ~~~ {.cpp}; P = Pconvex - (Pconvex-P) where (-) means 'subtraction'; Pconvex-P = P1 + P2 + ... where (+) means 'union'; ~~~. *Note that P1, P2, ... do not intersect each other and they are defined; by subsets of the list of vertices of P. They can be split in the same; way as P*. Therefore, if C(P) represents the Boolean : 'does P contains a given point?',; then:. ~~~ {.cpp}; C(P) = C(Pconvex) .and. not(C(P1) | C(P2) | ...); ~~~. For creating a polygon without TGeoXtru class, one has to call the constructor; TGeoPolygon(nvert) and then SetXY(Double_t *x, Double_t *y) providing the; arrays of X and Y vertex positions (defined clockwise) that have to 'live' longer; than the polygon they will describe. This complication is due to efficiency reasons",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPolygon.cxx:776,Safe,Safety,776,geom/geom/src/TGeoPolygon.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPolygon.cxx,1,['Safe'],['Safety']
Safety,"// @(#)root/gui:$Id$; // Author: G. Ganis 10/10/2005; /*************************************************************************; * Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TGRedirectOutputGuard; \ingroup guiwidgets. This class provides output redirection to a TGTextView in guaranteed; exception safe way. Use like this:. ```; {; TGRedirectOutputGuard guard(textview);; ... // do something; guard.Update();; ... // do something else; }; ```. when guard goes out of scope, Update() is called to flush what left; on the screed and the output is automatically redirected again to; the standard units.; The exception mechanism takes care of calling the dtors; of local objects so it is exception safe.; Optionally the output can also be saved into a file:. ```; {; TGRedirectOutputGuard guard(textview, file, mode);; ... // do something; }; ```. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGRedirectOutputGuard.cxx:547,safe,safe,547,gui/gui/src/TGRedirectOutputGuard.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGRedirectOutputGuard.cxx,2,['safe'],['safe']
Safety,"// @(#)root/hist:$Id$; // Author: Frank Filthaut F.Filthaut@science.ru.nl 20/05/2002; // with additions by Bram Wijngaarden <dwijngaa@hef.kun.nl>; /** \class TFractionFitter; Fits MC fractions to data histogram. A la HMCMLL, see R. Barlow and C. Beeston,; Comp. Phys. Comm. 77 (1993) 219-228, and http://www.hep.man.ac.uk/~roger/hfrac.f. The virtue of this fit is that it takes into account both data and Monte Carlo; statistical uncertainties. The way in which this is done is through a standard; likelihood fit using Poisson statistics; however, the template (MC) predictions; are also varied within statistics, leading to additional contributions to the; overall likelihood. This leads to many more fit parameters (one per bin per; template), but the minimisation with respect to these additional parameters is; done analytically rather than introducing them as formal fit parameters. Some; special care needs to be taken in the case of bins with zero content. For more; details please see the original publication cited above. An example application of this fit is given below. For a TH1* histogram; (""data"") fitted as the sum of three Monte Carlo sources (""mc""):. ~~~{.cpp}; {; TH1F *data; //data histogram; TH1F *mc0; // first MC histogram; TH1F *mc1; // second MC histogram; TH1F *mc2; // third MC histogram; .... // retrieve histograms; TObjArray *mc = new TObjArray(3); // MC histograms are put in this array; mc->Add(mc0);; mc->Add(mc1);; mc->Add(mc2);; TFractionFitter* fit = new TFractionFitter(data, mc); // initialise; fit->Constrain(1,0.0,1.0); // constrain fraction 1 to be between 0 and 1; fit->SetRangeX(1,15); // use only the first 15 bins in the fit; Int_t status = fit->Fit(); // perform the fit; std::cout << ""fit status: "" << status << std::endl;; if (status == 0) { // check on fit status; TH1F* result = (TH1F*) fit->GetPlot();; data->Draw(""Ep"");; result->Draw(""same"");; }; }; ~~~. ## Assumptions; A few assumptions need to be made for the fit procedure to be carried out:; 1 ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:566,predict,predictions,566,hist/hist/src/TFractionFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx,1,['predict'],['predictions']
Safety,"// @(#)root/hist:$Id$; // Author: L. Moneta Thu Aug 31 10:40:20 2006; /**********************************************************************; * *; * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; * *; * *; **********************************************************************/; // Header file for class HFitInterface; // set of free functions used to couple the ROOT data object with the fitting classes; // avoid including this file when running CINT since free functions cannot be re-defined",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/HFitInterface.h:417,avoid,avoid,417,hist/hist/inc/HFitInterface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/HFitInterface.h,1,['avoid'],['avoid']
Safety,"// @(#)root/hist:$Id$; // Author: Lorenzo Moneta; /*************************************************************************; * Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////////////////; /** \class TBackCompFitter; \ingroup Hist; \brief Backward compatible implementation of TVirtualFitter. Backward compatible implementation of TVirtualFitter using the; class ROOT::Fit::Fitter. This class is created after fitting an; histogram (TH1), TGraph or TTree and provides in addition to the; methods of the TVirtualFitter hooks to access the fit result class; (ROOT::Fit::FitResult), the fit configuration; (ROOT::Fit::FitConfig) or the fit data (ROOT::Fit::FitData) using. ~~~~~~~~{.cpp}; TBackCompFitter * fitter = (TBackCompFitter *) TVirtualFitter::GetFitter();; ROOT::Fit::FitResult & result = fitter->GetFitResult();; result.Print(std::cout);; ~~~~~~~~. Methods for getting the confidence level or contours are also; provided. Note that after a new calls to TH1::Fit (or similar) the; class will be deleted and all reference to the FitResult, FitConfig; or minimizer will be invalid. One could eventually copying the; class before issuing a new fit to avoid deleting this information.; */; //////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:1455,avoid,avoid,1455,hist/hist/src/TBackCompFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx,1,['avoid'],['avoid']
Safety,"// @(#)root/io:$Id$; // Author: Rene Brun 18/05/2006; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /**; \class TFileCacheRead; \ingroup IO. A cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TNetXNGFile and TWebFile (via TFile::ReadBuffers()).; When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx:729,avoid,avoiding,729,io/io/src/TFileCacheRead.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx,1,['avoid'],['avoiding']
Safety,"// @(#)root/io:$Id$; // Author: Rene Brun 18/05/2006; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /**; \class TFileCacheWrite TFileCacheWrite.cxx; \ingroup IO; A cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TNetXNGFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()).; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheWrite.cxx:750,avoid,avoiding,750,io/io/src/TFileCacheWrite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheWrite.cxx,1,['avoid'],['avoiding']
Safety,"// @(#)root/io:$Id$; // Author: Rene Brun 28/12/94; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /**; \class TKey; \ingroup IO. Book space in a file, create I/O buffers, to fill them, (un)compress them. The TKey class includes functions to book space in a file, to create I/O; buffers, to fill these buffers, to compress/uncompress data buffers.; Before saving (making persistent) an object in a file, a key must; be created. The key structure contains all the information to; uniquely identify a persistent object in a file.; | Data Member | Explanation |; |-------------|-------------|; | fNbytes | Number of bytes for the compressed object and key. |; | fObjlen | Length of uncompressed object. |; | fDatime | Date/Time when the object was written. |; | fKeylen | Number of bytes for the key structure. |; | fCycle | Cycle number of the object. |; | fSeekKey | Address of the object on file (points to fNbytes). This is a redundant information used to cross-check the data base integrity. |; | fSeekPdir | Pointer to the directory supporting this object.|; | fClassName | Object class name. |; | fName | Name of the object. |; | fTitle | Title of the object. |. In the 16 highest bits of fSeekPdir is encoded a pid offset. This; offset is to be added to the pid index stored in the TRef object; and the referenced TObject. The TKey class is used by ROOT to:; - Write an object in the current directory; - Write a new ntuple buffer. The structure of a file is shown in TFile::TFile.; The structure of a directory is shown in TDirectoryFile::TDirectoryFile.; The TKey class is used by the TBasket class.; See also TTree.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TKey.cxx:1238,redund,redundant,1238,io/io/src/TKey.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TKey.cxx,1,['redund'],['redundant']
Safety,"// @(#)root/mathcore:$Id$; // Author: Jonas Hahnfeld 11/2020; /*************************************************************************; * Copyright (C) 1995-2021, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class ROOT::Math::RanluxppEngine; Implementation of the RANLUX++ generator. RANLUX++ is an LCG equivalent of RANLUX using 576 bit numbers. The idea of the generator (such as the initialization method) and the algorithm; for the modulo operation are described in; A. Sibidanov, *A revision of the subtract-with-borrow random numbergenerators*,; *Computer Physics Communications*, 221(2017), 299-303,; preprint https://arxiv.org/pdf/1705.03123.pdf. The code is loosely based on the Assembly implementation by A. Sibidanov; available at https://github.com/sibidanov/ranluxpp/. Compared to the original generator, this implementation contains a fix to ensure; that the modulo operation of the LCG always returns the smallest value congruent; to the modulus (based on notes by M. Lüscher). Also, the generator converts the; LCG state back to RANLUX numbers (implementation based on notes by M. Lüscher).; This avoids a bias in the generated numbers because the upper bits of the LCG; state, that is smaller than the modulus \f$ m = 2^{576} - 2^{240} + 1 \f$ (not; a power of 2!), have a higher probability of being 0 than 1. And finally, this; implementation draws 48 random bits for each generated floating point number; (instead of 52 bits as in the original generator) to maintain the theoretical; properties from understanding the original transition function of RANLUX as a; chaotic dynamical system.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/RanluxppEngineImpl.cxx:1330,avoid,avoids,1330,math/mathcore/src/RanluxppEngineImpl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/RanluxppEngineImpl.cxx,1,['avoid'],['avoids']
Safety,"// @(#)root/matrix:$Id$; // Authors: Fons Rademakers, Eddy Offermann Nov 2003; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TVectorT; \ingroup Matrix. TVectorT. Template class of Vectors in the linear algebra package. See the \ref Matrix page for the documentation of the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see `$ROOTSYS/test/stressLinear.cxx`. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TVectorT.cxx:820,avoid,avoiding,820,math/matrix/src/TVectorT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TVectorT.cxx,1,['avoid'],['avoiding']
Safety,"// @(#)root/physics:$Id$; // Author: Jan Conrad; /** \class TRolke; \legacy{TRolke, Consider switching to RooStats.}; \ingroup Physics; This class computes confidence intervals for the rate of a Poisson; process in the presence of uncertain background and/or efficiency. The treatment and the resulting limits are fully frequentist. The; limit calculations make use of the profile likelihood method. \author Jan Conrad (CERN) 2004, Updated: Johan Lundberg (CERN) 2009. For a full list of methods and their syntax, and build instructions,; consult the header file TRolke.h. Examples/tutorials are found in the separate file Rolke.C. ### TRolke implements the following Models. The signal is always assumed to be Poisson, with the following; combinations of models of background and detection efficiency:. If unsure, first consider model 3, 4 or 5. 1: SetPoissonBkgBinomEff(x,y,z,tau,m); ~~~; Background: Poisson; Efficiency: Binomial; ~~~; when the background is simultaneously measured; from sidebands (or MC), and; the signal efficiency was determined from Monte Carlo. 2: SetPoissonBkgGaussEff(x,y,em,tau,sde); ~~~; Background: Poisson; Efficiency: Gaussian; ~~~; when the background is simultaneously measured; from sidebands (or MC), and; the efficiency is modeled as Gaussian. 3: SetGaussBkgGaussEff(x,bm,em,sde,sdb); ~~~; Background: Gaussian; Efficiency: Gaussian; ~~~; when background and efficiency can both be; modeled as Gaussian. 4: SetPoissonBkgKnownEff(x,y,tau,e); ~~~; Background: Poisson; Efficiency: Known; ~~~; when the background is simultaneously measured; from sidebands (or MC). 5: SetGaussBkgKnownEff(x,bm,sdb,e); ~~~; Background: Gaussian; Efficiency: Known; ~~~; when background is Gaussian. 6: SetKnownBkgBinomEff(x,z,b,m); ~~~; Background: Known; Efficiency: Binomial; ~~~; when signal efficiency was determined from Monte Carlo. 7: SetKnownBkgGaussEff(x,em,sde,b); ~~~; Background: Known; Efficiency: Gaussian; ~~~; when background is known and efficiency Gaussian. ### Par",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TRolke.cxx:781,detect,detection,781,math/physics/src/TRolke.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/src/TRolke.cxx,1,['detect'],['detection']
Safety,"// @(#)root/quadp:$Id$; // Author: Eddy Offermann May 2004; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /*************************************************************************; * Parts of this file are copied from the OOQP distribution and *; * are subject to the following license: *; * *; * COPYRIGHT 2001 UNIVERSITY OF CHICAGO *; * *; * The copyright holder hereby grants you royalty-free rights to use, *; * reproduce, prepare derivative works, and to redistribute this software*; * to others, provided that any changes are clearly documented. This *; * software was authored by: *; * *; * E. MICHAEL GERTZ gertz@mcs.anl.gov *; * Mathematics and Computer Science Division *; * Argonne National Laboratory *; * 9700 S. Cass Avenue *; * Argonne, IL 60439-4844 *; * *; * STEPHEN J. WRIGHT swright@cs.wisc.edu *; * Computer Sciences Department *; * University of Wisconsin *; * 1210 West Dayton Street *; * Madison, WI 53706 FAX: (608)262-9777 *; * *; * Any questions or comments may be directed to one of the authors. *; * *; * ARGONNE NATIONAL LABORATORY (ANL), WITH FACILITIES IN THE STATES OF *; * ILLINOIS AND IDAHO, IS OWNED BY THE UNITED STATES GOVERNMENT, AND *; * OPERATED BY THE UNIVERSITY OF CHICAGO UNDER PROVISION OF A CONTRACT *; * WITH THE DEPARTMENT OF ENERGY. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////////////////; ///; /// \class TMehrotraSolver; ///; /// Derived class of TQpSolverBase implementing the original Mehrotra; /// predictor-corrector algorithm; ///; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TMehrotraSolver.cxx:1868,predict,predictor-corrector,1868,math/quadp/src/TMehrotraSolver.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TMehrotraSolver.cxx,1,['predict'],['predictor-corrector']
Safety,"// @(#)root/tmva $Id$; // Author: Andreas Hoecker, Joerg Stelzer, Fredrik Tegenfeldt, Helge Voss; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : RuleFitParams *; * *; * *; * Description: *; * A class doing the actual fitting of a linear model using rules as *; * base functions. *; * Reference paper: 1.Gradient Directed Regularization *; * Friedman, Popescu, 2004 *; * 2.Predictive Learning with Rule Ensembles *; * Friedman, Popescu, 2005 *; * *; * *; * Authors (alphabetical): *; * Fredrik Tegenfeldt <Fredrik.Tegenfeldt@cern.ch> - Iowa State U., USA *; * Helge Voss <Helge.Voss@cern.ch> - MPI-KP Heidelberg, Ger. *; * *; * Copyright (c) 2005: *; * CERN, Switzerland *; * Iowa State U. *; * MPI-K Heidelberg, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleFitParams.h:517,Predict,Predictive,517,tmva/tmva/inc/TMVA/RuleFitParams.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleFitParams.h,1,['Predict'],['Predictive']
Safety,"// @(#)root/tmva $Id$; // Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Header : MethodCFMlpANN_def *; * *; * *; * Description: *; * Common definition for CFMlpANN method *; * *; * Authors (alphabetical): *; * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; * Xavier Prudent <prudent@lapp.in2p3.fr> - LAPP, France *; * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; * Kai Voss <Kai.Voss@cern.ch> - U. of Victoria, Canada *; * *; * Copyright (c) 2005: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * LAPP, Annecy, France *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; // ------------- common definitions used in several modules --------------; // recovered explicit array definitions from f2c override",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodCFMlpANN_def.h:1137,recover,recovered,1137,tmva/tmva/inc/TMVA/MethodCFMlpANN_def.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodCFMlpANN_def.h,1,['recover'],['recovered']
Safety,"// @(#)root/tmva $Id$; // Author: Simon Pfreundschuh; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh, Saurav Shekhar *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Generic tests of the backpropagation algorithm. //; // //; // All tests randomly generate a net with identity activation //; // functions, i.e. which is completely linear and then tests the //; // computed gradients for each layer using numerical //; // derivation. The restriction to linear nets is to avoid the //; // required division by the finite difference interval used to //; // approximate the numerical derivatives, which would otherwise //; // cause precision loss. //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestBackpropagationDL.h:787,avoid,avoid,787,tmva/tmva/test/DNN/TestBackpropagationDL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestBackpropagationDL.h,2,['avoid'],['avoid']
Safety,"// @(#)root/tmva $Id$; // Author: Simon Pfreundschuh; /*************************************************************************; * Copyright (C) 2016, Simon Pfreundschuh; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; ////////////////////////////////////////////////////////////////////; // Generic tests of the backpropagation algorithm. //; // //; // All tests randomly generate a net with identity activation //; // functions, i.e. which is completely linear and then tests the //; // computed gradients for each layer using numerical //; // derivation. The restriction to linear nets is to avoid the //; // required division by the finite difference interval used to //; // approximate the numerical derivatives, which would otherwise //; // cause precision loss. //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestBackpropagation.h:769,avoid,avoid,769,tmva/tmva/test/DNN/TestBackpropagation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestBackpropagation.h,1,['avoid'],['avoid']
Safety,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Conv Net Prediction *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Conv Net Prediction //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestConvNetPrediction.cxx:304,Predict,Prediction,304,tmva/tmva/test/DNN/CNN/TestConvNetPrediction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestConvNetPrediction.cxx,2,['Predict'],['Prediction']
Safety,"// @(#)root/tmva/tmva/cnn:$Id$; // Author: Vladimir Ilievski; /**********************************************************************************; * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; * Package: TMVA *; * Class : *; * *; * *; * Description: *; * Testing Conv Net Prediction for CPU *; * *; * Authors (alphabetical): *; * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; * *; * Copyright (c) 2005-2015: *; * CERN, Switzerland *; * U. of Victoria, Canada *; * MPI-K Heidelberg, Germany *; * U. of Bonn, Germany *; * *; * Redistribution and use in source and binary forms, with or without *; * modification, are permitted according to the terms listed in LICENSE *; * (see tmva/doc/LICENSE) *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////; // Testing the Conv Net Prediction //; ////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestConvNetPredictionCpu.cxx:304,Predict,Prediction,304,tmva/tmva/test/DNN/CNN/TestConvNetPredictionCpu.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestConvNetPredictionCpu.cxx,2,['Predict'],['Prediction']
Safety,"// @(#)root/treeplayer:$Id$; // Author: Philippe Canal 06/06/2004; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /*; TODO:; Have separate names for the wrapper classes in the cases of: [done]; clones/non clones; split/non split; split levels. Have a solution for passing top+"".""+middle to the parents classes [probably done .. need testing]. Have a solution for the return by references of abstract classes [not done]. Have object inside ClonesArray properly treated! [done]; Why is there 2 TRef proxy classes? [done]. check why some inheritance are TObjProxy and not TPx_. Be smart enough to avoid issue about having 2 classes one unrolled and one non unrolled!. When using in interpreted mode understand why the reloading reloads the calling script and then crashes :(. CINT does not properly call the custom operators when doing return fNtrack. CINT does not handle fMatrix[2][1] well. The user's function in script.h are not exposed by ACLiC. Review the method to avoid the useless refreshing of the generated file; - for most efficiency it would require a different name for each tree; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProxyGenerator.cxx:912,avoid,avoid,912,tree/treeplayer/src/TTreeProxyGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProxyGenerator.cxx,2,['avoid'],['avoid']
Safety,"// @(#)root/win32gdk:$Id$; // Author: Valeriy Onuchin 08/08/2003; /*************************************************************************; * Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TGWin32ProxyBase; \ingroup win32. Proxy classes provide thread-safe interface to global objects. For example: TGWin32VirtualXProxy (to gVirtualX). Proxy object creates callback object and posts a windows message to; ""processing thread"". When windows message is received callback; (""real method"") is executed. For example:; gVirtualX->ClearWindow(). - callback object created containing pointer to function; corresponding TGWin32::ClearWindow() method; - message to ""processing thread"" (main thread) is posted; - TGWin32::ClearWindow() method is executed inside main thread; - thread containing gVirtualX proxy object waits for reply; from main thread that TGWin32::ClearWindow() is completed. Howto create proxy class:. 1. Naming.; name of proxy = TGWin32 + the name of ""virtual base class"" + Proxy. e.g. TGWin32VirtualXProxy = TGWin32 + VirtualX + Proxy. 2. Definition of global object; As example check definition and implementation of; gVirtualX global object. 3. Class definition.; proxy class must be inherited from ""virtual base class"" and; TGWin32ProxyBase class. For example:. class TGWin32VirtualX : public TVirtualX , public TGWin32ProxyBase. 4. Constructors, destructor, extra methods.; - constructors and destructor of proxy class do nothing; - proxy class must contain two extra static methods; RealObject(), ProxyObject(). Each of them return pointer to object; of virtual base class. For example:; static TVirtualX *RealObject();; static TVirtualX *ProxyObject();. 5. Implementation; TGWin32ProxyDefs.h file contains a set of macros which very; simpli",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32ProxyBase.cxx:498,safe,safe,498,graf2d/win32gdk/src/TGWin32ProxyBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32ProxyBase.cxx,1,['safe'],['safe']
Safety,"// @llvm.objectsize should never have side-effects and shouldn't need; // destruction/cleanups, so we can safely ""emit"" it after its arg,; // regardless of right-to-leftness",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:106,safe,safely,106,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['safe'],['safely']
Safety,"// A FileID is a (cached via ContentCache) SourceManager view of a; // FileManager::FileEntry (which is a wrapper on the file system file).; // In a subtle cases, code unloading can remove the cached region.; // However we are safe because it will empty the ContentCache and force; // the FileEntry to be re-read. It will keep the FileID intact and valid; // by design. When we reprocess the same (but modified) file it will get; // a new FileID. Then the Invalid flag will be false but the underlying; // buffer content will be empty. It will not compare equal to the lookup; // string and we will avoid using (a potentially broken) cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp:227,safe,safe,227,interpreter/cling/lib/Interpreter/LookupHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"// A JetEvent emulates 2 detectors A and B producing each; // a TClonesArray of Hit objects.; // A TClonesArray of Track objects is built with Hits objects; // of detectors A and B. Eack Track object has a TRefArray of hits.; // A TClonesArray of Jets is made with a subset of the Track objects; // also stored in a TRefArray.; // see $ROOTSYS/tutorials/jets.C for an example creating a Tree; // with JetEvents.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tree/JetEvent.cxx:25,detect,detectors,25,tutorials/tree/JetEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tree/JetEvent.cxx,2,['detect'],['detectors']
Safety,"// A LBR sample is like:; // 40062f 0x5c6313f/0x5c63170/P/-/-/0 0x5c630e7/0x5c63130/P/-/-/0 ...; // A heuristic for fast detection by checking whether a; // leading "" 0x"" and the '/' exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp:121,detect,detection,121,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,1,['detect'],['detection']
Safety,// A ParenListExpr can show up while doing error recovery with invalid code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:49,recover,recovery,49,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['recover'],['recovery']
Safety,"// A RooAddPdf needs to have a normalization set defined, otherwise its; // coefficient will not be uniquely defined. Its shape depends on the; // normalization provided. Un-normalized calls to RooAddPdf can happen in; // Roofit, when printing the pdf's or when computing integrals. In these case,; // if the pdf has a normalization set previously defined (i.e. stored as a; // datamember in _copyOfLastNormSet) it should use it by default when the pdf; // is evaluated without passing a normalizations set (in pdf->getVal(nullptr) ); // In the case of no pre-defined normalization set exists, a warning will be; // produced, since the obtained value will be arbitrary. Note that to avoid; // unnecessary warning messages, when calling RooAbsPdf::printValue or; // RooAbsPdf::graphVizTree, the printing of the warning messages for the; // RooFit::Eval topic is explicitly disabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx:683,avoid,avoid,683,roofit/roofitcore/src/RooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx,1,['avoid'],['avoid']
Safety,"// A boolean result can be represented as an integer type in C/C++, but at; // this point we only care about the SMT sorts. Set it as a boolean type; // to avoid subsequent SMT errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h:156,avoid,avoid,156,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,1,['avoid'],['avoid']
Safety,// A child of CompoundStatement can just be safely removed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Mutations.cpp:44,safe,safely,44,interpreter/llvm-project/clang/lib/Tooling/Syntax/Mutations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Mutations.cpp,1,['safe'],['safely']
Safety,// A common user mistake is specifying a target of aarch64-none-eabi or; // arm-none-elf whereas the correct names are aarch64-none-elf &; // arm-none-eabi. Detect these cases and issue a warning.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:157,Detect,Detect,157,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['Detect'],['Detect']
Safety,"// A comparison between two BCE atoms, e.g. `a == o.a` in the example at the; // top.; // Note: the terminology is misleading: the comparison is symmetric, so there; // is no real {l/r}hs. What we want though is to have the same base on the; // left (resp. right), so that we can detect consecutive loads. To ensure this; // we put the smallest atom on the left.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:280,detect,detect,280,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,1,['detect'],['detect']
Safety,"// A constant may be a member of both Constants and MachineCPVsSharingEntries,; // so keep track of which we've deleted to avoid double deletions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:123,avoid,avoid,123,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,1,['avoid'],['avoid']
Safety,"// A conversion operator presents complications/ambiguity if there's a; // conversion to class template that is itself a template, eg:; // template<typename T>; // operator ns::t1<T, int>();; // This should be named, eg: ""operator ns::t1<float, int><float>""; // (ignoring clang bug that means this is currently ""operator t1<float>""); // but if the arguments were stripped, the consumer couldn't differentiate; // whether the template argument list for the conversion type was the; // function's argument list (& no reconstitution was needed) or not.; // This could be handled if reconstitutable names had a separate attribute; // annotating them as such - this would remove the ambiguity.; //; // Alternatively the template argument list could be parsed enough to check; // whether there's one list or two, then compare that with the DWARF; // description of the return type and the template argument lists to determine; // how many lists there should be and if one is missing it could be assumed(?); // to be the function's template argument list & then be rebuilt.; //; // Other operator overloads that aren't conversion operators could be; // reconstituted but would require a bit more nuance about detecting the; // difference between these different operators during that rebuilding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:1202,detect,detecting,1202,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['detect'],['detecting']
Safety,// A decl to avoid as a correction because it is in the; // process of being initialized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:13,avoid,avoid,13,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['avoid'],['avoid']
Safety,"// A declaration is exported if it is [...] a namespace-definition; // that contains an exported declaration.; //; // Defer exporting the namespace until after we leave it, in order to; // avoid marking all subsequent declarations in the namespace as exported.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:189,avoid,avoid,189,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,1,['avoid'],['avoid']
Safety,"// A declaration of the partial specialization must be visible.; // We can always recover here, because this only happens when we're; // entering the context, and that can't happen in a SFINAE context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:82,recover,recover,82,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['recover'],['recover']
Safety,"// A declaration with an owning module for linkage can never link against; // anything that is not visible. We don't need to check linkage here; if; // the context has internal linkage, redeclaration lookup won't find things; // from other TUs, and we can't safely compute linkage yet in general.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:258,safe,safely,258,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['safe'],['safely']
Safety,// A definition of a single resource script token. Each token has its kind; // (declared in ResourceScriptTokenList) and holds a value - a reference; // representation of the token.; // RCToken does not claim ownership on its value. A memory buffer containing; // the token value should be stored in a safe place and cannot be freed; // nor reallocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsResource/ResourceScriptToken.h:302,safe,safe,302,interpreter/llvm-project/llvm/include/llvm/WindowsResource/ResourceScriptToken.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsResource/ResourceScriptToken.h,2,['safe'],['safe']
Safety,"// A first loop to retrieve the mother classes before starting to; // fill this TClass instance. This is done in order to avoid recursions; // for example in presence of daughter and mother class present in two; // dictionaries compiled in two different libraries which are not linked; // one with each other.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TProtoClass.cxx:122,avoid,avoid,122,core/meta/src/TProtoClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TProtoClass.cxx,1,['avoid'],['avoid']
Safety,"// A first sanity check",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/XMLReader.cxx:11,sanity check,sanity check,11,core/dictgen/src/XMLReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/XMLReader.cxx,1,['sanity check'],['sanity check']
Safety,"// A frame index will resolve to a positive constant, so it should always be; // safe to fold the addressing mode, even pre-GFX9.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp:81,safe,safe,81,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,1,['safe'],['safe']
Safety,"// A funnel shift (rotate) can be decomposed into simpler shifts. See if we; // are mixing in another shift that is redundant with the funnel shift.; // (fshl X, ?, Y) | (shl X, Y) --> fshl X, ?, Y; // (shl X, Y) | (fshl X, ?, Y) --> fshl X, ?, Y",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:116,redund,redundant,116,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['redund'],['redundant']
Safety,"// A global variable is a root if it is a pointer, or could plausibly contain; // a pointer. There are two challenges; one is that we could have a struct; // the has an inner member which is a pointer. We recurse through the type to; // detect these (up to a point). The other is that we may actually be a union; // of a pointer and another type, and so our LLVM type is an integer which; // gets converted into a pointer, or our type is an [i8 x #] with a pointer; // potentially contained here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:237,detect,detect,237,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['detect'],['detect']
Safety,"// A hack... we need to insert the aliasing info in a predictable order for; // lit tests. Would like to have them in a stable order already, ideally the; // same order they get allocated, which might mean an ordered set container",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:54,predict,predictable,54,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['predict'],['predictable']
Safety,// A helper class to help with address of function resolution; // - allows us to avoid passing around all those ugly parameters,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:81,avoid,avoid,81,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['avoid'],['avoid']
Safety,"// A list of the template argument list flattened in a predictible manner for; // the purposes of caching. The ConstraintSatisfaction type is in AST so it; // has no access to the MultiLevelTemplateArgumentList, so this has to happen; // here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:55,predict,predictible,55,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,1,['predict'],['predictible']
Safety,"// A load from a fixed stack slot can be rematerialized. This may be; // redundant with subsequent checks, but it's target-independent,; // simple, and a common case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:73,redund,redundant,73,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,1,['redund'],['redundant']
Safety,"// A load of a floating-point value into the high-order half of; // a vector register is safe, provided that we introduce a swap; // following the load, which will be done by the SUBREG_TO_REG; // support. So just mark these as safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:89,safe,safe,89,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,2,['safe'],['safe']
Safety,"// A logical: should predictor winnowing (i.e feature selection) be used?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/inc/TMVA/MethodC50.h:21,predict,predictor,21,tmva/rmva/inc/TMVA/MethodC50.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/inc/TMVA/MethodC50.h,1,['predict'],['predictor']
Safety,// A map to avoid duplicate got entries (Mips64 specific),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h:12,avoid,avoid,12,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.h,1,['avoid'],['avoid']
Safety,// A mapping between the virtual memory address to the instruction metadata; // struct. TODO(hctim): Reimplement this as a sorted vector to avoid per-; // insertion allocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h:140,avoid,avoid,140,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,1,['avoid'],['avoid']
Safety,"// A new HazardRec is created for each DAG and owned by SchedBoundary.; // Destroying and reconstructing it is very expensive though. So keep; // invalid, placeholder HazardRecs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:9,Hazard,HazardRec,9,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['Hazard'],"['HazardRec', 'HazardRecs']"
Safety,"// A note on note{Pre, Post}{Use, Mod}:; //; // (It helps to follow the algorithm with an expression such as; // ""((++k)++, k) = k"" or ""k = (k++, k++)"". Both contain unsequenced; // operations before C++17 and both are well-defined in C++17).; //; // When visiting a node which uses/modify an object we first call notePreUse; // or notePreMod before visiting its sub-expression(s). At this point the; // children of the current node have not yet been visited and so the eventual; // uses/modifications resulting from the children of the current node have not; // been recorded yet.; //; // We then visit the children of the current node. After that notePostUse or; // notePostMod is called. These will 1) detect an unsequenced modification; // as side effect (as in ""k++ + k"") and 2) add a new usage with the; // appropriate usage kind.; //; // We also have to be careful that some operation sequences modification as; // side effect as well (for example: || or ,). To account for this we wrap; // the visitation of such a sub-expression (for example: the LHS of || or ,); // with SequencedSubexpression. SequencedSubexpression is an RAII object; // which record usages which are modifications as side effect, and then; // downgrade them (or more accurately restore the previous usage which was a; // modification as side effect) when exiting the scope of the sequenced; // subexpression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:705,detect,detect,705,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['detect'],['detect']
Safety,"// A pseudo probe verifier that can be run after each IR passes to detect the; // violation of updating probe factors. In principle, the sum of distribution; // factor for a probe should be identical before and after a pass. For a; // function pass, the factor sum for a probe would be typically 100%.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h:67,detect,detect,67,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h,1,['detect'],['detect']
Safety,"// A safer alternative would be to recompile the whole thing .... However; // currently compile HAS TO be called from the constructor!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormulaManager.cxx:5,safe,safer,5,tree/treeplayer/src/TTreeFormulaManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormulaManager.cxx,1,['safe'],['safer']
Safety,// A self-debugging facility that you can use to notify the user when; // suggestions or fixits are incomplete.; // Uses std::function to avoid computing the message when it won't; // actually be displayed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/UnsafeBufferUsage.h:138,avoid,avoid,138,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/UnsafeBufferUsage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/UnsafeBufferUsage.h,1,['avoid'],['avoid']
Safety,// A semicolon was missing after this declaration. Diagnose and recover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:64,recover,recover,64,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,['recover'],['recover']
Safety,// A simple interval overlap detection algorithm. Sorts all ranges by their; // begin location then finds the first overlap in one pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:29,detect,detection,29,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['detect'],['detection']
Safety,// A small number of targets have no predicates. Null terminate the array to; // avoid a zero-length array.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetFeatureInfo.cpp:81,avoid,avoid,81,interpreter/llvm-project/llvm/utils/TableGen/SubtargetFeatureInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetFeatureInfo.cpp,1,['avoid'],['avoid']
Safety,// A sub-register definition can only be rematerialized if the instruction; // doesn't read the other parts of the register. Otherwise it is really a; // read-modify-write operation on the full virtual register which cannot be; // moved safely.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:237,safe,safely,237,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,1,['safe'],['safely']
Safety,"// A two-CLC sequence is a clear win over a loop, not least because; // it needs only one branch. A three-CLC sequence needs the same; // number of branches as a loop (i.e. 2), but is shorter. That; // brings us to lengths greater than 768 bytes. It seems relatively; // likely that a difference will be found within the first 768 bytes,; // so we just optimize for the smallest number of branch; // instructions, in order to avoid polluting the prediction buffer; // too much.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:426,avoid,avoid,426,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,2,"['avoid', 'predict']","['avoid', 'prediction']"
Safety,"// A udiv/urem with a common divisor is safe because UB can only occur with; // div-by-zero, and that would be present in the original code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:40,safe,safe,40,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['safe'],['safe']
Safety,"// A universal file member can be a MachOObjectFile, an IRObject or an; // Archive. In case we can successfully cast the member as an Archive,; // it is safe to throw away the error generated due to casting the; // object as a MachOObjectFile.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp:153,safe,safe,153,interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp,1,['safe'],['safe']
Safety,"// A universal file member can be a MachOObjectFile, an IRObject or an; // Archive. In case we can successfully cast the member as an; // IRObject, it is safe to throw away the error generated due to; // casting the object as a MachOObjectFile.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp:154,safe,safe,154,interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp,1,['safe'],['safe']
Safety,"// A value in the reduction can be used:; // - By the reduction:; // - Reduction operation:; // - One use of reduction value (safe).; // - Multiple use of reduction value (not safe).; // - PHI:; // - All uses of the PHI must be the reduction (safe).; // - Otherwise, not safe.; // - By instructions outside of the loop (safe).; // * One value may have several outside users, but all outside; // uses must be of the same value.; // - By store instructions with a loop invariant address (safe with; // the following restrictions):; // * If there are several stores, all must have the same address.; // * Final value should be stored in that loop invariant address.; // - By an instruction that is not part of the reduction (not safe).; // This is either:; // * An instruction type other than PHI or the reduction operation.; // * A PHI in the header other than the initial PHI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:126,safe,safe,126,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,7,['safe'],['safe']
Safety,"// A variable array type that has an initializer can only do empty; // initialization. And because this feature is not exposed as an extension; // in C++, we can safely memset the array memory to zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp:162,safe,safely,162,interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,1,['safe'],['safely']
Safety,"// A vector of MachineInstr/unsigned pairs to denote potential aliases that; // need to be checked before the candidate is considered safe to merge. The; // unsigned value is an index into the Stores vector. The indexed store is; // the highest-indexed store that has already been checked to not have an; // alias with the instruction. We record this so we don't have to repeat; // alias checks that have been already done, only those with stores added; // after the potential alias is recorded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h:134,safe,safe,134,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h,1,['safe'],['safe']
Safety,// A.3 Branch on Integer Register with Prediction (BPr); // Inst{21-20} = d16hi;; // Inst{13-0} = d16lo;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcAsmBackend.cpp:39,Predict,Prediction,39,interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcAsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/MCTargetDesc/SparcAsmBackend.cpp,1,['Predict'],['Prediction']
Safety,"// AA might be used later for instruction scheduling, and we need it to be; // able to deduce the correct aliasing releationships between pointers; // derived from the alloca being remapped and the target of that remapping.; // The only safe way, without directly informing AA about the remapping; // somehow, is to directly update the IR to reflect the change being made; // here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:237,safe,safe,237,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,1,['safe'],['safe']
Safety,"// AAPCS requires i1 to be zero-extended to i8 by the producer of the; // value. This is strictly redundant on Darwin (which uses ""zeroext; // i1""), but will be optimised out before ISel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:98,redund,redundant,98,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['redund'],['redundant']
Safety,"// ANDI Rd, 0xff is redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:20,redund,redundant,20,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,1,['redund'],['redundant']
Safety,"// ARMEmitCmp emits a FMSTAT when necessary, so it's always safe to use CPSR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:60,safe,safe,60,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,1,['safe'],['safe']
Safety,"// AVoid problems with empty URLs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofMgr.cxx:3,AVoid,AVoid,3,proof/proof/src/TProofMgr.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofMgr.cxx,1,['AVoid'],['AVoid']
Safety,// Abort as soon as a match is found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:3,Abort,Abort,3,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,2,['Abort'],['Abort']
Safety,// Abort at the end of a chain (without finding a suitable source).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:3,Abort,Abort,3,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['Abort'],['Abort']
Safety,// Abort errors and other errors are handled the same,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:3,Abort,Abort,3,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,1,['Abort'],['Abort']
Safety,// Abort here if not all requirements can be satisfied.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:3,Abort,Abort,3,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,1,['Abort'],['Abort']
Safety,// Abort if ALU offset is not a register or immediate,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:3,Abort,Abort,3,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,1,['Abort'],['Abort']
Safety,// Abort if any of the inner matchers can't be converted to; // Matcher<T>.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/VariantValue.cpp:3,Abort,Abort,3,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/VariantValue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/VariantValue.cpp,1,['Abort'],['Abort']
Safety,// Abort if it's unsupported in order to prevent corrupting the object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOLayoutBuilder.cpp:3,Abort,Abort,3,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOLayoutBuilder.cpp,1,['Abort'],['Abort']
Safety,// Abort if not all the regunits are reserved.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:3,Abort,Abort,3,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['Abort'],['Abort']
Safety,// Abort if the element is not an extension.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Abort,Abort,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Abort'],['Abort']
Safety,// Abort if the requested VP intrinsic could not be created.; // This is useful for strict consistency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/VectorBuilder.h:3,Abort,Abort,3,interpreter/llvm-project/llvm/include/llvm/IR/VectorBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/VectorBuilder.h,1,['Abort'],['Abort']
Safety,// Abort if the spill cannot be inserted at the MBB' start,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:3,Abort,Abort,3,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,2,['Abort'],['Abort']
Safety,"// Abort if the table has no columns at all or if the total width; // of the table is zero or less.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx:3,Abort,Abort,3,gui/guihtml/src/TGHtmlTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx,1,['Abort'],['Abort']
Safety,// Abort if there is no register info or function info.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Abort,Abort,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['Abort'],['Abort']
Safety,// Abort if there's no change,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:3,Abort,Abort,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Abort'],['Abort']
Safety,// Abort if this would be too expensive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp:3,Abort,Abort,3,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.cpp,1,['Abort'],['Abort']
Safety,// Abort if typo correction already failed for this specific typo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Abort,Abort,3,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['Abort'],['Abort']
Safety,// Abort if we can't understand the usage,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:3,Abort,Abort,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Abort'],['Abort']
Safety,// Abort if we cannot possibly implement the COPY with the given indexes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:3,Abort,Abort,3,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,2,['Abort'],['Abort']
Safety,// Abort if we have more than one user per component.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:3,Abort,Abort,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Abort'],['Abort']
Safety,"// Abort if we have only part of the servers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimultaneous.cxx:3,Abort,Abort,3,roofit/roofitcore/src/RooSimultaneous.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimultaneous.cxx,1,['Abort'],['Abort']
Safety,"// Abort if we have to process too many values to get a result for this one.; // Because of the design of the overdefined cache currently being per-block; // to avoid naming-related issues (IE it wants to try to give different; // results for the same name in different blocks), overdefined results don't; // get cached globally, which in turn means we will often try to rediscover; // the same overdefined result again and again. Once something like; // PredicateInfo is used in LVI or CVP, we should be able to make the; // overdefined cache global, and remove this throttle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:3,Abort,Abort,3,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,2,"['Abort', 'avoid']","['Abort', 'avoid']"
Safety,"// Abort import if declaration file cannot be opened",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx:3,Abort,Abort,3,roofit/roofitcore/src/RooWorkspace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx,1,['Abort'],['Abort']
Safety,"// Abort import if implementation file cannot be opened",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx:3,Abort,Abort,3,roofit/roofitcore/src/RooWorkspace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx,1,['Abort'],['Abort']
Safety,"// Abort on higher than kSysError's and set error handler",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx:3,Abort,Abort,3,net/net/src/TApplicationServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx,2,['Abort'],['Abort']
Safety,// Abort slicing if it does not seem to be profitable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Abort,Abort,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Abort'],['Abort']
Safety,// Abort the operation as we can't update all CSR restores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Abort,Abort,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['Abort'],['Abort']
Safety,// Abort when there are too few insts with common base.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:3,Abort,Abort,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,1,['Abort'],['Abort']
Safety,"// Abort, we can't find a restore point in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:3,Abort,Abort,3,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,1,['Abort'],['Abort']
Safety,"// Abort, we can't find a restore point in this case.; // Make sure we would be able to insert the restore code before the; // terminator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:3,Abort,Abort,3,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,1,['Abort'],['Abort']
Safety,"// Aborted",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:3,Abort,Aborted,3,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['Abort'],['Aborted']
Safety,"// Abortion test",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/proof/ProofEventProc.h:3,Abort,Abortion,3,tutorials/proof/ProofEventProc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/proof/ProofEventProc.h,1,['Abort'],['Abortion']
Safety,"// Above loop misses the last (or only) range. If we are still safe, then; // let's save the range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:63,safe,safe,63,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['safe'],['safe']
Safety,"// Accessors can be wrapped in a try-catch block, so throwing the; // exception here is akin to checking the error.; //; // Setting fIsChecked to true also avoids a spurious warning in the RResult destructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx:156,avoid,avoids,156,core/foundation/v7/inc/ROOT/RError.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx,1,['avoid'],['avoids']
Safety,"// According to GCC info page:; //; // 6.28 Compound Literals; //; // As an optimization, G++ sometimes gives array compound literals longer; // lifetimes: when the array either appears outside a function or has a; // const-qualified type. If foo and its initializer had elements of type; // char *const rather than char *, or if foo were a global variable, the; // array would have static storage duration. But it is probably safest; // just to avoid the use of array compound literals in C++ code.; //; // Obey that rule by checking constness for converted array types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:427,safe,safest,427,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,2,"['avoid', 'safe']","['avoid', 'safest']"
Safety,"// According to the AArch64 Procedure Call Standard, the following are; // undefined on entry/exit from a function call:; //; // * Registers x16, x17, (and thus w16, w17); // * Condition codes (and thus the NZCV register); //; // If any of these registers are used inside or live across an outlined; // function, then they may be modified later, either by the compiler or; // some other tool (like the linker).; //; // To avoid outlining in these situations, partition each block into ranges; // where these registers are dead. We will only outline from those ranges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:422,avoid,avoid,422,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['avoid'],['avoid']
Safety,"// According to the PE-COFF spec, the LSB of this value marks the object; // for ""registered SEH"". This means that all SEH handler entry points; // must be registered in .sxdata. Use of any unregistered handlers will; // cause the process to terminate immediately. LLVM does not know how to; // register any SEH handlers, so its object files should be safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:352,safe,safe,352,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,1,['safe'],['safe']
Safety,// Accumulate all of the case values in a vector so that we can sort them; // and detect duplicates. This vector contains the APInt for the case after; // it has been converted to the condition type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:82,detect,detect,82,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['detect'],['detect']
Safety,"// Accurate safety is expensive, use the bounding box",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoXtru.cxx:12,safe,safety,12,geom/geom/src/TGeoXtru.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoXtru.cxx,1,['safe'],['safety']
Safety,// Acquires a slot from every buffered resource in mask `ConsumedBuffers`.; // Units that are dispatch hazards (i.e. BufferSize=0) are marked as reserved.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:103,hazard,hazards,103,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['hazard'],['hazards']
Safety,"// Acquiring a handle is not always successful. In Fuchsia most functions; // return a status code that determines the status of the handle.; // When we split the path based on this status code we know that on one; // path we do have the handle and on the other path the acquire failed.; // This method helps avoiding false positive leak warnings on paths where; // the function failed.; // Moreover, when a handle is known to be zero (the invalid handle),; // we no longer can follow the symbol on the path, becaue the constant; // zero will be used instead of the symbol. We also do not need to release; // an invalid handle, so we remove the corresponding symbol from the state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp:309,avoid,avoiding,309,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/FuchsiaHandleChecker.cpp,1,['avoid'],['avoiding']
Safety,// Actually process results here; this need to be a separate loop to avoid; // calling getNonLocalPointerDepFromBB for blocks we don't want to return; // any results for. (getNonLocalPointerDepFromBB will modify our; // datastructures in ways the code after the PredTranslationFailure label; // doesn't expect.),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:69,avoid,avoid,69,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['avoid'],['avoid']
Safety,"// Actually we don't need this COPY instruction. However if we do nothing with; // it, post RA pseudo instrs expansion just removes it and we get the code; // with undef registers. Therefore, we need to replace all uses of dst with; // the src register. COPY instr itself will be safely removed later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstrInfo.cpp:280,safe,safely,280,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstrInfo.cpp,1,['safe'],['safely']
Safety,"// Add !invariant.load md to virtual function load to indicate that; // function didn't change inside vtable.; // It's safe to add it without -fstrict-vtable-pointers, but it would not; // help in devirtualization because it will only matter if we will have 2; // the same virtual function loads from the same vtable load, which won't; // happen without enabled devirtualization with -fstrict-vtable-pointers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:119,safe,safe,119,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['safe'],['safe']
Safety,"// Add 1 to the id, to avoid the id of 0, which is treated as ""null"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:23,avoid,avoid,23,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,1,['avoid'],['avoid']
Safety,"// Add 1% each way to avoid any rounding conflicts with drawn objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLPerspectiveCamera.cxx:22,avoid,avoid,22,graf3d/gl/src/TGLPerspectiveCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLPerspectiveCamera.cxx,1,['avoid'],['avoid']
Safety,"// Add a \n here to avoid long lines which contain duplications, for example (from MathCore):; // namespace ROOT { namespace Math { class IBaseFunctionMultiDim; } }namespace ROOT { namespace Fit { template <typename FunType> class Chi2FCN; } }; // namespace ROOT { namespace Math { class IGradientFunctionMultiDim; } }namespace ROOT { namespace Fit { template <typename FunType> class Chi2FCN; } }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:20,avoid,avoid,20,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['avoid'],['avoid']
Safety,// Add a label to mark the beginning of the landing pad. Deletion of the; // landing pad can thus be detected via the MachineModuleInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:101,detect,detected,101,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,2,['detect'],['detected']
Safety,"// Add a random string to the filename to avoid races.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/TModuleGenerator.cxx:42,avoid,avoid,42,core/dictgen/src/TModuleGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/TModuleGenerator.cxx,1,['avoid'],['avoid']
Safety,"// Add a redundant copy of the callee global which will not be legalized, as; // we need direct access to the callee later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:9,redund,redundant,9,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['redund'],['redundant']
Safety,// Add an entry to ProcessedTruncs to avoid counting the same; // operand multiple times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:38,avoid,avoid,38,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,1,['avoid'],['avoid']
Safety,"// Add an extra element to the shuffle, taking it from element Elem of Op.; // A null Op indicates a vector input whose value will be calculated later;; // there is at most one such input per shuffle and it always has the same; // type as the result. Aborts and returns false if the source vector elements; // of an EXTRACT_VECTOR_ELT are smaller than the destination elements. Per; // LLVM they become implicitly extended, but this is rare and not optimized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:251,Abort,Aborts,251,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['Abort'],['Aborts']
Safety,// Add any parameter attributes except the ones incompatible with the new; // type. Note that we made sure all incompatible ones are safe to drop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:133,safe,safe,133,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['safe'],['safe']
Safety,// Add both the safe stack and the stack protection passes: each of them will; // only protect functions that have corresponding attributes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:16,safe,safe,16,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,2,['safe'],['safe']
Safety,"// Add epsilon to avoid singularities",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:18,avoid,avoid,18,hist/hist/src/TSVDUnfold.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx,1,['avoid'],['avoid']
Safety,// Add instrumented globals to llvm.compiler.used list to avoid LTO from; // ConstantMerge'ing them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:58,avoid,avoid,58,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['avoid'],['avoid']
Safety,// Add live symbol to avoid dead-stripping for .ARM.exidx sections,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h:22,avoid,avoid,22,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELFLinkGraphBuilder.h,1,['avoid'],['avoid']
Safety,"// Add metadata to avoid reapplying a transformation, such as; // llvm.loop.unroll.disable and llvm.loop.isvectorized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:19,avoid,avoid,19,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,1,['avoid'],['avoid']
Safety,// Add methods in superclass.; // Avoid passing in IsRootClass since root classes won't have super classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:34,Avoid,Avoid,34,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['Avoid'],['Avoid']
Safety,"// Add new reverse deps after scanning the set, to avoid invalidating 'Set'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:51,avoid,avoid,51,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['avoid'],['avoid']
Safety,"// Add new reverse deps after scanning the set, to avoid invalidating the; // 'ReverseDeps' reference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:51,avoid,avoid,51,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['avoid'],['avoid']
Safety,"// Add output dependence to the next nearest defs of this vreg.; //; // Unless this definition is dead, the output dependence should be; // transitively redundant with antidependencies from this definition's; // uses. We're conservative for now until we have a way to guarantee the uses; // are not eliminated sometime during scheduling. The output dependence edge; // is also useful if output latency exceeds def-use latency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:153,redund,redundant,153,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['redund'],['redundant']
Safety,"// Add safety check here - applyTrackingOpt will only be applied if present; // dataset is constructed in terms of a RooVectorDataStore",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx:7,safe,safety,7,roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,2,['safe'],['safety']
Safety,// Add static function to initialize some of the meta-data fields.; // avoid doing it twice.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:71,avoid,avoid,71,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,1,['avoid'],['avoid']
Safety,"// Add tag to the list of processed tags to avoid double processing; // (there may be more objects with the same name, created by each worker)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:44,avoid,avoid,44,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['avoid'],['avoid']
Safety,// Add the 'const' to the type to recover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:34,recover,recover,34,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['recover'],['recover']
Safety,"// Add the function's symbol to the .gfids section.; // Note: For dllimport functions, MSVC sometimes does not add this symbol; // to the .gfids section, but only adds the corresponding ""__imp_"" symbol; // to the .giats section. Here we always add the symbol to the .gfids; // section, since this does not introduce security risks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinCFGuard.cpp:325,risk,risks,325,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinCFGuard.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinCFGuard.cpp,1,['risk'],['risks']
Safety,"// Add the given requirements to the lists. If constraints conflict, or these; // requirements cannot be satisfied, then abort the compilation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:121,abort,abort,121,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,1,['abort'],['abort']
Safety,"// Add the inputs to the Ops list, avoiding duplicates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:35,avoid,avoiding,35,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoiding']
Safety,// Add the internal paths from a driver that detects standard include paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:45,detect,detects,45,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['detect'],['detects']
Safety,"// Add the internal paths from a driver that detects standard include paths.; // Note: Some paths that came from ""-internal-isystem"" arguments may have; // already been generated as ""-isystem"". If that's the case, their position on; // command line was such that this has no semantic impact on include paths.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:45,detect,detects,45,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['detect'],['detects']
Safety,"// Add the non-lazy-bind attribute, since objc_loadClassref is likely to; // be called a lot.; //; // Also it is safe to make it readnone, since we never load or store the; // classref except by calling this function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:113,safe,safe,113,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['safe'],['safe']
Safety,"// Add the record to the collection if we don't already have a record that; // points to the same function name. This is useful to ignore the redundant; // records for the functions with ODR linkage.; // In addition, prefer records with real coverage mapping data to dummy; // records, which were emitted for inline functions which were seen but; // not used in the corresponding translation unit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp:142,redund,redundant,142,interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,1,['redund'],['redundant']
Safety,"// Add this particle's energy loss at the total; // energy loss into the detector",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:73,detect,detector,73,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,1,['detect'],['detector']
Safety,"// Adding the permute dimensions if present, else are avoided to use default values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/RModelParser_Keras.cxx:54,avoid,avoided,54,tmva/pymva/src/RModelParser_Keras.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/RModelParser_Keras.cxx,1,['avoid'],['avoided']
Safety,"// Adding the prefix can cause problems when one file has a ""foo"" and; // another has a ""\01foo"". That is known to happen on ELF with the; // tricks normally used for producing aliases (PR9177). Fortunately the; // llvm mangler on ELF is a nop, so we can just avoid adding the \01; // marker.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Mangle.cpp:260,avoid,avoid,260,interpreter/llvm-project/clang/lib/AST/Mangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Mangle.cpp,1,['avoid'],['avoid']
Safety,// Additional operators needed to avoid ambiguous parses; // because of the implicit conversion hack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h:34,avoid,avoid,34,interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h,1,['avoid'],['avoid']
Safety,"// Additionally need to drop all global values from the comdat to; // available_externally, to satisfy the COMDAT requirement that all members; // are discarded as a unit. The non-local linkage global values avoid; // duplicate definition linker errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:208,avoid,avoid,208,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['avoid'],['avoid']
Safety,// Adds the unsafe-buffer attribute (if not already there) to `FReDecl`:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:12,unsafe,unsafe-buffer,12,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['unsafe'],['unsafe-buffer']
Safety,// Adjust RegAssign if a register assignment is killed at Def. We want to; // avoid calculating the live range of the source register if possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:78,avoid,avoid,78,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,1,['avoid'],['avoid']
Safety,// Adjust SP by Amount bytes where bytes can be up to 32bit number.; // This can only be called at times that we know that there is at least one free; // register.; // This is clearly safe at prologue and epilogue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp:184,safe,safe,184,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.cpp,1,['safe'],['safe']
Safety,"// Adjust insert point to be after instructions inserted by the expander, so; // we can re-use already inserted instructions. Avoid skipping past the; // original \p MustDominate, in case it is an inserted instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:126,Avoid,Avoid,126,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['Avoid'],['Avoid']
Safety,"// Adjust potentially 's' setting instructions after isel, i.e. ADC, SBC, RSB,; // RSC. Coming out of isel, they have an implicit CPSR def, but the optional; // operand is still set to noreg. If needed, set the optional operand's; // register to CPSR, and remove the redundant implicit def.; //; // e.g. ADCS (..., implicit-def CPSR) -> ADC (... opt:def CPSR).; // Rename pseudo opcodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:267,redund,redundant,267,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['redund'],['redundant']
Safety,// Adjust the stack pointer to make room for the arguments.; // FIXME: Use hasReservedCallFrame to avoid %sp adjustments around all calls; // with more than 6 arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:99,avoid,avoid,99,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,2,['avoid'],['avoid']
Safety,// Advance UI to the next non-I use to avoid invalidating it!; // Instructions could multiply use V.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:39,avoid,avoid,39,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['avoid'],['avoid']
Safety,// Advance over a MachineInstr bundle. Look for hazards in the bundled; // instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.h:48,hazard,hazards,48,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.h,1,['hazard'],['hazards']
Safety,"// Advance the pointer here, to avoid invalidation issues when the old; // PHI is erased.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:32,avoid,avoid,32,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,1,['avoid'],['avoid']
Safety,// Advance to a place where it is safe to insert the new store and insert it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:34,safe,safe,34,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['safe'],['safe']
Safety,"// After emitting the diagnostic, bypass the overriding file to recover; // (this creates a separate FileEntry).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:64,recover,recover,64,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['recover'],['recover']
Safety,"// After getting the multiplication result in 4 parts, we need to perform a; // shift right by the amount of the scale to get the result in that scale.; //; // Let's say we multiply 2 64 bit numbers. The resulting value can be held in; // 128 bits that are cut into 4 32-bit parts:; //; // HH HL LH LL; // |---32---|---32---|---32---|---32---|; // 128 96 64 32 0; //; // |------VTSize-----|; //; // |NVTSize-|; //; // The resulting Lo and Hi would normally be in LL and LH after the shift. But; // to avoid unneccessary shifting of all 4 parts, we can adjust the shift; // amount and get Lo and Hi using two funnel shifts. Or for the special case; // when Scale is a multiple of NVTSize we can just pick the result without; // shifting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:501,avoid,avoid,501,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['avoid'],['avoid']
Safety,"// After scanning this function, if we still have entries in callsites, then; // they are dangling pointers. WeakTrackingVH should save us for this, so; // abort if; // this happens.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:156,abort,abort,156,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,1,['abort'],['abort']
Safety,"// After the abort button has been pressed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h:13,abort,abort,13,proof/proof/inc/TProof.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h,1,['abort'],['abort']
Safety,// After this it is safe to delete instructions.; // Delete all of the method arguments and unlink from symbol table...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp:20,safe,safe,20,interpreter/llvm-project/llvm/lib/IR/Function.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Function.cpp,1,['safe'],['safe']
Safety,"// After we have saved the token reset the current one to something which; // is safe (semi colon usually means empty decl)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/ClingRAII.h:81,safe,safe,81,core/metacling/src/ClingRAII.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/ClingRAII.h,2,['safe'],['safe']
Safety,"// After we have saved the token reset the current one to something; // which is safe (semi colon usually means empty decl)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ClingPragmas.cpp:81,safe,safe,81,interpreter/cling/lib/Interpreter/ClingPragmas.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ClingPragmas.cpp,1,['safe'],['safe']
Safety,"// Aggregate assignment turns into llvm.memcpy. This is almost valid per; // C99 6.5.16.1p3, which states ""If the value being stored in an object is; // read from another object that overlaps in anyway the storage of the first; // object, then the overlap shall be exact and the two objects shall have; // qualified or unqualified versions of a compatible type.""; //; // memcpy is not defined if the source and destination pointers are exactly; // equal, but other compilers do this optimization, and almost every memcpy; // implementation handles this case safely. If there is a libc that does not; // safely handle this, we can add a target hook.; // Get data size info for this aggregate. Don't copy the tail padding if this; // might be a potentially-overlapping subobject, since the tail padding might; // be occupied by a different object. Otherwise, copying it is fine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp:558,safe,safely,558,interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,2,['safe'],['safely']
Safety,// Aggregate values are safe if all their elements are.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:24,safe,safe,24,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,1,['safe'],['safe']
Safety,// Aligned read to sanity check that the buffer was allocated with at least 8b; // alignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp:19,sanity check,sanity check,19,interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,1,['sanity check'],['sanity check']
Safety,// All 8 byte instructions may require alignment. Each 8 byte; // instruction may be aligned by another 4 bytes.; // This means that an 8 byte instruction may require 12 bytes; // (8 for the instruction itself and 4 for the alignment nop).; // This will happen if an 8 byte instruction can be aligned to 64 bytes; // by only adding a 4 byte nop.; // We don't know the alignment at this point in the code so we have to; // adopt a more pessimistic approach. If an instruction may need; // alignment we assume that it does need alignment and add 4 bytes to; // it. As a result we may end up with more long branches than before; // but we are in the safe position where if we need a long branch we; // have one.; // The if statement checks to make sure that two 8 byte instructions; // are at least 64 bytes away from each other. It is not possible for; // two instructions that both need alignment to be within 64 bytes of; // each other.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp:647,safe,safe,647,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp,1,['safe'],['safe']
Safety,"// All Hexagon architectures have prediction bits on dot-new branches,; // but only Hexagon V60+ has prediction bits on dot-old ones. Make sure; // to pick the right opcode when converting back to dot-old.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:34,predict,prediction,34,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,2,['predict'],['prediction']
Safety,// All IR flags are safe to back-propagate because any potential poison; // created in unused vector elements is discarded by the extract.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:20,safe,safe,20,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['safe'],['safe']
Safety,// All IR flags are safe to back-propagate. There is no potential for extra; // poison to be created by the scalar instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:20,safe,safe,20,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['safe'],['safe']
Safety,"// All PHIs in the inner and outer headers must either be:; // - The induction PHI, which we are going to rewrite as one induction in; // the new loop. This is already checked by findLoopComponents.; // - An outer header PHI with all incoming values from outside the loop.; // LoopSimplify guarantees we have a pre-header, so we don't need to; // worry about that here.; // - Pairs of PHIs in the inner and outer headers, which implement a; // loop-carried dependency that will still be valid in the new loop. To; // be valid, this variable must be modified only in the inner loop.; // The set of PHI nodes in the outer loop header that we know will still be; // valid after the transformation. These will not need to be modified (with; // the exception of the induction variable), but we do need to check that; // there are no unsafe PHI nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:828,unsafe,unsafe,828,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,1,['unsafe'],['unsafe']
Safety,// All checks are done. Add instructions detectable by InterleavedAccessPass; // The old instruction will are left dead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:41,detect,detectable,41,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,1,['detect'],['detectable']
Safety,"// All conflicts with previous declarations are recovered by; // returning the previous declaration, unless this is a definition,; // in which case we want the caller to bail out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,recover,recovered,48,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recovered']
Safety,"// All conflicts with previous declarations are recovered by; // returning the previous declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp:48,recover,recovered,48,interpreter/cling/lib/Interpreter/DeclExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp,1,['recover'],['recovered']
Safety,"// All incoming values are zexts or constants that are safe to truncate.; // Create a new phi node of the narrow type, phi together all of the new; // operands, and zext the result back to the original type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:55,safe,safe,55,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,1,['safe'],['safe']
Safety,"// All invalid items are sorted at the end, so it's safe to stop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:52,safe,safe,52,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,3,['safe'],['safe']
Safety,"// All of the ""abstract"" emission methods below permit the emission to; // be immediately discarded without finalizing anything. Therefore, they; // must also promise not to do anything that will, in the future, require; // finalization:; //; // - using the CGF (if present) for anything other than establishing; // semantic context; for example, an expression with ignored; // side-effects must not be emitted as an abstract expression; //; // - doing anything that would not be safe to duplicate within an; // initializer or to propagate to another context; for example,; // side effects, or emitting an initialization that requires a; // reference to its current location.; /// Try to emit the initializer of the given declaration as an abstract; /// constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ConstantEmitter.h:480,safe,safe,480,interpreter/llvm-project/clang/lib/CodeGen/ConstantEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ConstantEmitter.h,1,['safe'],['safe']
Safety,"// All of the methods of interest are static, so avoid any lookup for; // non-static methods (the common case).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/ChromiumCheckModel.cpp:49,avoid,avoid,49,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/ChromiumCheckModel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/ChromiumCheckModel.cpp,1,['avoid'],['avoid']
Safety,// All other OpenMP runtime calls will not reach parallel regions so they; // can be safely ignored for now. Since it is a known OpenMP runtime call; // we have now modeled all effects and there is no need for any update.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:85,safe,safely,85,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['safe'],['safely']
Safety,"// All simm32 constants should be handled by isel.; // NOTE: The getMaxBuildIntsCost call below should return a value >= 2 making; // this check redundant, but small immediates are common so this check; // should have better compile time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:145,redund,redundant,145,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['redund'],['redundant']
Safety,"// All stores must be the same size to ensure that we are writing all of the; // bytes in the wide value.; // This store should have exactly one use as a chain operand for another; // store in the merging set. If there are other chain uses, then the; // transform may not be safe because order of loads/stores outside of this; // set may not be preserved.; // TODO: We could allow multiple sizes by tracking each stored byte.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:275,safe,safe,275,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['safe'],['safe']
Safety,"// All subscripts are all the same type.; // Loop bound may be smaller (e.g., a char).; // Should zero extend loop bound, since it's always >= 0.; // This routine collects upper bound and extends or truncates if needed.; // Truncating is safe when subscripts are known not to wrap. Cases without; // nowrap flags should have been rejected earlier.; // Return null if no bound available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:238,safe,safe,238,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['safe'],['safe']
Safety,"// All uses of the alloca are safe, we can place it on the safe stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:30,safe,safe,30,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,2,['safe'],['safe']
Safety,"// All uses of the arguments should have been resolved by this point,; // so we can safely remove the dummy values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:84,safe,safely,84,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['safe'],['safely']
Safety,// All uses of the shuffle should be sunk to avoid duplicating it across gpr; // and vector registers,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:45,avoid,avoid,45,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,['avoid'],['avoid']
Safety,// Allocate space for every unsafe static AllocaInst on the unsafe stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:28,unsafe,unsafe,28,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,2,['unsafe'],['unsafe']
Safety,"// Allocate the mask array for the node out of the BumpPtrAllocator, since; // SDNode doesn't have access to it. This memory will be ""leaked"" when; // the node is deallocated, but recovered when the NodeAllocator is released.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:180,recover,recovered,180,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['recover'],['recovered']
Safety,// Allocating variables that are used directly in this struct to get; // alignment aware allocation and predictable frame size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:104,predict,predictable,104,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['predict'],['predictable']
Safety,// Allocator for ConversionSequenceLists. We store the first few of these; // inline to avoid allocation for small sets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h:88,avoid,avoid,88,interpreter/llvm-project/clang/include/clang/Sema/Overload.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h,1,['avoid'],['avoid']
Safety,// Allow #defining |and| and friends for Microsoft compatibility or; // recovery when legacy C headers are included in C++.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:72,recover,recovery,72,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['recover'],['recovery']
Safety,// Allow casts of address-of-label differences if they are no-ops; // or narrowing. (The narrowing case isn't actually guaranteed to; // be constant-evaluatable except in some narrow cases which are hard; // to detect here. We let it through on the assumption the user knows; // what they are doing.),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:211,detect,detect,211,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['detect'],['detect']
Safety,// Allow detection of fast FMA support.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:9,detect,detection,9,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,1,['detect'],['detection']
Safety,// Allow exactly one instruction to be speculated regardless of its cost; // (as long as it is safe to do so).; // This is intended to flatten the CFG even if the instruction is a division; // or other expensive operation. The speculation of an expensive instruction; // is expected to be undone in CodeGenPrepare if the speculation has not; // enabled further IR optimizations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:95,safe,safe,95,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['safe'],['safe']
Safety,// Allow unsafe math if unsafe-fp-math attribute explicitly says so.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:9,unsafe,unsafe,9,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,2,['unsafe'],"['unsafe', 'unsafe-fp-math']"
Safety,// Allow wider loads if they are sufficiently aligned to avoid memory faults; // and if the original load is simple.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:57,avoid,avoid,57,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['avoid'],['avoid']
Safety,// Alphanum is safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:15,safe,safe,15,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,1,['safe'],['safe']
Safety,// Already predicted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:11,predict,predicted,11,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,2,['predict'],['predicted']
Safety,// Also avoid sibcall optimization if either caller or callee uses struct; // return semantics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:8,avoid,avoid,8,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,['avoid'],['avoid']
Safety,// Also avoid sibcall optimization if we're an sret return fn and the callee; // is incompatible. See comment in LowerReturn about why hasStructRetAttr is; // insufficient.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:8,avoid,avoid,8,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['avoid'],['avoid']
Safety,// Also avoid tail call optimization if either caller or callee uses struct; // return semantics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:8,avoid,avoid,8,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Also make sure the inner loop preheader does not contain any unsafe; // instructions. Note that all instructions in the preheader will be moved to; // the outer loop header when interchanging.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:64,unsafe,unsafe,64,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,1,['unsafe'],['unsafe']
Safety,// Also recover CFG index by scanning the CFG block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:8,recover,recover,8,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,1,['recover'],['recover']
Safety,"// Also store the unique ID of the _normSet. This makes it possible to; // detect if the pointer was invalidated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsPdf.h:75,detect,detect,75,roofit/roofitcore/inc/RooAbsPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsPdf.h,1,['detect'],['detect']
Safety,"// Also that one was empty. We need to error out, but only if the user; // did not explicitly request to avoid errors about missing branches",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx:105,avoid,avoid,105,tree/treeplayer/src/TTreeReaderValue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx,1,['avoid'],['avoid']
Safety,"// Although End can be a MAX expression we estimate MaxEnd considering only; // the case End = RHS of the loop termination condition. This is safe because; // in the other case (End - Start) is zero, leading to a zero maximum backedge; // taken count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:142,safe,safe,142,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['safe'],['safe']
Safety,"// Although End can be a MIN expression we estimate MinEnd considering only; // the case End = RHS. This is safe because in the other case (Start - End); // is zero, leading to a zero maximum backedge taken count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:108,safe,safe,108,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['safe'],['safe']
Safety,"// Although it is not explicitly requested by the Microsoft COFF spec,; // we should avoid emitting forward associative section references,; // because MSVC link.exe as of 2017 cannot handle that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/WinCOFFObjectWriter.cpp:85,avoid,avoid,85,interpreter/llvm-project/llvm/lib/MC/WinCOFFObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/WinCOFFObjectWriter.cpp,1,['avoid'],['avoid']
Safety,"// Although we asserted, be extra safe for release build.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:34,safe,safe,34,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,1,['safe'],['safe']
Safety,"// Although we create ADJCALLSTACKDOWN and ADJCALLSTACKUP; // as scheduling fences, we skip creating fences if we already; // have existing ADJCALLSTACKDOWN/UP to avoid nesting,; // which causes verification error with -verify-machineinstrs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:163,avoid,avoid,163,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,1,['avoid'],['avoid']
Safety,"// Although we'll properly infer the type of the block once it's completed,; // make sure we provide a return type now for better error recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:136,recover,recovery,136,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['recover'],['recovery']
Safety,"// Always avoid lexing editor placeholders when we're just running the; // preprocessor as we never want to emit the; // ""editor placeholder in source file"" error in PP only mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:10,avoid,avoid,10,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['avoid'],['avoid']
Safety,// Always localize G_GLOBAL_VALUE to avoid high reg pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:37,avoid,avoid,37,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Always print the module.; // Unwrap and print directly to avoid filtering problems in general routines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp:61,avoid,avoid,61,interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp,1,['avoid'],['avoid']
Safety,// Always safe to dispatch to getFrameIndexReference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:10,safe,safe,10,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,1,['safe'],['safe']
Safety,// Always test the initial module.; // Unwrap and print directly to avoid filtering problems in general routines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp:68,avoid,avoid,68,interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp,1,['avoid'],['avoid']
Safety,// Always try to create iterator declarator to avoid extra error messages; // about unknown declarations use.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:47,avoid,avoid,47,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['avoid'],['avoid']
Safety,// Always use LA if the displacement is small enough. It should always; // be no worse than AGHI (and better if it avoids a move).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:115,avoid,avoids,115,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['avoid'],['avoids']
Safety,"// Amount to shift hash values to avoid clustering",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx:34,avoid,avoid,34,core/base/src/TString.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx,1,['avoid'],['avoid']
Safety,"// An @catch parameter must be an unqualified object pointer type;; // FIXME: Recover from ""NSObject foo"" by inserting the * in ""NSObject *foo""?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:78,Recover,Recover,78,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['Recover'],['Recover']
Safety,"// An FCVT[SU] instruction performs: convertToInt(Val * 2^fbits) where fbits; // is between 1 and 32 for a destination w-register, or 1 and 64 for an; // x-register.; //; // By this stage, we've detected (fp_to_[su]int (fmul Val, THIS_NODE)) so we; // want THIS_NODE to be 2^fbits. This is much easier to deal with using; // integers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:195,detect,detected,195,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['detect'],['detected']
Safety,"// An LE has been generated, but it's not the terminator - that is an; // unconditional branch. However, the logic has now been reversed with the; // CBN?Z being the conditional branch and the LE being the unconditional; // branch. So this means we can remove the redundant unconditional branch; // at the end of the block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp:264,redund,redundant,264,interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,1,['redund'],['redundant']
Safety,// An abort controller could be added within a future PR,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:6,abort,abort,6,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,1,['abort'],['abort']
Safety,"// An error has occurred.. We might be able to recover with metalinks.; // Try to populate the replicas vector. If successful, TFile will try; // the replicas one by one",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/davix/src/TDavixFile.cxx:47,recover,recover,47,net/davix/src/TDavixFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/davix/src/TDavixFile.cxx,1,['recover'],['recover']
Safety,// An existent entry with multiple sources is a PHI cycle we must avoid.; // Otherwise it's an entry with a valid next source we already found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:66,avoid,avoid,66,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['avoid'],['avoid']
Safety,"// An explicit instantiation definition can add a dll attribute to a; // template with a previous implicit instantiation. MinGW doesn't allow; // this. We limit clang to only adding dllexport, to avoid potentially; // strange codegen behavior. For example, if we extend this conditional; // to dllimport, and we have a source file calling a method on an; // implicitly instantiated template class instance and then declaring a; // dllimport explicit instantiation definition for the same template; // class, the codegen for the method call will not respect the dllimport,; // while it will with cl. The Def will already have the DLL attribute,; // since the Def and Specialization will be the same in the case of; // Old_TSK == TSK_ImplicitInstantiation, and we already added the; // attribute to the Specialization; we just need to make it take effect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:196,avoid,avoid,196,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['avoid'],['avoid']
Safety,"// An inline asm cannot be together with a branch, because we may not be; // able to remove the asm out after packetizing (i.e. if the asm must be; // moved past the bundle). Similarly, two asms cannot be together to avoid; // complications when determining their relative order outside of a bundle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:217,avoid,avoid,217,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['avoid'],['avoid']
Safety,"// An instantiated function template inherits the declaration context of the; // templated decl. This is used for name mangling; fix it to avoid clashing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DefinitionShadower.cpp:139,avoid,avoid,139,interpreter/cling/lib/Interpreter/DefinitionShadower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DefinitionShadower.cpp,1,['avoid'],['avoid']
Safety,"// An option to enable unsafe alias results from the GlobalsModRef analysis.; // When enabled, GlobalsModRef will provide no-alias results which in extremely; // rare cases may not be conservatively correct. In particular, in the face of; // transforms which cause asymmetry between how effective getUnderlyingObject; // is for two pointers, it may produce incorrect results.; //; // These unsafe results have been returned by GMR for many years without; // causing significant issues in the wild and so we provide a mechanism to; // re-enable them for users of LLVM that have a particular performance; // sensitivity and no known issues. The option also makes it easy to evaluate; // the performance impact of these results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:23,unsafe,unsafe,23,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,2,['unsafe'],['unsafe']
Safety,// An optional ObjectCache to be notified of compiled objects and used to; // perform lookup of pre-compiled code to avoid re-compilation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:117,avoid,avoid,117,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,1,['avoid'],['avoid']
Safety,"// An out-of-order CPU can speculatively execute past a predictable branch,; // but a conditional move could be stalled by an expensive earlier operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:56,predict,predictable,56,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['predict'],['predictable']
Safety,"// An undef shuffle mask element may propagate as an undef constant element in; // the new binop. That would produce poison where the original code might not.; // If we already made a safe constant, then there's no danger.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:184,safe,safe,184,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['safe'],['safe']
Safety,// And each safe point...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp:12,safe,safe,12,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,1,['safe'],['safe']
Safety,// And if it's safe to clone the dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:15,safe,safe,15,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['safe'],['safe']
Safety,"// And locations of macro calls, to properly recover boundaries of those in; // case of empty expansions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:45,recover,recover,45,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,1,['recover'],['recover']
Safety,"// And make sure that the negative value of increment can be added to all; // other offsets after the BaseAccess. We rely on either; // dominates(BaseAccess, OtherAccess) or dominates(OtherAccess, BaseAccess); // to keep things simple.; // This also adds a simple codesize metric, to detect if an instruction (like; // t2LDRBi12) which can often be shrunk to a thumb1 instruction (tLDRBi); // cannot because it is converted to something else (t2LDRBi8). We start this; // at -1 for the gain from removing the increment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:284,detect,detect,284,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['detect'],['detect']
Safety,"// And wait for the help to finish to avoid the risk that it is still; // running when the main tread is finished (and the thread library unloaded!)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx:38,avoid,avoid,38,core/thread/src/TThread.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx,2,"['avoid', 'risk']","['avoid', 'risk']"
Safety,"// And/or are potentially poison-safe logical patterns like:; // select x, y, false; // select x, true, y",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,safe,safe,33,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['safe'],['safe']
Safety,// Android provides a fixed TLS slot for the SafeStack pointer. See the; // definition of TLS_SLOT_SAFESTACK in; // https://android.googlesource.com/platform/bionic/+/master/libc/private/bionic_tls.h,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:45,Safe,SafeStack,45,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['Safe'],['SafeStack']
Safety,// Android provides a libc function to retrieve the address of the current; // thread's unsafe stack pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:88,unsafe,unsafe,88,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['unsafe'],['unsafe']
Safety,// Another interesting case is if the killing store overwrites the end of the; // dead store.; //; // |--dead--|; // |-- killing --|; //; // In this case we may want to trim the size of dead store to avoid; // generating stores to addresses which will definitely be overwritten killing; // store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:200,avoid,avoid,200,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['avoid'],['avoid']
Safety,"// Another special case: If C was a sign bit, the sub has been; // canonicalized into a xor.; // FIXME: Would it be better to use computeKnownBits to; // determine whether it's safe to decanonicalize the xor?; // x s< 0 ? x^C : 0 --> usubsat x, C",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:177,safe,safe,177,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['safe'],['safe']
Safety,"// Any branch that is not a leaf count can be safely processed in parallel when reading; // We need to reset the vector to make sure we do not re-add several times the same branch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:46,safe,safely,46,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['safe'],['safely']
Safety,// Any break on this level means that the parent level has been broken; // and we need to avoid bin packing there.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:90,avoid,avoid,90,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['avoid'],['avoid']
Safety,// Any instruction which isn't safe to speculate at the beginning of the; // block is control dependend on any early exit or non-willreturn call; // which proceeds it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:31,safe,safe,31,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['safe'],['safe']
Safety,// AnyCall helps us here to avoid checking for FunctionDecl and ObjCMethodDecl; // separately and aggregates interfaces of these classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp:28,avoid,avoid,28,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonNullParamChecker.cpp,1,['avoid'],['avoid']
Safety,// Append an empty element to avoid ending up with an empty array.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/OptParserEmitter.cpp:30,avoid,avoid,30,interpreter/llvm-project/llvm/utils/TableGen/OptParserEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/OptParserEmitter.cpp,1,['avoid'],['avoid']
Safety,"// Append the preexisting target features last, so that +mattr overrides; // the ""unsafe-fp-math"" function attribute.; // Creating a separate target feature is not strictly necessary, it only; // exists to make ""unsafe-fp-math"" force creating a new subtarget.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:82,unsafe,unsafe-fp-math,82,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,2,['unsafe'],['unsafe-fp-math']
Safety,// Apply modifiers to an option in a type safe way.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h:42,safe,safe,42,interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,1,['safe'],['safe']
Safety,// Apply reversed order to keep the original ordering of the reused; // elements to avoid extra reorder indices shuffling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:84,avoid,avoid,84,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,// ArgTokens - Build up a list of tokens that make up each argument. Each; // argument is separated by an EOF token. Use a SmallVector so we can avoid; // heap allocations in the common case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:145,avoid,avoid,145,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['avoid'],['avoid']
Safety,// Args were sensible expressions but we couldn't initialize the member; // from them. Preserve them in a RecoveryExpr instead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:106,Recover,RecoveryExpr,106,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['Recover'],['RecoveryExpr']
Safety,// Argument types are too different. Abort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:37,Abort,Abort,37,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,2,['Abort'],['Abort']
Safety,"// Arguments of 256-bits are split into four eightbyte chunks. The; // least significant one belongs to class SSE and all the others to class; // SSEUP. The original Lo and Hi design considers that types can't be; // greater than 128-bits, so a 64-bit split in Hi and Lo makes sense.; // This design isn't correct for 256-bits, but since there're no cases; // where the upper parts would need to be inspected, avoid adding; // complexity and just consider Hi to match the 64-256 part.; //; // Note that per 3.5.7 of AMD64-ABI, 256-bit args are only passed in; // registers if they are ""named"", i.e. not part of the ""..."" of a; // variadic function.; //; // Similarly, per 3.2.3. of the AVX512 draft, 512-bits (""named"") args are; // split into eight eightbyte chunks, one SSE and seven SSEUP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:410,avoid,avoid,410,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['avoid'],['avoid']
Safety,"// Arguments to functions or returns from functions are inherently; // escaping, so we can immediately classify those as not aliasing any; // non-addr-taken globals.; //; // (Transitive) loads from a global are also safe - if this aliased; // another global, its address would escape, so no alias.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:216,safe,safe,216,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,1,['safe'],['safe']
Safety,// As (BECount + 1) can potentially unsigned overflow we count; // (BECount % Count) + 1 which is overflow safe as BECount % Count < Count.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:107,safe,safe,107,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,1,['safe'],['safe']
Safety,"// As a compile-time optimization, avoid allocating and evaluating an MCExpr; // tree for (Hi - Lo) when Hi and Lo are offsets into the same fragment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp:35,avoid,avoid,35,interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,1,['avoid'],['avoid']
Safety,"// As a pragmatic matter, we limit tokens to 16KB; this is often the limit; // in size of HTTP headers for many web servers.; // This also avoids unbounded memory use in case if the user points us to; // a large file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/davix/src/TDavixFile.cxx:139,avoid,avoids,139,net/davix/src/TDavixFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/davix/src/TDavixFile.cxx,1,['avoid'],['avoids']
Safety,// As a safe default always respond as if PS has color exports.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp:8,safe,safe,8,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp,1,['safe'],['safe']
Safety,"// As a special case, detect code like this:; // double fabs(double f) { return __builtin_fabs(f); } // a 'fabs' call; // and disable this xform in this case, because the code generator will; // lower the call to fabs into inline code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:22,detect,detect,22,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,1,['detect'],['detect']
Safety,"// As a special case, handle fixed(0) (i.e., a fixed field with zero bits); // and vbr(0) as a literal zero. This is decoded the same way, and avoids; // a slow path in Read() to have to handle reading zero bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp:143,avoid,avoids,143,interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp,1,['avoid'],['avoids']
Safety,"// As currently BasicAA does not analyze ptrtoint/inttoptr, do not lower to; // arithmetic operations if the target uses alias analysis in codegen.; // Additionally, pointers that aren't integral (and so can't be safely; // converted to integers) or those whose offset size is different from their; // pointer size (which means that doing integer arithmetic on them could; // affect that data) can't be lowered in this way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:213,safe,safely,213,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,1,['safe'],['safely']
Safety,"// As far as we do not support file symlinks, compare; // basenames here to avoid request to file system.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp:76,avoid,avoid,76,interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp,1,['avoid'],['avoid']
Safety,"// As the TBasket invokes Add{Tot,Zip}Bytes on its parent tree, we must do these updates in a thread-safe; // manner only when we are flushing multiple baskets in parallel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:101,safe,safe,101,tree/tree/inc/TTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h,1,['safe'],['safe']
Safety,"// As with the one-use checks below, this is not strictly necessary, but we; // are being cautious to avoid potential perf regressions on targets that; // do not actually have a funnel/rotate instruction (where the funnel shift; // would be expanded back into math/shift/logic ops).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:102,avoid,avoid,102,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['avoid'],['avoid']
Safety,// As-is msan can not tolerate noundef mismatch between caller and; // implementation. Mismatch is possible for e.g. indirect calls from C-caller; // into C++. Such mismatches lead to confusing false reports. To avoid; // expensive workaround on msan we enforce initialization event in uncommon; // cases where it's allowed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:212,avoid,avoid,212,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['avoid'],['avoid']
Safety,// Asan needs to poison memory to detect invalid access which is possible; // even for empty lifetime range.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:34,detect,detect,34,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['detect'],['detect']
Safety,// Ascending register numbers and no offset. It's safe to change it to a; // ldm or stm.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:50,safe,safe,50,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['safe'],['safe']
Safety,"// Ask slave to progate the stop/abort request",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:33,abort,abort,33,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['abort'],['abort']
Safety,// Assign in order of operand index to make use-list order predictable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:59,predict,predictable,59,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,3,['predict'],['predictable']
Safety,"// Assign the kIsOnHeap bit in 'bits' based on the pattern seen in uniqueID.; // See Storage::FilledByObjectAlloc for details.; // This routine is marked as inline with attribute noinline so that it never; // inlined and thus can be used in a valgrind suppression file to suppress; // the known/intentional uninitialized memory read but still be a 'quick'; // function call to avoid losing performance at object creation.; // Moving the function into the source file, results in doubling of the; // overhead (compared to inlining)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TStorage.h:377,avoid,avoid,377,core/base/inc/TStorage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TStorage.h,1,['avoid'],['avoid']
Safety,// Assign the position number to the instruction. Note that we are going to; // move some instructions during the optimization however there will never; // be a need to move two instructions before any selected instruction. So to; // avoid multiple positions' updates during moves we just increase position; // counter by two leaving a free space for instructions which will be moved.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp:234,avoid,avoid,234,interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,1,['avoid'],['avoid']
Safety,"// Assume functions might recurse (see `reAssume` or `tryRearrange`). During; // the recursion the State might not change anymore, that means we reached a; // fixpoint.; // We avoid infinite recursion of assume calls by checking already visited; // States on the stack of assume function calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp:176,avoid,avoid,176,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ConstraintManager.cpp,1,['avoid'],['avoid']
Safety,// Assume loads from different basic blocks are unsafe to move.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:48,unsafe,unsafe,48,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,1,['unsafe'],['unsafe']
Safety,"// Assume pre-ARMv6 doesn't support unaligned accesses.; //; // ARMv6 may or may not support unaligned accesses depending on the; // SCTLR.U bit, which is architecture-specific. We assume ARMv6; // Darwin and NetBSD targets support unaligned accesses, and others don't.; //; // ARMv7 always has SCTLR.U set to 1, but it has a new SCTLR.A bit; // which raises an alignment fault on unaligned accesses. Linux; // defaults this bit to 0 and handles it as a system-wide (not; // per-process) setting. It is therefore safe to assume that ARMv7+; // Linux targets support unaligned accesses. The same goes for NaCl; // and Windows.; //; // The above behavior is consistent with GCC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:513,safe,safe,513,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,1,['safe'],['safe']
Safety,// Assume that C allocation functions allocate arrays to avoid false; // positives.; // TODO: Add heuristics to distinguish alloc calls that allocates single; // objecs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp:57,avoid,avoid,57,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp,1,['avoid'],['avoid']
Safety,// Assume that the source has the same reservoir size as the destination to; // avoid needing to record it in the indexed profile format.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp:80,avoid,avoid,80,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,1,['avoid'],['avoid']
Safety,"// Assume the we will use FLAT for all global memory accesses; // on VI.; // FIXME: This assumption is currently wrong. On VI we still use; // MUBUF instructions for the r + i addressing mode. As currently; // implemented, the MUBUF instructions only work on buffer < 4GB.; // It may be possible to support > 4GB buffers with MUBUF instructions,; // by setting the stride value in the resource descriptor which would; // increase the size limit to (stride * 4GB). However, this is risky,; // because it has never been validated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:481,risk,risky,481,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['risk'],['risky']
Safety,"// Assume this server does not serve multi-range HTTP GET requests. We; // will detect this when the HTTP headers of this files are retrieved; // later in the initialization process",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3WebFile.cxx:80,detect,detect,80,net/net/src/TS3WebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3WebFile.cxx,1,['detect'],['detect']
Safety,"// Assume we can vectorize V (and hence we need extraction) if the; // scalars are not computed yet. This can happen, because it is called; // via getScalarizationOverhead from setCostBasedWideningDecision, before; // the scalars are collected. That should be a safe assumption in most; // cases, because we check if the operands have vectorizable types; // beforehand in LoopVectorizationLegality.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:262,safe,safe,262,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['safe'],['safe']
Safety,"// At least one of the elements must be zero in the upper 17 bits, or can be; // safely made zero without altering the final result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:81,safe,safely,81,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['safe'],['safely']
Safety,"// At least one unsafe register is not dead. We do not want to outline at; // this point. If it is long enough to outline from, save the range; // [RangeBegin, RangeEnd).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:16,unsafe,unsafe,16,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['unsafe'],['unsafe']
Safety,"// At most one of the register is a sub register, make it Src to avoid; // duplicating the test.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:65,avoid,avoid,65,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,1,['avoid'],['avoid']
Safety,"// At this point directVars are all variables that are safe to be generated directly; // otherVars are all variables that are _not_ safe to be generated directly",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenContext.cxx:55,safe,safe,55,roofit/roofitcore/src/RooGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenContext.cxx,2,['safe'],['safe']
Safety,"// At this point the SALU can be assumed to mitigate the hazard; // because either:; // (a) it is independent of the at risk SMEM (breaking chain),; // or; // (b) it is dependent on the SMEM, in which case an appropriate; // s_waitcnt lgkmcnt _must_ exist between it and the at risk; // SMEM instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:57,hazard,hazard,57,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,3,"['hazard', 'risk']","['hazard', 'risk']"
Safety,"// At this point we don't have any forward reference remaining, or temporary; // that haven't been loaded. We can safely drop RAUW support and mark cycles; // as resolved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:114,safe,safely,114,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,1,['safe'],['safely']
Safety,"// At this point we have a value which, first of all, is not a binary; // expression of the right kind, and secondly, is only used inside the; // expression. This means that it can safely be modified. See if we; // can usefully morph it into an expression of the right kind.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:181,safe,safely,181,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['safe'],['safely']
Safety,// At this point we have deserialized and merged the decl and it is safe to; // update its canonical decl to signal that the entire entity is used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:68,safe,safe,68,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['safe'],['safe']
Safety,"// At this point we have tables found from the section header and from the; // dynamic segment. Usually they match, but we have to do sanity checks to; // verify that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp:134,sanity check,sanity checks,134,interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,1,['sanity check'],['sanity checks']
Safety,"// At this point we know both costs hold sensible values.; // If both values have a different base frequency, there is no much; // we can do but to scale everything.; // However, if they have the same base frequency we can avoid making; // complicated computation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:223,avoid,avoid,223,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['avoid'],['avoid']
Safety,// At this point we know that the denominator is -1. It is safe to hoist as; // long we know that the numerator is not INT_MIN.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:59,safe,safe,59,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['safe'],['safe']
Safety,"// At this point we leverage the postorder list of SCCs to detect when the; // insertion of an edge changes the SCC structure in any way.; //; // First and foremost, we can eliminate the need for any changes when the; // edge is toward the beginning of the postorder sequence because all edges; // flow in that direction already. Thus adding a new one cannot form a cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:59,detect,detect,59,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,1,['detect'],['detect']
Safety,"// At this point we lost our controller: we need to abort to avoid; // hidden timeouts or loops",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:52,abort,abort,52,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,3,"['abort', 'avoid', 'timeout']","['abort', 'avoid', 'timeouts']"
Safety,"// At this point, all IfBlocks are empty, so our if statement; // has been flattened. Change DomBlock to jump directly to our new block to; // avoid other simplifycfg's kicking in on the diamond.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:143,avoid,avoid,143,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['avoid'],['avoid']
Safety,"// At this point, we are sure that the type is signed and we can safely; // use unary - operator.; //; // While calculating absolute maximum, we can use the following formula; // because of these reasons:; // * If From >= 0 then To >= From and To >= -From.; // AbsMax == To == max(To, -From); // * If To <= 0 then -From >= -To and -From >= From.; // AbsMax == -From == max(-From, To); // * Otherwise, From <= 0, To >= 0, and; // AbsMax == max(abs(From), abs(To))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:65,safe,safely,65,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['safe'],['safely']
Safety,"// At this point, we can safely insert a gc.relocate or gc.result as the first; // instruction in Ret if needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:25,safe,safely,25,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['safe'],['safely']
Safety,"// At this point, we have only ""safe"" candidates to outline. Figure out; // frame + call instruction information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:32,safe,safe,32,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['safe'],['safe']
Safety,"// At this point, we're committed to promoting the alloca using IDF's, and; // the standard SSA construction algorithm. Determine which blocks need phi; // nodes and see if we can optimize out some work by avoiding insertion of; // dead phi nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:206,avoid,avoiding,206,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['avoid'],['avoiding']
Safety,"// At this point, we've successfully parsed a class-specifier in 'definition'; // form (e.g. ""struct foo { int x; }"". While we could just return here, we're; // going to look at what comes after it to improve error recovery. If an; // impossible token occurs next, we assume that the programmer forgot a ; at; // the end of the declaration and recover that way.; //; // Also enforce C++ [temp]p3:; // In a template-declaration which defines a class, no declarator; // is permitted.; //; // After a type-specifier, we don't expect a semicolon. This only happens in; // C, since definitions are not permitted in this context in C++.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:215,recover,recovery,215,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,2,['recover'],"['recover', 'recovery']"
Safety,// Attempt to avoid multi-use ops if we don't need anything from them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:14,avoid,avoid,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,20,['avoid'],['avoid']
Safety,// Attempt to avoid multi-use ops if we don't need anything from them.; // TODO - use KnownUndef to relax the demandedelts?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:14,avoid,avoid,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['avoid'],['avoid']
Safety,// Attempt to avoid multi-use os if we don't need anything from it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:14,avoid,avoid,14,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Attempt to avoid multi-use src if we don't need anything from it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:14,avoid,avoid,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,2,['avoid'],['avoid']
Safety,"// Attempt to avoid passing indirect results using byval when possible. This; // is important for good codegen.; //; // We do this by coercing the value into a scalar type which the backend can; // handle naturally (i.e., without using byval).; //; // For simplicity, we currently only do this when we have exhausted all of the; // free integer registers. Doing this when there are free integer registers; // would require more care, as we would have to ensure that the coerced value; // did not claim the unused register. That would require either reording the; // arguments to the function (so that any subsequent inreg values came first),; // or only doing this optimization when there were no following arguments that; // might be inreg.; //; // We currently expect it to be rare (particularly in well written code) for; // arguments to be passed on the stack when there are still free integer; // registers available (this would typically imply large structs being passed; // by value), so this seems like a fair tradeoff for now.; //; // We can revisit this if the backend grows support for 'onstack' parameter; // attributes. See PR12193.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:14,avoid,avoid,14,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['avoid'],['avoid']
Safety,"// Attempt to canonicalize SGT/UGT -> SGE/UGE compares with constant which; // reduces the number of EFLAGs bit reads (the GE conditions don't read ZF),; // this may translate to less uops depending on uarch implementation. The; // equivalent for SLE/ULE -> SLT/ULT isn't likely to happen as we already; // canonicalize to that CondCode.; // NOTE: Only do this if incrementing the constant doesn't increase the bit; // encoding size - so it must either already be a i8 or i32 immediate, or it; // shrinks down to that. We don't do this for any i64's to avoid additional; // constant materializations.; // TODO: Can we move this to TranslateX86CC to handle jumps/branches too?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:553,avoid,avoid,553,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Attempt to detect ""hidden"" splats, which only reveal themselves as splats; // when re-interpreted as a vector with a larger element type. For example,; // v4i16 = build_vector i16 0, i16 1, i16 0, i16 1; // could be instead splat as; // v2i32 = build_vector i32 0x00010000, i32 0x00010000; // TODO: This optimization could also work on non-constant splats, but it; // would require bit-manipulation instructions to construct the splat value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:14,detect,detect,14,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['detect'],['detect']
Safety,// Attempt to detect a suitable splat from increasing splat widths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp:14,detect,detect,14,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,1,['detect'],['detect']
Safety,"// Attempt to detect an expanded vXi64 SIGN_EXTEND_INREG vXi1 pattern, and; // convert to a splatted v2Xi32 SIGN_EXTEND_INREG pattern:; // psrad(pshufd(psllq(X,63),1,1,3,3),31) ->; // pshufd(psrad(pslld(X,31),31),0,0,2,2).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:14,detect,detect,14,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['detect'],['detect']
Safety,"// Attempt to detect the file type using file magic. We have a slight bias; // towards the binary format, and we do this by making sure that the first 4; // bytes of the binary file is some combination of the following byte; // patterns: (observe the code loading them assumes they're little endian); //; // 0x01 0x00 0x00 0x00 - version 1, ""naive"" format; // 0x01 0x00 0x01 0x00 - version 1, ""flight data recorder"" format; // 0x02 0x00 0x01 0x00 - version 2, ""flight data recorder"" format; //; // YAML files don't typically have those first four bytes as valid text so we; // try loading assuming YAML if we don't find these bytes.; //; // Only if we can't load either the binary or the YAML format will we yield an; // error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:14,detect,detect,14,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,1,['detect'],['detect']
Safety,// Attempt to estimate the relative costs of predication versus branching.; // Here we scale up each component of UnpredCost to avoid precision issue when; // scaling TCycles/FCycles by Probability.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:128,avoid,avoid,128,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['avoid'],['avoid']
Safety,"// Attempt to fold HOP(LOSUBVECTOR(SHUFFLE(X)),HISUBVECTOR(SHUFFLE(X))); // to SHUFFLE(HOP(LOSUBVECTOR(X),HISUBVECTOR(X))), this is mainly for; // truncation trees that help us avoid lane crossing shuffles.; // TODO: There's a lot more we can do for PACK/HADD style shuffle combines.; // TODO: We don't handle vXf64 shuffles yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:177,avoid,avoid,177,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Attempt to recover by skipping the invalid 'typename',MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:14,recover,recover,14,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['recover'],['recover']
Safety,"// Attempt to salvage back through as many instructions as possible. Bail if; // a non-instruction is seen, such as a constant expression or global; // variable. FIXME: Further work could recover those too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:188,recover,recover,188,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['recover'],['recover']
Safety,// Attempt to switch the lexer to the included file before consuming the; // end of statement to avoid losing it when we switch.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:97,avoid,avoid,97,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,2,['avoid'],['avoid']
Safety,"// Attempts to optimize the pattern whereby memory is copied from an alloca to; // another alloca, where the two allocas don't have conflicting mod/ref. If; // successful, the two allocas can be merged into one and the transfer can be; // deleted. This pattern is generated frequently in Rust, due to the ubiquity of; // move operations in that language.; //; // Once we determine that the optimization is safe to perform, we replace all; // uses of the destination alloca with the source alloca. We also ""shrink wrap""; // the lifetime markers of the single merged alloca to before the first use; // and after the last use. Note that the ""shrink wrapping"" procedure is a safe; // transformation only because we restrict the scope of this optimization to; // allocas that aren't captured.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:406,safe,safe,406,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,2,['safe'],['safe']
Safety,"// Author: Bertrand Bellenot 22/08/02; /*************************************************************************; * Copyright (C) 1995-2002, Bertrand Bellenot. *; * All rights reserved. *; * *; * For the licensing terms see the LICENSE file. *; *************************************************************************/; //////////////////////////////////////////////////////////////////////////; // //; // MyDetector //; // defines a simple detector class with one geometry, one material //; // and the physical properties of the detector's material //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyDetector.h:443,detect,detector,443,test/RootShower/MyDetector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyDetector.h,2,['detect'],['detector']
Safety,"// Author: Stefan Schmitt, Amnon Harel; // DESY and CERN, 11/08/11; // Version 17.9, parallel to changes in TUnfold; //; // History:; // Version 17.8, new method GetDXDY(); // Version 17.7, with bug-fix for curvature regularisation; // Version 17.6, with updated doxygen comments and bug-fixes in TUnfoldBinning; // Version 17.5, bug fix in TUnfold also corrects GetEmatrixSysUncorr(); // Version 17.4, in parallel to changes in TUnfoldBinning; // Version 17.3, in parallel to changes in TUnfoldBinning; // Version 17.2, with new options 'N' and 'c' for axis regularisation steering; // Version 17.1, add scan type RhoSquare, small bug fixes with useAxisBinning; // Version 17.0, support for density regularisation, complex binning schemes, tau scan; /** \class TUnfoldDensity; An algorithm to unfold distributions from detector to truth level. TUnfoldDensity is used to decompose a measurement y into several sources x,; given the measurement uncertainties, background b and a matrix of migrations A.; The method can be applied to a large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Beyond such a simple template fit,; TUnfoldDensity has an adjustable regularisation term and also supports an; optional constraint on the total number of events.; Background sources can be specified, with a normalisation constant and; normalisation uncertainty. In addition, variants of the response; matrix may be specified, these are taken to determine systematic; uncertainties. Complex, multidimensional arrangements of signal and; background bins are managed with the help of the class TUnfoldBinning. If you use this software, please consider the following citation; <br/>; <b>S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]</b>; <br/>; Detailed documentation and updates are available on; http://www.desy.de/~sschmitt. <h3>Brief recipy to use TUnfoldSys:</h3>; <ul>; <li>Set up binning schemes for the truth and measured; distributions. T",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldDensity.cxx:820,detect,detector,820,hist/unfold/src/TUnfoldDensity.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldDensity.cxx,1,['detect'],['detector']
Safety,"// Author: Stefan Schmitt; // DESY, 10/08/11; // Version 17.9, parallel to changes in TUnfold; //; // History:; // Version 17.8, bug fix in GetNonemptyNode() and non-const access of tree; // Version 17.7, bug fix in ExtractHistogram; // Version 17.6, bug fix to avoid possible crash in method; // CreateHistogramOfMigrations(). Bug fix with NaN in GetGlobalBinNumber(); // Version 17.5, in parallel to changes in TUnfold; // Version 17.4, bug fix with error handling; // Version 17.3, bug fix with underflow/overflow bins; // Version 17.2, new option isPeriodic; // Version 17.1, in parallel to TUnfold; // Version 17.0, initial version, numbered in parallel to TUnfold",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldBinning.h:262,avoid,avoid,262,hist/unfold/inc/TUnfoldBinning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldBinning.h,1,['avoid'],['avoid']
Safety,"// Author: Stefan Schmitt; // DESY, 10/08/11; // Version 17.9, parallel to changes in TUnfold; //; // History:; // Version 17.8, bug fix in GetNonemptyNode() and non-const access of tree; // Version 17.7, bug fix in ExtractHistogram; // Version 17.6, bug fix to avoid possible crash in method; // CreateHistogramOfMigrations(). Bug fix with NaN in GetGlobalBinNumber(); // Version 17.5, in parallel to changes in TUnfold; // Version 17.4, bug fix with error handling; // Version 17.3, bug fix with underflow/overflow bins; // Version 17.2, with XML support, bug fix with bin map creation,; // isPeriodic option for neighbour bins; // Version 17.1, in parallel to changes in TUnfold; // Version 17.0, initial version, numbered in parallel to TUnfold; /** \class TUnfoldBinning; Binning schemes for use with the unfolding algorithm TUnfoldDensity. Binning schemes are used to map analysis bins on a single histogram; axis and back. The analysis bins may include unconnected bins (e.g; nuisances for background normalisation) or various multidimensional; histograms (signal bins, differential background normalisation bins, etc).; <br/>; If you use this software, please consider the following citation; <br/>; <b>S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]</b>; <br/>; Detailed documentation and updates are available on; http://www.desy.de/~sschmitt. <h3>Functionality</h3>. The TUnfoldBinning objects are connected by a tree-like structure.; The structure does not hold any data, but is only responsible for; arranging the analysis bins in the proper order.; Each node of the tree is responsible for a group of bins. That group; may consist of; <ul>; <li> several unconnected bins, each with a dedicated name.</li>; <li> bins organized in a multidimensional distribution, defined by a; set of axes. The axes are defined by a number of bins N and by (N+1); bin borders. In addition to the N bins inside there may be an underflow and an; overflow bin</li>; </ul>; Each bin has a ""global"" bin numb",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldBinning.cxx:262,avoid,avoid,262,hist/unfold/src/TUnfoldBinning.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldBinning.cxx,1,['avoid'],['avoid']
Safety,"// Author: Stefan Schmitt; // DESY, 19/10/11; // Version 17.9; //////////////////////////////////////////////////////////////////////////; // //; // //; // TUnfold provides functionality to correct data //; // for migration effects. //; // //; // Citation: S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201] //; // //; // this class implements the iterative EM unfolding method //; // (also called D'Agostini Method or ""iterative Bayesian method"") //; // which has been ""invented"" independently by numnerous authors //; // to unfold Poisson-distributed, mutually exclusive bins. //; // See e.g. //; // Richardson, W.H., Opt. Soc. Amer. A62 (1972), 55 //; // Lucy, L.B., Astron. J. 79 (1974), 745. //; // Vardi, Y., Shepp, L.A. and Kaufman, L., //; // J. Amer. Stat. Assoc. 80 (1985), 8. //; // Multhei, H.N. and Schorr, B., Nucl. Instr. Meth. A257 (1987), 371 //; // D'Agostini, G., Nucl. Instr. Meth. A362 (1995), 487 //; // //; // The novelty with this implementation is that the number of //; // iterations can be chosen based on SURE //; // (Stein's unbiased Risk Estimator) //; // See: //; // Tibshirani, R.J. and Rosset, S., J. Amer. Stat. Assoc. 114, 526 //; // [arXiv:1612.09415] //; // //; // This method is there for comparison with the Tihkonov unfolding. //; // The interface is similar to ""TUnfoldDensity"" //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldIterativeEM.h:1063,Risk,Risk,1063,hist/unfold/inc/TUnfoldIterativeEM.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldIterativeEM.h,1,['Risk'],['Risk']
Safety,"// Author: Stefan Schmitt; // DESY, 23/01/09; // Version 17.9, parallel to changes in TUnfold; //; // History:; // Version 17.8, parallel to changes in TUnfold; // Version 17.7, bug fix in GetBackground(); // Version 17.6, with updated doxygen comments; // Version 17.5, in parallel to changes in TUnfold; // Version 17.4, in parallel to changes in TUnfoldBinning; // Version 17.3, in parallel to changes in TUnfoldBinning; // Version 17.2, add methods to find back systematic and background sources; // Version 17.1, bug fix with background uncertainty; // Version 17.0, possibility to specify an error matrix with SetInput; // Version 16.1, parallel to changes in TUnfold; // Version 16.0, parallel to changes in TUnfold; // Version 15, fix bugs with uncorr. uncertainties, add backgnd subtraction; // Version 14, remove some print-out, do not add unused sys.errors; // Version 13, support for systematic errors; /** \class TUnfoldSys; \ingroup Unfold; An algorithm to unfold distributions from detector to truth level,; with background subtraction and propagation of systematic uncertainties. TUnfoldSys is used to decompose a measurement y into several sources x,; given the measurement uncertainties, background b and a matrix of migrations A.; The method can be applied to a large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Beyond such a simple template fit,; TUnfoldSys has an adjustable regularisation term and also supports an; optional constraint on the total number of events.; Background sources can be specified, with a normalisation constant and; normalisation uncertainty. In addition, variants of the response; matrix may be specified, these are taken to determine systematic; uncertainties. <b>For most applications, it is better to use the derived class; TUnfoldDensity instead of TUnfoldSys. TUnfoldDensity adds; features to TUnfoldSys, related to possible complex multidimensional; arrangements of bins. For inn",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx:997,detect,detector,997,hist/unfold/src/TUnfoldSys.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx,1,['detect'],['detector']
Safety,"// Auto-detect line breaks according to the break discovered in the first line",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/RRawFile.cxx:8,detect,detect,8,io/io/src/RRawFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/RRawFile.cxx,1,['detect'],['detect']
Safety,// Auto-detect the binding type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:8,detect,detect,8,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,1,['detect'],['detect']
Safety,// Auto-detect w/o --dsym.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp:8,detect,detect,8,interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,1,['detect'],['detect']
Safety,"// Avoid ""Address already in use"" errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid ""has no symbols"" warning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Debug.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Support/Debug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Debug.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid -Wcovered-switch-default,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,3,['Avoid'],['Avoid']
Safety,// Avoid 128-bit multi lane shuffles if pre-AVX2 and FP (integer will split).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid 8 and 16 bit types because they increase the chance for unnecessary; // zero-extensions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid AsanInitInternal cycle, Issue #64126.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid CMOV instruction which value is used as a pointer to load from.; // This is another conservative check to avoid converting CMOV instruction; // used with tree-search like algorithm, where the branch is unpredicted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,2,"['Avoid', 'avoid']","['Avoid', 'avoid']"
Safety,// Avoid CONCAT_VECTORS on sub-128bit nodes as these can fail after; // type legalization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid FP vectorization if the target is unsure about proper support.; // This may be related to the SIMD unit in the target not handling; // IEEE 754 FP ops properly, or bad single-to-double promotions.; // Otherwise, a sequence of vectorized loops, even without reduction,; // could lead to different end results on the destination vectors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['Avoid'],['Avoid']
Safety,// Avoid MSVC's Compiler Error C2276:; // http://msdn.microsoft.com/en-us/library/850cstw1(v=VS.80).aspx,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/CheckerRegistry.h:3,Avoid,Avoid,3,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/CheckerRegistry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Frontend/CheckerRegistry.h,1,['Avoid'],['Avoid']
Safety,// Avoid NOP description.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid OOB by returning early on empty input.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ConvertUTFWrapper.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Support/ConvertUTFWrapper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ConvertUTFWrapper.cpp,3,['Avoid'],['Avoid']
Safety,// Avoid Partial chain merge.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid TObject inheritance due to clash with TObject::Draw as well; // as possible inheritance of TGLPadScene from VierualViewer3D.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLSceneBase.h:3,Avoid,Avoid,3,graf3d/gl/inc/TGLSceneBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLSceneBase.h,1,['Avoid'],['Avoid']
Safety,"// Avoid TObject inheritance due to clash with TVirtualViewer3D.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLViewerBase.h:3,Avoid,Avoid,3,graf3d/gl/inc/TGLViewerBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLViewerBase.h,1,['Avoid'],['Avoid']
Safety,// Avoid UB by explicitly truncating the (unsigned) ~ result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['Avoid'],['Avoid']
Safety,"// Avoid UB when encountering LLONG_MIN, because in 2's complement; // abs(LLONG_MIN) is LLONG_MAX+1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid a build/concat_vector of 1 entry.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid a cross-class copy. This is very unlikely.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,4,['Avoid'],['Avoid']
Safety,// Avoid a data dependence from a select or a branch to a(nother); // select. Note no instruction can't data-depend on a branch (a branch; // instruction doesn't produce a value).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid a dereference w dumb compiler",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx:3,Avoid,Avoid,3,core/base/src/TString.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx,2,['Avoid'],['Avoid']
Safety,// Avoid a gcc warning about accessing 'this' in an initializer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid a hanging comma.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid a shift in the degenerate case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid accidentally supporting std types through TClass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:3,Avoid,Avoid,3,tree/ntuple/v7/src/RField.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx,1,['Avoid'],['Avoid']
Safety,"// Avoid accidentally supporting std types through TEnum.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:3,Avoid,Avoid,3,tree/ntuple/v7/src/RField.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx,1,['Avoid'],['Avoid']
Safety,// Avoid adding a false dependency on partial flag update by some 16-bit; // instructions which has the 's' bit set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,2,['Avoid'],['Avoid']
Safety,// Avoid adding defined bits with the zero_extend.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid adding duplicates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid adding fall through branches.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid adding incorrect test cases to the corpus.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-opt-fuzzer/llvm-opt-fuzzer.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/tools/llvm-opt-fuzzer/llvm-opt-fuzzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-opt-fuzzer/llvm-opt-fuzzer.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid adding symbols from an unknown/undefined section.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/SymbolizableObjectFile.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/SymbolizableObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/SymbolizableObjectFile.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid adding the ""Stride == 1"" predicate when we know that; // Stride >= Trip-Count. Such a predicate will effectively optimize a single; // or zero iteration loop, as Trip-Count <= Stride == 1.; //; // TODO: We are currently not making a very informed decision on when it is; // beneficial to apply stride versioning. It might make more sense that the; // users of this analysis (such as the vectorizer) will trigger it, based on; // their specific cost considerations; For example, in cases where stride; // versioning does not help resolving memory accesses/dependences, the; // vectorizer should evaluate the cost of the runtime test, and the benefit; // of various possible stride specializations, considering the alternatives; // of using gather/scatters (if available).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid adding volatile or ordered stores to the candidate. We already have a; // check for this in instMayAlias() but that only get's called later between; // potential aliasing hazards.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,2,"['Avoid', 'hazard']","['Avoid', 'hazards']"
Safety,"// Avoid additional loops inside",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMonitor.cxx:3,Avoid,Avoid,3,net/net/src/TMonitor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMonitor.cxx,1,['Avoid'],['Avoid']
Safety,// Avoid adjustment of ZERO weight since it should remain unchanged.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,2,['Avoid'],['Avoid']
Safety,// Avoid allocating parameter area for fastcc functions if all the arguments; // can be passed in the registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid an incorrect ordering that'd otherwise compile incorrectly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/include/llvm/IR/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h,2,['Avoid'],['Avoid']
Safety,// Avoid an infinite loop by making sure that N00 is not a constant; // (the inner multiply has not been constant folded yet).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid an infinite loop with min/max canonicalization.; // TODO: This will be unnecessary if we canonicalize to min/max intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid analyzing cases where the result will either be invalid (and; // diagnosed as such) or entirely valid and not something to warn about.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid anonymous enums,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid arguments with padding for now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid asking about the class when it is still building",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:3,Avoid,Avoid,3,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['Avoid'],['Avoid']
Safety,// Avoid assertion about validity of L.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h,4,['Avoid'],['Avoid']
Safety,// Avoid assertion about validity of R.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h,4,['Avoid'],['Avoid']
Safety,// Avoid assertion in appendMacroDirective.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid assertion in the ~IncrementalParser.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:3,Avoid,Avoid,3,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid assertion on add.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp:3,Avoid,Avoid,3,interpreter/cling/lib/Interpreter/DeclUnloader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid assertions in unreachable code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid blurred poles,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,Avoid,Avoid,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Avoid'],['Avoid']
Safety,// Avoid breaking back edge. From == To means backedge for single BB cycle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid bugpoint weirdness: A block may end with a conditional branch but; // jumps to the same MBB is either case. We have duplicate CFG edges in that; // case that we can't handle. Since this never happens in properly optimized; // code, just skip those edges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid building the original CU if it won't be used,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid building the remark unless we know there are at least *some*; // remarks enabled. We can't currently check whether remarks are requested; // for the calling pass since that requires actually building the remark.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,2,['Avoid'],['Avoid']
Safety,// Avoid callbacks for now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid calling NextPrime for the common case:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TExMap.cxx:3,Avoid,Avoid,3,core/cont/src/TExMap.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TExMap.cxx,1,['Avoid'],['Avoid']
Safety,"// Avoid calling TROOT::RecursiveRemove for this tree, it takes the read lock and we don't need it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProcessorMT.cxx:3,Avoid,Avoid,3,tree/treeplayer/src/TTreeProcessorMT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProcessorMT.cxx,1,['Avoid'],['Avoid']
Safety,// Avoid calling isRenamable for virtual registers since we assert that; // renamable property is only queried/set for physical registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid calling setAttrs() directly because it uses Decl::getASTContext(); // internally which is unsafe during derialization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,2,"['Avoid', 'unsafe']","['Avoid', 'unsafe']"
Safety,// Avoid calling setIsRenamable for virtual registers since we assert that; // renamable property is only queried/set for physical registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid calling setLexicalDeclContext() directly because it uses; // Decl::getASTContext() internally which is unsafe during derialization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,2,"['Avoid', 'unsafe']","['Avoid', 'unsafe']"
Safety,"// Avoid cases where the extend/round has multiple uses, as duplicating; // those is typically more expensive than removing a fneg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid casts in the loop and make sure we have a reasonable number.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid catastrophic cancellation in the high tails:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h:3,Avoid,Avoid,3,roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h,1,['Avoid'],['Avoid']
Safety,"// Avoid causing spills. If register pressure is high, schedule for; // register pressure reduction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid certain wrap-arounds. This doesn't detect all wrap-arounds.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,2,"['Avoid', 'detect']","['Avoid', 'detect']"
Safety,"// Avoid changing gDirectory;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:3,Avoid,Avoid,3,tree/dataframe/src/RLoopManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx,2,['Avoid'],['Avoid']
Safety,// Avoid changing the result vector type if the source element type was; // requested.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid checking the PLT since it produces spurious failures on AArch64; // when ignoring DWARF data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid clearing state if we're using the same subtarget again.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid clobbering a register that's used by the instruction at; // the point of insertion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid clobbering an existing mapping.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid cloning types, compile units, and (other) subprograms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid cloning when the block contains non-duplicable instructions.; // CFI instructions are marked as non-duplicable only because of Darwin,; // so we exclude them from this check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockPathCloning.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockPathCloning.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockPathCloning.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid complication with duplicating EH pads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid confusion -- if mode is zero no analytical integral is defined regardless of contents of _anaList",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:3,Avoid,Avoid,3,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['Avoid'],['Avoid']
Safety,"// Avoid considering instructions with less frequency than the source; // instruction (i.e., avoid colder code regions of the dependence slice).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,2,"['Avoid', 'avoid']","['Avoid', 'avoid']"
Safety,// Avoid constant expressions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid conversions where iN is larger than the float (e.g., float -> i64).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid conversions where iN is larger than the float (e.g., i64 -> float).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid converting a constant or loop invariant test back to a runtime; // test. This is critical for when SCEV's cached ExitCount is less precise; // than the current IR (such as after we've proven a particular exit is; // actually dead and thus the BE count never reaches our ExitCount.),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid copy like instructions: they don't define values, only move them.; // Leave a virtual-register reference until it can be fixed up later, to; // find the underlying value definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid copying a block to the heap if the block is assigned to a local; // auto variable that is declared in the same scope as the block. This; // optimization is unsafe if the local variable is declared in an outer; // scope. For example:; //; // BlockTy b;; // {; // b = ^{...};; // }; // // It is unsafe to invoke the block here if it wasn't copied to the; // // heap.; // b();,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,3,"['Avoid', 'unsafe']","['Avoid', 'unsafe']"
Safety,// Avoid copying a physreg twice since RegAllocFast is incompetent and only; // allows one use of a physreg per block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid copying overlapping areas.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid copying the array of types when there's just a single element.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid copying the whole array because there may be a lot of reports.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid correcting the RHS to the same Expr as the LHS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid crashes in MarkBad or alike while closing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h:3,Avoid,Avoid,3,proof/proof/inc/TProof.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h,1,['Avoid'],['Avoid']
Safety,// Avoid crashing on code with undefined behavior,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,3,['Avoid'],['Avoid']
Safety,"// Avoid crashing on undefined behavior with an illegal call to a; // kernel. If a callsite's calling convention doesn't match the; // function's, it's undefined behavior. If the callsite calling; // convention does match, that would have errored earlier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUResourceUsageAnalysis.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUResourceUsageAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUResourceUsageAnalysis.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid creating a conditional cleanup just to hold an llvm.lifetime.end; // marker. Instead, start the lifetime of a conditional temporary earlier; // so that it's unconditional. Don't do this with sanitizers which need; // more precise lifetime marks. However when inside an ""await.suspend""; // block, we should always avoid conditional cleanup because it creates; // boolean marker that lives across await_suspend, which can destroy coro; // frame.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,2,"['Avoid', 'avoid']","['Avoid', 'avoid']"
Safety,// Avoid creating a fragment expression that covers the entire variable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid creating a non-type-dependent expression that contains typos.; // Non-type-dependent expressions are liable to be discarded without; // checking for embedded typos.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid creating a store with a narrower source than result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid creating additional instructions if we're just adding additional; // copies of padding bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid creating cycles in the DAG. We must ensure that none of the other; // operands depend on True through it's Chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid creating duplicate edges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid creating filenames with special characters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid creating illegal types if running after type legalizer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid creating inttoptr of zero here: While LLVMs treatment of; // inttoptr is generally conservative, this particular case is folded to; // a null pointer, which will have incorrect provenance.; // gep (gep V, C), (sub 0, V) -> C",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid creating no-op copies with the same src and dst reg class. These; // confuse some of the machine passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid creating select between 2 constants unless it's selecting; // between 0, 1 and -1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid critical resource consumption and balance the schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,5,['Avoid'],['Avoid']
Safety,// Avoid cycles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid dangling StringRef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid decrementing RegionEnd for blocks with no terminator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid dereferencing a null pointer here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid destroying the cache; must be placed before deleting the trees",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx:3,Avoid,Avoid,3,proof/proofplayer/src/TEventIter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx,2,['Avoid'],['Avoid']
Safety,// Avoid diagnosing any sanitizer which is disabled later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid diagnosing invalid decls as incomplete.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid disabling potential load folding opportunities.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid dividing by zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Timer.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Support/Timer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Timer.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid division by zero,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BasicValueFactory.cpp,2,['Avoid'],['Avoid']
Safety,// Avoid division by zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['Avoid'],['Avoid']
Safety,"// Avoid doubling the exit operations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServLite.cxx:3,Avoid,Avoid,3,proof/proof/src/TProofServLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServLite.cxx,1,['Avoid'],['Avoid']
Safety,"// Avoid duplicate implicit defs. This will not detect cases of implicit; // defs that define registers that overlap, but it is not clear how to; // interpret that in the absence of explicit defs. Overlapping explicit; // defs are likely illegal already.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,2,"['Avoid', 'detect']","['Avoid', 'detect']"
Safety,// Avoid duplicate scheduling of the block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid duplicate warning from template instantiation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid duplicated code for big and little endian,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid duplicated replacement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/DefinitionBlockSeparator.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Format/DefinitionBlockSeparator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/DefinitionBlockSeparator.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid duplicates",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/Paths.cpp:3,Avoid,Avoid,3,interpreter/cling/lib/Utils/Paths.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/Paths.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid duplicating calls before register allocation. Calls presents a; // barrier to register allocation so duplicating them may end up increasing; // spills.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid eliminating a copy from/to a reserved registers as we cannot predict; // the value (Example: The sparc zero register is writable but stays zero).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,2,"['Avoid', 'predict']","['Avoid', 'predict']"
Safety,// Avoid emitting DW_AT_calling_convention if the C convention was used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid emitting code for the store implementing the copy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid emitting extra errors if we already errored on the scope.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid emitting tail calls in functions with the disable-tail-calls; // attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid emitting this error twice for the same location. Using a hashtable; // like this is unfortunate, but because we must continue parsing as normal; // after encountering a deferred error, it's otherwise very tricky for us to; // ensure that we only emit this deferred error once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid emitting unnecessary branches to the next block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,7,['Avoid'],['Avoid']
Safety,// Avoid empty array if there are no arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/ItaniumManglingCanonicalizer.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/ProfileData/ItaniumManglingCanonicalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/ItaniumManglingCanonicalizer.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid empty chunks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TThreadExecutor.hxx:3,Avoid,Avoid,3,core/imt/inc/ROOT/TThreadExecutor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TThreadExecutor.hxx,1,['Avoid'],['Avoid']
Safety,// Avoid empty switches.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeEmitterGen.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/utils/TableGen/CodeEmitterGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeEmitterGen.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid endless loop in degenerate case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid erasing the same inst twice.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid error: invalid application of ‘sizeof’ to incomplete type in RJittedAction::GetMergeableValue",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedAction.cxx:3,Avoid,Avoid,3,tree/dataframe/src/RJittedAction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedAction.cxx,1,['Avoid'],['Avoid']
Safety,// Avoid ever breaking before a @tag or a { in JavaScript.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid exceeding the maximum function scope depth.; // See https://bugs.llvm.org/show_bug.cgi?id=19607; // Note Sema::ActOnParamDeclarator calls ParmVarDecl::setScopeInfo with; // getFunctionPrototypeDepth() - 1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid exceeding the target's limit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['Avoid'],['Avoid']
Safety,// Avoid exponential behavior on extremely deep expression trees.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid extending live range of physical registers if they are; //allocatable or reserved.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid extra cost of running passes for BFI when the function doesn't have; // entry count.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/CGProfile.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/CGProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/CGProfile.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid extraction of simple literals and references.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Extract/Extract.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid false dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid false positives due to uninstrumented assembly code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,1,['Avoid'],['Avoid']
Safety,// Avoid fixups when possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid folding Dst into ORR-with-shift if Dst has other uses than ORR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid folding legal fp_rounds into non-legal ones.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid folding to a constant if any OpaqueConstant is involved.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid frequent reallocations as we move up the call stack",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/src/RError.cxx:3,Avoid,Avoid,3,core/foundation/v7/src/RError.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/src/RError.cxx,1,['Avoid'],['Avoid']
Safety,// Avoid functions with complicated argument passing semantics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid garbage input, set the iterator to the end.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkParser.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid generating TFRIs for register transfers---this will keep the; // coalescing opportunities.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid getting clipped,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/OutlinePassEve.js:3,Avoid,Avoid,3,ui5/eve7/lib/OutlinePassEve.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/OutlinePassEve.js,1,['Avoid'],['Avoid']
Safety,"// Avoid having different alignments on delegate call args by always; // setting the alignment to 4, which is what we do for inallocas.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid having the cursor of an expression ""overwrite"" the annotation of the; // variable declaration that it belongs to.; // This can happen for C++ constructor expressions whose range generally; // include the variable declaration, e.g.:; // MyCXXClass foo; // Make sure we don't annotate 'foo' as a CallExpr cursor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid having the cursor of an expression replace the declaration cursor; // when the expression source range overlaps the declaration range.; // This can happen for C++ constructor expressions whose range generally; // include the variable declaration, e.g.:; // MyCXXClass foo; // Make sure pointing at 'foo' returns a VarDecl; // cursor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid having the implicit methods override the property decls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid high cost expansions. Note: This heuristic is questionable in; // that our definition of ""high cost"" is not exactly principled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid hitting recordAnalysis multiple times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid hoisting (and (load x) 1) since it is unlikely to be folded by the; // target even if isLoadExtLegal says an i1 EXTLOAD is valid. For example,; // for the AArch64 target isLoadExtLegal(ZEXTLOAD, i32, i1) returns true, but; // (and (load x) 1) is not matched as a single instruction, rather as a LDR; // followed by an AND.; // TODO: Look into removing this restriction by fixing backends to either; // return false for isLoadExtLegal for i1 or have them select this pattern to; // a single instruction.; //; // Also avoid hoisting if we didn't see any ands with the exact DemandBits; // mask, since these are the only ands that will be removed by isel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,2,"['Avoid', 'avoid']","['Avoid', 'avoid']"
Safety,"// Avoid huge SCEV computations in the loop below, make sure we only; // consider AddRecs of the loop we are trying to peel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid including ""llvm-c/Core.h"" for compile time, fwd-declare this instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Target.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/Target.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Target.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid including type_traits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Value.h:3,Avoid,Avoid,3,interpreter/cling/include/cling/Interpreter/Value.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Value.h,1,['Avoid'],['Avoid']
Safety,// Avoid incompatibility with ASan which relies on the `noreturn`; // attribute to insert handler calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid increasing cross-block register pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid increasing the max critical pressure in the scheduled region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,3,['Avoid'],['Avoid']
Safety,// Avoid increasing the max pressure of the entire region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,3,['Avoid'],['Avoid']
Safety,// Avoid incrementing past stop since it could overflow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid infinite looping with PromoteIntBinOp.; // TODO: Should we apply desirable/legal constraints to all opcodes?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid infinite or exponential worklist processing.; // Also ensure unique worklist users.; // If Def is a LoopPhi, it may not be in the Simplified set, so check for; // self edges first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid infinite recursion",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:3,Avoid,Avoid,3,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['Avoid'],['Avoid']
Safety,// Avoid infinite regress,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid inserting a debug-info record into an EH block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid inserting an intrinsic into an EH block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid inserting the same intrinsic twice.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid instantiating vector<bool> as `operator[]` returns temporaries in that case. Use std::deque instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx:3,Avoid,Avoid,3,tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefaultValueFor.hxx,3,['Avoid'],['Avoid']
Safety,// Avoid instructions obviously unsafe for remat.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,2,"['Avoid', 'unsafe']","['Avoid', 'unsafe']"
Safety,// Avoid instructions which load from potentially varying memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid interpreting hash as a directive under -fpreprocessed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid introducing CC spills (because SRA would clobber CC).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid introducing branch on poison. This also replaces the ctz operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid introducing shuffles with illegal mask.; // shuffle(shuffle(A, B, M0), C, M1) -> shuffle(A, B, M2); // shuffle(shuffle(A, B, M0), C, M1) -> shuffle(A, C, M2); // shuffle(shuffle(A, B, M0), C, M1) -> shuffle(B, C, M2); // shuffle(shuffle(A, B, M0), C, M1) -> shuffle(B, A, M2); // shuffle(shuffle(A, B, M0), C, M1) -> shuffle(C, A, M2); // shuffle(shuffle(A, B, M0), C, M1) -> shuffle(C, B, M2)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid introducing undefined behavior due to poison which didn't exist in; // the original program. (Annoyingly, the rules for poison and undef; // propagation are distinct, so this does NOT cover the undef case above.); // We have to ensure that we don't introduce UB by introducing a use on an; // iteration where said IV produces poison. Our strategy here differs for; // pointers and integer IVs. For integers, we strip and reinfer as needed,; // see code in linearFunctionTestReplace. For pointers, we restrict; // transforms as there is no good way to reinfer inbounds once lost.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid invalidating mutex state when a known supported function is called.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PthreadLockChecker.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid invalidating the iterator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,4,['Avoid'],['Avoid']
Safety,"// Avoid invariant checking of CXXMethodDecl::addOverriddenMethod,; // MD may be initializing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid issuing multiple warnings about the same decl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid iterator invalidation by copying users to a temporary vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid iterator invalidation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid large immediates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid later warnings about a class member of incomplete type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid leak",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:3,Avoid,Avoid,3,tree/dataframe/src/RDFInterfaceUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx,1,['Avoid'],['Avoid']
Safety,// Avoid left shift by 64 directly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid linking compatibility stubs on i386 mac.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid loading zero-sized COFF sections.; // In PE files, VirtualSize gives the section size, and SizeOfRawData; // may be zero for sections with content. In Obj files, SizeOfRawData; // gives the section size, and VirtualSize is always zero. Hence; // the need to check for both cases below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid lookup if can't possibly be in map.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid loops with possiblity of throw,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid losing inrange information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid lots of cluttering when inline printing nodes with associated; // DbgValues in verbose mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid making a copy when initializing a template parameter of class type; // from a template parameter object of the same type. This is going beyond; // the standard, but is required for soundness: in; // template<A a> struct X { X *p; X<a> *q; };; // ... we need p and q to have the same type.; //; // Similarly, don't inject a call to a copy constructor when initializing; // from a template parameter of the same type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid making expensive immediates by commuting shifts. (This logic; // only applies to Thumb1 because ARM and Thumb2 immediates can be shifted; // for free.),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid making zero-length regions active. If it's the last region,; // emit a skipped segment. Otherwise use its predecessor's count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid malloc-ing zero bytes, use max()...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid many check of option validity",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:3,Avoid,Avoid,3,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['Avoid'],['Avoid']
Safety,// Avoid massive lists,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid matching if this pointer gets reused.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid materializing a constant when possible by reusing a known value in; // a register. However, don't perform this optimization if the known value; // is one, zero or negative one in the case of a CSEL. We can always; // materialize these values using CSINC, CSEL and CSINV with wzr/xzr as the; // FVal, respectively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid materializing a temporary for an elidable copy/move constructor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid merging nontemporal stores since the resulting; // memcpy/memset would not be able to preserve the nontemporal hint.; // In theory we could teach how to propagate the !nontemporal metadata to; // memset calls. However, that change would force the backend to; // conservatively expand !nontemporal memset calls back to sequences of; // store instructions (effectively undoing the merging).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid merging nontemporal stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid movs with shifter operand (for Swift),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid multi-step promotion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid multiple DW_OP_stack_values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid multiple calls to GetUrl",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofMgr.cxx:3,Avoid,Avoid,3,proof/proof/src/TProofMgr.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofMgr.cxx,1,['Avoid'],['Avoid']
Safety,// Avoid multiple edges early.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid multiple insertions of the same DICompileUnit to NMD.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid multiplication overflows below.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid multiplication with a denormal, it is not safe on all platforms and; // may be slower than a normal division.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,2,"['Avoid', 'safe']","['Avoid', 'safe']"
Safety,// Avoid negative or zero stride values,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid negative or zero stride values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid non regs, instructions defining physical regs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid odr-using TTree::kMaxEntries which would require a; // definition in C++14. In C++17, all constexpr static data; // members are implicitly inline.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:3,Avoid,Avoid,3,tree/tree/src/InternalTreeUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx,1,['Avoid'],['Avoid']
Safety,// Avoid one makeExactMulNSWRegion() call for the common case of constants.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid other output when using a raw option.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,2,['Avoid'],['Avoid']
Safety,// Avoid out of bounds in checks below. This was already reported earlier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid out of bounds indexing the pieces.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid out of bounds reads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid over-aligning vector parameters. It would require realigning the; // stack and waste space for no real benefit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid overflow in our later calculations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid overflow when addr_delta is large.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid overflow/underflow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid parsing into complex operands (#:),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid parsing the register in `call rd, foo` as a call symbol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid partial and undef register update stalls unless optimizing for size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,3,['Avoid'],['Avoid']
Safety,// Avoid performing the look-up in the common case where the specified; // expression has no loop-variant portions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid picking up a newer decl, just because it was newer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid potential infinite loops by checking for non-constant condition.; // TODO: Can we assert instead by improving canonicalizeSelectToShuffle()?; // Scalar select must have simplified?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid predicating instructions that define a subregister if subregister; // liveness tracking is not enabled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid prescheduling copies to virtual registers, which don't behave; // like other nodes from the perspective of scheduling heuristics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid prescheduling to copies from virtual registers, which don't behave; // like other nodes from the perspective of scheduling heuristics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid printing _Bool instead of bool",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ForwardDeclPrinter.cpp:3,Avoid,Avoid,3,interpreter/cling/lib/Interpreter/ForwardDeclPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ForwardDeclPrinter.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid printing nodes that are part of a pi-block twice. They will get; // printed when the pi-block is printed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid problem with RecursiveRemove.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:3,Avoid,Avoid,3,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,5,['Avoid'],['Avoid']
Safety,"// Avoid problem with file corruption.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:3,Avoid,Avoid,3,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['Avoid'],['Avoid']
Safety,"// Avoid processing instructions out of order, which could cause; // reuse before a value is defined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid processing the same info twice.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid producing TBL instruction if we don't know SVE register minimal size,; // unless NEON is not available and we can assume minimal SVE register size is; // 128-bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid producing inconsistent states by requiring breaks where they are not; // permitted for C# generic type constraints.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid proven overflow cases: this will ensure that the backedge taken count; // will not generate any unsigned overflow. Relaxed no-overflow conditions; // exploit NoWrapFlags, allowing to optimize in presence of undefined; // behaviors like the case of C language.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid proven overflow cases: this will ensure that the backedge taken; // count will not generate any unsigned overflow. Relaxed no-overflow; // conditions exploit NoWrapFlags, allowing to optimize in presence of; // undefined behaviors like the case of C language.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid putting nodes into empty blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid query of available multi-sample modes when not required.; // Over ssh, SLC5 lies about supporting the GLX_SAMPLES_ARB; // extension and then dies horribly when the query is made.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLFormat.cxx:3,Avoid,Avoid,3,graf3d/gl/src/TGLFormat.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLFormat.cxx,1,['Avoid'],['Avoid']
Safety,// Avoid querying the MachineFunctionProperties for each operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid race conditions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TWin32Condition.cxx:3,Avoid,Avoid,3,core/thread/src/TWin32Condition.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TWin32Condition.cxx,2,['Avoid'],['Avoid']
Safety,"// Avoid reading outside the memory accessed by the original load (could; // happened if we only adjust the load base pointer by ShAmt). Instead we; // try to narrow the load even further. The typical scenario here is:; // (i64 (truncate (i96 (srl (load x), 64)))) ->; // (i64 (truncate (i96 (zextload (load i32 + offset) from i32))))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid realigning functions that explicitly do not want to be realigned.; // Normally, we should report an error when a function should be dynamically; // realigned but also has the attribute no-realign-stack. Unfortunately,; // with this attribute, MachineFrameInfo clamps each new object's alignment; // to that of the stack's alignment as specified by the ABI. As a result,; // the information of whether we have objects with larger alignment; // requirement than the stack's alignment is already lost at this point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid reallocations in the loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid reassociating expressions that can be lowered to smlal/umlal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid recalculation of fLast (compared to ->RemoveAt(uid))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TProcessID.cxx:3,Avoid,Avoid,3,core/base/src/TProcessID.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TProcessID.cxx,1,['Avoid'],['Avoid']
Safety,// Avoid recheck of N.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid recursion around e.g. nxv1i8.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid recursion when the caller is computing constant values for this; // IRP itself.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid redundant warning, only warn at the first unmatched sample.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,2,"['Avoid', 'redund']","['Avoid', 'redundant']"
Safety,// Avoid releasing a pointer twice.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['Avoid'],['Avoid']
Safety,"// Avoid rematerializing instructions that return a value that is; // different depending on vector length, even when it is not returned; // in a scalable vector/predicate register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid rematerializing rematerializable instructions that use/define; // scalable values, such as 'pfalse' or 'ptrue', which result in different; // results when the runtime vector length is different.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid removing a DPV that is linked to instructions because it holds; // information about an existing store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid removing a dbg.assign that is linked to instructions because it; // holds information about an existing store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid repeating the create-global-set pattern.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid replacing with broadcast when it's a use of a shuffle; // instruction to preserve the present custom lowering of shuffles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid reporting multiple unreachable code diagnostics that are; // triggered by the same conditional value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid requesting analyses if there are no guards or widenable conditions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid resetting during a cloning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TStreamerElement.cxx:3,Avoid,Avoid,3,core/meta/src/TStreamerElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TStreamerElement.cxx,1,['Avoid'],['Avoid']
Safety,"// Avoid returning a reference to a temporary because of the conversion; // between std::string and TString.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:3,Avoid,Avoid,3,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,3,['Avoid'],['Avoid']
Safety,// Avoid returning empty ranges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid returning the same shuffle operation. For example,; // t7: v16i16 = vector_shuffle<8,9,10,11,4,5,6,7,0,1,2,3,12,13,14,15> t5,; // undef:v16i16",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid returning the same shuffle operation. For example,; // v8i32 = vector_shuffle<0,1,0,1,0,1,0,1> t5, undef:v8i32",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid returning the same shuffle operation.; // v8i32 = vector_shuffle<0,1,4,5,2,3,6,7> t5, undef:v8i32",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid reusing a potentially undef value to compute other values that may; // have originally had a concrete definition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid rewriting the path unless we have to.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Path.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Support/Path.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Path.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid running into the non-derivable point at 0.0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestBackpropagation.h:3,Avoid,Avoid,3,tmva/tmva/test/DNN/TestBackpropagation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestBackpropagation.h,2,['Avoid'],['Avoid']
Safety,// Avoid running it if this is not a call: We should emit *all* template; // parameters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid scalarizing in cases that should be truly illegal. In unresolvable; // situations (like an invalid implicit use), we don't want to infinite loop; // in the legalizer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid scalarizing zero splat stores for scalable vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid scheduling the def-side copy before other successors. Otherwise,; // we could introduce another physreg interference on the copy and; // continue inserting copies indefinitely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid scoring the defined register multiple times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCChecker.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid screwing up the prompt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:3,Avoid,Avoid,3,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['Avoid'],['Avoid']
Safety,// Avoid selecting implicit 'this' expressions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid self-assignment due to incorrect assertions in libstdc++; // containers (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85828).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['Avoid'],['Avoid']
Safety,// Avoid self-assignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,2,['Avoid'],['Avoid']
Safety,"// Avoid self-assignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:3,Avoid,Avoid,3,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,2,['Avoid'],['Avoid']
Safety,"// Avoid sending (error) messages at next action",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:3,Avoid,Avoid,3,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['Avoid'],['Avoid']
Safety,// Avoid serializing long latency dependence chains.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['Avoid'],['Avoid']
Safety,"// Avoid serializing long latency dependence chains.; // For acyclic path limited loops, latency was already checked above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['Avoid'],['Avoid']
Safety,"// Avoid setting up the register pressure tracker for small regions to save; // compile time. As a rough heuristic, only track pressure when the number of; // schedulable instructions exceeds half the integer register file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid shifting by 64: doing so yields an undefined result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,1,['Avoid'],['Avoid']
Safety,"// Avoid sinking loads in order not to skip state-modifying instructions,; // that may alias with the loaded address.; // Only allow sinking of loads within the same basic block that are; // conservatively proven to be safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,2,"['Avoid', 'safe']","['Avoid', 'safe']"
Safety,"// Avoid sinking soft-FP comparisons, since this can move them into a loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid some checks and module map parsing when loading PCM files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid special case, where the start value is an imm(0).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid spelling identifiers, the most common form of token.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid spilling LR in Thumb1 if there's a tail call: it's expensive to; // restore LR in that case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid spilling by exceeding the register limit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid spitting warnings for the use of ECompressionAlgorithm, as this function is itself deprecated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Compression.cxx:3,Avoid,Avoid,3,core/zip/src/Compression.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/Compression.cxx,1,['Avoid'],['Avoid']
Safety,"// Avoid splitting a MOVW+MOVT pair with a relocation on Windows.; // On Windows, this instruction pair is covered by one single; // IMAGE_REL_ARM_MOV32T relocation which covers both instructions. If a; // constant island is injected inbetween them, the relocation will clobber; // the instruction and fail to update the MOVT instruction.; // (These instructions are bundled up until right before the ConstantIslands; // pass.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid splitting an IT block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid splitting backedges of loops. It would introduce small; // out-of-line blocks into the loop which is very bad for code placement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid spurious messages at first action",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServLite.cxx:3,Avoid,Avoid,3,proof/proof/src/TProofServLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServLite.cxx,1,['Avoid'],['Avoid']
Safety,"// Avoid spurious messages: deactivate new inputs ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:3,Avoid,Avoid,3,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['Avoid'],['Avoid']
Safety,"// Avoid spurrious/redundant error messages in case of failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/test/testHashRecursiveRemove.cxx:3,Avoid,Avoid,3,core/meta/test/testHashRecursiveRemove.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/test/testHashRecursiveRemove.cxx,2,"['Avoid', 'redund']","['Avoid', 'redundant']"
Safety,"// Avoid stack access for dynamic indexing by custom lowering to; // v_bfi_b32 (v_bfm_b32 16, (shl idx, 16)), val, vec",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid stack access for these.; // TODO: Generalize to more vector types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid stores to frame-indices (due to an unknown offset).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid storing the same expr twice.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid streaming the synthetic/artificial streamer elements.; // Intentionally, nothing to do at all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TStreamerElement.cxx:3,Avoid,Avoid,3,core/meta/src/TStreamerElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TStreamerElement.cxx,1,['Avoid'],['Avoid']
Safety,"// Avoid tail chasing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:3,Avoid,Avoid,3,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,1,['Avoid'],['Avoid']
Safety,// Avoid tail folding if the trip count is known to be a multiple of any VF; // we choose.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid ternary due to failure to convert the ubig32_t value to a unit64_t; // with MSVC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp,2,['Avoid'],['Avoid']
Safety,"// Avoid that pyconfig.h decides using a #pragma what library python library to use; //#define MS_NO_COREDLL 1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyy.h:3,Avoid,Avoid,3,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyy.h,1,['Avoid'],['Avoid']
Safety,// Avoid the BB to be multi visited.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PreTileConfig.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/X86/X86PreTileConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PreTileConfig.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid the String.fromCharCode.apply(null, array) shortcut, which; // throws a ""maximum call stack size exceeded"" error for large arrays.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:3,Avoid,Avoid,3,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,1,['Avoid'],['Avoid']
Safety,// Avoid the block-retain if this is a block literal that doesn't need to be; // copied to the heap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid the byte-per-byte scan if we're memseting a zeroinitializer; // to zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid the case that the first word is a virtual_base_offset_table instead of; // a virtual_function_table",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TIsAProxy.cxx:3,Avoid,Avoid,3,core/meta/src/TIsAProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TIsAProxy.cxx,1,['Avoid'],['Avoid']
Safety,"// Avoid the double search below in case the name is a fundamental type; // or typedef to a fundamental type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:3,Avoid,Avoid,3,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['Avoid'],['Avoid']
Safety,"// Avoid the expensive division. The compiler should be able to figure it; // out by itself. However as of clang 7, even with the appropriate; // llvm_unreachable added just here, it is not able to do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/AST/Expr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid the fast path, it would only increase code size for a marginal win.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,1,['Avoid'],['Avoid']
Safety,"// Avoid the fold if it would unduly increase the number of multiplies due to; // multiple uses, except on hardware with full-rate multiply-add (which is; // part of full-rate 64-bit ops).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid the full correct expansion for f32 sqrt when promoting from f16.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid the generic expansion with min/max if we don't have pminu*/pmaxu*.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid the magic number of 4 propagated through the code with an alias.; // We use this SmallVector to track the root nodes in a call graph.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-stacks.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/tools/llvm-xray/xray-stacks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-stacks.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid the multiply if we only have 2 bytes to add.; // TODO: Only doing this for scalars because vectors weren't as obviously; // improved.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid the need for a non-const filtered iterator variant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Option/ArgList.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Option/ArgList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Option/ArgList.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid the overflow/underflow",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistFactoryNavigation.cxx:3,Avoid,Avoid,3,roofit/histfactory/src/HistFactoryNavigation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistFactoryNavigation.cxx,1,['Avoid'],['Avoid']
Safety,"// Avoid the overhead if nothing is to be declared",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:3,Avoid,Avoid,3,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['Avoid'],['Avoid']
Safety,"// Avoid the reload as it is GOT relative, and instead fall back to the; // hardcoded value below. This allows a mismatch between the OS and; // application without immediately terminating on the difference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid the transformation if there are multiple uses of the loaded value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid the tricky legalization cases by falling back to using the; // splat code which already handles it gracefully.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid the unnecessary parse-time lookup in the common case; // where the syntax forbids a type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid the weird ""pointer to pointee of ..."".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Checkers/SValExplainer.h:3,Avoid,Avoid,3,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Checkers/SValExplainer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Checkers/SValExplainer.h,1,['Avoid'],['Avoid']
Safety,// Avoid to insert ldtilecfg before any shape defs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PreTileConfig.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/X86/X86PreTileConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PreTileConfig.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid too many nested initializations to prevent a stack overflow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['Avoid'],['Avoid']
Safety,// Avoid trailing comma,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:3,Avoid,Avoid,3,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['Avoid'],['Avoid']
Safety,// Avoid transforming 'DstOp0' if it has other uses than the AND node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid traversing for Load operand with high number of users.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid traversing the ConceptReference in the TypeConstraint; // if we have an immediately-declared-constraint, otherwise; // we'll end up visiting the concept and the arguments in; // the TC twice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h:3,Avoid,Avoid,3,interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h,1,['Avoid'],['Avoid']
Safety,// Avoid traversing the semantic expressions. They should be handled by; // looking through the appropriate opaque expressions in order to build; // a meaningful selection tree.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid triggering a fatal error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid trouble with ridiculously large TrailZ values, such as; // those computed from a null pointer.; // LLVM doesn't support alignments larger than (1 << MaxAlignmentExponent).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid truncating the 64-bit Length to 32 bits in ILP32.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid turning single icmps into a switch.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid types like <2 x i32*>.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid types that are padded when being allocated as scalars, while; // being packed together in a vector (such as i1).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid undefined int64_t -> int conversion below in extreme case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid undefined shifts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,2,['Avoid'],['Avoid']
Safety,// Avoid unnecessary line dash declarations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,Avoid,Avoid,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['Avoid'],['Avoid']
Safety,// Avoid unnecessary undefs by reusing the other operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid unnecessary work if there are no matrix intrinsics in the function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid unrolling when optimizing for size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,2,['Avoid'],['Avoid']
Safety,"// Avoid unused var warning",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:3,Avoid,Avoid,3,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['Avoid'],['Avoid']
Safety,"// Avoid using MCRegisterClass::getSize, since that function will go away; // (move from MC* level to Target* level). Return size in bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid using conditional returns at the end of a loop (since then; // we'd need to emit an unconditional branch to the beginning anyway,; // making the loop body longer). This doesn't apply for low-probability; // loops (eg. compare-and-swap retry), so just decide based on branch; // probability instead of looping structure.; // However, since Compare and Trap instructions cost the same as a regular; // Compare instruction, we should allow the if conversion to convert this; // into a Conditional Compare regardless of the branch probability.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid using parens for identifiers starting with $ - ptxas does; // not expect them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXMCAsmInfo.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXMCAsmInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXMCAsmInfo.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid var-arg functions for now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid visiting default arguments from the definition that were already; // visited in the declaration.; // FIXME: A free function definition can have default arguments.; // Avoiding double visitaiton of default arguments should be handled by the; // visitor probably with a bit in the AST to indicate if the attached; // default argument was 'inherited' or written in source.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp,2,['Avoid'],"['Avoid', 'Avoiding']"
Safety,// Avoid walking large instruction graphs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid walking many users.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid walking the whole tree of a big ConstantExprs multiple times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid warning about comparison of integers with different signs when; // RHS/LHS has a `typeof(E)` type whose sign is different from the sign of; // the type of `E`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid warning about uninitialized pClass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TTabCom.cxx:3,Avoid,Avoid,3,core/rint/src/TTabCom.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TTabCom.cxx,6,['Avoid'],['Avoid']
Safety,"// Avoid warning twice on the same identifier, and don't warn on redeclaration; // of system decl.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid wasting slots with large size and/or large alignment. Pick one; // that is the best fit for this register class (in street metric).; // Picking a larger slot than necessary could happen if a slot for a; // larger register is reserved before a slot for a smaller one. When; // trying to spill a smaller register, the large slot would be found; // first, thus making it impossible to spill the larger register later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterScavenging.cpp,1,['Avoid'],['Avoid']
Safety,// Avoid weird loops,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,2,['Avoid'],['Avoid']
Safety,// Avoid weird situations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Avoid,Avoid,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['Avoid'],['Avoid']
Safety,"// Avoid writing a domain that was already written",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/Domains.cxx:3,Avoid,Avoid,3,roofit/hs3/src/Domains.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/Domains.cxx,1,['Avoid'],['Avoid']
Safety,"// Avoid zooming if the axis is just clicked.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TParallelCoordVar.cxx:3,Avoid,Avoid,3,tree/treeviewer/src/TParallelCoordVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TParallelCoordVar.cxx,1,['Avoid'],['Avoid']
Safety,"// Avoiding duplicated newline terminator, since FileLists are; // newline-separated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Job.cpp:3,Avoid,Avoiding,3,interpreter/llvm-project/clang/lib/Driver/Job.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Job.cpp,1,['Avoid'],['Avoiding']
Safety,"// BB 28/10/05 : Removed (commented out) StrDup() :; // - To get same behaviour on Windows and on Linux; // - To avoid the need to use #ifdefs; // - Solve memory leaks (mainly in TTF::SetTextFont()); // No need for the calling routine to use free() anymore.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx:113,avoid,avoid,113,core/winnt/src/TWinNTSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx,1,['avoid'],['avoid']
Safety,// BUILD_VECTOR was lowered into an IMPLICIT_DEF + 4 INSERT_SUBREG; // that adds a 128 bits reg copy when going through TwoAddressInstructions; // pass. We want to avoid 128 bits copies as much as possible because they; // can't be bundled by our scheduler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelDAGToDAG.cpp:164,avoid,avoid,164,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,// Bail for large initializers in excess of 4K to avoid too many scans.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:50,avoid,avoid,50,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['avoid'],['avoid']
Safety,// Bail for large initializers in excess of 64K to avoid allocating; // too much memory.; // Offset is assumed to be less than or equal than InitSize (this; // is enforced in ReadDataFromGlobal).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:51,avoid,avoid,51,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['avoid'],['avoid']
Safety,// Bail out if the constant can't be safely incremented/decremented.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:37,safe,safely,37,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,2,['safe'],['safely']
Safety,"// Basic ""sanity check"" test -- can we create and delete trees?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/TBasket.cxx:10,sanity check,sanity check,10,tree/tree/test/TBasket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/TBasket.cxx,1,['sanity check'],['sanity check']
Safety,"// Basic hashing mechanism to detect structural change to the IR, used to verify; // pass return status consistency with actual change. In addition to being used; // by the MergeFunctions pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp:30,detect,detect,30,interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,1,['detect'],['detect']
Safety,"// BasicBlock is destroyed already, so this access is UB detectable by msan.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:57,detect,detectable,57,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['detect'],['detectable']
Safety,"// Basing on the type of latch predicate, we interpret the IV iteration range; // as signed or unsigned range. We use different min/max functions (signed or; // unsigned) when intersecting this range with safe iteration ranges implied; // by range checks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:205,safe,safe,205,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,1,['safe'],['safe']
Safety,"// Be conservative, don't insert instruction above something that may have; // side-effects. And since it's potentially bad to separate flag setting; // instruction from the conditional branch, just abort the optimization; // completely.; // Also avoid moving code above predicated instruction since it's hard to; // reason about register liveness with predicated instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:199,abort,abort,199,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,2,"['abort', 'avoid']","['abort', 'avoid']"
Safety,"// Because (problably) we built with cygwin, the path name like:; // LOCALS~1\\Temp; // gets extended to; // LOCALSc:\\Devel; // The most likely cause is that '~' is used with Unix semantic of the; // home directory (and it also cuts the path short after ... who knows why!); // So we need to detect this case and prevents its expansion :(.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx:293,detect,detect,293,core/winnt/src/TWinNTSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx,1,['detect'],['detect']
Safety,// Because NewLowerBound is never the smallest representable integer; // it is safe here to subtract one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:79,safe,safe,79,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,1,['safe'],['safe']
Safety,"// Because all to-be-promoted nodes only have users that are other; // promoted nodes (or the original INSERT_SUBREG), we can safely replace; // the i32 result value type with i64.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:126,safe,safely,126,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['safe'],['safely']
Safety,"// Because calling the setters of these calls recomputes, just set them; // manually to avoid recomputing a bunch of times.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h:88,avoid,avoid,88,interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,1,['avoid'],['avoid']
Safety,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:140,safe,safe,140,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,2,['safe'],"['safe', 'safely']"
Safety,"// Because of how EmitCmp is called with fast-isel, you can; // end up with redundant ""andi"" instructions after the sequences emitted below.; // We should try and solve this issue in the future.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:76,redund,redundant,76,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,1,['redund'],['redundant']
Safety,"// Because the result and the input are different vector types, widening; // the result could create a legal type but widening the input might make; // it an illegal type that might lead to repeatedly splitting the input; // and then widening it. To avoid this, we widen the input only if; // it results in a legal type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:250,avoid,avoid,250,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['avoid'],['avoid']
Safety,"// Because the result and the input are different vector types, widening; // the result could create a legal type but widening the input might; // make it an illegal type that might lead to repeatedly splitting the; // input and then widening it. To avoid this, we widen the input only if; // it results in a legal type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:250,avoid,avoid,250,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['avoid'],['avoid']
Safety,// Because we don't try to provide any exception safety guarantees we can; // implement move assignment very simply by first destroying the current; // object and then move-constructing over top of it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h:49,safe,safety,49,interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,1,['safe'],['safety']
Safety,"// Before IRTranslator pass, calls to spv_switch intrinsic are inserted before; // each switch instruction. IRTranslator lowers switches to G_ICMP + G_BRCOND; // + G_BR triples. A switch with two cases may be transformed to this MIR; // sequence:; //; // intrinsic(@llvm.spv.switch), %CmpReg, %Const0, %Const1; // %Dst0 = G_ICMP intpred(eq), %CmpReg, %Const0; // G_BRCOND %Dst0, %bb.2; // G_BR %bb.5; // bb.5.entry:; // %Dst1 = G_ICMP intpred(eq), %CmpReg, %Const1; // G_BRCOND %Dst1, %bb.3; // G_BR %bb.4; // bb.2.sw.bb:; // ...; // bb.3.sw.bb1:; // ...; // bb.4.sw.epilog:; // ...; //; // Sometimes (in case of range-compare switches), additional G_SUBs; // instructions are inserted before G_ICMPs. Those need to be additionally; // processed.; //; // This function modifies spv_switch call's operands to include destination; // MBBs (default and for each constant value).; //; // At the end, the function removes redundant [G_SUB] + G_ICMP + G_BRCOND +; // G_BR sequences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:917,redund,redundant,917,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,1,['redund'],['redundant']
Safety,"// Before adding, extend both operands to i64 to avoid; // overflow trouble.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:49,avoid,avoid,49,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['avoid'],['avoid']
Safety,"// Before passing 'returned' to the target lowering code, ensure that; // either the register MVT and the actual EVT are the same size or that; // the return value and argument are extended in the same way; in these; // cases it's safe to pass the argument register value unchanged as the; // return register value (although it's at the target's option whether; // to do so); // TODO: allow code generation to take advantage of partially preserved; // registers rather than clobbering the entire register when the; // parameter extension method is not compatible with the return; // extension method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:231,safe,safe,231,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['safe'],['safe']
Safety,// Before recursing into the children keep some state that we are going; // to use in the AnnotateTokensWorker::postVisitChildren callback to do some; // extra work after the child nodes are visited.; // Note that we don't call VisitChildren here to avoid traversing statements; // code-recursively which can blow the stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:250,avoid,avoid,250,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['avoid'],['avoid']
Safety,"// Before rematerializing into a register for a single instruction, try to; // fold a load into the instruction. That avoids allocating a new register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:118,avoid,avoids,118,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['avoid'],['avoids']
Safety,"// Before returning, rename the files if no errors occurred; // otherwise clean them to avoid remnants (see ROOT-10015)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:88,avoid,avoid,88,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['avoid'],['avoid']
Safety,"// Before we handle the more subtle cases of register-register CMOVs inside; // of potentially hot loops, we want to quickly remove all CMOVs (ForceAll) or; // the ones with a memory operand (ForceMemOperand option). The latter CMOV; // will risk a stall waiting for the load to complete that speculative; // execution behind a branch is better suited to handle on modern x86 chips.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:242,risk,risk,242,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,1,['risk'],['risk']
Safety,"// Before we start introducing relocations, we want to tweak the IR a bit to; // avoid unfortunate code generation effects. The main example is that we; // want to try to make sure the comparison feeding a branch is after any; // safepoints. Otherwise, we end up with a comparison of pre-relocation; // values feeding a branch after relocation. This is semantically correct,; // but results in extra register pressure since both the pre-relocation and; // post-relocation copies must be available in registers. For code without; // relocations this is handled elsewhere, but teaching the scheduler to; // reverse the transform we're about to do would be slightly complex.; // Note: This may extend the live range of the inputs to the icmp and thus; // increase the liveset of any statepoint we move over. This is profitable; // as long as all statepoints are in rare blocks. If we had in-register; // lowering for live values this would be a much safer transform.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:81,avoid,avoid,81,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,3,"['avoid', 'safe']","['avoid', 'safepoints', 'safer']"
Safety,"// Before we update MTracker, remember which values were present in each of; // the locations about to be overwritten, so that we can recover any; // potentially clobbered variables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:134,recover,recover,134,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['recover'],['recover']
Safety,"// Before/After callbacks accept IRUnits whenever appropriate, so they need; // to take them as constant pointers, wrapped with llvm::Any.; // For the case when IRUnit has been invalidated there is a different; // callback to use - AfterPassInvalidated.; // We call all BeforePassFuncs to determine if a pass should run or not.; // BeforeNonSkippedPassFuncs are called only if the pass should run.; // TODO: currently AfterPassInvalidated does not accept IRUnit, since passing; // already invalidated IRUnit is unsafe. There are ways to handle invalidated; // IRUnits in a safe way, and we might pursue that as soon as there is a; // useful instrumentation that needs it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassInstrumentation.h:511,unsafe,unsafe,511,interpreter/llvm-project/llvm/include/llvm/IR/PassInstrumentation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassInstrumentation.h,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"// Beyond this point, if any operand is a global, skip that instruction.; // The reason is that certain instructions that can take an immediate; // operand can also have a global symbol in that operand. To avoid; // checking what kind of operand a given instruction has individually; // for each instruction, do it here. Global symbols as operands gene-; // rally do not provide any useful information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:206,avoid,avoid,206,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,1,['avoid'],['avoid']
Safety,"// Big endian - avoid unaligned loads.; // EXTLOAD:i24 -> (shl EXTLOAD:i16, 8) | ZEXTLOAD@+2:i8; // Load the top RoundWidth bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:16,avoid,avoid,16,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['avoid'],['avoid']
Safety,"// Big endian - avoid unaligned stores.; // TRUNCSTORE:i24 X -> TRUNCSTORE:i16 (srl X, 8), TRUNCSTORE@+2:i8 X; // Store the top RoundWidth bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:16,avoid,avoid,16,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['avoid'],['avoid']
Safety,"// Bit width info is 1 bytes, 256 is safely out of range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/InterfaceStub/IFSStub.h:37,safe,safely,37,interpreter/llvm-project/llvm/include/llvm/InterfaceStub/IFSStub.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/InterfaceStub/IFSStub.h,1,['safe'],['safely']
Safety,"// Bitcasting to f64 here allows us to do a single 64-bit store from; // an SSE register, avoiding the store forwarding penalty that would come; // with two 32-bit stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:90,avoid,avoiding,90,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['avoid'],['avoiding']
Safety,// Blend in safe operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:12,safe,safe,12,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,1,['safe'],['safe']
Safety,// Block CopyFromReg so partial register stalls are avoided.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:52,avoid,avoided,52,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,1,['avoid'],['avoided']
Safety,"// Block fields are not necessarily ordered; if we detect that we're; // adding them out-of-order, make sure we sort later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:51,detect,detect,51,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['detect'],['detect']
Safety,// Blocks in OpenCL have unique constraints which make the standard fields; // redundant while requiring size and align fields for enqueue_kernel. See; // initializeForBlockHeader in CGBlocks.cpp,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:79,redund,redundant,79,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,2,['redund'],['redundant']
Safety,// Borrowed from Arm Target; // We would like to restrict this hazard recognizer to only; // post-RA scheduling; we can tell that we're post-RA because we don't; // track VRegLiveness.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:63,hazard,hazard,63,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['hazard'],['hazard']
Safety,"// Both expressions have locations, though they may not have corresponding; // values. In that case, we create a fresh value at this point. Note that if; // two branches both do this, they will not share the value, but it at least; // allows for local reasoning about the value. To avoid the above, we would; // need *lazy* value allocation.; // FIXME: allocate values lazily, instead of just creating a fresh value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp:282,avoid,avoid,282,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,1,['avoid'],['avoid']
Safety,// Both the base and derived must be piped through the safepoint.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:55,safe,safepoint,55,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['safe'],['safepoint']
Safety,"// Both the registers were live: examine the conflict resolution record for; // the value number Reg refers to. CR_Keep meant that this value number; // ""won"" and the merged register definitely refers to that value. CR_Erase; // means the value number was a redundant copy of the other value, which; // was coalesced and Reg deleted. It's safe to refer to the other register; // (which will be the source of the copy).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:258,redund,redundant,258,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,2,"['redund', 'safe']","['redundant', 'safe']"
Safety,// Bound symbolic regions need to be invalidated for dead symbol; // detection.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:69,detect,detection,69,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,1,['detect'],['detection']
Safety,// Branch predicted taken.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h:10,predict,predicted,10,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonBaseInfo.h,1,['predict'],['predicted']
Safety,"// Branch to dest on icc condition, with prediction (64-bit only).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h:41,predict,prediction,41,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h,1,['predict'],['prediction']
Safety,"// Branch to dest on xcc condition, with prediction (64-bit only).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h:41,predict,prediction,41,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.h,1,['predict'],['prediction']
Safety,// Branches are assumed to be predicted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:30,predict,predicted,30,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,4,['predict'],['predicted']
Safety,"// Branching SPIR-V intrinsics are not detected by this generic method.; // Thus, we can only trust negative result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:39,detect,detected,39,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,1,['detect'],['detected']
Safety,"// Break out of the ParsingDeclSpec context, too. This const_cast is; // safe because we're always the sole owner.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:73,safe,safe,73,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['safe'],['safe']
Safety,"// Breaking before the first ""<<"" is generally not desirable if the LHS is; // short. Also always add the penalty if the LHS is split over multiple lines; // to avoid unnecessary line breaks that just work around this penalty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:161,avoid,avoid,161,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['avoid'],['avoid']
Safety,"// Bugpoint has the ability of generating a plethora of core files, so to; // avoid filling up the disk, we prevent it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp:78,avoid,avoid,78,interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp,1,['avoid'],['avoid']
Safety,"// Bugzilla ID: 46767; // TODO: Check if fixing up the stack more than once is safe so we can; // outline these.; //; // An outline resulting in a caller that requires stack fixups at the; // callsite to a callee that also requires stack fixups can happen when; // there are no available registers at the candidate callsite for a; // candidate that itself also has calls.; //; // In other words if function_containing_sequence in the following pseudo; // assembly requires that we save LR at the point of the call, but there; // are no available registers: in this case we save using SP and as a; // result the SP offsets requires stack fixups by multiples of 16.; //; // function_containing_sequence:; // ...; // save LR to SP <- Requires stack instr fixups in OUTLINED_FUNCTION_N; // call OUTLINED_FUNCTION_N; // restore LR from SP; // ...; //; // OUTLINED_FUNCTION_N:; // save LR to SP <- Requires stack instr fixups in OUTLINED_FUNCTION_N; // ...; // bl foo; // restore LR from SP; // ret; //; // Because the code to handle more than one stack fixup does not; // currently have the proper checks for legality, these cases will assert; // in the AArch64 MachineOutliner. This is because the code to do this; // needs more hardening, testing, better checks that generated code is; // legal, etc and because it is only verified to handle a single pass of; // stack fixup.; //; // The assert happens in AArch64InstrInfo::buildOutlinedFrame to catch; // these cases until they are known to be handled. Bugzilla 46767 is; // referenced in comments at the assert site.; //; // To avoid asserting (or generating non-legal code on noassert builds); // we remove all candidates which would need more than one stack fixup by; // pruning the cases where the candidate has calls while also having no; // available LR and having no available general purpose registers to copy; // LR to (ie one extra stack save/restore).; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:79,safe,safe,79,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"// Build MemorySSA using a batch alias analysis. This reuses the internal; // state that AA collects during an alias()/getModRefInfo() call. This is; // safe because there are no CFG changes while building MemorySSA and can; // significantly reduce the time spent by the compiler in AA, because we will; // make queries about all the instructions in the Function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:153,safe,safe,153,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['safe'],['safe']
Safety,// Build a full-expression copy expression if initialization; // succeeded and used a non-trivial constructor. Recover from; // errors by pretending that the copy isn't necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:111,Recover,Recover,111,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['Recover'],['Recover']
Safety,"// Build a minimal pipeline based on the semantics required by LLVM,; // which is just that always inlining occurs. Further, disable generating; // lifetime intrinsics to avoid enabling further optimizations during; // code generation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:171,avoid,avoid,171,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['avoid'],['avoid']
Safety,// Build a string naming the redundant qualifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:29,redund,redundant,29,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['redund'],['redundant']
Safety,"// Build the instruction used to repair, then clone it at the right; // places. Avoiding buildCopy bypasses the check that Src and Dst have the; // same types because the type is a placeholder when this function is called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:80,Avoid,Avoiding,80,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['Avoid'],['Avoiding']
Safety,// Build the region hierarchy after all region detected.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:47,detect,detected,47,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,1,['detect'],['detected']
Safety,// Build up a worklist of inner-loops to transform to avoid iterator; // invalidation.; // FIXME: This logic comes from other passes that actually change the loop; // nest structure. It isn't clear this is necessary (or useful) for a pass; // which merely optimizes the use of loads in a loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:54,avoid,avoid,54,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,1,['avoid'],['avoid']
Safety,"// BuildIdArray();; // avoid voxelization if requested to speed up geometry startup",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:23,avoid,avoid,23,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,1,['avoid'],['avoid']
Safety,"// Builds a joined TypeErasedDataflowAnalysisState from 0 or more sources,; // each of which may be owned (built as part of the join) or external (a; // reference to an Environment that will outlive the builder).; // Avoids unneccesary copies of the environment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp:217,Avoid,Avoids,217,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp,1,['Avoid'],['Avoids']
Safety,// Bump CurCycle to account for latency. We assume the latency of other; // available instructions may be hidden by the stall (not a full pipe stall).; // This updates the hazard recognizer's cycle before reserving resources for; // this instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:172,hazard,hazard,172,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['hazard'],['hazard']
Safety,// Bump the reference DI to avoid cramming discriminators on line 0.; // FIXME(mtrofin): pin ReferenceDI on blocks or first instruction with DI; // in a block. It's more consistent than just relying on the last memop; // instruction we happened to see.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp:28,avoid,avoid,28,interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp,1,['avoid'],['avoid']
Safety,"// But if this is a static local in a dlimport/dllexport function, the; // function will never be inlined, which means the var would never be; // imported, so having it marked import/export is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:193,safe,safe,193,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['safe'],['safe']
Safety,"// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js); // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,; // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.; // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped; // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture; // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:648,detect,detected,648,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['detect'],['detected']
Safety,"// By default prefer folding (abs (sub nsw x, y)) -> abds(x, y). Some targets; // may want to avoid this to prevent loss of sub_nsw pattern.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:94,avoid,avoid,94,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['avoid'],['avoid']
Safety,"// By default the entry count is initialized to -1, which will be treated; // conservatively by getEntryCount as the same as unknown (None). This is; // to avoid newly added code to be treated as cold. If we have samples; // this will be overwritten in emitAnnotations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:156,avoid,avoid,156,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['avoid'],['avoid']
Safety,"// By default, an instruction consumes a number of buffer entries equal to its; // number of micro opcodes (see field `InstrDesc::NumMicroOpcodes`). The; // number of entries consumed by an instruction is normalized to the; // minimum value between NumMicroOpcodes and the buffer size. This is to avoid; // problems with (microcoded) instructions that generate a number of micro; // opcodes than doesn't fit in the buffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Stages/MicroOpQueueStage.h:297,avoid,avoid,297,interpreter/llvm-project/llvm/include/llvm/MCA/Stages/MicroOpQueueStage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Stages/MicroOpQueueStage.h,1,['avoid'],['avoid']
Safety,"// By introducing PREPARE_PROBED_ALLOCA_NEGSIZE_OPT, ActualNegSizeReg; // and NegSizeReg will be allocated in the same phyreg to avoid; // redundant copy when NegSizeReg has only one use which is current MI and; // will be replaced by PREPARE_PROBED_ALLOCA then.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:129,avoid,avoid,129,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,// By this point we've effectively got; // zero_inactive_lanes_and_trunc_i1(sext_i1(A)). If we can prove A's inactive; // lanes are already zero then the trunc(sext()) sequence is redundant and we; // can operate on A directly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:180,redund,redundant,180,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['redund'],['redundant']
Safety,// Bypass HazardRec virtual calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:10,Hazard,HazardRec,10,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['Hazard'],['HazardRec']
Safety,// Bypass back edges to avoid extra work.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:24,avoid,avoid,24,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,1,['avoid'],['avoid']
Safety,"// C++ 8.2p1:; // The ambiguity arising from the similarity between a function-style cast and; // a declaration mentioned in 6.8 can also occur in the context of a; // declaration. In that context, the choice is between a function declaration; // with a redundant set of parentheses around a parameter name and an object; // declaration with a function-style cast as the initializer. Just as for the; // ambiguities mentioned in 6.8, the resolution is to consider any construct; // that could possibly be a declaration a declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:254,redund,redundant,254,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['redund'],['redundant']
Safety,"// C++ [dcl.typedef]p9: [P1766R1, applied as DR]; // An unnamed class with a typedef name for linkage purposes shall [be; // C-like].; //; // FIXME: Also diagnose if we've already computed the linkage. That ideally; // shouldn't happen, but there are constructs that the language rule doesn't; // disallow for which we can't reasonably avoid computing linkage early.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:336,avoid,avoid,336,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avoid'],['avoid']
Safety,// C++ [expr.typeid]p3:; // When typeid is applied to an expression other than an glvalue of a; // polymorphic class type [...] [the] expression is an unevaluated; // operand. [...]; // We add only potentially evaluated statements to the block to avoid; // CFG generation for unevaluated operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:247,avoid,avoid,247,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['avoid'],['avoid']
Safety,"// C++ [over.over]p1:; // [...] [Note: any redundant set of parentheses surrounding the; // overloaded function name is ignored (5.1). ]; // C++ [over.over]p1:; // [...] The overloaded function name can be preceded by the &; // operator.; // If we didn't actually find any template-ids, we're done.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:43,redund,redundant,43,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['redund'],['redundant']
Safety,"// C++ [temp.class.spec]p9b3:; //; // -- The argument list of the specialization shall not be identical; // to the implicit argument list of the primary template.; //; // This rule has since been removed, because it's redundant given DR1495,; // but we keep it because it produces better diagnostics and recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:218,redund,redundant,218,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,2,"['recover', 'redund']","['recovery', 'redundant']"
Safety,"// C++ [temp.mem]p6:; // [...] For each such operator, if argument deduction succeeds; // (14.9.2.3), the resulting specialization is used as if found by; // name lookup.; //; // When referencing a conversion function for any purpose other than; // a redeclaration (such that we'll be building an expression with the; // result), perform template argument deduction and place the; // specialization into the result set. We do this to avoid forcing all; // callers to perform special deduction for conversion functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:434,avoid,avoid,434,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['avoid'],['avoid']
Safety,"// C++ [temp.names]p3:; // A name prefixed by the keyword template shall be a template-id [...]; //; // A template-id cannot begin with a '~' token. This would never work; // anyway: x.~A<int>() would specify that the destructor is a template,; // not that 'A' is a template.; //; // FIXME: Suggest replacing the attempted destructor name with a correct; // destructor name and recover. (This is not trivial if this would become; // a pseudo-destructor name).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:378,recover,recover,378,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['recover'],['recover']
Safety,"// C++ for OpenCL does not allow virtual function qualifier, to avoid; // function pointers restricted in OpenCL v2.0 s6.9.a.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:64,avoid,avoid,64,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['avoid'],['avoid']
Safety,"// C++03 [basic.lookup.classref]p4:; // [...] If the name is found in both contexts, the; // class-name-or-namespace-name shall refer to the same entity.; //; // We already found the name in the scope of the object. Now, look; // into the current scope (the scope of the postfix-expression) to; // see if we can find the same name there. As above, if there is no; // scope, reconstruct the result from the template instantiation itself.; //; // Note that C++11 does *not* perform this redundant lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:485,redund,redundant,485,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['redund'],['redundant']
Safety,"// C++14 [class.qual]p2:; // In a lookup in which function names are not ignored and the; // nested-name-specifier nominates a class C, if the name specified; // [...] is the injected-class-name of C, [...] the name is instead; // considered to name the constructor; //; // We don't get here if naming the constructor would be valid, so we; // just reject immediately and recover by treating the; // injected-class-name as naming the template.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:372,recover,recover,372,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['recover'],['recover']
Safety,"// C++17 [dcl.init]p17:; // - If the initializer expression is a prvalue and the cv-unqualified; // version of the source type is the same class as the class of the; // destination, the initializer expression is used to initialize the; // destination object.; // Per DR (no number yet), this does not apply when initializing a base; // class or delegating to another constructor from a mem-initializer.; // ObjC++: Lambda captured by the block in the lambda to block conversion; // should avoid copy elision.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:489,avoid,avoid,489,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['avoid'],['avoid']
Safety,"// C++1y / DR1070:; // shall be initialized [...] from an empty initializer list.; //; // We apply the resolution of this DR to C++11 but not C++98, since C++98; // does not have useful semantics for initialization from an init list.; // We treat this as copy-initialization, because aggregate initialization; // always performs copy-initialization on its elements.; //; // Only do this if we're initializing a class type, to avoid filling in; // the initializer list where possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:426,avoid,avoid,426,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['avoid'],['avoid']
Safety,"// C++20 [expr.prim.lambda]p8:; // If a lambda-capture includes a capture-default that is =,; // each simple-capture of that lambda-capture shall be of the form; // ""&identifier"", ""this"", or ""* this"". [ Note: The form [&,this] is; // redundant but accepted for compatibility with ISO C++14. --end note ]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:234,redund,redundant,234,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,1,['redund'],['redundant']
Safety,"// C++23 [lex.phases] p1; // Diagnose invalid UTF-8 if the corresponding warning is enabled, emitting a; // diagnostic only once per entire ill-formed subsequence to avoid; // emiting to many diagnostics (see http://unicode.org/review/pr-121.html).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:166,avoid,avoid,166,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['avoid'],['avoid']
Safety,"// C++2a [over.built]p14:; //; // For every integral type T there exists a candidate operator function; // of the form; //; // std::strong_ordering operator<=>(T, T); //; // C++2a [over.built]p15:; //; // For every pair of floating-point types L and R, there exists a candidate; // operator function of the form; //; // std::partial_ordering operator<=>(L, R);; //; // FIXME: The current specification for integral types doesn't play nice with; // the direction of p0946r0, which allows mixed integral and unscoped-enum; // comparisons. Under the current spec this can lead to ambiguity during; // overload resolution. For example:; //; // enum A : int {a};; // auto x = (a <=> (long)42);; //; // error: call is ambiguous for arguments 'A' and 'long'.; // note: candidate operator<=>(int, int); // note: candidate operator<=>(long, long); //; // To avoid this error, this function deviates from the specification and adds; // the mixed overloads `operator<=>(L, R)` where L and R are promoted; // arithmetic types (the same as the generic relational overloads).; //; // For now this function acts as a placeholder.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:849,avoid,avoid,849,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['avoid'],['avoid']
Safety,// C2 << X can equal zero in some circumstances.; // This simplification might be unsafe if C is zero.; //; // We know it is safe if:; // - The shift is nsw. We can't shift out the one bit.; // - The shift is nuw. We can't shift out the one bit.; // - C2 is one.; // - C isn't zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:82,unsafe,unsafe,82,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"// C99 6.8.4p3 - In C99, the body of the if statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do this; // if the body isn't a compound statement to avoid push/pop in common cases.; //; // C++ 6.4p1:; // The substatement in a selection-statement (each substatement, in the else; // form of the if statement) implicitly defines a local scope.; //; // For C++ we create a scope for the condition and a new scope for; // substatements because:; // -When the 'then' scope exits, we want the condition declaration to still be; // active for the 'else' scope too.; // -Sema will detect name clashes by considering declarations of a; // 'ControlScope' as part of its direct subscope.; // -If we wanted the condition and substatement to be in the same scope, we; // would have to notify ParseStatement not to create a new scope. It's; // simpler to let it create a new scope.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:198,avoid,avoid,198,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,2,"['avoid', 'detect']","['avoid', 'detect']"
Safety,"// C99 6.8.4p3 - In C99, the body of the if statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do; // this if the body isn't a compound statement to avoid push/pop in common; // cases.; //; // C++ 6.4p1:; // The substatement in a selection-statement (each substatement, in the else; // form of the if statement) implicitly defines a local scope.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:198,avoid,avoid,198,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['avoid'],['avoid']
Safety,"// C99 6.8.4p3 - In C99, the body of the switch statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do this; // if the body isn't a compound statement to avoid push/pop in common cases.; //; // C++ 6.4p1:; // The substatement in a selection-statement (each substatement, in the else; // form of the if statement) implicitly defines a local scope.; //; // See comments in ParseIfStatement for why we create a scope for the; // condition and a new scope for substatement in C++.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:202,avoid,avoid,202,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['avoid'],['avoid']
Safety,"// C99 6.8.5p5 - In C99, the body of the do statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do this; // if the body isn't a compound statement to avoid push/pop in common cases.; //; // C++ 6.5p2:; // The substatement in an iteration-statement implicitly defines a local scope; // which is entered and exited each time through the loop.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:198,avoid,avoid,198,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['avoid'],['avoid']
Safety,"// C99 6.8.5p5 - In C99, the body of the for statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do this; // if the body isn't a compound statement to avoid push/pop in common cases.; //; // C++ 6.5p2:; // The substatement in an iteration-statement implicitly defines a local scope; // which is entered and exited each time through the loop.; //; // See comments in ParseIfStatement for why we create a scope for; // for-init-statement/condition and a new scope for substatement in C++.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:199,avoid,avoid,199,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['avoid'],['avoid']
Safety,"// C99 6.8.5p5 - In C99, the body of the while statement is a scope, even if; // there is no compound stmt. C90 does not have this clause. We only do this; // if the body isn't a compound statement to avoid push/pop in common cases.; //; // C++ 6.5p2:; // The substatement in an iteration-statement implicitly defines a local scope; // which is entered and exited each time through the loop.; //; // See comments in ParseIfStatement for why we create a scope for the; // condition and a new scope for substatement in C++.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:201,avoid,avoid,201,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['avoid'],['avoid']
Safety,"// C99 6.9.2p3: If the declaration of an identifier for an object is; // a tentative definition and has internal linkage (C99 6.2.2p3), the; // declared type shall not be an incomplete type.; // NOTE: code such as the following; // static struct s;; // struct s { int a; };; // is accepted by gcc. Hence here we issue a warning instead of; // an error and we do not invalidate the static declaration.; // NOTE: to avoid multiple warnings, only check the first declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:414,avoid,avoid,414,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avoid'],['avoid']
Safety,"// CAUTION! This state is only valid for the last click event.; // If the next itemPress is triggered by a keyboard or touch event, it will still; // read this outdated ctrlKeyPressed information!!; // So ALL events causing itemPress must clear/set ctrlKeyPressed; // or ctrlKeyPressed must be reset to false after a short timeout.; //; // Also, it is not tested whether for all types of events, the direct browser; // event is coming BEFORE the itemPress event handler invocation!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/controller/Ged.controller.js:323,timeout,timeout,323,ui5/eve7/controller/Ged.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/controller/Ged.controller.js,1,['timeout'],['timeout']
Safety,"// CCMP accept the constant int the range [0, 31]; // if the Op1 is a constant in the range [-31, -1], we; // can select to CCMN to avoid the extra mov",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:132,avoid,avoid,132,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// CFRetain isn't supposed to be annotated. However, this may as; // well be a user-made ""safe"" CFRetain function that is incorrectly; // annotated as cf_returns_retained due to lack of better options.; // We want to ignore such annotation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:90,safe,safe,90,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,1,['safe'],['safe']
Safety,"// CMOV in (cmov (trunc ...), true, false, int-comparison) is safe.; // However, trunc in true or false clauses is not safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:62,safe,safe,62,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,2,['safe'],['safe']
Safety,"// CUDA 8.0.41 relies on __USE_FAST_MATH__ and __CUDA_PREC_DIV's values.; // Previous versions used to check whether they are defined or not.; // CU_DEVICE_INVALID macro is only defined in 8.0.41, so we use it; // here to detect the switch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:222,detect,detect,222,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,1,['detect'],['detect']
Safety,"// CUDA headers define __noinline__ which interferes with libstdc++'s use of; // `__attribute((__noinline__))`. In order to avoid compilation error,; // temporarily unset __noinline__ when we include affected libstdc++ header.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/basic_string.h:124,avoid,avoid,124,interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/basic_string.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cuda_wrappers/bits/basic_string.h,2,['avoid'],['avoid']
Safety,"// CUDA host and device may have different _Float16 support, therefore; // allows f16 literals to avoid false alarm.; // When we compile for OpenMP target offloading on NVPTX, f16 suffix; // should also be supported.; // ToDo: more precise check for CUDA.; // TODO: AMDGPU might also support it in the future.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:98,avoid,avoid,98,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,1,['avoid'],['avoid']
Safety,"// CUDA host and device may have different _Float16 support, therefore; // do not diagnose _Float16 usage to avoid false alarm.; // ToDo: more precise diagnostics for CUDA.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:109,avoid,avoid,109,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['avoid'],['avoid']
Safety,// CUDA/HIP can have the same input source code compiled multiple times so do; // not compiled again if there are already failures. It is OK to abort the; // CUDA pipeline on errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Compilation.cpp:144,abort,abort,144,interpreter/llvm-project/clang/lib/Driver/Compilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Compilation.cpp,1,['abort'],['abort']
Safety,"// CUDA/HIP: managed variables need to be externalized since it is; // a declaration in IR, therefore cannot have internal linkage. Kernels in; // anonymous name space needs to be externalized to avoid duplicate symbols.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:196,avoid,avoid,196,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['avoid'],['avoid']
Safety,// Cache ProfileSummaryAnalysis once to avoid the potential need to insert; // RequireAnalysisPass for PSI before subsequent non-module passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:40,avoid,avoid,40,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,4,['avoid'],['avoid']
Safety,// Cache already parsed PatFrags to avoid doing extra work.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp:36,avoid,avoid,36,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,1,['avoid'],['avoid']
Safety,// Cache and recycle the CodeExtractor analysis to avoid O(n^2) compile-time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:51,avoid,avoid,51,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,2,['avoid'],['avoid']
Safety,"// Cache for the ""fake"" buffer used for error-recovery purposes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:46,recover,recovery,46,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['recover'],['recovery']
Safety,// Cache of created instructions to avoid creating duplicates.; // XXX Currently only used by genBitSplit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:36,avoid,avoid,36,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,1,['avoid'],['avoid']
Safety,"// Cache the Pass ID here in case the pass manager finds this pass is; // redundant with ones already scheduled / available, and deletes it.; // Fundamentally, once we add the pass to the manager, we no longer own it; // and shouldn't reference it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:74,redund,redundant,74,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,1,['redund'],['redundant']
Safety,// Cache the valid types we encounter to avoid rechecking structs that are; // used again,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:41,avoid,avoid,41,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avoid'],['avoid']
Safety,// Caches boolean evaluations of expressions to avoid multiple re-evaluations; // during construction of branches for chained logical operators.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:48,avoid,avoid,48,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['avoid'],['avoid']
Safety,// Calculate 31-x. 31 is used instead of 32 to avoid creating an undefined; // shift if x is zero. We can use XOR here because x is known to be smaller; // than 32.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:47,avoid,avoid,47,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['avoid'],['avoid']
Safety,"// Calculate Edge Weights using ""Pointer Heuristics"". Predict a comparison; // between two pointer or pointer and NULL will fail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:54,Predict,Predict,54,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,1,['Predict'],['Predict']
Safety,// Calculate K! / 2^T and T; we divide out the factors of two before; // multiplying for calculating K! / 2^T to avoid overflow.; // Other overflow doesn't matter because we only care about the bottom; // W bits of the result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:113,avoid,avoid,113,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avoid'],['avoid']
Safety,"// Calculate number of buffer bins on each size to avoid cyclical flow",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:51,avoid,avoid,51,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['avoid'],['avoid']
Safety,// Calculate symbol coverage and detect invalid debug locations and ranges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVReader.cpp:33,detect,detect,33,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVReader.cpp,1,['detect'],['detect']
Safety,// Calculate timings for FlameGraph. Cast time points to microsecond precision; // rather than casting duration. This avoids truncation issues causing inner; // scopes overruning outer scopes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/TimeProfiler.cpp:118,avoid,avoids,118,interpreter/llvm-project/llvm/lib/Support/TimeProfiler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/TimeProfiler.cpp,1,['avoid'],['avoids']
Safety,"// Call Calc every 1000 newlines in order to avoid jitting a very large function body, which is slow:; // see https://github.com/root-project/root/issues/9312 and https://github.com/root-project/root/issues/7604",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx:45,avoid,avoid,45,tree/dataframe/src/RDFUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx,1,['avoid'],['avoid']
Safety,"// Call ShowMember() on obj.; // This could be faster if we implemented this either as a templated; // function or by rootcint-generated code using the typeid (i.e. the; // difference is a lookup in a TList instead of in a map).; // To avoid a spurious error message in case the data member is; // transient and does not have a dictionary we check first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMemberInspector.cxx:236,avoid,avoid,236,core/base/src/TMemberInspector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMemberInspector.cxx,1,['avoid'],['avoid']
Safety,"// Call getAArch64ArchFeaturesFromMarch only if ""-Wa,-march="" or; // ""-Xassembler -march"" is detected. Otherwise it may return false; // and causes Clang to error out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/AArch64.cpp:93,detect,detected,93,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/AArch64.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/AArch64.cpp,1,['detect'],['detected']
Safety,"// Call recursively to avoid an extra check whether operand(1) is; // indeed an immediate (it could be a global address, for example),; // plus we can handle COPY at the same time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:23,avoid,avoid,23,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,1,['avoid'],['avoid']
Safety,"// Call sites inlined through a 'nounwind' call site should be; // 'nounwind' as well. However, avoid marking call sites explicitly; // where possible. This helps expose more opportunities for CSE after; // inlining, commonly when the callee is an intrinsic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:96,avoid,avoid,96,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['avoid'],['avoid']
Safety,// Call through a pointer to member function. This is safe to inline.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:54,safe,safe,54,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['safe'],['safe']
Safety,"// Caller (`X86InstrInfo::optimizeCompareInstr`) guarantees that; // `CmpValDefInstr` defines the value that's used by `CmpInstr`; in this case; // if `CmpValDefInstr` sets the EFLAGS, it is likely that `CmpInstr` is; // redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:221,redund,redundant,221,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['redund'],['redundant']
Safety,"// Callers should detect this case on their own: calling this function; // generally requires computing layout information, which is a waste of time; // if we've already emitted this block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:18,detect,detect,18,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,1,['detect'],['detect']
Safety,"// Calling Convention Implementation.; // The expectations for frontend ABI lowering vary from target to target.; // Ideally, an LLVM frontend would be able to avoid worrying about many ABI; // details, but this is a longer term goal. For now, we simply try to keep the; // role of the frontend as simple and well-defined as possible. The rules can; // be summarised as:; // * Never split up large scalar arguments. We handle them here.; // * If a hardfloat calling convention is being used, and the struct may be; // passed in a pair of registers (fp+fp, int+fp), and both registers are; // available, then pass as two separate arguments. If either the GPRs or FPRs; // are exhausted, then pass according to the rule below.; // * If a struct could never be passed in registers or directly in a stack; // slot (as it is larger than 2*XLEN and the floating point rules don't; // apply), then pass it using a pointer with the byval attribute.; // * If a struct is less than 2*XLEN, then coerce to either a two-element; // word-sized array or a 2*XLEN scalar (depending on alignment).; // * The frontend can determine whether a struct is returned by reference or; // not based on its size and fields. If it will be returned by reference, the; // frontend must modify the prototype so a pointer with the sret annotation is; // passed as the first argument. This is not necessary for large scalar; // returns.; // * Struct return values and varargs should be coerced to structs containing; // register-size fields in the same situations they would be for fixed; // arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:160,avoid,avoid,160,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Calling the base class implementation is unsafe because we override the; // GetDecl which it forwads to. That implementation depends on fIdx which is; // used to determine validity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodArgInfo.cxx:44,unsafe,unsafe,44,core/metacling/src/TClingMethodArgInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodArgInfo.cxx,1,['unsafe'],['unsafe']
Safety,"// Calls are scheduled in their preceding cycle, so don't conflict with; // hazards from instructions after the call. EmitNode will reset the; // scoreboard state before emitting the call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:76,hazard,hazards,76,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['hazard'],['hazards']
Safety,// Calls to fast_cc functions use different rules for passing parameters on; // the stack from the ABI and using PIC base in the function imposes; // similar restrictions to using the base pointer. It is not generally safe; // to move the stack pointer update in these situations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:218,safe,safe,218,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['safe'],['safe']
Safety,"// Can a (CMP op1, (sub 0, op2) be turned into a CMN instruction on; // the grounds that ""op1 - (-op2) == op1 + op2"" ? Not always, the C and V flags; // can be set differently by this operation. It comes down to whether; // ""SInt(~op2)+1 == SInt(~op2+1)"" (and the same for UInt). If they are then; // everything is fine. If not then the optimization is wrong. Thus general; // comparisons are only valid if op2 != 0.; //; // So, finally, the only LLVM-native comparisons that don't mention C and V; // are SETEQ and SETNE. They're the only ones we can safely use CMN for in; // the absence of information about op2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:552,safe,safely,552,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['safe'],['safely']
Safety,"// Can not read TFile.h here and avoid going through the interpreter by; // simply hard-coding this value.; // This **must** be equal to TFile::k630forwardCompatibility",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx:33,avoid,avoid,33,core/base/src/TObject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx,1,['avoid'],['avoid']
Safety,// Can safely ignore the predicate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:7,safe,safely,7,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,1,['safe'],['safely']
Safety,// Can vectorize safely without RT checks. All dependences are known to be; // safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:17,safe,safely,17,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,2,['safe'],"['safe', 'safely']"
Safety,"// Can we prove this instruction is safe to unconditionally execute?; // If not, we must use some form of predication.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:36,safe,safe,36,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['safe'],['safe']
Safety,"// Can we safely move 'From' to just before 'To'? To satisfy this, 'From' must; // not define a register that is used by any instructions, after and including,; // 'To'. These instructions also must not redefine any of Froms operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp:10,safe,safely,10,interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp,1,['safe'],['safely']
Safety,"// Can't handle indirect branch.; // In practice we should never have an undef eflags operand, if we do; // abort here as we are not prepared to preserve the flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:108,abort,abort,108,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['abort'],['abort']
Safety,"// Can't merge volatiles or load/stores that have a hint to avoid pair; // formation, for example.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:60,avoid,avoid,60,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['avoid'],['avoid']
Safety,"// Can't merge with self!; // It is not safe to merge these two switch instructions if they have a common; // successor, and if that successor has a PHI node, and if *that* PHI node has; // conflicting incoming values from the two switch blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:40,safe,safe,40,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['safe'],['safe']
Safety,"// Can't replace negative values with an LI as that will sign-extend; // and not clear the left bits. If we're setting the CR bit, we will use; // ANDI_rec which won't sign extend, so that's safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:191,safe,safe,191,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,2,['safe'],['safe']
Safety,"// Can't tell, just return false to be safe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:39,safe,safe,39,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['safe'],['safe']
Safety,"// Cancellation; // there are two types of TThread cancellation:; // DEFERRED - Cancellation only in user provided cancel-points; // ASYNCHRONOUS - In any point; // DEFERRED is more safe, it is DEFAULT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/TThread.h:182,safe,safe,182,core/thread/inc/TThread.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/TThread.h,1,['safe'],['safe']
Safety,"// Cannot apply fp modifiers to int literals preserving the same semantics; // for VOP1/2/C and VOP3 because of integer truncation. To avoid ambiguity,; // disable these cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:135,avoid,avoid,135,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,1,['avoid'],['avoid']
Safety,"// Cannot ask the user : abort any remote processing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:25,abort,abort,25,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['abort'],['abort']
Safety,"// Cannot safely mirror live intervals with PHI nodes, so check for these; // before optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMaskingPreRA.cpp:10,safe,safely,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMaskingPreRA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMaskingPreRA.cpp,1,['safe'],['safely']
Safety,// Cannot soundly sink instructions with side-effects.; // Terminator or phi instructions cannot be sunk.; // Avoid sinking other select instructions (should be handled separetely).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:110,Avoid,Avoid,110,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,1,['Avoid'],['Avoid']
Safety,// Cannot transform this parameter value.; // Check if there are any incompatible attributes we cannot drop safely.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:108,safe,safely,108,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['safe'],['safely']
Safety,"// Cannot use `UMUL_LOHI` directly, because some 32-bit targets (ARM) do not; // know how to expand `i64,i64 = umul_lohi a, b` and abort (why isn’t this; // operation recursively legalized?).; //; // Many backends understand this pattern and will convert into LOHI; // themselves, if applicable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:131,abort,abort,131,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['abort'],['abort']
Safety,// Cannot vectorize due to known unsafe dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:33,unsafe,unsafe,33,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['unsafe'],['unsafe']
Safety,"// Canonicalise concat_vectors to replace concatenations of truncated nots; // with nots of concatenated truncates. This in some cases allows for multiple; // redundant negations to be eliminated.; // (concat_vectors (v4i16 (truncate (not (v4i32)))),; // (v4i16 (truncate (not (v4i32))))); // ->; // (not (concat_vectors (v4i16 (truncate (v4i32))),; // (v4i16 (truncate (v4i32)))))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:159,redund,redundant,159,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['redund'],['redundant']
Safety,"// Canonicalize a signbit condition to use zero constant by swapping:; // (CmpLHS > -1) ? TV : FV --> (CmpLHS < 0) ? FV : TV; // To avoid conflicts (infinite loops) with other canonicalizations, this is; // not applied with any constant select arm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:132,avoid,avoid,132,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['avoid'],['avoid']
Safety,// Canonicalize src to a native path to avoid mixed separator styles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FileCollector.cpp:40,avoid,avoid,40,interpreter/llvm-project/llvm/lib/Support/FileCollector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FileCollector.cpp,1,['avoid'],['avoid']
Safety,// Canonicalize stack leaf to avoid 'random' IP from leaf frame skew LBR; // ranges,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp:30,avoid,avoid,30,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,1,['avoid'],['avoid']
Safety,"// Canonicalize toward having the constant on the RHS.; // TODO: Handle non-splat vector constants. All undef causes trouble.; // FIXME: We can't yet fold constant scalable vector splats, so avoid an; // infinite loop here when we encounter one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:191,avoid,avoid,191,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['avoid'],['avoid']
Safety,"// Canonicalizing a sign bit comparison that gets used in a branch,; // pessimizes codegen by generating branch on zero instruction instead; // of a test and branch. So we avoid canonicalizing in such situations; // because test and branch instruction has better branch displacement; // than compare and branch instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:172,avoid,avoid,172,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['avoid'],['avoid']
Safety,// Capture global firstprivates to avoid crash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:35,avoid,avoid,35,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['avoid'],['avoid']
Safety,// Capture the extracted value as a lambda argument to avoid potential issues; // with lifetime extension of the reference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:55,avoid,avoid,55,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['avoid'],['avoid']
Safety,"// CapturePred and others may have left the node in the pending queue, avoid; // adding it twice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:71,avoid,avoid,71,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avoid'],['avoid']
Safety,"// Capturing a 0 length array is a no-op, so we ignore it to get a more; // accurate analysis. If it's not ignored, it would set the default; // binding of the lambda to 'Unknown', which can lead to falsely detecting; // 'Uninitialized' values as 'Unknown' and not reporting a warning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:207,detect,detecting,207,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,1,['detect'],['detecting']
Safety,"// Case where the collection dictionary was not requested and; // the content's dictionary was also not requested.; // [This is a super set of what we need, but we can't really detect it :(]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:177,detect,detect,177,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['detect'],['detect']
Safety,"// Cases #1 (return statements) and #3.; //; // It is hard to detect that something is an assertion or came; // from assertion. Here we use a simple heuristic:; //; // - If it came from a macro, it can be an assertion.; //; // Additionally, we can't assume a number of basic blocks or the CFG's; // structure because assertions might include loops and conditions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:62,detect,detect,62,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,1,['detect'],['detect']
Safety,"// Cases, labels, and defaults aren't ""scope parents"". It's also; // important to handle these iteratively instead of recursively in; // order to avoid blowing out the stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/VarBypassDetector.cpp:146,avoid,avoid,146,interpreter/llvm-project/clang/lib/CodeGen/VarBypassDetector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/VarBypassDetector.cpp,2,['avoid'],['avoid']
Safety,"// Cast Index to the same type as the bitmap.; // Note: The Index is <= the number of elements in the table, so; // truncating it to the width of the bitmask is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:161,safe,safe,161,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['safe'],['safe']
Safety,"// Cast doubles to float before packing them; // TODO(gparolini): avoid this allocation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:66,avoid,avoid,66,tree/ntuple/v7/src/RColumnElement.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx,1,['avoid'],['avoid']
Safety,// Cast to the base class to avoid ambiguities.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:29,avoid,avoid,29,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['avoid'],['avoid']
Safety,"// Catch error condition: data present where zero events are predicted",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNLLVar.cxx:61,predict,predicted,61,roofit/roofitcore/src/RooNLLVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNLLVar.cxx,3,['predict'],['predicted']
Safety,// Catch trivial redundancies,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:17,redund,redundancies,17,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,2,['redund'],['redundancies']
Safety,// Catch trivial redundancies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:17,redund,redundancies,17,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['redund'],['redundancies']
Safety,"// Caution: this function is called by the AST reader during deserialization,; // so it cannot rely on AST invariants being met. Non-trivial accessors; // should be avoided, along with any traversal of redeclaration chains.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:165,avoid,avoided,165,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['avoid'],['avoided']
Safety,// Certain data sections we treat as named custom sections rather than; // segments within the data section.; // This could be avoided if all data segements (the wasm sense) were; // represented as their own sections (in the llvm sense).; // TODO(sbc): https://github.com/WebAssembly/tool-conventions/issues/138,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:127,avoid,avoided,127,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,1,['avoid'],['avoided']
Safety,// Chain detected. Skip this symbol for this round.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:9,detect,detected,9,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['detect'],['detected']
Safety,"// Chaining values within a given chunk (specifically the compress_in_place; // interface) are represented as words. This avoids unnecessary bytes<->words; // conversion overhead in the portable implementation. However, the hash_many; // interface handles both user input and parent node blocks, so it accepts; // bytes. For that reason, chaining values in the CV stack are represented as; // bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:122,avoid,avoids,122,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,1,['avoid'],['avoids']
Safety,"// Change select and PHI nodes to select values instead of addresses: this; // helps alias analysis out a lot, allows many others simplifications, and; // exposes redundancy in the code.; //; // Note that we cannot do the transformation unless we know that the; // introduced loads cannot trap! Something like this is valid as long as; // the condition is always false: load (select bool %C, int* null, int* %G),; // but it would not be valid if we transformed it to load from null; // unconditionally.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:163,redund,redundancy,163,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['redund'],['redundancy']
Safety,"// Change the -release to ""receiver = nil"" in a finally to avoid a leak; // when an exception is thrown.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp:59,avoid,avoid,59,interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp,1,['avoid'],['avoid']
Safety,// Change the insert point to avoid emitting the fall-back call after the; // bitcast.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:30,avoid,avoid,30,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['avoid'],['avoid']
Safety,"// Character types are special and can alias anything.; // In C++, this technically only includes ""char"" and ""unsigned char"",; // and not ""signed char"". In C, it includes all three. For now,; // the risk of exploiting this detail in C++ seems likely to outweigh; // the benefit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp:199,risk,risk,199,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp,1,['risk'],['risk']
Safety,"// Check Load, Store, GEP, and BitCast Uses on alloca and make them; // use the converted generic address, in order to expose non-generic; // addrspacecast to NVPTXInferAddressSpaces. For other types; // of instructions this is unnecessary and may introduce redundant; // address cast.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp:258,redund,redundant,258,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAlloca.cpp,1,['redund'],['redundant']
Safety,"// Check RF work dir - aborts if it fails",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleFitAPI.h:23,abort,aborts,23,tmva/tmva/inc/TMVA/RuleFitAPI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleFitAPI.h,1,['abort'],['aborts']
Safety,"// Check all use of User node. If all of them are safe, optimize; // truncate to extract_subreg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:50,safe,safe,50,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,1,['safe'],['safe']
Safety,"// Check all use of selections, bit operations, and copies. If all of them; // are safe, optimize truncate to extract_subreg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:83,safe,safe,83,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,1,['safe'],['safe']
Safety,// Check bundled MachineInstr's for hazards.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:36,hazard,hazards,36,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazards']
Safety,// Check code object version options. Emit warnings for legacy options; // and errors for the last invalid code object version options.; // It is done here to avoid repeated warning or error messages for; // each tool invocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp:159,avoid,avoid,159,interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp,1,['avoid'],['avoid']
Safety,// Check consitency of records. Return true if an error has been detected.; // Return false if the records are valid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DirectiveEmitter.cpp:65,detect,detected,65,interpreter/llvm-project/llvm/utils/TableGen/DirectiveEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DirectiveEmitter.cpp,1,['detect'],['detected']
Safety,"// Check for ""<::"" which is parsed as ""[:"". If found, fix token stream,; // diagnose error, suggest fix, and recover parsing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:109,recover,recover,109,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['recover'],['recover']
Safety,// Check for SI_KILL_*_TERMINATOR on path from if to endif.; // if there is any such terminator simplifications are not safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp:120,safe,safe,120,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,1,['safe'],['safe']
Safety,// Check for [us]0x[0-9A-Fa-f]+ which are Hexadecimal constant generated by; // the CFE to avoid forcing it to deal with 64-bit numbers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:91,avoid,avoid,91,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,1,['avoid'],['avoid']
Safety,// Check for a complete definition and recover if not so.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:39,recover,recover,39,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,4,['recover'],['recover']
Safety,"// Check for a null receiver and, if there is one, jump to the; // null-receiver block. There's no point in trying to avoid it:; // we're always going to put *something* there, because otherwise; // we shouldn't have done this null-check in the first place.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:118,avoid,avoid,118,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['avoid'],['avoid']
Safety,// Check for a sequence of stores to the same base address. We don't need to; // precisely determine whether a store pair can be formed. But we do want to; // filter out most situations where we can't form store pairs to avoid; // computing trace metrics in those cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StorePairSuppress.cpp:221,avoid,avoid,221,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StorePairSuppress.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StorePairSuppress.cpp,1,['avoid'],['avoid']
Safety,"// Check for an indirect call or branch that may need its input hardened; // even if we couldn't find the specific load used, or were able to; // avoid hardening it for some reason. Note that here we cannot break; // out afterward as we may still need to handle any call aspect of this; // instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:146,avoid,avoid,146,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['avoid'],['avoid']
Safety,"// Check for circular inclusion of the main file.; // We can't generate a consistent preamble with regard to the conditional; // stack if the main file is included again as due to the preamble bounds; // some directives (e.g. #endif of a header guard) will never be seen.; // Since this will lead to confusing errors, avoid the inclusion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:318,avoid,avoid,318,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['avoid'],['avoid']
Safety,// Check for dead BasicBlocks in every function.; // We need dead instruction detection because we do not want to deal with; // broken IR in which SSA rules do not apply.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:78,detect,detection,78,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['detect'],['detection']
Safety,// Check for each StmtSequence if its successor has the same hash value.; // We don't check the last StmtSequence as it has no successor.; // Note: The 'size - 1 ' in the condition is safe because we check for an; // empty Group vector at the beginning of this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:184,safe,safe,184,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,1,['safe'],['safe']
Safety,// Check for either a dependence (latency) or resource (hazard) stall.; //; // Note: The ScheduleHazardRecognizer interface requires a non-const SU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:56,hazard,hazard,56,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['hazard'],['hazard']
Safety,// Check for hazard,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:13,hazard,hazard,13,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,"// Check for interlocks first. For the purpose of other heuristics, an; // instruction that cannot issue appears as if it's not in the ReadyQueue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:13,interlock,interlocks,13,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['interlock'],['interlocks']
Safety,"// Check for kills that appear after the terminator instruction, that; // would not be detected by clearKillFlags, since they will cause the; // register to be dead at a later place, causing the verifier to fail.; // We use the candidates to clear the kill flags later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMasking.cpp:87,detect,detected,87,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMasking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMasking.cpp,1,['detect'],['detected']
Safety,// Check for physical registers on the instructions first to avoid cases; // like this:; //; // %a = COPY $physreg; // ...; // SOMETHING implicit-def $physreg; // ...; // %b = COPY $physreg; //; // These copies are not equivalent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:61,avoid,avoid,61,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['avoid'],['avoid']
Safety,// Check for redundancy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/Record.cpp:13,redund,redundancy,13,interpreter/llvm-project/llvm/lib/TableGen/Record.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/Record.cpp,1,['redund'],['redundancy']
Safety,// Check for redundant/conflicting ownership qualifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:13,redund,redundant,13,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['redund'],['redundant']
Safety,"// Check for safe conditions to execute memmove.; // If stride is positive, copying things from higher to lower addresses; // is equivalent to memmove. For negative stride, it's the other way; // around. Copying forward in memory with positive stride may not be; // same as memmove since we may be copying values that we just stored; // in some previous iteration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:13,safe,safe,13,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,1,['safe'],['safe']
Safety,"// Check for some cases that are worth simplifying. Right now we want to look; // for loads that are used by a switch or by the condition for the branch. If; // we see one, check to see if it's partially redundant. If so, insert a PHI; // which can then be used to thread the values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:204,redund,redundant,204,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['redund'],['redundant']
Safety,"// Check for the default ""clang"" invocation that won't set any cl::opt values.; // Skip trying to parse the command line invocation to avoid the issues; // described below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:135,avoid,avoid,135,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,1,['avoid'],['avoid']
Safety,"// Check for the fully redundant, dominating load case. In this case, we can; // just use the dominating value directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:23,redund,redundant,23,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['redund'],['redundant']
Safety,// Check for the trivial case here to avoid having to check for it in the; // rest of the code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp:38,avoid,avoid,38,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp,1,['avoid'],['avoid']
Safety,// Check for thread safety violations,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:20,safe,safety,20,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['safe'],['safety']
Safety,// Check for unsafe hoistings due to side effects.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:13,unsafe,unsafe,13,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['unsafe'],['unsafe']
Safety,// Check for uses of the argument again so that we can avoid exporting ArgVal; // if it is't used by anything other than the store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:55,avoid,avoid,55,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['avoid'],['avoid']
Safety,// Check formatting specifiers. NOTE: We're only doing this for the non-size; // call to avoid duplicate diagnostics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:89,avoid,avoid,89,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['avoid'],['avoid']
Safety,// Check function call safety,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:23,safe,safety,23,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,1,['safe'],['safety']
Safety,"// Check getSplatValue early in this function, to avoid doing unnecessary; // work.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:50,avoid,avoid,50,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['avoid'],['avoid']
Safety,// Check if MI has any non-dead defs or physreg uses. This also detects; // predicated instructions which will be reading CPSR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:64,detect,detects,64,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['detect'],['detects']
Safety,// Check if MI has any non-dead defs or physreg uses. This also detects; // predicated instructions which will be reading SR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:64,detect,detects,64,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,1,['detect'],['detects']
Safety,// Check if ObjC container adds ivars after variable sized ivar in superclass.; // Perform the check only if OCD is the first container to declare ivars to; // avoid multiple warnings for the same ivar.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:160,avoid,avoid,160,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['avoid'],['avoid']
Safety,// Check if RecordDecl is in FunctionDecl parameters to avoid infinite loop.; // example: int struct_in_proto(struct data_t{int a;int b;} *d);; // FIXME: We could support these constructs by importing a different type of; // this parameter and by importing the original type of the parameter only; // after the FunctionDecl is created. See; // VisitFunctionDecl::UsedDifferentProtoType.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:56,avoid,avoid,56,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['avoid'],['avoid']
Safety,// Check if SI that may alias with MemLoc can be safely skipped. This is; // possible in case if SI can only must alias or no alias with MemLoc (no; // partial overlapping possible) and it writes the same value that MemLoc; // contains now (it was loaded before this store and was not modified in; // between).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:49,safe,safely,49,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['safe'],['safely']
Safety,"// Check if a Thumb1 LDM/STM merge is safe. This is the case if:; // - There is no writeback (LDM of base register),; // - the base register is killed by the merged instruction,; // - or it's safe to overwrite the condition flags, i.e. to insert a SUBS; // to reset the base register.; // Otherwise, don't merge.; // It's safe to return here since the code to materialize a new base register; // above is also conditional on SafeToClobberCPSR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:38,safe,safe,38,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,4,"['Safe', 'safe']","['SafeToClobberCPSR', 'safe']"
Safety,// Check if a given Phi node can be recognized as an ordered reduction for; // vectorizing floating point operations without unsafe math.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:125,unsafe,unsafe,125,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,1,['unsafe'],['unsafe']
Safety,"// Check if a given register has bits that are references to any other; // registers. This is to detect situations where the instruction that; // defines register R takes register Q as an operand, but R itself does; // not contain any bits from Q. Loads are examples of how this could; // happen:; // R = load Q; // In this case (assuming we do not have any knowledge about the loaded; // value), we must not treat R as a ""conveyance"" of the bits from Q.; // (The information in BT about R's bits would have them as constants,; // in case of zero-extending loads, or refs to R.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:97,detect,detect,97,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,1,['detect'],['detect']
Safety,"// Check if all entries have the NoUnwind attribute.; // If all entries have it, we can safely mark the; // cfi.jumptable as NoUnwind, otherwise, direct calls; // to the jump table will not handle exceptions properly",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:88,safe,safely,88,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,1,['safe'],['safely']
Safety,"// Check if all the requirements can be satisfied for the given subtarget, and; // if not abort compilation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:90,abort,abort,90,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,1,['abort'],['abort']
Safety,"// Check if any of the odd lanes in the v16i8 are used. If not, we can mask; // them out and avoid using UNPCK{L,H} to extract the elements of V as; // i16s.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:93,avoid,avoid,93,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Check if any of the successors of TailBB has a PHI node in which the; // value corresponding to TailBB uses a subregister.; // If a phi node uses a register paired with a subregister, the actual; // ""value type"" of the phi may differ from the type of the register without; // any subregisters. Due to a bug, tail duplication may add a new operand; // without a necessary subregister, producing an invalid code. This is; // demonstrated by test/CodeGen/Hexagon/tail-dup-subreg-abort.ll.; // Disable tail duplication for this case for now, until the problem is; // fixed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:479,abort,abort,479,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,1,['abort'],['abort']
Safety,// Check if coalescing seems safe by finding the set of clobbered physreg; // pairs in the region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp:29,safe,safe,29,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZRegisterInfo.cpp,1,['safe'],['safe']
Safety,// Check if each of the unsafe registers are available...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:24,unsafe,unsafe,24,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['unsafe'],['unsafe']
Safety,"// Check if it is safe to hoist values tracked by CHI in the range; // [Begin, End) and accumulate them in Safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:18,safe,safe,18,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,2,"['Safe', 'safe']","['Safe', 'safe']"
Safety,// Check if it is safe to move LoadI next to the SI.; // Conservatively assume it is safe only if there is no instruction; // modifying memory in-between the load and the select instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:18,safe,safe,18,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,2,['safe'],['safe']
Safety,// Check if it is safe to swap operand of two GEP.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:18,safe,safe,18,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,1,['safe'],['safe']
Safety,"// Check if it's a proto: must have (); // This might not be too safe to use :(",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TTabCom.cxx:65,safe,safe,65,core/rint/src/TTabCom.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TTabCom.cxx,1,['safe'],['safe']
Safety,"// Check if it's safe to fold the load. If the size of the object is; // narrower than the load width, then it's not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:17,safe,safe,17,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['safe'],['safe']
Safety,"// Check if it's safe to fold the load. If the size of the object is; // narrower than the load width, then it's not.; // FIXME: Allow scalar intrinsic instructions like ADDSSrm_Int.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:17,safe,safe,17,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['safe'],['safe']
Safety,// Check if it's safe to move the instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:17,safe,safe,17,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,4,['safe'],['safe']
Safety,// Check if it's safe to move the load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:17,safe,safe,17,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['safe'],['safe']
Safety,"// Check if it's safe to remove the instruction due to side effects.; // We can, and want to, remove Phis here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:17,safe,safe,17,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['safe'],['safe']
Safety,// Check if it's safe to replace registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp:17,safe,safe,17,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp,1,['safe'],['safe']
Safety,"// Check if no need to reorder operands since they're are perfect or; // shuffled diamond match.; // Need to do it to avoid extra external use cost counting for; // shuffled matches, which may cause regressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:118,avoid,avoid,118,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,"// Check if string contains quotes. On Windows, file names cannot contain quotes.; // We do not accept them however to avoid hard-to-debug problems.; // A quote in user input would end the parameter quote and so break the command invocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs:119,avoid,avoid,119,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/ClangFormatPackage.cs,1,['avoid'],['avoid']
Safety,// Check if the Case Range is perfectly squeezed in between; // already checked Upper and Lower bounds. If it is then we can avoid; // emitting the code that checks if the value actually falls in the range; // because the bounds already tell us so.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:125,avoid,avoid,125,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,1,['avoid'],['avoid']
Safety,"// Check if the EFLAGS register is marked as live-out. This shouldn't happen,; // because the calling convention defines the EFLAGS register as NOT; // preserved.; //; // Unfortunatelly the EFLAGS show up as live-out after branch folding. Adding; // an assert to track this and clear the register afterwards to avoid; // unnecessary crashes during release builds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp:311,avoid,avoid,311,interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp,1,['avoid'],['avoid']
Safety,// Check if the Mul source can be safely shrunk.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,safe,safely,34,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['safe'],['safely']
Safety,// Check if the array size will overflow.; // Size overflow check does not work with symbolic expressions because a; // overflow situation can not be detected easily.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp:150,detect,detected,150,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,1,['detect'],['detected']
Safety,// Check if the constant operand can be safely incremented/decremented; // without overflowing/underflowing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:40,safe,safely,40,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['safe'],['safely']
Safety,"// Check if the extra components of the expressions in the enclosing; // data environment are redundant for the current base declaration.; // If they are, the maps completely overlap, which is legal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:94,redund,redundant,94,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['redund'],['redundant']
Safety,"// Check if the given instruction has observable side-effects, i.e. if; // it should be considered ""live"". It is safe for this function to be; // overly conservative (i.e. return ""true"" for all instructions), but it; // is not safe to return ""false"" for an instruction that should not be; // considered removable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp:113,safe,safe,113,interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.cpp,2,['safe'],['safe']
Safety,"// Check if the instructions in Insts, together with their dependencies; // cover the loop in the sense that the loop could be safely eliminated once; // the instructions in Insts are removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:127,safe,safely,127,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,1,['safe'],['safely']
Safety,// Check if the load can safely be moved to all the unavailable predecessors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:25,safe,safely,25,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['safe'],['safely']
Safety,// Check if the name needs quotes to be safe for the linker to interpret.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Mangler.cpp:40,safe,safe,40,interpreter/llvm-project/llvm/lib/IR/Mangler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Mangler.cpp,1,['safe'],['safe']
Safety,// Check if the necessary condition for the hazard is met: both LDS and VMEM; // instructions need to appear in the same function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:44,hazard,hazard,44,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,// Check if the new instruction is redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:35,redund,redundant,35,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['redund'],['redundant']
Safety,// Check if the preheader candidate is a successor of any other loop; // headers. We want to avoid having two loop setups in the same block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp:93,avoid,avoid,93,interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLoopInfo.cpp,1,['avoid'],['avoid']
Safety,"// Check if the profile summary indicates that the profiled application; // has a huge working set size, in which case we disable peeling to avoid; // bloating it further.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:141,avoid,avoid,141,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['avoid'],['avoid']
Safety,"// Check if the target supports potentially unsafe FP vectorization.; // FIXME: Add a check for the type of safety issue (denormal, signaling); // for the target we're vectorizing for, to make sure none of the; // additional fp-math flags can help.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:44,unsafe,unsafe,44,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,"['safe', 'unsafe']","['safety', 'unsafe']"
Safety,"// Check if there are any stores, calls, etc. between any of the loads. If; // there are, then we can't safely perform the combine.; //; // MaxIter is chosen based off the (worst case) number of iterations it; // typically takes to succeed in the LLVM test suite plus some padding.; //; // FIXME: Is there a better way to check for load fold barriers?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:104,safe,safely,104,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['safe'],['safely']
Safety,"// Check if this actually represents a binned dataset, and then import it; // like a RooDataHist. This happens frequently when people create combined; // RooDataSets from binned data to fit HistFactory models. In this case, it; // doesn't make sense to export them like an unbinned dataset, because the; // coordinates are redundant information with the binning. We only do this; // for 1D data for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/RooJSONFactoryWSTool.cxx:323,redund,redundant,323,roofit/hs3/src/RooJSONFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/RooJSONFactoryWSTool.cxx,1,['redund'],['redundant']
Safety,"// Check if this decl was interesting to the consumer. If we just loaded; // the declaration, then we know it was interesting and we skip the call; // to isConsumerInterestedIn because it is unsafe to call in the; // current ASTReader state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:191,unsafe,unsafe,191,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['unsafe'],['unsafe']
Safety,"// Check if this instruction has a dependence on the critical path that; // is an anti-dependence that we may be able to break. If it is, set; // AntiDepReg to the non-zero register associated with the anti-dependence.; //; // We limit our attention to the critical path as a heuristic to avoid; // breaking anti-dependence edges that aren't going to significantly; // impact the overall schedule. There are a limited number of registers; // and we want to save them for the important edges.; //; // TODO: Instructions with multiple defs could have multiple; // anti-dependencies. The current code here only knows how to break one; // edge per instruction. Note that we'd have to be able to break all of; // the anti-dependencies in an instruction in order to be effective.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:289,avoid,avoid,289,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,1,['avoid'],['avoid']
Safety,// Check if this is an operand modifier or an opcode modifier; // which may look like an expression but it is not. We should; // avoid parsing these modifiers as expressions. Currently; // recognized sequences are:; // |...|; // abs(...); // neg(...); // sext(...); // -reg; // -|...|; // -abs(...); // name:...; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:129,avoid,avoid,129,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,1,['avoid'],['avoid']
Safety,// Check if this load/store has a hint to avoid pair formation.; // MachineMemOperands hints are set by the AArch64StorePairSuppress pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:42,avoid,avoid,42,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['avoid'],['avoid']
Safety,// Check if users allow reordering.; // Currently look up just 1 level of operands to avoid increase of; // the compile time.; // Profitable to reorder if definitely more operands allow; // reordering rather than those with natural order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:86,avoid,avoid,86,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,// Check if we already have visited this cast instruction before to avoid; // unnecessary cloning.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:68,avoid,avoid,68,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,1,['avoid'],['avoid']
Safety,"// Check if we are coping with an array... then expand; // The array operator used is {}. It is detected in TNeuron, and; // passed directly as instance index of the TTreeFormula,; // so that complex compounds made of arrays can be used without; // parsing the details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMultiLayerPerceptron.cxx:96,detect,detected,96,math/mlp/src/TMultiLayerPerceptron.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMultiLayerPerceptron.cxx,1,['detect'],['detected']
Safety,// Check if we can avoid allocating by storing a single reference directly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:19,avoid,avoid,19,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['avoid'],['avoid']
Safety,"// Check if we can detect an AVG pattern from the truncation. If yes,; // replace the trunc store by a normal store with the result of X86ISD::AVG; // instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:19,detect,detect,19,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['detect'],['detect']
Safety,// Check if we can move the stack update instruction (stdu) down the prologue; // past the callee saves. Hopefully this will avoid the situation where the; // saves are waiting for the update on the store with update to complete.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:125,avoid,avoid,125,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['avoid'],['avoid']
Safety,"// Check if we can safely insert a subvector. If it is not possible, just; // generate a whole-sized vector and shuffle the source vector and the new; // subvector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,safe,safely,19,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['safe'],['safely']
Safety,// Check if we can safely rename this Comdat function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp:19,safe,safely,19,interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,2,['safe'],['safely']
Safety,// Check if we can widen the induction variables to avoid overflow checks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:52,avoid,avoid,52,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,1,['avoid'],['avoid']
Safety,"// Check if we have a cached safety value from parallel world, and if this can still be used.; // Return negative value if no cache available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h:29,safe,safety,29,geom/geom/inc/TGeoNavigator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h,1,['safe'],['safety']
Safety,"// Check if we have registered the unqualified name into the list; // of TClass that are in kNoInfo, kEmulated or kFwdDeclaredState.; // Since this is used as heureutistic to avoid spurrious calls to GetNormalizedName; // the unqualified name is sufficient (and the fully qualified name might be; // 'wrong' if there is difference in spelling in the template paramters (for example)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:175,avoid,avoid,175,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['avoid'],['avoid']
Safety,"// Check if we have the wide qualifier, because if it's present we; // must avoid selecting a 16-bit thumb instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:76,avoid,avoid,76,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['avoid'],['avoid']
Safety,// Check if we should avoid folding this immediate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:22,avoid,avoid,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,// Check isSafeToPrune() here rather than in shouldExplore() to avoid; // an expensive reachability query for every instruction we look at.; // Instead we only do one for actual capturing candidates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:64,avoid,avoid,64,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,1,['avoid'],['avoid']
Safety,"// Check isSuccessor to avoid case where the next block is empty, but; // it's not a successor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:24,avoid,avoid,24,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,1,['avoid'],['avoid']
Safety,"// Check it's really safe to treat that pair of `ptrtoint`/`inttoptr` as a; // no-op cast. Besides checking both of them are no-op casts, as the; // reinterpreted pointer may be used in other pointer arithmetic, we also; // need to double-check that through the target-specific hook. That ensures; // the underlying target also agrees that's a no-op address space cast and; // pointer bits are preserved.; // The current IR spec doesn't have clear rules on address space casts,; // especially a clear definition for pointer bits in non-default address; // spaces. It would be undefined if that pointer is dereferenced after an; // invalid reinterpret cast. Also, due to the unclearness for the meaning of; // bits in non-default address spaces in the current spec, the pointer; // arithmetic may also be undefined after invalid pointer reinterpret cast.; // However, as we confirm through the target hooks that it's a no-op; // addrspacecast, it doesn't matter since the bits should be the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:21,safe,safe,21,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,1,['safe'],['safe']
Safety,"// Check safety for current segment",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPcon.cxx:9,safe,safety,9,geom/geom/src/TGeoPcon.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPcon.cxx,4,['safe'],['safety']
Safety,"// Check safety of replacing the scalar load with a larger vector load.; // We use minimal alignment (maximum flexibility) because we only care about; // the dereferenceable region. When calculating cost and creating a new op,; // we may use a larger value based on alignment attributes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:9,safe,safety,9,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['safe'],['safety']
Safety,"// Check that a call to a target specific builtin has the correct target; // features.; // This is down here to avoid non-target specific builtins, however, if; // generic builtins start to require generic target features then we; // can move this up to the beginning of the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:112,avoid,avoid,112,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['avoid'],['avoid']
Safety,// Check that both shuffles use the same mask. The masks are known to be of; // the same length because the result vector type is the same.; // Check also that shuffles have only one use to avoid introducing extra; // instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:190,avoid,avoid,190,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,// Check that register source operand is not clobbered before MI.; // Immediate operands are always safe to propagate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:100,safe,safe,100,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['safe'],['safe']
Safety,"// Check that sinking the store won't cause program behavior changes. Sinking; // the store out of the Q blocks won't change any behavior as we're sinking; // from a block to its unconditional successor. But we're moving a store from; // the P blocks down through the middle block (QBI) and past both QFB and QTB.; // So we need to check that there are no aliasing loads or stores in; // QBI, QTB and QFB. We also need to check there are no conflicting memory; // operations between PStore and the end of its parent block.; //; // The ideal way to do this is to query AliasAnalysis, but we don't; // preserve AA currently so that is dangerous. Be super safe and just; // check there are no other memory operations at all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:653,safe,safe,653,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['safe'],['safe']
Safety,"// Check that the add is independent of the load/store. Otherwise, folding; // it would create a cycle. We can avoid searching through Addr as it's a; // predecessor to both.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:111,avoid,avoid,111,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Check that the register is marked 'renamable' so we know it is safe to; // rename it without violating any constraints that aren't expressed in the; // IR (e.g. ABI or opcode requirements).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:66,safe,safe,66,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,1,['safe'],['safe']
Safety,"// Check that the select condition doesn't reach either load. If so,; // folding this will induce a cycle into the DAG. If not, this is safe to; // xform, so create a select of the addresses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:136,safe,safe,136,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['safe'],['safe']
Safety,// Check the action and ordering of the interlocked intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:40,interlock,interlocked,40,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['interlock'],['interlocked']
Safety,// Check the code surrounding the inner loop for instructions that are deemed; // unsafe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp:82,unsafe,unsafe,82,interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp,2,['unsafe'],['unsafe']
Safety,// Check the loop safety info for exceptions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:18,safe,safety,18,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,1,['safe'],['safety']
Safety,"// Check the model, avoid simplifying AST to save time",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConstraintManager.h:20,avoid,avoid,20,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConstraintManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConstraintManager.h,1,['avoid'],['avoid']
Safety,// Check the properties of the dividend. It must not be zero to avoid a; // division by zero (see Proof).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:64,avoid,avoid,64,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['avoid'],['avoid']
Safety,// Check the safety of assignment from LHS to RHS,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:13,safe,safety,13,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['safe'],['safety']
Safety,"// Check there is other extract_high with same source vector.; // For example,; //; // t18: v4i16 = extract_subvector t2, Constant:i64<0>; // t12: v4i16 = truncate t11; // t31: v4i32 = AArch64ISD::SMULL t18, t12; // t23: v4i16 = extract_subvector t2, Constant:i64<4>; // t16: v4i16 = truncate t15; // t30: v4i32 = AArch64ISD::SMULL t23, t1; //; // This dagcombine assumes the two extract_high uses same source vector in; // order to detect the pair of the mull. If they have different source vector,; // this code will not work.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:433,detect,detect,433,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['detect'],['detect']
Safety,"// Check this case first, to avoid the swap all-together.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalExecutor.cpp:29,avoid,avoid,29,interpreter/cling/lib/Interpreter/IncrementalExecutor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalExecutor.cpp,1,['avoid'],['avoid']
Safety,"// Check to see if merging these blocks/phis would cause conflicts for any of; // the phi nodes in BB or Succ. If not, we can safely merge.; // Check for cases where Succ has multiple predecessors and a PHI node in BB; // has uses which will not disappear when the PHI nodes are merged. It is; // possible to handle such cases, but difficult: it requires checking whether; // BB dominates Succ, which is non-trivial to calculate in the case where; // Succ has multiple predecessors. Also, it requires checking whether; // constructing the necessary self-referential PHI node doesn't introduce any; // conflicts; this isn't too difficult, but the previous code for doing this; // was incorrect.; //; // Note that if this check finds a live use, BB dominates Succ, so BB is; // something like a loop pre-header (or rarely, a part of an irreducible CFG);; // folding the branch isn't profitable in that case anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:126,safe,safely,126,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['safe'],['safely']
Safety,"// Check to see if we created any new functions. If not, no loops were; // extracted and we should return null. Limit the number of loops we extract; // to avoid taking forever.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:156,avoid,avoid,156,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,1,['avoid'],['avoid']
Safety,// Check viable function only to avoid unnecessary data copying/moving.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:33,avoid,avoid,33,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['avoid'],['avoid']
Safety,"// Check whether C compares a floating-point value with zero and if that; // floating-point value is also negated. In this case we can use the; // negation to set CC, so avoiding separate LOAD AND TEST and; // LOAD (NEGATIVE/COMPLEMENT) instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:170,avoid,avoiding,170,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['avoid'],['avoiding']
Safety,// Check whether CmpInstr can be made redundant by the current instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:38,redund,redundant,38,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,3,['redund'],['redundant']
Safety,"// Check whether MI uses a vector length operand. If so, we prepare for VL; // register. We would like to reuse VL register as much as possible. We; // also would like to keep the number of LEA instructions as fewer as; // possible. Therefore, we use a regular scalar register to hold immediate; // values to load VL register. And try to reuse identical scalar registers; // to avoid new LVLr instructions as much as possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/LVLGen.cpp:378,avoid,avoid,378,interpreter/llvm-project/llvm/lib/Target/VE/LVLGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/LVLGen.cpp,1,['avoid'],['avoid']
Safety,// Check whether \param SecondEntryBlock has side-effect and is safe to; // speculate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:64,safe,safe,64,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,1,['safe'],['safe']
Safety,"// Check whether folding this offset is legal. It must not go out of bounds of; // the referenced object to avoid violating the code model, and must be; // smaller than 2^20 because this is the largest offset expressible in all; // object formats. (The IMAGE_REL_ARM64_PAGEBASE_REL21 relocation in COFF; // stores an immediate signed 21 bit offset.); //; // This check also prevents us from folding negative offsets, which will end; // up being treated in the same way as large positive ones. They could also; // cause code model violations, and aren't really common enough to matter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:108,avoid,avoid,108,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['avoid'],['avoid']
Safety,"// Check whether it is semantically safe Src and Dst considering any potential; // dependency between them.; //; // @param UnrollLevel The level of the loop being unrolled; // @param JamLevel The level of the loop being jammed; if Src and Dst are on; // different levels, the outermost common loop counts as jammed level; //; // @return true if is safe and false if there is a dependency violation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:36,safe,safe,36,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,2,['safe'],['safe']
Safety,// Check whether it would be safe to inline this dllimport function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:29,safe,safe,29,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['safe'],['safe']
Safety,"// Check whether the previous packet is in a different loop. If this is the; // case, there is little point in trying to avoid a stall because that would; // favor the rare case (loop entry) over the common case (loop iteration).; //; // TODO: We should really be able to check all the incoming edges if this is; // the first packet in a basic block, so we can avoid stalls from the loop; // backedge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:121,avoid,avoid,121,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,2,['avoid'],['avoid']
Safety,// Check whether the profiled binary was built with position independent code; // (PIC). Perform sanity checks for assumptions we rely on to simplify; // symbolization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp:97,sanity check,sanity checks,97,interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,1,['sanity check'],['sanity checks']
Safety,// Check whether there's not a write between the two loads which would; // prevent them from being safely merged.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:99,safe,safely,99,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,1,['safe'],['safely']
Safety,"// Check whether this might be a C++ implicit instance member access.; // C++ [class.mfct.non-static]p3:; // When an id-expression that is not part of a class member access; // syntax and not used to form a pointer to member is used in the; // body of a non-static member function of class X, if name lookup; // resolves the name in the id-expression to a non-static non-type; // member of some class C, the id-expression is transformed into a; // class member access expression using (*this) as the; // postfix-expression to the left of the . operator.; //; // But we don't actually need to do this for '&' operands if R; // resolved to a function or overloaded function set, because the; // expression is ill-formed if it actually works out to be a; // non-static member function:; //; // C++ [expr.ref]p4:; // Otherwise, if E1.E2 refers to a non-static member function. . .; // [t]he expression can be used only as the left-hand operand of a; // member function call.; //; // There are other safeguards against such uses, but it's important; // to get this right here so that we don't end up making a; // spuriously dependent expression if we're inside a dependent; // instance method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:995,safe,safeguards,995,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['safe'],['safeguards']
Safety,"// Check which instruction is first in the block so we don't break def-use; // deps by ""moving"" the instruction incorrectly. Also keep track of which; // instruction is first so we pick it's operands, avoiding use-before-def; // bugs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:201,avoid,avoiding,201,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['avoid'],['avoiding']
Safety,// Check with isOperationFoldable() first to avoid linearly iterating; // over the operands unnecessarily which can be expensive for; // instructions with many operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:45,avoid,avoid,45,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['avoid'],['avoid']
Safety,"// CheckVariableDeclaration will set NewVD as invalid if something is in; // error like WebAssembly tables being declared as arrays with a non-zero; // size, but then parsing continues and emits further errors on that line.; // To avoid that we check here if it happened and return nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:231,avoid,avoid,231,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avoid'],['avoid']
Safety,// Checks if the current node (N) is used by any SELECT instruction and; // returns an empty SDValue to avoid applying the optimization to prevent; // incorrect results,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:104,avoid,avoid,104,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Choose better solution for the current VF, Note that Invalid; // costs compare as maximumal large. If both are invalid, we get; // scalable invalid which signals a failure and a vectorization abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:195,abort,abort,195,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['abort'],['abort']
Safety,"// Choose the minimum alignment. If we could prove both stores execute, we; // could use biggest one. In this case, though, we only know that one of the; // stores executes. And we don't know it's safe to take the alignment from a; // store that doesn't execute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:197,safe,safe,197,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['safe'],['safe']
Safety,// Chrome trace event format always wants data in micros.; // CyclesPerMicro = CycleHertz / 10^6; // TSC / CyclesPerMicro == TSC * 10^6 / CycleHertz == MicroTimestamp; // Could lose some precision here by converting the TSC to a double to; // multiply by the period in micros. 52 bit mantissa is a good start though.; // TODO: Make feature request to Chrome Trace viewer to accept ticks and a; // frequency or do some more involved calculation to avoid dangers of; // conversion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-converter.cpp:447,avoid,avoid,447,interpreter/llvm-project/llvm/tools/llvm-xray/xray-converter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-converter.cpp,1,['avoid'],['avoid']
Safety,// Circumvent ICE checking in C++11 to avoid evaluating the expression twice; // in the non-ICE case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:39,avoid,avoid,39,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['avoid'],['avoid']
Safety,// Claim `-fmodule-output` and `-fmodule-output=` to avoid unused warnings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:53,avoid,avoid,53,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['avoid'],['avoid']
Safety,// Claim here to avoid the more general unused warning.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:17,avoid,avoid,17,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['avoid'],['avoid']
Safety,"// Clamping after deleting to avoid corruption",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx:30,avoid,avoid,30,core/base/src/TString.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx,1,['avoid'],['avoid']
Safety,// Clang AST consumers assume a DeclRefExpr refers to a valid decl. We; // wrap a DeclRefExpr referring to an invalid decl with a dependent-type; // RecoveryExpr to avoid follow-up semantic analysis (thus prevent bogus; // diagnostics).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:149,Recover,RecoveryExpr,149,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,"['Recover', 'avoid']","['RecoveryExpr', 'avoid']"
Safety,"// Class extensions have no name as a category, and it's possible; // for them to be the semantic parent of certain declarations; // (primarily, tag decls defined within declarations). Such; // declarations will always have internal linkage, so the name; // doesn't really matter, but we shouldn't crash on them. For; // safety, just handle all ObjC containers here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:321,safe,safety,321,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['safe'],['safety']
Safety,// Class for less-than inequality comparason for the set `RedundantTokens`.; // We store tokens in the order they appear in the translation unit so that; // we do not need to sort them in `generateFixes()`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:58,Redund,RedundantTokens,58,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,1,['Redund'],['RedundantTokens']
Safety,// Class to be specialized for different users of RegionInfo; // (i.e. BasicBlocks or MachineBasicBlocks). This is only to avoid needing to; // pass around an unreasonable number of template parameters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:123,avoid,avoid,123,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,1,['avoid'],['avoid']
Safety,// Cleanup of redundant (identical) address/immediate loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:14,redund,redundant,14,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,1,['redund'],['redundant']
Safety,// Cleanup of redundant immediate/address loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:14,redund,redundant,14,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,1,['redund'],['redundant']
Safety,"// Clear eval error log prior to forking; // to avoid confusions...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx:48,avoid,avoid,48,roofit/roofitcore/src/RooRealMPFE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx,1,['avoid'],['avoid']
Safety,"// Clear out the list of suppressed diagnostics, so that we don't emit; // them again for this specialization. However, we don't obsolete this; // entry from the table, because we want to avoid ever emitting these; // diagnostics again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:188,avoid,avoid,188,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['avoid'],['avoid']
Safety,// Clear the registration list and release the lock once we're done. Any; // pending updates from other threads will safely take effect after we return.; // That might not be what the user wants if they're measuring a compilation; // but it's their responsibility to prevent concurrent compilations to make; // a single compilation measurable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Statistic.cpp:117,safe,safely,117,interpreter/llvm-project/llvm/lib/Support/Statistic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Statistic.cpp,1,['safe'],['safely']
Safety,// Clients are responsible for avoid race conditions in registration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/TargetRegistry.cpp:31,avoid,avoid,31,interpreter/llvm-project/llvm/lib/MC/TargetRegistry.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/TargetRegistry.cpp,1,['avoid'],['avoid']
Safety,"// Clients may or may not want to ignore defs when testing for equality.; // For example, machine CSE pass only cares about finding common; // subexpressions, so it's safe to ignore virtual register defs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:167,safe,safe,167,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,1,['safe'],['safe']
Safety,"// Cloned Die may have address attributes relocated to a; // totally unrelated value. This can happen:; // - If high_pc is an address (Dwarf version == 2), then it might have been; // relocated to a totally unrelated value (because the end address in the; // object file might be start address of another function which got moved; // independently by the linker).; // - If address relocated in an inline_subprogram that happens at the; // beginning of its inlining function.; // To avoid above cases and to not apply relocation twice (in; // applyValidRelocs and here), read address attribute from InputDIE and apply; // Info.PCOffset here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:482,avoid,avoid,482,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,2,['avoid'],['avoid']
Safety,"// CloseProgressDialog does not do anything when run without GUI. This detects; // whether the proof instance is still there and deletes it if that is the case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooStudyManager.cxx:71,detect,detects,71,roofit/roofitcore/src/RooStudyManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooStudyManager.cxx,1,['detect'],['detects']
Safety,"// Cluster if the memory operations are on the same or a neighbouring cache; // line, but limit the maximum ClusterSize to avoid creating too much; // additional register pressure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:123,avoid,avoid,123,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,1,['avoid'],['avoid']
Safety,"// Coalescing will extend the live interval of the destination register.; // If the destination register is a vector pair, avoid introducing function; // calls into the interval, since it could result in a spilling of a pair; // instead of a single vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:123,avoid,avoid,123,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,1,['avoid'],['avoid']
Safety,"// Code compiled without atomics or bulk-memory may have had its atomics or; // thread-local data lowered to nonatomic operations or non-thread-local; // data. In that case, we mark the pseudo-feature ""shared-mem"" as disallowed; // to tell the linker that it would be unsafe to allow this code ot be used; // in a module with shared memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:268,unsafe,unsafe,268,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,1,['unsafe'],['unsafe']
Safety,"// Code motion for interleaved accesses can potentially hoist strided loads; // and sink strided stores. The code below checks the legality of the; // following two conditions:; //; // 1. Potentially moving a strided load (B) before any store (A) that; // precedes B, or; //; // 2. Potentially moving a strided store (A) after any load or store (B); // that A precedes.; //; // It's legal to reorder A and B if we know there isn't a dependence from A; // to B. Note that this determination is conservative since some; // dependences could potentially be reordered safely.; // A is potentially the source of a dependence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:564,safe,safely,564,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['safe'],['safely']
Safety,"// CodeGenFunction can also detect this, but this gives a better error; // message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:28,detect,detect,28,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['detect'],['detect']
Safety,"// CodeGenPrepare can sink pointer compare past statepoint, which; // breaks assumption that statepoint kills tied-use register when; // in SSA form (see note in IR/SafepointIRVerifier.cpp). Fall back; // to generic tied register handling to avoid assertion failures.; // TODO: Recompute LIS/LV information for new range here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:165,Safe,SafepointIRVerifier,165,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,2,"['Safe', 'avoid']","['SafepointIRVerifier', 'avoid']"
Safety,"// Collect all points where stack gets unwound and needs to be restored; // This is only necessary because the runtime (setjmp and unwind code) is; // not aware of the unsafe stack and won't unwind/restore it properly.; // To work around this problem without changing the runtime, we insert; // instrumentation to restore the unsafe stack pointer when necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:168,unsafe,unsafe,168,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,2,['unsafe'],['unsafe']
Safety,// Collect masked ops in temporary set first to avoid partially populating; // MaskedOp if a block cannot be predicated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:48,avoid,avoid,48,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['avoid'],['avoid']
Safety,"// Collect redundant MIs from [G_SUB] + G_ICMP + G_BRCOND + G_BR sequences.; // After updating spv_switches, the instructions can be removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:11,redund,redundant,11,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,1,['redund'],['redundant']
Safety,// Collect regions with rematerializable reg as live-in to avoid; // searching later when updating RP.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:59,avoid,avoid,59,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['avoid'],['avoid']
Safety,"// Collect replicate regions followed by an empty block, followed by another; // replicate region with matching masks to process front. This is to avoid; // iterator invalidation issues while merging regions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:147,avoid,avoid,147,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,1,['avoid'],['avoid']
Safety,// Collect safe addresses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:11,safe,safe,11,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['safe'],['safe']
Safety,// Collect the ISELs that can be merged together.; // This will eat up ISEL instructions without considering whether they; // may be redundant or foldable to a register copy. So we still keep; // the handleSpecialCases() downstream to handle them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:133,redund,redundant,133,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,1,['redund'],['redundant']
Safety,// Collect the given instruction in the specified MS. We assume global register; // numbering has already occurred by this point. We can directly compare reg; // arguments when detecting duplicates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:177,detect,detecting,177,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,1,['detect'],['detecting']
Safety,// Collect values which satisfy safety checks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:32,safe,safety,32,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['safe'],['safety']
Safety,"// CollectUnexpandedParameterPacksVisitor does not expect to see a; // FunctionParmPackExpr, but diagnosing unexpected parameter packs may still; // see such an expression in a lambda body.; // We'll bail out early in this case to avoid triggering an assertion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp:231,avoid,avoid,231,interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,1,['avoid'],['avoid']
Safety,"// Collision, abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:14,abort,abort,14,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['abort'],['abort']
Safety,// Color diagnostics are parsed by the driver directly from argv and later; // re-parsed to construct this job; claim any possible color diagnostic here; // to avoid warn_drv_unused_argument and diagnose bad; // OPT_fdiagnostics_color_EQ values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:160,avoid,avoid,160,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['avoid'],['avoid']
Safety,// Color diagnostics are parsed by the driver directly from argv and later; // re-parsed to construct this job; claim any possible color diagnostic here; // to avoid warn_drv_unused_argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp:160,avoid,avoid,160,interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Flang.cpp,1,['avoid'],['avoid']
Safety,// Combine store of vmv.x.s/vfmv.f.s to vse with VL of 1.; // vfmv.f.s is represented as extract element from 0. Match it late to avoid; // any illegal types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:130,avoid,avoid,130,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Command line option to control appending FunctionHash to the name of a COMDAT; // function. This is to avoid the hash mismatch caused by the preinliner.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:106,avoid,avoid,106,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,1,['avoid'],['avoid']
Safety,// Commit the changes now that we know this fold is safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:52,safe,safe,52,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['safe'],['safe']
Safety,// Common paste case: identifier+identifier = identifier. Avoid creating; // a lexer and other overhead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:58,Avoid,Avoid,58,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['Avoid'],['Avoid']
Safety,"// Compare IFS output with the existing IFS file. If unchanged, avoid; // changing the file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/llvm-ifs.cpp:64,avoid,avoid,64,interpreter/llvm-project/llvm/tools/llvm-ifs/llvm-ifs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/llvm-ifs.cpp,1,['avoid'],['avoid']
Safety,"// Compare Stub output with existing Stub file.; // If Stub file unchanged, abort updating.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:76,abort,abort,76,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,1,['abort'],['abort']
Safety,"// Compare every group in the result with the rest. If one groups contains; // another group, we only need to return the bigger group.; // Note: This doesn't scale well, so if possible avoid calling any heavy; // function from this loop to minimize the performance impact.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:185,avoid,avoid,185,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,1,['avoid'],['avoid']
Safety,"// Compare the hash generated to the hash stored. A difference means; // that a body was present in the original source. Due to merging,; // the standard way of detecting a body will not work.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp:161,detect,detecting,161,interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp,1,['detect'],['detecting']
Safety,"// Compare to the RHS.; // FIXME: We need to compare template parameters here to avoid incorrect; // collisions in mapMetadata when RF_ReuseAndMutateDistinctMDs and a; // ODR-DISubprogram has a non-ODR template parameter (i.e., a; // DICompositeType that does not have an identifier). Eventually we should; // decouple ODR logic from uniquing logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:81,avoid,avoid,81,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,1,['avoid'],['avoid']
Safety,"// Compare values. If RHS is 0 and it is safe to calculate without; // comparison, we don't generate an instruction for comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:41,safe,safe,41,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,1,['safe'],['safe']
Safety,"// Compared with amount (2048 - StackAlign), StackSize needs to; // satisfy the following conditions to avoid using more instructions; // to adjust the sp after adjusting the amount, such as; // StackSize meets the condition (StackSize <= 2048 + RVCompressLen),; // case1: Amount is 2048 - StackAlign: use addi + addi to adjust sp.; // case2: Amount is RVCompressLen: use addi + addi to adjust sp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:104,avoid,avoid,104,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['avoid'],['avoid']
Safety,"// Compared with jump tables, the DFA optimizer removes an indirect branch; // on each loop iteration, thus making branch prediction more precise. The; // more branch targets there are, the more likely it is for the branch; // predictor to make a mistake, and the more benefit there is in the DFA; // optimizer. Thus, the more branch targets there are, the lower is the; // cost of the DFA opt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:122,predict,prediction,122,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,2,['predict'],"['prediction', 'predictor']"
Safety,"// Complete the newly synthesized compound expression by inserting a right; // curly brace before the end of the declaration.; // FIXME: This approach avoids rewriting the initializer expression. It; // also assumes there is only one declarator. For example, the following; // isn't currently supported by this routine (in general):; //; // double __block BYREFVAR = 1.34, BYREFVAR2 = 1.37;; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:151,avoid,avoids,151,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,1,['avoid'],['avoids']
Safety,// Completely unsafe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:14,unsafe,unsafe,14,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,3,['unsafe'],['unsafe']
Safety,"// Compute a hash value on the operands. Instcombine will likely have; // sorted them, which helps expose duplicates, but we have to check all; // the operands to be safe in case instcombine hasn't run.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:166,safe,safe,166,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['safe'],['safe']
Safety,// Compute a safe set of limits for the main loop to run in -- effectively the; // intersection of `Range' and the iteration space of the original loop.; // Return std::nullopt if unable to compute the set of subranges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:13,safe,safe,13,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,1,['safe'],['safe']
Safety,"// Compute a sufficient number of bits that is always large enough but might; // be too large. This avoids the assertion in the constructor. This; // calculation doesn't work appropriately for the numbers 0-9, so just use 4; // bits in that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:100,avoid,avoids,100,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['avoid'],['avoids']
Safety,"// Compute energy loss in detector's material; // cf Bethe Bloch formula",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:26,detect,detector,26,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,1,['detect'],['detector']
Safety,// Compute loop safety information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:16,safe,safety,16,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['safe'],['safety']
Safety,"// Compute the cost of each block, as well as the total loop cost. Also, bail; // out if we see instructions which are incompatible with loop unswitching; // (convergent, noduplicate, or cross-basic-block tokens).; // FIXME: We might be able to safely handle some of these in non-duplicated; // regions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:245,safe,safely,245,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['safe'],['safely']
Safety,// Compute the module access path corresponding to this module.; // FIXME: Should we have a second loadModule() overload to avoid this; // extra lookup step?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:124,avoid,avoid,124,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['avoid'],['avoid']
Safety,// Computing the value outside of the loop brings no benefit if it is; // definitely used inside the loop in a way which can not be optimized; // away. Avoid doing so unless we know we have a value which computes; // the ExitValue already. TODO: This should be merged into SCEV; // expander to leverage its knowledge of existing expressions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:152,Avoid,Avoid,152,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,1,['Avoid'],['Avoid']
Safety,// CondCost is included to account for cases where the computation of the; // condition is part of a long dependence chain (potentially loop-carried); // that would delay detection of a misprediction and increase its cost.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:171,detect,detection,171,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,1,['detect'],['detection']
Safety,"// Conditions under which the scheduler should eagerly advance the cycle:; // (1) No available instructions; // (2) All pipelines full, so available instructions must have hazards.; //; // If HazardRec is disabled, the cycle was pre-advanced before calling; // ReleasePredecessors. In that case, IssueCount should remain 0.; //; // Check AvailableQueue after ReleasePredecessors in case of zero latency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:172,hazard,hazards,172,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,2,"['Hazard', 'hazard']","['HazardRec', 'hazards']"
Safety,// Conflicting properties are detected elsewhere.; // Check for overriding methods,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:30,detect,detected,30,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['detect'],['detected']
Safety,// Conjure a new symbol if necessary to recover precision.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:40,recover,recover,40,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,1,['recover'],['recover']
Safety,// Conservatively abort if-conversion if BB's address is taken.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:18,abort,abort,18,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,2,['abort'],['abort']
Safety,// Conservatively abort if-conversion if either BB has its address taken.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:18,abort,abort,18,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,1,['abort'],['abort']
Safety,// Conservatively avoid trying to use the post-inc value in non-latch; // exits if there may be pre-inc users in intervening blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:18,avoid,avoid,18,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['avoid'],['avoid']
Safety,// Conservatively return true if we're seeing a large number or a deep chain; // of users. This avoids excessive compilation times in pathological cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:96,avoid,avoids,96,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['avoid'],['avoids']
Safety,"// Conservatively, mark all functions and calls in CUDA and OpenCL as; // convergent (meaning, they may call an intrinsically convergent op, such; // as __syncthreads() / barrier(), and so can't have certain optimizations; // applied around them). LLVM will remove this attribute where it safely; // can.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:289,safe,safely,289,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['safe'],['safely']
Safety,// Consider different header search and diagnostic options to create; // different modules. This avoids the unsound aliasing of module PCMs.; //; // TODO: Implement diagnostic bucketing to reduce the impact of strict; // context hashing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:97,avoid,avoids,97,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,1,['avoid'],['avoids']
Safety,// Consider taskgroup reduction descriptor variable a private; // to avoid possible capture in the region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:69,avoid,avoid,69,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['avoid'],['avoid']
Safety,"// Consider this case:; // %1 = instr1 ...; // %2 = instr2 ...; // %0 = C2_mux ..., %1, %2; // If %0 was coalesced with %1, we could end up with the following; // code:; // %0 = instr1 ...; // %2 = instr2 ...; // %0 = A2_tfrf ..., %2; // which will later become:; // %0 = instr1 ...; // %0 = instr2_cNotPt ...; // i.e. there will be an unconditional definition (instr1) of %0; // followed by a conditional one. The output dependency was there before; // and it unavoidable, but if instr1 is predicable, we will no longer be; // able to predicate it here.; // To avoid this scenario, don't coalesce the destination register with; // a source register that is defined by a predicable instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:562,avoid,avoid,562,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,1,['avoid'],['avoid']
Safety,"// Consider this pattern:; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // A = ...; // ... = A; // There are three anti-dependencies here, and without special care,; // we'd break all of them using the same register:; // A = ...; // ... = A; // B = ...; // ... = B; // B = ...; // ... = B; // B = ...; // ... = B; // because at each anti-dependence, B is the first register that; // isn't A which is free. This re-introduces anti-dependencies; // at all but one of the original anti-dependencies that we were; // trying to break. To avoid this, keep track of the most recent; // register that each register was replaced with, avoid; // using it to repair an anti-dependence on the same register.; // This lets us produce this:; // A = ...; // ... = A; // B = ...; // ... = B; // C = ...; // ... = C; // B = ...; // ... = B; // This still has an anti-dependence on B, but at least it isn't on the; // original critical path.; //; // TODO: If we tracked more than one register here, we could potentially; // fix that remaining critical edge too. This is a little more involved,; // because unlike the most recent register, less recent registers should; // still be considered, though only if no other registers are available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:560,avoid,avoid,560,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,2,['avoid'],['avoid']
Safety,"// Constant pointers (that are not exclusively null) may have; // meaning in different VMs, so we cannot reorder the compare; // against constant pointers before the safepoint. In other words,; // comparison of an unrelocated use against a non-null constant; // maybe invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:166,safe,safepoint,166,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['safe'],['safepoint']
Safety,// ConstantAsMetadata doesn't reference anything. We may as well shuffle it; // to the front since we can detect it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:106,detect,detect,106,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,2,['detect'],['detect']
Safety,"// Constants only safely match if A doesn't contain undef/poison.; // As we'll be reusing A, it doesn't matter if B contain undef/poison.; // TODO: Handle cases where A and B have the same undef/poison elements.; // TODO: Merge A and B with mismatching undef/poison elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:18,safe,safely,18,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,1,['safe'],['safely']
Safety,"// Construct PointerType points to null (aka void *) instead of exploring; // pointee type to avoid infinite search problem. For example, we would be; // in trouble if we traverse recursively:; //; // struct Node {; // Node* ptr;; // };",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:94,avoid,avoid,94,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['avoid'],['avoid']
Safety,"// Construct a numpy array from the lowlevelview (w/o copy if possible); this; // uses the Python methods to avoid depending on numpy directly; // Expect as most a dtype from the arguments;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/LowLevelViews.cxx:109,avoid,avoid,109,bindings/pyroot/cppyy/CPyCppyy/src/LowLevelViews.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/LowLevelViews.cxx,1,['avoid'],['avoid']
Safety,"// Construct in lambda only references packs declared outside the lambda.; // That's OK for now, but the lambda itself is considered to contain an; // unexpanded pack in this case, which will require expansion outside the; // lambda.; // We do not permit pack expansion that would duplicate a statement; // expression, not even within a lambda.; // FIXME: We could probably support this for statement expressions that; // do not contain labels.; // FIXME: This is insufficient to detect this problem; consider; // f( ({ bad: 0; }) + pack ... );",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp:480,detect,detect,480,interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,1,['detect'],['detect']
Safety,"// Construct the name <ModuleName>-<hash of ModuleMapPath>.pcm which should; // ideally be globally unique to this particular module. Name collisions; // in the hash are safe (because any translation unit can only import one; // module with each name), but result in a loss of caching.; //; // To avoid false-negatives, we form as canonical a path as we can, and map; // to lower-case in case we're on a case-insensitive file system.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:170,safe,safe,170,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"// Constructor; // Initialisation of unfolding; // ""bdat"" - measured data distribution (number of events); // ""Bcov"" - covariance matrix for measured data distribution; // ""bini"" - reconstructed MC distribution (number of events); // ""xini"" - truth MC distribution (number of events); // ""Adet"" - detector response matrix (number of events)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TSVDUnfold.h:297,detect,detector,297,hist/hist/inc/TSVDUnfold.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TSVDUnfold.h,1,['detect'],['detector']
Safety,"// Consume any end of statement token, if present, to avoid spurious; // addBlankLine calls().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:54,avoid,avoid,54,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,2,['avoid'],['avoid']
Safety,"// Consume constexpr-opt mutable-opt in any sequence, and set the DeclEndLoc; // to the final of those locations. Emit an error if we have multiple; // copies of those keywords and recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:181,recover,recover,181,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['recover'],['recover']
Safety,"// Consume the identifier token - but if parsing certain directives, avoid; // lexical expansion of the next token.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp:69,avoid,avoid,69,interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,1,['avoid'],['avoid']
Safety,// Containers to remember the pointer infos and new copies while we are not; // sure that we can find all of them. If we abort we want to avoid spurious; // dependences and potential copies in the provided container.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:121,abort,abort,121,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,2,"['abort', 'avoid']","['abort', 'avoid']"
Safety,"// Continue as long as we still make progress (prevNtot < ntotCurrentBuf), that the next entry range to be looked; // at,; // which start at 'minEntry', is not past the end of the requested range (minEntry < fEntryMax); // and we guess that we not going to go over the requested amount of memory by asking for another set; // of entries (fBufferSizeMin > ((Long64_t)ntotCurrentBuf*(clusterIterations+1))/clusterIterations).; // ntotCurrentBuf / clusterIterations is the average size we are accumulated so far at each loop.; // and thus (ntotCurrentBuf / clusterIterations) * (clusterIterations+1) is a good guess at what the next total; // size; // would be if we run the loop one more time. ntotCurrentBuf and clusterIterations are Int_t but can sometimes; // be 'large' (i.e. 30Mb * 300 intervals) and can overflow the numerical limit of Int_t (i.e. become; // artificially negative). To avoid this issue we promote ntotCurrentBuf to a long long (64 bits rather than 32; // bits)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:890,avoid,avoid,890,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['avoid'],['avoid']
Safety,"// Convenience assignment operators. This only works if the destination; // DocNode has an associated Document, i.e. it was not constructed using the; // default constructor. The string one does not copy, so the string must; // remain valid for the lifetime of the Document. Use fromString to avoid; // that restriction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:293,avoid,avoid,293,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,1,['avoid'],['avoid']
Safety,// Convenience function to return a signed value. This avoids; // us forgetting to first cast to int8_t before casting to a; // wider signed int type.; // if we casted uint8 directly to a wider type we'd lose; // negative values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutorImpl.h:55,avoid,avoids,55,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutorImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutorImpl.h,1,['avoid'],['avoids']
Safety,"// Convenience method to avoid code duplication between; // SetEntry and InitSlot",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx:25,avoid,avoid,25,tree/dataframe/src/RArrowDS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RArrowDS.cxx,1,['avoid'],['avoid']
Safety,// Convenience variables to avoid some queries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:28,avoid,avoid,28,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,2,['avoid'],['avoid']
Safety,"// Convenient constant check, but redundant for recursive calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:34,redund,redundant,34,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['redund'],['redundant']
Safety,"// Convenient type-safe accessors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooPlot.h:19,safe,safe,19,roofit/roofitcore/inc/RooPlot.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooPlot.h,1,['safe'],['safe']
Safety,// Convergent attribute has been used on operations that involve inter-thread; // communication which results are implicitly affected by the enclosing; // control flows. It is not safe to hoist or sink such operations across; // control flow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:180,safe,safe,180,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,1,['safe'],['safe']
Safety,// Convergent attribute has been used on operations that involve; // inter-thread communication which results are implicitly affected by the; // enclosing control flows. It is not safe to hoist or sink such operations; // across control flow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:180,safe,safe,180,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['safe'],['safe']
Safety,"// Convert a strict mode transition to a pseudo transition.; // This still pre-allocates registers to prevent clobbering,; // but avoids any EXEC mask changes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:130,avoid,avoids,130,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['avoid'],['avoids']
Safety,// Convert iterator to elt# to avoid invalidating iterator when we reserve(),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTVector.h:31,avoid,avoid,31,interpreter/llvm-project/clang/include/clang/AST/ASTVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTVector.h,4,['avoid'],['avoid']
Safety,"// Convert iterator to elt# to avoid invalidating iterator when we reserve()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:31,avoid,avoid,31,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,2,['avoid'],['avoid']
Safety,"// Convert number to double. To avoid spurious underflows, we re-; // normalize against the ""double"" minExponent first, and only *then*; // truncate the mantissa. The result of that second conversion; // may be inexact, but should never underflow.; // Declare fltSemantics before APFloat that uses it (and; // saves pointer to it) to ensure correct destruction order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:32,avoid,avoid,32,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['avoid'],['avoid']
Safety,"// Convert self to upper-case; // For detecting null substrings",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TString.h:38,detect,detecting,38,core/base/inc/TString.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TString.h,1,['detect'],['detecting']
Safety,"// Convert shuffles that are directly supported on NEON to target-specific; // DAG nodes, instead of keeping them as shuffles and matching them again; // during code selection. This is more efficient and avoids the possibility; // of inconsistencies between legalization and selection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:204,avoid,avoids,204,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoids']
Safety,"// Convert shuffles that are directly supported on NEON to target-specific; // DAG nodes, instead of keeping them as shuffles and matching them again; // during code selection. This is more efficient and avoids the possibility; // of inconsistencies between legalization and selection.; // FIXME: floating-point vectors should be canonicalized to integer vectors; // of the same time so that they get CSEd properly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:204,avoid,avoids,204,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avoid'],['avoids']
Safety,// Convert the character to unsigned char before passing it to putchar; // to avoid host-specific sign extension in the IR. Putchar converts; // it to unsigned char regardless.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:78,avoid,avoid,78,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,2,['avoid'],['avoid']
Safety,"// Convert the entire string Str representing an integer in Base, up to; // the terminating nul if present, to a constant according to the rules; // of strtoul[l] or, when AsSigned is set, of strtol[l]. On success; // return the result, otherwise null.; // The function assumes the string is encoded in ASCII and carefully; // avoids converting sequences (including """") that the corresponding; // library call might fail and set errno for.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:327,avoid,avoids,327,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['avoid'],['avoids']
Safety,// Convert the mask to a predicated (NOTE: We don't need to worry about; // inactive lanes since VSELECT is safe when given undefined elements).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:108,safe,safe,108,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['safe'],['safe']
Safety,"// Converting between a vector predicate and a scalar predicate. In the; // vector predicate, a group of BitBytes bits will correspond to a single; // i1 element of the source vector type. Those bits will all have the same; // value. The same will be true for ByteVec, where each byte corresponds; // to a bit in the vector predicate.; // The algorithm is to traverse the ByteVec, going over the i1 values from; // the source vector, and generate the corresponding representation in an; // 8-byte vector. To avoid repeated extracts from ByteVec, shuffle the; // elements so that the interesting 8 bytes will be in the low end of the; // vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:508,avoid,avoid,508,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,1,['avoid'],['avoid']
Safety,"// Copies/moves of physical accumulators are expensive operations; // that should be avoided whenever possible. MMA instructions are; // meant to be used in performance-sensitive computational kernels.; // This option is provided, at least for the time being, to give the; // user a tool to detect this expensive operation and either rework; // their code or report a compiler bug if that turns out to be the; // cause.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:85,avoid,avoided,85,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,2,"['avoid', 'detect']","['avoided', 'detect']"
Safety,"// Copy CandidateSet is necessary, to avoid unsynchronized access to; // the datastructure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Speculation.h:38,avoid,avoid,38,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Speculation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Speculation.h,1,['avoid'],['avoid']
Safety,// Copy FP to the scratch register now and emit the CFI entry. It avoids; // the extra FP copy needed in the other two cases when FP is spilled to; // memory or to a VGPR lane.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:66,avoid,avoids,66,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['avoid'],['avoids']
Safety,// Copy all dependencies to the head of the chain to avoid any; // computation being inserted into the chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUExportClustering.cpp:53,avoid,avoid,53,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUExportClustering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUExportClustering.cpp,1,['avoid'],['avoid']
Safety,// Copy blocks into a temporary array to avoid iterator invalidation issues; // as we remove them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:41,avoid,avoid,41,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,1,['avoid'],['avoid']
Safety,// Copy blocks into a temporary array to avoid iterator invalidation issues; // as we remove them.; // Note that this intentionally skips the entry block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:41,avoid,avoid,41,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['avoid'],['avoid']
Safety,// Copy non-redundant base specifiers into permanent storage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,redund,redundant,12,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['redund'],['redundant']
Safety,"// Copy parameters for thread safety",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TF1.h:30,safe,safety,30,hist/hist/inc/TF1.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TF1.h,1,['safe'],['safety']
Safety,"// Copy predecessor edges from SUb to SUa to avoid the SUnits that; // SUb dependent on scheduled in-between SUb and SUa. Successor edges; // do not need to be copied from SUa to SUb since no one will depend; // on stores.; // Notice that, we don't need to care about the memory dependency as; // we won't try to cluster them if they have any memory dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:45,avoid,avoid,45,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['avoid'],['avoid']
Safety,"// Copy state information back into the TGHtml object for safe keeping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlSizer.cxx:58,safe,safe,58,gui/guihtml/src/TGHtmlSizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlSizer.cxx,1,['safe'],['safe']
Safety,// Copy the thread un-safe result of strerror into; // the buffer as fast as possible to minimize impact; // of collision of strerror in multiple threads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Errno.cpp:22,safe,safe,22,interpreter/llvm-project/llvm/lib/Support/Errno.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Errno.cpp,1,['safe'],['safe']
Safety,// Copy was redundantly redefining either Src or Def. Remove earlier kill; // flags between Copy and PrevCopy because the value will be reused now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:12,redund,redundantly,12,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,1,['redund'],['redundantly']
Safety,// CopyToReg should be close to its uses to facilitate coalescing and; // avoid spilling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:74,avoid,avoid,74,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,2,['avoid'],['avoid']
Safety,// CorrectTypo used in a non error recovery situation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:35,recover,recovery,35,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['recover'],['recovery']
Safety,// CorrectTypo used in normal error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:36,recover,recovery,36,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['recover'],['recovery']
Safety,"// Costs for both fshl & fshr are the same, so just pass Intrinsic::fshl; // to avoid having to duplicate the costs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:80,avoid,avoid,80,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['avoid'],['avoid']
Safety,"// Crash is expected, so disable crash report and symbolization to reduce; // output and avoid potentially slow symbolization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/not/not.cpp:89,avoid,avoid,89,interpreter/llvm-project/llvm/utils/not/not.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/not/not.cpp,1,['avoid'],['avoid']
Safety,// Create a MCSymbol for the label to avoid any target lowering; // that would make this PC relative.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:38,avoid,avoid,38,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['avoid'],['avoid']
Safety,// Create a RawMemProfReader after sanity checking the contents of the file at; // \p Path or the \p Buffer. The binary from which the profile has been; // collected is specified via a path in \p ProfiledBinary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/RawMemProfReader.h:35,sanity check,sanity checking,35,interpreter/llvm-project/llvm/include/llvm/ProfileData/RawMemProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/RawMemProfReader.h,1,['sanity check'],['sanity checking']
Safety,// Create a dummy memory operand to avoid allocframe from being treated as; // a volatile memory reference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:36,avoid,avoid,36,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,1,['avoid'],['avoid']
Safety,"// Create a dynamic lds variable with a name associated with the passed; // function that has the maximum alignment of any dynamic lds variable; // reachable from this kernel. Dynamic LDS is allocated after the static LDS; // allocation, possibly after alignment padding. The representative variable; // created here has the maximum alignment of any other dynamic variable; // reachable by that kernel. All dynamic LDS variables are allocated at the; // same address in each kernel in order to provide the documented aliasing; // semantics. Setting the alignment here allows this IR pass to accurately; // predict the exact constant at which it will be allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:606,predict,predict,606,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['predict'],['predict']
Safety,"// Create a flag indicating whether the cleanup needs to call; // objc_exception_try_exit. This is true except when; // - no catches match and we're branching through the cleanup; // just to rethrow the exception, or; // - a catch matched and we're falling out of the catch handler.; // The setjmp-safety rule here is that we should always store to this; // variable in a place that dominates the branch through the cleanup; // without passing through any setjmps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:298,safe,safety,298,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['safe'],['safety']
Safety,// Create a local alias with the original name to avoid breaking; // references from inline assembly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:50,avoid,avoid,50,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,1,['avoid'],['avoid']
Safety,"// Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/hsimple.cxx:160,detect,detector,160,test/hsimple.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/hsimple.cxx,1,['detect'],['detector']
Safety,// Create a read hazard for the allocas. This inhibits dead-store; // optimizations and forces the values to memory. This hazard is; // inserted before any 'throwing' calls in the protected scope to; // reflect the possibility that the variables might be read from the; // catch block if the call throws.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:17,hazard,hazard,17,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,2,['hazard'],['hazard']
Safety,"// Create a root node that connects to every connected component of the graph.; // This is done to allow graph iterators to visit all the disjoint components; // of the graph, in a single walk.; //; // This algorithm works by going through each node of the graph and for each; // node N, do a DFS starting from N. A rooted edge is established between the; // root node and N (if N is not yet visited). All the nodes reachable from N; // are marked as visited and are skipped in the DFS of subsequent nodes.; //; // Note: This algorithm tries to limit the number of edges out of the root; // node to some extent, but there may be redundant edges created depending on; // the iteration order. For example for a graph {A -> B}, an edge from the; // root node is added to both nodes if B is visited before A. While it does; // not result in minimal number of edges, this approach saves compile-time; // while keeping the number of edges in check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:629,redund,redundant,629,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,1,['redund'],['redundant']
Safety,// Create a vreg for the destination.; // FIXME: No need to do this if the ultimate user expects an FPR64.; // Check for that and avoid the copy if possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AdvSIMDScalarPass.cpp:130,avoid,avoid,130,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AdvSIMDScalarPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AdvSIMDScalarPass.cpp,1,['avoid'],['avoid']
Safety,"// Create a wrapper function with type Ty that calls F (which may have a; // different type). Attempt to support common bitcasted function idioms:; // - Call with more arguments than needed: arguments are dropped; // - Call with fewer arguments than needed: arguments are filled in with undef; // - Return value is not needed: drop it; // - Return value needed but not present: supply an undef; //; // If the all the argument types of trivially castable to one another (i.e.; // I32 vs pointer type) then we don't create a wrapper at all (return nullptr; // instead).; //; // If there is a type mismatch that we know would result in an invalid wasm; // module then generate wrapper that contains unreachable (i.e. abort at; // runtime). Such programs are deep into undefined behaviour territory,; // but we choose to fail at runtime rather than generate and invalid module; // or fail at compiler time. The reason we delay the error is that we want; // to support the CMake which expects to be able to compile and link programs; // that refer to functions with entirely incorrect signatures (this is how; // CMake detects the existence of a function in a toolchain).; //; // For bitcasts that involve struct types we don't know at this stage if they; // would be equivalent at the wasm level and so we can't know if we need to; // generate a wrapper.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:714,abort,abort,714,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,2,"['abort', 'detect']","['abort', 'detects']"
Safety,// Create a write hazard for the allocas. This inhibits folding; // loads across the hazard. This hazard is inserted at the; // beginning of the catch path to reflect the possibility that the; // variables might have been written within the protected scope.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:18,hazard,hazard,18,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,3,['hazard'],['hazard']
Safety,"// Create additions. We do this before subtractions to avoid constructs like; // ((0 - X) + Y), as opposed to (Y - X).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp:55,avoid,avoid,55,interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp,1,['avoid'],['avoid']
Safety,// Create an empty module interface unit for error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:51,recover,recovery,51,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,1,['recover'],['recovery']
Safety,"// Create artificial dependencies between the source of COPY/REG_SEQUENCE that; // is loop-carried to the USE in next iteration. This will help pipeliner avoid; // additional copies that are needed across iterations. An artificial dependence; // edge is added from USE to SOURCE of COPY/REG_SEQUENCE.; // PHI-------Anti-Dep-----> COPY/REG_SEQUENCE (loop-carried); // SRCOfCopY------True-Dep---> COPY/REG_SEQUENCE; // PHI-------True-Dep------> USEOfPhi; // The mutation creates; // USEOfPHI -------Artificial-Dep---> SRCOfCopy; // This overall will ensure, the USEOfPHI is scheduled before SRCOfCopy; // (since USE is a predecessor), implies, the COPY/ REG_SEQUENCE is scheduled; // late to avoid additional copies across iterations. The possible scheduling; // order would be; // USEOfPHI --- SRCOfCopy--- COPY/REG_SEQUENCE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:154,avoid,avoid,154,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,2,['avoid'],['avoid']
Safety,// Create empty phi nodes. This avoids cyclic dependencies when creating; // the remaining instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:32,avoid,avoids,32,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['avoid'],['avoids']
Safety,"// Create indices at the start, end, and middle, but avoid dups.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp:53,avoid,avoid,53,interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp,1,['avoid'],['avoid']
Safety,"// Create instance of query results; we set ownership of the input list; // to the TQueryResult object, to avoid too many instantiations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:107,avoid,avoid,107,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['avoid'],['avoid']
Safety,// Create local alias for NewGlobal to avoid crash on ODR between; // instrumented and non-instrumented libraries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:39,avoid,avoid,39,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['avoid'],['avoid']
Safety,// Create local copies which are safely captured-by-copy in lambdas,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Caching.cpp:33,safe,safely,33,interpreter/llvm-project/llvm/lib/Support/Caching.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Caching.cpp,1,['safe'],['safely']
Safety,"// Create local declarations to avoid rewriting all closure decl ref exprs.; // First, emit a declaration for all ""by ref"" decls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:32,avoid,avoid,32,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['avoid'],['avoid']
Safety,// Create new attribute set containing only attributes which can be transferred; // from the original call to the safepoint.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:114,safe,safepoint,114,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['safe'],['safepoint']
Safety,// Create section descriptors ahead if they are not exist at the moment.; // SectionDescriptors container is not thread safe. Thus we should be sure; // that descriptors would not be created in following parallel tasks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp:120,safe,safe,120,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.cpp,1,['safe'],['safe']
Safety,"// Create task-specific TDirectory, so avoid parallel tasks to interfere; // in gDirectory with histogram registration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSimpleAnalysis.cxx:39,avoid,avoid,39,tree/treeplayer/src/TSimpleAnalysis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSimpleAnalysis.cxx,1,['avoid'],['avoid']
Safety,"// Create the MBBs for the dispatch code like following:; //; // ThisMBB:; // Prepare DispatchBB address and store it to buf[1].; // ...; //; // DispatchBB:; // %s15 = GETGOT iff isPositionIndependent; // %callsite = load callsite; // brgt.l.t #size of callsites, %callsite, DispContBB; //; // TrapBB:; // Call abort.; //; // DispContBB:; // %breg = address of jump table; // %pc = load and calculate next pc from %breg and %callsite; // jmp %pc; // Shove the dispatch's address into the return slot in the function context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:311,abort,abort,311,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,1,['abort'],['abort']
Safety,// Create the copy and transfer ownership to clang::SourceManager.; // TODO: Avoid copying files into memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp:77,Avoid,Avoid,77,interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp,1,['Avoid'],['Avoid']
Safety,"// Create the fragile hazards. Note that this will not capture any; // of the allocas required for exception processing, but will; // capture the current basic block (which extends all the way to the; // setjmp call) as ""before the @try"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:22,hazard,hazards,22,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['hazard'],['hazards']
Safety,"// Create the merged parallel region with default proc binding, to; // avoid overriding binding settings, and without explicit cancellation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:71,avoid,avoid,71,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['avoid'],['avoid']
Safety,// Creating OutlinableGroups for each SimilarityCandidate to be used in; // each of the following for loops to avoid making an allocator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:111,avoid,avoid,111,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,1,['avoid'],['avoid']
Safety,"// Cross-compiling binutils and GCC installations (vanilla and openSUSE at; // least) put various tools in a triple-prefixed directory off of the parent; // of the GCC installation. We use the GCC triple here to ensure that we end; // up with tools that support the same amount of cross compiling as the; // detected GCC installation. For example, if we find a GCC installation; // targeting x86_64, but it is a bi-arch GCC installation, it can also be; // used to target i386.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:308,detect,detected,308,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['detect'],['detected']
Safety,"// Current rematerialization algorithm is very simple: we rematerialize; // immediately before EVERY use, even if there are several uses in same; // block or if use is local to Cand Def. The reason is that this allows; // us to avoid recomputing liveness without complicated analysis:; // - If we did not eliminate all uses of original Candidate, we do not; // know exaclty in what BBs it is still live.; // - If we rematerialize once per BB, we need to find proper insertion; // place (first use in block, but after Def) and analyze if there is; // statepoint between uses in the block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:228,avoid,avoid,228,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['avoid'],['avoid']
Safety,// Currently memprof profiles are only added at the IR level. Mark the profile; // type as IR in that case as well and the subsequent matching needs to detect; // which is available (might be one or both).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:152,detect,detect,152,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['detect'],['detect']
Safety,"// Currently only order, simdlen and safelen clauses are supported",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:37,safe,safelen,37,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['safe'],['safelen']
Safety,// Currently we consider all ARC errors as recoverable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:43,recover,recoverable,43,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,1,['recover'],['recoverable']
Safety,"// Currently we make a somewhat optimistic assumption that; // active_lane_mask's are always free. In reality it may be freely folded; // into a tail predicated loop, expanded into a VCPT or expanded into a lot; // of add/icmp code. We may need to improve this in the future, but being; // able to detect if it is free or not involves looking at a lot of other; // code. We currently assume that the vectorizer inserted these, and knew; // what it was doing in adding one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:298,detect,detect,298,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,1,['detect'],['detect']
Safety,"// Currently, if Cling sees the ""key function"" of a virtual class, it; // emits typeinfo and vtable variables in every transaction llvm::Module; // that reference them. Turn them into weak linkage to avoid duplicate; // symbol errors from the JIT linker.; // FIXME: This is a hack, we should teach the frontend to emit these; // only once, or mark all duplicates as available_externally (if that; // improves performance due to optimizations).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/BackendPasses.cpp:200,avoid,avoid,200,interpreter/cling/lib/Interpreter/BackendPasses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/BackendPasses.cpp,1,['avoid'],['avoid']
Safety,"// Custom detector id.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveVSDStructs.h:10,detect,detector,10,graf3d/eve/inc/TEveVSDStructs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveVSDStructs.h,4,['detect'],['detector']
Safety,// Custom handling for some quad-vector types to detect MULL.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:49,detect,detect,49,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['detect'],['detect']
Safety,// Custom handling for some quad-vector types to detect VMULL.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:49,detect,detect,49,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['detect'],['detect']
Safety,// Custom handling for some vector types to avoid expensive expansions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:44,avoid,avoid,44,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Custom legalize these to avoid over promotion or custom promotion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:28,avoid,avoid,28,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Custom lower fixed vector undefs to scalable vector undefs to avoid; // expansion to a build_vector of 0s.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:65,avoid,avoid,65,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['avoid'],['avoid']
Safety,"// Custom sub-detector id.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveVSDStructs.h:14,detect,detector,14,graf3d/eve/inc/TEveVSDStructs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveVSDStructs.h,4,['detect'],['detector']
Safety,// Custom widen strict v2i32->v2f32 to avoid scalarization.; // FIXME: Should generic type legalizer do this?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:39,avoid,avoid,39,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Cycle detected,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h:9,detect,detected,9,interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h,1,['detect'],['detected']
Safety,// Cycle detected?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDie.cpp:9,detect,detected,9,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDie.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDie.cpp,1,['detect'],['detected']
Safety,"// Cyclical dependency, abort",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:24,abort,abort,24,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,2,['abort'],['abort']
Safety,"// Cygwin and MinGW insert calls from the main function to the runtime; // function __main. The __main function is responsible for setting up main's; // environment (e.g. running static constructors), however this is not needed; // when running under lli: the executor process will have run non-JIT ctors,; // and ORC will take care of running JIT'd ctors. To avoid a missing symbol; // error we just implement __main as a no-op.; //; // FIXME: Move this to ORC-RT (and the ORC-RT substitution library once it; // exists). That will allow it to work out-of-process, and for all; // ORC tools (the problem isn't lli specific).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:360,avoid,avoid,360,interpreter/llvm-project/llvm/tools/lli/lli.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp,1,['avoid'],['avoid']
Safety,"// D is a power-of-two if D0 is one. This includes INT_MIN.; // If all divisors are power-of-two, we will prefer to avoid the fold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:116,avoid,avoid,116,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['avoid'],['avoid']
Safety,"// D is a power-of-two if D0 is one.; // If all divisors are power-of-two, we will prefer to avoid the fold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:93,avoid,avoid,93,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['avoid'],['avoid']
Safety,"// DEBUG: flag is true if risk evolution behaves badly",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx:26,risk,risk,26,tmva/tmva/src/RuleFitParams.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx,1,['risk'],['risk']
Safety,"// DEBUG: risk scan",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx:10,risk,risk,10,tmva/tmva/src/RuleFitParams.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx,1,['risk'],['risk']
Safety,// DFS through subsequent users while tracking visits to avoid cycles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:57,avoid,avoid,57,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,1,['avoid'],['avoid']
Safety,"// Darwin uses a linker-private symbol name for constant-pools (to; // avoid addends on the relocation?), ELF has no such concept and; // uses a normal private symbol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp:71,avoid,avoid,71,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp,1,['avoid'],['avoid']
Safety,// Debug info can safely be ignored here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:18,safe,safely,18,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,1,['safe'],['safely']
Safety,// Debug info generation is disabled for SPIRV-LLVM-Translator; // which currently aborts on the presence of DW_OP_LLVM_convert.; // TODO: Enable debug info when the SPIR-V backend arrives.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp:83,abort,aborts,83,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp,1,['abort'],['aborts']
Safety,"// Debug info is never a scheduling boundary. It's necessary to be explicit; // due to the special treatment of IT instructions below, otherwise a; // dbg_value followed by an IT will result in the IT instruction being; // considered a scheduling hazard, which is wrong. It should be the actual; // instruction preceding the dbg_value instruction(s), just like it is; // when debug info is not present.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:247,hazard,hazard,247,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,2,['hazard'],['hazard']
Safety,// Debugifying the register allocator passes seems to provoke some; // non-determinism that affects CodeGen and there doesn't seem to be a point; // where it becomes safe again so stop debugifying here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:166,safe,safe,166,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,1,['safe'],['safe']
Safety,"// Declare a bunch of static data sets that we'll select between below. These; // are specifically designed to always refer to string literals to avoid any; // lifetime or initialization issues.; //; // The *Triples variables hard code some triples so that, for example,; // --target=aarch64 (incomplete triple) can detect lib/aarch64-linux-gnu.; // They are not needed when the user has correct LLVM_DEFAULT_TARGET_TRIPLE; // and always uses the full --target (e.g. --target=aarch64-linux-gnu). The; // lists should shrink over time. Please don't add more elements to *Triples.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:146,avoid,avoid,146,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,2,"['avoid', 'detect']","['avoid', 'detect']"
Safety,"// Decrease the timeout counter if requested",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:16,timeout,timeout,16,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,2,['timeout'],['timeout']
Safety,"// Decrementing return addresses by one moves them into the call instruction.; // The address doesn't have to be the start of the call instruction, just some; // byte on the inside. Subtracting one avoids needing detailed instruction; // length information here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/MarkupFilter.cpp:198,avoid,avoids,198,interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/MarkupFilter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/MarkupFilter.cpp,1,['avoid'],['avoids']
Safety,"// Def is used locally, it's never safe to move this def.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:35,safe,safe,35,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['safe'],['safe']
Safety,// Default ISD::TRAP to expand (which turns it into abort).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:52,abort,abort,52,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['abort'],['abort']
Safety,"// Default to avoid implicit floating-point for kernel/kext code, but allow; // that to be overridden with -mno-soft-float.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:14,avoid,avoid,14,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['avoid'],['avoid']
Safety,// Default to avoiding fdiv which is often very expensive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:14,avoid,avoiding,14,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['avoid'],['avoiding']
Safety,// Default version if not detected or specified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:26,detect,detected,26,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,1,['detect'],['detected']
Safety,"// Defensive maneuver for ill-formed code: we're likely not to make it to; // a point where we set the access specifier, so default it to ""public""; // to avoid triggering asserts elsewhere in the front end.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:154,avoid,avoid,154,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,1,['avoid'],['avoid']
Safety,// Defer any ready instrs that now have a hazard.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:42,hazard,hazard,42,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['hazard'],['hazard']
Safety,"// Define ROOFIT_MEMORY_SAFE_INTERFACES to change RooFit interfaces to be; // memory safe.; // #define ROOFIT_MEMORY_SAFE_INTERFACES",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Config.h:85,safe,safe,85,roofit/roofitcore/inc/RooFit/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Config.h,1,['safe'],['safe']
Safety,"// Define TSelector object. We use reflection to avoid including the header,; // so being able to change the tutorial directory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:49,avoid,avoid,49,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,1,['avoid'],['avoid']
Safety,"// Define __CUDACC__ early as libstdc++ standard headers with GNU extensions; // enabled depend on it to avoid using __float128, which is unsupported in; // CUDA.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:105,avoid,avoid,105,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,1,['avoid'],['avoid']
Safety,"// Define the 144 possibilities for these two cast instructions. The values; // in this matrix determine what to do in a given situation and select the; // case in the switch below. The rows correspond to firstOp, the columns; // correspond to secondOp. In looking at the table below, keep in mind; // the following cast properties:; //; // Size Compare Source Destination; // Operator Src ? Size Type Sign Type Sign; // -------- ------------ ------------------- ---------------------; // TRUNC > Integer Any Integral Any; // ZEXT < Integral Unsigned Integer Any; // SEXT < Integral Signed Integer Any; // FPTOUI n/a FloatPt n/a Integral Unsigned; // FPTOSI n/a FloatPt n/a Integral Signed; // UITOFP n/a Integral Unsigned FloatPt n/a; // SITOFP n/a Integral Signed FloatPt n/a; // FPTRUNC > FloatPt n/a FloatPt n/a; // FPEXT < FloatPt n/a FloatPt n/a; // PTRTOINT n/a Pointer n/a Integral Unsigned; // INTTOPTR n/a Integral Unsigned Pointer n/a; // BITCAST = FirstClass n/a FirstClass n/a; // ADDRSPCST n/a Pointer n/a Pointer n/a; //; // NOTE: some transforms are safe, but we consider them to be non-profitable.; // For example, we could merge ""fptoui double to i32"" + ""zext i32 to i64"",; // into ""fptoui double to i64"", but this loses information about the range; // of the produced value (we no longer know the top-part is all zeros).; // Further this conversion is often much more expensive for typical hardware,; // and causes issues when building libgcc. We disallow fptosi+sext for the; // same reason.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:1066,safe,safe,1066,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,1,['safe'],['safe']
Safety,"// Degenerated arcs can be ignored by renderer, but should not be dropped; // to avoid collisions with `S A S` and so on. Replace with empty line.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:81,avoid,avoid,81,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,// Delay slot hazard handling. Use lookahead over state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:14,hazard,hazard,14,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,1,['hazard'],['hazard']
Safety,"// Delay the cost estimation if the same nodes are reshuffling.; // If we already requested the cost of reshuffling of E1 and E2 before, no; // need to estimate another cost with the sub-Mask, instead include this; // sub-Mask into the CommonMask to estimate it later and avoid double cost; // estimation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:272,avoid,avoid,272,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,// Delayed decision on the forward pass to allow aligned barrier detection; // in the backwards traversal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:65,detect,detection,65,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['detect'],['detection']
Safety,"// Delete RooFitResult when comparison is finished to avoid noise in leak checking",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooUnitTest.cxx:54,avoid,avoid,54,roofit/roofitcore/src/RooUnitTest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooUnitTest.cxx,1,['avoid'],['avoid']
Safety,"// Delete RooPlot when comparison is finished to avoid noise in leak checking",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooUnitTest.cxx:49,avoid,avoid,49,roofit/roofitcore/src/RooUnitTest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooUnitTest.cxx,1,['avoid'],['avoid']
Safety,"// Delete RooTable when comparison is finished to avoid noise in leak checking",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooUnitTest.cxx:50,avoid,avoid,50,roofit/roofitcore/src/RooUnitTest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooUnitTest.cxx,1,['avoid'],['avoid']
Safety,"// Delete TH1 when comparison is finished to avoid noise in leak checking",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooUnitTest.cxx:45,avoid,avoid,45,roofit/roofitcore/src/RooUnitTest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooUnitTest.cxx,1,['avoid'],['avoid']
Safety,"// Delete all the elements in the map, but don't reset the elements; // to default values. This is a copy of clear(), but avoids unnecessary; // work not required in the destructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:122,avoid,avoids,122,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,1,['avoid'],['avoids']
Safety,// Delete hazard recognizers kept around for each MBB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:10,hazard,hazard,10,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,1,['hazard'],['hazard']
Safety,"// Delete objects from directory list, this in turn, recursively closes all; // sub-directories (that were allocated on the heap); // if this dir contains subdirs, we must use the slow option for Delete!; // we must avoid ""slow"" as much as possible, in particular Delete(""slow""); // with a large number of objects (eg >10^5) would take for ever.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TDirectory.cxx:216,avoid,avoid,216,core/base/src/TDirectory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TDirectory.cxx,2,['avoid'],['avoid']
Safety,// Delete stuff at the end to avoid invalid references and a nice order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:30,avoid,avoid,30,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['avoid'],['avoid']
Safety,// Delete the original allocas (which are no longer used) and the intrinsic; // calls (which are no longer valid). Doing this last avoids invalidating; // iterators.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp:131,avoid,avoids,131,interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp,1,['avoid'],['avoids']
Safety,// DemandedBits only detects dead integer uses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:21,detect,detects,21,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,1,['detect'],['detects']
Safety,"// Describes a way to handle '\0' characters when processing the string.; // rc.exe tool sometimes behaves in a weird way in postprocessing.; // If the string to be output is equivalent to a C-string (e.g. in MENU; // titles), string is (predictably) truncated after first 0-byte.; // When outputting a string table, the behavior is equivalent to appending; // '\0\0' at the end of the string, and then stripping the string; // before the first '\0\0' occurrence.; // Finally, when handling strings in user-defined resources, 0-bytes; // aren't stripped, nor do they terminate the string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp:238,predict,predictably,238,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp,1,['predict'],['predictably']
Safety,"// Destroy ASTContext and Sema.; // Now Sema is gone, PP can safely be destroyed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp:61,safe,safely,61,interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/TestAST.cpp,1,['safe'],['safely']
Safety,"// Destroy old elements: useless work for trivial types, but in case the element type's constructor; // allocates memory we need to release it here to avoid memleaks (e.g. if this is an RVec<RVec<int>>)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:151,avoid,avoid,151,tree/ntuple/v7/src/RField.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx,1,['avoid'],['avoid']
Safety,"// Detect ""(inline|export)? namespace"" in the beginning of a line.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/Format/FormatToken.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h,1,['Detect'],['Detect']
Safety,"// Detect ""Dst = VSrc * Imm + VGPR"" and convert to MK form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIShrinkInstructions.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIShrinkInstructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIShrinkInstructions.cpp,1,['Detect'],['Detect']
Safety,"// Detect ""Dst = VSrc * VGPR + Imm"" and convert to AK form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIShrinkInstructions.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIShrinkInstructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIShrinkInstructions.cpp,1,['Detect'],['Detect']
Safety,// Detect 'truncate_vector_inreg' style shuffles that pack the lower parts of; // each source element of a large type into the lowest elements of a smaller; // destination type. This is often generated during legalization.; // If the source node itself was a '*_extend_vector_inreg' node then we should; // then be able to remove it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Detect'],['Detect']
Safety,// Detect 0 and 180 degrees rotation,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,1,['Detect'],['Detect']
Safety,// Detect 32 -> 64-bit extensions where we may reuse the low sub-register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['Detect'],['Detect']
Safety,// Detect 90 and 270 degrees rotation,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,1,['Detect'],['Detect']
Safety,// Detect AMD GPUs availible on the system.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp,1,['Detect'],['Detect']
Safety,// Detect Conflicts Within a Vector,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['Detect'],['Detect']
Safety,// Detect Debian g++-multiarch-incdir.diff.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,2,['Detect'],['Detect']
Safety,// Detect MMX constant vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Detect'],['Detect']
Safety,// Detect NVIDIA GPUs availible on the system.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,1,['Detect'],['Detect']
Safety,// Detect ROCm packages built with SPACK.; // clang is installed at; // <rocm_root>/llvm-amdgpu-<rocm_release_string>-<hash>/bin directory.; // We only consider the parent directory of llvm-amdgpu package as ROCm; // installation candidate for SPACK.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp,1,['Detect'],['Detect']
Safety,// Detect SCALAR_TO_VECTOR conversions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['Detect'],['Detect']
Safety,// Detect TRUNCATE operations on bitcasts of float128 values.; // What we are looking for here is the situtation where we extract a subset; // of bits from a 128 bit float.; // This can be of two forms:; // 1) BITCAST of f128 feeding TRUNCATE; // 2) BITCAST of f128 feeding SRL (a shift) feeding TRUNCATE; // The reason this is required is because we do not have a legal i128 type; // and so we want to prevent having to store the f128 and then reload part; // of it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Detect'],['Detect']
Safety,"// Detect VTST (Vector Test Bits) = icmp ne (and (op0, op1), zero).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Detect'],['Detect']
Safety,"// Detect a SMIN, which for an i64 node will be a vselect/setcc, not a smin.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Detect'],['Detect']
Safety,"// Detect a long single-line comment, like:; // /** long long long */; // Below, '2' is the width of '*/'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,1,['Detect'],['Detect']
Safety,// Detect a multiline jsdoc comment and set DelimitersOnNewline in that case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,1,['Detect'],['Detect']
Safety,// Detect a pattern of a + b + 1 where the order doesn't matter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Detect'],['Detect']
Safety,// Detect a possible Reg+Imm addressing mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['Detect'],['Detect']
Safety,"// Detect a possible reg+reg addressing mode, but only if we haven't already; // detected a Reg+Imm one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,2,"['Detect', 'detect']","['Detect', 'detected']"
Safety,"// Detect a run of memory tagging instructions for adjacent stack frame slots,; // and replace them with a shorter instruction sequence:; // * replace STG + STG with ST2G; // * replace STGloop + STGloop with STGloop; // This code needs to run when stack slot offsets are already known, but before; // FrameIndex operands in STG instructions are eliminated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['Detect'],['Detect']
Safety,// Detect a triangular shape:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,1,['Detect'],['Detect']
Safety,// Detect all regions in function and build the region tree.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:3,Detect,Detect,3,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,1,['Detect'],['Detect']
Safety,// Detect all regions starting with bb 'entry'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:3,Detect,Detect,3,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,1,['Detect'],['Detect']
Safety,"// Detect an interleave shuffle and lower to; // (vmaccu.vx (vwaddu.vx lohalf(V1), lohalf(V2)), lohalf(V2), (2^eltbits - 1))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['Detect'],['Detect']
Safety,// Detect and consume the header indicator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['Detect'],['Detect']
Safety,// Detect and handle the case where the decl might be an implicit; // member.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['Detect'],['Detect']
Safety,// Detect bit packing failure; // Always track SP. This avoids the implicit clobbering caused by regmasks; // from affectings its values. (LiveDebugValues disbelieves calls and; // regmasks that claim to clobber SP).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,2,"['Detect', 'avoid']","['Detect', 'avoids']"
Safety,// Detect bitcasts between element or subvector extraction to x86mmx.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Detect'],['Detect']
Safety,// Detect bitcasts from FP_TO_SINT to x86mmx.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Detect'],['Detect']
Safety,// Detect bitcasts of 64-bit build vectors and convert to a; // MMX UNPCK/PSHUFW which takes MMX type inputs with the value in the; // lowest element.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Detect'],['Detect']
Safety,// Detect bitcasts to x86mmx low word.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Detect'],['Detect']
Safety,// Detect calls to free.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,1,['Detect'],['Detect']
Safety,// Detect calls to vfork and split execution appropriately.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VforkChecker.cpp,1,['Detect'],['Detect']
Safety,"// Detect cases where Hi is (SRA Lo, 31) which means Hi is Lo sign extended.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['Detect'],['Detect']
Safety,// Detect cases where a ref-qualified method cannot be invoked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['Detect'],['Detect']
Safety,"// Detect cases where we're performing call slot forwarding, but; // happen to be using a load-store pair to implement it, rather than; // a memcpy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['Detect'],['Detect']
Safety,// Detect collisions between string and numeric variables when the former; // is created later than the latter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['Detect'],['Detect']
Safety,// Detect collisions between string and numeric variables when the latter; // is created later than the former.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['Detect'],['Detect']
Safety,// Detect collisions between string and numeric variables when the; // former is created later than the latter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['Detect'],['Detect']
Safety,// Detect color from terminal type unless the user passed the --color option.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/WithColor.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Support/WithColor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/WithColor.cpp,1,['Detect'],['Detect']
Safety,"// Detect common error, from old metadata syntax.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['Detect'],['Detect']
Safety,// Detect common single-character typos and resume.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['Detect'],['Detect']
Safety,// Detect constant shift amounts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Detect'],['Detect']
Safety,// Detect cycles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,1,['Detect'],['Detect']
Safety,"// Detect different types of framework style paths:; //; // ...Foo.framework/{Headers,PrivateHeaders}; // ...Foo.framework/Versions/{A,Current}/{Headers,PrivateHeaders}; // ...Foo.framework/Frameworks/Nested.framework/{Headers,PrivateHeaders}; // ...<other variations with 'Versions' like in the above path>; //; // and some other variations among these lines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,1,['Detect'],['Detect']
Safety,"// Detect dot pseudo destructor calls on pointer objects, e.g.:; // Foo *foo;; // foo.~Foo();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['Detect'],['Detect']
Safety,"// Detect duplicate case ranges, which usually don't exist at all in; // the first place.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['Detect'],['Detect']
Safety,"// Detect either of the patterns:; //; // 1. (medlow pattern):; // lui vreg1, %hi(s); // addi vreg2, vreg1, %lo(s); //; // 2. (medany pattern):; // .Lpcrel_hi1:; // auipc vreg1, %pcrel_hi(s); // addi vreg2, vreg1, %pcrel_lo(.Lpcrel_hi1); //; // The pattern is only accepted if:; // 1) The first instruction has only one use, which is the ADDI.; // 2) The address operands have the appropriate type, reflecting the; // lowering of a global address or constant pool using medlow or medany.; // 3) The offset value in the Global Address or Constant Pool is 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,1,['Detect'],['Detect']
Safety,"// Detect elements that are inserted more than once at different scopes,; // causing a crash on the reader destruction, as the element is already; // deleted from other scope. Helper for CodeView reader.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVReader.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVReader.cpp,1,['Detect'],['Detect']
Safety,// Detect equal or self arguments,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['Detect'],['Detect']
Safety,// Detect error if 2nd arg were present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['Detect'],['Detect']
Safety,"// Detect errors in the header and report any that are found. If we make it; // past this without errors, we know we have a good magic value, a supported; // version number, verified address offset size and a valid UUID size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp,1,['Detect'],['Detect']
Safety,// Detect finite numbers of f80 by checking individual classes because; // they have different settings of the explicit integer bit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['Detect'],['Detect']
Safety,// Detect floating point reduction only when it can be reordered.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,1,['Detect'],['Detect']
Safety,// Detect general splats with undefs.; // TODO: Do we need to handle NumEltsBits > SplatBitWidth splitting?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,1,['Detect'],['Detect']
Safety,"// Detect identical elements in the shufflevector result, even though; // findScalarElement cannot tell us what that element is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,1,['Detect'],['Detect']
Safety,"// Detect if both types are (ptr to) class, and note any incompleteness.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,1,['Detect'],['Detect']
Safety,"// Detect if the class has a 'new' Merge function.; // Detect if the class or one of its parent has a DirectoryAutoAdd",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:3,Detect,Detect,3,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,2,['Detect'],['Detect']
Safety,"// Detect if the class has a 'new' Merge function.; // bool hasMethod = cl.HasMethod(""DirectoryAutoAdd"");; // Detect if the class or one of its parent has a DirectoryAutoAdd",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:3,Detect,Detect,3,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,2,['Detect'],['Detect']
Safety,"// Detect if the class has a ClassDef",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:3,Detect,Detect,3,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['Detect'],['Detect']
Safety,"// Detect if the class has a DirectoryAutoAdd; // Detect if the class or one of its parent has a DirectoryAutoAdd",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:3,Detect,Detect,3,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,2,['Detect'],['Detect']
Safety,"// Detect if the class has an old fashion Merge function.; // Detect if the class or one of its parent has a DirectoryAutoAdd",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:3,Detect,Detect,3,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,2,['Detect'],['Detect']
Safety,"// Detect if there are non-zero column numbers in the profile. If not,; // treat all column numbers as 0 when matching (i.e. ignore any non-zero; // columns in the IR). The profiled binary might have been built with; // column numbers disabled, for example.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,1,['Detect'],['Detect']
Safety,// Detect if we have any capture size requiring runtime evaluation of the; // size so that a constant array could be eventually used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['Detect'],['Detect']
Safety,"// Detect incomplete types, relying on the fact that their size is unknown.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:3,Detect,Detect,3,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['Detect'],['Detect']
Safety,// Detect inherently cold functions and mark them as such.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,1,['Detect'],['Detect']
Safety,"// Detect invalid DBG_VALUE instructions, with a debug-use of a virtual; // register that hasn't been defined yet. If we do not remove those here, then; // the re-insertion of the DBG_VALUE instruction after register allocation; // will be incorrect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,1,['Detect'],['Detect']
Safety,// Detect libffi,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp,1,['Detect'],['Detect']
Safety,// Detect mmx extraction of all bits as a i64. It works better as a bitcast.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Detect'],['Detect']
Safety,// Detect mmx to i32 conversion through a v2i32 elt extract.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Detect'],['Detect']
Safety,"// Detect overflow based on whether the value is signed. If signed; // and if the value is too large, emit a warning ""integer constant is so; // large that it is unsigned"" e.g. on 12345678901234567890 where intmax_t; // is 64-bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,1,['Detect'],['Detect']
Safety,// Detect overflow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:3,Detect,Detect,3,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,1,['Detect'],['Detect']
Safety,"// Detect overlap, handle above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalUnion.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalUnion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervalUnion.cpp,1,['Detect'],['Detect']
Safety,// Detect overlapping contributions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,1,['Detect'],['Detect']
Safety,"// Detect patterns for large offsets that are passed into an ADD instruction.; // If the pattern is found, updates the offset in Hi and Lo instructions; // and deletes TailAdd and the instructions that produced the offset.; //; // Base address lowering is of the form:; // Hi: lui vreg1, %hi(s); // Lo: addi vreg2, vreg1, %lo(s); // / \; // / \; // / \; // / The large offset can be of two forms: \; // 1) Offset that has non zero bits in lower 2) Offset that has non zero; // 12 bits and upper 20 bits bits in upper 20 bits only; // OffseLUI: lui vreg3, 4; // OffsetTail: addi voff, vreg3, 188 OffsetTail: lui voff, 128; // \ /; // \ /; // \ /; // \ /; // TailAdd: add vreg4, vreg2, voff",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,1,['Detect'],['Detect']
Safety,"// Detect patterns for offsets that are passed into a SHXADD instruction.; // The offset has 1, 2, or 3 trailing zeros and fits in simm13, simm14, simm15.; // The constant is created with addi voff, x0, C, and shXadd is used to; // fill insert the trailing zeros and do the addition.; // If the pattern is found, updates the offset in Hi and Lo instructions; // and deletes TailShXAdd and the instructions that produced the offset.; //; // Hi: lui vreg1, %hi(s); // Lo: addi vreg2, vreg1, %lo(s); // OffsetTail: addi voff, x0, C; // TailAdd: shXadd vreg4, voff, vreg2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,1,['Detect'],['Detect']
Safety,"// Detect patterns of a0,a1,a2,a3,b0,b1,b2,b3,c0,c1,c2,c3,d0,d1,d2,d3 from; // v4i32s. This is really a truncate, which we can construct out of (legal); // concats and truncate nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['Detect'],['Detect']
Safety,// Detect profile mismatch for profile staleness metrics report.; // Skip reporting the metrics for imported functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['Detect'],['Detect']
Safety,// Detect reduction patterns,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,['Detect'],['Detect']
Safety,// Detect sample with call stack,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,1,['Detect'],['Detect']
Safety,// Detect self copies - these can result from running AADB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,1,['Detect'],['Detect']
Safety,// Detect self-referential nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['Detect'],['Detect']
Safety,// Detect self-referential values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,1,['Detect'],['Detect']
Safety,// Detect shifts/rotates by a scalar amount and convert them into; // V*_BY_SCALAR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['Detect'],['Detect']
Safety,// Detect shuffles which can be re-expressed as vector selects; these are; // shuffles in which each element in the destination is taken from an element; // at the corresponding index in either source vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['Detect'],['Detect']
Safety,"// Detect spurious null characters, which are likely errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,4,['Detect'],['Detect']
Safety,// Detect supported compressed encodings and accept all.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Debuginfod/HTTPClient.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Debuginfod/HTTPClient.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Debuginfod/HTTPClient.cpp,1,['Detect'],['Detect']
Safety,// Detect the PSVVersion by looking at the size field.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/DXContainer.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Object/DXContainer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/DXContainer.cpp,1,['Detect'],['Detect']
Safety,// Detect the architecture from the object file. We usually don't need OS; // info to lookup a target and create register info.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewReader.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewReader.cpp,2,['Detect'],['Detect']
Safety,// Detect the archive format from the object or bitcode file. This helps; // assume the archive format when creating or editing archives in the case; // one isn't explicitly set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ArchiveWriter.h:3,Detect,Detect,3,interpreter/llvm-project/llvm/include/llvm/Object/ArchiveWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ArchiveWriter.h,1,['Detect'],['Detect']
Safety,"// Detect the case where a call result is converted from floating-point to; // to bool, and the final argument to the call is converted from bool, to; // discover this typo:; //; // bool b = fabs(x < 1.0); // should be ""bool b = fabs(x) < 1.0;""; //; // FIXME: This is an incredibly special case; is there some more general; // way to detect this class of misplaced-parentheses bug?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,2,"['Detect', 'detect']","['Detect', 'detect']"
Safety,"// Detect the case where macros are used to generate lambdas or; // function bodies, e.g.:; // auto my_lambda = MACRO((Type *type, int i) { .. body .. });",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['Detect'],['Detect']
Safety,// Detect the distribute schedule kind and chunk.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['Detect'],['Detect']
Safety,"// Detect the following pattern:; //; // %1 = zext <N x i8> %a to <N x i32>; // %2 = zext <N x i8> %b to <N x i32>; // %3 = add nuw nsw <N x i32> %1, <i32 1 x N>; // %4 = add nuw nsw <N x i32> %3, %2; // %5 = lshr <N x i32> %N, <i32 1 x N>; // %6 = trunc <N x i32> %5 to <N x i8>; //; // In AVX512, the last instruction can also be a trunc store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Detect'],['Detect']
Safety,// Detect the highest available version of libc++ in include path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h:3,Detect,Detect,3,interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,1,['Detect'],['Detect']
Safety,// Detect the host and set code model to small.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithCustomObjectLinkingLayer/LLJITWithCustomObjectLinkingLayer.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithCustomObjectLinkingLayer/LLJITWithCustomObjectLinkingLayer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithCustomObjectLinkingLayer/LLJITWithCustomObjectLinkingLayer.cpp,3,['Detect'],['Detect']
Safety,// Detect the if-else blocks,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp,1,['Detect'],['Detect']
Safety,// Detect the loop schedule kind and chunk.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['Detect'],['Detect']
Safety,// Detect the path style in use by checking the first separator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,1,['Detect'],['Detect']
Safety,// Detect the unusual situation where an inline version is shadowed by a; // non-inline version. In that case we should pick the external one; // everywhere. That's GCC behavior too.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['Detect'],['Detect']
Safety,"// Detect the unusual situation where an inline version is shadowed by a; // non-inline version. In that case we should pick the external one; // everywhere. That's GCC behavior too. Unfortunately, I cannot find a way; // to detect that situation before we reach codegen, so do some late; // replacement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:3,Detect,Detect,3,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,2,"['Detect', 'detect']","['Detect', 'detect']"
Safety,"// Detect triangle first. In case of a triangle, one of the blocks TB/FB; // can fall through into the other, in other words, it will be executed; // in both cases. We only want to predicate the block that is executed; // conditionally.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,1,['Detect'],['Detect']
Safety,"// Detect vfuncs that are referenced as ""relative pointers"" which are used; // in Swift vtables, i.e. entries in the form of:; //; // i32 trunc (i64 sub (i64 ptrtoint @f, i64 ptrtoint ...)) to i32); //; // In this case, replace the whole ""sub"" expression with constant 0 to; // avoid leaving a weird sub(0, symbol) expression behind.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,2,"['Detect', 'avoid']","['Detect', 'avoid']"
Safety,"// Detect when ""or"" is used to add an offset to a stack object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['Detect'],['Detect']
Safety,"// Detect when we have multiple callers of this callsite that; // have already been assigned to specific, and different, clones; // of OrigFunc (due to other unrelated callsites in Func they; // reach via call contexts). Is this Clone of callsite Node; // assigned to a different clone of OrigFunc? If so, clone Node; // again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['Detect'],['Detect']
Safety,"// Detect whether RD is a bitfield extract (sign- or zero-extended) of; // some register from the AVs set. Create a new corresponding instruction; // at the location of MI. The intent is to recognize situations where; // a sequence of instructions performs an operation that is equivalent to; // an extract operation, such as a shift left followed by a shift right.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,1,['Detect'],['Detect']
Safety,"// Detect whether any atomics will be lowered, since there is no way to tell; // whether the LowerAtomic pass lowers e.g. stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyTargetMachine.cpp,1,['Detect'],['Detect']
Safety,"// Detect whether this is a recurrence with a start value and some number of; // backedge values. We'll check whether we can push the freeze through the; // backedge values (possibly dropping poison flags along the way) until we; // reach the phi again. In that case, we can move the freeze to the start; // value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['Detect'],['Detect']
Safety,// Detect which mov lane this would be from the first non-undef element.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Detect,Detect,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Detect'],['Detect']
Safety,"// DetectDeadLanes may mark register uses as undef without removing; // them, in which case a non-phi instruction using the original register; // may exist in the Endif block even though the register is not live; // into it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp:3,Detect,DetectDeadLanes,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp,1,['Detect'],['DetectDeadLanes']
Safety,// Detected/marked divergent values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:3,Detect,Detected,3,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,1,['Detect'],['Detected']
Safety,"// Detector dimensions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyDetector.h:3,Detect,Detector,3,test/RootShower/MyDetector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyDetector.h,1,['Detect'],['Detector']
Safety,"// Detector max. boundaries",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyDetector.h:3,Detect,Detector,3,test/RootShower/MyDetector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyDetector.h,1,['Detect'],['Detector']
Safety,"// Detector min. boundaries",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyDetector.h:3,Detect,Detector,3,test/RootShower/MyDetector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyDetector.h,1,['Detect'],['Detector']
Safety,"// Detector structure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyDetector.h:3,Detect,Detector,3,test/RootShower/MyDetector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyDetector.h,1,['Detect'],['Detector']
Safety,// Detects if a memory operation has an erroneous base register modification.; // Memory operations are detected by matching the types of operands.; //; // TODO: This test is focussed on one specific instance (ld/st).; // Extend it to handle more cases or be more robust.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp:3,Detect,Detects,3,interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/AsmParser/LanaiAsmParser.cpp,2,"['Detect', 'detect']","['Detects', 'detected']"
Safety,// Detects regions in F.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:3,Detect,Detects,3,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,1,['Detect'],['Detects']
Safety,"// Determine if any of our values are mapped. This is uncommon, so we want; // to avoid the range scan if not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:82,avoid,avoid,82,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,1,['avoid'],['avoid']
Safety,"// Determine if this is a vector of ConstantFPs and if so, return the minimal; // type we can safely truncate all elements to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:94,safe,safely,94,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['safe'],['safely']
Safety,// Determine the maximum depth of any itinerary. This determines the depth of; // the scoreboard. We always make the scoreboard at least 1 cycle deep to; // avoid dealing with the boundary condition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:157,avoid,avoid,157,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,1,['avoid'],['avoid']
Safety,"// Determine the previous frame's address. If FrameSize can't be; // represented as 16 bits or we need special alignment, then we load the; // previous frame's address from 0(SP). Why not do an addis of the hi?; // Because R0 is our only safe tmp register and addi/addis treat R0 as zero.; // Constructing the constant and adding would take 3 instructions.; // Fortunately, a frame greater than 32K is rare.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:238,safe,safe,238,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,1,['safe'],['safe']
Safety,"// Determine whether the original StartBB post-dominates all of the blocks we; // visited. If not, insert a sentinel indicating that most optimizations are; // not safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:164,safe,safe,164,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,1,['safe'],['safe']
Safety,"// Determine whether the prefix qualifiers of the NewName should be ignored.; // Normally, we set it to true for the symbol declaration and definition to; // avoid adding prefix qualifiers.; // For example, if it is true and NewName is ""a::b::foo"", then the symbol; // occurrence which the RenameInfo points to will be renamed to ""foo"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:158,avoid,avoid,158,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,1,['avoid'],['avoid']
Safety,"// Determine whether this is a valid expression. If not, we will hit; // a parse error one way or another. In that case, tell the caller that; // this is ambiguous. Typo-correct to type and expression keywords and; // to types and identifiers, in order to try to recover from errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:263,recover,recover,263,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['recover'],['recover']
Safety,// Determine whether we've already imported this decl.; // FriendDecl is not a NamedDecl so we cannot use lookup.; // We try to maintain order and count of redundant friend declarations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:156,redund,redundant,156,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['redund'],['redundant']
Safety,"// Determine which buffer to use, so that we can avoid a memcpy in case of; // the basket was not compressed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:49,avoid,avoid,49,tree/tree/src/TBasket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx,1,['avoid'],['avoid']
Safety,"// Determine which is the most common successor. If we have many inputs and; // this block is a switch, we want to start by threading the batch that goes; // to the most popular destination first. If we only know about one; // threadable destination (the common case) we can avoid this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:275,avoid,avoid,275,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['avoid'],['avoid']
Safety,"// Determining when to avoid vperm is tricky. Many things affect the cost; // of vperm, particularly how many times the perm mask needs to be; // computed. For example, if the perm mask can be hoisted out of a loop or; // is already used (perhaps because there are multiple permutes with the; // same shuffle mask?) the vperm has a cost of 1. OTOH, hoisting the; // permute mask out of the loop requires an extra register.; //; // As a compromise, we only emit discrete instructions if the shuffle can; // be generated in 3 or fewer operations. When we have loop information; // available, if this block is within a loop, we should avoid using vperm; // for 3-operation perms and use a constant pool load instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:23,avoid,avoid,23,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['avoid'],['avoid']
Safety,"// Diagnose a missing typename if this resolved unambiguously to a type in; // a dependent context. If we can recover with a type, downgrade this to; // a warning in Microsoft compatibility mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:110,recover,recover,110,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['recover'],['recover']
Safety,// Diagnose if we've recovered from an ill-formed 'auto' storage class; // specifier in a pre-C++11 dialect of C++ or in a pre-C23 dialect of C.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:21,recover,recovered,21,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,1,['recover'],['recovered']
Safety,// Did we exhaust the string or encounter an error that; // we can recover from?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:67,recover,recover,67,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,3,['recover'],['recover']
Safety,"// Dig through any refs to refs, collapsing the ReferenceTypes as we go. The; // rule here is rvalue ref to rvalue ref collapses to a rvalue ref, and any; // other combination collapses to a lvalue ref.; //; // A combination of a TemplateForwardReference and a back-ref Substitution; // from an ill-formed string may have created a cycle; use cycle detection to; // avoid looping forever.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h:349,detect,detection,349,interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h,2,"['avoid', 'detect']","['avoid', 'detection']"
Safety,"// Direct copy from SGPR to AGPR is not possible. To avoid creation; // of exploded copies SGPR->VGPR->AGPR in the copyPhysReg() later,; // create a copy here and track if we already have such a copy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp:53,avoid,avoid,53,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,1,['avoid'],['avoid']
Safety,// Directly mangle mapped operands into the string. Each operand is; // identified by a '$' sign followed by a byte identifying the number of the; // operand. We add one to the index to avoid zero bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp:186,avoid,avoid,186,interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp,1,['avoid'],['avoid']
Safety,// Disable abort and fall back to SDAG silently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:11,abort,abort,11,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['abort'],['abort']
Safety,"// Disable autoload to avoid potential infinite recursion",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:23,avoid,avoid,23,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['avoid'],['avoid']
Safety,"// Disable buffering for console devices. Console output is re-encoded from; // UTF-8 to UTF-16 on Windows, and buffering it would require us to split the; // buffer on a valid UTF-8 codepoint boundary. Terminal buffering is disabled; // below on most other OSs, so do the same thing on Windows and avoid that; // complexity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp:299,avoid,avoid,299,interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,1,['avoid'],['avoid']
Safety,"// Disable include reordering across blocks in Chromium code.; // - clang-format tries to detect that foo.h is the ""main"" header for; // foo.cc and foo_unittest.cc via IncludeIsMainRegex. However, Chromium; // uses many other suffices (_win.cc, _mac.mm, _posix.cc, _browsertest.cc,; // _private.cc, _impl.cc etc) in different permutations; // (_win_browsertest.cc) so disable this until IncludeIsMainRegex has a; // better default for Chromium code.; // - The default for .cc and .mm files is different (r357695) for Google style; // for the same reason. The plan is to unify this again once the main; // header detection works for Google's ObjC code, but this hasn't happened; // yet. Since Chromium has some ObjC code, switching Chromium is blocked; // on that.; // - Finally, ""If include reordering is harmful, put things in different; // blocks to prevent it"" has been a recommendation for a long time that; // people are used to. We'll need a dev education push to change this to; // ""If include reordering is harmful, put things in a different block and; // _prepend that with a comment_ to prevent it"" before changing behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:90,detect,detect,90,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,2,['detect'],"['detect', 'detection']"
Safety,// Disable the abort but emit a diagnostic on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:15,abort,abort,15,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,1,['abort'],['abort']
Safety,// Disable the abort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:15,abort,abort,15,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,1,['abort'],['abort']
Safety,// Disambiguate headers that are meant to be header units from those; // intended to be PCH. Avoid missing '.h' cases that are counted as; // C headers by default - we know we are in C++ mode and we do not; // want to issue a complaint about compiling things in the wrong mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:93,Avoid,Avoid,93,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['Avoid'],['Avoid']
Safety,// Discard the thread storage class specifier to recover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:49,recover,recover,49,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,1,['recover'],['recover']
Safety,// Distinguish if we are called from scheduler or hazard recognizer,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.h:50,hazard,hazard,50,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.h,1,['hazard'],['hazard']
Safety,"// Distribute add(vecreduce(load(Y)), vecreduce(load(Z))); // Or add(add(X, vecreduce(load(Y))), vecreduce(load(Z))); // by ascending load offsets. This can help cores prefetch if the order of; // loads is more predictable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:211,predict,predictable,211,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['predict'],['predictable']
Safety,"// Distributed indexing detected that nothing from the module is needed; // for the final linking. So we can skip the compilation. We sill need to; // output an empty object file to make sure that a linker does not fail; // trying to read it. Also for some features, like CFI, we must skip; // the compilation as CombinedIndex does not contain all required; // information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:24,detect,detected,24,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,1,['detect'],['detected']
Safety,"// Divide by the absolute step amount. If the range is not a multiple of; // the step size, rounding-up the effective upper bound ensures that the; // last iteration is included.; // Note that the rounding-up may cause an overflow in a temporry that; // could be avoided, but would have occurred in a C-style for-loop as; // well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:263,avoid,avoided,263,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['avoid'],['avoided']
Safety,// Division operators need a safe divisor on masked-off lanes (1).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:29,safe,safe,29,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,1,['safe'],['safe']
Safety,"// Do NOT branch on overflow to avoid jumping code, just add 0 if there was; // no overflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/ranluxpp/helpers.h:32,avoid,avoid,32,math/mathcore/src/ranluxpp/helpers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/ranluxpp/helpers.h,2,['avoid'],['avoid']
Safety,"// Do PHI translation to get its value in the predecessor if necessary. The; // returned pointer (if non-null) is guaranteed to dominate UnavailablePred.; // We do the translation for each edge we skipped by going from Load's block; // to LoadBB, otherwise we might miss pieces needing translation.; // If all preds have a single successor, then we know it is safe to insert; // the load on the pred (?!?), so we can insert code to materialize the; // pointer if it is not available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:360,safe,safe,360,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['safe'],['safe']
Safety,"// Do a single-step desugar, aborting the loop if the type isn't; // sugared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:29,abort,aborting,29,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,1,['abort'],['aborting']
Safety,"// Do alignment, specialized to power of 2 and for signed ints,; // avoiding having to do a C-style cast from uint_64t to int when; // using alignTo from include/llvm/Support/MathExtras.h.; // FIXME: Move this function to include/MathExtras.h?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp:68,avoid,avoiding,68,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,1,['avoid'],['avoiding']
Safety,// Do an unsafe store of null into self.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:9,unsafe,unsafe,9,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['unsafe'],['unsafe']
Safety,// Do as a single replacement to avoid rewalking use lists.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,avoid,avoid,33,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"// Do not add undef debug values, as they are redundant information in; // the location list entries. An undef debug results in an empty location; // description. If there are any non-undef fragments then padding pieces; // with empty location descriptions will automatically be inserted, and if; // all fragments are undef then the whole location list entry is; // redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:46,redund,redundant,46,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,2,['redund'],['redundant']
Safety,// Do not check for -fno-fast-math or -fno-unsafe-math when -Ofast passed; // (to keep the linker options consistent with gcc and clang itself).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp:43,unsafe,unsafe-math,43,interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp,1,['unsafe'],['unsafe-math']
Safety,// Do not cover already-covered lanes to avoid creating cycles; // in copy bundles (= bundle contains copies that write to the; // registers).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:41,avoid,avoid,41,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,1,['avoid'],['avoid']
Safety,"// Do not defer instantiations of constexpr functions, to avoid the; // expression evaluator needing to call back into Sema if it sees a; // call to such a function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:58,avoid,avoid,58,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['avoid'],['avoid']
Safety,"// Do not enter a scope for the brace, as the arguments are in the same scope; // (the function body) as the body itself. Instead, just read the statement; // list and put it into a CompoundStmt for safe keeping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:199,safe,safe,199,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['safe'],['safe']
Safety,// Do not expand if the total number of loads is larger than what the; // target allows. Note that it's important that we exit before completing; // the expansion to avoid using a ton of memory to store the expansion for; // large sizes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:166,avoid,avoid,166,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,1,['avoid'],['avoid']
Safety,// Do not increase the number of redundant components: that would remove; // useful parts of already-visited paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:33,redund,redundant,33,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,1,['redund'],['redundant']
Safety,"// Do not instrument the rtti proxies with hwasan to avoid a duplicate; // symbol error. Aliases generated by hwasan will retain the same namebut; // the addresses they are set to may have different tags from different; // compilation units. We don't run into this without hwasan because the; // proxies are in comdat groups, but those aren't propagated to the alias.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp:53,avoid,avoid,53,interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp,1,['avoid'],['avoid']
Safety,"// Do not iterate past PHI nodes to avoid infinite loops. This can; // make the final set a bit less accurate, but the removable register; // sets are an approximation anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:36,avoid,avoid,36,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,1,['avoid'],['avoid']
Safety,"// Do not process PHI if there is one (or fewer) predecessor from region.; // If PHI has exactly one predecessor from region, only this one incoming; // will be replaced on codeRepl block, so it should be safe to skip PHI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:205,safe,safe,205,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,1,['safe'],['safe']
Safety,// Do not rebuild lambdas to avoid creating a new type.; // Lambdas have already been processed inside their eval context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,avoid,avoid,29,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['avoid'],['avoid']
Safety,"// Do not recursively visit the children of this expression. Profiling the; // body would result in unnecessary work, and is not safe to do during; // deserialization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp:129,safe,safe,129,interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp,1,['safe'],['safe']
Safety,// Do not risk on moving increment into a child loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:10,risk,risk,10,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['risk'],['risk']
Safety,"// Do not save RA to the SCS if it's not saved to the regular stack,; // i.e. RA is not at risk of being overwritten.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:91,risk,risk,91,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['risk'],['risk']
Safety,// Do not shrink True16 instructions pre-RA to avoid the restriction in; // register allocation from only being able to use 128 VGPRs,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNDPPCombine.cpp:47,avoid,avoid,47,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNDPPCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNDPPCombine.cpp,1,['avoid'],['avoid']
Safety,// Do not sink MI if it might be used to optimize a redundant compare.; // We heuristically only look at the instruction immediately following MI to; // avoid potentially searching the entire basic block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:52,redund,redundant,52,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,// Do not treat tail or sibling call sites as safe points. This is; // legal since any arguments passed to the callee which live in the; // remnants of the callers frame will be owned and updated by the; // callee if required.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:46,safe,safe,46,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,1,['safe'],['safe']
Safety,// Do not try to if-convert if the condition has a high chance of being; // predictable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:76,predict,predictable,76,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,1,['predict'],['predictable']
Safety,// Do not try to recover if it is already building a recovery call.; // This stops infinite loops for template instantiations like; //; // template <typename T> auto foo(T t) -> decltype(foo(t)) {}; // template <typename T> auto foo(T t) -> decltype(foo(&t)) {},MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:17,recover,recover,17,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,2,['recover'],"['recover', 'recovery']"
Safety,// Do not unreserve dispatch hazard resource buffers. Wait until all; // pipeline resources have been freed too.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/ResourceManager.cpp:29,hazard,hazard,29,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/ResourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/ResourceManager.cpp,1,['hazard'],['hazard']
Safety,"// Do not use TClass::GetClass to avoid any risk of autoloading.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClassTable.cxx:34,avoid,avoid,34,core/cont/src/TClassTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClassTable.cxx,2,"['avoid', 'risk']","['avoid', 'risk']"
Safety,"// Do not use f64 to lower memcpy if source is string constant. It's; // better to use i32 to avoid the loads.; // Also, do not use f64 to lower memset unless this is a memset of zeros.; // The gymnastics of splatting a byte value into an XMM register and then; // only using 8-byte stores (because this is a CPU with slow unaligned; // 16-byte accesses) makes that a loser.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:94,avoid,avoid,94,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['avoid'],['avoid']
Safety,"// Do not use frame virtual registers. They used to be used for SGPRs, but; // once we reach PrologEpilogInserter, we can no longer spill SGPRs. If the; // scavenger fails, we can increment/decrement the necessary SGPRs to avoid a; // spill.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:223,avoid,avoid,223,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['avoid'],['avoid']
Safety,// Do one-time initialization in a thread-safe way.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Debug.cpp:42,safe,safe,42,interpreter/llvm-project/llvm/lib/Support/Debug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Debug.cpp,1,['safe'],['safe']
Safety,// Do shorten memory intrinsics.; // FIXME: Add memmove if it's also safe to transform.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:69,safe,safe,69,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['safe'],['safe']
Safety,// Do some sanity checking on the pattern we're about to match.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:11,sanity check,sanity checking,11,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['sanity check'],['sanity checking']
Safety,// Do the actual prediction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:17,predict,prediction,17,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,2,['predict'],['prediction']
Safety,// Do the transformation here to avoid potentially introducing an infinite; // loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:33,avoid,avoid,33,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['avoid'],['avoid']
Safety,"// Do we already have a DominatorTree avaliable from the previous pass?; // Note that we should *NOT* require it, to avoid the case where we end up; // not needing it, but the legacy PM would have computed it for us anyways.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:117,avoid,avoid,117,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,1,['avoid'],['avoid']
Safety,// Does sinking this instruction render previous PHIs redundant?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:54,redund,redundant,54,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,1,['redund'],['redundant']
Safety,"// Does the function use a red zone? If it does, then we can't risk messing; // with the stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:63,risk,risk,63,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['risk'],['risk']
Safety,"// Does the initial scan of the directory - directly calling Receiver,; // bypassing the Queue. Both InitialScan and EventReceivingLoop use Receiver; // which isn't necessarily thread-safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp:184,safe,safe,184,interpreter/llvm-project/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp,1,['safe'],['safe']
Safety,// Does the module have any calls to the llvm.experimental.guard intrinsic; // at all? If not we can avoid scanning instructions looking for guards.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:101,avoid,avoid,101,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,1,['avoid'],['avoid']
Safety,"// Doing a tail call should be safe if there are no successors, because either; // we have a returning block or the end of the block is unreachable, so the; // restore will be eliminated regardless.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:31,safe,safe,31,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['safe'],['safe']
Safety,// Don't abort for terminator unless the level is really high,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:9,abort,abort,9,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['abort'],['abort']
Safety,// Don't add a redundant or conflicting attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:15,redund,redundant,15,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,1,['redund'],['redundant']
Safety,"// Don't add code regions for the area covered by expansion regions.; // This not only suppresses redundant regions, but sometimes prevents; // creating regions with wrong counters if, for example, a statement's; // body ends at the end of a nested macro.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp:98,redund,redundant,98,interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,1,['redund'],['redundant']
Safety,"// Don't allow globals to be tagged with something that looks like a; // short-granule tag, otherwise we lose inter-granule overflow detection, as; // the fast path shadow-vs-address check succeeds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:133,detect,detection,133,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,1,['detect'],['detection']
Safety,// Don't allow repeated splitting as a safe guard against looping.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:39,safe,safe,39,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,2,['safe'],['safe']
Safety,"// Don't allow specializing in the wrong class during error recovery.; // Otherwise, things can go horribly wrong.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:60,recover,recovery,60,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['recover'],['recovery']
Safety,// Don't alter Loop headers and latches to ensure another pass can; // detect and transform nested loops later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:71,detect,detect,71,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['detect'],['detect']
Safety,"// Don't assume any minimum vector size when PSTATE.SM may not be 0, because; // we don't yet support streaming-compatible codegen support that we trust; // is safe for functions that may be executed in streaming-SVE mode.; // By returning '0' here, we disable vectorization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h:160,safe,safe,160,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h,1,['safe'],['safe']
Safety,"// Don't avoid identity copies here (i.e. if the source and the destination; // are the same registers). It is actually better to generate them here,; // since this would cause the copy to potentially be predicated in the next; // step. The predication will remove such a copy if it is unable to; /// predicate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:9,avoid,avoid,9,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,1,['avoid'],['avoid']
Safety,"// Don't bother if we won't track subregister liveness later. This pass is; // required for correctness if subregister liveness is enabled because the; // register coalescer cannot deal with hidden dead defs. However without; // subregister liveness enabled, the expected benefits of this pass are small; // so we safe the compile time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp:314,safe,safe,314,interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DetectDeadLanes.cpp,1,['safe'],['safe']
Safety,"// Don't bother with single bits.; // If this is at the root of the pattern, we emit a redundant; // CheckOpcode so that the following checks get factored properly under; // a single opcode check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp:87,redund,redundant,87,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,1,['redund'],['redundant']
Safety,"// Don't break string literals inside preprocessor directives (except for; // #define directives, as their contents are stored in separate lines and; // are not affected by this check).; // This way we avoid breaking code with line directives and unknown; // preprocessor directives that contain long string literals.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:202,avoid,avoid,202,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['avoid'],['avoid']
Safety,// Don't call the normal error handler. It may allocate memory. Directly write; // an OOM to stderr and abort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp:104,abort,abort,104,interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,1,['abort'],['abort']
Safety,"// Don't change anything, let the calling column flush itself; // TODO(jblomer): we may consider skipping the column in TryEvict and thus avoiding erase+insert",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx:138,avoid,avoiding,138,tree/ntuple/v7/src/RPageStorage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx,1,['avoid'],['avoiding']
Safety,// Don't check ObjCInterfaceDecl as interfaces are named and mismatches can be; // detected in VisitObjCInterfaceDecl. Here we are looking for redeclarations; // in extensions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:83,detect,detected,83,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['detect'],['detected']
Safety,// Don't check hazards for non-machineinstr Nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:15,hazard,hazards,15,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,1,['hazard'],['hazards']
Safety,// Don't combine AND since emitComparison converts the AND to an ANDS; // (a.k.a. TST) and the test in the test bit and branch instruction; // becomes redundant. This would also increase register pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:151,redund,redundant,151,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['redund'],['redundant']
Safety,"// Don't count dbg.value against the ScanLimit, to avoid perturbing the; // generated code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:51,avoid,avoid,51,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,2,['avoid'],['avoid']
Safety,"// Don't create an alias to a linker weak symbol. This avoids producing; // different COMDATs in different TUs. Another option would be to; // output the alias both for weak_odr and linkonce_odr, but that; // requires explicit comdat support in the IL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp:55,avoid,avoids,55,interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,1,['avoid'],['avoids']
Safety,"// Don't decrement RefsMinusAssignments if volatile variable with compound; // assignment (+=, ...) or increment/decrement unary operator to avoid; // potential unused-but-set-variable warning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:141,avoid,avoid,141,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['avoid'],['avoid']
Safety,"// Don't do any extra work if an error that is not still recovered occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:57,recover,recovered,57,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,1,['recover'],['recovered']
Safety,"// Don't do this early, since it may interfere with adjacent load merging for; // illegal types. We can avoid losing alignment information for exotic types; // pre-legalize.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:104,avoid,avoid,104,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Don't emit an empty requires expr here to avoid confusing the user with; // other diagnostics quoting an empty requires expression they never; // wrote.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:45,avoid,avoid,45,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['avoid'],['avoid']
Safety,"// Don't fold globals with redzones. ODR violation detector and redzone; // poisoning implicitly creates a dependence on the global's address, so it; // is no longer valid for it to be marked unnamed_addr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:51,detect,detector,51,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['detect'],['detector']
Safety,// Don't fold into a copy to a physical register with the same class. Doing; // so would interfere with the register coalescer's logic which would avoid; // redundant initializations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp:147,avoid,avoid,147,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"// Don't form VALU clauses. It's not clear what benefit they give, if any.; // In practice s_nop is the only internal instruction we're likely to see.; // It's safe to treat the rest as illegal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertHardClauses.cpp:160,safe,safe,160,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertHardClauses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertHardClauses.cpp,1,['safe'],['safe']
Safety,"// Don't generate 24-bit multiplies on values that are in SGPRs, since; // we only have a 32-bit scalar multiply (avoid values being moved to VGPRs; // unnecessarily). isDivergent() is used as an approximation of whether the; // value is in an SGPR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:114,avoid,avoid,114,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Don't generate 24-bit multiplies on values that are in SGPRs, since; // we only have a 32-bit scalar multiply (avoid values being moved to VGPRs; // unnecessarily). isDivergent() is used as an approximation of whether the; // value is in an SGPR.; // This doesn't apply if no s_mul_hi is available (since we'll end up with a; // valu op anyway)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:114,avoid,avoid,114,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,2,['avoid'],['avoid']
Safety,// Don't generate EH edges for CallExprs as we'd like to avoid the n^2; // explosion for destructors that can result and the compile time hit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:57,avoid,avoid,57,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['avoid'],['avoid']
Safety,// Don't generate anything that came from parseAnalyzerConfigs. It would be; // redundant and may not be valid on the command line.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:80,redund,redundant,80,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['redund'],['redundant']
Safety,"// Don't go into catchswitch blocks, which can happen with PHIs.; // Such blocks can only have PHIs and the catchswitch. There is no; // place to insert a shuffle if we need to, so just avoid that issue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:186,avoid,avoid,186,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,// Don't hoist the instruction if it's unsafe or expensive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:39,unsafe,unsafe,39,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['unsafe'],['unsafe']
Safety,"// Don't let ParseOptionalCXXScopeSpecifier() ""correct""; // `int A; struct { ~A::A(); };` to `int A; struct { ~A:A(); };`,; // it will confuse this recovery logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:148,recover,recovery,148,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['recover'],['recovery']
Safety,"// Don't promote if the symbol is not defined in the module. This avoids; // creating a reference to a symbol that doesn't exist in the module; // This can happen when we compile with a sample profile collected from; // one binary but used for another, which may have profiled targets that; // aren't used in the new binary. We might have a declaration initially in; // the case where the symbol is globally dead in the binary and removed by; // ThinLTO.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp:66,avoid,avoids,66,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp,1,['avoid'],['avoids']
Safety,// Don't propagate AvoidBinPacking into subexpressions of arg/param lists.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:19,Avoid,AvoidBinPacking,19,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['Avoid'],['AvoidBinPacking']
Safety,// Don't recover if the caller isn't expecting us to or if we're in a SFINAE; // context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,recover,recover,9,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['recover'],['recover']
Safety,"// Don't rewrite to a landing pad fallthough. That could lead to the case; // where a BB jumps to more than one landing pad.; // TODO: Is it ever worth rewriting predecessors which don't already; // jump to a landing pad, and so can safely jump to the fallthrough?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:233,safe,safely,233,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['safe'],['safely']
Safety,// Don't risk duplicating unordered loads; // This checks for an invariant.start dominating the load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:9,risk,risk,9,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['risk'],['risk']
Safety,// Don't risk increasing register pressure if it would create copies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:9,risk,risk,9,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,1,['risk'],['risk']
Safety,"// Don't set MaxLookAhead until we find at least one nonzero stage.; // This way, an itinerary with no stages has MaxLookAhead==0, which; // completely bypasses the scoreboard hazard logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp:176,hazard,hazard,176,interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScoreboardHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,"// Don't sink/hoist volatile or ordered atomic loads!; // Loads from constant memory are always safe to move, even if they end up; // in the same alias set as something that ends up being modified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:96,safe,safe,96,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['safe'],['safe']
Safety,// Don't speculate if we're just trying to improve error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:57,recover,recovery,57,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['recover'],['recovery']
Safety,// Don't touch the first M to avoid potential confusions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:30,avoid,avoid,30,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// Don't transform functions that receive inallocas, as the transformation may; // not be safe depending on calling convention.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:90,safe,safe,90,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,1,['safe'],['safe']
Safety,// Don't traverse child nodes to avoid output duplication.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTConsumers.cpp:33,avoid,avoid,33,interpreter/llvm-project/clang/lib/Frontend/ASTConsumers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTConsumers.cpp,1,['avoid'],['avoid']
Safety,// Don't use const reference. The subsequent pop_back() might make it; // unsafe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp:74,unsafe,unsafe,74,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/WorkList.cpp,1,['unsafe'],['unsafe']
Safety,// Don't use the cached binary holder because we have no thread-safety; // guarantee and the lifetime is limited.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:64,safe,safety,64,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,2,['safe'],['safety']
Safety,"// Don't use this Format, if the difference between the longest and shortest; // element in a column exceeds a threshold to avoid excessive spaces.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.cpp:124,avoid,avoid,124,interpreter/llvm-project/clang/lib/Format/FormatToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.cpp,1,['avoid'],['avoid']
Safety,"// Double cast to avoid a warning ""cast to pointer from integer of different; // size"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceLocation.h:18,avoid,avoid,18,interpreter/llvm-project/clang/include/clang/Basic/SourceLocation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceLocation.h,1,['avoid'],['avoid']
Safety,"// Double division avoids possible underflow",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixDEigen.cxx:19,avoid,avoids,19,math/matrix/src/TMatrixDEigen.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixDEigen.cxx,1,['avoid'],['avoids']
Safety,"// Draw and selection; // Scene rendering timeouts",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLViewer.h:42,timeout,timeouts,42,graf3d/gl/inc/TGLViewer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLViewer.h,1,['timeout'],['timeouts']
Safety,// Drop available_externally and unreferenced globals. This is necessary; // with ThinLTO in order to avoid leaving undefined references to dead; // globals in the object file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:102,avoid,avoid,102,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['avoid'],['avoid']
Safety,// Drop imp-defs/uses that would be redundant with the new def/use.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:36,redund,redundant,36,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,1,['redund'],['redundant']
Safety,// Drop references for MDNodes. Do this before Values get deleted to avoid; // unnecessary RAUW when nodes are still unresolved.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp:69,avoid,avoid,69,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp,1,['avoid'],['avoid']
Safety,"// Drop the terminating "" so Utf-8 errors can be detected (""\xeA"")",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Value.cpp:49,detect,detected,49,interpreter/cling/lib/Interpreter/Value.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Value.cpp,1,['detect'],['detected']
Safety,"// Due to parsing error, we either went over the cached tokens or; // there are still cached tokens left. If it's the latter case skip the; // leftover tokens.; // Since this is an uncommon situation that should be avoided, use the; // expensive isBeforeInTranslationUnit call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:215,avoid,avoided,215,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['avoid'],['avoided']
Safety,// Dummy hazard recognizer allows all instructions to issue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:9,hazard,hazard,9,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,1,['hazard'],['hazard']
Safety,// Dummy initialization to avoid warnings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:27,avoid,avoid,27,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['avoid'],['avoid']
Safety,// Duplicate a little to avoid transposing matrices.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/ReductionRules.h:25,avoid,avoid,25,interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/ReductionRules.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/ReductionRules.h,1,['avoid'],['avoid']
Safety,// Duplicate option detection.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp:20,detect,detection,20,interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,1,['detect'],['detection']
Safety,// Duplicated from FileSystem.h to avoid a dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h:35,avoid,avoid,35,interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h,1,['avoid'],['avoid']
Safety,"// During a compare task, the template parameters are expanded to; // point to their real types, to avoid compare conflicts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVType.cpp:100,avoid,avoid,100,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVType.cpp,1,['avoid'],['avoid']
Safety,"// During the 'Deep' part of the search we will call GetClassSharedLibsForModule; // (when module are enabled) which might end up calling AutoParsing but; // that should only be for the cases where the library has no generated pcm; // and in that case a rootmap should be available.; // This avoids a very costly operation (for generally no gain) but reduce the; // quality of the search (i.e. bad in case of library with no pcm and no rootmap; // file).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:292,avoid,avoids,292,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['avoid'],['avoids']
Safety,"// Dynamic information is required to be stripped for comparisons,; // because it could leak the dynamic information. Based on comparisons; // of pointers to dynamic objects, the optimizer can replace one pointer; // with another, which might be incorrect in presence of invariant; // groups. Comparison with null is safe because null does not carry any; // dynamic information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:317,safe,safe,317,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['safe'],['safe']
Safety,"// EH pads are unsafe to outline because doing so breaks EH type tables. It; // follows that invoke instructions cannot be extracted, because CodeExtractor; // requires unwind destinations to be within the extraction region.; //; // Resumes that are not reachable from a cleanup landing pad are considered to; // be unreachable. It’s not safe to split them out either.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:15,unsafe,unsafe,15,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"// Each entry is the address of the block minus the address of the jump; // table. This is used for PIC jump tables where gprel32 is not supported.; // e.g.:; // .word LBB123 - LJTI1_2; // If the .set directive avoids relocations, this is emitted as:; // .set L4_5_set_123, LBB123 - LJTI1_2; // .word L4_5_set_123",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:211,avoid,avoids,211,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['avoid'],['avoids']
Safety,// Each location Op may need a SCEVDbgValueBuilder in order to recover; // it. Pre-allocating a vector will enable quick lookups of the builder; // later during the salvage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:63,recover,recover,63,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['recover'],['recover']
Safety,// Each of these checks needs to return 'false' when an issue was detected.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:66,detect,detected,66,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['detect'],['detected']
Safety,"// Each weighted sum is going to be less than the total frequency of the; // bundle. Ideally, we should simply set Value = sign(SumP - SumN), but we; // will add a dead zone around 0 for two reasons:; //; // 1. It avoids arbitrary bias when all links are 0 as is possible during; // initial iterations.; // 2. It helps tame rounding errors when the links nominally sum to 0.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:214,avoid,avoids,214,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,1,['avoid'],['avoids']
Safety,// Early abort if there was no interchange during an entire round of; // moving loops outwards.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:9,abort,abort,9,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,1,['abort'],['abort']
Safety,// Early return to avoid doing the wrong thing in the face of; // reinterpret_cast.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:19,avoid,avoid,19,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,1,['avoid'],['avoid']
Safety,// Early termination to avoid expensive call,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConstraintManager.h:24,avoid,avoid,24,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConstraintManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConstraintManager.h,1,['avoid'],['avoid']
Safety,"// Either Cur is in the error state, or we have an error in ULEBSizeErr or; // MetadataDecodeErr (but not both), but we join all errors here to be safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ELF.cpp:147,safe,safe,147,interpreter/llvm-project/llvm/lib/Object/ELF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ELF.cpp,1,['safe'],['safe']
Safety,// Eliminate all the TOC save instructions which are redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:53,redund,redundant,53,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['redund'],['redundant']
Safety,// Eliminate redundancies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:13,redund,redundancies,13,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['redund'],['redundancies']
Safety,// Eliminate redundant IV cycles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:13,redund,redundant,13,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['redund'],['redundant']
Safety,// Eliminate redundant IV users.; //; // Simplification works best when run before other consumers of SCEV. We; // attempt to avoid evaluating SCEVs for sign/zero extend operations until; // other expressions involving loop IVs have been evaluated. This helps SCEV; // set no-wrap flags before normalizing sign/zero extension.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:13,redund,redundant,13,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,// Eliminate redundant Phi nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:13,redund,redundant,13,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,1,['redund'],['redundant']
Safety,// Eliminate redundant destinations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:13,redund,redundant,13,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['redund'],['redundant']
Safety,"// Eliminate redundant instructions; //; // This transformation will identify instructions where the output register; // is the same as one of its input registers. This only works on instructions; // that define a single register (unlike post-increment loads, for example).; // The equality check is actually more detailed: the code calculates which; // bits of the output are used, and only compares these bits with the input; // registers.; // If the output matches an input, the instruction is replaced with COPY.; // The copies will be removed by another transformation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:13,redund,redundant,13,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,1,['redund'],['redundant']
Safety,"// Eliminate redundant variables, e.g. x = y, or x = 5,; // but keep anything more complicated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:13,redund,redundant,13,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,1,['redund'],['redundant']
Safety,"// Eliminate the current context entry, to avoid re-entering in case the; // cleanup code crashes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp:43,avoid,avoid,43,interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,1,['avoid'],['avoid']
Safety,// Embed the type hash in the X86::MOV32ri instruction to avoid special; // casing object file parsers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:58,avoid,avoid,58,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,1,['avoid'],['avoid']
Safety,"// Emit ""if (coro.free(CoroId, CoroBegin)) Deallocate;""; // Note: That deallocation will be emitted twice: once for a normal exit and; // once for exceptional exit. This usage is safe because Deallocate does not; // contain any declarations. The SubStmtBuilder::makeNewAndDeleteExpr(); // builds a single call to a deallocation function which is safe to emit; // multiple times.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:179,safe,safe,179,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,2,['safe'],['safe']
Safety,// Emit __clangast in custom section instead of named data segment; // to find it while iterating sections.; // This could be avoided if all data segements (the wasm sense) were; // represented as their own sections (in the llvm sense).; // TODO: https://github.com/WebAssembly/tool-conventions/issues/138,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ObjectFilePCHContainerOperations.cpp:126,avoid,avoided,126,interpreter/llvm-project/clang/lib/CodeGen/ObjectFilePCHContainerOperations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ObjectFilePCHContainerOperations.cpp,1,['avoid'],['avoided']
Safety,"// Emit a CheckComplexPat operation, which does the match (aborting if it; // fails) and pushes the matched operands onto the recorded nodes list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp:59,abort,aborting,59,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,1,['abort'],['aborting']
Safety,// Emit a combined atomicrmw load/store operation for the interlocked; // intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:58,interlock,interlocked,58,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['interlock'],['interlocked']
Safety,"// Emit a function symbol for the type data to avoid unreachable instruction; // warnings from binary validation tools, and use the same linkage as the; // parent function. Note that using local linkage would result in duplicate; // symbols for weak parent functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:47,avoid,avoid,47,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,1,['avoid'],['avoid']
Safety,// Emit a label assignment with the SEH frame offset so we can use it for; // llvm.eh.recoverfp.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:86,recover,recoverfp,86,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,1,['recover'],['recoverfp']
Safety,"// Emit a legalized extension from <2 x s16> to 2 32-bit components, avoiding; // any illegal vector extend or unmerge operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:69,avoid,avoiding,69,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['avoid'],['avoiding']
Safety,// Emit a plain load for the non-interlocked intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:33,interlock,interlocked,33,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['interlock'],['interlocked']
Safety,// Emit a warning if the detected CUDA version is too new.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:25,detect,detected,25,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['detect'],['detected']
Safety,// Emit an implicit barrier at the end (to avoid data race on firstprivate; // init or if no 'nowait' clause was specified and no 'copyprivate' clause).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:43,avoid,avoid,43,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['avoid'],['avoid']
Safety,// Emit diagnostic if a recursive function call is detected for all paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:51,detect,detected,51,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['detect'],['detected']
Safety,// Emit implicit barrier to synchronize threads and avoid data races on; // initialization of firstprivate variables and post-update of lastprivate; // variables.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:52,avoid,avoid,52,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['avoid'],['avoid']
Safety,// Emit implicit barrier to synchronize threads and avoid data races on; // initialization of firstprivate variables and post-update of; // lastprivate variables.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:52,avoid,avoid,52,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['avoid'],['avoid']
Safety,// Emit implicit barrier to synchronize threads and avoid data races on; // initialization of firstprivate variables.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:52,avoid,avoid,52,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['avoid'],['avoid']
Safety,// Emit implicit barrier to synchronize threads and avoid data races on; // propagation master's thread values of threadprivate variables to local; // instances of that variables of all other implicit threads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:52,avoid,avoid,52,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['avoid'],['avoid']
Safety,// Emit implicit barrier to synchronize threads and avoid data races; // on initialization of firstprivate variables and post-update of; // lastprivate variables.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:52,avoid,avoid,52,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['avoid'],['avoid']
Safety,"// Emit incoming terminator(s). Be optimistic and assume that branch; // prediction will generally do ""the right thing"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:73,predict,prediction,73,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,1,['predict'],['prediction']
Safety,// Emit notes only for the first discovered declaration of unsupported type; // to avoid mess of notes. This flag is to track that error already happened.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaSYCL.cpp:83,avoid,avoid,83,interpreter/llvm-project/clang/lib/Sema/SemaSYCL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaSYCL.cpp,1,['avoid'],['avoid']
Safety,"// Emit relative relocation `addr - base`, which avoids a dynamic; // relocation in the final binary. User will get the address with; // `base + addr`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:49,avoid,avoids,49,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['avoid'],['avoids']
Safety,// Emit remark for first unsafe dependence,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:25,unsafe,unsafe,25,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['unsafe'],['unsafe']
Safety,// Emit tables in a deterministic order to avoid needless rebuilds.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SearchableTableEmitter.cpp:43,avoid,avoid,43,interpreter/llvm-project/llvm/utils/TableGen/SearchableTableEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SearchableTableEmitter.cpp,1,['avoid'],['avoid']
Safety,// Emit the .safeseh directive for this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86WinEHState.cpp:13,safe,safeseh,13,interpreter/llvm-project/llvm/lib/Target/X86/X86WinEHState.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86WinEHState.cpp,1,['safe'],['safeseh']
Safety,"// Emit the FPEXTEND_PSEUDO instruction.; //; // Expand an f16 to either a FGR32Opnd or FGR64Opnd.; //; // Safety: Cycle the result through the GPRs so the result always ends up; // the correct floating point register.; //; // FIXME: This copying is strictly unnecessary. If we could tie FGR32Opnd:$Fd; // / FGR64Opnd:$Fd and MSA128F16:$Ws to the same physical register; // (which they can be, as the MSA registers are defined to alias the; // FPU's 64 bit and 32 bit registers) the result can be accessed using; // the correct register class. That requires operands be tie-able across; // register classes which have a sub/super register class relationship. I; // haven't checked.; //; // For FGR32Opnd:; //; // FPEXTEND FGR32Opnd:$fd, MSA128F16:$ws; // =>; // fexupr.w $wtemp, $ws; // copy_s.w $rtemp, $ws[0]; // mtc1 $rtemp, $fd; //; // For FGR64Opnd on Mips64:; //; // FPEXTEND FGR64Opnd:$fd, MSA128F16:$ws; // =>; // fexupr.w $wtemp, $ws; // fexupr.d $wtemp2, $wtemp; // copy_s.d $rtemp, $wtemp2s[0]; // dmtc1 $rtemp, $fd; //; // For FGR64Opnd on Mips32:; //; // FPEXTEND FGR64Opnd:$fd, MSA128F16:$ws; // =>; // fexupr.w $wtemp, $ws; // fexupr.d $wtemp2, $wtemp; // copy_s.w $rtemp, $wtemp2[0]; // mtc1 $rtemp, $ftemp; // copy_s.w $rtemp2, $wtemp2[1]; // $fd = mthc1 $rtemp2, $ftemp",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:107,Safe,Safety,107,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['Safe'],['Safety']
Safety,"// Emit the FPROUND_PSEUDO instruction.; //; // Round an FGR64Opnd, FGR32Opnd to an f16.; //; // Safety: Cycle the operand through the GPRs so the result always ends up; // the correct MSA register.; //; // FIXME: This copying is strictly unnecessary. If we could tie FGR32Opnd:$Fs; // / FGR64Opnd:$Fs and MSA128F16:$Wd to the same physical register; // (which they can be, as the MSA registers are defined to alias the; // FPU's 64 bit and 32 bit registers) the result can be accessed using; // the correct register class. That requires operands be tie-able across; // register classes which have a sub/super register class relationship.; //; // For FPG32Opnd:; //; // FPROUND MSA128F16:$wd, FGR32Opnd:$fs; // =>; // mfc1 $rtemp, $fs; // fill.w $rtemp, $wtemp; // fexdo.w $wd, $wtemp, $wtemp; //; // For FPG64Opnd on mips32r2+:; //; // FPROUND MSA128F16:$wd, FGR64Opnd:$fs; // =>; // mfc1 $rtemp, $fs; // fill.w $rtemp, $wtemp; // mfhc1 $rtemp2, $fs; // insert.w $wtemp[1], $rtemp2; // insert.w $wtemp[3], $rtemp2; // fexdo.w $wtemp2, $wtemp, $wtemp; // fexdo.h $wd, $temp2, $temp2; //; // For FGR64Opnd on mips64r2+:; //; // FPROUND MSA128F16:$wd, FGR64Opnd:$fs; // =>; // dmfc1 $rtemp, $fs; // fill.d $rtemp, $wtemp; // fexdo.w $wtemp2, $wtemp, $wtemp; // fexdo.h $wd, $wtemp2, $wtemp2; //; // Safety note: As $wtemp is UNDEF, we may provoke a spurious exception if the; // undef bits are ""just right"" and the exception enable bits are; // set. By using fill.w to replicate $fs into all elements over; // insert.w for one element, we avoid that potiential case. If; // fexdo.[hw] causes an exception in, the exception is valid and it; // occurs for all elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:97,Safe,Safety,97,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,3,"['Safe', 'avoid']","['Safety', 'avoid']"
Safety,"// Emit the LD_F16_PSEDUO instruction to load a f16 value into an MSA register.; //; // LD_F16 MSA128F16:$wd, mem_simm10:$addr; // =>; // lh $rtemp, $addr; // fill.h $wd, $rtemp; //; // Safety: We can't use ld.h & co as they over-read from the source.; // Additionally, if the address is not modulo 16, 2 cases can occur:; // a) Segmentation fault as the load instruction reads from a memory page; // memory it's not supposed to.; // b) The load crosses an implementation specific boundary, requiring OS; // intervention.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:186,Safe,Safety,186,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['Safe'],['Safety']
Safety,"// Emit the ST_F16_PSEDUO instruction to store a f16 value from an MSA; // register.; //; // STF16 MSA128F16:$wd, mem_simm10:$addr; // =>; // copy_u.h $rtemp,$wd[0]; // sh $rtemp, $addr; //; // Safety: We can't use st.h & co as they would over write the memory after; // the destination. It would require half floats be allocated 16 bytes(!) of; // space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:194,Safe,Safety,194,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['Safe'],['Safety']
Safety,"// Emit the actual declaration. All these functions are; // declared 'static inline' without a body, which is fine; // provided clang recognizes them as builtins, and has the; // effect that this type signature is used in place of the one; // that Builtins.def didn't provide. That's how we can get; // structure types that weren't defined until this header was; // included to be part of the type signature of a builtin that; // was known to clang already.; //; // The declarations use __attribute__(__clang_arm_builtin_alias),; // so that each function declared will be recognized as the; // appropriate MVE builtin in spite of its user-facing name.; //; // (That's better than making them all wrapper functions,; // partly because it avoids any compiler error message citing; // the wrapper function definition instead of the user's code,; // and mostly because some MVE intrinsics have arguments; // required to be compile-time constants, and that property; // can't be propagated through a wrapper function. It can be; // propagated through a macro, but macros can't be overloaded; // on argument types very easily - you have to use _Generic,; // which makes error messages very confusing when the user; // gets it wrong.); //; // Finally, the polymorphic versions of the intrinsics are; // also defined with __attribute__(overloadable), so that when; // the same name is defined with several type signatures, the; // right thing happens. Each one of the overloaded; // declarations is given a different builtin id, which; // has exactly the effect we want: first clang resolves the; // overload to the right function, then it knows which builtin; // it's referring to, and then the Sema checking for that; // builtin can check further things like the constant; // arguments.; //; // One more subtlety is the newline just before the return; // type name. That's a cosmetic tweak to make the error; // messages legible if the user gets the types wrong in a call; // to a polymorphic function: this",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:737,avoid,avoids,737,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,1,['avoid'],['avoids']
Safety,// Emit the address of the safe point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp:27,safe,safe,27,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,1,['safe'],['safe']
Safety,// Emit the body content. We do it after connecting the loop to the CFG to; // avoid that the callback encounters degenerate BBs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:79,avoid,avoid,79,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['avoid'],['avoid']
Safety,"// Emit the label for this Entry, so that IDX_parents may refer to it.; // Note: a DIE may have multiple accelerator Entries; this check avoids; // creating/emitting multiple labels for the same DIE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:137,avoid,avoids,137,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,1,['avoid'],['avoids']
Safety,// Emit the remarks section contents.; // FIXME: Figure out when is the safest time to emit this section. It should; // not come after debug info.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:72,safe,safest,72,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['safe'],['safest']
Safety,"// Emit two handler calls: first one for set of unrecoverable checks,; // another one for recoverable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:90,recover,recoverable,90,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['recover'],['recoverable']
Safety,"// Emit: if (PreCond) - begin.; // If the condition constant folds and can be elided, avoid emitting the; // whole loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:86,avoid,avoid,86,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['avoid'],['avoid']
Safety,// Emits the first unsafe memory dependence in a loop.; // Emits nothing if there are no unsafe dependences; // or if the dependences were not recorded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:19,unsafe,unsafe,19,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,2,['unsafe'],['unsafe']
Safety,// Emitting one decl is sufficient - debuggers can detect that this is an; // overloaded name & provide lookup for all the overloads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:51,detect,detect,51,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['detect'],['detect']
Safety,"// Empirical risk",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleFitParams.h:13,risk,risk,13,tmva/tmva/inc/TMVA/RuleFitParams.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleFitParams.h,1,['risk'],['risk']
Safety,"// Empty arcs can be ignored by renderer, but should not be dropped; // to avoid collisions with `S A S` and so on. Replace with empty line.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:75,avoid,avoid,75,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// Empty directories could be present in the YAML as a way to; // describe a file for a current directory after some of its subdir; // is parsed. This only leads to redundant walks, ignore it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp:165,redund,redundant,165,interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,1,['redund'],['redundant']
Safety,"// Enable compatilibily mode to avoid analyzer-config related errors.; // Since we can't access frontend flags through hasArg, let's manually iterate; // through them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:32,avoid,avoid,32,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['avoid'],['avoid']
Safety,"// Enable stale profile matching by default for probe-based profile.; // Currently the matching relies on if the checksum mismatch is detected,; // which is currently only available for pseudo-probe mode. Removing the; // checksum check could cause regressions for some cases, so further tuning; // might be needed if we want to enable it for all cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:134,detect,detected,134,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['detect'],['detected']
Safety,// Enable the abort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:14,abort,abort,14,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,1,['abort'],['abort']
Safety,"// Enable the binned likelihood optimization to avoid integrals; // (like in HistFactory).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testTestStatistics.cxx:48,avoid,avoid,48,roofit/roofitcore/test/testTestStatistics.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testTestStatistics.cxx,1,['avoid'],['avoid']
Safety,"// EnableImplicitMT() only enables thread safety if IMT was configured;; // enable thread safety even with IMT off:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:42,safe,safety,42,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,2,['safe'],['safety']
Safety,"// End NS Internal; //////////////////////////////////////////////////////////////////////////; /// \brief Class constructor.; /// If the scheduler is active (e.g. because another TThreadExecutor is in flight, or ROOT::EnableImplicitMT() was; /// called), work with the current pool of threads.; /// If not, initialize the pool of threads, spawning nThreads. nThreads' default value, 0, initializes the; /// pool with as many logical threads as are available in the system (see NLogicalCores in RTaskArenaWrapper.cxx).; ///; /// At construction time, TThreadExecutor automatically enables ROOT's thread-safety locks as per calling; /// ROOT::EnableThreadSafety().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/TThreadExecutor.cxx:603,safe,safety,603,core/imt/src/TThreadExecutor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/TThreadExecutor.cxx,1,['safe'],['safety']
Safety,// End anonymous namespace.; // TODO: this implementation is likely now redundant with the default; // EmitVAArg.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp:72,redund,redundant,72,interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,1,['redund'],['redundant']
Safety,// Endian safe: Array[i] = (PointerTy)Dest;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:10,safe,safe,10,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,1,['safe'],['safe']
Safety,"// Endianness info is 1 bytes, 256 is safely out of range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/InterfaceStub/IFSStub.h:38,safe,safely,38,interpreter/llvm-project/llvm/include/llvm/InterfaceStub/IFSStub.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/InterfaceStub/IFSStub.h,1,['safe'],['safely']
Safety,"// Ensure that in case of only 1 boost the method weight equals; // 1.0. This avoids unexpected behaviour in case of very bad; // classifiers which have fBoostWeight=1 or fMethodError=0.5,; // because their weight would be set to zero. This behaviour is; // not ok if one boosts just one time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBoost.cxx:78,avoid,avoids,78,tmva/tmva/src/MethodBoost.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBoost.cxx,1,['avoid'],['avoids']
Safety,// Ensure this insertion is not redundant (two LFENCEs in sequence).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:32,redund,redundant,32,interpreter/llvm-project/llvm/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp,1,['redund'],['redundant']
Safety,// Entry tokens don't need to be added to the list. They are; // redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:65,redund,redundant,65,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['redund'],['redundant']
Safety,"// Enum alignment sources can be safely ignored here, because this only; // helps decide whether we need the AIX alignment upgrade, which only; // applies to floating-point types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:33,safe,safely,33,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['safe'],['safely']
Safety,"// Enum traits that marks enums as safe or unsafe to iterate over.; // By default, enum types are *not* considered safe for iteration.; // To allow iteration for your enum type, provide a specialization with; // `is_iterable` set to `true` in the `llvm` namespace.; // Alternatively, you can pass the `force_iteration_on_noniterable_enum` tag; // to `enum_seq` or `enum_seq_inclusive`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:35,safe,safe,35,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,3,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,// Enumerate all string patches and write them into the destination section.; // Order of patches is the same as in original input file. To avoid emitting; // the same string twice we accumulate NextOffset value. Thus if string; // offset smaller than NextOffset value then the patch is skipped (as that; // string was emitted earlier).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFEmitterImpl.h:140,avoid,avoid,140,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFEmitterImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFEmitterImpl.h,1,['avoid'],['avoid']
Safety,// Enumeration types referenced prior to definition may appear as a result of; // error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:88,recover,recovery,88,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['recover'],['recovery']
Safety,"// Envoid the cost of TPushPop if we don't need it; // FIXME: This is not thread safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TEmulatedCollectionProxy.cxx:81,safe,safe,81,io/io/src/TEmulatedCollectionProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TEmulatedCollectionProxy.cxx,1,['safe'],['safe']
Safety,"// Equivalence Assumptions; //; // For basic blocks in loops, some values in phi nodes may depend on; // values from not yet processed basic blocks in the loop. When encountering; // such values, we optimistically asssume their equivalence and store this; // assumption in a BlockDiffCandidate for the pair of compared BBs.; //; // Once we have diffed all BBs, for every BlockDiffCandidate, we check all; // stored assumptions using the Values map that stores proven equivalences; // between the old and new values, and report a diff if an assumption cannot; // be proven to be true.; //; // Note that after having made an assumption, all further determined; // equivalences implicitly depend on that assumption. These will not be; // reverted or reported if the assumption proves to be false, because these; // are considered indirect diffs caused by earlier direct diffs.; //; // We aim to avoid false negatives in llvm-diff, that is, ensure that; // whenever no diff is reported, the functions are indeed equal. If; // assumptions were made, this is not entirely clear, because in principle we; // could end up with a circular proof where the proof of equivalence of two; // nodes is depending on the assumption of their equivalence.; //; // To see that assumptions do not add false negatives, note that if we do not; // report a diff, this means that there is an equivalence mapping between old; // and new values that is consistent with all assumptions made. The circular; // dependency that exists on an IR value level does not exist at run time,; // because the values selected by the phi nodes must always already have been; // computed. Hence, we can prove equivalence of the old and new functions by; // considering step-wise parallel execution, and incrementally proving; // equivalence of every new computed value. Another way to think about it is; // to imagine cloning the loop BBs for every iteration, turning the loops; // into (possibly infinite) DAGs, and proving equivalence by indu",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:892,avoid,avoid,892,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,1,['avoid'],['avoid']
Safety,// Erase the instructions and the blocks without having to worry; // about ordering because we already dropped the references.; // NOTE: This iteration is safe because erasing the block does not remove; // its entry from the loop's block list. We do that in the next section.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:155,safe,safe,155,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,1,['safe'],['safe']
Safety,// Error recovery might have converted a non-static member into a static; // member.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:9,recover,recovery,9,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['recover'],['recovery']
Safety,// Error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:9,recover,recovery,9,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,1,['recover'],['recovery']
Safety,"// Error recovery: drop the non-leaf attribute so that to suppress; // all future warnings caused by erroneous attributes. The leaf attribute; // needs to be kept because it can only suppresses warnings, not cause them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:9,recover,recovery,9,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['recover'],['recovery']
Safety,"// Error recovery: some names weren't found, or we have a mix of; // type and protocol names. Go resolve all of the unresolved names; // and complain if we can't find a consistent answer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:9,recover,recovery,9,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['recover'],['recovery']
Safety,"// Error reporting calls should be cold, mark them as such.; // This applies even to non-builtin calls: it is only a hint and applies to; // functions that the frontend might not understand as builtins.; // This heuristic was suggested in:; // Improving Static Branch Prediction in a Compiler; // Brian L. Deitrich, Ben-Chung Cheng, Wen-mei W. Hwu; // Proceedings of PACT'98, Oct. 1998, IEEE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:268,Predict,Prediction,268,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['Predict'],['Prediction']
Safety,// ErrorCallback is used to handle recoverable errors. An Error returned; // by the callback aborts the parsing and is then returned by this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/CommonConfig.h:35,recover,recoverable,35,interpreter/llvm-project/llvm/include/llvm/ObjCopy/CommonConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/CommonConfig.h,2,"['abort', 'recover']","['aborts', 'recoverable']"
Safety,// Essentially boils down to performing an unaligned VMX load sequence so; // as to avoid crossing a page boundary and then shuffling the elements; // into the right side of the vector register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:84,avoid,avoid,84,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['avoid'],['avoid']
Safety,// Estimate all types may be fused with contract/unsafe flags,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:49,unsafe,unsafe,49,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,1,['unsafe'],['unsafe']
Safety,// Evaluate ReferenceBindsToTemporary and ReferenceConstructsFromTemporary; // alongside the IsConstructible traits to avoid duplication.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:119,avoid,avoid,119,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['avoid'],['avoid']
Safety,"// Evaluate as many IV expressions as possible before widening any IVs. This; // forces SCEV to set no-wrap flags before evaluating sign/zero; // extension. The first time SCEV attempts to normalize sign/zero extension,; // the result becomes final. So for the most predictable results, we delay; // evaluation of sign/zero extend evaluation until needed, and avoid running; // other SCEV based analysis prior to simplifyAndExtend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:266,predict,predictable,266,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,2,"['avoid', 'predict']","['avoid', 'predictable']"
Safety,"// Evaluate special cases related to a nested function as the base.; // pow(exp(x), y) -> exp(x * y); // pow(exp2(x), y) -> exp2(x * y); // If exp{,2}() is used only once, it is better to fold two transcendental; // math functions into one. If used again, exp{,2}() would still have to be; // called with the original argument, then keep both original transcendental; // functions. However, this transformation is only safe with fully relaxed; // math semantics, since, besides rounding differences, it changes overflow; // and underflow behavior quite dramatically. For example:; // pow(exp(1000), 0.001) = pow(inf, 0.001) = inf; // Whereas:; // exp(1000 * 0.001) = exp(1); // TODO: Loosen the requirement for fully relaxed math semantics.; // TODO: Handle exp10() when more targets have it available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:419,safe,safe,419,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['safe'],['safe']
Safety,"// Evaluate the RHS first. If we're ignoring the result, assume; // that we can emit at an unsafe +0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:91,unsafe,unsafe,91,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['unsafe'],['unsafe']
Safety,"// Evaluates an XRay record and performs accounting on it.; //; // If the record is an ENTER record it pushes the FuncID and TSC onto a; // structure representing the call stack for that function.; // If the record is an EXIT record it checks computes computes the ammount of; // time the function took to complete and then stores that information in an; // edge of the graph. If there is no matching ENTER record the function tries; // to recover by assuming that there were EXIT records which were missed, for; // example caused by tail call elimination and if the option is enabled then; // then tries to recover from this.; //; // This function will also error if the records are out of order, as the trace; // is expected to be sorted.; //; // The graph generated has an immaginary root for functions called by no-one at; // FuncId 0.; //; // FIXME: Refactor this and account subcommand to reduce code duplication.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.cpp:440,recover,recover,440,interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.cpp,2,['recover'],['recover']
Safety,"// Evaluating in the trip count's type can not overflow here as the overflow; // checks are performed in checkOverflow, but are first tried to avoid by; // widening the IV.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:143,avoid,avoid,143,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,1,['avoid'],['avoid']
Safety,"// Even if TrueVal does not simplify, we can directly replace a use of; // CmpLHS with CmpRHS, as long as the instruction is not used anywhere; // else and is safe to speculatively execute (we may end up executing it; // with different operands, which should not cause side-effects or trigger; // undefined behavior). Only do this if CmpRHS is a constant, as; // profitability is not clear for other cases.; // FIXME: Support vectors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:159,safe,safe,159,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['safe'],['safe']
Safety,"// Even if the instructions are identical, it may not; // be safe to hoist them if we have skipped over; // instructions with side effects or their operands; // weren't hoisted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:61,safe,safe,61,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['safe'],['safe']
Safety,"// Even though DPV defines a variable location, VarLocsBeforeInst can; // still be empty if that VarLoc was redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:108,redund,redundant,108,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['redund'],['redundant']
Safety,"// Even though it is technically only required when the computation graph; // is changed because global observables are taken from data, it is safer; // to clone the constraint model in general to reset the normalization; // integral caches and avoid ASAN build failures (the PDF of the main; // measurement is cloned too anyway, so not much overhead). This can be; // reconsidered after the caching of normalization sets by pointer is changed; // to a more memory-safe solution.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx:143,safe,safer,143,roofit/roofitcore/src/FitHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx,3,"['avoid', 'safe']","['avoid', 'safe', 'safer']"
Safety,"// Even though we could use a smaller VL, don't to avoid a vsetivli; // toggle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:51,avoid,avoid,51,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Even though we're optimising for size at the expense of performance,; // avoid creating really long predicated blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:76,avoid,avoid,76,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,1,['avoid'],['avoid']
Safety,// Every segment will overlap with itself but we don't want a segment to; // be its own parent so we avoid that situation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp:101,avoid,avoid,101,interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp,1,['avoid'],['avoid']
Safety,// Evict the LRU binary until the max cache size is reached or there's <= 1; // item in the cache. The MRU binary is always kept to avoid thrashing if it's; // larger than the cache size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/Symbolize.cpp:132,avoid,avoid,132,interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/Symbolize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/Symbolize.cpp,1,['avoid'],['avoid']
Safety,"// Examine the remaining variable locations: if we can find the same value; // again, we can recover the location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:93,recover,recover,93,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['recover'],['recover']
Safety,"// Example IR modules.; //; // Note that in the conditionally compiled modules, FooMod and BarMod, functions; // have been given an _body suffix. This is to ensure that their names do not; // clash with their lazy-reexports.; // For clients who do not wish to rename function bodies (e.g. because they want; // to re-use cached objects between static and JIT compiles) techniques exist to; // avoid renaming. See the lazy-reexports section of the ORCv2 design doc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp:393,avoid,avoid,393,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp,4,['avoid'],['avoid']
Safety,"// Example of pattern we try to detect:; // t := (v8i32 mul (sext (v8i16 x0), (sext (v8i16 x1)))); //(add (build_vector (extract_elt t, 0),; // (extract_elt t, 2),; // (extract_elt t, 4),; // (extract_elt t, 6)),; // (build_vector (extract_elt t, 1),; // (extract_elt t, 3),; // (extract_elt t, 5),; // (extract_elt t, 7)))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:32,detect,detect,32,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['detect'],['detect']
Safety,"// Example, explaining the loop break condition: Let's assume our; // starting instruction is i0 and MaxMemDepDistance = 3.; //; // +--------v--v--v; // i0,i1,i2,i3,i4,i5,i6,i7,i8; // +--------^--^--^; //; // MaxMemDepDistance let us stop alias-checking at i3 and we add; // dependencies from i0 to i3,i4,.. (even if they are not aliased).; // Previously we already added dependencies from i3 to i6,i7,i8; // (because of MaxMemDepDistance). As we added a dependency from; // i0 to i3, we have transitive dependencies from i0 to i6,i7,i8; // and we can abort this loop at i6.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:552,abort,abort,552,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['abort'],['abort']
Safety,"// Exception handling requires additional IR. If the 'await_resume' function; // is marked as 'noexcept', we avoid generating this additional IR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:109,avoid,avoid,109,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,1,['avoid'],['avoid']
Safety,"// Exception safe locking/unlocking of mutex",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TVirtualMutex.h:13,safe,safe,13,core/base/inc/TVirtualMutex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TVirtualMutex.h,1,['safe'],['safe']
Safety,"// Exception safe output redirection",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TRedirectOutputGuard.h:13,safe,safe,13,core/base/inc/TRedirectOutputGuard.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TRedirectOutputGuard.h,2,['safe'],['safe']
Safety,"// Exception safe push routine",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/MetaProcessor/MetaProcessor.cpp:13,safe,safe,13,interpreter/cling/lib/MetaProcessor/MetaProcessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/MetaProcessor/MetaProcessor.cpp,1,['safe'],['safe']
Safety,"// Exception safety requires us to destroy all the; // already-constructed members if an initializer throws.; // For that, we'll need an EH cleanup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp:13,safe,safety,13,interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,1,['safe'],['safety']
Safety,"// Exception-safe EVE redraw-disabler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveManager.h:13,safe,safe,13,graf3d/eve/inc/TEveManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveManager.h,1,['safe'],['safe']
Safety,"// Exception-safe wrapper for temporary setting of gGeoManager variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveUtil.h:13,safe,safe,13,graf3d/eve/inc/TEveUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveUtil.h,1,['safe'],['safe']
Safety,"// Exception-safe wrapper for temporary setting of gPad variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveUtil.h:13,safe,safe,13,graf3d/eve/inc/TEveUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveUtil.h,1,['safe'],['safe']
Safety,// Exception: there is no hazard if the wmma instructions are of the same; // type and there is no input modifier on src2 of the current instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:26,hazard,hazard,26,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazard']
