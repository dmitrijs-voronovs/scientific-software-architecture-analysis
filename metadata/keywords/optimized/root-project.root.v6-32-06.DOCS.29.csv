quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Testability,wp_asan/platform_specific/guarded_pool_allocator_fuchsia.h; compiler-rt/lib/gwp_asan/platform_specific/guarded_pool_allocator_posix.cpp; compiler-rt/lib/gwp_asan/platform_specific/guarded_pool_allocator_posix.h; compiler-rt/lib/gwp_asan/platform_specific/guarded_pool_allocator_tls.h; compiler-rt/lib/gwp_asan/platform_specific/mutex_fuchsia.cpp; compiler-rt/lib/gwp_asan/platform_specific/mutex_fuchsia.h; compiler-rt/lib/gwp_asan/platform_specific/mutex_posix.cpp; compiler-rt/lib/gwp_asan/platform_specific/mutex_posix.h; compiler-rt/lib/gwp_asan/platform_specific/utilities_fuchsia.cpp; compiler-rt/lib/gwp_asan/platform_specific/utilities_posix.cpp; compiler-rt/lib/gwp_asan/tests/backtrace.cpp; compiler-rt/lib/gwp_asan/tests/basic.cpp; compiler-rt/lib/gwp_asan/tests/compression.cpp; compiler-rt/lib/gwp_asan/tests/crash_handler_api.cpp; compiler-rt/lib/gwp_asan/tests/driver.cpp; compiler-rt/lib/gwp_asan/tests/enable_disable.cpp; compiler-rt/lib/gwp_asan/tests/harness.cpp; compiler-rt/lib/gwp_asan/tests/harness.h; compiler-rt/lib/gwp_asan/tests/iterate.cpp; compiler-rt/lib/gwp_asan/tests/late_init.cpp; compiler-rt/lib/gwp_asan/tests/mutex_test.cpp; compiler-rt/lib/gwp_asan/tests/options.cpp; compiler-rt/lib/gwp_asan/tests/slot_reuse.cpp; compiler-rt/lib/gwp_asan/tests/thread_contention.cpp; compiler-rt/lib/gwp_asan/tests/platform_specific/printf_sanitizer_common.cpp; compiler-rt/lib/hwasan/hwasan_checks.h; compiler-rt/lib/hwasan/hwasan_dynamic_shadow.h; compiler-rt/lib/hwasan/hwasan_flags.h; compiler-rt/lib/hwasan/hwasan_globals.cpp; compiler-rt/lib/hwasan/hwasan_globals.h; compiler-rt/lib/hwasan/hwasan_linux.cpp; compiler-rt/lib/hwasan/hwasan_poisoning.cpp; compiler-rt/lib/hwasan/hwasan_poisoning.h; compiler-rt/lib/hwasan/hwasan_preinit.cpp; compiler-rt/lib/interception/interception_mac.cpp; compiler-rt/lib/interception/tests/interception_test_main.cpp; compiler-rt/lib/lsan/lsan.h; compiler-rt/lib/lsan/lsan_common.cpp; compiler-rt/lib/lsan/lsan_thread.cpp; compiler-rt/l,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:93456,test,tests,93456,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['test'],['tests']
Testability,wrappers_c.cpp; compiler-rt/lib/scudo/standalone/wrappers_c.h; compiler-rt/lib/scudo/standalone/wrappers_c_bionic.cpp; compiler-rt/lib/scudo/standalone/wrappers_c_checks.h; compiler-rt/lib/scudo/standalone/benchmarks/malloc_benchmark.cpp; compiler-rt/lib/scudo/standalone/fuzz/get_error_info_fuzzer.cpp; compiler-rt/lib/scudo/standalone/include/scudo/interface.h; compiler-rt/lib/scudo/standalone/tests/atomic_test.cpp; compiler-rt/lib/scudo/standalone/tests/bytemap_test.cpp; compiler-rt/lib/scudo/standalone/tests/checksum_test.cpp; compiler-rt/lib/scudo/standalone/tests/chunk_test.cpp; compiler-rt/lib/scudo/standalone/tests/combined_test.cpp; compiler-rt/lib/scudo/standalone/tests/common_test.cpp; compiler-rt/lib/scudo/standalone/tests/flags_test.cpp; compiler-rt/lib/scudo/standalone/tests/list_test.cpp; compiler-rt/lib/scudo/standalone/tests/map_test.cpp; compiler-rt/lib/scudo/standalone/tests/memtag_test.cpp; compiler-rt/lib/scudo/standalone/tests/mutex_test.cpp; compiler-rt/lib/scudo/standalone/tests/primary_test.cpp; compiler-rt/lib/scudo/standalone/tests/quarantine_test.cpp; compiler-rt/lib/scudo/standalone/tests/release_test.cpp; compiler-rt/lib/scudo/standalone/tests/report_test.cpp; compiler-rt/lib/scudo/standalone/tests/scudo_unit_test.h; compiler-rt/lib/scudo/standalone/tests/scudo_unit_test_main.cpp; compiler-rt/lib/scudo/standalone/tests/secondary_test.cpp; compiler-rt/lib/scudo/standalone/tests/size_class_map_test.cpp; compiler-rt/lib/scudo/standalone/tests/stats_test.cpp; compiler-rt/lib/scudo/standalone/tests/strings_test.cpp; compiler-rt/lib/scudo/standalone/tests/vector_test.cpp; compiler-rt/lib/scudo/standalone/tests/wrappers_cpp_test.cpp; compiler-rt/lib/scudo/standalone/tests/wrappers_c_test.cpp; compiler-rt/lib/scudo/standalone/tools/compute_size_class_config.cpp; compiler-rt/lib/tsan/rtl/tsan_fd.h; compiler-rt/lib/tsan/rtl/tsan_ignoreset.h; compiler-rt/lib/tsan/rtl/tsan_ilist.h; compiler-rt/lib/tsan/rtl/tsan_interface_ann.h; compiler-rt/lib/tsan/rt,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:102953,test,tests,102953,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['test'],['tests']
Testability,"write things like this:. .. code-block:: llvm. ; CHECK: movhpd	{{[0-9]+}}(%esp), {{%xmm[0-7]}}. In this case, any offset from the ESP register will be allowed, and any xmm; register will be allowed. Because regular expressions are enclosed with double braces, they are; visually distinct, and you don't need to use escape characters within the double; braces like you would in C. In the rare case that you want to match double; braces explicitly from the input, you can use something ugly like; ``{{[}][}]}}`` as your pattern. Or if you are using the repetition count; syntax, for example ``[[:xdigit:]]{8}`` to match exactly 8 hex digits, you; would need to add parentheses like this ``{{([[:xdigit:]]{8})}}`` to avoid; confusion with FileCheck's closing double-brace. FileCheck String Substitution Blocks; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. It is often useful to match a pattern and then verify that it occurs again; later in the file. For codegen tests, this can be useful to allow any; register, but verify that that register is used consistently later. To do; this, :program:`FileCheck` supports string substitution blocks that allow; string variables to be defined and substituted into patterns. Here is a simple; example:. .. code-block:: llvm. ; CHECK: test5:; ; CHECK: notw	[[REGISTER:%[a-z]+]]; ; CHECK: andw	{{.*}}[[REGISTER]]. The first check line matches a regex ``%[a-z]+`` and captures it into the; string variable ``REGISTER``. The second line verifies that whatever is in; ``REGISTER`` occurs later in the file after an ""``andw``"". :program:`FileCheck`; string substitution blocks are always contained in ``[[ ]]`` pairs, and string; variable names can be formed with the regex ``[a-zA-Z_][a-zA-Z0-9_]*``. If a; colon follows the name, then it is a definition of the variable; otherwise, it; is a substitution. :program:`FileCheck` variables can be defined multiple times, and substitutions; always get the latest value. Variables can also be substituted later on the; same line t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:26211,test,tests,26211,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['test'],['tests']
Testability,"written in Fortran around 1975-1980 at CERN by Fred; James @bib-MINUIT. Its main field of usage is statistical data analysis; of experimental data recorded at CERN, but it is also used by people; doing data analysis outside CERN or outside high energy physics (HEP).; In 2002 Fred James started a project aiming to re-implement M in an; object-oriented way using . More information about recent developments, releases and installation; can be obtained from the M homepage @bib-C++MINUIT. The names of M applications are written in capital letters (e.g.; $\mbox{MIGRAD}$, $\mbox{MINOS}$, $\mbox{CONTOURS}$), the; corresponding names of the classes are written using sans-serif font; type (MnMigrad, MnMinos, MnContours). # Introduction: M basic concepts #. [sec:intro]. ## The organization of M ##. The M package acts on a multiparameter *objective function* which is; called — for historical reasons — the $\mbox{FCN}$ function (see; [howto:fcn]). This function is usually a chisquared or a log–likelihood,; but it could also be a mathematical function. The $\mbox{FCN}$; function needs to be written in for which M defines the pure abstract; base class FCNBase as interface. The user must define and implement the; $\mbox{FCN}$ function in a derived class from FCNBase. Sometimes; this is done by an intermediate program such as HippoDraw@bib-HippoDraw,; in which case M is being used under the control of such an intermediate; program[^1]. The value of the $\mbox{FCN}$ function will in general; depend on one or more variable parameters whose meaning is defined by; the user (or by the intermediate program), but whose trial values are; determined by M . To take a simple example, suppose the problem is to fit a polynomial; through a set of data points. Then the user would write a; $\mbox{FCN}$ which calculates the $\chi^2$ between a polynomial and; the data; the variable parameters of $\mbox{FCN}$ would be the; coefficients of the polynomials. Using objects for minimization from M ,; the us",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:1905,log,log,1905,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['log'],['log']
Testability,"ws-base-vscode2019/Dockerfile>`_; with the entire build tool chain. This can be used to test the build with a; tool chain different from your host installation or to create build servers. Next steps; ==========; 1. Read the documentation.; 2. Seriously, read the documentation.; 3. Remember that you were warned twice about reading the documentation. Test LLVM on the command line:; ------------------------------; The LLVM tests can be run by changing directory to the llvm source; directory and running:. .. code-block:: bat. c:\llvm> python ..\build\Release\bin\llvm-lit.py llvm\test. This example assumes that Python is in your PATH variable, which would be; after **Add Python to the PATH** was selected during Python installation.; If you had opened a command window prior to Python installation, you would; have to close and reopen it to get the updated PATH. A specific test or test directory can be run with:. .. code-block:: bat. c:\llvm> python ..\build\Release\bin\llvm-lit.py llvm\test\Transforms\Util. Build the LLVM Suite:; ---------------------; * The projects may still be built individually, but to build them all do; not just select all of them in batch build (as some are meant as; configuration projects), but rather select and build just the; ``ALL_BUILD`` project to build everything, or the ``INSTALL`` project,; which first builds the ``ALL_BUILD`` project, then installs the LLVM; headers, libs, and other useful things to the directory set by the; ``CMAKE_INSTALL_PREFIX`` setting when you first configured CMake.; * The Fibonacci project is a sample program that uses the JIT. Modify the; project's debugging properties to provide a numeric command line argument; or run it from the command line. The program will print the; corresponding fibonacci value. Links; =====; This document is just an **introduction** to how to use LLVM to do some simple; things... there are many more interesting and complicated things that you can; do that aren't documented here (but we'll gl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:9524,test,test,9524,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,1,['test'],['test']
Testability,"x - correct scaling of axis labels when tilt them by 25 degree, make this angle configurable; 26. Fix - legend multi-columns drawing and labels scaling; 27. Fix - graph ""B"" bar widths as in native ROOT; 28. Fix - use pad and not frame size for `TText` / `TLatex` scaling; 29. Fix - properly handle ""NB"" (no border) draw option for `TPave` classes; 30. Fix - do not draw histogram title with AXIS draw option; 31. Fix - correct scaling of custom axis labels; 32. Fix - shrink axis labels like 0.20 -> 0.2 or 10^0 -> 1; 33. Fix - copy axis attributes from histogram z scale to palette; 34. Fix - let handle derived from TH1/TH2 classes as histograms #269. ## Changes in 7.4.3; 1. Fix - correctly use GMT specifier in time format; 2. Fix - logical error in `decodeUrl`; 3. Fix - member-wise streaming of std::map #262. ## Changes in 7.4.2; 1. Fix - unzoom z on lego2 plots; 2. Fix - browsing TLists with nullptr inside; 3. Fix - check NaN values when performing TTree::Draw(); 4. Fix - support standard log function in TF1/TF2. ## Changes in 7.4.1; 1. Fix - context menu position on lego plots; 2. Fix - add missing math functions Chebyshev0 and normalized Gaus; 3. Fix - correctly render TPolyLine3D; 4. Fix - properly add interactive resize elements for paves and frame; 5. Fix - drag and drop handling on tabs layout. ## Changes in 7.4.0; 1. Upgrade d3.js v7.6.1 -> v7.8.4; 2. Upgrade three.js r146 -> r151; 3. Support `[cutg]` draw option for TH2; 4. Correctly handle `same0` draw option for TH2; 5. Fix several issues with axis reverse order, support on lego plots; 6. Support more kinds of log scales - ln and logN where N is any positive integer; 7. Adjust TAxis title positioning to native ROOT behavior; 8. Add interactivity (moving, context menu) for TLine, TBox, TText, TLatex, TDiamond, TGaxis, TASImage; 9. Use new gStyle attributes for candle and violin plots; 10. Implement autoplace for TLegend, also via context menu; 11. Change algorithm of building smooth (bezier) curves; 12. Let cha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:11716,log,log,11716,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['log'],['log']
Testability,"x was updated from 0.6.4 to 0.6.7 (support for OpenSSL 1.1, [ROOT-9353](https://sft.its.cern.ch/jira/browse/ROOT-9353)); - Vdt has been updated from 0.3.9 to 0.4.1 (includes new atan function); - XRootd has been updated from 4.6.1 to 4.8.2 (for GCC 8.x support); - Builtin TBB can now be used on Windows; - xxHash and LZ4 have been separated so that a system version of LZ4 can be used even if it does not include xxHash headers ([ROOT-9099](https://sft.its.cern.ch/jira/browse/ROOT-9099)); - In addition, several updates have been made to fix minor build system issues, such as not checking for external packages if their builtin is turned off, or checking for packages even when the respective option is disabled ([ROOT-8806](https://sft.its.cern.ch/jira/browse/ROOT-8806), [ROOT-9190](https://sft.its.cern.ch/jira/browse/ROOT-9190), [ROOT-9315](https://sft.its.cern.ch/jira/browse/ROOT-9315), [ROOT-9385](https://sft.its.cern.ch/jira/browse/ROOT-9385)).; - The `python3` option to CMake has been removed ([ROOT-9033](https://sft.its.cern.ch/jira/browse/ROOT-9033), [ROOT-9143](https://sft.its.cern.ch/jira/browse/ROOT-9143)). Python support is enabled by default. To configure ROOT to use specific Python versions, there is a new option called `python_version`. This is how to configure ROOT and Python for the common use cases:. * Use the default Python interpreter:; - `-Dpython=ON` (default); * Search only for Python 2.x or only 3.x:; - `-Dpython_version=2` or `-Dpython_version=3`; * Use a specific version of Python from `$PATH`:; - `-Dpython_version=2.7` or `-Dpython_version=3.5`; * Use a specific Python interpreter, whatever the version:; - `-DPYTHON_EXECUTABLE=/usr/local/bin/python`. Note: The use of `PYTHON_EXECUTABLE` requires the full path to the interpreter. ## Infrastructure and Testing. - Reduce time taken by tests which takes too long to run ({One,Two}SidedFrequentistUpperLimitWithBands.C); - Disable PyROOT SQL tutorials (the C++ counterparts are since several releases).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:20252,test,tests,20252,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['test'],['tests']
Testability,"x10.2-256``, because ``avx10.2-256`` implies ``avx10.1-256``; and ``-mavx512f -mavx10.1-256`` equals to ``-mavx10.1-512``. There are some new macros introduced with AVX10 support. ``-mavx10.1-256`` will; enable ``__AVX10_1__`` and ``__EVEX256__``, while ``-mavx10.1-512`` enables; ``__AVX10_1__``, ``__EVEX256__``, ``__EVEX512__`` and ``__AVX10_1_512__``.; Besides, both ``-mavx10.1-256`` and ``-mavx10.1-512`` will enable all AVX512; feature specific macros. A AVX512 feature will enable both ``__EVEX256__``,; ``__EVEX512__`` and its own macro. So ``__EVEX512__`` can be used to guard code; that can run on both legacy AVX512 and AVX10/512 capable processors but cannot; run on AVX10/256, while a AVX512 macro like ``__AVX512F__`` cannot tell the; difference among the three options. Users need to check additional macros; ``__AVX10_1__`` and ``__EVEX512__`` if they want to make distinction. ARM; ^^^. The support for ARM (specifically ARMv6 and ARMv7) is considered stable; on Darwin (iOS): it has been tested to correctly compile many large C,; C++, Objective-C, and Objective-C++ codebases. Clang only supports a; limited number of ARM architectures. It does not yet fully support; ARMv5, for example. PowerPC; ^^^^^^^. The support for PowerPC (especially PowerPC64) is considered stable; on Linux and FreeBSD: it has been tested to correctly compile many; large C and C++ codebases. PowerPC (32bit) is still missing certain; features (e.g. PIC code on ELF platforms). Other platforms; ^^^^^^^^^^^^^^^. clang currently contains some support for other architectures (e.g. Sparc);; however, significant pieces of code generation are still missing, and they; haven't undergone significant testing. clang contains limited support for the MSP430 embedded processor, but; both the clang support and the LLVM backend support are highly; experimental. Other platforms are completely unsupported at the moment. Adding the; minimal support needed for parsing and semantic analysis on a new; platform is q",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:161540,test,tested,161540,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['test'],['tested']
Testability,"x2 < %s | FileCheck %s -check-prefix=AVX2. And the checks are different:. .. code-block:: llvm. ; SSE2: @test1; ; SSE2: psubusw LCPI0_0(%rip), %xmm0; ; AVX1: @test1; ; AVX1: vpsubusw LCPI0_0(%rip), %xmm0, %xmm0; ; AVX2: @test1; ; AVX2: vpsubusw LCPI0_0(%rip), %xmm0, %xmm0. So, if you're testing for a behaviour that you know is platform-specific or; depends on special features of sub-architectures, you must add the specific; triple, test with the specific FileCheck and put it into the specific; directory that will filter out all other architectures. Constraining test execution; ---------------------------. Some tests can be run only in specific configurations, such as; with debug builds or on particular platforms. Use ``REQUIRES``; and ``UNSUPPORTED`` to control when the test is enabled. Some tests are expected to fail. For example, there may be a known bug; that the test detect. Use ``XFAIL`` to mark a test as an expected failure.; An ``XFAIL`` test will be successful if its execution fails, and; will be a failure if its execution succeeds. .. code-block:: llvm. ; This test will be only enabled in the build with asserts.; ; REQUIRES: asserts; ; This test is disabled when running on Linux.; ; UNSUPPORTED: system-linux; ; This test is expected to fail when targeting PowerPC.; ; XFAIL: target=powerpc{{.*}}. ``REQUIRES`` and ``UNSUPPORTED`` and ``XFAIL`` all accept a comma-separated; list of boolean expressions. The values in each expression may be:. - Features added to ``config.available_features`` by configuration files such as ``lit.cfg``.; String comparison of features is case-sensitive. Furthermore, a boolean expression can; contain any Python regular expression enclosed in ``{{ }}``, in which case the boolean; expression is satisfied if any feature matches the regular expression. Regular; expressions can appear inside an identifier, so for example ``he{{l+}}o`` would match; ``helo``, ``hello``, ``helllo``, and so on.; - The default target triple, preceded by the s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:19896,test,test,19896,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['test']
Testability,"x86, this data is stored in the flags register used by the; conditional jump instruction. Along both edges after this fork in control flow,; the flags register remains alive and contains data that we can use to build up; our accumulated predicate state. We accumulate it using the x86 conditional; move instruction which also reads the flag registers where the state resides.; These conditional move instructions are known to not be predicted on any x86; processors, making them immune to misprediction that could reintroduce the; vulnerability. When we insert the conditional moves, the code ends up looking; like the following:; ```; # %bb.0: # %entry; pushq %rax; xorl %eax, %eax # Zero out initial predicate state.; movq $-1, %r8 # Put all-ones mask into a register.; testl %edi, %edi; jne .LBB0_1; # %bb.2: # %then1; cmovneq %r8, %rax # Conditionally update predicate state.; testl %esi, %esi; jne .LBB0_1; # %bb.3: # %then2; cmovneq %r8, %rax # Conditionally update predicate state.; testl %edx, %edx; je .LBB0_4; .LBB0_1:; cmoveq %r8, %rax # Conditionally update predicate state.; popq %rax; retq; .LBB0_4: # %danger; cmovneq %r8, %rax # Conditionally update predicate state.; ...; ```. Here we create the ""empty"" or ""correct execution"" predicate state by zeroing; `%rax`, and we create a constant ""incorrect execution"" predicate value by; putting `-1` into `%r8`. Then, along each edge coming out of a conditional; branch we do a conditional move that in a correct execution will be a no-op,; but if misspeculated, will replace the `%rax` with the value of `%r8`.; Misspeculating any one of the three predicates will cause `%rax` to hold the; ""incorrect execution"" value from `%r8` as we preserve incoming values when; execution is correct rather than overwriting it. We now have a value in `%rax` in each basic block that indicates if at some; point previously a predicate was mispredicted. And we have arranged for that; value to be particularly effective when used below to harden loads. #",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:16802,test,testl,16802,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['test'],['testl']
Testability,"x86_64-unknown-linux-gnu, but not armv8l-unknown-linux-gnueabihf.; Prefer to use hyphens to delimit triple components (``target=mips-{{.*}}``); and it's generally a good idea to use a trailing wildcard to allow for; unexpected suffixes. Also, it's generally better to write regular expressions that use entire; triple components, than to do something clever to shorten them. For; example, to match both freebsd and netbsd in an expression, you could write; ``target={{.*(free|net)bsd.*}}`` and that would work. However, it would; prevent a ``grep freebsd`` from finding this test. Better to use:; ``target={{.+-freebsd.*}} || target={{.+-netbsd.*}}``. Substitutions; -------------. Besides replacing LLVM tool names the following substitutions are performed in; RUN lines:. ``%%``; Replaced by a single ``%``. This allows escaping other substitutions. ``%s``; File path to the test case's source. This is suitable for passing on the; command line as the input to an LLVM tool. Example: ``/home/user/llvm/test/MC/ELF/foo_test.s``. ``%S``; Directory path to the test case's source. Example: ``/home/user/llvm/test/MC/ELF``. ``%t``; File path to a temporary file name that could be used for this test case.; The file name won't conflict with other test cases. You can append to it; if you need multiple temporaries. This is useful as the destination of; some redirected output. Example: ``/home/user/llvm.build/test/MC/ELF/Output/foo_test.s.tmp``. ``%T``; Directory of ``%t``. Deprecated. Shouldn't be used, because it can be easily; misused and cause race conditions between tests. Use ``rm -rf %t && mkdir %t`` instead if a temporary directory is necessary. Example: ``/home/user/llvm.build/test/MC/ELF/Output``. ``%{pathsep}``. Expands to the path separator, i.e. ``:`` (or ``;`` on Windows). ``${fs-src-root}``; Expands to the root component of file system paths for the source directory,; i.e. ``/`` on Unix systems or ``C:\`` (or another drive) on Windows. ``${fs-tmp-root}``; Expands to the root c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:24044,test,test,24044,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['test']
Testability,"x; src/RooTruthModel.cxx; src/RooUniformBinning.cxx; src/RooUnitTest.cxx; src/RooVectorDataStore.cxx; src/RooWorkspace.cxx; src/RooWrapperPdf.cxx; src/TestStatistics/ConstantTermsOptimizer.cxx; src/TestStatistics/LikelihoodGradientWrapper.cxx; src/TestStatistics/LikelihoodSerial.cxx; src/TestStatistics/LikelihoodWrapper.cxx; src/TestStatistics/MinuitFcnGrad.cxx; src/TestStatistics/RooAbsL.cxx; src/TestStatistics/RooBinnedL.cxx; src/TestStatistics/RooRealL.cxx; src/TestStatistics/RooSubsidiaryL.cxx; src/TestStatistics/RooSumL.cxx; src/TestStatistics/RooUnbinnedL.cxx; src/TestStatistics/buildLikelihood.cxx; src/TestStatistics/SharedOffset.cxx; ${LegacyEvalBackendSources}; ${RooFitMPTestStatisticsSources}; DICTIONARY_OPTIONS; ""-writeEmptyRootPCM""; LIBRARIES; RooBatchCompute; ${EXTRA_LIBRARIES}; DEPENDENCIES; Core; Hist; Graf; Matrix; Tree; Minuit; RIO; MathCore; Foam; Smatrix; ${EXTRA_DEPENDENCIES}; LINKDEF; inc/LinkDef.h; ${EXTRA_DICT_OPTS}; ). # The following definitions are PUBLIC so they can also be used in ROOT-internal tests. if(roofit_legacy_eval_backend); target_compile_definitions(RooFitCore PUBLIC ROOFIT_LEGACY_EVAL_BACKEND); endif(). if(roofit_multiprocess); target_compile_definitions(RooFitCore PUBLIC ROOFIT_MULTIPROCESS); endif(). if(clad); target_compile_definitions(RooFitCore PUBLIC ROOFIT_CLAD); endif(). if(cuda); target_compile_definitions(RooFitCore PUBLIC ROOFIT_CUDA); endif(). if(fftw3); target_compile_definitions(RooFitCore PUBLIC ROOFIT_MATH_FFTW3); endif(). # To avoid deprecation warnings when including old test statistics headers.; # RooFit has to include them to build the documentation.; target_compile_definitions(RooFitCore PUBLIC ROOFIT_BUILDS_ITSELF). target_include_directories(RooFitCore PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/res>). # For recent clang, this can facilitate auto-vectorisation.; # In RooFit, the errno side effect is not needed, anyway:; if(""${CMAKE_CXX_COMPILER_ID}"" MATCHES ""Clang""); target_compile_options(RooFit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/CMakeLists.txt:10621,test,tests,10621,roofit/roofitcore/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/CMakeLists.txt,1,['test'],['tests']
Testability,"xTrack-1);; ntrack = nt;; sumstat = 0;; // set the values in each track; for (Int_t n=0;n<nt;n++) {; stat[n] = n%3;; sign[n] = i%2;; px[n] = gRandom->Gaus(0,1);; py[n] = gRandom->Gaus(0,2);; pz[n] = gRandom->Gaus(10,5);; zv[n] = gRandom->Gaus(100,2);; chi2[n] = gRandom->Gaus(0,.01);; sumstat += chi2[n];; pt[n] = TMath::Sqrt(px[n]*px[n] + py[n]*py[n]);; }; t3->Fill();; t3f->Fill();; }; // Write the two files; t3->Print();; f.cd();; t3->Write();; fr.cd();; t3f->Write();; }. // Function to read the two files and add the friend; void tree3r() {; TFile *f = new TFile(""tree3.root"");; TTree *t3 = (TTree*)f->Get(""t3"");; // Add the second tree to the first tree as a friend; t3->AddFriend(""t3f"",""tree3f.root"");; // Draw pz which is in the first tree and use pt; // in the condition. pt is in the friend tree.; t3->Draw(""pz"",""pt>3"");; }. // This is executed when typing .x tree3.C; void tree3() {; tree3w();; tree3r();; }; ```. ## Example 4: A Tree with an Event Class. This example is a simplified version of `$ROOTSYS/test/MainEvent.cxx`; and where Event objects are saved in a tree. The full definition of; `Event` is in `$ROOTSYS/test`/`Event.h`. To execute this macro, you will; need the library `$ROOTSYS/test/libEvent.so`. If it does not exist you; can build the test directory applications by following the instruction; in the `$ROOTSYS/test/README` file. In this example we will show. - the difference in splitting or not splitting a branch; - how to read selected branches of the tree,; - how to print a selected entry. ### The Event Class. `Event` is a descendent of **`TObject`**. As such it inherits the data; members of **`TObject`** and its methods such as `Dump()` and; `Inspect() `and` Write()`. In addition, because it inherits from; **`TObject`** it can be a member of a collection. To summarize, the; advantages of inheriting from a **`TObject`** are:. - Inherit the `Write`, `Inspect`, and `Dump` methods; - Enables a class to be a member of a ROOT collection; - Enables RTTI. Belo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:58046,test,test,58046,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['test'],['test']
Testability,"xample:. .. code-block:: console. $ D:\git> git clone https://github.com/mjansson/rpmalloc; $ D:\llvm-project> cmake ... -DLLVM_INTEGRATED_CRT_ALLOC=D:\git\rpmalloc. This flag needs to be used along with the static CRT, ie. if building the; Release target, add -DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreaded. **LLVM_INSTALL_DOXYGEN_HTML_DIR**:STRING; The path to install Doxygen-generated HTML documentation to. This path can; either be absolute or relative to the *CMAKE_INSTALL_PREFIX*. Defaults to; ``${CMAKE_INSTALL_DOCDIR}/llvm/doxygen-html``. **LLVM_LINK_LLVM_DYLIB**:BOOL; If enabled, tools will be linked with the libLLVM shared library. Defaults; to OFF. Setting LLVM_LINK_LLVM_DYLIB to ON also sets LLVM_BUILD_LLVM_DYLIB; to ON.; This option is not available on Windows. **LLVM_LIT_ARGS**:STRING; Arguments given to lit. ``make check`` and ``make clang-test`` are affected.; By default, ``'-sv --no-progress-bar'`` on Visual C++ and Xcode, ``'-sv'`` on; others. **LLVM_LIT_TOOLS_DIR**:PATH; The path to GnuWin32 tools for tests. Valid on Windows host. Defaults to; the empty string, in which case lit will look for tools needed for tests; (e.g. ``grep``, ``sort``, etc.) in your %PATH%. If GnuWin32 is not in your; %PATH%, then you can set this variable to the GnuWin32 directory so that; lit can find tools needed for tests in that directory. **LLVM_NATIVE_TOOL_DIR**:STRING; Full path to a directory containing executables for the build host; (containing binaries such as ``llvm-tblgen`` and ``clang-tblgen``). This is; intended for cross-compiling: if the user sets this variable and the; directory contains executables with the expected names, no separate; native versions of those executables will be built. **LLVM_NO_INSTALL_NAME_DIR_FOR_BUILD_TREE**:BOOL; Defaults to ``OFF``. If set to ``ON``, CMake's default logic for library IDs; on Darwin in the build tree will be used. Otherwise the install-time library; IDs will be used in the build tree as well. Mainly useful when other CMake; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:30998,test,tests,30998,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['test'],['tests']
Testability,"xc0000005 thrown in the test body.; # According to the internet, this has to do with gtest, so it's not a RooFit problem; ROOT_ADD_GTEST(testRooRealIntegral testRooRealIntegral.cxx LIBRARIES RooFitCore); endif(); if(clad); if(NOT MSVC OR MSVC_VERSION GREATER_EQUAL 1938); # Disabled on Windows with Visual Studio before v17.8 because it causes the following error:; # Assertion failed: Ctx->isFileContext() && ""We should have been looking; # only at file context here already."", file; # C:\build\workspace\root-pullrequests-build\root\interpreter\llvm-project\clang\lib\Sema\SemaLookup.cpp,; # line 1492; ROOT_ADD_GTEST(testRooFuncWrapper testRooFuncWrapper.cxx LIBRARIES RooFitCore RooFit HistFactory); endif(); endif(); ROOT_ADD_GTEST(testGlobalObservables testGlobalObservables.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testInterface TestStatistics/testInterface.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testLikelihoodSerial TestStatistics/testLikelihoodSerial.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testNaNPacker testNaNPacker.cxx LIBRARIES RooFitCore RooBatchCompute); ROOT_ADD_GTEST(testRooAbsL TestStatistics/testRooAbsL.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testRooCurve testRooCurve.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testRooHist testRooHist.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testRooHistPdf testRooHistPdf.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testRooPolyFunc testRooPolyFunc.cxx LIBRARIES Gpad RooFitCore); ROOT_ADD_GTEST(testRooRealL TestStatistics/testRooRealL.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testRooRombergIntegrator testRooRombergIntegrator.cxx LIBRARIES MathCore RooFitCore); ROOT_ADD_GTEST(testRooSTLRefCountList testRooSTLRefCountList.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testRooSimultaneous testRooSimultaneous.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testRooTruthModel testRooTruthModel.cxx LIBRARIES RooFitCore RooFit); ROOT_ADD_GTEST(testSumW2Error testSumW2Error.cxx LIBRARIES Gpad RooFitCore); ROOT_ADD_GTEST(testTestStatistics testTe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/CMakeLists.txt:3634,test,testNaNPacker,3634,roofit/roofitcore/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/CMakeLists.txt,2,['test'],['testNaNPacker']
Testability,"xceptions from; leaving destructors. class C {; int *p; // warn; public:; C() { p = new int; }; ~C() { delete p; }; };. WinAPI. Name, DescriptionExampleProgress. WinAPI.CreateProcess; (C); CreateProcess(): if the first parameter ; lpApplicationName is NULL then the executable name must be in the; white space-delimited string pointed to by lpCommandLine.; If the executable or path name has a space in it, there is a risk that a; different executable could be run because of the way the function parses; spaces.; Source: ; MSDN: CreateProcess function, Security Remarks. #include <windows.h>. void test() {; STARTUPINFO si;; PROCESS_INFORMATION pi;; CreateProcess(NULL, TEXT(""C:\\Program Files\\App -L -S""),; NULL, NULL, TRUE, 0, NULL, NULL, &si, π);; // warn; }. WinAPI.LoadLibrary; (C); The SearchPath() function is used to retrieve a path to a DLL for; a subsequent LoadLibrary() call.; Source: ; MSDN: LoadLibrary function, Security Remarks. #include <windows.h>. HINSTANCE test() {; char filePath[100];; SearchPath(NULL, ""file.dll"", NULL, 100, filePath, NULL);; return LoadLibrary(filePath); // warn; }. WinAPI.WideCharToMultiByte; (C); Buffer overrun while calling WideCharToMultiByte(). The size of; the input buffer equals the number of characters in the Unicode string, while; the size of the output buffer equals the number of bytes.; Source: ; MSDN: WideCharToMultiByte function. #include <windows.h>. void test() {; wchar_t ws[] = L""abc"";; char s[3];; WideCharToMultiByte(CP_UTF8, 0, ws, -1, s,; 3, NULL, NULL); // warn; }. optimization. Name, DescriptionExampleProgress. optimization.PassConstObjByValue; (C, C++); Optimization: It is more effective to pass constant parameter by reference to; avoid unnecessary object copying. struct A {};. void f(const struct A a); // warn. optimization.PostfixIncIter; (C++); Optimization: It is more effective to use prefix increment operator with; iterator.; Source: Scott Meyers ""More Effective C++"", item 6:; Distinguish between prefix and postfi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:26658,test,test,26658,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability,"xecuted at least once. Template functions and static inline; functions from headers are two kinds of functions which may have multiple; instantiations. This statistic is hidden by default in reports, but can be; enabled via the ``-show-instantiation-summary`` option. * Line coverage is the percentage of code lines which have been executed at; least once. Only executable lines within function bodies are considered to be; code lines. * Region coverage is the percentage of code regions which have been executed at; least once. A code region may span multiple lines (e.g in a large function; body with no control flow). However, it's also possible for a single line to; contain multiple code regions (e.g in ""return x || y && z""). * Branch coverage is the percentage of ""true"" and ""false"" branches that have; been taken at least once. Each branch is tied to individual conditions in the; source code that may each evaluate to either ""true"" or ""false"". These; conditions may comprise larger boolean expressions linked by boolean logical; operators. For example, ""x = (y == 2) || (z < 10)"" is a boolean expression; that is comprised of two individual conditions, each of which evaluates to; either true or false, producing four total branch outcomes. * Modified Condition/Decision Coverage (MC/DC) is the percentage of individual; branch conditions that have been shown to independently affect the decision; outcome of the boolean expression they comprise. This is accomplished using; the analysis of executed control flow through the expression (i.e. test; vectors) to show that as a condition's outcome is varied between ""true"" and; false"", the decision's outcome also varies between ""true"" and false"", while; the outcome of all other conditions is held fixed (or they are masked out as; unevaluatable, as happens in languages whose logical operators have; short-circuit semantics). MC/DC builds on top of branch coverage and; requires that all code blocks and all execution paths have been tested. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:12017,log,logical,12017,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,1,['log'],['logical']
Testability,"xes and new features should `include a testcase`_ so we know if the; fix/feature ever regresses in the future. #. Code must pass the ``llvm/test`` test suite. #. The code must not cause regressions on a reasonable subset of llvm-test,; where ""reasonable"" depends on the contributor's judgement and the scope of; the change (more invasive changes require more testing). A reasonable subset; might be something like ""``llvm-test/MultiSource/Benchmarks``"". #. Ensure that links in source code and test files point to publicly available; resources and are used primarily to add additional information rather than; to supply critical context. The surrounding comments should be sufficient; to provide the context behind such links. Additionally, the committer is responsible for addressing any problems found in; the future that the change is responsible for. For example:. * The code should compile cleanly on all supported platforms. * The changes should not cause any correctness regressions in the ``llvm-test``; suite and must not cause any major performance regressions. * The change set should not cause performance or correctness regressions for the; LLVM tools. * The changes should not cause performance or correctness regressions in code; compiled by LLVM on all applicable targets. * You are expected to address any `GitHub Issues <https://github.com/llvm/llvm-project/issues>`_ that; result from your change. We prefer for this to be handled before submission but understand that it isn't; possible to test all of this for every submission. Our build bots and nightly; testing infrastructure normally finds these problems. A good rule of thumb is; to check the nightly testers for regressions the day after your change. Build; bots will directly email you if a group of commits that included yours caused a; failure. You are expected to check the build bot messages to see if they are; your fault and, if so, fix the breakage. Commits that violate these quality standards (e.g. are very broken",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:13604,test,test,13604,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['test'],['test']
Testability,"ximums. .. option:: --filter=REGEXP. Run only those tests whose name matches the regular expression specified in; ``REGEXP``. The environment variable ``LIT_FILTER`` can be also used in place; of this option, which is especially useful in environments where the call; to ``lit`` is issued indirectly. .. option:: --filter-out=REGEXP. Filter out those tests whose name matches the regular expression specified in; ``REGEXP``. The environment variable ``LIT_FILTER_OUT`` can be also used in; place of this option, which is especially useful in environments where the; call to ``lit`` is issued indirectly. .. option:: --xfail=LIST. Treat those tests whose name is in the semicolon separated list ``LIST`` as; ``XFAIL``. This can be helpful when one does not want to modify the test; suite. The environment variable ``LIT_XFAIL`` can be also used in place of; this option, which is especially useful in environments where the call to; ``lit`` is issued indirectly. A test name can specified as a file name relative to the test suite directory.; For example:. .. code-block:: none. LIT_XFAIL=""affinity/kmp-hw-subset.c;offloading/memory_manager.cpp"". In this case, all of the following tests are treated as ``XFAIL``:. .. code-block:: none. libomp :: affinity/kmp-hw-subset.c; libomptarget :: nvptx64-nvidia-cuda :: offloading/memory_manager.cpp; libomptarget :: x86_64-pc-linux-gnu :: offloading/memory_manager.cpp. Alternatively, a test name can be specified as the full test name; reported in LIT output. For example, we can adjust the previous; example not to treat the ``nvptx64-nvidia-cuda`` version of; ``offloading/memory_manager.cpp`` as XFAIL:. .. code-block:: none. LIT_XFAIL=""affinity/kmp-hw-subset.c;libomptarget :: x86_64-pc-linux-gnu :: offloading/memory_manager.cpp"". .. option:: --xfail-not=LIST. Do not treat the specified tests as ``XFAIL``. The environment variable; ``LIT_XFAIL_NOT`` can also be used in place of this option. The syntax is the; same as for :option:`--xfail` and ``LIT_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:9036,test,test,9036,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,2,['test'],['test']
Testability,xmodules AND WIN32); set (EXTRA_DICT_OPTS NO_CXXMODULE); endif(). ROOT_STANDARD_LIBRARY_PACKAGE(TreePlayer; HEADERS; ROOT/TTreeReaderFast.hxx; ROOT/TTreeReaderValueFast.hxx; TBranchProxyClassDescriptor.h; TBranchProxyDescriptor.h; TBranchProxyDirector.h; TBranchProxy.h; TChainIndex.h; TFileDrawMap.h; TFormLeafInfo.h; TFormLeafInfoReference.h; TFriendProxyDescriptor.h; TFriendProxy.h; TRefArrayProxy.h; TRefProxy.h; TSelectorDraw.h; TSelectorEntries.h; TSimpleAnalysis.h; TTreeDrawArgsParser.h; TTreeFormula.h; TTreeFormulaManager.h; TTreeGeneratorBase.h; TTreeIndex.h; TTreePerfStats.h; TTreePlayer.h; TTreeProxyGenerator.h; TTreeReaderArray.h; TTreeReaderGenerator.h; TTreeReader.h; TTreeReaderUtils.h; TTreeReaderValue.h; TTreeTableInterface.h; ${TREEPLAYER_EXTRA_HEADERS}; SOURCES; src/TBranchProxyClassDescriptor.cxx; src/TBranchProxy.cxx; src/TBranchProxyDescriptor.cxx; src/TBranchProxyDirector.cxx; src/TChainIndex.cxx; src/TFileDrawMap.cxx; src/TFormLeafInfo.cxx; src/TFormLeafInfoReference.cxx; src/TFriendProxy.cxx; src/TFriendProxyDescriptor.cxx; src/TRefArrayProxy.cxx; src/TRefProxy.cxx; src/TSelectorDraw.cxx; src/TSelectorEntries.cxx; src/TSimpleAnalysis.cxx; src/TTreeDrawArgsParser.cxx; src/TTreeFormula.cxx; src/TTreeFormulaManager.cxx; src/TTreeGeneratorBase.cxx; src/TTreeIndex.cxx; src/TTreePerfStats.cxx; src/TTreePlayer.cxx; src/TTreeProxyGenerator.cxx; src/TTreeReaderArray.cxx; src/TTreeReader.cxx; src/TTreeReaderFast.cxx; src/TTreeReaderGenerator.cxx; src/TTreeReaderValue.cxx; src/TTreeReaderValueFast.cxx; src/TTreeTableInterface.cxx; DICTIONARY_OPTIONS; -writeEmptyRootPCM; DEPENDENCIES; Gpad; Graf; Graf3d; Hist; ${TREEPLAYER_EXTRA_DEPENDENCIES}; MathCore; RIO; Tree; ${EXTRA_DICT_OPTS}; ). if(NOT MSVC); target_sources(TreePlayer PRIVATE; src/TMPWorkerTree.cxx; src/TTreeProcessorMP.cxx; ); target_link_libraries(TreePlayer PUBLIC MultiProc); endif(). if(imt); target_sources(TreePlayer PRIVATE src/TTreeProcessorMT.cxx); endif(). ROOT_ADD_TEST_SUBDIRECTORY(test); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/CMakeLists.txt:2731,test,test,2731,tree/treeplayer/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/CMakeLists.txt,1,['test'],['test']
Testability,"xpected to fail when targeting PowerPC or running on Darwin.; ; XFAIL: target=powerpc{{.*}}, system-darwin. Tips for writing constraints; ----------------------------. **``REQUIRES`` and ``UNSUPPORTED``**. These are logical inverses. In principle, ``UNSUPPORTED`` isn't absolutely; necessary (the logical negation could be used with ``REQUIRES`` to get; exactly the same effect), but it can make these clauses easier to read and; understand. Generally, people use ``REQUIRES`` to state things that the test; depends on to operate correctly, and ``UNSUPPORTED`` to exclude cases where; the test is expected never to work. **``UNSUPPORTED`` and ``XFAIL``**. Both of these indicate that the test isn't expected to work; however, they; have different effects. ``UNSUPPORTED`` causes the test to be skipped;; this saves execution time, but then you'll never know whether the test; actually would start working. Conversely, ``XFAIL`` actually runs the test; but expects a failure output, taking extra execution time but alerting you; if/when the test begins to behave correctly (an XPASS test result). You; need to decide which is more appropriate in each case. **Using ``target=...``**. Checking the target triple can be tricky; it's easy to mis-specify. For; example, ``target=mips{{.*}}`` will match not only mips, but also mipsel,; mips64, and mips64el. ``target={{.*}}-linux-gnu`` will match; x86_64-unknown-linux-gnu, but not armv8l-unknown-linux-gnueabihf.; Prefer to use hyphens to delimit triple components (``target=mips-{{.*}}``); and it's generally a good idea to use a trailing wildcard to allow for; unexpected suffixes. Also, it's generally better to write regular expressions that use entire; triple components, than to do something clever to shorten them. For; example, to match both freebsd and netbsd in an expression, you could write; ``target={{.*(free|net)bsd.*}}`` and that would work. However, it would; prevent a ``grep freebsd`` from finding this test. Better to use:; ``target={{",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:22594,test,test,22594,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,3,['test'],['test']
Testability,"xplicitly set linkage to each; item:. ``` {.cpp}; #pragma link [C|C++|off] [class|function|global]; ```. This pragma statement must be given before `rootcling` reads any; C/C++ definitions from header files. Example:. ``` {.cpp}; #ifdef __ROOTCLING__; #pragma link default off;; #endif. class A {; int a;; double b;; };. class B {; int d;; double e;; };. #ifdef __ROOTCLING__; #pragma link C++ class A; // only class A is linked, not B; #endif; ```. ##### Compilation. **Step 4:** Compile the class using the `Makefile. `In the `Makefile`; call `rootcling` to make the dictionary for the class. Call it; `SClassDict.cxx`. The `rootcling` utility generates the methods; `Streamer`, **`TBuffer`** &operator\>\>() and `ShowMembers `for ROOT; classes. ``` {.cpp}; gmake -f Makefile; ```. Load the shared library:. ``` {.cpp}; root[] .L SClass.so; root[] SClass *sc = new SClass(); root[] TFile *f = new TFile(""Afile.root"",""UPDATE"");; root[] sc->Write();; ```. For more information on `rootcling` see the `$ROOTSYS/test` directory; `Makefile`, `Event.cxx`, and `Event.h` for an example, or follow this; link: <http://root.cern.ch/root/RootCintMan.html>. ## genreflex: A Comfortable Interface to rootcling. Version 5 supported both `Cint` and `Reflex` dictionaries. The tool to create; `Reflex` dictionaries was a Python script called `genreflex` and was very; successful in the user community.; Even if version 6 has only one type of dictionaries, `cling` dictionaries,; a re-implementation of `genreflex` is provided.; More precisely, in ROOT6, `genreflex` is nothing but a wrapper around; `rootcling`, which offers an identical CLI and behaviour to the old Python; tool.; The input to `genreflex` is a C++ header file, a set of switches and a; *selection XML file*. The output, as for `rootcling`, is a C++ dictionary; source and a `pcm` files.; An exhaustive documentation of the CLI switches of `genreflex` can be; inspected with the `genreflex --help` command. The entity corresponding to the `LinkDef",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:33491,test,test,33491,documentation/users-guide/AddingaClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md,1,['test'],['test']
Testability,xpm1f.h; libc/src/math/fabs.h; libc/src/math/fabsf.h; libc/src/math/fabsl.h; libc/src/math/fdim.h; libc/src/math/fdimf.h; libc/src/math/fdiml.h; libc/src/math/floor.h; libc/src/math/floorf.h; libc/src/math/floorl.h; libc/src/math/fma.cpp; libc/src/math/fma.h; libc/src/math/fmaf.cpp; libc/src/math/fmaf.h; libc/src/math/fmax.h; libc/src/math/fmaxf.h; libc/src/math/fmaxl.h; libc/src/math/fmin.h; libc/src/math/fminf.h; libc/src/math/fminl.h; libc/src/math/frexp.h; libc/src/math/frexpf.h; libc/src/math/frexpl.h; libc/src/math/hypot.h; libc/src/math/hypotf.h; libc/src/math/ilogb.h; libc/src/math/ilogbf.h; libc/src/math/ilogbl.h; libc/src/math/ldexp.h; libc/src/math/ldexpf.h; libc/src/math/ldexpl.h; libc/src/math/llrint.h; libc/src/math/llrintf.h; libc/src/math/llrintl.h; libc/src/math/llround.h; libc/src/math/llroundf.h; libc/src/math/llroundl.h; libc/src/math/log10f.h; libc/src/math/log1pf.h; libc/src/math/log2f.h; libc/src/math/logb.h; libc/src/math/logbf.h; libc/src/math/logbl.h; libc/src/math/logf.h; libc/src/math/lrint.h; libc/src/math/lrintf.h; libc/src/math/lrintl.h; libc/src/math/lround.h; libc/src/math/lroundf.h; libc/src/math/lroundl.h; libc/src/math/modf.h; libc/src/math/modff.h; libc/src/math/modfl.h; libc/src/math/nearbyint.h; libc/src/math/nearbyintf.h; libc/src/math/nearbyintl.h; libc/src/math/nextafter.h; libc/src/math/nextafterf.h; libc/src/math/nextafterl.h; libc/src/math/remainder.h; libc/src/math/remainderf.h; libc/src/math/remainderl.h; libc/src/math/remquo.h; libc/src/math/remquof.h; libc/src/math/remquol.h; libc/src/math/rint.h; libc/src/math/rintf.h; libc/src/math/rintl.h; libc/src/math/round.h; libc/src/math/roundf.h; libc/src/math/roundl.h; libc/src/math/sin.h; libc/src/math/sincosf.h; libc/src/math/sinf.h; libc/src/math/sqrt.h; libc/src/math/sqrtf.h; libc/src/math/sqrtl.h; libc/src/math/tan.h; libc/src/math/trunc.h; libc/src/math/truncf.h; libc/src/math/truncl.h; libc/src/math/aarch64/ceil.cpp; libc/src/math/aarch64/ceilf.cpp; libc/src/math/aarc,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:135811,log,logf,135811,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['log'],['logf']
Testability,xray/tests/unit/segmented_array_test.cpp; compiler-rt/lib/xray/tests/unit/test_helpers.h; compiler-rt/lib/xray/tests/unit/xray_unit_test_main.cpp; compiler-rt/tools/gwp_asan/options_parser_fuzzer.cpp; compiler-rt/tools/gwp_asan/stack_trace_compressor_fuzzer.cpp; cross-project-tests/debuginfo-tests/clang_llvm_roundtrip/simplified_template_names_noncanonical_type_units.cpp; cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source/test.cpp; cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary/test.cpp; cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source/test.cpp; cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps/hit_count.cpp; cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limit_steps/limit_steps_line_mismatch.cpp; cross-project-tests/debuginfo-tests/dexter-tests/global-constant.cpp; cross-project-tests/debuginfo-tests/dexter-tests/nrvo.cpp; cross-project-tests/debuginfo-tests/dexter-tests/realigned-frame.cpp; cross-project-tests/debuginfo-tests/llvm-prettyprinters/gdb/llvm-support.cpp; flang/examples/external-hello.cpp; flang/examples/FlangOmpReport/FlangOmpReport.cpp; flang/examples/FlangOmpReport/FlangOmpReportVisitor.cpp; flang/examples/FlangOmpReport/FlangOmpReportVisitor.h; flang/examples/PrintFlangFunctionNames/PrintFlangFunctionNames.cpp; flang/include/flang/ISO_Fortran_binding.h; flang/include/flang/Common/bit-population-count.h; flang/include/flang/Common/constexpr-bitset.h; flang/include/flang/Common/default-kinds.h; flang/include/flang/Common/enum-set.h; flang/include/flang/Common/fast-int-set.h; flang/include/flang/Common/format.h; flang/include/flang/Common/Fortran-features.h; flang/include/flang/Common/Fortran.h; flang/include/flang/Common/idioms.h; flang/include/flang/Common/indirection.h; flang/include/flang/,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:107888,test,tests,107888,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,3,['test'],['tests']
Testability,xray_buffer_queue.h; compiler-rt/lib/xray/xray_fdr_controller.h; compiler-rt/lib/xray/xray_fdr_flags.cpp; compiler-rt/lib/xray/xray_fdr_flags.h; compiler-rt/lib/xray/xray_fdr_logging.h; compiler-rt/lib/xray/xray_fdr_log_records.h; compiler-rt/lib/xray/xray_flags.cpp; compiler-rt/lib/xray/xray_flags.h; compiler-rt/lib/xray/xray_interface_internal.h; compiler-rt/lib/xray/xray_log_interface.cpp; compiler-rt/lib/xray/xray_mips.cpp; compiler-rt/lib/xray/xray_mips64.cpp; compiler-rt/lib/xray/xray_powerpc64.cpp; compiler-rt/lib/xray/xray_profile_collector.cpp; compiler-rt/lib/xray/xray_profile_collector.h; compiler-rt/lib/xray/xray_profiling.cpp; compiler-rt/lib/xray/xray_profiling_flags.cpp; compiler-rt/lib/xray/xray_profiling_flags.h; compiler-rt/lib/xray/xray_recursion_guard.h; compiler-rt/lib/xray/xray_trampoline_powerpc64.cpp; compiler-rt/lib/xray/xray_tsc.h; compiler-rt/lib/xray/tests/unit/allocator_test.cpp; compiler-rt/lib/xray/tests/unit/buffer_queue_test.cpp; compiler-rt/lib/xray/tests/unit/fdr_log_writer_test.cpp; compiler-rt/lib/xray/tests/unit/function_call_trie_test.cpp; compiler-rt/lib/xray/tests/unit/profile_collector_test.cpp; compiler-rt/lib/xray/tests/unit/segmented_array_test.cpp; compiler-rt/lib/xray/tests/unit/test_helpers.h; compiler-rt/lib/xray/tests/unit/xray_unit_test_main.cpp; compiler-rt/tools/gwp_asan/options_parser_fuzzer.cpp; compiler-rt/tools/gwp_asan/stack_trace_compressor_fuzzer.cpp; cross-project-tests/debuginfo-tests/clang_llvm_roundtrip/simplified_template_names_noncanonical_type_units.cpp; cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source/test.cpp; cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary/test.cpp; cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source/test.cpp; cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/limi,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:106731,test,tests,106731,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['test'],['tests']
Testability,"xt, we register the analysis passes used by the transform passes. .. code-block:: c++. // Register analysis passes used in these transform passes.; PassBuilder PB;; PB.registerModuleAnalyses(*TheMAM);; PB.registerFunctionAnalyses(*TheFAM);; PB.crossRegisterProxies(*TheLAM, *TheFAM, *TheCGAM, *TheMAM);; }. Once the PassManager is set up, we need to make use of it. We do this by; running it after our newly created function is constructed (in; ``FunctionAST::codegen()``), but before it is returned to the client:. .. code-block:: c++. if (Value *RetVal = Body->codegen()) {; // Finish off the function.; Builder.CreateRet(RetVal);. // Validate the generated code, checking for consistency.; verifyFunction(*TheFunction);. // Optimize the function.; TheFPM->run(*TheFunction, *TheFAM);. return TheFunction;; }. As you can see, this is pretty straightforward. The; ``FunctionPassManager`` optimizes and updates the LLVM Function\* in; place, improving (hopefully) its body. With this in place, we can try; our test above again:. ::. ready> def test(x) (1+2+x)*(x+(1+2));; ready> Read function definition:; define double @test(double %x) {; entry:; %addtmp = fadd double %x, 3.000000e+00; %multmp = fmul double %addtmp, %addtmp; ret double %multmp; }. As expected, we now get our nicely optimized code, saving a floating; point add instruction from every execution of this function. LLVM provides a wide variety of optimizations that can be used in; certain circumstances. Some `documentation about the various; passes <../../Passes.html>`_ is available, but it isn't very complete.; Another good source of ideas can come from looking at the passes that; ``Clang`` runs to get started. The ""``opt``"" tool allows you to; experiment with passes from the command line, so you can see if they do; anything. Now that we have reasonable code coming out of our front-end, let's talk; about executing it!. Adding a JIT Compiler; =====================. Code that is available in LLVM IR can have a wide variety ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:8670,test,test,8670,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['test'],['test']
Testability,"xtended to also include C++ and C++11 headers using a *requires-declaration*:. .. parsed-literal::. module std {; // C standard library... module vector {; requires cplusplus; header ""vector""; }. module type_traits {; requires cplusplus11; header ""type_traits""; }; }. Header declaration; ~~~~~~~~~~~~~~~~~~; A header declaration specifies that a particular header is associated with the enclosing module. .. parsed-literal::. *header-declaration*:; ``private``:sub:`opt` ``textual``:sub:`opt` ``header`` *string-literal* *header-attrs*:sub:`opt`; ``umbrella`` ``header`` *string-literal* *header-attrs*:sub:`opt`; ``exclude`` ``header`` *string-literal* *header-attrs*:sub:`opt`. *header-attrs*:; '{' *header-attr** '}'. *header-attr*:; ``size`` *integer-literal*; ``mtime`` *integer-literal*. A header declaration that does not contain ``exclude`` nor ``textual`` specifies a header that contributes to the enclosing module. Specifically, when the module is built, the named header will be parsed and its declarations will be (logically) placed into the enclosing submodule. A header with the ``umbrella`` specifier is called an umbrella header. An umbrella header includes all of the headers within its directory (and any subdirectories), and is typically used (in the ``#include`` world) to easily access the full API provided by a particular library. With modules, an umbrella header is a convenient shortcut that eliminates the need to write out ``header`` declarations for every library header. A given directory can only contain a single umbrella header. .. note::; Any headers not included by the umbrella header should have; explicit ``header`` declarations. Use the; ``-Wincomplete-umbrella`` warning option to ask Clang to complain; about headers not covered by the umbrella header or the module map. A header with the ``private`` specifier may not be included from outside the module itself. A header with the ``textual`` specifier will not be compiled when the module is; built, and will",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:36213,log,logically,36213,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['log'],['logically']
Testability,xtra/clangd/unittests/tweaks/ExtractFunctionTests.cpp; clang-tools-extra/clangd/unittests/tweaks/ExtractVariableTests.cpp; clang-tools-extra/clangd/unittests/tweaks/ObjCLocalizeStringLiteralTests.cpp; clang-tools-extra/clangd/unittests/tweaks/PopulateSwitchTests.cpp; clang-tools-extra/clangd/unittests/tweaks/RawStringLiteralTests.cpp; clang-tools-extra/clangd/unittests/tweaks/RemoveUsingNamespaceTests.cpp; clang-tools-extra/clangd/unittests/tweaks/ShowSelectionTreeTests.cpp; clang-tools-extra/clangd/unittests/tweaks/SwapIfBranchesTests.cpp; clang-tools-extra/clangd/unittests/tweaks/TweakTesting.cpp; clang-tools-extra/clangd/unittests/tweaks/TweakTesting.h; clang-tools-extra/clangd/unittests/tweaks/TweakTests.cpp; clang-tools-extra/clangd/unittests/xpc/ConversionTests.cpp; clang-tools-extra/clangd/xpc/Conversion.cpp; clang-tools-extra/clangd/xpc/Conversion.h; clang-tools-extra/clangd/xpc/XPCTransport.cpp; clang-tools-extra/clangd/xpc/framework/ClangdXPC.cpp; clang-tools-extra/clangd/xpc/test-client/ClangdXPCTestClient.cpp; clang-tools-extra/modularize/Modularize.h; clang-tools-extra/pp-trace/PPTrace.cpp; clang-tools-extra/tool-template/ToolTemplate.cpp; clang-tools-extra/unittests/clang-apply-replacements/ApplyReplacementsTest.cpp; clang-tools-extra/unittests/clang-doc/BitcodeTest.cpp; clang-tools-extra/unittests/clang-doc/ClangDocTest.cpp; clang-tools-extra/unittests/clang-doc/ClangDocTest.h; clang-tools-extra/unittests/clang-doc/GeneratorTest.cpp; clang-tools-extra/unittests/clang-doc/HTMLGeneratorTest.cpp; clang-tools-extra/unittests/clang-doc/MDGeneratorTest.cpp; clang-tools-extra/unittests/clang-doc/MergeTest.cpp; clang-tools-extra/unittests/clang-doc/SerializeTest.cpp; clang-tools-extra/unittests/clang-doc/YAMLGeneratorTest.cpp; clang-tools-extra/unittests/clang-tidy/AddConstTest.cpp; clang-tools-extra/unittests/clang-tidy/ClangTidyDiagnosticConsumerTest.cpp; clang-tools-extra/unittests/clang-tidy/ClangTidyTest.h; clang-tools-extra/unittests/clang-tidy/DeclRefE,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:88063,test,test-client,88063,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['test'],['test-client']
Testability,"xtract) # now empty (or invalid); 0; >>> extract = boost.any_cast[std.vector[int]](val); >>> list(extract); [0, 1, 2, 3, 4, 5, 6, ..., 97, 98, 99]; >>>. Of course, there is no reason to use Boost from Python (in fact, this example; calls out for :doc:`pythonizations <pythonizations>`), but it shows that; cppyy seamlessly supports many advanced C++ features. cppyy is available for both `CPython`_ (v2 and v3) and `PyPy`_, reaching; C++-like performance with the latter.; It makes judicious use of precompiled headers, dynamic loading, and lazy; instantiation, to support C++ programs consisting of millions of lines of; code and many thousands of classes.; cppyy minimizes dependencies to allow its use in distributed, heterogeneous,; development environments. .. _Cling: https://github.com/vgvassilev/cling; .. _tutorial: https://github.com/wlav/cppyy/blob/master/doc/tutorial/CppyyTutorial.ipynb; .. _`PyHPC'16 paper`: http://wlav.web.cern.ch/wlav/Cppyy_LavrijsenDutta_PyHPC16.pdf; .. _`CAAS presentation`: https://www.youtube.com/watch?v=stMD7VDWlVU; .. _`Jason Turner's`: https://www.youtube.com/watch?v=TL83P77vZ1k; .. _`Boost`: http://www.boost.org/; .. _`CPython`: http://python.org; .. _`PyPy`: http://pypy.org. .. only: not latex. Contents:. .. toctree::; :maxdepth: 1. changelog; license. .. toctree::; :caption: Getting Started; :maxdepth: 1. installation; starting; examples; bugs. .. toctree::; :caption: Features; :maxdepth: 1. toplevel; basic_types; strings; classes; functions; type_conversions; stl; exceptions; python; numba; cuda; lowlevel; misc; debugging. .. toctree::; :caption: Redistribution; :maxdepth: 1. pythonizations; utilities; cmake_interface. .. toctree::; :caption: Developers; :maxdepth: 1. packages; repositories; testing. .. toctree::; :caption: Background; :maxdepth: 1. history; philosophy. Bugs and feedback; -----------------. Please report bugs or requests for improvement on the `issue tracker`_. .. _`issue tracker`: https://github.com/wlav/cppyy/issues; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/index.rst:5639,test,testing,5639,bindings/pyroot/cppyy/cppyy/doc/source/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/index.rst,1,['test'],['testing']
Testability,"xx LIBRARIES ROOTNTuple CustomStruct); ROOT_ADD_GTEST(ntuple_bulk ntuple_bulk.cxx LIBRARIES ROOTNTuple CustomStruct); ROOT_ADD_GTEST(ntuple_cast ntuple_cast.cxx LIBRARIES ROOTNTuple); ROOT_ADD_GTEST(ntuple_checksum ntuple_checksum.cxx ntuple_test.cxx LIBRARIES ROOTNTuple); ROOT_ADD_GTEST(ntuple_cluster ntuple_cluster.cxx LIBRARIES ROOTNTuple); ROOT_ADD_GTEST(ntuple_compat ntuple_compat.cxx RXTuple.cxx LIBRARIES ROOTNTuple xxHash::xxHash); ROOT_GENERATE_DICTIONARY(RXTupleDict ${CMAKE_CURRENT_SOURCE_DIR}/RXTuple.hxx; MODULE ntuple_compat; LINKDEF RXTupleLinkDef.h; DEPENDENCIES RIO); ROOT_ADD_GTEST(ntuple_descriptor ntuple_descriptor.cxx LIBRARIES ROOTNTuple CustomStruct); ROOT_GENERATE_DICTIONARY(RNTupleDescriptorDict ${CMAKE_CURRENT_SOURCE_DIR}/RNTupleDescriptorDict.hxx; MODULE ntuple_descriptor; LINKDEF RNTupleDescriptorLinkDef.h; OPTIONS -inlineInputHeader; DEPENDENCIES RIO CustomStruct); ROOT_ADD_GTEST(ntuple_endian ntuple_endian.cxx LIBRARIES ROOTNTuple); if(NOT MSVC); # The unit test relies on fork(), which is not available on Windows.; ROOT_ADD_GTEST(ntuple_evolution ntuple_evolution.cxx LIBRARIES ROOTNTuple); endif(); ROOT_ADD_GTEST(ntuple_friends ntuple_friends.cxx LIBRARIES ROOTNTuple CustomStruct); ROOT_ADD_GTEST(ntuple_index ntuple_index.cxx LIBRARIES ROOTNTuple); ROOT_ADD_GTEST(ntuple_merger ntuple_merger.cxx LIBRARIES ROOTNTuple CustomStruct ZLIB::ZLIB); ROOT_ADD_GTEST(ntuple_metrics ntuple_metrics.cxx LIBRARIES ROOTNTuple CustomStruct); ROOT_ADD_GTEST(ntuple_model ntuple_model.cxx LIBRARIES ROOTNTuple CustomStruct); ROOT_ADD_GTEST(ntuple_multi_column ntuple_multi_column.cxx LIBRARIES ROOTNTuple); ROOT_ADD_GTEST(ntuple_packing ntuple_packing.cxx LIBRARIES ROOTNTuple CustomStruct); ROOT_ADD_GTEST(ntuple_pages ntuple_pages.cxx LIBRARIES ROOTNTuple CustomStruct); ROOT_ADD_GTEST(ntuple_print ntuple_print.cxx LIBRARIES ROOTNTuple CustomStruct); ROOT_ADD_GTEST(ntuple_processor ntuple_processor.cxx LIBRARIES ROOTNTuple); ROOT_ADD_GTEST(ntuple_project ntuple_proj",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CMakeLists.txt:1755,test,test,1755,tree/ntuple/v7/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CMakeLists.txt,1,['test'],['test']
Testability,"xx; FAILREGEX ""FAILED|Error in"" DEPENDS test-stressspectrum LABELS longtest); endif(). #--stressVector------------------------------------------------------------------------------------; ROOT_EXECUTABLE(stressVector stressVector.cxx LIBRARIES Physics GenVector); ROOT_ADD_TEST(test-stressvector COMMAND stressVector FAILREGEX ""FAILED|Error in""); ROOT_ADD_TEST(test-stressvector-interpreted COMMAND ${ROOT_root_CMD} -b -q -l ${CMAKE_CURRENT_SOURCE_DIR}/stressVector.cxx; FAILREGEX ""FAILED|Error in"" DEPENDS test-stressvector). #--stressMathMore----------------------------------------------------------------------------------; if(ROOT_mathmore_FOUND); ROOT_EXECUTABLE(stressMathMore stressMathMore.cxx LIBRARIES MathMore Smatrix); ROOT_ADD_TEST(test-stressmathmore COMMAND stressMathMore FAILREGEX ""FAILED|Error in"" LABELS longtest); ROOT_ADD_TEST(test-stressmathmore-interpreted COMMAND ${ROOT_root_CMD} -b -q -l ${CMAKE_CURRENT_SOURCE_DIR}/stressMathMore.cxx; FAILREGEX ""FAILED|Error in"" DEPENDS test-stressmathmore TIMEOUT 1800); endif(). #--stressMathCore----------------------------------------------------------------------------------; ROOT_STANDARD_LIBRARY_PACKAGE(TrackMathCoreDict; NO_SOURCES; NO_INSTALL_HEADERS; HEADERS ${CMAKE_CURRENT_SOURCE_DIR}/TrackMathCore.h; LINKDEF TrackMathCoreLinkDef.h; DEPENDENCIES Core MathCore RIO GenVector Smatrix); if(MSVC AND NOT CMAKE_GENERATOR MATCHES Ninja); add_custom_command(TARGET TrackMathCoreDict POST_BUILD; COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_BINARY_DIR}/$<CONFIG>/libTrackMathCoreDict.dll; ${CMAKE_CURRENT_BINARY_DIR}/libTrackMathCoreDict.dll); endif(); ROOT_EXECUTABLE(stressMathCore stressMathCore.cxx LIBRARIES MathCore Hist RIO Tree GenVector); ROOT_ADD_TEST(test-stressmathcore COMMAND stressMathCore FAILREGEX ""FAILED|Error in"" LABELS longtest); ROOT_ADD_TEST(test-stressmathcore-interpreted COMMAND ${ROOT_root_CMD} -b -q -l ${CMAKE_CURRENT_SOURCE_DIR}/stressMathCore.cxx; FAILREGEX ""FAILED|Error in"" DEPENDS test-stressm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/CMakeLists.txt:11511,test,test-stressmathmore,11511,test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/CMakeLists.txt,1,['test'],['test-stressmathmore']
Testability,"y (or make sure ``llvm-symbolizer`` is in your; ``$PATH``):. .. code-block:: console. % ASAN_SYMBOLIZER_PATH=/usr/local/bin/llvm-symbolizer ./a.out; ==9442== ERROR: AddressSanitizer heap-use-after-free on address 0x7f7ddab8c084 at pc 0x403c8c bp 0x7fff87fb82d0 sp 0x7fff87fb82c8; READ of size 4 at 0x7f7ddab8c084 thread T0; #0 0x403c8c in main example_UseAfterFree.cc:4; #1 0x7f7ddabcac4d in __libc_start_main ??:0; 0x7f7ddab8c084 is located 4 bytes inside of 400-byte region [0x7f7ddab8c080,0x7f7ddab8c210); freed by thread T0 here:; #0 0x404704 in operator delete[](void*) ??:0; #1 0x403c53 in main example_UseAfterFree.cc:4; #2 0x7f7ddabcac4d in __libc_start_main ??:0; previously allocated by thread T0 here:; #0 0x404544 in operator new[](unsigned long) ??:0; #1 0x403c43 in main example_UseAfterFree.cc:2; #2 0x7f7ddabcac4d in __libc_start_main ??:0; ==9442== ABORTING. If that does not work for you (e.g. your process is sandboxed), you can use a; separate script to symbolize the result offline (online symbolization can be; force disabled by setting ``ASAN_OPTIONS=symbolize=0``):. .. code-block:: console. % ASAN_OPTIONS=symbolize=0 ./a.out 2> log; % projects/compiler-rt/lib/asan/scripts/asan_symbolize.py / < log | c++filt; ==9442== ERROR: AddressSanitizer heap-use-after-free on address 0x7f7ddab8c084 at pc 0x403c8c bp 0x7fff87fb82d0 sp 0x7fff87fb82c8; READ of size 4 at 0x7f7ddab8c084 thread T0; #0 0x403c8c in main example_UseAfterFree.cc:4; #1 0x7f7ddabcac4d in __libc_start_main ??:0; ... Note that on macOS you may need to run ``dsymutil`` on your binary to have the; file\:line info in the AddressSanitizer reports. Additional Checks; =================. Initialization order checking; -----------------------------. AddressSanitizer can optionally detect dynamic initialization order problems,; when initialization of globals defined in one translation unit uses; globals defined in another translation unit. To enable this check at runtime,; you should set environment variable; `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:4526,sandbox,sandboxed,4526,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['sandbox'],['sandboxed']
Testability,"y **`TGMenuTitle`**; class. The menu bar is the highest-level of the menu system and it is a; starting point for all interactions. Also, it is always visible and; allows using the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar automatically; resizes itself so that it has the same width as its parent (typically; **`TGMainFrame`**). The menu bar is as a container for its menus - objects of the type; **`TGPopupMenu.`** Popup menus can appear in a menu bar. They can be a; sub-menu of another popup menu (cascading menus) or can be standalone; (as a context menu). They are made of one or more menu items choices.; When displayed, the menu items are arranged in a vertical list. Usually; they correspond to actions (e.g. `Open`**)**. These items can be labeled; with text, graphics or a combination of both. Each of them should have a; character defined as its unique key for access. Grouped logically by; their functionality, they are separated visually by menu separators in; groups. For example, The `File` menu is a common menu title for tasks; that apply to a file, as **`Open`**,**`Save`**,**`Close`**,**`Print`**... ``` {.cpp}; // a popup menu; fMenuFile = new TGPopupMenu(gClient->GetRoot());. // adding menu entries; fMenuFile->AddEntry(""&Open..."",M_FILE_OPEN);; fMenuFile->AddEntry(""&Save"",M_FILE_SAVE);; fMenuFile->AddEntry(""S&ave as..."",M_FILE_SAVEAS);; fMenuFile->AddEntry(""&Close"", -1);. // adding separator; fMenuFile->AddSeparator();. // next group of menu entries; fMenuFile->AddEntry(""&Print"",M_FILE_PRINT);; fMenuFile->AddEntry(""P&rint setup..."",M_FILE_PRINTSETUP);; . . .; fMenuFile->AddSeparator();; fMenuFile->AddEntry(""E&xit"",M_FILE_EXIT);; ```. First we create the File menu by creating an object of; class**` TGPopupMenu`** and adding menu entries with `AddEntry` method.; Its first parameter is a hot string, the second - a menu ID. The; ampersand character (&) denotes shortcut for each menu entry; you can;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:69836,log,logically,69836,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['log'],['logically']
Testability,"y CMake use the; 32-bit toolset. If you are developing on a 64-bit version of Windows and; want to use the 64-bit toolset, pass the ``-Thost=x64`` flag when; generating the Visual Studio solution. This requires CMake 3.8.0 or later. 13. Start Visual Studio and select configuration:. In the directory you created the project files will have an ``llvm.sln``; file, just double-click on that to open Visual Studio. The default Visual; Studio configuration is **Debug** which is slow and generates a huge amount; of debug information on disk. For now, we recommend selecting **Release**; configuration for the LLVM project which will build the fastest or; **RelWithDebInfo** which is also several time larger than Release.; Another technique is to build all of LLVM in Release mode and change; compiler flags, disabling optimization and enabling debug information, only; for specific libraries or source files you actually need to debug. 14. Test LLVM in Visual Studio:. You can run LLVM tests by merely building the project ""check-all"". The test; results will be shown in the VS output window. Once the build succeeds, you; have verified a working LLVM development environment!. You should not see any unexpected failures, but will see many unsupported; tests and expected failures:. ::. 114>Testing Time: 1124.66s; 114> Skipped : 39; 114> Unsupported : 21649; 114> Passed : 51615; 114> Expectedly Failed: 93; ========== Build: 114 succeeded, 0 failed, 321 up-to-date, 0 skipped ==========``. Alternatives to manual installation; ===================================; Instead of the steps above, to simplify the installation procedure you can use; `Chocolatey <https://chocolatey.org/>`_ as package manager.; After the `installation <https://chocolatey.org/install>`_ of Chocolatey,; run these commands in an admin shell to install the required tools:. .. code-block:: bat. choco install -y git cmake python3; pip3 install psutil. There is also a Windows; `Dockerfile <https://github.com/llvm/llvm-zorg/b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:7477,test,tests,7477,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,1,['test'],['tests']
Testability,"y about 5-10%. At the moment, rpmalloc,; snmalloc and mimalloc are supported. Use the path to `git clone` to select; the respective allocator, for example:. .. code-block:: console. $ D:\git> git clone https://github.com/mjansson/rpmalloc; $ D:\llvm-project> cmake ... -DLLVM_INTEGRATED_CRT_ALLOC=D:\git\rpmalloc. This flag needs to be used along with the static CRT, ie. if building the; Release target, add -DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreaded. **LLVM_INSTALL_DOXYGEN_HTML_DIR**:STRING; The path to install Doxygen-generated HTML documentation to. This path can; either be absolute or relative to the *CMAKE_INSTALL_PREFIX*. Defaults to; ``${CMAKE_INSTALL_DOCDIR}/llvm/doxygen-html``. **LLVM_LINK_LLVM_DYLIB**:BOOL; If enabled, tools will be linked with the libLLVM shared library. Defaults; to OFF. Setting LLVM_LINK_LLVM_DYLIB to ON also sets LLVM_BUILD_LLVM_DYLIB; to ON.; This option is not available on Windows. **LLVM_LIT_ARGS**:STRING; Arguments given to lit. ``make check`` and ``make clang-test`` are affected.; By default, ``'-sv --no-progress-bar'`` on Visual C++ and Xcode, ``'-sv'`` on; others. **LLVM_LIT_TOOLS_DIR**:PATH; The path to GnuWin32 tools for tests. Valid on Windows host. Defaults to; the empty string, in which case lit will look for tools needed for tests; (e.g. ``grep``, ``sort``, etc.) in your %PATH%. If GnuWin32 is not in your; %PATH%, then you can set this variable to the GnuWin32 directory so that; lit can find tools needed for tests in that directory. **LLVM_NATIVE_TOOL_DIR**:STRING; Full path to a directory containing executables for the build host; (containing binaries such as ``llvm-tblgen`` and ``clang-tblgen``). This is; intended for cross-compiling: if the user sets this variable and the; directory contains executables with the expected names, no separate; native versions of those executables will be built. **LLVM_NO_INSTALL_NAME_DIR_FOR_BUILD_TREE**:BOOL; Defaults to ``OFF``. If set to ``ON``, CMake's default logic for library IDs; on Dar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:30829,test,test,30829,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['test'],['test']
Testability,"y another function. As; the reader may notice, this way seems to be quite expensive. Of course we could; introduce hashing and other helpers, but it is still just an optimization, and; thus the level of O(N*N) complexity. Can we reach another level? Could we introduce logarithmical search, or random; access lookup? The answer is: ""yes"". Random-access; """"""""""""""""""""""""""; How it could this be done? Just convert each function to a number, and gather; all of them in a special hash-table. Functions with equal hashes are equal.; Good hashing means, that every function part must be taken into account. That; means we have to convert every function part into some number, and then add it; into the hash. The lookup-up time would be small, but such an approach adds some; delay due to the hashing routine. Logarithmical search; """"""""""""""""""""""""""""""""""""""""; We could introduce total ordering among the functions set, once ordered we; could then implement a logarithmical search. Lookup time still depends on N,; but adds a little of delay (*log(N)*). Present state; """"""""""""""""""""""""""; Both of the approaches (random-access and logarithmical) have been implemented; and tested and both give a very good improvement. What was most; surprising is that logarithmical search was faster; sometimes by up to 15%. The; hashing method needs some extra CPU time, which is the main reason why it works; slower; in most cases, total ""hashing"" time is greater than total; ""logarithmical-search"" time. So, preference has been granted to the ""logarithmical search"". Though in the case of need, *logarithmical-search* (read ""total-ordering"") could; be used as a milestone on our way to the *random-access* implementation. Every comparison is based either on the numbers or on the flags comparison. In; the *random-access* approach, we could use the same comparison algorithm.; During comparison, we exit once we find the difference, but here we might have; to scan the whole function body every time (note, it could be slower). Like i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:6323,log,log,6323,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['log'],['log']
Testability,"y buffer passed in RDI (live in). .. code-block:: none. # LLVM-EXEGESIS-LIVEIN RDI; # LLVM-EXEGESIS-DEFREG XMM1 42; vmulps	(%rdi), %xmm1, %xmm2; vhaddps	%xmm2, %xmm2, %xmm3; addq $0x10, %rdi. Example 3: benchmarking with memory annotations; -----------------------------------------------. Some snippets require memory setup in specific places to execute without; crashing. Setting up memory can be accomplished with the `LLVM-EXEGESIS-MEM-DEF`; and `LLVM-EXEGESIS-MEM-MAP` annotations. To execute the following snippet:. .. code-block:: none. movq $8192, %rax; movq (%rax), %rdi. We need to have at least eight bytes of memory allocated starting `0x2000`.; We can create the necessary execution environment with the following; annotations added to the snippet:. .. code-block:: none. # LLVM-EXEGESIS-MEM-DEF test1 4096 7fffffff; # LLVM-EXEGESIS-MEM-MAP test1 8192. movq $8192, %rax; movq (%rax), %rdi. EXAMPLE 4: analysis; -------------------. Assuming you have a set of benchmarked instructions (either latency or uops) as; YAML in file `/tmp/benchmarks.yaml`, you can analyze the results using the; following command:. .. code-block:: bash. $ llvm-exegesis --mode=analysis \; --benchmarks-file=/tmp/benchmarks.yaml \; --analysis-clusters-output-file=/tmp/clusters.csv \; --analysis-inconsistencies-output-file=/tmp/inconsistencies.html. This will group the instructions into clusters with the same performance; characteristics. The clusters will be written out to `/tmp/clusters.csv` in the; following format:. .. code-block:: none. cluster_id,opcode_name,config,sched_class; ...; 2,ADD32ri8_DB,,WriteALU,1.00; 2,ADD32ri_DB,,WriteALU,1.01; 2,ADD32rr,,WriteALU,1.01; 2,ADD32rr_DB,,WriteALU,1.00; 2,ADD32rr_REV,,WriteALU,1.00; 2,ADD64i32,,WriteALU,1.01; 2,ADD64ri32,,WriteALU,1.01; 2,MOVSX64rr32,,BSWAP32r_BSWAP64r_MOVSX64rr32,1.00; 2,VPADDQYrr,,VPADDBYrr_VPADDDYrr_VPADDQYrr_VPADDWYrr_VPSUBBYrr_VPSUBDYrr_VPSUBQYrr_VPSUBWYrr,1.02; 2,VPSUBQYrr,,VPADDBYrr_VPADDDYrr_VPADDQYrr_VPADDWYrr_VPSUBBYrr_VPSU",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:7547,benchmark,benchmarked,7547,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,2,['benchmark'],"['benchmarked', 'benchmarks']"
Testability,"y completed. Refresh and improve Clang's documentation: Clang is inconsistent; with documenting implementation-defined behaviors. We have significant; documentation in the ; Language Extensions page, but the information is incomplete and the page is; difficult to navigate. We would appreciate help with:. improving the way this information is presented to users,; table generating; documentation where possible, such as for implementation limits or other; target-specific information,; adding documentation for currently; ; undocumented attributes,; documenting ; diagnostic group flags (adding code examples of what is diagnosed, or; other relevant information), or; documenting ; command line options, or; help with completing other missing documentation. These projects are independent of each other.; Complete the investigation into Clang's C conformance: Clang's; C status page contain a number of entries marked as; Unknown. Completing the investigation involves adding; test; coverage for the various standards papers and updating the documentation; accordingly. Improve Clang's C and C++ standard conformance test coverage:; Clang's test suite is structured such that most tests are written to provide; coverage for what part of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model suitable for open source projects,; so we would appreciate help in improving the existing coverage we have both in; terms of layout of the tests as well as in coverage of the various standard; modes.; Complete the investigation into Clang's C and C++ Defect Report; conformance: Separate from (but related to) general con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:1296,test,test,1296,interpreter/llvm-project/clang/www/OpenProjects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html,1,['test'],['test']
Testability,"y default."" OFF); add_subdirectory(examples). if(APPLE); # this line is needed as a cleanup to ensure that any CMakeCaches with the old; # default value get updated to the new default.; if(CLANG_ORDER_FILE STREQUAL """"); unset(CLANG_ORDER_FILE CACHE); unset(CLANG_ORDER_FILE); endif(). set(CLANG_ORDER_FILE ${CMAKE_CURRENT_BINARY_DIR}/clang.order CACHE FILEPATH; ""Order file to use when compiling clang in order to improve startup time (Darwin Only - requires ld64).""). if(NOT EXISTS ${CLANG_ORDER_FILE}); string(FIND ""${CLANG_ORDER_FILE}"" ""${CMAKE_CURRENT_BINARY_DIR}"" PATH_START); if(PATH_START EQUAL 0); file(WRITE ${CLANG_ORDER_FILE} ""\n""); else(); message(FATAL_ERROR ""Specified order file '${CLANG_ORDER_FILE}' does not exist.""); endif(); endif(); endif(). if( CLANG_INCLUDE_TESTS ); add_subdirectory(unittests); list(APPEND CLANG_TEST_DEPS ClangUnitTests); list(APPEND CLANG_TEST_PARAMS; clang_unit_site_config=${CMAKE_CURRENT_BINARY_DIR}/test/Unit/lit.site.cfg; ); add_subdirectory(test); add_subdirectory(bindings/python/tests). if(CLANG_BUILT_STANDALONE); umbrella_lit_testsuite_end(check-all); endif(); add_subdirectory(utils/perf-training); endif(). option(CLANG_INCLUDE_DOCS ""Generate build targets for the Clang docs.""; ${LLVM_INCLUDE_DOCS}); if( CLANG_INCLUDE_DOCS ); add_subdirectory(docs); endif(). # Custom target to install all clang libraries.; add_custom_target(clang-libraries); set_target_properties(clang-libraries PROPERTIES FOLDER ""Misc""). if(NOT LLVM_ENABLE_IDE); add_llvm_install_targets(install-clang-libraries; DEPENDS clang-libraries; COMPONENT clang-libraries); endif(). get_property(CLANG_LIBS GLOBAL PROPERTY CLANG_LIBS); if(CLANG_LIBS); list(REMOVE_DUPLICATES CLANG_LIBS); foreach(lib ${CLANG_LIBS}); add_dependencies(clang-libraries ${lib}); if(NOT LLVM_ENABLE_IDE); add_dependencies(install-clang-libraries install-${lib}); add_dependencies(install-clang-libraries-stripped install-${lib}-stripped); endif(); endforeach(); endif(). add_subdirectory(cmake/modules).",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:18945,test,test,18945,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,2,['test'],"['test', 'tests']"
Testability,"y directives like the following to redefine the parameter substitutions as; desired before each use of ``%{check}`` in a ``RUN:`` line:. .. code-block:: llvm. ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0 -fopenmp-simd; ; REDEFINE: %{fcflags} = -check-prefix=SIMD; ; RUN: %{check}. ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu -fopenmp-simd; ; REDEFINE: %{fcflags} = -check-prefix=SIMD; ; RUN: %{check}. ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0; ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD; ; RUN: %{check}. ; REDEFINE: %{cflags} = -triple x86_64-unknown-linux-gnu; ; REDEFINE: %{fcflags} = -check-prefix=NO-SIMD; ; RUN: %{check}. Besides providing initial values, the initial ``DEFINE:`` directives for the; parameter substitutions in the above example serve a second purpose: they; establish the substitution order so that both ``%{check}`` and its parameters; expand as desired. There's a simple way to remember the required definition; order in a test file: define a substitution before any substitution that might; refer to it. In general, substitution expansion behaves as follows:. - Upon arriving at each ``RUN:`` line, lit expands all substitutions in that; ``RUN:`` line using their current values from the substitution list. No; substitution expansion is performed immediately at ``DEFINE:`` and; ``REDEFINE:`` directives except ``%(line)``, ``%(line+<number>)``, and; ``%(line-<number>)``.; - When expanding substitutions in a ``RUN:`` line, lit makes only one pass; through the substitution list by default. In this case, a substitution must; have been inserted earlier in the substitution list than any substitution; appearing in its value in order for the latter to expand. (For greater; flexibility, you can enable multiple passes through the substitution list by; setting `recursiveExpansionLimit`_ in a lit configuration file.); - While lit configuration files can insert anywhere in the substitution list,; the insertion behavior of the `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:30892,test,test,30892,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['test']
Testability,"y empty hist bin if fSumw2 not zero. ## Changes in 7.7.4; 1. Fix - TGraph Y range selection, do not cross 0; 2. Fix - correctly handle `#font[id]` in latex; 3. Fix - store canvas with embed geometry drawing; 4. Fix - upgrade rollup and import.meta polyfill. ## Changes in 7.7.3; 1. Fix - correctly handle in I/O empty std::map; 2. Fix - reading of small (<1KB) ROOT files; 3. Fix - race condition in zstd initialization #318; 4. Fix - deployment with zstd #317. ## Changes in 7.7.2; 1. Fix - hide empty title on the canvas; 2. Fix - properly handle zooming in THStack histogram; 3. Fix - always use 0 as minimum in THStack drawings; 4. Fix - always show all ticks for labeled axis; 5. Fix - draw TProfile2D bins content as text, not entries; 6. Fix - interactive zooming on log color palette; 7. Fix - keyboard handling while input dialog active; 8. Fix - legend entry with not configured fill attributes; 9. Fix - prevent that color palette exceed graphical range; 10. Fix - exponential log axis labels with kMoreLogLabels bit set. ## Changes in 7.7.1; 1. Fix - properly select TF1 range after zooming; 2. Fix - TH1 y-range selection; 3. Fix - add 'gl' and svg2pdf-related packages to dependencies in package.json. ## Changes in 7.7.0; 1. Let plot current time, file creation or modification time with `&optdate=[1,2,3]` URL parameters; 2. Let plot file name, full file name or item name with `&optfile=[1,2,3]` URL parameters; 3. Let define date and file name position with `&datex=0.03&datey=0.03` URL parameters; 4. Improve TRatioPlot axis and lines drawing; 5. Use localStorage to preserve custom settings and gStyle; 6. Let configure custom storage prefix with `&storage_prefix=name` URL #290; 7. Let customize URL for ""Show in new tab"" menu command; 8. Support both new and old TRatioPlot drawings; 10. Synchronize X/Y range selection with native ROOT; 11. Proper handle attributes from TH2Poly bins, support ""p"" for markers drawing; 12. Correctly scale size of axis ticks - take into account N",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:3787,log,log,3787,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['log'],['log']
Testability,"y instrumentation of 'safe' variables. SafeStack is going to be the; first user. 'safe' variables can be defined as variables that can not be used out-of-scope; (e.g. use-after-return) or accessed out of bounds. In the future it can be; extended to track other variable properties. E.g. we plan to extend; implementation with a check to make sure that variable is always initialized; before every read to optimize use-of-uninitialized-memory checks. How it works; ============. The analysis is implemented in two stages:. The intra-procedural, or 'local', stage performs a depth-first search inside; functions to collect all uses of each alloca, including loads/stores and uses as; arguments functions. After this stage we know which parts of the alloca are used; by functions itself but we don't know what happens after it is passed as; an argument to another function. The inter-procedural, or 'global', stage, resolves what happens to allocas after; they are passed as function arguments. This stage performs a depth-first search; on function calls inside a single module and propagates allocas usage through; functions calls. When used with ThinLTO, the global stage performs a whole program analysis over; the Module Summary Index. Testing; =======. The analysis is covered with lit tests. We expect that users can tolerate false classification of variables as; 'unsafe' when in-fact it's 'safe'. This may lead to inefficient code. However, we; can't accept false 'safe' classification which may cause sanitizers to miss actual; bugs in instrumented code. To avoid that we want additional validation tool. AddressSanitizer may help with this validation. We can instrument all variables; as usual but additionally store stack-safe information in the; ``ASanStackVariableDescription``. Then if AddressSanitizer detects a bug on; a 'safe' variable we can produce an additional report to let the user know that; probably Stack Safety Analysis failed and we should check for a bug in the; compiler.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackSafetyAnalysis.rst:1612,test,tests,1612,interpreter/llvm-project/llvm/docs/StackSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackSafetyAnalysis.rst,1,['test'],['tests']
Testability,"y matrices |; +-------------------+--------------------------------------------------------+; | `hworld.cxx` | Small program showing basic graphics |; +-------------------+--------------------------------------------------------+; | `guitest.cxx` | Example usage of the ROOT GUI classes |; +-------------------+--------------------------------------------------------+; | `gui` `viewer` | Another ROOT GUI example program |; | `.cxx` | |; +-------------------+--------------------------------------------------------+; | `Hello.cxx` | Dancing text example |; +-------------------+--------------------------------------------------------+; | `Aclock.cxx` | Analog clock (a la X11 `xclock`) |; +-------------------+--------------------------------------------------------+; | `Tetris.cxx` | The known Tetris game based on the ROOT graphics |; +-------------------+--------------------------------------------------------+; | `stress.cxx` | Important ROOT stress testing program |; +-------------------+--------------------------------------------------------+; | `stress*.cxx` | Stress testing of different ROOT classes |; +-------------------+--------------------------------------------------------+; | `bench.cxx` | STL and ROOT container test and benchmarking program |; +-------------------+--------------------------------------------------------+; | QpRandomDriver.cx | Verification program for Quadratic programming classes |; | x | in Quadp library |; +-------------------+--------------------------------------------------------+; | DrawTest.sh | Entry script to extensive **`TTree`** query test suite |; +-------------------+--------------------------------------------------------+; | dt\_\* | Scripts used by DrawTest.sh |; +-------------------+--------------------------------------------------------+. The `$ROOTSYS/test` directory is a gold mine of root-wisdom nuggets, and; we encourage you to explore and exploit it. These instructions will; compile all programs in `$ROOTSYS/test`:. I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:4807,test,testing,4807,documentation/users-guide/TutorialsandTests.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md,1,['test'],['testing']
Testability,"y number of 0.0 simultaneously. Currently we only use it for simple; insertions. See comments in LowerINSERT_VECTOR_ELT_SSE4. //===---------------------------------------------------------------------===//. On a random note, SSE2 should declare insert/extract of 2 x f64 as legal, not; Custom. All combinations of insert/extract reg-reg, reg-mem, and mem-reg are; legal, it'll just take a few extra patterns written in the .td file. Note: this is not a code quality issue; the custom lowered code happens to be; right, but we shouldn't have to custom lower anything. This is probably related; to <2 x i64> ops being so bad. //===---------------------------------------------------------------------===//. LLVM currently generates stack realignment code, when it is not necessary; needed. The problem is that we need to know about stack alignment too early,; before RA runs. At that point we don't know, whether there will be vector spill, or not.; Stack realignment logic is overly conservative here, but otherwise we can; produce unaligned loads/stores. Fixing this will require some huge RA changes. Testcase:; #include <emmintrin.h>. typedef short vSInt16 __attribute__ ((__vector_size__ (16)));. static const vSInt16 a = {- 22725, - 12873, - 22725, - 12873, - 22725, - 12873,; - 22725, - 12873};;. vSInt16 madd(vSInt16 b); {; return _mm_madd_epi16(a, b);; }. Generated code (x86-32, linux):; madd:; pushl %ebp; movl %esp, %ebp; andl $-16, %esp; movaps .LCPI1_0, %xmm1; pmaddwd %xmm1, %xmm0; movl %ebp, %esp; popl %ebp; ret. //===---------------------------------------------------------------------===//. Consider:; #include <emmintrin.h> ; __m128 foo2 (float x) {; return _mm_set_ps (0, 0, x, 0);; }. In x86-32 mode, we generate this spiffy code:. _foo2:; 	movss	4(%esp), %xmm0; 	pshufd	$81, %xmm0, %xmm0; 	ret. in x86-64 mode, we generate this code, which could be better:. _foo2:; 	xorps	%xmm1, %xmm1; 	movss	%xmm0, %xmm1; 	pshufd	$81, %xmm1, %xmm0; 	ret. In sse4 mode, we could use insertps t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt:15100,log,logic,15100,interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,1,['log'],['logic']
Testability,"y operands or blocks referencing the IR then the; IR function can be replaced by a parameterless dummy function like; `define @func() { ret void }`. - It is possible to drop the whole IR section of the MIR file if it only; contains dummy functions (see above). The .mir loader will create the; IR functions automatically in this case. .. _limitations:. Limitations; -----------. Currently the MIR format has several limitations in terms of which state it; can serialize:. - The target-specific state in the target-specific ``MachineFunctionInfo``; subclasses isn't serialized at the moment. - The target-specific ``MachineConstantPoolValue`` subclasses (in the ARM and; SystemZ backends) aren't serialized at the moment. - The ``MCSymbol`` machine operands don't support temporary or local symbols. - A lot of the state in ``MachineModuleInfo`` isn't serialized - only the CFI; instructions and the variable debug information from MMI is serialized right; now. These limitations impose restrictions on what you can test with the MIR format.; For now, tests that would like to test some behaviour that depends on the state; of temporary or local ``MCSymbol`` operands or the exception handling state in; MMI, can't use the MIR format. As well as that, tests that test some behaviour; that depends on the state of the target specific ``MachineFunctionInfo`` or; ``MachineConstantPoolValue`` subclasses can't use the MIR format at the moment. High Level Structure; ====================. .. _embedded-module:. Embedded Module; ---------------. When the first YAML document contains a `YAML block literal string`_, the MIR; parser will treat this string as an LLVM assembly language string that; represents an embedded LLVM IR module.; Here is an example of a YAML document that contains an LLVM module:. .. code-block:: llvm. define i32 @inc(i32* %x) {; entry:; %0 = load i32, i32* %x; %1 = add i32 %0, 1; store i32 %1, i32* %x; ret i32 %1; }. .. _YAML block literal string: http://www.yaml.org/spec/1.2/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:5936,test,test,5936,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['test'],['test']
Testability,"y states that it is an object file path (the default). A positional argument or standard input value can be preceded by ""DATA"" or; ""CODE"" to indicate that the address should be symbolized as data or executable; code respectively. If neither is specified, ""CODE"" is assumed. DATA is; symbolized as address and symbol size rather than line number. :program:`llvm-symbolizer` parses options from the environment variable; ``LLVM_SYMBOLIZER_OPTS`` after parsing options from the command line.; ``LLVM_SYMBOLIZER_OPTS`` is primarily useful for supplementing the command-line; options when :program:`llvm-symbolizer` is invoked by another program or; runtime. EXAMPLES; --------. All of the following examples use the following two source files as input. They; use a mixture of C-style and C++-style linkage to illustrate how these names are; printed differently (see :option:`--demangle`). .. code-block:: c. // test.h; extern ""C"" inline int foz() {; return 1234;; }. .. code-block:: c. // test.cpp; #include ""test.h""; int bar=42;. int foo() {; return bar;; }. int baz() {; volatile int k = 42;; return foz() + k;; }. int main() {; return foo() + baz();; }. These files are built as follows:. .. code-block:: console. $ clang -g test.cpp -o test.elf; $ clang -g -O2 test.cpp -o inlined.elf. Example 1 - addresses and object on command-line:. .. code-block:: console. $ llvm-symbolizer --obj=test.elf 0x4004d0 0x400490; foz; /tmp/test.h:1:0. baz(); /tmp/test.cpp:11:0. Example 2 - addresses on standard input:. .. code-block:: console. $ cat addr.txt; 0x4004a0; 0x400490; 0x4004d0; $ llvm-symbolizer --obj=test.elf < addr.txt; main; /tmp/test.cpp:15:0. baz(); /tmp/test.cpp:11:0. foz; /tmp/./test.h:1:0. Example 3 - object specified with address:. .. code-block:: console. $ llvm-symbolizer ""test.elf 0x400490"" ""FILE:inlined.elf 0x400480""; baz(); /tmp/test.cpp:11:0. foo(); /tmp/test.cpp:8:10. $ cat addr2.txt; FILE:test.elf 0x4004a0; inlined.elf 0x400480. $ llvm-symbolizer < addr2.txt; main; /tmp/test.cp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst:2298,test,test,2298,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,1,['test'],['test']
Testability,"y. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; The cmake build tool is set up to create Visual Studio project files; for running the tests, ""check-clang"" being the root. Therefore, to; run the test from Visual Studio, right-click the check-clang project; and select ""Build"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:4737,test,test,4737,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,1,['test'],['test']
Testability,"yer will call; this function to ask us what we would like to compile. At a minimum we need to; compile the function being called (given by the argument to the partitioning; function), but we could also request that the CompileOnDemandLayer compile other; functions that are unconditionally called (or highly likely to be called) from; the function being called. For KaleidoscopeJIT we'll keep it simple and just; request compilation of the function that was called. Next we pass a reference to; our CompileCallbackManager. Finally, we need to supply an ""indirect stubs; manager builder"": a utility function that constructs IndirectStubManagers, which; are in turn used to build the stubs for the functions in each module. The; CompileOnDemandLayer will call the indirect stub manager builder once for each; call to addModule, and use the resulting indirect stubs manager to create; stubs for all functions in all modules in the set. If/when the module set is; removed from the JIT the indirect stubs manager will be deleted, freeing any; memory allocated to the stubs. We supply this function by using the; createLocalIndirectStubsManagerBuilder utility. .. code-block:: c++. // ...; if (auto Sym = CODLayer.findSymbol(Name, false)); // ...; return cantFail(CODLayer.addModule(std::move(Ms),; std::move(Resolver)));; // ... // ...; return CODLayer.findSymbol(MangledNameStream.str(), true);; // ... // ...; CODLayer.removeModule(H);; // ... Finally, we need to replace the references to OptimizeLayer in our addModule,; findSymbol, and removeModule methods. With that, we're up and running. **To be done:**. ** Chapter conclusion.**. Full Code Listing; =================. Here is the complete code listing for our running example with a CompileOnDemand; layer added to enable lazy function-at-a-time compilation. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst:7375,stub,stubs,7375,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,2,['stub'],['stubs']
Testability,yet because they contain Fortran; code. In case of cactuBSSN only a small portion is Fortran. The hosts's; Fortran compiler could be used for these parts. Note that CMake's Ninja generator has difficulties with Fortran. See the; `CMake documentation <https://cmake.org/cmake/help/v3.13/generator/Ninja.html#fortran-support>`_; for details. * 503.bwaves_r/603.bwaves_s; * 507.cactuBSSN_r; * 521.wrf_r/621.wrf_s; * 527.cam4_r/627.cam4_s; * 628.pop2_s; * 548.exchange2_r/648.exchange2_s; * 549.fotonik3d_r/649.fotonik3d_s; * 554.roms_r/654.roms_s. SPEC OMP2012; ------------; https://www.spec.org/omp2012/. * 350.md; * 351.bwaves; * 352.nab; * 357.bt331; * 358.botsalgn; * 359.botsspar; * 360.ilbdc; * 362.fma3d; * 363.swim; * 367.imagick; * 370.mgrid331; * 371.applu331; * 372.smithwa; * 376.kdtree. OpenCV; ------; https://opencv.org/. OpenMP 4.x SIMD Benchmarks; --------------------------; https://github.com/flwende/simd_benchmarks. PWM-benchmarking; ----------------; https://github.com/tbepler/PWM-benchmarking. SLAMBench; ---------; https://github.com/pamela-project/slambench. FireHose; --------; http://firehose.sandia.gov/. A Benchmark for the C/C++ Standard Library; ------------------------------------------; https://github.com/hiraditya/std-benchmark. OpenBenchmarking.org CPU / Processor Suite; ------------------------------------------; https://openbenchmarking.org/suite/pts/cpu. This is a subset of the; `Phoronix Test Suite <https://github.com/phoronix-test-suite/phoronix-test-suite/>`_; and is itself a collection of benchmark suites. Parboil Benchmarks; ------------------; http://impact.crhc.illinois.edu/parboil/parboil.aspx. MachSuite; ---------; https://breagen.github.io/MachSuite/. Rodinia; -------; http://lava.cs.virginia.edu/Rodinia/download_links.htm. Rodinia has already been partially included in; MultiSource/Benchmarks/Rodinia. Benchmarks still missing are:. * streamcluster; * particlefilter; * nw; * nn; * myocyte; * mummergpu; * lud; * leukocyte; * lavaMD; * kmea,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst:1949,benchmark,benchmarking,1949,interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst,1,['benchmark'],['benchmarking']
Testability,"ying; a ``std::vector`` while looping over it, whereas Python has no such; restriction, complicating loops.; Thus, cppyy has specialized ``std::vector`` iteration for both PyPy and; CPython, easily outperforming looping over an equivalent numpy array. In CPython, the performance of `non-overloaded` function calls depends; greatly on the Python interpreter's internal specializations; and Python3; has many specializations specific to basic extension modules (C function; pointer calls), gaining a performance boost of more than 30% over Python2.; Only since Python3.8 is there also better support for closure objects (vector; calls) as cppyy uses, to short-cut through the interpreter's own overhead. As a practical consideration, whether a binder performs well on code that you; care about, depends `entirely` on whether it has the relevant specializations; for your most performance-sensitive use cases.; The only way to know for sure is to write a test application and measure, but; a binder that provides more specializations, or makes it easy to add your; own, is more likely to deliver. `Manual v.s. automatic`; -----------------------. Python is, today, one of the most popular programming languages and has a; rich and mature eco-system around it.; But when the project that became cppyy started in the field of High Energy; Physics (HEP), Python usage was non-existent there.; As a Python user to work in this predominantly C++ environment, you had to; bring your own bindings, thus automatic was the only way to go.; Binders such as SWIG, SIP (or even boost.python with Pyste) all had the fatal; assumption that you were providing Python bindings to your `own` C++ code,; and that you were thus able to modify those (many) areas of the C++ codes; that their parsers could not handle.; The `CINT`_ interpreter was already well established in HEP, however, and; although it, too, had many limitations, C++ developers took care not to write; code that it could not parse.; In particular, sinc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:4375,test,test,4375,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['test'],['test']
Testability,"yline); - TGaxis : [dflt](https://root.cern/js/latest/examples.htm#misc_axis); - TEllipse : [dflt](https://root.cern/js/latest/examples.htm#misc_ellipse); - TArrow : [dflt](https://root.cern/js/latest/examples.htm#misc_arrow); - TPolyMarker3D: [dflt](https://root.cern/js/latest/examples.htm#misc_3dmark). More examples of supported classes can be found on: <https://root.cern/js/latest/examples.htm>. There are special JSROOT draw options which only can be used with for `TCanvas` or `TPad` objects:. - logx - enable log10 scale for X axis; - logy - enable log10 scale for Y axis; - logz - enable log10 scale for Z axis; - log - enable log10 scale for X,Y,Z axes; - log2x - enable log2 scale for X axis; - log2y - enable log2 scale for Y axis; - log2z - enable log2 scale for Z axis; - log2 - enable log2 scale for X,Y,Z axes; - gridx - enable grid for X axis; - gridy - enable grid for X axis; - grid - enable grid for X and Y axes; - tickx - enable ticks for X axis; - ticky - enable ticks for X axis; - tick - enable ticks for X and Y axes; - rx - reverse X axis; - ry - reverse Y axis; - rotate - rotate frame; - fixframe - disable interactive moving of the frame; - nozoomx - disable zooming on X axis; - nozoomy - disable zooming on Y axis; - cpXY - create palette XY for the canvas like cp50; - nopalette - ignore palette stored with TCanvas; - nocolors - ignore colors list stored with TCanvas; - lcolors - use only locally colors list stored with TCanvas; - nomargins - clear frame margins. ## Superimposing draw objects. In the URL string one could use ""+"" sign to specify objects superposition:. - [item=hpx+hprof](https://root.cern/js/latest/?file=../files/hsimple.root&item=hpx+hprof). With similar syntax one could specify individual draw options for superimposed objects. - [item=hpx+hprof&opt=logy+hist](https://root.cern/js/latest/?file=../files/hsimple.root&item=hpx+hprof&opt=logy+hist). Here ""logy"" option will be used for ""hpx1"" item and ""hist"" option for ""hprof;1"" item. While d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:12835,log,logx,12835,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,4,['log'],"['log', 'logx', 'logy', 'logz']"
Testability,"ymbolizer ""test.elf 0x400490"" ""FILE:inlined.elf 0x400480""; baz(); /tmp/test.cpp:11:0. foo(); /tmp/test.cpp:8:10. $ cat addr2.txt; FILE:test.elf 0x4004a0; inlined.elf 0x400480. $ llvm-symbolizer < addr2.txt; main; /tmp/test.cpp:15:0. foo(); /tmp/test.cpp:8:10. Example 4 - BUILDID and FILE prefixes:. .. code-block:: console. $ llvm-symbolizer ""FILE:test.elf 0x400490"" ""DATA BUILDID:123456789abcdef 0x601028""; baz(); /tmp/test.cpp:11:0. bar; 6295592 4. $ cat addr3.txt; FILE:test.elf 0x400490; DATA BUILDID:123456789abcdef 0x601028. $ llvm-symbolizer < addr3.txt; baz(); /tmp/test.cpp:11:0. bar; 6295592 4. Example 5 - CODE and DATA prefixes:. .. code-block:: console. $ llvm-symbolizer --obj=test.elf ""CODE 0x400490"" ""DATA 0x601028""; baz(); /tmp/test.cpp:11:0. bar; 6295592 4. $ cat addr4.txt; CODE test.elf 0x4004a0; DATA inlined.elf 0x601028. $ llvm-symbolizer < addr4.txt; main; /tmp/test.cpp:15:0. bar; 6295592 4. Example 6 - path-style options:. This example uses the same source file as above, but the source file's; full path is /tmp/foo/test.cpp and is compiled as follows. The first case; shows the default absolute path, the second --basenames, and the third; shows --relativenames. .. code-block:: console. $ pwd; /tmp; $ clang -g foo/test.cpp -o test.elf; $ llvm-symbolizer --obj=test.elf 0x4004a0; main; /tmp/foo/test.cpp:15:0; $ llvm-symbolizer --obj=test.elf 0x4004a0 --basenames; main; test.cpp:15:0; $ llvm-symbolizer --obj=test.elf 0x4004a0 --relativenames; main; foo/test.cpp:15:0. Example 7 - Addresses as symbol names:. .. code-block:: console. $ llvm-symbolizer --obj=test.elf main; main; /tmp/test.cpp:14:0; $ llvm-symbolizer --obj=test.elf ""CODE foz""; foz; /tmp/test.h:1:0. OPTIONS; -------. .. option:: --adjust-vma <offset>. Add the specified offset to object file addresses when performing lookups.; This can be used to perform lookups as if the object were relocated by the; offset. .. option:: --basenames, -s. Print just the file's name without any directories, instead ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst:4113,test,test,4113,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,1,['test'],['test']
Testability,"ymmetric linear system. For users who need the solution, using this functions avoid for them performing the inversion and then a matrix multiplication. Add support in the SMatrix class for operator m[i][j]; Add in the dictionary the typedefs for some square and symmetrix matrices based on double and floats (up to size 7) defined in the file Math/SMatrixDfwd and Math/SMatrixFfwd; . Minuit. Apply various improvements in the TMInuitMInimizer class thanks to the feedback of Alfio Lazzaro:; ; implement Hess() and CovMatrixStatus();; add new method based on SEEK. The Tolerance() value can be used to specify the volume (in unit of sigma) for searching for the global minimum; fix some of the methods, like NCalls() and GlobalCC(); . Minuit2. Apply some fixes in MnHesse and MnPosDef classes to check correctly variables to not be zero.; (use same checks as in F77Minuit); ; Fix a bug introduced in DavidonErrorCalculator when checking for delgam. Negative values are allowed. This fixes a test problem given privately by A. Suter.; ; Uses also a tighter condition on edm when exiting the iterations (factor of 5 smaller). This is more consistent with conditions used by F77Minuit.; ; Fix a bug in MnCross in the standalone version of Minuit (when WARNINGMSG was not defined).; ; Fix a bug in the sign of the derivative for sine transformation which are used with double bound parameters. The bug could affect the minimization of function with user provided gradient and bound parameters and bound parameters. It could also affected Fumili2. Furthermore, a wrong sign for the correlation matrix could also have been obtained in some cases with bound parameters.; ; Use a tolerance of 0.01 instead of 0.05 in MnContours. The value of 0.01 is the same used in Minos. This is sufficient to get good quality contours.; Improve also the debug in MnContour. Add printing of points as info messages; Remove some un-necessary assert() when defining the minimization parameters.; Fix a bug in MnHesse to retur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html:5592,test,test,5592,math/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html,1,['test'],['test']
Testability,"you must export ``MACOSX_DEPLOYMENT_TARGET=10.9`` before running; the script. This script builds three phases of Clang+LLVM twice each (Release and; Release+Asserts), so use screen or nohup to avoid headaches, since it'll take; a long time. Use the ``--help`` option to see all the options and chose it according to; your needs. findRegressions-nightly.py; --------------------------. TODO. .. _test-suite:. Test Suite; ==========. .. contents::; :local:. Follow the `LNT Quick Start Guide; <https://llvm.org/docs/lnt/quickstart.html>`__ link on how to set-up the; test-suite. The binary location you'll have to use for testing is inside the; ``rcN/Phase3/Release+Asserts/llvmCore-REL-RC.install``.; Link that directory to an easier location and run the test-suite. An example on the run command line, assuming you created a link from the correct; install directory to ``~/devel/llvm/install``::. ./sandbox/bin/python sandbox/bin/lnt runtest \; nt \; -j4 \; --sandbox sandbox \; --test-suite ~/devel/llvm/test/test-suite \; --cc ~/devel/llvm/install/bin/clang \; --cxx ~/devel/llvm/install/bin/clang++. It should have no new regressions, compared to the previous release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:3873,sandbox,sandbox,3873,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,7,"['sandbox', 'test']","['sandbox', 'test', 'test-suite']"
Testability,"your comments, scroll to the bottom of the page and; click the Submit button. You can add overall comments in the text box at the bottom of the page.; When you're done, click the Submit button. Phabricator has many useful features, for example allowing you to select; diffs between different versions of the patch as it was reviewed in the; *Revision Update History*. Most features are self descriptive - explore, and; if you have a question, drop by on #llvm in IRC to get help. Note that as e-mail is the system of reference for code reviews, and some; people prefer it over a web interface, we do not generate automated mail; when a review changes state, for example by clicking ""Accept Revision"" in; the web interface. Thus, please type LGTM into the comment box to accept; a change from Phabricator. .. _pre-merge-testing:. Pre-merge testing; -----------------. The pre-merge tests are a continuous integration (CI) workflow. The workflow; checks the patches uploaded to Phabricator before a user merges them to the main; branch - thus the term *pre-merge testing*. When a user uploads a patch to Phabricator, Phabricator triggers the checks and; then displays the results. This way bugs in a patch are contained during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how to improve pre-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repository. Please make sure that either:. * You set a git hash as ``sourceControlBaseRevision`` in Phabric",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:10590,test,testing,10590,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['test'],['testing']
Testability,"ype RooDataSet) rather; than binned datasets of type RooDataHist so that mixed binned/unbinned data is always represented; through a uniform interface. Fix in the optimization strategy of likelihoods constructed from simultaneous pdf. In the parameter; dependency analysis of the components of a simultaneous pdfs parameters originating from 'irrelevant'; constraint terms (i.e. those that don't relate to any of the parameters of that likelihood component) were; not ignored, which could result in a substantial loss of computational efficiency as likelihood; terms were erroneously recalculated even if no relevant parameters was changed. General performance tuning of RooFit to reduce computational overhead. Extensive profiling of; CPU times in call graphas and analysis heap memory use have been performed and many small ; changes have been made to make the code more efficient and use less memory. RooStats Package; AsymptoticCalculator. New Class for doing an hypothesis tests using the asymptotic likelihood formulae, described in the paper from; G. Cowan, K. Cranmer, E. Gross and O. Vitells, Asymptotic formulae for likelihood- based tests of new physics,; Eur. Phys. J., C71 (1), 2011.; The class computes the p-value for the null and also for the alternate using the Asimov data set. In this; differs form the ProfileLikelihoodCalculator which computes only the p-values for the null hypothesis.; The Asimov data set is generated with the utility function AsymptoticCalculator::MakeAsimovData and then; it is used to evaluate the likelihood. ; ; This class implements the HypoTestCalculatorGeneric interface and can be used as an alternative Hypothesis test; calculator in the HypoTestInverter class. It can then plugged in the HypoTestInverter for computing asymptotic CLs and CLs+b; limits. In this way the limits will be computed by just performing a fit for each test parameter value and without; generating any toys. . The class can be used via the StandardHypothesisTest.C tutorial ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html:6991,test,tests,6991,roofit/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html,1,['test'],['tests']
Testability,"ype may be used as; the value arguments to the PHI node. Only labels may be used as the; label arguments. There must be no non-phi instructions between the start of a basic block; and the PHI instructions: i.e. PHI instructions must be first in a basic; block. For the purposes of the SSA form, the use of each incoming value is; deemed to occur on the edge from the corresponding predecessor block to; the current block (but after any definition of an '``invoke``'; instruction's return value on the same edge). The optional ``fast-math-flags`` marker indicates that the phi has one; or more :ref:`fast-math-flags <fastmath>`. These are optimization hints; to enable otherwise unsafe floating-point optimizations. Fast-math-flags; are only valid for phis that return a floating-point scalar or vector; type, or an array (nested to any depth) of floating-point scalar or vector; types. Semantics:; """""""""""""""""""". At runtime, the '``phi``' instruction logically takes on the value; specified by the pair corresponding to the predecessor basic block that; executed just prior to the current block. Example:; """""""""""""""". .. code-block:: llvm. Loop: ; Infinite loop that counts from 0 on up...; %indvar = phi i32 [ 0, %LoopHeader ], [ %nextindvar, %Loop ]; %nextindvar = add i32 %indvar, 1; br label %Loop. .. _i_select:. '``select``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = select [fast-math flags] selty <cond>, <ty> <val1>, <ty> <val2> ; yields ty. selty is either i1 or {<N x i1>}. Overview:; """""""""""""""""". The '``select``' instruction is used to choose one value based on a; condition, without IR-level branching. Arguments:; """""""""""""""""""". The '``select``' instruction requires an 'i1' value or a vector of 'i1'; values indicating the condition, and two values of the same :ref:`first; class <t_firstclass>` type. #. The optional ``fast-math flags`` marker indicates that the select has one or more; :ref:`fast-math flags <fastmath>`. These are optimization hints to enable; oth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:468399,log,logically,468399,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['log'],['logically']
Testability,"ype_template_args`` was not updated.; However, its support can be tested with ``__has_extension(cxx_generalized_nttp)``. - Clang won't perform ODR checks for decls in the global module fragment any; more to ease the implementation and improve the user's using experience.; This follows the MSVC's behavior. Users interested in testing the more strict; behavior can use the flag '-Xclang -fno-skip-odr-check-in-gmf'.; (`#79240 <https://github.com/llvm/llvm-project/issues/79240>`_). C++23 Feature Support; ^^^^^^^^^^^^^^^^^^^^^; - Implemented `P0847R7: Deducing this <https://wg21.link/P0847R7>`_. Some related core issues were also; implemented (`CWG2553 <https://wg21.link/CWG2553>`_, `CWG2554 <https://wg21.link/CWG2554>`_,; `CWG2653 <https://wg21.link/CWG2653>`_, `CWG2687 <https://wg21.link/CWG2687>`_). Because the; support for this feature is still experimental, the feature test macro ``__cpp_explicit_this_parameter``; was not set in this version.; However, its support can be tested with ``__has_extension(cxx_explicit_this_parameter)``. - Added a separate warning to warn the use of attributes on lambdas as a C++23 extension; in previous language versions: ``-Wc++23-lambda-attributes``. C++2c Feature Support; ^^^^^^^^^^^^^^^^^^^^^. - Implemented `P2169R4: A nice placeholder with no name <https://wg21.link/P2169R4>`_. This allows using ``_``; as a variable name multiple times in the same scope and is supported in all C++ language modes as an extension.; An extension warning is produced when multiple variables are introduced by ``_`` in the same scope.; Unused warnings are no longer produced for variables named ``_``.; Currently, inspecting placeholders variables in a debugger when more than one are declared in the same scope; is not supported. .. code-block:: cpp. struct S {; int _, _; // Was invalid, now OK; };; void func() {; int _, _; // Was invalid, now OK; }; void other() {; int _; // Previously diagnosed under -Wunused, no longer diagnosed; }. - Attributes now expect u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:10025,test,tested,10025,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['test'],['tested']
Testability,"ypedef types. Given; typedef int X;; typedefType(); matches ""typedef int X"". Matcher<Type>unaryTransformTypeMatcher<UnaryTransformType>...; Matches types nodes representing unary type transformations. Given:; typedef __underlying_type(T) type;; unaryTransformType(); matches ""__underlying_type(T)"". Matcher<Type>usingTypeMatcher<UsingType>...; Matches types specified through a using declaration. Given; namespace a { struct S {}; }; using a::S;; S s;. usingType() matches the type of the variable declaration of s. Matcher<Type>variableArrayTypeMatcher<VariableArrayType>...; Matches C arrays with a specified size that is not an; integer-constant-expression. Given; void f() {; int a[] = { 2, 3 }; int b[42];; int c[a[0]];; }; variableArrayType(); matches ""int c[a[0]]"". Narrowing Matchers. Narrowing matchers match certain attributes on the current node, thus; narrowing down the set of nodes of the current type to match on.; There are special logical narrowing matchers (allOf, anyOf, anything and unless); which allow users to create more powerful match expressions. Return typeNameParameters. Matcher<*>allOfMatcher<*>, ..., Matcher<*>; Matches if all given matchers match. Usable as: Any Matcher. Matcher<*>anyOfMatcher<*>, ..., Matcher<*>; Matches if any of the given matchers matches. Usable as: Any Matcher. Matcher<*>anything; Matches any node. Useful when another matcher requires a child matcher, but there's no; additional constraint. This will often be used with an explicit conversion; to an internal::Matcher<> type such as TypeMatcher. Example: DeclarationMatcher(anything()) matches all declarations, e.g.,; ""int* p"" and ""void f()"" in; int* p;; void f();. Usable as: Any Matcher. unspecifiedmapAnyOfnodeMatcherFunction...; Matches any of the NodeMatchers with InnerMatchers nested within. Given; if (true);; for (; true; );; with the matcher; mapAnyOf(ifStmt, forStmt).with(; hasCondition(cxxBoolLiteralExpr(equals(true))); ).bind(""trueCond""); matches the if and the for. It is eq",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:53525,log,logical,53525,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['log'],['logical']
Testability,"ypes: !2); !8 = !{!9, !11}; !9 = !DILocalVariable(name: ""1"", scope: !6, file: !1, line: 1, type: !10); !10 = !DIBasicType(name: ""ty64"", size: 64, encoding: DW_ATE_unsigned); !11 = !DILocalVariable(name: ""2"", scope: !6, file: !1, line: 3, type: !10); !12 = !DILocation(line: 1, column: 1, scope: !6); !13 = !DILocation(line: 2, column: 1, scope: !6); !14 = !DILocation(line: 3, column: 1, scope: !6); !15 = !DILocation(line: 4, column: 1, scope: !6); !16 = !DILocation(line: 5, column: 1, scope: !6). Using ``debugify``; ^^^^^^^^^^^^^^^^^^. A simple way to use ``debugify`` is as follows:. .. code-block:: bash. $ opt -debugify -pass-to-test -check-debugify sample.ll. This will inject synthetic DI to ``sample.ll`` run the ``pass-to-test`` and; then check for missing DI. The ``-check-debugify`` step can of course be; omitted in favor of more customizable FileCheck directives. Some other ways to run debugify are available:. .. code-block:: bash. # Same as the above example.; $ opt -enable-debugify -pass-to-test sample.ll. # Suppresses verbose debugify output.; $ opt -enable-debugify -debugify-quiet -pass-to-test sample.ll. # Prepend -debugify before and append -check-debugify -strip after; # each pass on the pipeline (similar to -verify-each).; $ opt -debugify-each -O2 sample.ll. In order for ``check-debugify`` to work, the DI must be coming from; ``debugify``. Thus, modules with existing DI will be skipped. ``debugify`` can be used to test a backend, e.g:. .. code-block:: bash. $ opt -debugify < sample.ll | llc -o -. There is also a MIR-level debugify pass that can be run before each backend; pass, see:; :ref:`Mutation testing for MIR-level transformations<MIRDebugify>`. ``debugify`` in regression tests; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The output of the ``debugify`` pass must be stable enough to use in regression; tests. Changes to this pass are not allowed to break existing tests. .. note::. Regression tests must be robust. Avoid hardcoding line/variable numbers in; check ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:12474,test,test,12474,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['test'],['test']
Testability,"ype}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a particular relevant target?. If the answer to any of these is ""yes"", the feature test macro should either; not be defined or there should be very strong rationale for why the issues; should not prevent defining it. Note, it is acceptable to define the feature; test macro on a per-target basis if needed. When in doubt, being conservative is better than being aggressive. If we don't; claim support for the feature but it does useful things, users can still use it; and provide us with useful feedback on what is missing. But if we claim support; for a feature that has significant bugs, we've eliminated most of the utility; of having a feature testing macro at all because u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:163276,test,test,163276,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['test'],['test']
Testability,"ys shown at the end of the run and; the results are always stored in the ``report.<type>.format`` file (when; running with ``TEST=<type>``). The ``report`` also generate a file; called ``report.<type>.raw.out`` containing the output of the entire; test run. Writing Custom Tests for the test-suite; =======================================. Assuming you can run the test suite, (e.g.; ""``gmake TEST=nightly report``"" should work), it is really easy to run; optimizations or code generator components against every program in the; tree, collecting statistics or running custom checks for correctness. At; base, this is how the nightly tester works, it's just one example of a; general framework. Lets say that you have an LLVM optimization pass, and you want to see; how many times it triggers. First thing you should do is add an LLVM; `statistic <ProgrammersManual.html#Statistic>`_ to your pass, which will; tally counts of things you care about. Following this, you can set up a test and a report that collects these; and formats them for easy viewing. This consists of two files, a; ""``test-suite/TEST.XXX.Makefile``"" fragment (where XXX is the name of; your test) and a ""``test-suite/TEST.XXX.report``"" file that indicates; how to format the output into a table. There are many example reports of; various levels of sophistication included with the test suite, and the; framework is very general. If you are interested in testing an optimization pass, check out the; ""libcalls"" test as an example. It can be run like this:. .. code-block:: bash. % cd llvm/projects/test-suite/MultiSource/Benchmarks # or some other level; % make TEST=libcalls report. This will do a bunch of stuff, then eventually print a table like this:. ::. Name | total | #exit |; ...; FreeBench/analyzer/analyzer | 51 | 6 |; FreeBench/fourinarow/fourinarow | 1 | 1 |; FreeBench/neural/neural | 19 | 9 |; FreeBench/pifft/pifft | 5 | 3 |; MallocBench/cfrac/cfrac | 1 | * |; MallocBench/espresso/espresso | 52 | 12 |; MallocBenc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:5698,test,test,5698,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,1,['test'],['test']
Testability,"ysis should; always involve two functions: an ``ActOnXXX`` function that will be called; directly from the parser, and a ``BuildXXX`` function that performs the; actual semantic analysis and will (eventually!) build the AST node. It's; fairly common for the ``ActOnCXX`` function to do very little (often just; some minor translation from the parser's representation to ``Sema``'s; representation of the same thing), but the separation is still important:; C++ template instantiation, for example, should always call the ``BuildXXX``; variant. Several notes on semantic analysis before we get into construction; of the AST:. * Your expression probably involves some types and some subexpressions.; Make sure to fully check that those types, and the types of those; subexpressions, meet your expectations. Add implicit conversions where; necessary to make sure that all of the types line up exactly the way you; want them. Write extensive tests to check that you're getting good; diagnostics for mistakes and that you can use various forms of; subexpressions with your expression.; * When type-checking a type or subexpression, make sure to first check; whether the type is ""dependent"" (``Type::isDependentType()``) or whether a; subexpression is type-dependent (``Expr::isTypeDependent()``). If any of; these return ``true``, then you're inside a template and you can't do much; type-checking now. That's normal, and your AST node (when you get there); will have to deal with this case. At this point, you can write tests that; use your expression within templates, but don't try to instantiate the; templates.; * For each subexpression, be sure to call ``Sema::CheckPlaceholderExpr()``; to deal with ""weird"" expressions that don't behave well as subexpressions.; Then, determine whether you need to perform lvalue-to-rvalue conversions; (``Sema::DefaultLvalueConversions``) or the usual unary conversions; (``Sema::UsualUnaryConversions``), for places where the subexpression is; producing a value y",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:146662,test,tests,146662,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['test'],['tests']
Testability,"ystems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, which are built with a given path; (into the build directory) and can later be used from an installed; location. To build a relocatable precompiled header, place your headers into a; subdirectory whose structure mimics the installed location. For example,; if you want to build a precompiled header for the header ``mylib.h``; that will be i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:47544,test,test,47544,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['test'],['test']
Testability,"yx & yy & yz \\; zx & zy & zz; \end{array}; \right|$$. It describes a so-called active rotation, i.e. a rotation of objects; inside a static system of coordinates. In case you want to rotate the; frame and want to know the coordinates of objects in the rotated system,; you should apply the inverse rotation to the objects. If you want to; transform coordinates from the rotated frame to the original frame you; have to apply the direct transformation. A rotation around a specified; axis means counterclockwise rotation around the positive direction of; the axis. ### Declaration, Access, Comparisons. ``` {.cpp}; TRotation r; // r initialized as identity; TRotation m(r); // m = r; ```. There is no direct way to set the matrix elements - to ensure that a; **`TRotation`** always describes a real rotation. But you can get the; values by with the methods `XX()..ZZ()` or the `(,)` operator:. ``` {.cpp}; Double_t xx = r.XX(); // the same as xx=r(0,0); xx = r(0,0);; if (r==m) {...} // test for equality; if (r!=m) {..} // test for inequality; if (r.IsIdentity()) {...} // test for identity; ```. ### Rotation around Axes. The following matrices describe counter-clockwise rotations around the; coordinate axes and are implemented in: `RotateX()`,` RotateY()` and; `RotateZ()`:. $$; Rx(a) = \left|; \begin{array}{ccc}; 1 & 0 & 0 \\; 0 & cos(a) & -sin(a) \\; 0 & sin(a) & cos(a); \end{array}; \right|; Ry(a) = \left|; \begin{array}{ccc}; cos(a) & 0 & sin(a) \\; 0 & 1 & 0 \\; -sin(a) & 0 & cos(a); \end{array}; \right|; Rz(a) = \left|; \begin{array}{ccc}; cos(a) & -sin(a) & 0 \\; sin(a) & cos(a) & 0 \\; 0 & 0 & 1; \end{array}; \right|; $$. ``` {.cpp}; r.RotateX(TMath::Pi()); // rotation around the x-axis; ```. ### Rotation around Arbitrary Axis. The `Rotate()` method allows you to rotate around an arbitrary vector; (not necessary a unit one) and returns the result. ``` {.cpp}; r.Rotate(TMath::Pi()/3,TVector3(3,4,5));; ```. It is possible to find a unit vector and an angle, which describe the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:6702,test,test,6702,documentation/users-guide/PhysicsVectors.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md,1,['test'],['test']
Testability,"yzer-checker=core test.c. Otherwise, if your command line contains --analyze,; the actual clang instance would be run in a separate process. In; order to debug it, use the -### flag for obtaining; the command line of the child process:. $ clang --analyze test.c -\#\#\#. Below we describe a few useful command line arguments, all of which assume that; you are running clang -cc1. Narrowing Down the Problem; While investigating a checker-related issue, instruct the analyzer to only; execute a single checker:. $ clang -cc1 -analyze -analyzer-checker=osx.KeychainAPI test.c. If you are experiencing a crash, to see which function is failing while; processing a large file use the -analyzer-display-progress; option.; To selectively analyze only the given function, use the; -analyze-function option:. $ clang -cc1 -analyze -analyzer-checker=core test.c -analyzer-display-progress; ANALYZE (Syntax): test.c foo; ANALYZE (Syntax): test.c bar; ANALYZE (Path, Inline_Regular): test.c bar; ANALYZE (Path, Inline_Regular): test.c foo; $ clang -cc1 -analyze -analyzer-checker=core test.c -analyzer-display-progress -analyze-function=foo; ANALYZE (Syntax): test.c foo; ANALYZE (Path, Inline_Regular): test.c foo. Note: a fully qualified function name has to be used when selecting; C++ functions and methods, Objective-C methods and blocks, e.g.:. $ clang -cc1 -analyze -analyzer-checker=core test.cc -analyze-function='foo(int)'. The fully qualified name can be found from the; -analyzer-display-progress output. The bug reporter mechanism removes path diagnostics inside intermediate; function calls that have returned by the time the bug was found and contain; no interesting pieces. Usually it is up to the checkers to produce more; interesting pieces by adding custom BugReporterVisitor objects.; However, you can disable path pruning while debugging with the; -analyzer-config prune-paths=false option. Visualizing the Analysis; To dump the AST, which often helps understanding how the program should; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:20084,test,test,20084,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['test'],['test']
Testability,"zation; Unknown; Unknown. relaxed restrictions on portable header names; N772; Unknown. return without an expression not permitted in function that returns a value; Unknown; Yes. C11 implementation status; Clang implements a significant portion of the ISO 9899:2011 (C11) standard, but the status of individual proposals is still under investigation.; You can use Clang in C11 mode with the -std=c11 option (use -std=c1x in Clang 3.0 and earlier). List of features and minimum Clang version with support. Language Feature; C11 Proposal; Available in Clang?. A finer-grained specification for sequencing; N1252; Unknown. Clarification of expressions; N1282; Unknown. Extending the lifetime of temporary objects (factored approach); N1285; Unknown. Requiring signed char to have no padding bits; N1310; Unknown. Initializing static or external variables; N1311; Yes. Conversion between pointers and floating types; N1316; Yes. Adding TR 19769 to the C Standard Library; N1326; Clang 3.3. Static assertions; N1330; Yes. Parallel memory sequencing model proposal; N1349; Unknown. Analyzability (#1, #4 - conditionally normative); N1350; Unknown. FLT_EVAL_METHOD issues (first change only); N1353; Unknown. _Bool bit-fields; N1356; Yes. Technical corrigendum for C1X; N1359; Unknown. Benign typedef redefinition; N1360; Clang 3.1. Thread-local storage; N1364; Clang 3.3. Constant expressions; N1365; Unknown. Contractions and expression evaluation methods; N1367; Unknown. FLT_EVAL_METHOD and return; N1382; Unknown. Floating-point to int/_Bool conversions; N1391; Yes. Analyzability (along the lines); N1394; Unknown. Wide function returns (alternate proposal); N1396; Unknown. Alignment. N1397; Clang 3.2. N1447; Clang 3.2. Anonymous member-structures and unions (modulo ""name lookup""); N1406; Yes. Completeness of types; N1439; Yes. Generic macro facility; N1441; Yes. Dependency ordering for C memory model; N1444; Unknown. Subsetting the standard; N1460; Yes. Assumed types in F.9.2; N1468; Unknown. S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:4740,assert,assertions,4740,interpreter/llvm-project/clang/www/c_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html,1,['assert'],['assertions']
Testability,"ze argument!"");; }; }; }. This function implements a very simple parser for the kinds of strings we are; interested in. Although it has some holes (it allows ""``123KKK``"" for example),; it is good enough for this example. Note that we use the option itself to print; out the error message (the ``error`` method always returns true) in order to get; a nice error message (shown below). Now that we have our parser class, we can; use it like this:. .. code-block:: c++. static cl::opt<unsigned, false, FileSizeParser>; MFS(""max-file-size"", cl::desc(""Maximum file size to accept""),; cl::value_desc(""size""));. Which adds this to the output of our program:. ::. OPTIONS:; -help - display available options (-help-hidden for more); ...; -max-file-size=<size> - Maximum file size to accept. And we can test that our parse works correctly now (the test program just prints; out the max-file-size argument value):. ::. $ ./test; MFS: 0; $ ./test -max-file-size=123MB; MFS: 128974848; $ ./test -max-file-size=3G; MFS: 3221225472; $ ./test -max-file-size=dog; -max-file-size option: 'dog' value invalid for file size argument!. It looks like it works. The error message that we get is nice and helpful, and; we seem to accept reasonable file sizes. This wraps up the ""custom parser""; tutorial. Exploiting external storage; ---------------------------. Several of the LLVM libraries define static ``cl::opt`` instances that will; automatically be included in any program that links with that library. This is; a feature. However, sometimes it is necessary to know the value of the command; line option outside of the library. In these cases the library does or should; provide an external storage location that is accessible to users of the; library. Examples of this include the ``llvm::DebugFlag`` exported by the; ``lib/Support/Debug.cpp`` file and the ``llvm::TimePassesIsEnabled`` flag; exported by the ``lib/IR/PassManager.cpp`` file. .. todo::. TODO: complete this section. .. _dynamically loaded options:.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:66130,test,test,66130,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['test'],['test']
Testability,"ze>. Only effective for `-repetition-mode=[loop|min]`.; Instead of looping over the snippet directly, first duplicate it so that the; loop body contains at least this many instructions. This potentially results; in loop body being cached in the CPU Op Cache / Loop Cache, which allows to; which may have higher throughput than the CPU decoders. .. option:: --max-configs-per-opcode=<value>. Specify the maximum configurations that can be generated for each opcode.; By default this is `1`, meaning that we assume that a single measurement is; enough to characterize an opcode. This might not be true of all instructions:; for example, the performance characteristics of the LEA instruction on X86; depends on the value of assigned registers and immediates. Setting a value of; `-max-configs-per-opcode` larger than `1` allows `llvm-exegesis` to explore; more configurations to discover if some register or immediate assignments; lead to different performance characteristics. .. option:: --benchmarks-file=</path/to/file>. File to read (`analysis` mode) or write (`latency`/`uops`/`inverse_throughput`; modes) benchmark results. ""-"" uses stdin/stdout. .. option:: --analysis-clusters-output-file=</path/to/file>. If provided, write the analysis clusters as CSV to this file. ""-"" prints to; stdout. By default, this analysis is not run. .. option:: --analysis-inconsistencies-output-file=</path/to/file>. If non-empty, write inconsistencies found during analysis to this file. `-`; prints to stdout. By default, this analysis is not run. .. option:: --analysis-filter=[all|reg-only|mem-only]. By default, all benchmark results are analysed, but sometimes it may be useful; to only look at those that to not involve memory, or vice versa. This option; allows to either keep all benchmarks, or filter out (ignore) either all the; ones that do involve memory (involve instructions that may read or write to; memory), or the opposite, to only keep such benchmarks. .. option:: --analysis-clustering=[dbsca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:14484,benchmark,benchmarks-file,14484,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,1,['benchmark'],['benchmarks-file']
Testability,"zer-opt-output-style:. .. option:: --output-style <LLVM|GNU|JSON>. Specify the preferred output style. Defaults to ``LLVM``. When the output; style is set to ``GNU``, the tool follows the style of GNU's **addr2line**.; The differences from the ``LLVM`` style are:. * Does not print the column of a source code location. * Does not add an empty line after the report for an address. * Does not replace the name of an inlined function with the name of the; topmost caller when inlined frames are not shown. * Prints an address's debug-data discriminator when it is non-zero. One way to; produce discriminators is to compile with clang's -fdebug-info-for-profiling. ``JSON`` style provides a machine readable output in JSON. If addresses are; supplied via stdin, the output JSON will be a series of individual objects.; Otherwise, all results will be contained in a single array. .. code-block:: console. $ llvm-symbolizer --obj=inlined.elf 0x4004be 0x400486 -p; baz() at /tmp/test.cpp:11:18; (inlined by) main at /tmp/test.cpp:15:0. foo() at /tmp/test.cpp:6:3. $ llvm-symbolizer --output-style=LLVM --obj=inlined.elf 0x4004be 0x400486 -p --no-inlines; main at /tmp/test.cpp:11:18. foo() at /tmp/test.cpp:6:3. $ llvm-symbolizer --output-style=GNU --obj=inlined.elf 0x4004be 0x400486 -p --no-inlines; baz() at /tmp/test.cpp:11; foo() at /tmp/test.cpp:6. $ clang -g -fdebug-info-for-profiling test.cpp -o profiling.elf; $ llvm-symbolizer --output-style=GNU --obj=profiling.elf 0x401167 -p --no-inlines; main at /tmp/test.cpp:15 (discriminator 2). $ llvm-symbolizer --output-style=JSON --obj=inlined.elf 0x4004be 0x400486 -p; [; {; ""Address"": ""0x4004be"",; ""ModuleName"": ""inlined.elf"",; ""Symbol"": [; {; ""Column"": 18,; ""Discriminator"": 0,; ""FileName"": ""/tmp/test.cpp"",; ""FunctionName"": ""baz()"",; ""Line"": 11,; ""StartAddress"": ""0x4004be"",; ""StartFileName"": ""/tmp/test.cpp"",; ""StartLine"": 9; },; {; ""Column"": 0,; ""Discriminator"": 0,; ""FileName"": ""/tmp/test.cpp"",; ""FunctionName"": ""main"",; ""Line"": 15,; ""StartAdd",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst:9311,test,test,9311,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,1,['test'],['test']
Testability,"zero status. When this option is enabled, :program:`lit` will also automatically provide a; ""``valgrind``"" feature that can be used to conditionally disable (or expect; failure in) certain tests. .. option:: --vg-arg=ARG. When :option:`--vg` is used, specify an additional argument to pass to; :program:`valgrind` itself. .. option:: --vg-leak. When :option:`--vg` is used, enable memory leak checks. When this option is; enabled, :program:`lit` will also automatically provide a ""``vg_leak``""; feature that can be used to conditionally disable (or expect failure in); certain tests. .. option:: --time-tests. Track the wall time individual tests take to execute and includes the results; in the summary output. This is useful for determining which tests in a test; suite take the most time to execute. .. option:: --ignore-fail. Exit with status zero even if some tests fail. .. _selection-options:. SELECTION OPTIONS; -----------------. By default, `lit` will run failing tests first, then run tests in descending; execution time order to optimize concurrency. The execution order can be; changed using the :option:`--order` option. The timing data is stored in the `test_exec_root` in a file named; `.lit_test_times.txt`. If this file does not exist, then `lit` checks the; `test_source_root` for the file to optionally accelerate clean builds. .. option:: --shuffle. Run the tests in a random order, not failing/slowest first. Deprecated,; use :option:`--order` instead. .. option:: --per-test-coverage. Emit the necessary test coverage data, divided per test case (involves; setting a unique value to LLVM_PROFILE_FILE for each RUN). The coverage; data files will be emitted in the directory specified by `config.test_exec_root`. .. option:: --max-failures N. Stop execution after the given number ``N`` of failures.; An integer argument should be passed on the command line; prior to execution. .. option:: --max-tests=N. Run at most ``N`` tests and then terminate. .. option:: --max-time=N. Sp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:5405,test,tests,5405,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,2,['test'],['tests']
Testability,"zzer -merge=1 CURRENT_CORPUS_DIR NEW_POTENTIALLY_INTERESTING_INPUTS_DIR. Running; -------. To run the fuzzer, first create a Corpus_ directory that holds the; initial ""seed"" sample inputs:. .. code-block:: console. mkdir CORPUS_DIR; cp /some/input/samples/* CORPUS_DIR. Then run the fuzzer on the corpus directory:. .. code-block:: console. ./my_fuzzer CORPUS_DIR # -max_len=1000 -jobs=20 ... As the fuzzer discovers new interesting test cases (i.e. test cases that; trigger coverage of new paths through the code under test), those test cases; will be added to the corpus directory. By default, the fuzzing process will continue indefinitely – at least until; a bug is found. Any crashes or sanitizer failures will be reported as usual,; stopping the fuzzing process, and the particular input that triggered the bug; will be written to disk (typically as ``crash-<sha1>``, ``leak-<sha1>``,; or ``timeout-<sha1>``). Parallel Fuzzing; ----------------. Each libFuzzer process is single-threaded, unless the library under test starts; its own threads. However, it is possible to run multiple libFuzzer processes in; parallel with a shared corpus directory; this has the advantage that any new; inputs found by one fuzzer process will be available to the other fuzzer; processes (unless you disable this with the ``-reload=0`` option). This is primarily controlled by the ``-jobs=N`` option, which indicates that; that `N` fuzzing jobs should be run to completion (i.e. until a bug is found or; time/iteration limits are reached). These jobs will be run across a set of; worker processes, by default using half of the available CPU cores; the count of; worker processes can be overridden by the ``-workers=N`` option. For example,; running with ``-jobs=30`` on a 12-core machine would run 6 workers by default,; with each worker averaging 5 bugs by completion of the entire process. Fork mode; ---------. **Experimental** mode ``-fork=N`` (where ``N`` is the number of parallel jobs); enables oom-, time",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:6512,test,test,6512,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['test'],['test']
Testability,"{.cpp}; TLorentzRotation a,b,c;; c = b*a; // product; c = a.MatrixMultiplication(b); // a is unchanged; a *= b; // a=a*b; c = a.Transform(b) // a=b*a then c=a; ```. Lorentz boosts:. ``` {.cpp}; Double_t bx, by, bz;; TVector3 v(bx,by,bz);; TLorentzRotation l;; l.Boost(v);; l.Boost(bx,by,bz);; ```. Rotations:. ``` {.cpp}; TVector3 axis;; l.RotateX(TMath::Pi()); // rotation around x-axis; l.Rotate(.5,axis); // rotation around specified vector; ```. Inverse transformation: use the method `Inverse() `to return the inverse; transformation keeping the current one unchanged`.` The method; `Invert()` inverts the current **`TLorentzRotation`**:. ``` {.cpp}; l1 = l2.Inverse(); // l1 is inverse of l2, l2 unchanged; l1 = l2.Invert(); // invert l2, then l1=l2; ```. The matrix for the inverse transformation of a **`TLorentzRotation`** is; as follows:. $$; \left|; \begin{array}{cccc}; xx & xy & xz & -tx \\; yx & yy & yz & -ty \\; zx & zy & zz & -tz \\; -xt & -yt & -zt & tt; \end{array}; \right|; $$. ### Transformation of a TLorentzVector. To apply **`TLorentzRotation`** to **`TLorentzVector`** you can use; either the `VectorMultiplication()` method or the `* operator`. You can; also use the `Transform()` function and the `*= `operator of the class; **`TLorentzVector`**. ``` {.cpp}; TLorentzVector v;; TLorentzRotation l;; ...; v = l.VectorMultiplication(v);; v = l * v;; v.Transform(l);; v *= l; // v = l*v; ```. ### Physics Vector Example. The test file `$ROOTSYS/test/TestVectors.cxx is` an example of using; physics vectors. The vector classes are not loaded by default, and to; run it, you will need to load `libPhysics.so` first:. ``` {.cpp}; root[] .L $ROOTSYS/lib/libPhysics.so; root[] .x TestVectors.cxx; ```. To load the physics vector library in a ROOT application use:. ``` {.cpp}; gSystem->Load(""libPhysics"");; ```. The example `$ROOTSYS/test/TestVectors.cxx` does not return much,; especially if all went well, but when you look at the code you will find; examples for many calls.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:18111,test,test,18111,documentation/users-guide/PhysicsVectors.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md,3,['test'],['test']
Testability,"{; @private; id x; // warn; }; @end. @implementation MyObj; @end. osx.cocoa.VariadicMethodTypes; (ObjC); Check for passing non-Objective-C types to variadic collection initialization; methods that expect only Objective-C types. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. osx.coreFoundation.CFError; (C); Check usage of CFErrorRef* parameters. void test(CFErrorRef *error) {; // warn: function accepting CFErrorRef* should have a; // non-void return; }. int foo(CFErrorRef *error) {; *error = 0; // warn: potential null dereference; return 0;; }. osx.coreFoundation.CFNumber; (C); Check for improper uses of CFNumberCreate. CFNumberRef test(unsigned char x) {; return CFNumberCreate(0, kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to initialize a 16 bit integer; }. osx.coreFoundation.CFRetainRelease; (C); Check for null arguments to CFRetain, CFRelease,; CFMakeCollectable. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }. void test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. osx.coreFoundation.containers.OutOfBounds; (C); Checks for index out-of-bounds when using CFArray API. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. osx.coreFoundation.containers.PointerSizedValues; (C); Warns if CFArray, CFDictionary, CFSet are; created with non-pointer-size values. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void **)x, 1,; &kCFTypeArrayCallBacks); // warn; }. Security Checkers. Name, DescriptionExample. security.FloatLoopCounter; (C); Warn on using a floating point value as a loop counter (CERT: FLP30-C,; FLP30-CPP). void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. security.insecureAPI.UncheckedReturn; (C); Warn on uses of functions whose return values must be always checked:; setuid; setgid; seteuid; setegid; setreuid; setregid. void te",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:20379,test,test,20379,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability,"{Coverage} 100.00%; [0x0000000056][004] {Location}; [0x0000000056][005] {Entry} Stack Offset: -20 (0xffffffffffffffec) [DW_OP_fbreg]; [0x000000008d][003] 4 {TypeAlias} 'INTEGER' -> [0x0000000099]'int'; [0x0000000000][003] 2 {Line} {NewStatement} '/test.cpp'; [0x0000000000][003] {Code} 'pushq	%rbp'; [0x0000000001][003] {Code} 'movq	%rsp, %rbp'; [0x0000000004][003] {Code} 'movb	%dl, %al'; [0x0000000006][003] {Code} 'movq	%rdi, -0x10(%rbp)'; [0x000000000a][003] {Code} 'movl	%esi, -0x14(%rbp)'; [0x000000000d][003] {Code} 'andb	$0x1, %al'; [0x000000000f][003] {Code} 'movb	%al, -0x15(%rbp)'; [0x0000000012][003] 3 {Line} {NewStatement} {PrologueEnd} '/test.cpp'; [0x0000000012][003] {Code} 'testb	$0x1, -0x15(%rbp)'; [0x0000000016][003] {Code} 'je	0x13'; [0x0000000032][003] 8 {Line} '/test.cpp'; [0x0000000032][003] {Code} 'movl	%eax, -0x4(%rbp)'; [0x0000000035][003] 9 {Line} {NewStatement} '/test.cpp'; [0x0000000035][003] {Code} 'movl	-0x4(%rbp), %eax'; [0x0000000038][003] {Code} 'popq	%rbp'; [0x0000000039][003] {Code} 'retq'; [0x000000003a][003] 9 {Line} {NewStatement} {EndSequence} '/test.cpp'. -----------------------------; Element Total Printed; -----------------------------; Scopes 3 3; Symbols 4 4; Types 5 5; Lines 25 25; -----------------------------; Total 37 37. Scope Sizes:; 189 (100.00%) : [0x000000000b][001] {CompileUnit} 'test.cpp'; 110 ( 58.20%) : [0x000000002a][002] 2 {Function} extern not_inlined 'foo' -> [0x0000000099]'int'; 27 ( 14.29%) : [0x0000000071][003] {Block}. Totals by lexical level:; [001]: 189 (100.00%); [002]: 110 ( 58.20%); [003]: 27 ( 14.29%). The **Scope Sizes** table shows the contribution in bytes to the debug; information by each scope, which can be used to determine unexpected; size changes in the DWARF sections between different versions of the; same toolchain. .. code-block:: none. [0x000000002a][002] 2 {Function} extern not_inlined 'foo' -> [0x0000000099]'int'; [0x000000002a][003] {Range} Lines 2:9 [0x0000000000:0x000000003a]; [0x000000",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:58262,test,test,58262,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['test'],['test']
Testability,"{array}; \right|$$. It describes a so-called active rotation, i.e. a rotation of objects; inside a static system of coordinates. In case you want to rotate the; frame and want to know the coordinates of objects in the rotated system,; you should apply the inverse rotation to the objects. If you want to; transform coordinates from the rotated frame to the original frame you; have to apply the direct transformation. A rotation around a specified; axis means counterclockwise rotation around the positive direction of; the axis. ### Declaration, Access, Comparisons. ``` {.cpp}; TRotation r; // r initialized as identity; TRotation m(r); // m = r; ```. There is no direct way to set the matrix elements - to ensure that a; **`TRotation`** always describes a real rotation. But you can get the; values by with the methods `XX()..ZZ()` or the `(,)` operator:. ``` {.cpp}; Double_t xx = r.XX(); // the same as xx=r(0,0); xx = r(0,0);; if (r==m) {...} // test for equality; if (r!=m) {..} // test for inequality; if (r.IsIdentity()) {...} // test for identity; ```. ### Rotation around Axes. The following matrices describe counter-clockwise rotations around the; coordinate axes and are implemented in: `RotateX()`,` RotateY()` and; `RotateZ()`:. $$; Rx(a) = \left|; \begin{array}{ccc}; 1 & 0 & 0 \\; 0 & cos(a) & -sin(a) \\; 0 & sin(a) & cos(a); \end{array}; \right|; Ry(a) = \left|; \begin{array}{ccc}; cos(a) & 0 & sin(a) \\; 0 & 1 & 0 \\; -sin(a) & 0 & cos(a); \end{array}; \right|; Rz(a) = \left|; \begin{array}{ccc}; cos(a) & -sin(a) & 0 \\; sin(a) & cos(a) & 0 \\; 0 & 0 & 1; \end{array}; \right|; $$. ``` {.cpp}; r.RotateX(TMath::Pi()); // rotation around the x-axis; ```. ### Rotation around Arbitrary Axis. The `Rotate()` method allows you to rotate around an arbitrary vector; (not necessary a unit one) and returns the result. ``` {.cpp}; r.Rotate(TMath::Pi()/3,TVector3(3,4,5));; ```. It is possible to find a unit vector and an angle, which describe the; same rotation as the current one:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:6739,test,test,6739,documentation/users-guide/PhysicsVectors.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md,1,['test'],['test']
Testability,"{}; // warn; }. void test(int i) {; if (i == 0 && i == 1) {}; // warn; }. void test(int i) {; if (i < 0 || i >= 0) {}; // warn; }. different.OpPrecedenceAssignCmp; (C, C++); Comparison operation has higher precedence then assignment. Boolean value is; assigned to a variable of other type. Parenthesis may bee required around an; assignment. int f();. void test(int x, int y) {; bool b;; if((b = x != y)) {} // ok; if((x = f() != y)) {} // warn; }. different.OpPrecedenceIifShift; (C, C++); ?: has lower precedence then <<.; Source: Stephen C. Dewhurst ""C++ Gotchas: Avoiding Common Problems in Coding; and Design"", advise 15. #include <iostream>. void test(int a) {; std::cout << a ? ""a"" : ""b""; // warn; }. void test(int a) {; a << a > 7 ? 1 : 2; // warn; }. different.ObjectUnused; (C++); The object was created but is not being used. struct S {; int x, y;; S(int xx, int yy) : x(xx), y(yy) {}; S(int xx) {; S(xx, 0); // warn; }; };. #include <exception>. void test() {; std::exception();; // warn (did you mean 'throw std::exception()'?); }. different.StaticArrayPtrCompare; (C); Pointer to static array is being compared to NULL. May the subscripting is; missing. void test() {; int a[1][1];; if (a[0] == 0) {}; // warn; }. different.ConversionToBool; (C, C++); Odd implicit conversion to boolean.; Note: possibly merge with ; alpha.core.BoolAssignment. bool test() {; return 1.; // warn; }. bool test() {; return """"; // warn; }. different.ArrayBound; (C++); Out-of-bound dynamic array access.; Note: possibly an enhancement to ; alpha.security.ArrayBoundV2. void test() {; int *p = new int[1];; int i = 1;; if(p[i]) {}; // warn; delete[] p;; }. different.StrcpyInputSize; (C); Buffer copy without checking the size of input.; Note: possibly an enhancement to ; alpha.unix.cstring.OutOfBounds. void test(char* string) {; char buf[24];; strcpy(buf, string); // warn; }. different.IntegerOverflow; (C); Integer overflow.; Note: partially handled by Clang core; (search for 'overflow in expression' w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:23608,test,test,23608,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability,"| Load Hardening | Mitigated Speedup |; | -------------------------------------- | -------: | -------------: | ----------------: |; | Google microbenchmark suite | -74.8% | -36.4% | **2.5x** |; | Large server QPS (using ThinLTO & PGO) | -62% | -29% | **1.8x** |. Below is a visualization of the microbenchmark suite results which helps show; the distribution of results that is somewhat lost in the summary. The y-axis is; a log-scale speedup ratio of load hardening relative to `lfence` (up -> faster; -> better). Each box-and-whiskers represents one microbenchmark which may have; many different metrics measured. The red line marks the median, the box marks; the first and third quartiles, and the whiskers mark the min and max. ![Microbenchmark result visualization](speculative_load_hardening_microbenchmarks.png). We don't yet have benchmark data on SPEC or the LLVM test suite, but we can; work on getting that. Still, the above should give a pretty clear; characterization of the performance, and specific benchmarks are unlikely to; reveal especially interesting properties. ### Future Work: Fine Grained Control and API-Integration. The performance overhead of this technique is likely to be very significant and; something users wish to control or reduce. There are interesting options here; that impact the implementation strategy used. One particularly appealing option is to allow both opt-in and opt-out of this; mitigation at reasonably fine granularity such as on a per-function basis,; including intelligent handling of inlining decisions -- protected code can be; prevented from inlining into unprotected code, and unprotected code will become; protected when inlined into protected code. For systems where only a limited; set of code is reachable by externally controlled inputs, it may be possible to; limit the scope of mitigation through such mechanisms without compromising the; application's overall security. The performance impact may also be focused in a; few key functions",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:48746,benchmark,benchmarks,48746,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['benchmark'],['benchmarks']
Testability,"| MB/s) | MB/s) | MB/s) | MB/s) |; | Split = 1 | | | | | |; +------------+--------+---------------+---------------+----------------+----------------+. The **Total Time** is the real time in seconds to run the program.; **Effective time** is the real time minus the time spent in non I/O; operations (essentially the random number generator). The program; `Event` generates in average 600 tracks per event. Each track has 17; data members. The read benchmark runs in the interactive version of; ROOT. The ‘Total Time to Read All' is the real time reported by the; execution of the script `&ROOTSYS/test/eventa`. We did not correct this time for the overhead coming from the; interpreter itself. The **Total time to read sample** is the execution; time of the script `$ROOTSYS/test/eventb`. This script loops on all; events. For each event, the branch containing the number of tracks is; read. In case the number of tracks is less than 585, the full event is; read in memory. This test is obviously not possible in non-split mode.; In non-split mode, the full event must be read in memory. The times; reported in the table correspond to complete I/O operations necessary to; deal with **machine independent binary files**. On **Linux**, this also; includes byte-swapping operations. The ROOT file allows for direct; access to any event in the file and direct access to any part of an; event when split=1. Note also that the uncompressed file generated with split=0 is 48.7; Mbytes and only 47.17 Mbytes for the option split=1. The difference in; size is due to the object identification mechanism overhead when the; event is written to a single buffer. This overhead does not exist in; split mode because the branch buffers are optimized for homogeneous data; types. You can run the test programs on your architecture. The program; `Event` will report the write performance. You can measure the read; performance by executing the scripts `eventa` and `eventb`. The; performance depends not only of the p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:139057,test,test,139057,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['test'],['test']
Testability,"| `Aclock.cxx` | Analog clock (a la X11 `xclock`) |; +-------------------+--------------------------------------------------------+; | `Tetris.cxx` | The known Tetris game based on the ROOT graphics |; +-------------------+--------------------------------------------------------+; | `stress.cxx` | Important ROOT stress testing program |; +-------------------+--------------------------------------------------------+; | `stress*.cxx` | Stress testing of different ROOT classes |; +-------------------+--------------------------------------------------------+; | `bench.cxx` | STL and ROOT container test and benchmarking program |; +-------------------+--------------------------------------------------------+; | QpRandomDriver.cx | Verification program for Quadratic programming classes |; | x | in Quadp library |; +-------------------+--------------------------------------------------------+; | DrawTest.sh | Entry script to extensive **`TTree`** query test suite |; +-------------------+--------------------------------------------------------+; | dt\_\* | Scripts used by DrawTest.sh |; +-------------------+--------------------------------------------------------+. The `$ROOTSYS/test` directory is a gold mine of root-wisdom nuggets, and; we encourage you to explore and exploit it. These instructions will; compile all programs in `$ROOTSYS/test`:. If you do not have write permission in the `$ROOTSYS/test` directory,; copy the entire `$ROOTSYS/test` directory to your area. The `Makefile`; is a useful example of how ROOT applications are linked and built. Edit; the `Makefile` to specify your architecture by changing the `ARCH`; variable, for example, on an SGI machine type:` ARCH` = `sgikcc`. Now compile all programs:. % **`gmake`**. This will build several applications and shared libraries. We are; especially interested in Event, stress, and `guitest`. ### Event - An Example of a ROOT Application. Event is created by compiling `MainEvent.cxx`, and `Event.cxx`. It; creates a RO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:5446,test,test,5446,documentation/users-guide/TutorialsandTests.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md,1,['test'],['test']
Testability,"|; | | the LLVM build. This can dramatically speed up |; | | debug builds. |; +-------------------------+----------------------------------------------------+. To configure LLVM, follow these steps:. #. Change directory into the object root directory:. .. code-block:: console. % cd OBJ_ROOT. #. Run the ``cmake``:. .. code-block:: console. % cmake -G ""Unix Makefiles"" -DCMAKE_BUILD_TYPE=<type> -DCMAKE_INSTALL_PREFIX=/install/path; [other options] SRC_ROOT. Compiling the LLVM Suite Source Code; ------------------------------------. Unlike with autotools, with CMake your build type is defined at configuration.; If you want to change your build type, you can re-run cmake with the following; invocation:. .. code-block:: console. % cmake -G ""Unix Makefiles"" -DCMAKE_BUILD_TYPE=<type> SRC_ROOT. Between runs, CMake preserves the values set for all options. CMake has the; following build types defined:. Debug. These builds are the default. The build system will compile the tools and; libraries unoptimized, with debugging information, and asserts enabled. Release. For these builds, the build system will compile the tools and libraries; with optimizations enabled and not generate debug info. CMakes default; optimization level is -O3. This can be configured by setting the; ``CMAKE_CXX_FLAGS_RELEASE`` variable on the CMake command line. RelWithDebInfo. These builds are useful when debugging. They generate optimized binaries with; debug information. CMakes default optimization level is -O2. This can be; configured by setting the ``CMAKE_CXX_FLAGS_RELWITHDEBINFO`` variable on the; CMake command line. Once you have LLVM configured, you can build it by entering the *OBJ_ROOT*; directory and issuing the following command:. .. code-block:: console. % make. If the build fails, please `check here`_ to see if you are using a version of; GCC that is known not to compile LLVM. If you have multiple processors in your machine, you may wish to use some of the; parallel build options provided by ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:29006,assert,asserts,29006,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['assert'],['asserts']
Testability,"} 'pr-46466.cpp'; [002] {Producer} 'clang version 14.0.0'; [002] 8 {Variable} extern 'S' -> 'Struct'; [002] 1 {Struct} 'Struct'; [003] 5 {Member} public 'U' -> 'Union'. DWARF - GCC (Linux); ^^^^^^^^^^^^^^^^^^^. .. code-block:: none. Logical View:; [000] {File} 'pr-46466-dwarf-gcc.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-46466.cpp'; [002] {Producer} 'GNU C++14 9.3.0'; [002] 8 {Variable} extern 'S' -> 'Struct'; [002] 1 {Struct} 'Struct'; [003] 5 {Member} public 'U' -> 'Union'; [003] 2 {Union} 'Union'; [004] 3 {Enumeration} 'NestedEnum' -> 'unsigned int'; [005] {Enumerator} 'BLUE' = '0x1'; [005] {Enumerator} 'RED' = '0x0'. From the previous logical views, we can see that the DWARF debug; information generated by the Clang compiler does not include any; references to the enumerators **RED** and **BLUE**. The DWARF; generated by GCC, CodeView generated by Clang and MSVC, they do; include such references. Using the :program:`llvm-debuginfo-analyzer` selection facilities, we; can produce a logical view showing just the logical types that are; **Enumerator** and its parents. The logical view is sorted by the types; name. .. code-block:: none. llvm-debuginfo-analyzer --attribute=format,level; --output-sort=name; --select-types=Enumerator; --report=parents; --print=types; pr-46466-*.o. .. code-block:: none. Logical View:; [000] {File} 'pr-46466-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr-46466.cpp'; [002] 1 {Struct} 'Struct'; [003] 2 {Union} 'Union'; [004] 3 {Enumeration} 'NestedEnum' -> 'int'; [005] {Enumerator} 'BLUE' = '0x1'; [005] {Enumerator} 'RED' = '0x0'. Logical View:; [000] {File} 'pr-46466-codeview-msvc.o' -> COFF-i386. [001] {CompileUnit} 'pr-46466.cpp'; [002] 1 {Struct} 'Struct'; [003] 2 {Union} 'Union'; [004] 3 {Enumeration} 'NestedEnum' -> 'int'; [005] {Enumerator} 'BLUE' = '0x1'; [005] {Enumerator} 'RED' = '0x0'. Logical View:; [000] {File} 'pr-46466-dwarf-clang.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-46466.cpp'. Logical View:; [000] {File} ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:45248,log,logical,45248,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,2,['log'],['logical']
Testability,"} values to boolean variables. void test() {; BOOL b = -1; // warn; }. alpha.core.CallAndMessageUnInitRefArg; (C, C++); Check for uninitialized arguments in function calls and Objective-C; message expressions. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. alpha.core.CastSize; (C); Check when casting a malloc'ed type T, whether the size is a multiple of the; size of T (Works only with unix.Malloc; or alpha.unix.MallocWithAnnotations; checks enabled). void test() {; int *x = (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. alpha.core.DynamicTypeChecker; (ObjC); Check for cases where the dynamic and the static type of an; object are unrelated. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. alpha.core.FixedAddr; (C); Check for assignment of a fixed address to a pointer. void test() {; int *p;; p = (int *) 0x10000; // warn; }. alpha.core.IdenticalExpr; (C, C++); Warn about suspicious uses of identical expressions. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) {; int i = 10;; if (f()) { // warn: true and false branches are identical; do {; i--;; } while (f());; } else {; do {; i--;; } while (f());; }; }. alpha.core.PointerArithm; (C); Che",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:1920,test,test,1920,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['test'],['test']
Testability,}). SET(DNN_CUDA_LIBRARIES ${CUDA_CUBLAS_LIBRARIES} ). list(APPEND Libraries ${DNN_CUDA_LIBRARIES} CUDA::cuda_driver CUDA::cudart). # DNN - Activation Functions Cuda; add_executable(testActivationFunctionsCuda TestActivationFunctionsCuda.cxx); TARGET_LINK_LIBRARIES(testActivationFunctionsCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-ActivationFunctionsCuda COMMAND testActivationFunctionsCuda). # DNN - Loss Functions Cuda; add_executable(testLossFunctionsCuda TestLossFunctionsCuda.cxx); TARGET_LINK_LIBRARIES(testLossFunctionsCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-LossFunctionsCuda COMMAND testLossFunctionsCuda). # DNN - Derivatives Cuda; add_executable(testDerivativesCuda TestDerivativesCuda.cxx); TARGET_LINK_LIBRARIES(testDerivativesCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-DerivativesCuda COMMAND testDerivativesCuda). # DNN - Backpropagation Cuda; add_executable(testBackpropagationCuda TestBackpropagationCuda.cxx); TARGET_LINK_LIBRARIES(testBackpropagationCuda ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-BackpropagationCuda COMMAND testBackpropagationCuda). # DNN - Backpropagation DL Cuda; add_executable(testBackpropagationDLCuda TestBackpropagationDLCuda.cxx ); TARGET_LINK_LIBRARIES(testBackpropagationDLCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-Backpropagation-DLCuda COMMAND testBackpropagationDLCuda). # DNN - Batch normalization Cuda; add_executable(testBatchNormalizationCuda TestBatchNormalizationCuda.cxx ); TARGET_LINK_LIBRARIES(testBatchNormalizationCuda ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-BatchNormalization-Cuda COMMAND testBatchNormalizationCuda). # DNN - Minimization Cuda; add_executable(testMinimizationCuda TestMinimizationCuda.cxx); TARGET_LINK_LIBRARIES(testMinimizationCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-MinimizationCuda COMMAND testMinimizationCuda). # DNN - Arithmetic Cuda; add_executable(testArithmeticCuda TestMatrixArithmeticCuda.cxx); TARGET_LINK_LIBRARIES(testArithmeticCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-ArithmeticCuda COMMAND test,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CMakeLists.txt:1511,test,testBackpropagationCuda,1511,tmva/tmva/test/DNN/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CMakeLists.txt,2,['test'],['testBackpropagationCuda']
Testability,"}. For symmetry reasons, ``ident.ll`` is just a dummy file that doesn't; actually participate in the test besides holding the ``RUN:`` lines. .. note::. Some existing tests use ``RUN: true`` in extra files instead of just; putting the extra files in an ``Inputs/`` directory. This pattern is; deprecated. Fragile tests; -------------. It is easy to write a fragile test that would fail spuriously if the tool being; tested outputs a full path to the input file. For example, :program:`opt` by; default outputs a ``ModuleID``:. .. code-block:: console. $ cat example.ll; define i32 @main() nounwind {; ret i32 0; }. $ opt -S /path/to/example.ll; ; ModuleID = '/path/to/example.ll'. define i32 @main() nounwind {; ret i32 0; }. ``ModuleID`` can unexpectedly match against ``CHECK`` lines. For example:. .. code-block:: llvm. ; RUN: opt -S %s | FileCheck. define i32 @main() nounwind {; ; CHECK-NOT: load; ret i32 0; }. This test will fail if placed into a ``download`` directory. To make your tests robust, always use ``opt ... < %s`` in the RUN line.; :program:`opt` does not output a ``ModuleID`` when input comes from stdin. Platform-Specific Tests; -----------------------. Whenever adding tests that require the knowledge of a specific platform,; either related to code generated, specific output or back-end features,; you must make sure to isolate the features, so that buildbots that; run on different architectures (and don't even compile all back-ends),; don't fail. The first problem is to check for target-specific output, for example sizes; of structures, paths and architecture names, for example:. * Tests containing Windows paths will fail on Linux and vice-versa.; * Tests that check for ``x86_64`` somewhere in the text will fail anywhere else.; * Tests where the debug information calculates the size of types and structures. Also, if the test rely on any behaviour that is coded in any back-end, it must; go in its own directory. So, for instance, code generator tests for ARM go; i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:17093,test,tests,17093,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['tests']
Testability,"}/$<CONFIG>/libElementStructDict_rdict.pcm); endif(); target_include_directories(testTOffsetGeneration PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}); ROOT_STANDARD_LIBRARY_PACKAGE(SillyStruct NO_INSTALL_HEADERS HEADERS ${CMAKE_CURRENT_SOURCE_DIR}/SillyStruct.h SOURCES SillyStruct.cxx LINKDEF SillyStructLinkDef.h DEPENDENCIES RIO); ROOT_ADD_GTEST(testBulkApi BulkApi.cxx LIBRARIES RIO Tree TreePlayer); #FIXME: tests are having timeout on 32bit CERN VM (in docker container everything is fine),; # to be reverted after investigation.; if(NOT CMAKE_SIZEOF_VOID_P EQUAL 4); ROOT_ADD_GTEST(testBulkApiMultiple BulkApiMultiple.cxx LIBRARIES RIO Tree TreePlayer TIMEOUT 3000); ROOT_ADD_GTEST(testBulkApiVarLength BulkApiVarLength.cxx LIBRARIES RIO Tree TreePlayer); ROOT_ADD_GTEST(testBulkApiSillyStruct BulkApiSillyStruct.cxx LIBRARIES RIO Tree TreePlayer SillyStruct); endif(); ROOT_ADD_GTEST(testTBasket TBasket.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(testTBranch TBranch.cxx LIBRARIES RIO Tree MathCore); ROOT_ADD_GTEST(testTIOFeatures TIOFeatures.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(testTTreeCluster TTreeClusterTest.cxx LIBRARIES RIO Tree MathCore); ROOT_ADD_GTEST(testTChainParsing TChainParsing.cxx LIBRARIES RIO Tree); if(imt); ROOT_ADD_GTEST(testTTreeImplicitMT ImplicitMT.cxx LIBRARIES RIO Tree); endif(); ROOT_ADD_GTEST(testTChainSaveAsCxx TChainSaveAsCxx.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(testTChainRegressions TChainRegressions.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(testTTreeTruncatedDatatypes TTreeTruncatedDatatypes.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(testTTreeRegressions TTreeRegressions.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(entrylist_addsublist entrylist_addsublist.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(chain_setentrylist chain_setentrylist.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(entrylist_enter entrylist_enter.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(entrylist_enterrange entrylist_enterrange.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(friendinfo friendinfo.cxx LIBRARIES RI",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/CMakeLists.txt:1684,test,testTIOFeatures,1684,tree/tree/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/CMakeLists.txt,1,['test'],['testTIOFeatures']
Testability,"}; TVirtualViewer3D * v = gPad->GetViewer3D(""type"");; ```. Here the ""type"" string defines the viewer type - currently one of:. - ""`ogl`"" : External GL viewer. - ""`x3d`"": External X3D viewer. - ""`pad`"": Pad viewer. If no type is passed (null string), and there is no current viewer, then; the type is defaulted to ""`pad`"". If no type is passed and there is a; current viewer, then this is returned - hence once a viewer is created; it can be obtained elsewhere by:. ``` {.cpp}; TVirtualViewer3D * v = gPad->GetViewer3D();; ```. #### Opening / Closing Scenes. Objects must be added to viewer between `BeginScene()` and `EndScene()`; calls e.g. ``` {.cpp}; viewer->BeginScene();; // Add objects; viewer ->EndScene();; ```. These calls enable the viewer to suspend redraws, and perform internal; caching/setup. If the object you attach to the pad derives from; **`TAtt3D`**, then the pad will take responsibility for calling; `BeginScene()` and `EndScene()` for you. You can always test if the; scene is already open for object addition with:. ``` {.cpp}; viewer->BuildingScene();; ```. ![Overview of 3D viewer architecture](pictures/030000DF.png). Note: the x3d viewer does not support rebuilding of scenes - objects; added after the first Open/Close Scene pair will be ignored. #### Describing Objects - Filling TBuffer3D. The viewers behind the **`TVirtualViewer3D`** interface differ greatly; in their capabilities e.g. - Some support native shape (e.g. spheres/tubes in OpenGL) and can; draw these based on an abstract description. Others always require a; tessellation description based on **`TBuffer3D`**'s `kRaw` /; `kRawSizes` points/lines/segments sections. - Some need the 3D object positions in the master (world) frame,; others can cope with local frames and a translation matrix to place; the object. - Some require bounding boxes for objects - others do not. Similarly some viewer clients are only capable of providing positions in; master frame, cannot provide bounding boxes etc. Addition",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:125906,test,test,125906,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['test'],['test']
Testability,"}}. Trigger elements; ================. These elements cause an external action and will be presented to the user in a; human readable form. Generally they trigger an external action to occur that; results in a linkable page. The link or some other informative information about; the external action can then be presented to the user. ``{{{dumpfile:%s:%s}}}`` [#not_yet_implemented]_. Here the first ``%s`` is an identifier for a type of dump and the second; ``%s`` is an identifier for a particular dump that's just been published. The; types of dumps, the exact meaning of ""published"", and the nature of the; identifier are outside the scope of the markup format per se. In general it; might correspond to writing a file by that name or something similar. This element may trigger additional post-processing work beyond symbolizing; the markup. It indicates that a dump file of some sort has been published.; Some logic attached to the symbolizing filter may understand certain types of; dump file and trigger additional post-processing of the dump file upon; encountering this element (e.g. generating visualizations, symbolization). The; expectation is that the information collected from contextual elements; (described below) in the logging stream may be necessary to decode the content; of the dump. So if the symbolizing filter triggers other processing, it may; need to feed some distilled form of the contextual information to those; processes. An example of a type identifier is ``sancov``, for dumps from LLVM; `SanitizerCoverage <https://clang.llvm.org/docs/SanitizerCoverage.html>`_. Example::. {{{dumpfile:sancov:sancov.8675}}}. Contextual elements; ===================. These are elements that supply information necessary to convert presentation; elements to symbolic form. Unlike presentation elements, they are not directly; related to the surrounding text. Contextual elements should appear alone on; lines with no other non-whitespace text, so that the symbolizing filter might; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:16216,log,logic,16216,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,1,['log'],['logic']
Testability,"~~~~~~~~~~~~~~~~~~~~~~~~; The below example is used to show different output generated by; :program:`llvm-debuginfo-analyzer`. We compiled the example for an X86; ELF target with Clang (-O0 -g):. .. code-block:: c++. 1 using INTPTR = const int *;; 2 int foo(INTPTR ParamPtr, unsigned ParamUnsigned, bool ParamBool) {; 3 if (ParamBool) {; 4 typedef int INTEGER;; 5 const INTEGER CONSTANT = 7;; 6 return CONSTANT;; 7 }; 8 return ParamUnsigned;; 9 }. PRINTING MODE; ^^^^^^^^^^^^^; In this mode :program:`llvm-debuginfo-analyzer` prints the *logical view*; or portions of it, based on criteria patterns (including regular; expressions) to select the kind of *logical elements* to be included in; the output. BASIC DETAILS; """"""""""""""""""""""""""; The following command prints basic details for all the logical elements; sorted by the debug information internal offset; it includes its lexical; level and debug info format. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level,format; --output-sort=offset; --print=scopes,symbols,types,lines,instructions; test-dwarf-clang.o. or. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level,format; --output-sort=offset; --print=elements; test-dwarf-clang.o. Each row represents an element that is present within the debug; information. The first column represents the scope level, followed by; the associated line number (if any), and finally the description of; the element. .. code-block:: none. Logical View:; [000] {File} 'test-dwarf-clang.o' -> elf64-x86-64. [001] {CompileUnit} 'test.cpp'; [002] 2 {Function} extern not_inlined 'foo' -> 'int'; [003] 2 {Parameter} 'ParamPtr' -> 'INTPTR'; [003] 2 {Parameter} 'ParamUnsigned' -> 'unsigned int'; [003] 2 {Parameter} 'ParamBool' -> 'bool'; [003] {Block}; [004] 5 {Variable} 'CONSTANT' -> 'const INTEGER'; [004] 5 {Line}; [004] {Code} 'movl	$0x7, -0x1c(%rbp)'; [004] 6 {Line}; [004] {Code} 'movl	$0x7, -0x4(%rbp)'; [004] {Code} 'jmp	0x6'; [004] 8 {Line}; [004] {Code} 'movl	-0x14(%rbp), %eax'; [003]",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:24916,test,test-dwarf-clang,24916,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['test'],['test-dwarf-clang']
Usability," %done = call i1 @llvm.coro.done(ptr %hdl); br i1 %done, label %end, label %while; end:; call void @llvm.coro.destroy(ptr %hdl); ret i32 0; }. Usually, final suspend point is a frontend injected suspend point that does not; correspond to any explicitly authored suspend point of the high level language.; For example, for a Python generator that has only one suspend point:. .. code-block:: python. def coroutine(n):; for i in range(n):; yield i. Python frontend would inject two more suspend points, so that the actual code; looks like this:. .. code-block:: c. void* coroutine(int n) {; int current_value;; <designate current_value to be coroutine promise>; <SUSPEND> // injected suspend point, so that the coroutine starts suspended; for (int i = 0; i < n; ++i) {; current_value = i; <SUSPEND>; // corresponds to ""yield i""; }; <SUSPEND final=true> // injected final suspend point; }. and python iterator `__next__` would look like:. .. code-block:: c++. int __next__(void* hdl) {; coro.resume(hdl);; if (coro.done(hdl)) throw StopIteration();; return *(int*)coro.promise(hdl, 4, false);; }. Intrinsics; ==========. Coroutine Manipulation Intrinsics; ---------------------------------. Intrinsics described in this section are used to manipulate an existing; coroutine. They can be used in any function which happen to have a pointer; to a `coroutine frame`_ or a pointer to a `coroutine promise`_. .. _coro.destroy:. 'llvm.coro.destroy' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.coro.destroy(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.destroy``' intrinsic destroys a suspended; switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a coroutine handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.destroy` intrinsic is replaced with a direct call to; the coroutine destroy function. Otherwise it is replaced with an indirect call; based on the function pointer for the destroy function store",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:26593,resume,resume,26593,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability," %subtmp5); %addtmp = fadd double %calltmp, %calltmp6; br label %ifcont. ifcont: ; preds = %else, %then; %iftmp = phi double [ 1.000000e+00, %then ], [ %addtmp, %else ]; ret double %iftmp; }. This is a trivial case for mem2reg, since there are no redefinitions of; the variable. The point of showing this is to calm your tension about; inserting such blatant inefficiencies :). After the rest of the optimizers run, we get:. .. code-block:: llvm. define double @fib(double %x) {; entry:; %cmptmp = fcmp ult double %x, 3.000000e+00; %booltmp = uitofp i1 %cmptmp to double; %ifcond = fcmp ueq double %booltmp, 0.000000e+00; br i1 %ifcond, label %else, label %ifcont. else:; %subtmp = fsub double %x, 1.000000e+00; %calltmp = call double @fib(double %subtmp); %subtmp5 = fsub double %x, 2.000000e+00; %calltmp6 = call double @fib(double %subtmp5); %addtmp = fadd double %calltmp, %calltmp6; ret double %addtmp. ifcont:; ret double 1.000000e+00; }. Here we see that the simplifycfg pass decided to clone the return; instruction into the end of the 'else' block. This allowed it to; eliminate some branches and the PHI node. Now that all symbol table references are updated to use stack variables,; we'll add the assignment operator. New Assignment Operator; =======================. With our current framework, adding a new assignment operator is really; simple. We will parse it just like any other binary operator, but handle; it internally (instead of allowing the user to define it). The first; step is to set a precedence:. .. code-block:: c++. int main() {; // Install standard binary operators.; // 1 is lowest precedence.; BinopPrecedence['='] = 2;; BinopPrecedence['<'] = 10;; BinopPrecedence['+'] = 20;; BinopPrecedence['-'] = 20;. Now that the parser knows the precedence of the binary operator, it; takes care of all the parsing and AST generation. We just need to; implement codegen for the assignment operator. This looks like:. .. code-block:: c++. Value *BinaryExprAST::codegen() {; // Spe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:19809,simpl,simplifycfg,19809,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['simpl'],['simplifycfg']
Usability," %xmm0, %xmm0; ret. //===---------------------------------------------------------------------===//. Here's a sick and twisted idea. Consider code like this:. __m128 test(__m128 a) {; float b = *(float*)&A;; ...; return _mm_set_ps(0.0, 0.0, 0.0, b);; }. This might compile to this code:. movaps c(%esp), %xmm1; xorps %xmm0, %xmm0; movss %xmm1, %xmm0; ret. Now consider if the ... code caused xmm1 to get spilled. This might produce; this code:. movaps c(%esp), %xmm1; movaps %xmm1, c2(%esp); ... xorps %xmm0, %xmm0; movaps c2(%esp), %xmm1; movss %xmm1, %xmm0; ret. However, since the reload is only used by these instructions, we could ; ""fold"" it into the uses, producing something like this:. movaps c(%esp), %xmm1; movaps %xmm1, c2(%esp); ... movss c2(%esp), %xmm0; ret. ... saving two instructions. The basic idea is that a reload from a spill slot, can, if only one 4-byte ; chunk is used, bring in 3 zeros the one element instead of 4 elements.; This can be used to simplify a variety of shuffle operations, where the; elements are fixed zeros. //===---------------------------------------------------------------------===//. This code generates ugly code, probably due to costs being off or something:. define void @test(float* %P, <4 x float>* %P2 ) {; %xFloat0.688 = load float* %P; %tmp = load <4 x float>* %P2; %inFloat3.713 = insertelement <4 x float> %tmp, float 0.0, i32 3; store <4 x float> %inFloat3.713, <4 x float>* %P2; ret void; }. Generates:. _test:; 	movl	8(%esp), %eax; 	movaps	(%eax), %xmm0; 	pxor	%xmm1, %xmm1; 	movaps	%xmm0, %xmm2; 	shufps	$50, %xmm1, %xmm2; 	shufps	$132, %xmm2, %xmm0; 	movaps	%xmm0, (%eax); 	ret. Would it be better to generate:. _test:; movl 8(%esp), %ecx; movaps (%ecx), %xmm0; 	xor %eax, %eax; pinsrw $6, %eax, %xmm0; pinsrw $7, %eax, %xmm0; movaps %xmm0, (%ecx); ret. ?. //===---------------------------------------------------------------------===//. Some useful information in the Apple Altivec / SSE Migration Guide:. http://developer.apple.com/doc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt:8000,simpl,simplify,8000,interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,1,['simpl'],['simplify']
Usability," (normally a C++; include file or a textual list of warnings, options, and error messages). TableGen is used by both LLVM, Clang, and MLIR with very different goals.; LLVM uses it as a way to automate the generation of massive amounts of; information regarding instructions, schedules, cores, and architecture; features. Some backends generate output that is consumed by more than one; source file, so they need to be created in a way that makes it is easy for; preprocessor tricks to be used. Some backends can also print C++ code; structures, so that they can be directly included as-is. Clang, on the other hand, uses it mainly for diagnostic messages (errors,; warnings, tips) and attributes, so more on the textual end of the scale. MLIR uses TableGen to define operations, operation dialects, and operation; traits. See the :doc:`TableGen Programmer's Reference <./ProgRef>` for an in-depth; description of TableGen, and the :doc:`TableGen Backend Developer's Guide; <./BackGuide>` for a guide to writing a new backend. LLVM BackEnds; =============. .. warning::; This portion is incomplete. Each section below needs three subsections:; description of its purpose with a list of users, output generated from; generic input, and finally why it needed a new backend (in case there's; something similar). Overall, each backend will take the same TableGen file type and transform into; similar output for different targets/uses. There is an implicit contract between; the TableGen files, the back-ends and their users. For instance, a global contract is that each back-end produces macro-guarded; sections. Based on whether the file is included by a header or a source file,; or even in which context of each file the include is being used, you have; todefine a macro just before including it, to get the right output:. .. code-block:: c++. #define GET_REGINFO_TARGET_DESC; #include ""ARMGenRegisterInfo.inc"". And just part of the generated file would be included. This is useful if; you need the sa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst:1383,guid,guide,1383,interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,1,['guid'],['guide']
Usability," *point[3]);; ```. ### Initializing the Direction. In order to move inside geometry starting with the current point, the; modeller needs to know the current direction `(nx,ny,nz)`. This; direction is stored as `Double_t fCurrentDirection[3]` by the navigator; and it represents a direction in the global frame. It can be retrieved; with:. ``` {.cpp}; Const Double_t *cdir = gGeoManager->GetCurrentDirection();; ```. The direction can be initialized in a similar manner as the current; point:. ``` {.cpp}; gGeoManager->SetCurrentDirection(nx,ny,nz);; // or:; gGeoManager->SetCurrentDirection(Double_t *dir);; ```. ### Initializing the State. Setting the initial point and direction is not enough for initializing; tracking. The modeller needs to find out where the initial point is; located in the geometrical hierarchy. Due to the containment based; architecture of the model, this is the deepest positioned object; containing the point. For illustrating this, imagine that we have a; simple structure with a top volume `A` and another one `B `positioned; inside. Since `A `is a top volume, its associated node `A_1` will define; `MARS` and our simple hierarchy of nodes (positioned volumes) will be:; `/A_1/B_1`. Suppose now that the initial point is contained by `B_1`.; This implies by default that the point is also contained by `A_1`, since; `B_1` have to be fully contained by this. After searching the point; location, the modeller will consider that the point is located inside; `B_1`, which will be considered as the representative object (node) for; the current state. This is stored as: **`TGeoNode`**; \*`TGeoManager::fCurrentNode `and can be asked from the manager class; only after the `'Where am I?'` was completed:. ``` {.cpp}; TGeoNode *current = gGeoManager->GetCurrentNode();; ```. In order to find the location of the current point inside the hierarchy; of nodes, after setting this point it is mandatory to call the; `‘Where am I?'` method:. ``` {.cpp}; gGeoManager->FindNode();;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:105461,simpl,simple,105461,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability," *‘No drawing'* sets On/Off the option ""`0`""- do not draw the fit; results. *‘Do not store/draw'* sets On/Off option ""`N`""- do not store the; function and do not draw it. ### Advances Options. The advance option button is enabled only after having performed the fit and provides; additional drawing options that can be used after having done the fit. These new drawing tools,; which can be selected by the ""Advanced Drawing Tool"" panel that pops up when clicking the ""Advanced"" button, are:. * *Contour*: to plot the confidence contour of two chosen parameters. One can select the number of points to draw the contour; (more points might require more time to compute it), the parameters and the desired confidence level . * *Scan* : to plot a scan of the minimization function (likelihood or chi-squared) around the minimum as function of the chosen parameter. * *Conf Interval* : to plot the confidence interval of the fitted function as a filled coloured band around its central value.; One can select the desired confidence level for the band to be plotted. ### Print Options. This set of options specifies the amount of feedback printed on the; root command line after performed fits. *‘Verbose'* - prints fit results after each iteration. *‘Quiet'* - no fit information is printed. *‘Default'* - between Verbose and Quiet. ### Command Buttons. *Fit button* - performs a fit taking different option settings via the; Fit Panel interface. *Reset* - sets the GUI elements and related fit settings to the; default ones. *Close* - closes the Fit panel window. ### Minimization Options. With this tab one can select specific options for minimization. These include. * The minimizer library ( *Minuit*, *Minuit2*, *Fumili*, *GSL*, *Genetics* ); * The method (algorithm) for minimization. For example for Minuit one can choose between (*Migrad*, *Simplex* or *Scan*); * Error definition; * Minimization tolerance; * Number of iterations/function calls; * Print Level: (*Default*, *Verbose* or *Quiet*). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/doc/index.md:5387,feedback,feedback,5387,gui/fitpanel/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/doc/index.md,1,['feedback'],['feedback']
Usability," - context menu for axes in 3D drawings. ## Changes in 5.8.1; 1. Fix - use Math.floor when search for bin label; 2. Fix - renable correct highlight of TGraphErrors; 3. Fix - adjust TH1/TH2/TAxis values to let stream them in ROOT; 4. Fix - adjust TH[1,2,3].Fill() method to update entries count. ## Changes in 5.8.0; 1. Many TGeo-related changes:; - use TGeoManager::fVisLevel in geometry painter; - ""showtop"" draw option for TGeoManager (equivalent to gGeoManager->SetTopVisible()); - ""no_screen"" draw option to let ignore kVisOnScreen bits for display, checked first by default; - radial and z-axis interactive transformation for TGeo drawings; - improve ""comp"" and ""compx"" option to show TGeoCompositeShape components; - support of TGeo objects embed in TCanvas; - monitoring of TGeoManager with THttpServer; - ""rotyNN"" and ""rotzNN"" options to TGeo painter - let customize camera position; - context menu command to show current camera position; 2. New and simpler TArrow drawing without use of svg markers, interactive movement of TArrow class; 3. Support different marker styles in 3D drawings; 4. Support ""texte"" and ""texte0"" draw options for TH2/TProfile2D classes; 5. Provide wrong_http_response workaround (#189); 6. Update objects from list of histogram functions (#190). ## Changes in 5.7.2; 1. Fix - add missing factor in TGeoPgon shape; 2. Fix - correctly handle ""sync"" specifier in JSROOT.NewHttpRequest; 3. Fix - verify that TH1/TH2 superimposing in 3D works properly; 4. Fix - use provided options in JSROOT.redraw function; 5. Fix - arb8 shape, used in composite. ## Changes in 5.7.1; 1. Fix - cover for WebVR API inconsistencies in Android devices (#184); 2. Fix - add more checks in TF1 GetParName/GetParValue methods (#185); 3. Fix - bins highlight in lego drawing with ""zero"" option; 4. Fix - drawing tracks with geometry from TObjArray; 5. Fix - interactive TGraph point move on time scale; 6. Fix - arb8 shapes faces building. ## Changes in 5.7.0; 1. Add support of TProfile2Pol",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:28842,simpl,simpler,28842,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['simpl'],['simpler']
Usability," -----------------------------------------. Once a patch is reviewed, you can select the ""Squash and merge"" button in the; GitHub web interface. You might need to rebase your change before pushing; it to the repo. LLVM currently has a linear-history policy, which means that merge commits are; not allowed. The `llvm-project` repo on github is configured to reject pushes; that include merges, so the `git rebase` step above is required. Please ask for help if you're having trouble with your particular git workflow. .. _git_pre_push_hook:. Git pre-push hook; ^^^^^^^^^^^^^^^^^. We include an optional pre-push hook that run some sanity checks on the revisions; you are about to push and ask confirmation if you push multiple commits at once.; You can set it up (on Unix systems) by running from the repository root:. .. code-block:: console. % ln -sf ../../llvm/utils/git/pre-push.py .git/hooks/pre-push. Helpful Information About LLVM; ==============================; :doc:`LLVM's documentation <index>` provides a wealth of information about LLVM's internals as; well as various user guides. The pages listed below should provide a good overview; of LLVM's high-level design, as well as its internals:. :doc:`GettingStarted`; Discusses how to get up and running quickly with the LLVM infrastructure.; Everything from unpacking and compilation of the distribution to execution; of some tools. :doc:`LangRef`; Defines the LLVM intermediate representation. :doc:`ProgrammersManual`; Introduction to the general layout of the LLVM sourcebase, important classes; and APIs, and some tips & tricks. `LLVM for Grad Students`__; This is an introduction to the LLVM infrastructure by Adrian Sampson. While it; has been written for grad students, it provides a good, compact overview of; LLVM's architecture, LLVM's IR and how to write a new pass. .. __: http://www.cs.cornell.edu/~asampson/blog/llvm.html. `Intro to LLVM`__; Book chapter providing a compiler hacker's introduction to LLVM. .. __: http://www",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst:6454,guid,guides,6454,interpreter/llvm-project/llvm/docs/Contributing.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst,1,['guid'],['guides']
Usability," ------; * `C-SKY Architecture User Guide <https://github.com/c-sky/csky-doc/blob/master/CSKY%20Architecture%20user_guide.pdf>`_; * `C-SKY V2 ABI <https://github.com/c-sky/csky-doc/blob/master/C-SKY_V2_CPU_Applications_Binary_Interface_Standards_Manual.pdf>`_. LoongArch; ---------; * `LoongArch Reference Manual - Volume 1: Basic Architecture <https://loongson.github.io/LoongArch-Documentation/LoongArch-Vol1-EN.html>`_; * `LoongArch ELF ABI specification <https://loongson.github.io/LoongArch-Documentation/LoongArch-ELF-ABI-EN.html>`_. SPARC; -----. * `SPARC standards <http://sparc.org/standards>`_; * `SPARC V9 ABI <http://sparc.org/standards/64.psabi.1.35.ps.Z>`_; * `SPARC V8 ABI <http://sparc.org/standards/psABI3rd.pdf>`_. SystemZ; -------. * `z/Architecture Principles of Operation (registration required, free sign-up) <http://www-01.ibm.com/support/docview.wss?uid=isg2b9de5f05a9d57819852571c500428f9a>`_. VE; --. * `NEC SX-Aurora TSUBASA ISA Guide <https://www.hpc.nec/documents/guide/pdfs/Aurora_ISA_guide.pdf>`_; * `NEC SX-Aurora TSUBASA manuals and documentation <https://www.hpc.nec/documentation>`_. X86; ---. * `AMD processor manuals <http://developer.amd.com/resources/developer-guides-manuals/>`_; * `Intel 64 and IA-32 manuals <http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html>`_; * `Intel Itanium documentation <http://www.intel.com/design/itanium/documentation.htm?iid=ipp_srvr_proc_itanium2+techdocs>`_; * `X86 and X86-64 SysV psABI <https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI>`_; * `Calling conventions for different C++ compilers and operating systems <http://www.agner.org/optimize/calling_conventions.pdf>`_. XCore; -----. * `The XMOS XS1 Architecture (ISA) <https://www.xmos.ai/download/The-XMOS-XS1-Architecture%281.0%29.pdf>`_; * `The XMOS XS2 Architecture (ISA) <https://www.xmos.ai/download/xCORE-200:-The-XMOS-XS2-Architecture-%28ISA%29%281.1%29.pdf>`_; * `Tools Development Guide (includes ABI) <https://w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst:5665,guid,guide,5665,interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst,1,['guid'],['guide']
Usability," ... *not allowed* to add or remove SCC's from the current Module, though; they may change the contents of an SCC.; #. ... *allowed* to add or remove global variables from the current Module.; #. ... *allowed* to maintain state across invocations of :ref:`runOnSCC; <writing-an-llvm-pass-runOnSCC>` (including global data). Implementing a ``CallGraphSCCPass`` is slightly tricky in some cases because it; has to handle SCCs with more than one node in it. All of the virtual methods; described below should return ``true`` if they modified the program, or; ``false`` if they didn't. The ``doInitialization(CallGraph &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(CallGraph &CG);. The ``doInitialization`` method is allowed to do most of the things that; ``CallGraphSCCPass``\ es are not allowed to do. They can add and remove; functions, get pointers to functions, etc. The ``doInitialization`` method is; designed to do simple initialization type of stuff that does not depend on the; SCCs being processed. The ``doInitialization`` method call is not scheduled to; overlap with any other pass executions (thus it should be very fast). .. _writing-an-llvm-pass-runOnSCC:. The ``runOnSCC`` method; ^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnSCC(CallGraphSCC &SCC) = 0;. The ``runOnSCC`` method performs the interesting work of the pass, and should; return ``true`` if the module was modified by the transformation, ``false``; otherwise. The ``doFinalization(CallGraph &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization(CallGraph &CG);. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnSCC; <writing-an-llvm-pass-runOnSCC>` for every SCC in the program being compiled. .. _writing-an-llvm-pass-FunctionPass:. The ``FunctionPass`` class; --------------------------. In contrast to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:16123,simpl,simple,16123,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simple']
Usability," // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the declaration of the Instruction class, which is the; /// base class for all of the VM instructions.; ///; //===----------------------------------------------------------------------===//. A few things to note about this particular format: The ""``-*- C++ -*-``"" string; on the first line is there to tell Emacs that the source file is a C++ file, not; a C file (Emacs assumes ``.h`` files are C files by default). .. note::. This tag is not necessary in ``.cpp`` files. The name of the file is also; on the first line, along with a very short description of the purpose of the; file. The next section in the file is a concise note that defines the license that the; file is released under. This makes it perfectly clear what terms the source; code can be distributed under and should not be modified in any way. The main body is a `Doxygen <http://www.doxygen.nl/>`_ comment (identified by; the ``///`` comment marker instead of the usual ``//``) describing the purpose; of the file. The first sentence (or a passage beginning with ``\brief``) is; used as an abstract. Any additional information should be separated by a blank; line. If an algorithm is based on a paper or is described in another source,; provide a reference. Header Guard; """""""""""""""""""""""". The header file's guard should be the all-caps path that a user of this header; would #include, using '_' instead of path separator and extension marker.; For example, the header file; ``llvm/include/llvm/Analysis/Utils/Local.h`` would be ``#include``-ed as; ``#include ""llvm/Analysis/Utils/Local.h""``, so its guard is; ``LLVM_ANALYSIS_UTILS_LOCAL_H``. Class overviews; """""""""""""""""""""""""""""". Classes are a fundamental part of an object-oriented design. As such, a; class definition should have a comm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:8431,clear,clear,8431,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['clear'],['clear']
Usability," // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; ```. ### Installation. There are several ways of obtaining `PyROOT`, and which is best depends; on your specific situation. If you work at CERN, you can use the; installation available on `afs`. Otherwise, you will want to build from; source, as `PyROOT` is not build by default in the binaries distributed; from the ROOT project site. If you download the ROOT binaries, take care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from; the CERN `afs` cell `/afs/cern.ch/sw/root/<version>/<platform>`. To use; them, simply modify your shell environment accordingly. For Unix:. `export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%`. `set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%`. where `$ROOTSYS` should be set to; `/afs/cern.ch/sw/root/<version>/<platform>`, and `PYTHONDIR` to; `/afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform>` with `<version>`; and `<platform>` as appropriate. Note that the latest version of Python; is 2.4.1. #### Building from Source. The standard installation instructions for building ROOT from source; apply, with the addition that the build of `PyROOT` needs to be enabled; at the configuration step. First, follow the instructions for obtaining; and unpacking the source, and setting up the build environment. Then, use the following command to configure the build process (of; course, feel free to add any additional flags you m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:6082,simpl,simply,6082,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['simpl'],['simply']
Usability," /// parenexpr ::= '(' expression ')'; static std::unique_ptr<ExprAST> ParseParenExpr() {; getNextToken(); // eat (.; auto V = ParseExpression();; if (!V); return nullptr;. if (CurTok != ')'); return LogError(""expected ')'"");; getNextToken(); // eat ).; return V;; }. This function illustrates a number of interesting things about the; parser:. 1) It shows how we use the LogError routines. When called, this function; expects that the current token is a '(' token, but after parsing the; subexpression, it is possible that there is no ')' waiting. For example,; if the user types in ""(4 x"" instead of ""(4)"", the parser should emit an; error. Because errors can occur, the parser needs a way to indicate that; they happened: in our parser, we return null on an error. 2) Another interesting aspect of this function is that it uses recursion; by calling ``ParseExpression`` (we will soon see that; ``ParseExpression`` can call ``ParseParenExpr``). This is powerful; because it allows us to handle recursive grammars, and keeps each; production very simple. Note that parentheses do not cause construction; of AST nodes themselves. While we could do it this way, the most; important role of parentheses are to guide the parser and provide; grouping. Once the parser constructs the AST, parentheses are not; needed. The next simple production is for handling variable references and; function calls:. .. code-block:: c++. /// identifierexpr; /// ::= identifier; /// ::= identifier '(' expression* ')'; static std::unique_ptr<ExprAST> ParseIdentifierExpr() {; std::string IdName = IdentifierStr;. getNextToken(); // eat identifier. if (CurTok != '(') // Simple variable ref.; return std::make_unique<VariableExprAST>(IdName);. // Call.; getNextToken(); // eat (; std::vector<std::unique_ptr<ExprAST>> Args;; if (CurTok != ')') {; while (true) {; if (auto Arg = ParseExpression()); Args.push_back(std::move(Arg));; else; return nullptr;. if (CurTok == ')'); break;. if (CurTok != ','); return LogError(""Exp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:9239,simpl,simple,9239,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['simpl'],['simple']
Usability," 0;; }; return 1;; }; ```. Example `TMhs3:` Class **`TThreadframe`**; (`TThreadframe.h, TThreadframe.cxx`) is a simple example of a framework; class managing up to four threaded methods. Class `TMhs3`; (`TMhs3.h, TMhs3.cxx)` inherits from this base class, showing the `mhs3`; example 8.1 `(mhs3.h, mhs3.cxx) `within a class. The `Makefile` of this; example builds the shared libraries `libTThreadframe.so` and; `libTMhs3.so`. These are either loaded or executed by the ROOT script; `TMhs3demo.C,` or are linked against an executable: `TMhs3run.cxx`. ### Known Problems. Parts of the ROOT framework, like the interpreter, are not yet; thread-safe. Therefore, you should use this package with caution. If you; restrict your threads to distinct and \`simple' duties, you will able to; benefit from their use. The **`TThread`** class is available on all; platforms, which provide a POSIX compliant thread implementation. On; Linux, Xavier Leroy's Linux Threads implementation is widely used, but; the **`TThread`** implementation should be usable on all platforms that; provide `pthread`. **Linux Xlib on SMP machines** is not yet thread-safe. This may cause; crashes during threaded graphics operations; this problem is independent; of ROOT. **Object instantiation:** there is no implicit locking mechanism for; memory allocation and global ROOT lists. The user has to explicitly; protect their code when using them. ## The Signals of ROOT. The list of default signals handled by ROOT is:. ``` {.cpp}; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingException; kSigSystemkSigWindowChanged; ```. The signals ***`kSigFloatingException`***,; ***`kSigSegmentationViolation`***, ***`kSigIllegalInstruction`***, and; ***`kSigBus`*** cause the printing of the ***`*** Break *** `*** message; and make a long jump back to the ROOT prompt. No other custom; **`TSignalHandler`** can be added to these signals. The ***`kSigAlarm`*** signal handles asynch",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:17422,usab,usable,17422,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['usab'],['usable']
Usability," 11"",; @""String 02""];; const NSStringCompareOptions comparisonOptions; = NSCaseInsensitiveSearch | NSNumericSearch |; NSWidthInsensitiveSearch | NSForcedOrderingSearch;; NSLocale *currentLocale = [NSLocale currentLocale];; NSArray *sorted; = [array sortedArrayUsingComparator:[=](id s1, id s2) -> NSComparisonResult {; NSRange string1Range = NSMakeRange(0, [s1 length]);; return [s1 compare:s2 options:comparisonOptions; range:string1Range locale:currentLocale];; }];; NSLog(@""sorted: %@"", sorted);. This code relies on an implicit conversion from the type of the lambda; expression (an unnamed, local class type called the *closure type*) to the; corresponding block pointer type. The conversion itself is expressed by a; conversion operator in that closure type that produces a block pointer with the; same signature as the lambda itself, e.g.,. .. code-block:: objc. operator NSComparisonResult (^)(id, id)() const;. This conversion function returns a new block that simply forwards the two; parameters to the lambda object (which it captures by copy), then returns the; result. The returned block is first copied (with ``Block_copy``) and then; autoreleased. As an optimization, if a lambda expression is immediately; converted to a block pointer (as in the first example, above), then the block; is not copied and autoreleased: rather, it is given the same lifetime as a; block literal written at that point in the program, which avoids the overhead; of copying a block to the heap in the common case. The conversion from a lambda to a block pointer is only available in; Objective-C++, and not in C++ with blocks, due to its use of Objective-C memory; management (autorelease). Object Literals and Subscripting; --------------------------------. Clang provides support for :doc:`Object Literals and Subscripting; <ObjectiveCLiterals>` in Objective-C, which simplifies common Objective-C; programming patterns, makes programs more concise, and improves the safety of; container creation. There a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:76173,simpl,simply,76173,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['simpl'],['simply']
Usability," 2 = binary.; unsigned BinaryPrecedence = 30;. switch (CurTok) {; default:; return LogErrorP(""Expected function name in prototype"");; case tok_identifier:; FnName = IdentifierStr;; Kind = 0;; getNextToken();; break;; case tok_unary:; getNextToken();; if (!isascii(CurTok)); return LogErrorP(""Expected unary operator"");; FnName = ""unary"";; FnName += (char)CurTok;; Kind = 1;; getNextToken();; break;; case tok_binary:; ... As with binary operators, we name unary operators with a name that; includes the operator character. This assists us at code generation; time. Speaking of, the final piece we need to add is codegen support for; unary operators. It looks like this:. .. code-block:: c++. Value *UnaryExprAST::codegen() {; Value *OperandV = Operand->codegen();; if (!OperandV); return nullptr;. Function *F = getFunction(std::string(""unary"") + Opcode);; if (!F); return LogErrorV(""Unknown unary operator"");. return Builder->CreateCall(F, OperandV, ""unop"");; }. This code is similar to, but simpler than, the code for binary; operators. It is simpler primarily because it doesn't need to handle any; predefined operators. Kicking the Tires; =================. It is somewhat hard to believe, but with a few simple extensions we've; covered in the last chapters, we have grown a real-ish language. With; this, we can do a lot of interesting things, including I/O, math, and a; bunch of other things. For example, we can now add a nice sequencing; operator (printd is defined to print out the specified value and a; newline):. ::. ready> extern printd(x);; Read extern:; declare double @printd(double). ready> def binary : 1 (x y) 0; # Low-precedence operator that ignores operands.; ...; ready> printd(123) : printd(456) : printd(789);; 123.000000; 456.000000; 789.000000; Evaluated to 0.000000. We can also define a bunch of other ""primitive"" operations, such as:. ::. # Logical unary not.; def unary!(v); if v then; 0; else; 1;. # Unary negate.; def unary-(v); 0-v;. # Define > with the same preced",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:14200,simpl,simpler,14200,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simpler']
Usability," 2694; open; string-literals of the _Pragma operator; Not resolved. 2695; C++23; Semantic ignorability of attributes; Unknown. 2696; dup; Relational comparisons of pointers to void; Unknown. 2697; DRWP; Deduction guides using abbreviated function syntax; Unknown. 2698; DRWP; Using extended integer types with z suffix; Unknown. 2699; DRWP; Inconsistency of throw-expression specification; Unknown. 2700; review; #error disallows existing implementation practice; Not resolved. 2701; open; Default arguments in multiple scopes / inheritance of array bounds in the same scope; Not resolved. 2702; open; Constant destruction of reference members; Not resolved. 2703; review; Three-way comparison requiring strong ordering for floating-point types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception object; Unknown. 2712; DRWP; Simplify restrictions on built-in assignment operator candidates; Unknown. 2713; DRWP; Initialization of reference-to-aggregate from designated initializer list; Unknown. 2714; open; Implicit deduction guides omit properties from the parameter-declaration-clause of a constructor; Not resolved. 2715; DRWP; ""calling function"" for parameter initialization may not exist; Unknown. 2716; DRWP; Rule about self-or-base conversion is normatively redundant; Unknown. 2717; DRWP; Pack expansion for alignment-specifier; Unknown. 2718; DRWP; Type completeness for derived-to-base conversions; Unknown. 2719; DRWP; Creating objects in misaligned storage; Unknown. 2720; DRWP; Template valid",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:187017,guid,guides,187017,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['guid'],['guides']
Usability," 2`, one top level branch is created for each array; element. If one of the array elements is a **`TCollection`**, one; top level branch will be created for each element of this; collection. In case a collection element is a **`TClonesArray`**, the special Tree; constructor for **`TClonesArray`** is called. The collection itself; cannot be a **`TClonesArray`**. If `name` is given, all branch names; will be prefixed with `name_`. *IMPORTANT NOTE1:* This function should not be called if `splitlevel<1`.; *IMPORTANT NOTE2:* The branches created by this function will have names; corresponding to the collection or object names. It is important to give; names to collections to avoid misleading branch names or identical; branch names. By default collections have a name equal to the; corresponding class name, e.g. the default name of **`TList`** is; ""`TList`"". ## Examples for Writing and Reading Trees. The following sections are examples of writing and reading trees; increasing in complexity from a simple tree with a few variables to a; tree containing folders and complex Event objects. Each example has a; named script in the `$ROOTSYS/tutorials/tree` directory. They are called; tree1.C to tree4.C. The examples are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the fu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:33243,simpl,simple,33243,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability," :Overview:. The label type represents code labels. :Syntax:. ::. label. .. _t_token:. Token Type; ^^^^^^^^^^. :Overview:. The token type is used when a value is associated with an instruction; but all uses of the value must not attempt to introspect or obscure it.; As such, it is not appropriate to have a :ref:`phi <i_phi>` or; :ref:`select <i_select>` of type token. :Syntax:. ::. token. .. _t_metadata:. Metadata Type; ^^^^^^^^^^^^^. :Overview:. The metadata type represents embedded metadata. No derived types may be; created from metadata except for :ref:`function <t_function>` arguments. :Syntax:. ::. metadata. .. _t_aggregate:. Aggregate Types; ^^^^^^^^^^^^^^^. Aggregate Types are a subset of derived types that can contain multiple; member types. :ref:`Arrays <t_array>` and :ref:`structs <t_struct>` are; aggregate types. :ref:`Vectors <t_vector>` are not considered to be; aggregate types. .. _t_array:. Array Type; """""""""""""""""""". :Overview:. The array type is a very simple derived type that arranges elements; sequentially in memory. The array type requires a size (number of; elements) and an underlying data type. :Syntax:. ::. [<# elements> x <elementtype>]. The number of elements is a constant integer value; ``elementtype`` may; be any type with a size. :Examples:. +------------------+--------------------------------------+; | ``[40 x i32]`` | Array of 40 32-bit integer values. |; +------------------+--------------------------------------+; | ``[41 x i32]`` | Array of 41 32-bit integer values. |; +------------------+--------------------------------------+; | ``[4 x i8]`` | Array of 4 8-bit integer values. |; +------------------+--------------------------------------+. Here are some examples of multidimensional arrays:. +-----------------------------+----------------------------------------------------------+; | ``[3 x [4 x i32]]`` | 3x4 array of 32-bit integer values. |; +-----------------------------+----------------------------------------------------------+; | ``[",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:179395,simpl,simple,179395,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability," :ref:`function attributes <fnattrs>` list.; #. The optional :ref:`operand bundles <opbundles>` list. Semantics:; """""""""""""""""""". This instruction is designed to operate as a standard '``call``'; instruction in most regards. The primary difference is that it; establishes an association with additional labels to define where control; flow goes after the call. The output values of a '``callbr``' instruction are available only to; the '``fallthrough``' block, not to any '``indirect``' blocks(s). The only use of this today is to implement the ""goto"" feature of gcc inline; assembly where additional labels can be provided as locations for the inline; assembly to jump to. Example:; """""""""""""""". .. code-block:: llvm. ; ""asm goto"" without output constraints.; callbr void asm """", ""r,!i""(i32 %x); to label %fallthrough [label %indirect]. ; ""asm goto"" with output constraints.; <result> = callbr i32 asm """", ""=r,r,!i""(i32 %x); to label %fallthrough [label %indirect]. .. _i_resume:. '``resume``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. resume <type> <value>. Overview:; """""""""""""""""". The '``resume``' instruction is a terminator instruction that has no; successors. Arguments:; """""""""""""""""""". The '``resume``' instruction requires one argument, which must have the; same type as the result of any '``landingpad``' instruction in the same; function. Semantics:; """""""""""""""""""". The '``resume``' instruction resumes propagation of an existing; (in-flight) exception whose unwinding was interrupted with a; :ref:`landingpad <i_landingpad>` instruction. Example:; """""""""""""""". .. code-block:: llvm. resume { ptr, i32 } %exn. .. _i_catchswitch:. '``catchswitch``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind to caller; <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind label <default>. Overview:; """""""""""""""""". The '``catchswitch``' instruction is us",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:369708,resume,resume,369708,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['resume'],['resume']
Usability," :versionbadge:`clang-format 3.3` :ref:`¶ <AllowAllParametersOfDeclarationOnNextLine>`; If the function declaration doesn't fit on a line,; allow putting all parameters of a function declaration onto; the next line even if ``BinPackParameters`` is ``false``. .. code-block:: c++. true:; void myFunction(; int a, int b, int c, int d, int e);. false:; void myFunction(int a,; int b,; int c,; int d,; int e);. .. _AllowBreakBeforeNoexceptSpecifier:. **AllowBreakBeforeNoexceptSpecifier** (``BreakBeforeNoexceptSpecifierStyle``) :versionbadge:`clang-format 18` :ref:`¶ <AllowBreakBeforeNoexceptSpecifier>`; Controls if there could be a line break before a ``noexcept`` specifier. Possible values:. * ``BBNSS_Never`` (in configuration: ``Never``); No line break allowed. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2) noexcept(; noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. * ``BBNSS_OnlyWithParen`` (in configuration: ``OnlyWithParen``); For a simple ``noexcept`` there is no line break allowed, but when we; have a condition it is. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. * ``BBNSS_Always`` (in configuration: ``Always``); Line breaks are allowed. But note that because of the associated; penalties ``clang-format`` often prefers not to break before the; ``noexcept``. .. code-block:: c++. void foo(int arg1,; double arg2) noexcept;. void bar(int arg1, double arg2); noexcept(noexcept(baz(arg1)) &&; noexcept(baz(arg2)));. .. _AllowShortBlocksOnASingleLine:. **AllowShortBlocksOnASingleLine** (``ShortBlockStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortBlocksOnASingleLine>`; Dependent on the value, ``while (true) { continue; }`` can be put on a; single line. Possible values:. * ``SBS_Never`` (in configuration: ``Never``); Never merge blocks into a single line. .. code-block:: c++. while (true) {; }; while (true) {; co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:26155,simpl,simple,26155,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['simpl'],['simple']
Usability," :| ""["" `SliceElements` ""]""; :| ""."" `TokIdentifier`; RangeList: `RangePiece` ("","" `RangePiece`)*; RangePiece: `TokInteger`; :| `TokInteger` ""..."" `TokInteger`; :| `TokInteger` ""-"" `TokInteger`; :| `TokInteger` `TokInteger`; SliceElements: (`SliceElement` "","")* `SliceElement` "",""?; SliceElement: `Value`; :| `Value` ""..."" `Value`; :| `Value` ""-"" `Value`; :| `Value` `TokInteger`. .. warning::; The peculiar last form of :token:`RangePiece` and :token:`SliceElement` is; due to the fact that the ""``-``"" is included in the :token:`TokInteger`,; hence ``1-5`` gets lexed as two consecutive tokens, with values ``1`` and; ``-5``, instead of ""1"", ""-"", and ""5"".; The use of hyphen as the range punctuation is deprecated. Simple values; -------------. The :token:`SimpleValue` has a number of forms. .. productionlist::; SimpleValue: `TokInteger` | `TokString`+ | `TokCode`. A value can be an integer literal, a string literal, or a code literal.; Multiple adjacent string literals are concatenated as in C/C++; the simple; value is the concatenation of the strings. Code literals become strings and; are then indistinguishable from them. .. productionlist::; SimpleValue2: ""true"" | ""false"". The ``true`` and ``false`` literals are essentially syntactic sugar for the; integer values 1 and 0. They improve the readability of TableGen files when; boolean values are used in field initializations, bit sequences, ``if``; statements, etc. When parsed, these literals are converted to integers. .. note::. Although ``true`` and ``false`` are literal names for 1 and 0, we; recommend as a stylistic rule that you use them for boolean; values only. .. productionlist::; SimpleValue3: ""?"". A question mark represents an uninitialized value. .. productionlist::; SimpleValue4: ""{"" [`ValueList`] ""}""; ValueList: `ValueListNE`; ValueListNE: `Value` ("","" `Value`)*. This value represents a sequence of bits, which can be used to initialize a; ``bits<``\ *n*\ ``>`` field (note the braces). When doing so, the values; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:14390,simpl,simple,14390,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability," <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {...}, ...}. The above is possible because:. (1) The name of the debug type of the coroutine frame is the `linkage_name`,; plus the `.coro_frame_ty` suffix because each coroutine function shares the; same coroutine type. (2) The coroutine function name is accessible from the address of the coroutine; frame. The above commands can be simplified by placing them in debug scripts. Examples to print coroutine frames; ----------------------------------. The print examples below use the following definition:. .. code-block:: c++. #include <coroutine>; #include <iostream>. struct task{; struct promise_type {; task get_return_object() { return std::coroutine_handle<promise_type>::from_promise(*this); }; std::suspend_always initial_suspend() { return {}; }; std::suspend_always final_suspend() noexcept { return {}; }; void return_void() noexcept {}; void unhandled_exception() noexcept {}. int count = 0;; };. void resume() noexcept {; handle.resume();; }. task(std::coroutine_handle<promise_type> hdl) : handle(hdl) {}; ~task() {; if (handle); handle.destroy();; }. std::coroutine_handle<> handle;; };. class await_counter : public std::suspend_always {; public:; template<class PromiseType>; void await_suspend(std::coroutine_handle<PromiseType> handle) noexcept {; handle.promise().count++;; }; };. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; }. int main() {; task t = coro_task(43);; t.resume();; t.resume();; t.resume();; return 0;; }. In debug mode (`O0` + `g`), the printing result would be:. .. parsed-literal::. {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {count = 1}, v = 43, a = 45, __coro_index = 1 '\001', struct_std__suspend_always_0 = {__int_8 = 0 '\",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:6450,resume,resume,6450,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['resume'],['resume']
Usability," = type { ptr, ptr, i32 }. After resume and destroy parts are outlined, function `f` will contain only the; code responsible for creation and initialization of the coroutine frame and; execution of the coroutine until a suspend point is reached:. .. code-block:: llvm. define ptr @f(i32 %n) {; entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %alloc = call noalias ptr @malloc(i32 24); %frame = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc); %1 = getelementptr %f.frame, ptr %frame, i32 0, i32 0; store ptr @f.resume, ptr %1; %2 = getelementptr %f.frame, ptr %frame, i32 0, i32 1; store ptr @f.destroy, ptr %2. %inc = add nsw i32 %n, 1; %inc.spill.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i32 0, i32 2; store i32 %inc, ptr %inc.spill.addr; call void @print(i32 %n). ret ptr %frame; }. Outlined resume part of the coroutine will reside in function `f.resume`:. .. code-block:: llvm. define internal fastcc void @f.resume(ptr %frame.ptr.resume) {; entry:; %inc.spill.addr = getelementptr %f.frame, ptr %frame.ptr.resume, i64 0, i32 2; %inc.spill = load i32, ptr %inc.spill.addr, align 4; %inc = add i32 %inc.spill, 1; store i32 %inc, ptr %inc.spill.addr, align 4; tail call void @print(i32 %inc); ret void; }. Whereas function `f.destroy` will contain the cleanup code for the coroutine:. .. code-block:: llvm. define internal fastcc void @f.destroy(ptr %frame.ptr.destroy) {; entry:; tail call void @free(ptr %frame.ptr.destroy); ret void; }. Avoiding Heap Allocations; -------------------------. A particular coroutine usage pattern, which is illustrated by the `main`; function in the overview section, where a coroutine is created, manipulated and; destroyed by the same calling function, is common for coroutines implementing; RAII idiom and is suitable for allocation elision optimization which avoid; dynamic allocation by storing the coroutine frame as a static `alloca` in its; caller. In the entry block, we will call `coro.alloc`_ intrins",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:15634,resume,resume,15634,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability," == tok_identifier); ArgNames.push_back(IdentifierStr);; if (CurTok != ')'); return LogErrorP(""Expected ')' in prototype"");. // success.; getNextToken(); // eat ')'. // Verify right number of names for operator.; if (Kind && ArgNames.size() != Kind); return LogErrorP(""Invalid number of operands for operator"");. return std::make_unique<PrototypeAST>(FnName, std::move(ArgNames), Kind != 0,; BinaryPrecedence);; }. This is all fairly straightforward parsing code, and we have already; seen a lot of similar code in the past. One interesting part about the; code above is the couple lines that set up ``FnName`` for binary; operators. This builds names like ""binary@"" for a newly defined ""@""; operator. It then takes advantage of the fact that symbol names in the; LLVM symbol table are allowed to have any character in them, including; embedded nul characters. The next interesting thing to add, is codegen support for these binary; operators. Given our current structure, this is a simple addition of a; default case for our existing binary operator node:. .. code-block:: c++. Value *BinaryExprAST::codegen() {; Value *L = LHS->codegen();; Value *R = RHS->codegen();; if (!L || !R); return nullptr;. switch (Op) {; case '+':; return Builder->CreateFAdd(L, R, ""addtmp"");; case '-':; return Builder->CreateFSub(L, R, ""subtmp"");; case '*':; return Builder->CreateFMul(L, R, ""multmp"");; case '<':; L = Builder->CreateFCmpULT(L, R, ""cmptmp"");; // Convert bool 0/1 to double 0.0 or 1.0; return Builder->CreateUIToFP(L, Type::getDoubleTy(*TheContext),; ""booltmp"");; default:; break;; }. // If it wasn't a builtin binary operator, it must be a user defined one. Emit; // a call to it.; Function *F = getFunction(std::string(""binary"") + Op);; assert(F && ""binary operator not found!"");. Value *Ops[2] = { L, R };; return Builder->CreateCall(F, Ops, ""binop"");; }. As you can see above, the new code is actually really simple. It just; does a lookup for the appropriate operator in the symbol table and; gener",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:7880,simpl,simple,7880,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simple']
Usability," ============. Block Frequency is a metric for estimating the relative frequency of different; basic blocks. This document describes the terminology that the; ``BlockFrequencyInfo`` and ``MachineBlockFrequencyInfo`` analysis passes use. Branch Probability; ==================. Blocks with multiple successors have probabilities associated with each; outgoing edge. These are called branch probabilities. For a given block, the; sum of its outgoing branch probabilities should be 1.0. Branch Weight; =============. Rather than storing fractions on each edge, we store an integer weight.; Weights are relative to the other edges of a given predecessor block. The; branch probability associated with a given edge is its own weight divided by; the sum of the weights on the predecessor's outgoing edges. For example, consider this IR:. .. code-block:: llvm. define void @foo() {; ; ...; A:; br i1 %cond, label %B, label %C, !prof !0; ; ...; }; !0 = !{!""branch_weights"", i32 7, i32 8}. and this simple graph representation::. A -> B (edge-weight: 7); A -> C (edge-weight: 8). The probability of branching from block A to block B is 7/15, and the; probability of branching from block A to block C is 8/15. See :doc:`BranchWeightMetadata` for details about the branch weight IR; representation. Block Frequency; ===============. Block frequency is a relative metric that represents the number of times a; block executes. The ratio of a block frequency to the entry block frequency is; the expected number of times the block will execute per entry to the function. Block frequency is the main output of the ``BlockFrequencyInfo`` and; ``MachineBlockFrequencyInfo`` analysis passes. Implementation: a series of DAGs; ================================. The implementation of the block frequency calculation analyses each loop,; bottom-up, ignoring backedges; i.e., as a DAG. After each loop is processed,; it's packaged up to act as a pseudo-node in its parent loop's (or the; function's) DAG analysis. Block Ma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BlockFrequencyTerminology.rst:1129,simpl,simple,1129,interpreter/llvm-project/llvm/docs/BlockFrequencyTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BlockFrequencyTerminology.rst,1,['simpl'],['simple']
Usability," A cleanup is extra code which needs to be run as part of unwinding a scope. C++; destructors are a typical example, but other languages and language extensions; provide a variety of different kinds of cleanups. In general, a landing pad may; need to run arbitrary amounts of cleanup code before actually entering a catch; block. To indicate the presence of cleanups, a :ref:`i_landingpad` should have; a *cleanup* clause. Otherwise, the unwinder will not stop at the landing pad if; there are no catches or filters that require it to. .. note::. Do not allow a new exception to propagate out of the execution of a; cleanup. This can corrupt the internal state of the unwinder. Different; languages describe different high-level semantics for these situations: for; example, C++ requires that the process be terminated, whereas Ada cancels both; exceptions and throws a third. When all cleanups are finished, if the exception is not handled by the current; function, resume unwinding by calling the :ref:`resume instruction <i_resume>`,; passing in the result of the ``landingpad`` instruction for the original; landing pad. Throw Filters; -------------. Prior to C++17, C++ allowed the specification of which exception types may be; thrown from a function. To represent this, a top level landing pad may exist to; filter out invalid types. To express this in LLVM code the :ref:`i_landingpad`; will have a filter clause. The clause consists of an array of type infos.; ``landingpad`` will return a negative value; if the exception does not match any of the type infos. If no match is found then; a call to ``__cxa_call_unexpected`` should be made, otherwise; ``_Unwind_Resume``. Each of these functions requires a reference to the; exception structure. Note that the most general form of a ``landingpad``; instruction can have any number of catch, cleanup, and filter clauses (though; having more than one cleanup is pointless). The LLVM C++ front-end can generate; such ``landingpad`` instructions ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:12913,resume,resume,12913,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,2,['resume'],['resume']
Usability," After optimisations and code layout complete, information about variable; values must be translated into variable locations, i.e. registers and stack; slots. This is performed in the [`LiveDebugValues` pass][LiveDebugValues], where; the debug instructions and machine code are separated out into two independent; functions:; * One that assigns values to variable names,; * One that assigns values to machine registers and stack slots. LLVM's existing SSA tools are used to place `PHI`s for each function, between; variable values and the values contained in machine locations, with value; propagation eliminating any unnecessary `PHI`s. The two can then be joined up; to map variables to values, then values to locations, for each instruction in; the function. Key to this process is being able to identify the movement of values between; registers and stack locations, so that the location of values can be preserved; for the full time that they are resident in the machine. # Required target support and transition guide. Instruction referencing will work on any target, but likely with poor coverage.; Supporting instruction referencing well requires:; * Target hooks to be implemented to allow `LiveDebugValues` to follow values; through the machine,; * Target-specific optimisations to be instrumented, to preserve instruction; numbers. ## Target hooks. `TargetInstrInfo::isCopyInstrImpl` must be implemented to recognise any; instructions that are copy-like -- `LiveDebugValues` uses this to identify when; values move between registers. `TargetInstrInfo::isLoadFromStackSlotPostFE` and; `TargetInstrInfo::isStoreToStackSlotPostFE` are needed to identify spill and; restore instructions. Each should return the destination or source register; respectively. `LiveDebugValues` will track the movement of a value from / to; the stack slot. In addition, any instruction that writes to a stack spill; should have a `MachineMemoryOperand` attached, so that `LiveDebugValues` can; recognise that a sl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:5280,guid,guide,5280,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,1,['guid'],['guide']
Usability," Algorithm (BFGS), or Genetic Algorithm (GA - slower and worse). LearningRate No 0.02 − ANN learning rate parameter. DecayRate No 0.01 − Decay rate for learning parameter. TestRate No 10 − Test for overtraining performed at each #th epochs. EpochMonitoring No False − Provide epoch-wise monitoring plots according to TestRate (caution: causes big ROOT output file!). Sampling No 1 − Only 'Sampling' (randomly selected) events are trained each epoch. SamplingEpoch No 1 − Sampling is used for the first 'SamplingEpoch' epochs, afterwards, all events are taken for training. SamplingImportance No 1 − The sampling weights of events in epochs which successful (worse estimator than before) are multiplied with SamplingImportance, else they are divided. SamplingTraining No True − The training sample is sampled. SamplingTesting No False − The testing sample is sampled. ResetStep No 50 − How often BFGS should reset history. Tau No 3 − LineSearch size step. BPMode No sequential sequential, batch Back-propagation learning mode: sequential or batch. BatchSize No -1 − Batch size: number of events/batch, only set if in Batch Mode, -1 for BatchSize=number_of_events. ConvergenceImprove No 1e-30 − Minimum improvement which counts as improvement (<0 means automatic convergence check is turned off). ConvergenceTests No -1 − Number of steps (without improvement) required for convergence (<0 means automatic convergence check is turned off). UseRegulator No False − Use regulator to avoid over-training. UpdateLimit No 10000 − Maximum times of regulator update. CalculateErrors No False − Calculates inverse Hessian matrix at the end of the training to be able to calculate the uncertainties of an MVA value. WeightRange No 1 − Take the events for the estimator calculations from small deviations from the desired value to large deviations only over the weight range. Configuration options for MVA method :. Configuration options reference for MVA method: Cuts. Option Array Default value Predefined value",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:23339,learn,learning,23339,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['learn'],['learning']
Usability," Built Module Interface file; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. A ``Built Module Interface file`` stands for the precompiled result of an importable module unit.; It is also called the acronym ``BMI`` generally. Global module fragment; ~~~~~~~~~~~~~~~~~~~~~~. In a module unit, the section from ``module;`` to the module declaration is called the global module fragment. How to build projects using modules; -----------------------------------. Quick Start; ~~~~~~~~~~~. Let's see a ""hello world"" example that uses modules. .. code-block:: c++. // Hello.cppm; module;; #include <iostream>; export module Hello;; export void hello() {; std::cout << ""Hello World!\n"";; }. // use.cpp; import Hello;; int main() {; hello();; return 0;; }. Then we type:. .. code-block:: console. $ clang++ -std=c++20 Hello.cppm --precompile -o Hello.pcm; $ clang++ -std=c++20 use.cpp -fmodule-file=Hello=Hello.pcm Hello.pcm -o Hello.out; $ ./Hello.out; Hello World!. In this example, we make and use a simple module ``Hello`` which contains only a; primary module interface unit ``Hello.cppm``. Then let's see a little bit more complex ""hello world"" example which uses the 4 kinds of module units. .. code-block:: c++. // M.cppm; export module M;; export import :interface_part;; import :impl_part;; export void Hello();. // interface_part.cppm; export module M:interface_part;; export void World();. // impl_part.cppm; module;; #include <iostream>; #include <string>; module M:impl_part;; import :interface_part;. std::string W = ""World."";; void World() {; std::cout << W << std::endl;; }. // Impl.cpp; module;; #include <iostream>; module M;; void Hello() {; std::cout << ""Hello "";; }. // User.cpp; import M;; int main() {; Hello();; World();; return 0;; }. Then we are able to compile the example by the following command:. .. code-block:: console. # Precompiling the module; $ clang++ -std=c++20 interface_part.cppm --precompile -o M-interface_part.pcm; $ clang++ -std=c++20 impl_part.cppm --precompile -fprebuilt-module-pa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:4916,simpl,simple,4916,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['simpl'],['simple']
Usability, C++23; Missing __has_cpp_attribute(assume); Unknown. 2616; C++23; Imprecise restrictions on break and continue; Unknown. 2617; review; Default template arguments for template members of non-template classes; Not resolved. 2618; C++23; Substitution during deduction should exclude exception specifications; Unknown. 2619; C++23; Kind of initialization for a designated-initializer-list; Unknown. 2620; C++23; Nonsensical disambiguation rule; Unknown. 2621; C++23; Kind of lookup for using enum declarations; Clang 16. 2622; C++23; Compounding types from function and pointer-to-member types; Unknown. 2623; drafting; Invoking destroying operator delete for constructor failure; Not resolved. 2624; C++23; Array delete expression with no array cookie; Unknown. 2625; C++23; Deletion of pointer to out-of-lifetime object; Unknown. 2626; C++23; Rephrase ones' complement using base-2 representation; Unknown. 2627; C++23; Bit-fields and narrowing conversions; Unknown. 2628; DR; Implicit deduction guides should propagate constraints; No. 2629; C++23; Variables of floating-point type as switch conditions; Unknown. 2630; C++23; Syntactic specification of class completeness; Unknown. 2631; C++23; Immediate function evaluations in default arguments; Clang 16. 2632; review; 'user-declared' is not defined; Not resolved. 2633; open; typeid of constexpr-unknown dynamic type; Not resolved. 2634; tentatively ready; Avoid circularity in specification of scope for friend class declarations; Unknown. 2635; C++23; Constrained structured bindings; Clang 16. 2636; C++23; Update Annex E based on Unicode 15.0 UAX #31; N/A. 2637; tentatively ready; Injected-class-name as a simple-template-id; Unknown. 2638; tentatively ready; Improve the example for initializing by initializer list; Unknown. 2639; C++23; new-lines after phase 1; Unknown. 2640; C++23; Allow more characters in an n-char sequence; Clang 16. 2641; C++23; Redundant specification of value category of literals; Unknown. 2642; C++23; Inconsist,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:181127,guid,guides,181127,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['guid'],['guides']
Usability," CostModel, Legalization and SelectionDAG lowering. We will also emit diagnostics in Clang to prevent the use of; non-streaming(-compatible) operations, e.g. through ACLE intrinsics, when a; function is decorated with the streaming mode attributes. Other things to consider; ------------------------. * Inlining must be disabled when the call-site needs to toggle PSTATE.SM or; when the callee's function body is executed in a different streaming mode than; its caller. This is needed because function calls are the boundaries for; streaming mode changes. * Tail call optimization must be disabled when the call-site needs to toggle; PSTATE.SM, such that the caller can restore the original value of PSTATE.SM. 3. Handling PSTATE.ZA; =====================. In contrast to PSTATE.SM, enabling PSTATE.ZA does not affect the SVE vector; length and also doesn't clobber FP/AdvSIMD/SVE registers. This means it is safe; to toggle PSTATE.ZA using intrinsics. This also makes it simpler to setup a; lazy-save mechanism for calls to private-ZA functions (i.e. functions that may; either directly or indirectly clobber ZA state). For the purpose of handling functions marked with ``aarch64_pstate_za_new``,; we have introduced a new LLVM IR pass (SMEABIPass) that is run just before; SelectionDAG. Any such functions dealt with by this pass are marked with; ``aarch64_expanded_pstate_za``. Setting up a lazy-save; ----------------------. Committing a lazy-save; ----------------------. Exception handling and ZA; -------------------------. 4. Types; ========. AArch64 Predicate-as-Counter Type; ---------------------------------. :Overview:. The predicate-as-counter type represents the type of a predicate-as-counter; value held in a AArch64 SVE predicate register. Such a value contains; information about the number of active lanes, the element width and a bit that; tells whether the generated mask should be inverted. ACLE intrinsics should be; used to move the predicate-as-counter value to/from a predic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:17048,simpl,simpler,17048,interpreter/llvm-project/llvm/docs/AArch64SME.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst,1,['simpl'],['simpler']
Usability," Interp.ParseAndExecute(“int getGlobal();”);; Value V;; Interp.ParseAndExecute(“getGlobal()”, &V);; std::cout << V.getAs<int>() << “\n”; // Prints 42. **Note:** Above is an example of interoperability between the compiled code and; the interpreted code. Interoperability between languages (e.g., C++ and Python); works similarly. 2. Dump Captured Execution Results; ==================================. This feature helps create a temporary dump to display the value and type; (pretty print) of the desired data. This is a good way to interact with the; interpreter during interactive programming. How value printing is simplified (Automatic Printf); ---------------------------------------------------. The ``Automatic Printf`` feature makes it easy to display variable values during; program execution. Using the ``printf`` function repeatedly is not required.; This is achieved using an extension in the ``libclangInterpreter`` library. To automatically print the value of an expression, simply write the expression; in the global scope **without a semicolon**. .. graphviz::; :name: automaticprintf; :caption: Automatic PrintF; :alt: Shows how Automatic PrintF can be used; :align: center. digraph ""AutomaticPrintF"" {; size=""6,4"";; rankdir=""LR"";; graph [fontname=""Verdana"", fontsize=""12""];; node [fontname=""Verdana"", fontsize=""12""];; edge [fontname=""Sans"", fontsize=""9""];. manual [label="" Manual PrintF "", shape=""box""];; int1 [label="" int ( &) 42 "", shape=""box""]; auto [label="" Automatic PrintF "", shape=""box""];; int2 [label="" int ( &) 42 "", shape=""box""]. auto -> int2 [label=""int x = 42; \n x""];; manual -> int1 [label=""int x = 42; \n printf(&quot;(int &) %d \\n&quot;, x);""];; }. Significance of this feature; ----------------------------. Inspired by a similar implementation in `Cling <https://github.com/root-project/cling>`_,; this feature added to upstream Clang repo has essentially extended the syntax of; C++, so that it can be more helpful for people that are writing code for data; scie",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:14312,simpl,simply,14312,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['simpl'],['simply']
Usability," Interpreter on the Bela Platform <https://gist.github.com/jarmitage/6e411ae8746c04d6ecbee1cbc1ebdcd4>`_; - Jack Armitage 2019; - Cling has been installed on a BeagleBoard to bring live coding to the Bela interactive audio platform.; * - `Implementation of GlobalModuleIndex in ROOT and Cling <https://indico.cern.ch/event/840376/contributions/3525646/attachments/1895398/3127159/GSoC_Presentation__GMI.pdf>`_; - *Arpitha Raghunandan* 2012 Google Summer of Code GSoC; - GlobalModuleIndex can be used for improving ROOT’s and Cling’s performance ; * - `Example project using cling as library <https://github.com/root-project/cling/tree/master/tools/demo>`_; - *Axel Naumann* 2016 GitHub; - This video showcases how to use Cling as a library, and shows how to set up a simple CMake configuration that uses Cling.; * - `Cling C++ interpreter testdrive <https://www.youtube.com/watch?v=1IGTHusaJ18>`_; - *Mika* 2015 Youtube; - In this tutorial, a developer tries Cling for the first time by uploading a few simple C++ user-cases onto Cling, involving also the loading of external files; * - `Building an Order Book in C++ <https://www.youtube.com/watch?v=fxN4xEZvrxI>`_; - *Dimitri Nesteruk* 2015 Youtube; - This demo shows how to build a simple order book using C++, CLion, Google Test and, of course, Cling. ; * - `Cling C++ interpreter testdrive <https://www.youtube.com/watch?v=1IGTHusaJ18>`_; - Dimitri Nesteruk 2015 Youtube; - This tutorial describes Cling’s general features. You will learn how to start Cling on Ubuntu, how to write a simple expression (N=5, N++) and how to define a Class for calculating body mass index. ; * - `Cling Interactive OpenGL Demo <https://www.youtube.com/watch?v=eoIuqLNvzFs>`_; - *Alexander Penev* 2012 Youtube; - This demo shows how to use Cling for interactive OpenGL. A rotating triangle with changing color, a static figure, and a figure with light effects are created.; ; . .. list-table:: Language Interoperability with Cling:; :widths: 25 25 50; :header-rows:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst:4817,simpl,simple,4817,interpreter/cling/docs/chapters/references.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst,1,['simpl'],['simple']
Usability," JSON files in default user interface, including; monitoring. One could open file from link like: https://root.cern.ch/js/dev/?json=demo/canvas_tf1.json; 15. Introduce JSROOT.FFormat function to convert numeric values into string according; format like 6.4g or 5.7e. Used for statistic display. ## Changes in 3.5; 1. Fix error in vertical text alignment; 2. Many improvements in TPaletteAxis drawing - draw label, avoid too large ticks.; 3. Fix error with col drawing - bin with maximum value got wrong color; 4. Test for existing jquery.js, jquery-ui.js and d3.js libraries, reuse when provided; 5. Fix several I/O problems; now one could read files, produced in Geant4; 6. Implement 'e2' drawing option for TH1 class,; use by default 'e' option when TH1 has non-empty fSumw2; 7. Reuse statistic from histogram itself, when no axis selection done; 8. Support log/lin z scale for color drawing; 9. Implement interactive z-scale selection on TPaletteAxis; 10. Allow to redraw item with other draw options (before one should clear drawings); 11. Several improvements in THttpServer user interface - repair hierarchy reload,; hide unsupported context menu entries, status line update. ## Changes in 3.4; 1. Support usage of minimized versions of .js and .css files.; Minimized scripts used by default on web servers.; 2. Implement JSROOT.extend instead of jQuery.extend, reduce; usage of jquery.js in core JSROOT classes; 3. Implement main graphics without jquery at all,; such mode used in `nobrowser` mode.; 4. Provide optional latex drawing with MathJax SVG.; TMathText always drawn with MathJax,; other classes require `mathjax` option in URL; 5. Improve drawing of different text classes, correctly handle; their alignment and scaling, special handling for IE; 6. Fix error with time axes - time offset was not correctly interpreted. ## Changes in 3.3; 1. Use d3.time.scale for display of time scales; 2. Within JSRootCore.js script URL one could specify JSROOT; functionality to be loaded: '2d', '3",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:66108,clear,clear,66108,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['clear'],['clear']
Usability," LLVM, see `the download page; <https://llvm.org/releases/>`_ to find your documentation. The LLVM compiler infrastructure supports a wide range of projects, from; industrial strength compilers to specialized JIT applications to small; research projects. Similarly, documentation is broken down into several high-level groupings; targeted at different audiences:. LLVM Design & Overview; ======================. Several introductory papers and presentations. .. toctree::; :hidden:. FAQ; Lexicon. `Introduction to the LLVM Compiler`__; Presentation providing a users introduction to LLVM. .. __: https://llvm.org/pubs/2008-10-04-ACAT-LLVM-Intro.html. `Intro to LLVM`__; A chapter from the book ""The Architecture of Open Source Applications"" that; describes high-level design decisions that shaped LLVM. .. __: http://www.aosabook.org/en/llvm.html. `LLVM: A Compilation Framework for Lifelong Program Analysis & Transformation`__; Design overview. .. __: https://llvm.org/pubs/2004-01-30-CGO-LLVM.html. `LLVM: An Infrastructure for Multi-Stage Optimization`__; More details (quite old now). .. __: https://llvm.org/pubs/2002-12-LattnerMSThesis.html. Documentation; =============. Getting Started, How-tos, Developer Guides, and Tutorials. .. toctree::; :hidden:. GettingStartedTutorials; Reference; UserGuides; DiscourseMigrationGuide. :doc:`GettingStartedTutorials`; For those new to the LLVM system. :doc:`UserGuides`; User guides and How-tos. :doc:`Reference`; LLVM and API reference documentation. :doc:`DiscourseMigrationGuide`; Guide for users to migrate to Discourse. Community; =========. LLVM welcomes contributions of all kinds. To learn more, see the following articles:. .. toctree::; :hidden:. GettingInvolved. * :doc:`GettingInvolved`; * :ref:`development-process`; * :ref:`lists-forums`; * :ref:`meetups-social-events`; * :ref:`community-proposals`. Reporting a security issue. * :ref:`report-security-issue`. Indices and tables; ==================. * :ref:`genindex`; * :ref:`search`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/index.rst:1494,guid,guides,1494,interpreter/llvm-project/llvm/docs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/index.rst,2,"['guid', 'learn']","['guides', 'learn']"
Usability," Like new targets, most projects already in the monorepo are considered to be in; the *core tier* of our :doc:`support policy<SupportPolicy>`. The burden to add; things to the LLVM monorepo needs to be very high - code that is added to this; repository is checked out by everyone in the community. As such, we hold; components to a high bar similar to ""official targets"", they:. * Must be generally aligned with the mission of the LLVM project to advance; compilers, languages, tools, runtimes, etc.; * Must conform to all of the policies laid out in this developer policy; document, including license, patent, coding standards, and code of conduct.; * Must have an active community that maintains the code, including established; code owners.; * Should have reasonable documentation about how it works, including a high; quality README file.; * Should have CI to catch breakage within the project itself or due to; underlying LLVM dependencies.; * Should have code free of issues the community finds contentious, or be on a; clear path to resolving them.; * Must be proposed through the LLVM RFC process, and have its addition approved; by the LLVM community - this ultimately mediates the resolution of the; ""should"" concerns above. If you have a project that you think would make sense to add to the LLVM; monorepo, please start an RFC topic on the `LLVM Discourse forums`_ to kick off; the discussion. This process can take some time and iteration - please don’t; be discouraged or intimidated by that!. If you have an earlier stage project that you think is aligned with LLVM, please; see the ""Incubating New Projects"" section. Incubating New Projects; -----------------------. The burden to add a new project to the LLVM monorepo is intentionally very high,; but that can have a chilling effect on new and innovative projects. To help; foster these sorts of projects, LLVM supports an ""incubator"" process that is; much easier to get started with. It provides space for potentially valuable,; ne",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:46444,clear,clear,46444,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['clear'],['clear']
Usability," MC; simulation/integration in few dimensions. It relies heavily on ROOT package,; borrowing persistency of classes from ROOT. mFOAM can be easily used from; the ROOT shell. For more difficult problems the full FOAM may be better. ### How to run application programs ?. The application program can be run in two modes: it can be simply; interpreted by CLING or compiled. The first method is simpler but; results in slower execution. The second method employs ACLiC -; The Automatic Compiler of Libraries, which automatizes the; process of compilation and linking. In $(ROOTSYS)/tutorials there are 3 demonstration programs:. #### foam_kanwa.C; is a simple example how to run FOAM in interactive; mode. To run this macro issue the following simple command from the; Linux shell:. ```; root foam_kanwa.C; ```. or from CLING:. ```; root [0] .x foam_kanwa.C; ```. Simulation will start and graphical canvas with plot; of the distribution function appear. In this example; we defined the distribution function simply as a global; function function Camel2. #### foam_demo.C; shows usage of FOAM in compiled mode, which is; the preferred method. The integrand function is defined; now as a Density method from class TFDISTR inheriting from; abstract class TFoamIntegrand. User can modify interface to; integrand function according to their needs but they should; always remember to define Density method which provides the; density distribution.; Enter CLING interpreter and type:. ```; root [0] gSystem->Load(""libFoam.so""); root [1] .x foam_demo.C+; ```. to load FOAM library, compile and execute macro foam_demo.C.; A shared object foam_demo_C.so is created in the current; directory. At the end of exploration phase FOAM object; including distribution function will be written to disk. #### foam_demopers.C; demonstrates persistency of FOAM classes.; To run this macro type:. ```; root [0] .x foam_demopers.C; ```. Program reads the FOAM object from disk, checks its; consistency and prints geometry of c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/foam/index.md:1298,simpl,simply,1298,tutorials/foam/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/foam/index.md,1,['simpl'],['simply']
Usability," Map Format. - ""`svg`"" a Scalable Vector Graphics file. - ""`tiff`"" a Tagged-Image File Format. - ""`root`""a ROOT binary file is produced. You do not need to specify this second parameter; you can indicate by; the filename extension what format you want to save a canvas in (i.e.; `canvas.ps`, `canvas.gif`, `canvas.C`, etc). The size of the PostScript picture, by default, is computed to keep the; aspect ratio of the picture on the screen, where the size along `x` is; always 20 cm. You can set the size of the PostScript picture before; generating the picture with a command such as:. ``` {.cpp}; TPostScript myps(""myfile.ps"",111); myps.Range(xsize,ysize);; object->Draw();; myps.Close();; ```. The first parameter in the **`TPostScript`** constructor is the name of; the file; the second one is the format option:. - 111 - `ps portrait`. - 112 - `ps landscape`. - 113 - `eps`. You can set the default paper size with:. ``` {.cpp}; gStyle->SetPaperSize(xsize,ysize);; ```. You can resume writing again in this file with `myps.Open()`. Note that; you may have several Post Script files opened simultaneously. Use; `TPostScript::Text(x,y,""string"")` to add text to a postscript file. This; method writes the string in quotes into a PostScript file at position; `x, y` in world coordinates. ### Special Characters. The following characters have a special action on the PostScript file:. - `` ` `` - go to Greek. - `'` - go to special. - `~` - go to Zapf Dingbats. - `?` - go to subscript. - `^` - go to superscript. - `!` - go to normal level of script. - `&` - backspace one character. - `#` - end of Greek or end of ZapfDingbats. These special characters are printed as such on the screen. To generate; one of these characters on the PostScript file, you must escape it with; the escape character ""@"". The use of these special characters is; illustrated in several scripts referenced by the **`TPostScript`**; constructor. ### Writing Several Canvases to the Same PostScript File. The following sequen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:94639,resume,resume,94639,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['resume'],['resume']
Usability," MatchFinder::MatchCallback {; public :; virtual void run(const MatchFinder::MatchResult &Result) {; if (const ForStmt *FS = Result.Nodes.getNodeAs<clang::ForStmt>(""forLoop"")); FS->dump();; }; };. And change ``main()`` to:. .. code-block:: c++. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());. LoopPrinter Printer;; MatchFinder Finder;; Finder.addMatcher(LoopMatcher, &Printer);. return Tool.run(newFrontendActionFactory(&Finder).get());; }. Now, you should be able to recompile and run the code to discover for; loops. Create a new file with a few examples, and test out our new; handiwork:. .. code-block:: console. cd ~/clang-llvm/build/; ninja loop-convert; vim ~/test-files/simple-loops.cc; bin/loop-convert ~/test-files/simple-loops.cc. Step 3.5: More Complicated Matchers; ===================================. Our simple matcher is capable of discovering for loops, but we would; still need to filter out many more ourselves. We can do a good portion; of the remaining work with some cleverly chosen matchers, but first we; need to decide exactly which properties we want to allow. How can we characterize for loops over arrays which would be eligible; for translation to range-based syntax? Range based loops over arrays of; size ``N`` that:. - start at index ``0``; - iterate consecutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same vari",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:10425,simpl,simple-loops,10425,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['simpl'],['simple-loops']
Usability," Most layers that derived from IRLayer can rely on this default implementation; of the ``add`` method. These two operations, ``add`` and ``emit``, together constitute the layer; concept: A layer is a way to wrap a part of a compiler pipeline (in this case; the ""opt"" phase of an LLVM compiler) whose API is opaque to ORC with an; interface that ORC can call as needed. The add method takes an; module in some input program representation (in this case an LLVM IR module); and stores it in the target ``JITDylib``, arranging for it to be passed back; to the layer's emit method when any symbol defined by that module is requested.; Each layer can complete its own work by calling the ``emit`` method of its base; layer. For example, in this tutorial our IRTransformLayer calls through to; our IRCompileLayer to compile the transformed IR, and our IRCompileLayer in; turn calls our ObjectLayer to link the object file produced by our compiler. So far we have learned how to optimize and compile our LLVM IR, but we have; not focused on when compilation happens. Our current REPL optimizes and; compiles each function as soon as it is referenced by any other code,; regardless of whether it is ever called at runtime. In the next chapter we; will introduce a fully lazy compilation, in which functions are not compiled; until they are first called at run-time. At this point the trade-offs get much; more interesting: the lazier we are, the quicker we can start executing the; first function, but the more often we will have to pause to compile newly; encountered functions. If we only code-gen lazily, but optimize eagerly, we; will have a longer startup time (as everything is optimized at that time) but; relatively short pauses as each function just passes through code-gen. If we; both optimize and code-gen lazily we can start executing the first function; more quickly, but we will have longer pauses as each function has to be both; optimized and code-gen'd when it is first executed. Things bec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:10371,learn,learned,10371,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['learn'],['learned']
Usability," Phoebe Wang (she/her); - X86 backend, General questions to X86, women in compilers.; - Monthly, 3rd Wednesday of the month at 8:30am Beijing time, for 30 minutes.; - `MS Teams <https://teams.microsoft.com/l/meetup-join/19%3ameeting_NWQ0MjU0NjYtZjUyMi00YTU3LThmM2EtY2Y2YTE4NGM3NmFi%40thread.v2/0?context=%7b%22Tid%22%3a%2246c98d88-e344-4ed4-8496-4ed7712e255d%22%2c%22Oid%22%3a%227b309d9c-a9bb-44c8-a940-ab97eef42d4d%22%7d>`__; - English, Chinese; * - Amara Emerson; - GlobalISel questions.; - Monthly, 4th Wednesday of the month at 9:30am PT, for 30 minutes.; - `Google meet <https://meet.google.com/pdd-dibg-cwv>`__; - English. Guidance for office hours hosts; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * If you're interested in becoming an office hours host, please add your; information to the list above. Please create a calendar event for it and; invite calendar@llvm.org to the event so that it'll show up on the; :ref:`llvm-community-calendar`.; Please see :ref:`llvm-community-calendar-host-guidance` for more guidance on; what to add to your calendar invite.; * When starting an office hours session, consider typing something like ""*Hi,; I'm available for chats in the next half hour at* video chat URL. *I'm; looking forward to having conversations on the video chat or here.*"" on the; LLVM chat channels that you are already on. These could include:. * the `#office-hours Discord channel; <https://discord.com/channels/636084430946959380/976196303681896538>`__.; * :ref:`IRC`. Doing this can help:; * overcome potential anxiety to call in for a first time,; * people who prefer to first exchange a few messages through text chat; before dialing in, and; * remind the wider community that office hours do exist.; * If you decide to no longer host office hours, please do remove your entry; from the list above. .. _IRC:. IRC; ---. Users and developers of the LLVM project (including subprojects such as Clang); can be found in #llvm on `irc.oftc.net <irc://irc.oftc.net/llvm>`_. The channel; is act",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:16022,guid,guidance,16022,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,2,['guid'],['guidance']
Usability," Provide access to arbitrary data member of objects, registered to the server; - Prevent data caching in the browser by setting no-cache header. April 2014; - In TCivetweb class support digest authentication method. User; can specify auth_file and auth_domain parameters to protect; access to the server; - Fix error in FastCgi, now correctly works with Apache; - Avoid direct usage of TASImage. March 2014; - Replace mongoose by civetweb due to more liberal MIT license.; Works out of the box while civetweb version fully corresponds to; previously used version of mongoose.; - Introduce TBufferJSON class to store arbitrary ROOT object; into JSON format. It is not one-to-one storage (like XML), but; rather JS-like structures. For instance, all TCollections converted; into JavaScript Array. Produced JS object is similar to JSRootIO.; - Process get.json request, which returns object in JSON form.; It can be used directly is script without special I/O of Bertrand.; - Use get.json on browser side to simplify logic. No need for extra; requests for streamer infos.; - Process get.xml request, provide full object streaming via TBufferXML.; It is complete object data, but with many custom-streamer data.; - Significant redesign of I/O part of JSRootIO code. Main change -; introduce JSROOTIO.TBuffer class which has similar functionality as; original TBufferFile class. Eliminate many places with duplicated code; - In JSRootIO avoid objects cloning when object referenced several times; - Treat special cases (collection, arrays) in one place.; This is major advantage, while any new classes should be implemented once.; - Object representation, produced by JSRootIO is similar to; objects, produced by TBufferJSON class. By this one can exchange; I/O engine and use same JavaSctript graphic for display.; - More clear functions to display different elements of the file.; In the future functions should be fully separated from I/O part; and organized in similar way as online part.; - Eliminate ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt:2569,simpl,simplify,2569,net/http/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt,1,['simpl'],['simplify']
Usability," RAUW'd, do so. The; ``Value::replaceAllUsesWith`` API transparently updates debug uses of the; dying instruction to point to the replacement value. * If the dying instruction cannot be RAUW'd, call ``llvm::salvageDebugInfo`` on; it. This makes a best-effort attempt to rewrite debug uses of the dying; instruction by describing its effect as a ``DIExpression``. * If one of the **operands** of a dying instruction would become trivially; dead, use ``llvm::replaceAllDbgUsesWith`` to rewrite the debug uses of that; operand. Consider the following example function:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %b = sext i16 %a to i32; %c = and i32 %b, 15; call void @llvm.dbg.value(metadata i32 %c, ...); %d = trunc i32 %c to i16; ret i16 %d; }. Now, here's what happens after the unnecessary truncation instruction ``%d`` is; replaced with a simplified instruction:. .. code-block:: llvm. define i16 @foo(i16 %a) {; call void @llvm.dbg.value(metadata i32 undef, ...); %simplified = and i16 %a, 15; ret i16 %simplified; }. Note that after deleting ``%d``, all uses of its operand ``%c`` become; trivially dead. The debug use which used to point to ``%c`` is now ``undef``,; and debug info is needlessly lost. To solve this problem, do:. .. code-block:: cpp. llvm::replaceAllDbgUsesWith(%c, theSimplifiedAndInstruction, ...). This results in better debug info because the debug use of ``%c`` is preserved:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %simplified = and i16 %a, 15; call void @llvm.dbg.value(metadata i16 %simplified, ...); ret i16 %simplified; }. You may have noticed that ``%simplified`` is narrower than ``%c``: this is not; a problem, because ``llvm::replaceAllDbgUsesWith`` takes care of inserting the; necessary conversion operations into the DIExpressions of updated debug uses. Deleting a MIR-level MachineInstr; ---------------------------------. TODO. Rules for updating ``DIAssignID`` Attachments; =============================================. ``DIAssignID`` meta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:7935,simpl,simplified,7935,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,2,['simpl'],['simplified']
Usability," Rene Brun, CERN/SFT,\; Philippe Canal, FNAL,\; Cristina Cristescu, CERN/SFT,\; Olivier Couet, CERN/SFT,\; Kyle Cranmer, NYU, RooStats,\; Gerri Ganis, CERN/SFT,\; Andrei Gheata, CERN/SFT,\; Enrico Guiraud, CERN/SFT, \; Burt Holzman, Fermilab, CMS,\; Lukasz Janyst, CERN/IT,\; Christopher Jones, Fermilab, CMS,\; Wim Lavrijsen, LBNL, PyRoot,\; Sergey Linev, GSI, http, JSROOT, \; Pere Mato, CERN/SFT,\; Lorenzo Moneta, CERN/SFT,\; Axel Naumann, CERN/SFT,\; Danilo Piparo, CERN/SFT,\; Timur Pocheptsov, CERN/SFT,\; Fons Rademakers, CERN/IT/Openlab,\; Enric Tejedor Saavedra, CERN/SFT,\; Liza Sakellari, CERN/SFT,\; Manuel Tobias Schiller,CERN, LHCb\; David Smith, CERN/IT,\; Matevz Tadel, UCSD/CMS, Eve, \; Vassil Vassilev, CERN/SFT \; Wouter Verkerke, NIKHEF/Atlas, RooFit, \; Omar, Zapata, Medellin, Columbia \; Maciej Zimnoch, GSoC, Poland. ## ROOT reference manual. The ROOT reference manual has been moved into Doxygen. Still some work and; polish has to be done but the reference guide in this new format is now online; and can be seen from the [ROOT home page](https://root.cern.ch/doc/master/index.html). ## Core Libraries. ### Dictionary generation. Fixed the dictionary generation in the case of class inside a namespace; marked inlined. Added mechanisms to stop the dictionary generation while parsing the XML and while selecting in presence of duplicates. Fix [ROOT-7760] : fully allow the usage of the dylib extension on OSx. Fix [ROOT-7723] : allow IOCtors to have as argument a ref to a type called __void__. We added a dictionary for map<string,string> as part of the default STL dictionary. We added support for template parameter packs in class name involved in the I/O. ### Thread safety and thread awareness. We added the function `TMethodCall::GetCallFunc` to allow direct access to the function wrapper. We reduced thread serialization in `TClass::GetCheckSum`, `TClass::GetBaseClassOffset` and `TClass::Property`. `TObjArray::Delete` was updated to allow its caller to explicitly ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:1337,guid,guide,1337,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['guid'],['guide']
Usability," Replacement of Aggregates; ------------------------------------------. The well-known scalar replacement of aggregates transformation. This transform; breaks up ``alloca`` instructions of aggregate type (structure or array) into; individual ``alloca`` instructions for each member if possible. Then, if; possible, it transforms the individual ``alloca`` instructions into nice clean; scalar SSA form. .. _passes-sccp:. ``sccp``: Sparse Conditional Constant Propagation; -------------------------------------------------. Sparse conditional constant propagation and merging, which can be summarized; as:. * Assumes values are constant unless proven otherwise; * Assumes BasicBlocks are dead unless proven otherwise; * Proves values to be constant, and replaces them with constants; * Proves conditional branches to be unconditional. Note that this pass has a habit of making definitions be dead. It is a good; idea to run a :ref:`DCE <passes-dce>` pass sometime after running this pass. .. _passes-simplifycfg:. ``simplifycfg``: Simplify the CFG; ---------------------------------. Performs dead code elimination and basic block merging. Specifically:. * Removes basic blocks with no predecessors.; * Merges a basic block into its predecessor if there is only one and the; predecessor only has one successor.; * Eliminates PHI nodes for basic blocks with a single predecessor.; * Eliminates a basic block that only contains an unconditional branch. ``sink``: Code sinking; ----------------------. This pass moves instructions into successor blocks, when possible, so that they; aren't executed on paths where their results aren't needed. .. _passes-simple-loop-unswitch:. ``simple-loop-unswitch``: Unswitch loops; ----------------------------------------. This pass transforms loops that contain branches on loop-invariant conditions; to have multiple loops. For example, it turns the left into the right code:. .. code-block:: c++. for (...) if (lic); A for (...); if (lic) A; B; C; B else; C for (.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:34717,simpl,simplifycfg,34717,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simplifycfg']
Usability," Similarly, the; `float`_, `double`_, and `int`_ parsers work like you would expect, using the; '``strtol``' and '``strtod``' C library calls to parse the string value into the; specified data type. With the declarations above, ""``compiler -help``"" emits this:. ::. USAGE: compiler [options] <input file>. OPTIONS:; -f - Enable binary output on terminals; -o - Override output filename; -quiet - Don't print informational messages; -help - display available options (-help-hidden for more). and ""``compiler -help-hidden``"" prints this:. ::. USAGE: compiler [options] <input file>. OPTIONS:; -f - Enable binary output on terminals; -o - Override output filename; -q - Don't print informational messages; -quiet - Don't print informational messages; -help - display available options (-help-hidden for more). This brief example has shown you how to use the '`cl::opt`_' class to parse; simple scalar command line arguments. In addition to simple scalar arguments,; the CommandLine library also provides primitives to support CommandLine option; `aliases`_, and `lists`_ of options. .. _aliases:. Argument Aliases; ----------------. So far, the example works well, except for the fact that we need to check the; quiet condition like this now:. .. code-block:: c++. ...; if (!Quiet && !Quiet2) printInformationalMessage(...);; ... ... which is a real pain! Instead of defining two values for the same; condition, we can use the ""`cl::alias`_"" class to make the ""``-q``"" option an; **alias** for the ""``-quiet``"" option, instead of providing a value itself:. .. code-block:: c++. cl::opt<bool> Force (""f"", cl::desc(""Overwrite output files""));; cl::opt<bool> Quiet (""quiet"", cl::desc(""Don't print informational messages""));; cl::alias QuietA(""q"", cl::desc(""Alias for -quiet""), cl::aliasopt(Quiet));. The third line (which is the only one we modified from above) defines a ""``-q``""; alias that updates the ""``Quiet``"" variable (as specified by the `cl::aliasopt`_; modifier) whenever it is specified. Becaus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:11603,simpl,simple,11603,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability," StreamerInfo record, which is written to disk; automatically when a new or modified file is closed. The StreamerInfo record is a list (ROOTIO class TList) of ""StreamerInfo"" objects; (ROOTIO class TStreamerInfo). There is one StreamerInfo object in the list for; every class used in the file in a data record, other than a core layer record.; There is no streamerinfo object for a class used in a core layer record unless the; class is also used elsewhere in a data record. When reading a self-identifying; object from a file, the system uses the StreamerInfo list to decompose the object; recursively into its simple data members. Each streamerinfo object is an array of ""streamer element"" objects, each of which; describes a base class of the object or a (non-static and non-transient) data member; of the object. If the base class or data member is itself a class, then there will; also be a streamerinfo object in the record for that class. In this way, each; class is recursively decomposed into its atomic elements, each of which is a simple; type (e.g. ""int""). A ""long"" or ""unsigned long"" member is always written; as an 8 byte quantity, even if it occupies only 4 bytes in memory. A data member of a class is marked transient on the line of its declaration by a; comment beginning with ""//!"". Such members are not written to disk, nor is there; any streamerinfo for such a member. A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a; pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL); is written. If the declaration line has a comment beginning with ""//->"", this indicates; that the pointer value will never be null, which allows a performance optimization.; Another optimization is that if two or more pointers pointing to the same object are; streamed in the same I/O operation, the object is written only once. The remaining; pointers ref",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md:7309,simpl,simple,7309,io/doc/TFile/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md,1,['simpl'],['simple']
Usability," Symbolic values. In the previous example where we tried to figure out what values a variable can; have, the analysis had to be seeded with a concrete value. What if there are no; assignments of concrete values in the program? We can still deduce some; interesting information by representing unknown input values symbolically, and; computing results as symbolic expressions:. ```c++; void PrintAbs(int x) {; int result;; if (x >= 0) {; result = x; // result is {x}; } else {; result = -x; // result is {-x}; }; print(result); // result is {x; -x}; }; ```. We can't say what specific value gets printed, but we know that it is either `x`; or `-x`. Dataflow analysis is an instance of abstract interpretation, and does not dictate; how exactly the lattice and transfer functions should be designed, beyond the; necessary conditions for the analysis to converge. Nevertheless, we can use; symbolic execution ideas to guide our design of the lattice and transfer; functions: lattice values can be symbolic expressions, and transfer functions; can construct more complex symbolic expressions from symbolic expressions that; represent arguments. See [this StackOverflow; discussion](https://cstheory.stackexchange.com/questions/19708/symbolic-execution-is-a-case-of-abstract-interpretation); for a further comparison of abstract interpretation and symbolic execution. ### Flow condition. A human can say about the previous example that the function returns `x` when; `x >= 0`, and `-x` when `x < 0`. We can make this conclusion programmatically by; tracking a flow condition. A flow condition is a predicate written in terms of; the program state that is true at a specific program point regardless of the; execution path that led to this statement. For example, the flow condition for; the program point right before evaluating `result = x` is `x >= 0`. If we enhance the lattice to be a set of pairs of values and predicates, the; dataflow analysis computes the following values:. ```c++; void PrintAbs(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:12009,guid,guide,12009,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['guid'],['guide']
Usability," The LLVM project is using GitHub Pull Requests for Code Reviews. This document; describes the typical workflow of creating a Pull Request and getting it reviewed; and accepted. This is meant as an overview of the GitHub workflow, for complete; documentation refer to `GitHub's documentation <https://docs.github.com/pull-requests>`_. GitHub Tools; ------------; You can interact with GitHub in several ways: via git command line tools,; the web browser, `GitHub Desktop <https://desktop.github.com/>`_, or the; `GitHub CLI <https://cli.github.com>`_. This guide will cover the git command line; tools and the GitHub CLI. The GitHub CLI (`gh`) will be most like the `arc` workflow and; recommended. Creating Pull Requests; ----------------------; Keep in mind that when creating a pull request, it should generally only contain one; self-contained commit initially.; This makes it easier for reviewers to understand the introduced changes and; provide feedback. It also helps maintain a clear and organized commit history; for the project. If you have multiple changes you want to introduce, it's; recommended to create separate pull requests for each change. Create a local branch per commit you want to submit and then push that branch; to your `fork <https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks>`_; of the llvm-project and; `create a pull request from the fork <https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork>`_.; As GitHub uses the first line of the commit message truncated to 72 characters; as the pull request title, you may have to edit to reword or to undo this; truncation. Creating Pull Requests with GitHub CLI; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; With the CLI it's enough to create the branch locally and then run:. ::. gh pr create. When prompted select to create and use your own fork and follow; the instructions to ad",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:1904,clear,clear,1904,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['clear'],['clear']
Usability," The histogram can be drawn also normalised, ROOT; automatically takes cares of the necessary rescaling. - line *24* to *30*: This small snippet shows how easy it is to access; the moments and associated errors of a histogram. ## Add and Divide Histograms ##. Quite a large number of operations can be carried out with histograms.; The most useful are addition and division. In the following macro we; will learn how to manage these procedures within ROOT. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro6.C; ```. The plots that you will obtain are shown in Figures [5.2](#f52) and [5.3](#f53). [f52]: figures/histo_sum.png ""f52""; <a name=""f52""></a>. ![The sum of two histograms.\label{f52}][f52]. [f53]: figures/histo_ratio.png ""f53""; <a name=""f53""></a>. ![The ratio of two histograms.\label{f53}][f53]. Some lines now need a bit of clarification:. - line *3*: Cling, as we know, is also able to interpret more than one; function per file. In this case the function simply sets up some; parameters to conveniently set the line of histograms. - line *19* to *21*: Some `C++` syntax for conditional; statements is used to fill the histograms with different numbers of; entries inside the loop. - line *30*: The sum of two histograms. A weight, which can be negative, can; be assigned to the added histogram. - line *41*: The division of two histograms is rather straightforward. - line *44* to *62*: When you draw two quantities and their ratios, it; is much better if all the information is condensed in one single; plot. These lines provide a skeleton to perform this operation. ## Two-dimensional Histograms ##. Two-dimensional histograms are a very useful tool, for example to; inspect correlations between variables. You can exploit the; bi-dimensional histogram classes provided by ROOT in a simple way.; Let's see how in this macro:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro7.C; ```. Two kinds of plots are provided within the code, the first one; containing three-dimensional repre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:2537,simpl,simply,2537,documentation/primer/histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md,1,['simpl'],['simply']
Usability," The performance of `PyROOT` when programming with ROOT in Python is; similar to that of Cling. Differences occur mainly because of differences; in the respective languages: C++ is much harder to parse, but once; parsed, it is much easier to optimize. Consequently, individual calls to; ROOT are typically faster from `PyROOT`, whereas loops are typically; slower. When programming in Python, the modus operandi is to consider; performance generally ""good enough"" on the outset, and when it turns out; that, it is not good enough; the performance critical part is converted; into C/C++ in an extension module. The school of thought where; pre-mature optimization is the root of all evil should find this way of; working very satisfying. In addition, if you look at their history, you; will see that many of the standard Python modules have followed this; path. Your code should always make maximum use of ROOT facilities; such that; most of the time is spending in compiled code. This goes even for very; simple things: e.g. do not compute invariant masses in Python, use; **`TLorentzVector`** instead. Moreover, before you start optimizing,; make sure that you have run a profiler to find out where the bottlenecks; are. Some performance, without cost in terms of programmer effort, may; be gained by using `psyco`, see the next link:; <http://psyco.sourceforge.net>, a Python just in time compiler (JIT).; Note, however, that `psyco` is limited to Intel i386 CPUs. Since `psyco`; optimizes Python, not `PyROOT` calls; it generally does not improve; performance that much if most of your code consists of ROOT API calls.; Mathematical computations in Python, on the other hand, benefit a lot. Every call to a Python member function results in a lookup of that; member function and an association of this method with `'self'`.; Furthermore, a temporary object is created during this process that is; discarded after the method call. In inner loops, it may be worth your; while (up to 30%), to short-cu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:23331,simpl,simple,23331,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['simpl'],['simple']
Usability," The table below divides the passes that LLVM provides into three categories.; Analysis passes compute information that other passes can use or for debugging; or program visualization purposes. Transform passes can use (or invalidate); the analysis passes. Transform passes all mutate the program in some way.; Utility passes provides some utility but don't otherwise fit categorization.; For example passes to extract functions to bitcode or write a module to bitcode; are neither analysis nor transform passes. The table of contents above; provides a quick summary of each pass and links to the more complete pass; description later in the document. Analysis Passes; ===============. This section describes the LLVM Analysis Passes. ``aa-eval``: Exhaustive Alias Analysis Precision Evaluator; ----------------------------------------------------------. This is a simple N^2 alias analysis accuracy evaluator. Basically, for each; function in the program, it simply queries to see how the alias analysis; implementation answers alias queries between each pair of pointers in the; function. This is inspired and adapted from code by: Naveen Neelakantam, Francesco; Spadini, and Wojciech Stryjewski. ``basic-aa``: Basic Alias Analysis (stateless AA impl); ------------------------------------------------------. A basic alias analysis pass that implements identities (two different globals; cannot alias, etc), but does no stateful analysis. ``basiccg``: Basic CallGraph Construction; -----------------------------------------. Yet to be written. .. _passes-da:. ``da``: Dependence Analysis; ---------------------------. Dependence analysis framework, which is used to detect dependences in memory; accesses. ``domfrontier``: Dominance Frontier Construction; ------------------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominator frontiers. ``domtree``: Dominator Tree Construction; ----------------------------------------. This pass i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:1358,simpl,simply,1358,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simply']
Usability," To create a concrete target-specific subclass of ``LLVMTargetMachine``, start; by copying an existing ``TargetMachine`` class and header. You should name the; files that you create to reflect your specific target. For instance, for the; SPARC target, name the files ``SparcTargetMachine.h`` and; ``SparcTargetMachine.cpp``. For a target machine ``XXX``, the implementation of ``XXXTargetMachine`` must; have access methods to obtain objects that represent target components. These; methods are named ``get*Info``, and are intended to obtain the instruction set; (``getInstrInfo``), register set (``getRegisterInfo``), stack frame layout; (``getFrameInfo``), and similar information. ``XXXTargetMachine`` must also; implement the ``getDataLayout`` method to access an object with target-specific; data characteristics, such as data type size and alignment requirements. For instance, for the SPARC target, the header file ``SparcTargetMachine.h``; declares prototypes for several ``get*Info`` and ``getDataLayout`` methods that; simply return a class member. .. code-block:: c++. namespace llvm {. class Module;. class SparcTargetMachine : public LLVMTargetMachine {; const DataLayout DataLayout; // Calculates type size & alignment; SparcSubtarget Subtarget;; SparcInstrInfo InstrInfo;; TargetFrameInfo FrameInfo;. protected:; virtual const TargetAsmInfo *createTargetAsmInfo() const;. public:; SparcTargetMachine(const Module &M, const std::string &FS);. virtual const SparcInstrInfo *getInstrInfo() const {return &InstrInfo; }; virtual const TargetFrameInfo *getFrameInfo() const {return &FrameInfo; }; virtual const TargetSubtarget *getSubtargetImpl() const{return &Subtarget; }; virtual const TargetRegisterInfo *getRegisterInfo() const {; return &InstrInfo.getRegisterInfo();; }; virtual const DataLayout *getDataLayout() const { return &DataLayout; }. // Pass Pipeline Configuration; virtual bool addInstSelector(PassManagerBase &PM, bool Fast);; virtual bool addPreEmitPass(PassManagerBase &PM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:9469,simpl,simply,9469,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['simpl'],['simply']
Usability," `GetListOfPrimitives()`, which returns a list of all the objects on; the pad. From the list you can select the object you need. #### Hiding an Object. Hiding an object in a pad can be made by removing it from the list of; objects owned by that pad. This list is accessible by the; `GetListOfPrimitives()` method of **`TPad`**. This method returns a; pointer to a **`TList`**. Suppose we get the pointer to the object, we; want to hide, call it `obj` (see paragraph above). We get the pointer to; the list:. ``` {.cpp}; root[] li = gPad->GetListOfPrimitives(); ```. Then remove the object from this list:. ``` {.cpp}; root[] li->Remove(obj); ```. The object will disappear from the pad as soon as the pad is updated; (try to resize it for example). If one wants to make the object; reappear:. ``` {.cpp}; root[] obj->Draw(); ```. Caution, this will not work with composed objects, for example many; histograms drawn on the same plot (with the option ""`same`""). There are; other ways! Try to use the method described here for simple objects. ### The Coordinate Systems of a Pad. There are coordinate systems in a **`TPad`**: user coordinates,; normalized coordinates (NDC), and pixel coordinates. ![Pad coordinate systems](pictures/080000A3.png). #### The User Coordinate System. The most common is the user coordinate system. Most methods of; **`TPad`** use the user coordinates, and all graphic primitives have; their parameters defined in terms of user coordinates. By default, when; an empty pad is drawn, the user coordinates are set to a range from 0 to; 1 starting at the lower left corner. At this point they are equivalent; of the NDC coordinates (see below). If you draw a high level graphical; object, such as a histogram or a function, the user coordinates are set; to the coordinates of the histogram. Therefore, when you set a point it; will be in the histogram coordinates. For a newly created blank pad, one may use `TPad::Range` to set the user; coordinate system. This function is de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:18577,simpl,simple,18577,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simple']
Usability," `GitHub Issues <https://github.com/llvm/llvm-project/issues>`_ that; result from your change. We prefer for this to be handled before submission but understand that it isn't; possible to test all of this for every submission. Our build bots and nightly; testing infrastructure normally finds these problems. A good rule of thumb is; to check the nightly testers for regressions the day after your change. Build; bots will directly email you if a group of commits that included yours caused a; failure. You are expected to check the build bot messages to see if they are; your fault and, if so, fix the breakage. Commits that violate these quality standards (e.g. are very broken) may be; reverted. This is necessary when the change blocks other developers from making; progress. The developer is welcome to re-commit the change after the problem has; been fixed. .. _commit messages:. Commit messages; ---------------. Although we don't enforce the format of commit messages, we prefer that; you follow these guidelines to help review, search in logs, email formatting; and so on. These guidelines are very similar to rules used by other open source; projects. Most importantly, the contents of the message should be carefully written to; convey the rationale of the change (without delving too much in detail). It; also should avoid being vague or overly specific. For example, ""bits were not; set right"" will leave the reviewer wondering about which bits, and why they; weren't right, while ""Correctly set overflow bits in TargetInfo"" conveys almost; all there is to the change. Below are some guidelines about the format of the message itself:. * Separate the commit message into title and body separated by a blank line. * If you're not the original author, ensure the 'Author' property of the commit is; set to the original author and the 'Committer' property is set to yourself.; You can use a command similar to; ``git commit --amend --author=""John Doe <jdoe@llvm.org>""`` to correct the; auth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:14932,guid,guidelines,14932,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['guid'],['guidelines']
Usability," ``AllowErrnoReadOutsideConditionExpressions`` option allows read of the; errno value if the value is not used in a condition (in ``if`` statements,; loops, conditional expressions, ``switch`` statements). For example ``errno``; can be stored into a variable without getting a warning by the checker. .. code-block:: c. int unsafe_errno_read(int sock, void *data, int data_size) {; if (send(sock, data, data_size, 0) != data_size) {; int err = errno;; // warning if 'AllowErrnoReadOutsideConditionExpressions' is false; // no warning if 'AllowErrnoReadOutsideConditionExpressions' is true; }; return 1;; }. Default value of this option is ``true``. This allows save of the errno value; for possible later error handling. **Limitations**. - Only the very first usage of ``errno`` is checked after an affected function; call. Value of ``errno`` is not followed when it is stored into a variable; or returned from a function.; - Documentation of function ``lseek`` is not clear about what happens if the; function returns different value than the expected file position but not -1.; To avoid possible false-positives ``errno`` is allowed to be used in this; case. .. _unix-Malloc:. unix.Malloc (C); """"""""""""""""""""""""""""""; Check for memory leaks, double free, and use-after-free problems. Traces memory managed by malloc()/free(). .. literalinclude:: checkers/unix_malloc_example.c; :language: c. .. _unix-MallocSizeof:. unix.MallocSizeof (C); """"""""""""""""""""""""""""""""""""""""""; Check for dubious ``malloc`` arguments involving ``sizeof``. .. code-block:: c. void test() {; long *p = malloc(sizeof(short));; // warn: result is converted to 'long *', which is; // incompatible with operand type 'short'; free(p);; }. .. _unix-MismatchedDeallocator:. unix.MismatchedDeallocator (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for mismatched deallocators. .. literalinclude:: checkers/mismatched_deallocator_example.cpp; :language: c. .. _unix-Vfork:. unix.Vfork (C); """"""""""""""""""""""""""""; Check for proper usage of ``vfork``.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:28470,clear,clear,28470,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['clear'],['clear']
Usability," ``Auto``). .. _BasedOnStyle:. **BasedOnStyle** (``String``) :ref:`¶ <BasedOnStyle>`; The style used for all options not specifically set in the configuration. This option is supported only in the :program:`clang-format` configuration; (both within ``-style='{...}'`` and the ``.clang-format`` file). Possible values:. * ``LLVM``; A style complying with the `LLVM coding standards; <https://llvm.org/docs/CodingStandards.html>`_; * ``Google``; A style complying with `Google's C++ style guide; <https://google.github.io/styleguide/cppguide.html>`_; * ``Chromium``; A style complying with `Chromium's style guide; <https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md>`_; * ``Mozilla``; A style complying with `Mozilla's style guide; <https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html>`_; * ``WebKit``; A style complying with `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ``Microsoft``; A style complying with `Microsoft's style guide; <https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference>`_; * ``GNU``; A style complying with the `GNU coding standards; <https://www.gnu.org/prep/standards/standards.html>`_; * ``InheritParentConfig``; Not a real style, but allows to use the ``.clang-format`` file from the; parent directory (or its parent if there is none). If there is no parent; file found it falls back to the ``fallback`` style, and applies the changes; to that. With this option you can overwrite some parts of your main style for your; subdirectories. This is also possible through the command line, e.g.:; ``--style={BasedOnStyle: InheritParentConfig, ColumnLimit: 20}``. .. START_FORMAT_STYLE_OPTIONS. .. _AccessModifierOffset:. **AccessModifierOffset** (``Integer``) :versionbadge:`clang-format 3.3` :ref:`¶ <AccessModifierOffset>`; The extra indent or outdent of access modifiers, e.g. ``public:``. .. _AlignAfterOpenBracket:. **AlignAfterOpenBracket** ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:6069,guid,guide,6069,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['guid'],['guide']
Usability," ```. However, most of the time, the user will not need **or want** such direct control over the type, but rather just let RooFit figure out what exact likelihood type (`RooAbsL` derived class) is best.; For this situation, the `buildLikelihood` function was created that can be used (for instance) as:; ``` {.cpp}; std::shared_ptr<RooFit::TestStatistics::RooAbsL> likelihood = RooFit::TestStatistics::buildLikelihood(pdf, data);; ```; `buildLikelihood` actually returns a `unique_ptr`; storing the result in a `shared_ptr` as done here is just one possible use-case. ### Usage example: Create a likelihood of a simultaneous PDF with constraint terms and global observables (and other optional arguments); The `RooAbsPdf::fitTo` or `RooAbsPdf::createNLL` interfaces could take in a set of optional parameters as `RooCmdArg` objects.; In `TestStatistics::buildLikelihood`, we have implemented 4 of these options as separate types while an additional one is supported as a simple string:; - `RooAbsL::Extended`: an enum class used to set extended term calculation `on`, `off` or use `Extended::Auto` to determine automatically based on the pdf whether to activate or not.; - `ConstrainedParameters`: Initialized with a `RooArgSet` of parameters that are constrained. Pdf components dependent on these alone are added to a subsidiary likelihood term.; - `ExternalConstraints`: Initialized with a `RooArgSet` of external constraint pdfs, i.e. constraints not necessarily in the pdf itself. These are always added to the subsidiary likelihood.; - `GlobalObservables`: Initialized with a `RooArgSet` of observables that have a constant value, independent of the dataset events. Pdf components dependent on these alone are added to the subsidiary likelihood. \note This overrides all other likelihood parameters (like those in the `ConstrainedParameters` argument) if present.; - Finally, a string argument `global_observables_tag` can be given, which should be set as attribute in any pdf component to indic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md:3710,simpl,simple,3710,roofit/doc/developers/test_statistics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md,1,['simpl'],['simple']
Usability," ``ar`` and ``nm``. Note that ld.bfd from binutils version 2.21.51.0.2; and above also supports LTO via plugins. However, usage of the LLVM; gold plugin with ld.bfd is not tested and therefore not officially; supported or recommended. As of LLVM 15, the gold plugin will ignore bitcode from the ``.llvmbc``; section inside of ELF object files. However, LTO with bitcode files; is still supported. .. _`gold linker`: http://sourceware.org/binutils; .. _`GCC LTO`: http://gcc.gnu.org/wiki/LinkTimeOptimization; .. _`gold plugin interface`: http://gcc.gnu.org/wiki/whopr/driver. .. _lto-how-to-build:. How to build it; ===============. You need to have gold with plugin support and build the LLVMgold plugin.; The gold linker is installed as ld.gold. To see whether gold is the default; on your system, run ``/usr/bin/ld -v``. It will report ""GNU; gold"" or else ""GNU ld"" if not. If gold is already installed at; ``/usr/bin/ld.gold``, one option is to simply make that the default by; backing up your existing ``/usr/bin/ld`` and creating a symbolic link; with ``ln -s /usr/bin/ld.gold /usr/bin/ld``. Alternatively, you can build; with clang's ``-fuse-ld=gold`` or add ``-fuse-ld=gold`` to LDFLAGS, which will; cause the clang driver to invoke ``/usr/bin/ld.gold`` directly. If you have gold installed, check for plugin support by running; ``/usr/bin/ld.gold -plugin``. If it complains ""missing argument"" then; you have plugin support. If not, and you get an error such as ""unknown option"",; then you will either need to build gold or install a version with plugin; support. * Download, configure and build gold with plugin support:. .. code-block:: bash. $ git clone --depth 1 git://sourceware.org/git/binutils-gdb.git binutils; $ mkdir build; $ cd build; $ ../binutils/configure --enable-gold --enable-plugins --disable-werror; $ make all-gold. That should leave you with ``build/gold/ld-new`` which supports; the ``-plugin`` option. Running ``make`` will additionally build; ``build/binutils/ar`` and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:1423,simpl,simply,1423,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['simpl'],['simply']
Usability," ``camelBack`` styles for; variable names [LattnerTransition]_. A code review to implement this is at https://reviews.llvm.org/D57896. Advantages; **********. * Very easy to implement initially. Disadvantages; *************. * Leads to inconsistency [BradburyConcern]_ [AminiInconsistent]_.; * Inconsistency means it will be hard to know at a guess what name a variable; will have [DasInconsistent]_ [CarruthInconsistent]_.; * Some large-scale renaming may happen anyway, leading to its disadvantages; without any mitigations. Big bang; --------. With this approach, variables will be renamed by an automated script in a series; of large commits. The principle advantage of this approach is that it minimises the cost of; inconsistency [BradburyTransition]_ [RobinsonTransition]_. It goes against a policy of avoiding large-scale reformatting of existing code; [GreeneDistinguish]_. It has been suggested that LLD would be a good starter project for the renaming; [Ueyama]_. Keeping git blame usable; ************************. ``git blame`` (or ``git annotate``) permits quickly identifying the commit that; changed a given line in a file. After renaming variables, many lines will show; as being changed by that one commit, requiring a further invocation of ``git; blame`` to identify prior, more interesting commits [GreeneGitBlame]_; [RicciAcronyms]_. **Mitigation**: `git-hyper-blame; <https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/git-hyper-blame.html>`_; can ignore or ""look through"" a given set of commits.; A ``.git-blame-ignore-revs`` file identifying the variable renaming commits; could be added to the LLVM git repository root directory.; It is being `investigated; <https://public-inbox.org/git/20190324235020.49706-1-michael@platin.gs/>`_; whether similar functionality could be added to ``git blame`` itself. Minimising cost of downstream merges; ************************************. There are many forks of LLVM with downstream changes. Mergin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:8987,usab,usable,8987,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['usab'],['usable']
Usability," ``llvm.coro.end`` without having first; reached a ``llvm.coro.suspend.retcon`` has undefined behavior. The remainder of this section describes the behavior under switched-resume; lowering. This intrinsic is lowered when a coroutine is split into; the start, resume and destroy parts. In the start part, it is a no-op,; in resume and destroy parts, it is replaced with `ret void` instruction and; the rest of the block containing `coro.end` instruction is discarded.; In landing pads it is replaced with an appropriate instruction to unwind to; caller. The handling of coro.end differs depending on whether the target is; using landingpad or WinEH exception model. For landingpad based exception model, it is expected that frontend uses the; `coro.end`_ intrinsic as follows:. .. code-block:: llvm. ehcleanup:; %InResumePart = call i1 @llvm.coro.end(ptr null, i1 true, token none); br i1 %InResumePart, label %eh.resume, label %cleanup.cont. cleanup.cont:; ; rest of the cleanup. eh.resume:; %exn = load ptr, ptr %exn.slot, align 8; %sel = load i32, ptr %ehselector.slot, align 4; %lpad.val = insertvalue { ptr, i32 } undef, ptr %exn, 0; %lpad.val29 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1; resume { ptr, i32 } %lpad.val29. The `CoroSpit` pass replaces `coro.end` with ``True`` in the resume functions,; thus leading to immediate unwind to the caller, whereas in start function it; is replaced with ``False``, thus allowing to proceed to the rest of the cleanup; code that is only needed during initial invocation of the coroutine. For Windows Exception handling model, a frontend should attach a funclet bundle; referring to an enclosing cleanuppad as follows:. .. code-block:: llvm. ehcleanup:; %tok = cleanuppad within none []; %unused = call i1 @llvm.coro.end(ptr null, i1 true, token none) [ ""funclet""(token %tok) ]; cleanupret from %tok unwind label %RestOfTheCleanup. The `CoroSplit` pass, if the funclet bundle is present, will insert; ``cleanupret from %tok unwind to caller`` befor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:44957,resume,resume,44957,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability," ``{r11}{r12},{r11}{r12}``, will assign r11 to both operands, not at all what was; intended.). Supported Constraint Code List; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""". The constraint codes are, in general, expected to behave the same way they do in; GCC. LLVM's support is often implemented on an 'as-needed' basis, to support C; inline asm code which was supported by GCC. A mismatch in behavior between LLVM; and GCC likely indicates a bug in LLVM. Some constraint codes are typically supported by all targets:. - ``r``: A register in the target's general purpose register class.; - ``m``: A memory address operand. It is target-specific what addressing modes; are supported, typical examples are register, or register + register offset,; or register + immediate offset (of some target-specific size).; - ``p``: An address operand. Similar to ``m``, but used by ""load address""; type instructions without touching memory.; - ``i``: An integer constant (of target-specific width). Allows either a simple; immediate, or a relocatable value.; - ``n``: An integer constant -- *not* including relocatable values.; - ``s``: An integer constant, but allowing *only* relocatable values.; - ``X``: Allows an operand of any kind, no constraint whatsoever. Typically; useful to pass a label for an asm branch or call. .. FIXME: but that surely isn't actually okay to jump out of an asm; block without telling llvm about the control transfer???). - ``{register-name}``: Requires exactly the named physical register. Other constraints are target-specific:. AArch64:. - ``z``: An immediate integer 0. Outputs ``WZR`` or ``XZR``, as appropriate.; - ``I``: An immediate integer valid for an ``ADD`` or ``SUB`` instruction,; i.e. 0 to 4095 with optional shift by 12.; - ``J``: An immediate integer that, when negated, is valid for an ``ADD`` or; ``SUB`` instruction, i.e. -1 to -4095 with optional left shift by 12.; - ``K``: An immediate integer that is valid for the 'bitmask immediate 32' of a; logical instruction like ``A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:221273,simpl,simple,221273,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability," `fLocalFrame`: indicates if any positions in the buffer (bounding; box and tessellation vertexes) are in local or master (world frame). - `fLocalMaster`: is a standard 4x4 translation matrix (OpenGL column; major ordering) for placing the object into the 3D master frame. If `fLocalFrame` is false, `fLocalMaster` should contain an identity; matrix. This is set by default, and can be reset using the; **`TBuffer3D::SetLocalMasterIdentity()` method.**. #### Bounding Boxes. You are not obliged to complete the `kBoundingBox` section, as any; viewer requiring one internally (GL Viewer) will build it if you do not; provide. However to do this the viewer will force you to provide the; (expensive) raw tessellation, and the resulting box will be axis aligned; with the overall scene, which is non-ideal for rotated shapes. As we; need to support orientated (rotated) bounding boxes, **`TBuffer3D`**; requires the 6 vertices of the box. We also provide a convenience; function, `TBuffer::SetAABoundingBox()`, for simpler case of setting an; axis aligned bounding box. The bounding box should be filled in same; frame (local / master) as the rest of the **`TBuffer3D`**, and; in accordance with `fLocalFrame` flag. A typical example from TGeoBBox::FillBuffer3D:. ``` {.cpp}; if (reqSections & TBuffer3D::kBoundingBox) {; Double_t halfLengths[3] = { fDX, fDY, fDZ };; buffer.SetAABoundingBox(fOrigin, halfLengths);; if (!buffer.fLocalFrame) {; TransformPoints(buffer.fBBVertex[0], 8);; }; buffer.SetSectionsValid(TBuffer3D::kBoundingBox);; }; ```. #### Logical and Physical Objects. Some viewers can support two types of object placement:. - Add object as a single independent entity in the world reference; frame - e.g. a sphere, radius `r`, at `x`, `y`, `z`. - Repeated placement (copying) in world frame of this locally unique; piece of geometry (described in local reference frame) e.g. define a; sphere `S` (radius `r`), place copy at `x1`, `y1`, `z1`, another; copy at `x2`, `y2`, `z2` etc. The sec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:133654,simpl,simpler,133654,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simpler']
Usability," a RooProdPdf or a RooProduct, in that; case the components of the product are cached instead of the product itself. You can disable this; new optimization by adding Optimize(1) to the RooAbsPdf::fitTo() command line (0 = no caching,; 1 = cache constant terms only, 2 = cache also variable terms according to above mentioned strategy (DEFAULT)). It is also possible to tune this 'cache-and-track' optimization to perform a more fine-grained caching; of components than Optimize(2) implements: to do so, call arg->setAttribute(""CacheAndTrack"") on each; pdf component that you'd like to be cache-and-tracked individually. New pdf/data attach mechanism in likelihood objects (RooAbsOptTestStatistic). The new mechanism only; reattaches the dataset branch buffers and not the RooRealVars representing the data. This new designs; allows for a much faster RooAbsTestStatistic::setData() implementation, which changes the dataset in; an existing likelihood object. This will speed up RooStats tools based on 'simple' likelihood models; substantially. Automatic detections of 'binned' pdfs and automatic generation of binned data in generate(). RooFit will; now automatically generate binned pdf shapes. Binned pdfs shapes are fundamentally RooHistPdf and RooHistFuncs; (with interpolation order set to zero). Products and sums of exclusively binned shapes are also recognized; as binned shapes. For such binned shapes generate() will now by default follow the 'binned' strategy ; -- that is, take the expectation value in each bin and sample a Poisson distribution from that -- rather; than follow the unbinned strategy. The rationale is that such datasets result in much faster likelihood; calculations (for nbin smaller than nevent). The optimization is also exact: the likelihood of a binned ; data using a binned pdf is identical to that of an unbinned dataset with a binned pdf. Nevertheless you can ; switch off this feature by passing AutoBinned(false) to RooAbsPdf::generate(). Mixed binned/unbinned",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html:4342,simpl,simple,4342,roofit/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html,1,['simpl'],['simple']
Usability," a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friedly syntax layer called `TikZ`. To generate a such file it is enough to do:. ```; gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");; ```. Then, the generated file (<tt>hpx.tex</tt>) can be included in a; LaTeX document (`simple.tex`) in the following way:. ```; \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}; ```. Note the two directive needed at the top of the LaTeX file:. ```; \usepackage{tikz}; \usetikzlibrary{patterns}; ```. Then including the picture in the document is done with the; `\input` directive. The command `pdflatex simple.tex` will generate the corresponding pdf; file `simple.pdf`. ### X11 fonts. - A coverity fix in `Rotated.cxx` had a side effect on rotated text; drawn with X11 fonts. ### TCanvas and TPad. - `TPad::SaveAs` produces named macros in .C files.; - Change the way the string input is done in the Pad toolbar for text; and Pave Label. It doesn't use anymore the `TGX11` function `RequestString`.; Now the text appears directly as it will show and it is possible to; enter several text string. The input is not block in the `RequestString` event loop.; - The toolbar methods now work without XOR mode (useful for OpenGL()).; - A new ""vertex compression"" algorithm added to deal with complex histograms; (thousands/millions of bins - polygons with thousands/millions of vertices) -; optimization/fix for X11 crashes. ### TGaxis and TAxis. - The time axis behavior should now be correct along time zone and; summer saving time. A fix has been done with the of Philippe Gras; (CEA Saclay. IRFU/SEDI) and Julian Sitarek (IFAE). Time axis; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md:1785,simpl,simple,1785,graf2d/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md,1,['simpl'],['simple']
Usability," a ``catchret`` instruction, which is a terminator indicating where in; the function control is returned to. A cleanup handler which reaches its end; by normal execution executes a ``cleanupret`` instruction, which is a terminator; indicating where the active exception will unwind to next. Each of these new EH pad instructions has a way to identify which action should; be considered after this action. The ``catchswitch`` instruction is a terminator; and has an unwind destination operand analogous to the unwind destination of an; invoke. The ``cleanuppad`` instruction is not; a terminator, so the unwind destination is stored on the ``cleanupret``; instruction instead. Successfully executing a catch handler should resume; normal control flow, so neither ``catchpad`` nor ``catchret`` instructions can; unwind. All of these ""unwind edges"" may refer to a basic block that contains an; EH pad instruction, or they may unwind to the caller. Unwinding to the caller; has roughly the same semantics as the ``resume`` instruction in the landingpad; model. When inlining through an invoke, instructions that unwind to the caller; are hooked up to unwind to the unwind destination of the call site. Putting things together, here is a hypothetical lowering of some C++ that uses; all of the new IR instructions:. .. code-block:: c. struct Cleanup {; Cleanup();; ~Cleanup();; int m;; };; void may_throw();; int f() noexcept {; try {; Cleanup obj;; may_throw();; } catch (int e) {; may_throw();; return e;; }; return 0;; }. .. code-block:: text. define i32 @f() nounwind personality ptr @__CxxFrameHandler3 {; entry:; %obj = alloca %struct.Cleanup, align 4; %e = alloca i32, align 4; %call = invoke ptr @""??0Cleanup@@QEAA@XZ""(ptr nonnull %obj); to label %invoke.cont unwind label %lpad.catch. invoke.cont: ; preds = %entry; invoke void @""?may_throw@@YAXXZ""(); to label %invoke.cont.2 unwind label %lpad.cleanup. invoke.cont.2: ; preds = %invoke.cont; call void @""??_DCleanup@@QEAA@XZ""(ptr nonnull %obj) n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:27371,resume,resume,27371,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['resume'],['resume']
Usability, a braced-init-list; Unknown. 2319; drafting; Nested brace initialization from same type; Not resolved. 2320; extension; constexpr if and boolean conversions; Extension. 2321; CD5; Conditional operator and cv-qualified class prvalues; Unknown. 2322; CD5; Substitution failure and lexical order; Unknown. 2323; C++20; Expunge POD; Unknown. 2324; drafting; Size of base class subobject; Not resolved. 2325; drafting; std::launder and reuse of character buffers; Not resolved. 2326; dup; Type deduction with initializer list containing ambiguous functions; Unknown. 2327; drafting; Copy elision for direct-initialization with a conversion function; Not resolved. 2328; drafting; Unclear presentation style of template argument deduction rules; Not resolved. 2329; drafting; Virtual base classes and generated assignment operators; Not resolved. 2330; CD5; Missing references to variable templates; Unknown. 2331; CD6; Redundancy in description of class scope; N/A. 2332; CD5; template-name as simple-type-name vs injected-class-name; Unknown. 2333; CD6; Escape sequences in UTF-8 character literals; Unknown. 2334; open; Creation of objects by typeid; Not resolved. 2335; drafting; Deduced return types vs member types; No. 2336; CD5; Destructor characteristics vs potentially-constructed subobjects; Unknown. 2337; open; Incorrect implication of logic ladder for conversion sequence tiebreakers; Not resolved. 2338; CD5; Undefined behavior converting to short enums with fixed underlying types; Clang 12. 2339; CD5; Underspecified template arguments in structured bindings; Unknown. 2340; open; Reference collapsing and structured bindings; Not resolved. 2341; CD5; Structured bindings with static storage duration; Unknown. 2342; CD5; Reference reinterpret_cast and pointer-interconvertibility; Unknown. 2343; C++20; void* non-type template parameters; Unknown. 2344; NAD; Redeclaration of names in init-statements; Unknown. 2345; CD5; Jumping across initializers in init-statements and conditions; Un,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:159211,simpl,simple-type-name,159211,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['simpl'],['simple-type-name']
Usability," a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` values to exit codes using the; ``setExitCodeMapper`` method:. .. code-block:: c++. int main(int argc, char *argv[]) {; ExitOnErr.setBanner(std::string(argv[0]) + "" error:"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:32046,simpl,simplify,32046,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simplify']
Usability," a widget that shows that an operation is in progress; and how much time is left. It is a long rectangular bar, initially; empty, that fills with a color as a process is being performed. The; filled-in area indicates the percentage of the process that has been; completed. You should use this widget for waits exceeding `one minute`.; For a very time consuming operation it is better to break the operation; into subtasks and provide a progress bar for each of them. ![](pictures/0200021E.jpg). A progress bar may be oriented horizontally or vertically. The; horizontally oriented progress bar fills with a color from left to; right; the vertically oriented - from bottom to top. A percent complete; message provides an indication of the completed part of the process. It; is a good practice to include some descriptive text of the process to; keep users informed and entertained while they are waiting for process; completion. The picture below shows the progress bars you can create using the; classes **`TGProgressBar`**, **`TGHProgressBar`**, and; **`TGHProgressBar`**. ``` {.cpp}; // vertical frame with three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; fHProg2->SetBarColor(""lightblue"");; fHProg2->ShowPosition(kTRUE,kFALSE,""%.0f events"");; fHProg3 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg3->SetFillType(TGProgressBar::kBlockFill);. vframe->AddFrame(fHProg1,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->AddFrame(fHProg2,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->AddFrame(fHProg3,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->Resize(200, 200);; ```. ### Static Widgets. The classes **`TGLabel`** and **`TGIcon`** show some in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:88726,progress bar,progress bars,88726,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['progress bar'],['progress bars']
Usability," accepted without being in the ``-march`` string. LLVM also allows the explicit specification of the extensions in an ``-march`` string. .. _riscv-profiles-extensions-note:. ``Za128rs``, ``Za64rs``, ``Zic64b``, ``Ziccamoa``, ``Ziccif``, ``Zicclsm``, ``Ziccrse``; These extensions are defined as part of the `RISC-V Profiles specification <https://github.com/riscv/riscv-profiles/releases/tag/v1.0>`_. They do not introduce any new features themselves, but instead describe existing hardware features. Experimental Extensions; =======================. LLVM supports (to various degrees) a number of experimental extensions. All experimental extensions have ``experimental-`` as a prefix. There is explicitly no compatibility promised between versions of the toolchain, and regular users are strongly advised *not* to make use of experimental extensions before they reach ratification. The primary goal of experimental support is to assist in the process of ratification by providing an existence proof of an implementation, and simplifying efforts to validate the value of a proposed extension against large code bases. Experimental extensions are expected to either transition to ratified status, or be eventually removed. The decision on whether to accept an experimental extension is currently done on an entirely case by case basis; if you want to propose one, attending the bi-weekly RISC-V sync-up call is strongly advised. ``experimental-zacas``; LLVM implements the `1.0-rc1 draft specification <https://github.com/riscv/riscv-zacas/releases/tag/v1.0-rc1>`_. ``experimental-zfbfmin``, ``experimental-zvfbfmin``, ``experimental-zvfbfwma``; LLVM implements assembler support for the `1.0.0-rc2 specification <https://github.com/riscv/riscv-bfloat16/releases/tag/v59042fc71c31a9bcb2f1957621c960ed36fac401>`_. ``experimental-zicfilp``, ``experimental-zicfiss``; LLVM implements the `0.4 draft specification <https://github.com/riscv/riscv-cfi/releases/tag/v0.4.0>`__. ``experimental-ztso``; LLVM im",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst:9957,simpl,simplifying,9957,interpreter/llvm-project/llvm/docs/RISCVUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/RISCVUsage.rst,1,['simpl'],['simplifying']
Usability," all greek and math symbols are printed correctly by `TTexDump`.; - Implement dummy operators `#mbox` and `#hbox` to improve the compatibility; between `TLatex`, `TMathText` and `TTexDump`.; - Some operators like `#minus`, `#plus`, `#mp`, `#hbar` etc ...; ignored the color defined by the operator `#color`.; - With the Cocoa backend on Mac the text string were a bit too large; compared to the TTF rendering. ### TPave. - Implement `SetX1()` etc ... for `TPave` and inherited classes to make sure the; NDC coordinates are also defined. ### TLinearGradient and TRadialGradient. - Two new classes to support color gradient: `TLinearGradient` and `TRadialGradient`.; Both classes inherit from `TColor` and can be used the same way as ROOT's; standard colors in `TAttFill` (`SetFillColor(newColorIndex)`).; Gradient fill can be created using either RGBA values directly, or from; color indices (colors from the ROOT's color table).; - TRadialGradient supports a simple radial gradient (center + radius); and an ""extended"" radial gradient (starting/ending points + two radii).; - The new gradient fill option is available either with OpenGL (""gl-in-pad""); or with a Cocoa backend (OS X only).; - Please note, at the moment, a color gradient can not be saved; in a ROOT file or a pdf/ps file. It can be saved as an image (png/jpg etc.).; - There are several demos in the tutorials/cocoa and tutorials/gl sub-directories; explaining how to use these new classes:; * grad.C; * grad2.C; * radialgradients.C. ![TRadialGradient example](ellipses.png ""TEllipse objects with a radial gradient fill""). ![TLinearGradient example](lingrad.png ""Two histograms with a linear gradient fill and transparency""). ![Gradient example](mixgrad.png ""TPie with a radial fill + a linear gradient fill as a background""). ### TGCocoa and TGQuartz. - Correct font metrics for greek and math symbols are implemented now.; - Added support for linear and radial color gradients (see the notes above).; - ""GL-in-pad"" implemented for C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md:8054,simpl,simple,8054,graf2d/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md,1,['simpl'],['simple']
Usability," all-zero. (""Preferred NaN"" case); - The quiet bit is set and the payload is copied from any input operand that is; a NaN. (""Quieting NaN propagation"" case); - The quiet bit and payload are copied from any input operand that is a NaN.; (""Unchanged NaN propagation"" case); - The quiet bit is set and the payload is picked from a target-specific set of; ""extra"" possible NaN payloads. The set can depend on the input operand values.; This set is empty on x86 and ARM, but can be non-empty on other architectures.; (For instance, on wasm, if any input NaN does not have the preferred all-zero; payload or any input NaN is an SNaN, then this set contains all possible; payloads; otherwise, it is empty. On SPARC, this set consists of the all-one; payload.). In particular, if all input NaNs are quiet (or if there are no input NaNs), then; the output NaN is definitely quiet. Signaling NaN outputs can only occur if they; are provided as an input value. For example, ""fmul SNaN, 1.0"" may be simplified; to SNaN rather than QNaN. Similarly, if all input NaNs are preferred (or if; there are no input NaNs) and the target does not have any ""extra"" NaN payloads,; then the output NaN is guaranteed to be preferred. Floating-point math operations are allowed to treat all NaNs as if they were; quiet NaNs. For example, ""pow(1.0, SNaN)"" may be simplified to 1.0. Code that requires different behavior than this should use the; :ref:`Constrained Floating-Point Intrinsics <constrainedfp>`.; In particular, constrained intrinsics rule out the ""Unchanged NaN propagation""; case; they are guaranteed to return a QNaN. Unfortunately, due to hard-or-impossible-to-fix issues, LLVM violates its own; specification on some architectures:. - x86-32 without SSE2 enabled may convert floating-point values to x86_fp80 and; back when performing floating-point math operations; this can lead to results; with different precision than expected and it can alter NaN values. Since; optimizations can make contradicting assumpt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:159869,simpl,simplified,159869,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simplified']
Usability," already obvious from the context. Another time when ``auto`` works well; for these purposes is when the type would have been abstracted away anyways,; often behind a container's typedef such as ``std::vector<T>::iterator``. Similarly, C++14 adds generic lambda expressions where parameter types can be; ``auto``. Use these where you would have used a template. Beware unnecessary copies with ``auto``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The convenience of ``auto`` makes it easy to forget that its default behavior; is a copy. Particularly in range-based ``for`` loops, careless copies are; expensive. Use ``auto &`` for values and ``auto *`` for pointers unless you need to make a; copy. .. code-block:: c++. // Typically there's no reason to copy.; for (const auto &Val : Container) observe(Val);; for (auto &Val : Container) Val.change();. // Remove the reference if you really want a new copy.; for (auto Val : Container) { Val.change(); saveSomewhere(Val); }. // Copy pointers, but make it clear that they're pointers.; for (const auto *Ptr : Container) observe(*Ptr);; for (auto *Ptr : Container) Ptr->change();. Beware of non-determinism due to ordering of pointers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In general, there is no relative ordering among pointers. As a result,; when unordered containers like sets and maps are used with pointer keys; the iteration order is undefined. Hence, iterating such containers may; result in non-deterministic code generation. While the generated code; might work correctly, non-determinism can make it harder to reproduce bugs and; debug the compiler. In case an ordered result is expected, remember to; sort an unordered container before iteration. Or use ordered containers; like ``vector``/``MapVector``/``SetVector`` if you want to iterate pointer; keys. Beware of non-deterministic sorting order of equal elements; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``std::sort`` uses a non-stable sorting algorith",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:27739,clear,clear,27739,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['clear'],['clear']
Usability," amplifies the analyzer's ability to find issues.; Many bug fixes to the malloc/free checker.; Support for new Objective-C NSArray/NSDictionary/NSNumber literals syntax, and Objective-C container subscripting. NOTE: This build contains new interprocedural analysis that allows the analyzer to find more complicated bugs that span function boundaries. It may have problems, performance issues, etc. We'd like to hear about them. checker-261; built: February 22, 2012; highlights:. Contains a new experimental malloc/free checker.; Better support for projects using ARC.; Warns about null pointers passed as arguments to C string functions.; Warns about common anti-patterns in 'strncat' size argument, which can lead to buffer overflows.; set-xcode-analyzer now supports self-contained Xcode.app (Xcode 4.3 and later).; Contains a newer version of the analyzer than Xcode 4.3.; Misc. bug fixes and performance work. checker-260; built: January 25, 2012; highlights:; This is essentially the same as checker-259, but enables the following experimental checkers (please provide feedback):. Warns about unsafe uses of CFArrayCreate, CFSetCreate, and CFDictionaryCreate; Warns about unsafe uses of getpw, gets, which are sources of buffer overflows; Warns about unsafe uses of mktemp and mktemps, which can lead to insecure temporary files; Warns about unsafe uses of vfork, which is insecure to use; Warns about not checking the return values of setuid, setgid, seteuid, setegid, setreuid, setregid (another security issue). checker-259; built: January 25, 2012; highlights:. Contains a newer version of the analyzer than the one shipped in Xcode 4.2.; Significant performance optimizations to reduce memory usage of the analyzer.; Tweaks to scan-build to have it work more easily with Xcode projects using Clang.; Numerous bug fixes to better support code using ARC. checker-258; built: October 13, 2011; highlights:. Contains a newer version of the analyzer than the one shipped in Xcode 4.2.; Adds a n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html:9423,feedback,feedback,9423,interpreter/llvm-project/clang/www/analyzer/release_notes.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html,1,['feedback'],['feedback']
Usability," an index, the resume and destroy; function pointers are updated at every suspend. Early testing showed that the; current approach is easier on the optimizer than the latter so it is a; lowering strategy implemented at the moment. Distinct Save and Suspend; -------------------------. In the previous example, setting a resume index (or some other state change that; needs to happen to prepare a coroutine for resumption) happens at the same time as; a suspension of a coroutine. However, in certain cases, it is necessary to control; when coroutine is prepared for resumption and when it is suspended. In the following example, a coroutine represents some activity that is driven; by completions of asynchronous operations `async_op1` and `async_op2` which get; a coroutine handle as a parameter and resume the coroutine once async; operation is finished. .. code-block:: text. void g() {; for (;;); if (cond()) {; async_op1(<coroutine-handle>); // will resume once async_op1 completes; <suspend>; do_one();; }; else {; async_op2(<coroutine-handle>); // will resume once async_op2 completes; <suspend>; do_two();; }; }; }. In this case, coroutine should be ready for resumption prior to a call to; `async_op1` and `async_op2`. The `coro.save`_ intrinsic is used to indicate a; point when coroutine should be ready for resumption (namely, when a resume index; should be stored in the coroutine frame, so that it can be resumed at the; correct resume point):. .. code-block:: llvm. if.true:; %save1 = call token @llvm.coro.save(ptr %hdl); call void @async_op1(ptr %hdl); %suspend1 = call i1 @llvm.coro.suspend(token %save1, i1 false); switch i8 %suspend1, label %suspend [i8 0, label %resume1; i8 1, label %cleanup]; if.false:; %save2 = call token @llvm.coro.save(ptr %hdl); call void @async_op2(ptr %hdl); %suspend2 = call i1 @llvm.coro.suspend(token %save2, i1 false); switch i8 %suspend2, label %suspend [i8 0, label %resume2; i8 1, label %cleanup]. .. _coroutine promise:. Coroutine Promise; ------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:21213,resume,resume,21213,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,2,['resume'],['resume']
Usability," and B may or may not be from the same ASTContext.; - if A == X and B == Y (pointer equivalency) then (there is a cycle during the; traverse). - A and B are structurally equivalent if and only if. - All dependent nodes on the path from <A,B> to <X,Y> are structurally; equivalent. When we compare two classes or enums and one of them is incomplete or has; unloaded external lexical declarations then we cannot descend to compare their; contained declarations. So in these cases they are considered equal if they; have the same names. This is the way how we compare forward declarations with; definitions. .. TODO Should we elaborate the actual implementation of the graph traversal,; .. which is a very weird BFS traversal?. Redeclaration Chains; ^^^^^^^^^^^^^^^^^^^^. The early version of the ``ASTImporter``'s merge mechanism squashed the; declarations, i.e. it aimed to have only one declaration instead of maintaining; a whole redeclaration chain. This early approach simply skipped importing a; function prototype, but it imported a definition. To demonstrate the problem; with this approach let's consider an empty ""to"" context and the following; ``virtual`` function declarations of ``f`` in the ""from"" context:. .. code-block:: c++. struct B { virtual void f(); };; void B::f() {} // <-- let's import this definition. If we imported the definition with the ""squashing"" approach then we would; end-up having one declaration which is indeed a definition, but ``isVirtual()``; returns ``false`` for it. The reason is that the definition is indeed not; virtual, it is the property of the prototype!. Consequently, we must either set the virtual flag for the definition (but then; we create a malformed AST which the parser would never create), or we import; the whole redeclaration chain of the function. The most recent version of the; ``ASTImporter`` uses the latter mechanism. We do import all function; declarations - regardless if they are definitions or prototypes - in the order; as they a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:94415,simpl,simply,94415,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simply']
Usability," and it will take longer to generate, but it provides the most; opportunity for the compiler to optimize. The guidance for minimizing distribution size is to dynamically link LLVM and; Clang libraries into the tools to reduce code duplication. This will come at a; substantial performance penalty to the generated binary both because it reduces; optimization opportunity, and because dynamic linking requires resolving symbols; at process launch time, which can be very slow for C++ code. .. _shared_libs:. .. warning::; One very important note: Distributions should never be built using the; *BUILD_SHARED_LIBS* CMake option. That option exists for optimizing developer; workflow only. Due to design and implementation decisions, LLVM relies on; global data which can end up being duplicated across shared libraries; resulting in bugs. As such this is not a safe way to distribute LLVM or; LLVM-based tools. The simplest example of building a distribution with reasonable performance is; captured in the DistributionExample CMake cache file located at; clang/cmake/caches/DistributionExample.cmake. The following command will perform; and install the distribution build:. .. code-block:: console. $ cmake -G Ninja -C <path to clang>/cmake/caches/DistributionExample.cmake <path to LLVM source>; $ ninja stage2-distribution; $ ninja stage2-install-distribution. Difference between ``install`` and ``install-distribution``; -----------------------------------------------------------. One subtle but important thing to note is the difference between the ``install``; and ``install-distribution`` targets. The ``install`` target is expected to; install every part of LLVM that your build is configured to generate except the; LLVM testing tools. Alternatively the ``install-distribution`` target, which is; recommended for building distributions, only installs specific parts of LLVM as; specified at configuration time by *LLVM_DISTRIBUTION_COMPONENTS*. Additionally by default the ``install`` target w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:2494,simpl,simplest,2494,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['simpl'],['simplest']
Usability," and may have a; greater performance impact since pointer reads are more frequent than writes. .. _plugin:. .. _builtin-gc-strategies:. Built In GC Strategies; ======================. LLVM includes built in support for several varieties of garbage collectors. The Shadow Stack GC; ----------------------. To use this collector strategy, mark your functions with:. .. code-block:: c++. F.setGC(""shadow-stack"");. Unlike many GC algorithms which rely on a cooperative code generator to compile; stack maps, this algorithm carefully maintains a linked list of stack roots; [:ref:`Henderson2002 <henderson02>`]. This so-called ""shadow stack"" mirrors the; machine stack. Maintaining this data structure is slower than using a stack map; compiled into the executable as constant data, but has a significant portability; advantage because it requires no special support from the target code generator,; and does not require tricky platform-specific code to crawl the machine stack. The tradeoff for this simplicity and portability is:. * High overhead per function call. * Not thread-safe. Still, it's an easy way to get started. After your compiler and runtime are up; and running, writing a :ref:`plugin <plugin>` will allow you to take advantage; of :ref:`more advanced GC features <collector-algos>` of LLVM in order to; improve performance. The shadow stack doesn't imply a memory allocation algorithm. A semispace; collector or building atop ``malloc`` are great places to start, and can be; implemented with very little code. When it comes time to collect, however, your runtime needs to traverse the stack; roots, and for this it needs to integrate with the shadow stack. Luckily, doing; so is very simple. (This code is heavily commented to help you understand the; data structure, but there are only 20 lines of meaningful code.). .. code-block:: c++. /// The map for a single function's stack frame. One of these is; /// compiled as constant data into the executable for each function.; ///; /// S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:16708,simpl,simplicity,16708,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['simpl'],['simplicity']
Usability," and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3361,guid,guide,3361,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['guid'],['guide']
Usability," apply button is; pressed, the changes are applied to the edited shape and drawn. The; ""*Undo*"" button becomes active after the first modification has been; applied. It allows restoring the initial parameters of the shape. NOTE: In this version the ""*Undo*"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection of components before creating the object. ### Editing Volumes. Volumes are hierarchical components in the geometry, therefore their; editor is more complex. It provides the following functionalities:. - *General*. This category allows changing the name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""*Position*"" allows editing the; positioning matrix of a given node. ![Setting volume properties and modifying volume hierarchy](pictur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:171751,undo,undoable,171751,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['undo'],['undoable']
Usability," are equal. By overriding the following **`TObject`** member; functions, you can change the behavior of objects in collections:. - `IsEqual()`is used by the `FindObject() `collection method. By; default, `IsEqual()` compares the two object pointers. - `Compare()`returns -1, 0 or 1 depending if the object is smaller,; equal or larger than the other object. By default, a **`TObject`**; has not a valid `Compare()` method. - `IsSortable() `returns true if the class is sort able (i.e. if it; has a valid `Compare(`) method). By default, a **`TObject`** is not; sort able. - `Hash() `returns a hash value. It needs to be implemented if an; object has to be stored in a collection using a hashing technique,; like **`THashTable`**, **`THashList`** and **`TMap`**. By default,; `Hash(`) returns the address of the object. It is essential to; choose a good hash function. The example below shows how to use and override these member functions. ``` {.cpp}; class TObjNum : public TObject {; private:; Int_t num; // TObjNum is a simple container for an integer.; public:; TObjNum(Int_t i = 0) : num(i) { }; ~TObjNum() { }; void SetNum(Int_t i) { num = i; }; Int_t GetNum() const { return num; }; void Print(Option_t *) const; { printf(""num = %dn"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ((TObjNum*)obj)->num; }; Bool_t IsSortable() const { return kTRUE; }; Int_t Compare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Generic Iterator. As stated above, the **`TIterator`** class is abstract; it is not; possible to create **`TIterator`** objects. However, it should be; possible to write generic code to process all members of a collection so; there is a need for a generic iterator object. A **`TIter`** object acts; as generic iterator. It provides the same `Next()` and `Reset()` methods; as **`TIterator`** although it has no ide",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:9767,simpl,simple,9767,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['simpl'],['simple']
Usability," argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of; the object, the object is initially marked as dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. After '``llvm.lifetime.start``', the stack object that ``ptr`` points is marked; as alive and has an uninitialized value.; The stack object is marked as dead when either; :ref:`llvm.lifetime.end <int_lifeend>` to the alloca is executed or the; function returns. After :ref:`llvm.lifetime.end <int_lifeend>` is called,; '``llvm.lifetime.start``' on the stack object can be called again.; The second '``llvm.lifetime.start``' call marks the object as alive, but it; does not change the address of the object. If ``ptr`` is a non-stack-allocated object, it does not point to the first; byte of the object or it is a stack object that is already alive, it simply; fills all bytes of the object with ``poison``. .. _int_lifeend:. '``llvm.lifetime.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.lifetime.end(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.lifetime.end``' intrinsic specifies the end of a memory object's; lifetime. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". If ``ptr`` is a stack-allocated object and it points to the first byte of the; object, the object is dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. Calling ``llvm.lifetime.end`` on an already dead alloca is no-op. If ``ptr`` is a non-stack-all",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:862495,simpl,simply,862495,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability," arguments to variable symbol table.; NamedValues[std::string(Arg.getName())] = Alloca;; }. Here we're first creating the variable, giving it the scope (``SP``),; the name, source location, type, and since it's an argument, the argument; index. Next, we create an ``lvm.dbg.declare`` call to indicate at the IR; level that we've got a variable in an alloca (and it gives a starting; location for the variable), and setting a source location for the; beginning of the scope on the declare. One interesting thing to note at this point is that various debuggers have; assumptions based on how code and debug information was generated for them; in the past. In this case we need to do a little bit of a hack to avoid; generating line information for the function prologue so that the debugger; knows to skip over those instructions when setting a breakpoint. So in; ``FunctionAST::CodeGen`` we add some more lines:. .. code-block:: c++. // Unset the location for the prologue emission (leading instructions with no; // location in a function are considered part of the prologue and the debugger; // will run past them when breaking on a function); KSDbgInfo.emitLocation(nullptr);. and then emit a new location when we actually start generating code for the; body of the function:. .. code-block:: c++. KSDbgInfo.emitLocation(Body.get());. With this we have enough debug information to set breakpoints in functions,; print out argument variables, and call functions. Not too bad for just a; few simple lines of code!. Full Code Listing; =================. Here is the complete code listing for our running example, enhanced with; debug information. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../../examples/Kaleidoscope/Chapter9/toy.cpp; :language: c++. `Next: Conclusion and other useful LLVM tidbits <LangImpl10.html>`_. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:15440,simpl,simple,15440,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,1,['simpl'],['simple']
Usability," as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data->Draw(""Current/Potential:Temperature""); ```. It should have become clear from these examples how to navigate in such; a multi-dimensional space of variables and unveil relations between; variables using n-tuples. ### Reading N-tuples. For completeness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the content of a n-tuple:; after loading the n-tuple, its branches are assigned to variables and; `GetEntry(long)` automatically fills them with the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file_advanced.C; ```. The `Branch()` function requires a pointer to a variable and a; definition of the variable type. The following table lists some of the possible; values.; Please note that ROOT is not checking the input and mistakes are likely; to result in serious problems. This holds especially if values are read; as another type than they have been written, e.g. when storing a; variable as float and reading it as double. List of variable types that can be used to define the type of a bra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:4490,clear,clear,4490,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['clear'],['clear']
Usability," as the first line of the; method. If that still doesn't remove enough, then change the caller of; ``InstCombiner::DoOneIteration``, ``InstCombiner::runOnFunction`` to limit the; number of iterations. You may also find it useful to use ""``-stats``"" now to see what parts of; instcombine are firing. This can guide where to put additional reporting code. At this point, if the amount of transformations is still too large, then; inserting code to limit whether or not to execute the body of the code in the; visit function can be helpful. Add a static counter which is incremented on; every invocation of the function. Then add code which simply returns false on; desired ranges. For example:. .. code-block:: c++. static int calledCount = 0;; calledCount++;; LLVM_DEBUG(if (calledCount < 212) return false);; LLVM_DEBUG(if (calledCount > 217) return false);; LLVM_DEBUG(if (calledCount == 213) return false);; LLVM_DEBUG(if (calledCount == 214) return false);; LLVM_DEBUG(if (calledCount == 215) return false);; LLVM_DEBUG(if (calledCount == 216) return false);; LLVM_DEBUG(dbgs() << ""visitXOR calledCount: "" << calledCount << ""\n"");; LLVM_DEBUG(dbgs() << ""I: ""; I->dump());. could be added to ``visitXOR`` to limit ``visitXor`` to being applied only to; calls 212 and 217. This is from an actual test case and raises an important; point---a simple binary search may not be sufficient, as transformations that; interact may require isolating more than one call. In TargetLowering, use; ``return SDNode();`` instead of ``return false;``. Now that the number of transformations is down to a manageable number, try; examining the output to see if you can figure out which transformations are; being done. If that can be figured out, then do the usual debugging. If which; code corresponds to the transformation being performed isn't obvious, set a; breakpoint after the call count based disabling and step through the code.; Alternatively, you can use ""``printf``"" style debugging to report waypoints.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst:10718,simpl,simple,10718,interpreter/llvm-project/llvm/docs/Bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst,1,['simpl'],['simple']
Usability," avoid bias. Those two datasets; can be built aside and then given to the network, or can be built from; a standard expression. By default, half of the events are put in both; datasets. ``` {.cpp}; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; ```. The method `TMultiLayerPerceptron::SetLearningMethod()` defines the; learning method. Learning methods are:. ```; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; ```. The training can start with; `TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options).` The; first argument is the number of epochs while option is a string that; can contain ""`text`"" (simple text output), ""`graph`"" (evaluating; graphical training curves), ""`update` `=` `X`"" (step for the; text/graph output update) or ""`+`"" (will skip the randomization and; start from the previous values). All combinations are available. ``` {.cpp}; network.Train(1000,""text,graph,update=10""); // full output every; // 10 epochs; network.Train(100,""text,+""); // 100 more epochs; //starts with existing weights; ```. The weights can be saved to a file (`DumpWeights`) and then reloaded; (`LoadWeights`) to a new compatible network. The output can also be; evaluated (`Evaluate`) for a given output neuron and an array of; double input parameters or the network can be exported (`Export`) as a; standalone code. Up to now, this is only as a C++ or PYTHON class, but; other languages could be implemented. ### Examples. An example of how to use **`TMultiLayerPerceptron`** is the macro; `mlpHiggs.C` in \$ROOTSYS/tutorials. Using some standard simulated; information that could have been obtained at `LEP`, a neural network; is build, which can make the d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:76724,simpl,simple,76724,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['simpl'],['simple']
Usability," back to the caller. An i32 slot is; allocated in the coroutine frame and `%inc` is spilled and reloaded from that; slot as needed. We also store addresses of the resume and destroy functions so that the; `coro.resume` and `coro.destroy` intrinsics can resume and destroy the coroutine; when its identity cannot be determined statically at compile time. For our; example, the coroutine frame will be:. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32 }. After resume and destroy parts are outlined, function `f` will contain only the; code responsible for creation and initialization of the coroutine frame and; execution of the coroutine until a suspend point is reached:. .. code-block:: llvm. define ptr @f(i32 %n) {; entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %alloc = call noalias ptr @malloc(i32 24); %frame = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc); %1 = getelementptr %f.frame, ptr %frame, i32 0, i32 0; store ptr @f.resume, ptr %1; %2 = getelementptr %f.frame, ptr %frame, i32 0, i32 1; store ptr @f.destroy, ptr %2. %inc = add nsw i32 %n, 1; %inc.spill.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i32 0, i32 2; store i32 %inc, ptr %inc.spill.addr; call void @print(i32 %n). ret ptr %frame; }. Outlined resume part of the coroutine will reside in function `f.resume`:. .. code-block:: llvm. define internal fastcc void @f.resume(ptr %frame.ptr.resume) {; entry:; %inc.spill.addr = getelementptr %f.frame, ptr %frame.ptr.resume, i64 0, i32 2; %inc.spill = load i32, ptr %inc.spill.addr, align 4; %inc = add i32 %inc.spill, 1; store i32 %inc, ptr %inc.spill.addr, align 4; tail call void @print(i32 %inc); ret void; }. Whereas function `f.destroy` will contain the cleanup code for the coroutine:. .. code-block:: llvm. define internal fastcc void @f.destroy(ptr %frame.ptr.destroy) {; entry:; tail call void @free(ptr %frame.ptr.destroy); ret void; }. Avoiding Heap Allocations; -------------------------. A particular corout",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:15195,resume,resume,15195,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability," backend; --------------------------------------------------. Extended BPF (or eBPF) is similar to the original (""classic"") BPF (cBPF) used; to filter network packets. The; `bpf() system call <http://man7.org/linux/man-pages/man2/bpf.2.html>`_; performs a range of operations related to eBPF. For both cBPF and eBPF; programs, the Linux kernel statically analyzes the programs before loading; them, in order to ensure that they cannot harm the running system. eBPF is; a 64-bit RISC instruction set designed for one to one mapping to 64-bit CPUs.; Opcodes are 8-bit encoded, and 87 instructions are defined. There are 10; registers, grouped by function as outlined below. ::. R0 return value from in-kernel functions; exit value for eBPF program; R1 - R5 function call arguments to in-kernel functions; R6 - R9 callee-saved registers preserved by in-kernel functions; R10 stack frame pointer (read only). Instruction encoding (arithmetic and jump); ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; eBPF is reusing most of the opcode encoding from classic to simplify conversion; of classic BPF to eBPF. For arithmetic and jump instructions the 8-bit 'code'; field is divided into three parts:. ::. +----------------+--------+--------------------+; | 4 bits | 1 bit | 3 bits |; | operation code | source | instruction class |; +----------------+--------+--------------------+; (MSB) (LSB). Three LSB bits store instruction class which is one of:. ::. BPF_LD 0x0; BPF_LDX 0x1; BPF_ST 0x2; BPF_STX 0x3; BPF_ALU 0x4; BPF_JMP 0x5; (unused) 0x6; BPF_ALU64 0x7. When BPF_CLASS(code) == BPF_ALU or BPF_ALU64 or BPF_JMP,; 4th bit encodes source operand. ::. BPF_X 0x1 use src_reg register as source operand; BPF_K 0x0 use 32 bit immediate as source operand. and four MSB bits store operation code. ::. BPF_ADD 0x0 add; BPF_SUB 0x1 subtract; BPF_MUL 0x2 multiply; BPF_DIV 0x3 divide; BPF_OR 0x4 bitwise logical OR; BPF_AND 0x5 bitwise logical AND; BPF_LSH 0x6 left shift; BPF_RSH 0x7 right shift (zero extended); BPF",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:103560,simpl,simplify,103560,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simplify']
Usability," basic block and will look; as follows:. .. code-block:: llvm. define internal fastcc void @f.Resume(ptr %FramePtr) {; entry.Resume:; %index.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 2; %index = load i8, ptr %index.addr, align 1; %switch = icmp eq i8 %index, 0; %n.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 3; %n = load i32, ptr %n.addr, align 4. br i1 %switch, label %loop.resume, label %loop. loop.resume:; %sub = sub nsw i32 0, %n; call void @print(i32 %sub); br label %suspend; loop:; %inc = add nsw i32 %n, 1; store i32 %inc, ptr %n.addr, align 4; tail call void @print(i32 %inc); br label %suspend. suspend:; %storemerge = phi i8 [ 0, %loop ], [ 1, %loop.resume ]; store i8 %storemerge, ptr %index.addr, align 1; ret void; }. If different cleanup code needs to get executed for different suspend points,; a similar switch will be in the `f.destroy` function. .. note ::. Using suspend index in a coroutine state and having a switch in `f.resume` and; `f.destroy` is one of the possible implementation strategies. We explored; another option where a distinct `f.resume1`, `f.resume2`, etc. are created for; every suspend point, and instead of storing an index, the resume and destroy; function pointers are updated at every suspend. Early testing showed that the; current approach is easier on the optimizer than the latter so it is a; lowering strategy implemented at the moment. Distinct Save and Suspend; -------------------------. In the previous example, setting a resume index (or some other state change that; needs to happen to prepare a coroutine for resumption) happens at the same time as; a suspension of a coroutine. However, in certain cases, it is necessary to control; when coroutine is prepared for resumption and when it is suspended. In the following example, a coroutine represents some activity that is driven; by completions of asynchronous operations `async_op1` and `async_op2` which get; a coroutine handle as a parameter ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:20047,resume,resume,20047,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability," be overridden in a derived class of `Myclass`. (See example; `TMhs3`). Class `Myclass` may also provide a method to stop the running thread:. ``` {.cpp}; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; ```. Example `TMhs3:` Class **`TThreadframe`**; (`TThreadframe.h, TThreadframe.cxx`) is a simple example of a framework; class managing up to four threaded methods. Class `TMhs3`; (`TMhs3.h, TMhs3.cxx)` inherits from this base class, showing the `mhs3`; example 8.1 `(mhs3.h, mhs3.cxx) `within a class. The `Makefile` of this; example builds the shared libraries `libTThreadframe.so` and; `libTMhs3.so`. These are either loaded or executed by the ROOT script; `TMhs3demo.C,` or are linked against an executable: `TMhs3run.cxx`. ### Known Problems. Parts of the ROOT framework, like the interpreter, are not yet; thread-safe. Therefore, you should use this package with caution. If you; restrict your threads to distinct and \`simple' duties, you will able to; benefit from their use. The **`TThread`** class is available on all; platforms, which provide a POSIX compliant thread implementation. On; Linux, Xavier Leroy's Linux Threads implementation is widely used, but; the **`TThread`** implementation should be usable on all platforms that; provide `pthread`. **Linux Xlib on SMP machines** is not yet thread-safe. This may cause; crashes during threaded graphics operations; this problem is independent; of ROOT. **Object instantiation:** there is no implicit locking mechanism for; memory allocation and global ROOT lists. The user has to explicitly; protect their code when using them. ## The Signals of ROOT. The list of default signals handled by ROOT is:. ``` {.cpp}; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingException; kSigSystemkSigWindowChanged; ```. The signals ***`kSigFloatingException`***,; ***`kSigSegmentationViolation`***, ***`kSigIllegalInstru",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:17134,simpl,simple,17134,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['simpl'],['simple']
Usability," be provided as locations for the inline; assembly to jump to. Example:; """""""""""""""". .. code-block:: llvm. ; ""asm goto"" without output constraints.; callbr void asm """", ""r,!i""(i32 %x); to label %fallthrough [label %indirect]. ; ""asm goto"" with output constraints.; <result> = callbr i32 asm """", ""=r,r,!i""(i32 %x); to label %fallthrough [label %indirect]. .. _i_resume:. '``resume``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. resume <type> <value>. Overview:; """""""""""""""""". The '``resume``' instruction is a terminator instruction that has no; successors. Arguments:; """""""""""""""""""". The '``resume``' instruction requires one argument, which must have the; same type as the result of any '``landingpad``' instruction in the same; function. Semantics:; """""""""""""""""""". The '``resume``' instruction resumes propagation of an existing; (in-flight) exception whose unwinding was interrupted with a; :ref:`landingpad <i_landingpad>` instruction. Example:; """""""""""""""". .. code-block:: llvm. resume { ptr, i32 } %exn. .. _i_catchswitch:. '``catchswitch``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind to caller; <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind label <default>. Overview:; """""""""""""""""". The '``catchswitch``' instruction is used by `LLVM's exception handling system; <ExceptionHandling.html#overview>`_ to describe the set of possible catch handlers; that may be executed by the :ref:`EH personality routine <personalityfn>`. Arguments:; """""""""""""""""""". The ``parent`` argument is the token of the funclet that contains the; ``catchswitch`` instruction. If the ``catchswitch`` is not inside a funclet,; this operand may be the token ``none``. The ``default`` argument is the label of another basic block beginning with; either a ``cleanuppad`` or ``catchswitch`` instruction. This unwind destination; must be a legal target with respect ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:370325,resume,resume,370325,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['resume'],['resume']
Usability," be seen as unrolling the outer loop and ""jamming"" (fusing) the inner; loops into one. When variables or loads can be shared in the new inner loop, this; can lead to significant performance improvements. It uses; :ref:`Dependence Analysis <passes-da>` for proving the transformations are safe. ``lower-global-dtors``: Lower global destructors; ------------------------------------------------. This pass lowers global module destructors (``llvm.global_dtors``) by creating; wrapper functions that are registered as global constructors in; ``llvm.global_ctors`` and which contain a call to ``__cxa_atexit`` to register; their destructor functions. ``loweratomic``: Lower atomic intrinsics to non-atomic form; -----------------------------------------------------------. This pass lowers atomic intrinsics to non-atomic form for use in a known; non-preemptible environment. The pass does not verify that the environment is non-preemptible (in general; this would require knowledge of the entire call graph of the program including; any libraries which may not be available in bitcode form); it simply lowers; every atomic intrinsic. ``lowerinvoke``: Lower invokes to calls, for unwindless code generators; -----------------------------------------------------------------------. This transformation is designed for use by code generators which do not yet; support stack unwinding. This pass converts ``invoke`` instructions to; ``call`` instructions, so that any exception-handling ``landingpad`` blocks; become dead code (which can be removed by running the ``-simplifycfg`` pass; afterwards). ``lowerswitch``: Lower ``SwitchInst``\ s to branches; ----------------------------------------------------. Rewrites switch instructions with a sequence of branches, which allows targets; to get away with not implementing the switch instruction until it is; convenient. .. _passes-mem2reg:. ``mem2reg``: Promote Memory to Register; ---------------------------------------. This file promotes memory reference",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:29597,simpl,simply,29597,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simply']
Usability," be, and also easier to maintain and modify over time. The information is coded in a declarative style involving classes and records,; which are then processed by TableGen. ```; class Hello <string _msg> {; string msg = !strconcat(""Hello "", _msg);; }. def HelloWorld: Hello<""world!""> {}; ```; ```; ------------- Classes -----------------; class Hello<string Hello:_msg = ?> {; string msg = !strconcat(""Hello "", Hello:_msg);; }; ------------- Defs -----------------; def HelloWorld { // Hello; string msg = ""Hello world!"";; }; ```; [Try this example on Compiler Explorer.](https://godbolt.org/z/13xo1P5oz). The internalized records are passed on to various backends, which extract; information from a subset of the records and generate one or more output files. These output files are typically .inc files for C++, but may be any type of file; that the backend developer needs. Resources for learning the language:; * [TableGen Overview](https://llvm.org/docs/TableGen/index.html); * [Programmer's reference guide](https://llvm.org/docs/TableGen/ProgRef.html); * [Tutorial](jupyter/tablegen_tutorial_part_1.ipynb); * [Tools for Learning LLVM TableGen](https://blog.llvm.org/posts/2023-12-07-tools-for-learning-llvm-tablegen/); * [Lessons in TableGen](https://www.youtube.com/watch?v=45gmF77JFBY) (video),; [slides](https://archive.fosdem.org/2019/schedule/event/llvm_tablegen/attachments/slides/3304/export/events/attachments/llvm_tablegen/slides/3304/tablegen.pdf); * [Improving Your TableGen Descriptions](https://www.youtube.com/watch?v=dIEVUlsiktQ); (video), [slides](https://llvm.org/devmtg/2019-10/slides/Absar-ImprovingYourTableGenDescription.pdf). Writing TableGen backends:; * [TableGen Backend Developer's Guide](https://llvm.org/docs/TableGen/BackGuide.html); * [How to write a TableGen backend](https://www.youtube.com/watch?v=UP-LBRbvI_U); (video), [slides](https://llvm.org/devmtg/2021-11/slides/2021-how-to-write-a-tablegen-backend.pdf), also available as a; 	[notebook](jupyter/sql_quer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/README.md:1189,guid,guide,1189,interpreter/llvm-project/llvm/utils/TableGen/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/README.md,1,['guid'],['guide']
Usability," being `cl::Hidden`_, and use the aliased; options parser to do the conversion from string to data. .. _cl::extrahelp:. The ``cl::extrahelp`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``cl::extrahelp`` class is a nontemplated class that allows extra help text; to be printed out for the ``-help`` option. .. code-block:: c++. namespace cl {; struct extrahelp;; }. To use the extrahelp, simply construct one with a ``const char*`` parameter to; the constructor. The text passed to the constructor will be printed at the; bottom of the help message, verbatim. Note that multiple ``cl::extrahelp``; **can** be used, but this practice is discouraged. If your tool needs to print; additional help information, put all that help into a single ``cl::extrahelp``; instance. For example:. .. code-block:: c++. cl::extrahelp(""\nADDITIONAL HELP:\n\n This is the extra help\n"");. .. _cl::OptionCategory:. The ``cl::OptionCategory`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``cl::OptionCategory`` class is a simple class for declaring; option categories. .. code-block:: c++. namespace cl {; class OptionCategory;; }. An option category must have a name and optionally a description which are; passed to the constructor as ``const char*``. Note that declaring an option category and associating it with an option before; parsing options (e.g. statically) will change the output of ``-help`` from; uncategorized to categorized. If an option category is declared but not; associated with an option then it will be hidden from the output of ``-help``. .. _different parser:; .. _discussed previously:. Builtin parsers; ---------------. Parsers control how the string value taken from the command line is translated; into a typed value, suitable for use in a C++ program. By default, the; CommandLine library uses an instance of ``parser<type>`` if the command line; option specifies that it uses values of type '``type``'. Because of this,; custom option processing is specified with specializations of the '``parse",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:58021,simpl,simple,58021,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability," below. Viewing static analyzer results in Xcode. Key features:. Integrated workflow: Results are integrated within Xcode. There is; no experience of using a separate tool, and activating the analyzer requires a; single keystroke or mouse click.; Transparency: Works effortlessly with Xcode projects (including iPhone projects).; Cons: Doesn't work well with non-Xcode projects. For those,; consider using scan-build. Getting Started; Xcode is available as a free download from Apple on the Mac; App Store, with instructions; available for using the analyzer.; Using open source analyzer builds with Xcode; By default, Xcode uses the version of clang that came bundled with; it to analyze your code. It is possible to change Xcode's behavior to use an; alternate version of clang for this purpose while continuing to use; the clang that came with Xcode for compiling projects.; Why try open source builds?; The advantage of using open source analyzer builds (provided on this website); is that they are often newer than the analyzer provided with Xcode, and thus can; contain bug fixes, new checks, or simply better analysis.; On the other hand, new checks can be experimental, with results of variable; quality. Users are encouraged to file bug reports; (for any version of the analyzer) where they encounter false positives or other; issues.; set-xcode-analyzer; Starting with analyzer build checker-234, analyzer builds contain a command; line utility called set-xcode-analyzer that allows users to change what; copy of clang that Xcode uses for analysis:. $ set-xcode-analyzer -h; Usage: set-xcode-analyzer [options]. Options:; -h, --help show this help message and exit; --use-checker-build=PATH; Use the Clang located at the provided absolute path,; e.g. /Users/foo/checker-1; --use-xcode-clang Use the Clang bundled with Xcode. Operationally, set-xcode-analyzer edits Xcode's configuration files; to point it to use the version of clang you specify for static; analysis. Within this model it pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/xcode.html:1484,simpl,simply,1484,interpreter/llvm-project/clang/www/analyzer/xcode.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/xcode.html,1,['simpl'],['simply']
Usability," benefit from the build system's features. Mainly, you want; your source tree layout to look similar to the LLVM source tree layout. Underneath your top level directory, you should have the following directories:. **lib**. This subdirectory should contain all of your library source code. For each; library that you build, you will have one directory in **lib** that will; contain that library's source code. Libraries can be object files, archives, or dynamic libraries. The **lib**; directory is just a convenient place for libraries as it places them all in; a directory from which they can be linked later. **include**. This subdirectory should contain any header files that are global to your; project. By global, we mean that they are used by more than one library or; executable of your project. By placing your header files in **include**, they will be found; automatically by the LLVM build system. For example, if you have a file; **include/jazz/note.h**, then your source files can include it simply with; **#include ""jazz/note.h""**. **tools**. This subdirectory should contain all of your source code for executables.; For each program that you build, you will have one directory in **tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and comp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:2750,simpl,simply,2750,interpreter/llvm-project/llvm/docs/Projects.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst,1,['simpl'],['simply']
Usability," bins filled"");; histo->Fill(6.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Three bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Four bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf)"",""Title:The fourth bin content is 2"");; }; ```. Each character string following the keyword ""Title:"" makes a new entry; in the table of contents. ## Create or Modify a Style. All objects that can be drawn in a pad inherit from one or more; attribute classes like **`TAttLine`**, **`TAttFill`**, **`TAttText`**,; **`TAttMarker`**. When objects are created, their default attributes are; taken from the current style. The current style is an object of the; class **`TStyle`** and can be referenced via the global variable; ***`gStyle`*** (in `TStyle.h`). See the class **`TStyle`** for a; complete list of the attributes that can be set in one style. ROOT provides several styles called:. - ""`Default`"" - the default style. - ""`Plain`"" - the simple style (black and white). - ""`Bold`"" - bolder lines. - ""`Video`"" - suitable for html output or screen viewing. The ""`Default`"" style is created by:. ``` {.cpp}; TStyle *default = new TStyle(""Default"",""Default Style"");; ```. The ""`Plain`"" style can be used if you want to get a ""conventional""; PostScript output or if you are working on a monochrome display. The; following example shows how to create it. ``` {.cpp}; TStyle *plain = new TStyle(""Plain"",; ""Plain Style(no colors/fill areas)"");; plain->SetCanvasBorderMode(0);; plain->SetPadBorderMode(0);; plain->SetPadColor(0);; plain->SetCanvasColor(0);; plain->SetTitleColor(0);; plain->SetStatColor(0);; ```. You can set the current style by:. ``` {.cpp}; gROOT->SetStyle(style_name);; ```. You can get a pointer to an existing style by:. ``` {.cpp}; TStyle *style = gROOT->GetStyle(style_name);; ```. You can create additional styles by:. ``` {.cpp}; TStyle *st1 = new TStyle(""st1"",""my style"");; st1->Set...; st1->cd(); // this becomes now the cur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:101913,simpl,simple,101913,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simple']
Usability," branches for upstream monorepo branches.; for ref in $(git -C my-monorepo for-each-ref --format=""%(refname)"" \; refs/remotes/upstream/monorepo); do; upstream_branch=${ref#refs/remotes/upstream/monorepo/}; git -C my-monorepo branch upstream/${upstream_branch} ${ref}; done. The above gets you to a state like the following::. U1 - U2 - U3 <- upstream/main; \ \ \; \ \ - Llld1 - Llld2 -; \ \ \; \ - Lclang1 - Lclang2-- Lmerge <- local/octopus/main; \ /; - Lllvm1 - Lllvm2-----. Each branched component has its branch rewritten on top of the; monorepo and all components are unified by a giant octopus merge. If additional active local branches need to be preserved, the above; operations following the assignment to ``my_local_branch`` should be; done for each branch. Ref paths will need to be updated to map the; local branch to the corresponding upstream branch. If local branches; have no corresponding upstream branch, then the creation of; ``local/octopus/<local branch>`` need not use ``git-merge-base`` to; pinpoint its root commit; it may simply be branched from the; appropriate component branch (say, ``llvm/local_release_X``). Zipping local history; ---------------------. The octopus merge is suboptimal for many cases, because walking back; through the history of one component leaves the other components fixed; at a history that likely makes things unbuildable. Some downstream users track the order commits were made to subprojects; with some kind of ""umbrella"" project that imports the project git; mirrors as submodules, similar to the multirepo umbrella proposed; above. Such an umbrella repository looks something like this::. UM1 ---- UM2 -- UM3 -- UM4 ---- UM5 ---- UM6 ---- UM7 ---- UM8 <- main; | | | | | | |; Lllvm1 Llld1 Lclang1 Lclang2 Lllvm2 Llld2 Lmyproj1. The vertical bars represent submodule updates to a particular local; commit in the project mirror. ``UM3`` in this case is a commit of; some local umbrella repository state that is not a submodule update,; perhaps a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:23797,simpl,simply,23797,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['simpl'],['simply']
Usability," by removing certain cling runtime safety checks.; - Streamline and better document usage of multi-thread RDataFrame: edge cases in which processing of an event could start; before processing of another event finished have been removed, making it easier for user to write safe parallel RDF operations.; See the [relevant documentation](https://root.cern.ch/doc/master/classROOT_1_1RDataFrame.html#parallel-execution) for more information. ### TTreeProcessorMT; - Parallelise search of cluster boundaries for input datasets with no friends or TEntryLists. The net effect is a faster initialization time in this common case.; - Handle gracefully the presence of chains the files associated to which are corrupted.; - Reduce number of expensive `TChain::LoadTree` calls by spawning nested TBB tasks to ensure clusters of a given file will be most likely processed by the same thread. ### TTree; - TTrees can be forced to only create new baskets at event cluster boundaries.; This simplifies file layout and I/O at the cost of memory. Recommended for; simple file formats such as ntuples but not more complex data types. To; enable, invoke `tree->SetBit(TTree::kOnlyFlushAtCluster)`. ## Histogram Libraries. ## Math Libraries. ### [Clad](https://github.com/vgvassilev/clad); - Enable experimental automatic differentiation techniques to compute; derivatives and gradients of functions. Automatic differentiation is; superior to the slow symbolic or often inaccurate numerical differentiation.; It uses the fact that every computer program can be divided into a set of; elementary operations (-,+,*,/) and functions (sin, cos, log, etc). By; applying the chain rule repeatedly to these operations, derivatives of; arbitrary order can be computed.; - Implement experimental `TFormula::GradientPar` derivative engine which; employs clad. ### VecOps; - Add `All` helper: return true if all of the elements equate to true, return false otherwise.; - Add `Any` helper: return true if any of the elements equate",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:10655,simpl,simplifies,10655,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['simpl'],['simplifies']
Usability," bytecode) is actually two things: a `bitstream; container format`_ and an `encoding of LLVM IR`_ into the container format. The bitstream format is an abstract encoding of structured data, very similar to; XML in some ways. Like XML, bitstream files contain tags, and nested; structures, and you can parse the file without having to understand the tags.; Unlike XML, the bitstream format is a binary encoding, and unlike XML it; provides a mechanism for the file to self-describe ""abbreviations"", which are; effectively size optimizations for the content. LLVM IR files may be optionally embedded into a `wrapper`_ structure, or in a; `native object file`_. Both of these mechanisms make it easy to embed extra; data along with LLVM IR files. This document first describes the LLVM bitstream format, describes the wrapper; format, then describes the record structure used by LLVM IR files. .. _bitstream container format:. Bitstream Format; ================. The bitstream format is literally a stream of bits, with a very simple; structure. This structure consists of the following concepts:. * A ""`magic number`_"" that identifies the contents of the stream. * Encoding `primitives`_ like variable bit-rate integers. * `Blocks`_, which define nested content. * `Data Records`_, which describe entities within the file. * Abbreviations, which specify compression optimizations for the file. Note that the :doc:`llvm-bcanalyzer <CommandGuide/llvm-bcanalyzer>` tool can be; used to dump and inspect arbitrary bitstreams, which is very useful for; understanding the encoding. .. _magic number:. Magic Numbers; -------------. The first four bytes of a bitstream are used as an application-specific magic; number. Generic bitcode tools may look at the first four bytes to determine; whether the stream is a known stream type. However, these tools should *not*; determine whether a bitstream is valid based on its magic number alone. New; application-specific bitstream formats are being developed all the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:1402,simpl,simple,1402,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['simpl'],['simple']
Usability," calculated from p.d.fs that have; support for analytical integration are constructed from an appropriately reconnected RooRealIntegral.; If numeric integration is required, the c.d.f or running integral is calculated by a dedicated class; RooRunningIntegral that precalculates results for all observable values, which is more efficient; in most use cases. Cumulative distributions functions that are calculated numerically are handled slightly differently; that standard running integrals: their values is constructed to converge to exactly zero at the lower bound; and exactly 1 at the upper bound so that algorithms that make use of that property of c.d.f can do so reliably. Constraints management. New tools have been added to simplify studies with fits involving (external) constraints on parameters.; The general philosophy is that constraints on parameters can be represented as probability density functions; and can thus be modeled by RooAbsPdf classes (e.g. a RooGaussian for a simple Gaussian constraint on a parameter).; There are two modes of operation: you can add parameter constraints to your problem definition by multiplying; the constraint p.d.f.s with your 'master' p.d.f. or you specify them externally in each operation. The; first mode of operation keeps all information in your master p.d.f and may make the logistics of non-trivial; fitting problems easier. It works as follows: first you define your regular p.d.f, then you define your; constraint p.d.f and you multiply them with RooProdPdf. // Construct constraint; RooGaussian fconstraint(""fconstraint"",""fconstraint"",f,RooConst(0.8),RooConst(0.1)) ;. // Multiply constraint with p.d.f; RooProdPdf pdfc(""pdfc"",""p.d.f with constraint"",RooArgSet(p.d.f,fconstraint)) ;. If your top level p.d.f is already a RooProdPdf it also fine to multiply all terms together in one go.; Constraints do not need to be specified a the top-level RooProdPdf, constraint p.d.f.s in any component; RooProdPdf lower in the expression tree are u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:6889,simpl,simple,6889,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['simpl'],['simple']
Usability," called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cache; scripts to provide more complex options. By default, only a few CMake options will be passed between stages.; The list, called _BOOTSTRAP_DEFAULT_PASSTHROUGH, is defined in clang/CMakeLists.txt.; To force the passing of the variables between stages, use the -DCLANG_BOOTSTRAP_PASSTHROUGH; CMake option, each variable separated by a "";"". As example:. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DCLANG_BOOTSTRAP_PASSTHROUGH=""CMAKE_INSTALL_PREFIX;CMAKE_VERBOSE_MAKEFILE"" \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. CMake optio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:1578,simpl,simplest,1578,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['simpl'],['simplest']
Usability," can be; used to achieve this sort of thing in a localizable way, see below. Formatting a Diagnostic Argument; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Arguments to diagnostics are fully typed internally, and come from a couple; different classes: integers, types, names, and random strings. Depending on; the class of the argument, it can be optionally formatted in different ways.; This gives the ``DiagnosticConsumer`` information about what the argument means; without requiring it to use a specific presentation (consider this MVC for; Clang :). It is really easy to add format specifiers to the Clang diagnostics system, but; they should be discussed before they are added. If you are creating a lot of; repetitive diagnostics and/or have an idea for a useful formatter, please bring; it up on the cfe-dev mailing list. Here are the different diagnostic argument formats currently supported by; Clang:. **""s"" format**. Example:; ``""requires %0 parameter%s0""``; Class:; Integers; Description:; This is a simple formatter for integers that is useful when producing English; diagnostics. When the integer is 1, it prints as nothing. When the integer; is not 1, it prints as ""``s``"". This allows some simple grammatical forms to; be to be handled correctly, and eliminates the need to use gross things like; ``""requires %1 parameter(s)""``. Note, this only handles adding a simple; ""``s``"" character, it will not handle situations where pluralization is more; complicated such as turning ``fancy`` into ``fancies`` or ``mouse`` into; ``mice``. You can use the ""plural"" format specifier to handle such situations. **""select"" format**. Example:; ``""must be a %select{unary|binary|unary or binary}0 operator""``; Class:; Integers; Description:; This format specifier is used to merge multiple related diagnostics together; into one common one, without requiring the difference to be specified as an; English string argument. Instead of specifying the string, the diagnostic; gets an integer argument and the fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:10432,simpl,simple,10432,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability," can cause the; state to change, resulting in a new node in the ExplodedGraph with an; updated program point and an updated state. A bug is found by hitting; a node that satisfies some ""bug condition"" (basically a violation of a; checking invariant). The analyzer traces out multiple paths by reasoning about branches and; then bifurcating the state: on the true branch the conditions of the; branch are assumed to be true and on the false branch the conditions; of the branch are assumed to be false. Such ""assumptions"" create; constraints on the values of the program, and those constraints are; recorded in the ProgramState object (and are manipulated by the; ConstraintManager). If assuming the conditions of a branch would; cause the constraints to be unsatisfiable, the branch is considered; infeasible and that path is not taken. This is how we get; path-sensitivity. We reduce exponential blow-up by caching nodes. If; a new node with the same state and program point as an existing node; would get generated, the path ""caches out"" and we simply reuse the; existing node. Thus the ExplodedGraph is not a DAG; it can contain; cycles as paths loop back onto each other and cache out. ProgramState and ExplodedNodes are basically immutable once created. Once; one creates a ProgramState, you need to create a new one to get a new; ProgramState. This immutability is key since the ExplodedGraph represents; the behavior of the analyzed program from the entry point. To; represent these efficiently, we use functional data structures (e.g.,; ImmutableMaps) which share data between instances. Finally, individual Checkers work by also manipulating the analysis; state. The analyzer engine talks to them via a visitor interface.; For example, the PreVisitCallExpr() method is called by ExprEngine; to tell the Checker that we are about to analyze a CallExpr, and the; checker is asked to check for any preconditions that might not be; satisfied. The checker can do nothing, or it can generate a new;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt:2573,simpl,simply,2573,interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,1,['simpl'],['simply']
Usability," cannot set a line; execution count to the count from a gap region unless that region is the only; one on a line. Gap regions are used to eliminate unnatural artifacts in coverage reports, such; as red ""unexecuted"" highlights present at the end of an otherwise covered line,; or blue ""executed"" highlights present at the start of a line that is otherwise; not executed. Branch regions; --------------; When viewing branch coverage details in source-based file-level sub-views using; ``--show-branches``, it is recommended that users show all macro expansions; (using option ``--show-expansions``) since macros may contain hidden branch; conditions. The coverage summary report will always include these macro-based; boolean expressions in the overall branch coverage count for a function or; source file. Branch coverage is not tracked for constant folded branch conditions since; branches are not generated for these cases. In the source-based file-level; sub-view, these branches will simply be shown as ``[Folded - Ignored]`` so that; users are informed about what happened. Branch coverage is tied directly to branch-generating conditions in the source; code. Users should not see hidden branches that aren't actually tied to the; source code. MC/DC Instrumentation; ---------------------. When instrumenting for Modified Condition/Decision Coverage (MC/DC) using the; clang option ``-fcoverage-mcdc``, users are limited to at most **six** leaf-level; conditions in a boolean expression. A warning will be generated for boolean; expressions that contain more than six, and they will not be instrumented for; MC/DC. Also, if a boolean expression is embedded in the nest of another boolean; expression but separated by a non-logical operator, this is also not supported.; For example, in ``x = (a && b && c && func(d && f))``, the ``d && f`` case; starts a new boolean expression that is separated from the other conditions by; the operator ``func()``. When this is encountered, a warning will be ge",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:20491,simpl,simply,20491,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,1,['simpl'],['simply']
Usability," class definition is lost, or unavailable. - The current version of a shared library and an old file with old; class versions (backward compatibility). This is often the case when; reading old data. - Reading a file with a shared library built with `MakeProject`. This; is the case when someone has already read the data without a shared; library and has used ROOT `MakeProject` feature to reconstruct the; class definitions and shared library (`MakeProject` is explained in; detail later on). In case of a mismatch between the in-memory version and the persistent; version of a class, ROOT maps the persistent one to the one in memory.; This allows you to change the class definition at will, for example:. - Change the order of data members in the class. - Add new data members. By default, the value of the missing member; will be 0 or in case of an object it will be set to null. - Remove data members. - Move a data member to a base class or vice-versa. - Change the type of a member if it is a simple type or a pointer to a; simple type. If a loss of precision occurs, a warning is given. - Add or remove a base class. ![The schema evolution for objects written on disk and in memory](pictures/020000EE.jpg). ROOT supports schema evolution by keeping a class description of each; version of the class that was ever written to disk, with the class. When; it writes an object to file, it also writes the description of the; current class version along with it. This description is implemented in; the `StreamerInfo `class. ### The TStreamerInfo Class. Each class has a list of `StreamerInfo` objects, one for each version of; the class if that version was written to disk at least once. When; reading an object from a file, the system uses the `StreamerInfo` list; to decode an object into the current version. The `StreamerInfo` is made; up of **`TStreamerElements`** . Each describes one persistent data; member of the class. By default, all data members of a class are; persistent. To exclude a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:69697,simpl,simple,69697,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,2,['simpl'],['simple']
Usability," classes are extended using a (typically) simple; `translate()` function that extracts the mathematically differentiable; properties out of the RooFit classes that make up the statistical model. The `translate()` function helps implement the Code Squashing logic that is; used to optimize numerical evaluations. It accomplishes this by using a small; subset of helper functions that are available in the; `RooFit::Detail::CodeSquashContext` and `RooFuncWrapper` classes; (see Appendix B). It converts a RooFit expression into a form that can be; efficiently evaluated by Clad. The `translate()` function returns an `std::string` representing the; underlying mathematical notation of the class as code, that can later be; concatenated into a single string representing the entire model. This string; of code is then just-in-time compiled by Cling (a C++ interpreter for Root). **4. analyticalIntegral() Use Case:** If your class includes (or should; include) the `analyticalIntegral()` function, then a simple; `buildCallToAnalyticIntegral()` function needs to be created to help call the; `analyticalIntegral()` function. # Example for adding Code Generation support to RooFit classes. Let us take the `RooPoisson.cxx` class as an example. > [roofit/roofit/src/RooPoisson.cxx](https://github.com/root-project/root/blob/master/roofit/roofit/src/RooPoisson.cxx). First step is to locate the `RooPoisson::evaluate()` function. Most RooFit; classes implement this function. > RooFit internally calls the `evaluate()` function to evaluate a single node; in a compute graph. ## Before Code Generation Support. Following is a code snippet from `RooPoisson` *before* it had AD support. ``` {.cpp}; double RooPoisson::evaluate() const; {; double k = _noRounding ? x : floor(x);; if(_protectNegative && mean<0) {; RooNaNPacker np;; np.setPayload(-mean);; return np._payload;; }; return TMath::Poisson(k,mean);; }; ```; `TMath::Poisson()` is a simple mathematical function. For this example, the; relevant part i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:9142,simpl,simple,9142,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['simpl'],['simple']
Usability," commits to their corresponding rewritten ``L*1`` commits.; The ``L*2`` commits did not do any merges from upstream. Note that the merge from ``U2`` to ``Lclang1`` appears redundant, but; if, say, ``U3`` changed some files in upstream clang, the ``Lclang1``; commit appearing after the ``Llld1`` commit would actually represent a; clang tree *earlier* in the upstream clang history. We want the; ``local/zip`` branch to accurately represent the state of our umbrella; history and so the edge ``U2 -> Lclang1`` is a visual reminder of what; clang's tree actually looks like in ``Lclang1``. Even so, the edge ``U3 -> Llld1`` could be problematic for future; merges from upstream. git will think that we've already merged from; ``U3``, and we have, except for the state of the clang tree. One; possible mitigation strategy is to manually diff clang between ``U2``; and ``U3`` and apply those updates to ``local/zip``. Another,; possibly simpler strategy is to freeze local work on downstream; branches and merge all submodules from the latest upstream before; running ``zip-downstream-fork.py``. If downstream merged each project; from upstream in lockstep without any intervening local commits, then; things should be fine without any special action. We anticipate this; to be the common case. The tree for ``Lclang1`` outside of clang will represent the state of; things at ``U3`` since all of the upstream projects not participating; in the umbrella history should be in a state respecting the commit; ``U3``. The trees for llvm and lld should correctly represent commits; ``Lllvm1`` and ``Llld1``, respectively. Commit ``UM3`` changed files not related to submodules and we need; somewhere to put them. It is not safe in general to put them in the; monorepo root directory because they may conflict with files in the; monorepo. Let's assume we want them in a directory ``local`` in the; monorepo. **Example 1: Umbrella looks like the monorepo**. For this example, we'll assume that each subproject ap",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:26467,simpl,simpler,26467,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['simpl'],['simpler']
Usability," compile time. For our; example, the coroutine frame will be:. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32 }. After resume and destroy parts are outlined, function `f` will contain only the; code responsible for creation and initialization of the coroutine frame and; execution of the coroutine until a suspend point is reached:. .. code-block:: llvm. define ptr @f(i32 %n) {; entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %alloc = call noalias ptr @malloc(i32 24); %frame = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc); %1 = getelementptr %f.frame, ptr %frame, i32 0, i32 0; store ptr @f.resume, ptr %1; %2 = getelementptr %f.frame, ptr %frame, i32 0, i32 1; store ptr @f.destroy, ptr %2. %inc = add nsw i32 %n, 1; %inc.spill.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i32 0, i32 2; store i32 %inc, ptr %inc.spill.addr; call void @print(i32 %n). ret ptr %frame; }. Outlined resume part of the coroutine will reside in function `f.resume`:. .. code-block:: llvm. define internal fastcc void @f.resume(ptr %frame.ptr.resume) {; entry:; %inc.spill.addr = getelementptr %f.frame, ptr %frame.ptr.resume, i64 0, i32 2; %inc.spill = load i32, ptr %inc.spill.addr, align 4; %inc = add i32 %inc.spill, 1; store i32 %inc, ptr %inc.spill.addr, align 4; tail call void @print(i32 %inc); ret void; }. Whereas function `f.destroy` will contain the cleanup code for the coroutine:. .. code-block:: llvm. define internal fastcc void @f.destroy(ptr %frame.ptr.destroy) {; entry:; tail call void @free(ptr %frame.ptr.destroy); ret void; }. Avoiding Heap Allocations; -------------------------. A particular coroutine usage pattern, which is illustrated by the `main`; function in the overview section, where a coroutine is created, manipulated and; destroyed by the same calling function, is common for coroutines implementing; RAII idiom and is suitable for allocation elision optimization which avoid; dynamic allocation by storing the coroutine frame",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:15549,resume,resume,15549,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability," contained within the object. This term is used in opposition to; `derived pointer`_. P; -. **PGO**; Profile-Guided Optimization. **PR**; Problem report. A bug filed on `the LLVM Bug Tracking System; <https://bugs.llvm.org/enter_bug.cgi>`_. **PRE**; Partial Redundancy Elimination. R; -. **RAUW**. Replace All Uses With. The functions ``User::replaceUsesOfWith()``,; ``Value::replaceAllUsesWith()``, and; ``Constant::replaceUsesOfWithOnConstant()`` implement the replacement of one; Value with another by iterating over its def/use chain and fixing up all of; the pointers to point to the new value. See; also `def/use chains <ProgrammersManual.html#iterating-over-def-use-use-def-chains>`_. **Reassociation**; Rearranging associative expressions to promote better redundancy elimination; and other optimization. For example, changing ``(A+B-A)`` into ``(B+A-A)``,; permitting it to be optimized into ``(B+0)`` then ``(B)``. **RFC**; Request for Comment. An email sent to a project mailing list in order to; solicit feedback on a proposed change. .. _roots:; .. _stack roots:. **Root**; In garbage collection, a pointer variable lying outside of the `heap`_ from; which the collector begins its reachability analysis. In the context of code; generation, ""root"" almost always refers to a ""stack root"" --- a local or; temporary variable within an executing function. **RPO**; Reverse postorder. **RTTI**; Run-time Type Information. S; -. .. _safe point:. **Safe Point**; In garbage collection, it is necessary to identify `stack roots`_ so that; reachability analysis may proceed. It may be infeasible to provide this; information for every instruction, so instead the information is; calculated only at designated safe points. With a copying collector,; `derived pointers`_ must not be retained across safe points and `object; pointers`_ must be reloaded from stack roots. **SDISel**; Selection DAG Instruction Selection. **SCC**; Strongly Connected Component. **SCCP**; Sparse Conditional Constant Pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst:7088,feedback,feedback,7088,interpreter/llvm-project/llvm/docs/Lexicon.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Lexicon.rst,1,['feedback'],['feedback']
Usability," context menu) for TLine, TBox, TText, TLatex, TDiamond, TGaxis, TASImage; 9. Use new gStyle attributes for candle and violin plots; 10. Implement autoplace for TLegend, also via context menu; 11. Change algorithm of building smooth (bezier) curves; 12. Let change physical node visibility in TGeo drawings; 13. Use TGaxis attributes from gStyle - fAxisMaxDigits, fStripDecimals and exponent offset; 14. Implement ""projxy"" draw option for TH2 - like projxy3 or projx1_y5; 15. Support custom function in TGaxis - when drawn in TWebCanvas; 16. Introduce settings.WithCredentials, set xhr.withCredentials = true when submitting HTTP requests; 17. Let superimpose TH3 and geo drawings; 18. Apply pad draw options like 'gridx' or 'logy' to all subpads; 19. Support new TScatter and TAnnotation classes; 20. Implement moving and resizing of subpads; 21. Implement zooming in the TASImage; 22. Let configure position and direction of camera for TGeo, let create URL for that; 23. Support labels rotation for simple axis in geometry; 24. Support many orthographic cameras with overlayed grid/labels; 25. Support InstancedMesh for TGeo drawing, let show really large geometries; 26. Implement 'inject=path/script_name.js' url option to inject scripts without emulating of v6; 27. Exclude 'HEAD' http request when reading ROOT file, all necessary info can be get from first real HTTP request; 28. Provide makeImage function for generation of svg, png and jpeg images in batch and interactively (#257); 29. Implement interactive zoom shifting when middle-mouse button down or single-touch moving; 30. Several improvements for touch devices or devices with small displays; 31. Remove settings.FrameNDC, use Style.fPadLeft/Right/Top/BottomMargin values instead; 32. Fix - rescan sumw2 when update TH1; 33. Fix - correct placing for TLegend header; 34. Fix - correctly align sub/super scripts in complex TLatex; 35. Fix - correctly set visibility level for geo drawing (#258); 36. Fix - use more factor for number o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:13456,simpl,simple,13456,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['simpl'],['simple']
Usability," context,; except the result kind is a location description, the compilation unit is; unspecified, the object is unspecified, and an initial stack comprising the; location description of the current CFA (see; :ref:`amdgpu-dwarf-operation-expressions`). The DWARF is ill-formed if the CFA location description is not a memory byte; address location description, or if the register size does not match the size; of an address in the address space of the current CFA location description. *Since the CFA location description is required to be a memory byte address; location description, the value of val_offset(N) will also be a memory byte; address location description since it is offsetting the CFA location; description by N bytes. Furthermore, the value of val_offset(N) will be a; memory byte address in the same address space as the CFA location; description.*. .. note::. Should DWARF allow the address size to be a different size to the size of; the register? Requiring them to be the same bit size avoids any issue of; conversion as the bit contents of the register is simply interpreted as a; value of the address. GDB has a per register hook that allows a target specific conversion on a; register by register basis. It defaults to truncation of bigger registers,; and to actually reading bytes from the next register (or reads out of bounds; for the last register) for smaller registers. There are no GDB tests that; read a register out of bounds (except an illegal hand written assembly; test). *register(R)*; This register has been stored in another register numbered R. The previous value of this register is the location description obtained using; the call frame information for the current frame and current program location; for register R. The DWARF is ill-formed if the size of this register does not match the size; of register R or if there is a cyclic dependency in the call frame; information. .. note::. Should this also allow R to be larger than this register? If so is the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:193369,simpl,simply,193369,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simply']
Usability," controls whether or not the atomic operation is ordered with respect to the; whole system, the current device, an OpenCL workgroup, wavefront, or just a; single thread. If these are used on a target that does not support atomic; scopes, then they will behave exactly as the standard GNU atomic builtins. Low-level ARM exclusive memory builtins; ---------------------------------------. Clang provides overloaded builtins giving direct access to the three key ARM; instructions for implementing atomic operations. .. code-block:: c. T __builtin_arm_ldrex(const volatile T *addr);; T __builtin_arm_ldaex(const volatile T *addr);; int __builtin_arm_strex(T val, volatile T *addr);; int __builtin_arm_stlex(T val, volatile T *addr);; void __builtin_arm_clrex(void);. The types ``T`` currently supported are:. * Integer types with width at most 64 bits (or 128 bits on AArch64).; * Floating-point types; * Pointer types. Note that the compiler does not guarantee it will not insert stores which clear; the exclusive monitor in between an ``ldrex`` type operation and its paired; ``strex``. In practice this is only usually a risk when the extra store is on; the same cache line as the variable being modified and Clang will only insert; stack stores on its own, so it is best not to use these operations on variables; with automatic storage duration. Also, loads and stores may be implicit in code written between the ``ldrex`` and; ``strex``. Clang will not necessarily mitigate the effects of these either, so; care should be exercised. For these reasons the higher level atomic primitives should be preferred where; possible. Non-temporal load/store builtins; --------------------------------. Clang provides overloaded builtins allowing generation of non-temporal memory; accesses. .. code-block:: c. T __builtin_nontemporal_load(T *addr);; void __builtin_nontemporal_store(T value, T *addr);. The types ``T`` currently supported are:. * Integer types.; * Floating-point types.; * Vector types. Note t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:144097,clear,clear,144097,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['clear'],['clear']
Usability," current iterator; - **But not** inserting/deleting before/at the current iterator position. With a debug build (with assertions), the legacy iterators will check that the collection is not mutated. In a release build, elements might be skipped or be iterated twice. #### Moving away from the slower iterators; The legacy iterators have been flagged with a special deprecation macro that can be used help the user use the recommended ROOT interface. Defining one of the [deprecation macros](#preprocessor-deprecation-macros) (either in a single translation unit or in the build system), and creating a legacy iterator will trigger a compiler warning such as:; ```; <path>/RooChebychev.cxx:66:34: warning: 'createIterator' is deprecated: There is a superior alternative: begin(), end() and range-based for loops. [-Wdeprecated-declarations]; TIterator* coefIter = coefList.createIterator() ;; ^; 1 warning generated.; ```. ## TMVA. This release provides a consolidation and several fixes of the new machine learning tools provided in TMVA such as the Deep Learning module.; The method `TMVA::Types::kDL` should be used now for building Deep Learning architecture in TMVA, while `TMVA::Types::kDNN` is now deprecated. `TMVA::Types::kDL` provides all the functionality of `TMVA::Types::kDNN`, i.e building fully connected dense layer, but in addition supports building convolutional and recurrent neural network architectures.; These release contains improvements in the `MethodDL` such as:; - fix droput support for dense layer; - add protection to avoid returning NaN in the cross-entropy loss function. In addition we have :. - New `TMVA::Executor` class to control the multi-thread running of TMVA. By default now MT running will be enabled only when `ROOT::EnabledImplicitMT()` is called. But we can take the control of the threads by using `TMVA::gConfig().EnableMT(...)` and `TMVA::gConfig().DisableMT()`. ### PyMVA; - add support when using the Tensorflow backend in Keras to control the number o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:17254,learn,learning,17254,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['learn'],['learning']
Usability," custom user control flags, with their getters and setters and three new signal methods (required by EVE). All these were implemented for better control of the TGListTree behavior.; ; fUserControlled is a flag to take over the control; fEventHandled is a flag to tell TGListTree that the current event has been processed by user.; ; MouseOver(TGListTreeItem *entry); MouseOver(TGListTreeItem *entry, UInt_t mask); Clicked(TGListTreeItem *entry, Int_t btn, UInt_t mask, Int_t x, Int_t y). The new DrawOutline() method draws a colored outline around a list tree item following the mouse position.; Implemented correct keyboard navigation.; Improvements for list trees containing a large number of items (i.e. one million). TGTab. Added a new signal method Removed(Int_t id) to notify when a tab was removed. TGListBox. Fixed flickering problem on Windows. TGDockableFrame. Introduced the fFixedSize option, to let user choose if the undocked frame may; be resized or not. Keep the (fixed) original docked frame size when undocked; (i.e. for menus and toolbars). TGShutter. Two helper methods added:; ; SetSelectedItem(const char *name) - switch to the shutter section 'name'.; EnableItem(const char *name, Bool_t on) - enable/disable the shutter section 'name' according to the value of the second parameter 'on'.; . TGFileDialog; The File Open/Close dialogs show the list of all available (mounted) drives on Windows. Modal Dialogs; On Windows, any modal dialog now stays on top of its parent (true modal mode). Context Menus; The context menu of ROOT classes can be created with hierarchical sub-menus, which are more convenient and offer better organization. This makes possible to access more class methods from the context menu (without having the menu becoming larger than the screen). The next is an example of the hierarchihal submenu structure shown below. void SetLevelOne(EPaletteType palette = pal3); // *MENU={Hierarchy=""Candidates/SetLevelOne""}*; void SetPalette(EPaletteType palette = pal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v520/index.html:1944,undo,undocked,1944,gui/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v520/index.html,1,['undo'],['undocked']
Usability," data member of literal type; Clang 18. 2599; C++23; What does initializing a parameter include?; Unknown. 2600; DR; Type dependency of placeholder types; Unknown. 2601; C++23; Tracking of created and destroyed subobjects; Unknown. 2602; C++23; consteval defaulted functions; Unknown. 2603; C++23; Holistic functional equivalence for function templates; Unknown. 2604; C++23; Attributes for an explicit specialization; Unknown. 2605; C++23; Implicit-lifetime aggregates; Unknown. 2606; CD6; static_cast from ""pointer to void"" does not handle similar types; Unknown. 2607; drafting; Visibility of enumerator names; Not resolved. 2608; CD6; Omitting an empty template argument list; Unknown. 2609; open; Padding in class types; Not resolved. 2610; C++23; Indirect private base classes in aggregates; Unknown. 2611; C++23; Missing parentheses in expansion of fold-expression could cause syntactic reinterpretation; Unknown. 2612; C++23; Incorrect comment in example; Unknown. 2613; C++23; Incomplete definition of resumer; Unknown. 2614; C++23; Unspecified results for class member access; Unknown. 2615; C++23; Missing __has_cpp_attribute(assume); Unknown. 2616; C++23; Imprecise restrictions on break and continue; Unknown. 2617; review; Default template arguments for template members of non-template classes; Not resolved. 2618; C++23; Substitution during deduction should exclude exception specifications; Unknown. 2619; C++23; Kind of initialization for a designated-initializer-list; Unknown. 2620; C++23; Nonsensical disambiguation rule; Unknown. 2621; C++23; Kind of lookup for using enum declarations; Clang 16. 2622; C++23; Compounding types from function and pointer-to-member types; Unknown. 2623; drafting; Invoking destroying operator delete for constructor failure; Not resolved. 2624; C++23; Array delete expression with no array cookie; Unknown. 2625; C++23; Deletion of pointer to out-of-lifetime object; Unknown. 2626; C++23; Rephrase ones' complement using base-2 representation; Un",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:180042,resume,resumer,180042,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['resume'],['resumer']
Usability," default minimiser is MINUIT, a; package originally implemented in the FORTRAN programming language. A; C++ version is also available, MINUIT2, as well as Fumili [@Fumili] an; algorithm optimised for fitting. The; minimisation algorithms can be selected using the static functions of; the `ROOT::Math::MinimizerOptions` class. Steering options for the; minimiser, such as the convergence tolerance or the maximum number of; function calls, can also be set using the methods of this class. All; currently implemented minimisers are documented in the reference; documentation of ROOT: have a look for example to the; `ROOT::Math::Minimizer` class documentation.; \newpage; The complication level of the code below is intentionally a little; higher than in the previous examples. The graphical output of the macro; is shown in Figure [6.1](#f61):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro8.C; ```. Some step by step explanation is at this point necessary:. - Lines *1-3*: A simple function to ease the make-up of lines.; Remember that the class `TF1` inherits from `TAttLine`. - Lines *5-7* : Definition of a customised function, namely a Gaussian; (the ""signal"") plus a parabolic function, the ""background"". - Lines *10-12*: Some make-up for the Canvas. In particular we want; that the parameters of the fit appear very clearly and nicely on the; plot. - Lines *20-25*: Define and initialise an instance of `TF1`. - Lines *27-31*: Define and fill a histogram. - Lines *33-38*: For convenience, the same function as for the; generation of the pseudo-data is used in the fit; hence, we need to; reset the function parameters. This part of the code is very; important for each fit procedure, as it sets the initial values of; the fit. - Line *41*: A very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:2632,simpl,simple,2632,documentation/primer/functions_and_parameter_estimation.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md,1,['simpl'],['simple']
Usability," defined in ``BLOCKINFO`` blocks receive abbreviation; IDs as described in `DEFINE_ABBREV`_. The ``BLOCKNAME`` record (code 2) can optionally occur in this block. The; elements of the record are the bytes of the string name of the block.; llvm-bcanalyzer can use this to dump out bitcode files symbolically. The ``SETRECORDNAME`` record (code 3) can also optionally occur in this block.; The first operand value is a record ID number, and the rest of the elements of; the record are the bytes for the string name of the record. llvm-bcanalyzer can; use this to dump out bitcode files symbolically. Note that although the data in ``BLOCKINFO`` blocks is described as ""metadata,""; the abbreviations they contain are essential for parsing records from the; corresponding blocks. It is not safe to skip them. .. _wrapper:. Bitcode Wrapper Format; ======================. Bitcode files for LLVM IR may optionally be wrapped in a simple wrapper; structure. This structure contains a simple header that indicates the offset; and size of the embedded BC file. This allows additional information to be; stored alongside the BC file. The structure of this file header is:. :raw-html:`<tt><blockquote>`; [Magic\ :sub:`32`, Version\ :sub:`32`, Offset\ :sub:`32`, Size\ :sub:`32`, CPUType\ :sub:`32`]; :raw-html:`</blockquote></tt>`. Each of the fields are 32-bit fields stored in little endian form (as with the; rest of the bitcode file fields). The Magic number is always ``0x0B17C0DE`` and; the version is currently always ``0``. The Offset field is the offset in bytes; to the start of the bitcode stream in the file, and the Size field is the size; in bytes of the stream. CPUType is a target-specific value that can be used to; encode the CPU of the target. .. _native object file:. Native Object File Wrapper Format; =================================. Bitcode files for LLVM IR may also be wrapped in a native object file; (i.e. ELF, COFF, Mach-O). The bitcode must be stored in a section of the object; fi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:18100,simpl,simple,18100,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['simpl'],['simple']
Usability," depending on the oldest version of Clang you wish to support. * From Clang 10 onwards, ``__has_builtin(__X)`` can be used.; * From Clang 6 onwards, ``!__is_identifier(__X)`` can be used.; * From Clang 3 onwards, ``__has_feature(X)`` can be used, but only supports; the following traits:. * ``__has_nothrow_assign``; * ``__has_nothrow_copy``; * ``__has_nothrow_constructor``; * ``__has_trivial_assign``; * ``__has_trivial_copy``; * ``__has_trivial_constructor``; * ``__has_trivial_destructor``; * ``__has_virtual_destructor``; * ``__is_abstract``; * ``__is_base_of``; * ``__is_class``; * ``__is_constructible``; * ``__is_convertible_to``; * ``__is_empty``; * ``__is_enum``; * ``__is_final``; * ``__is_literal``; * ``__is_standard_layout``; * ``__is_pod``; * ``__is_polymorphic``; * ``__is_sealed``; * ``__is_trivial``; * ``__is_trivially_assignable``; * ``__is_trivially_constructible``; * ``__is_trivially_copyable``; * ``__is_union``; * ``__underlying_type``. A simplistic usage example as might be seen in standard C++ headers follows:. .. code-block:: c++. #if __has_builtin(__is_convertible_to); template<typename From, typename To>; struct is_convertible_to {; static const bool value = __is_convertible_to(From, To);; };; #else; // Emulate type trait for compatibility with other compilers.; #endif. Blocks; ======. The syntax and high level language feature description is in; :doc:`BlockLanguageSpec<BlockLanguageSpec>`. Implementation and ABI details for; the clang implementation are in :doc:`Block-ABI-Apple<Block-ABI-Apple>`. Query for this feature with ``__has_extension(blocks)``. ASM Goto with Output Constraints; ================================. Outputs may be used along any branches from the ``asm goto`` whether the; branches are taken or not. Query for this feature with ``__has_extension(gnu_asm_goto_with_outputs)``. Prior to clang-16, the output may only be used safely when the indirect; branches are not taken. Query for this difference with; ``__has_extension(gnu_asm_goto",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:66343,simpl,simplistic,66343,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['simpl'],['simplistic']
Usability," do not follow the; project how the C API is changing and evolving. .. _toolchain:. Updating Toolchain Requirements; -------------------------------. We intend to require newer toolchains as time goes by. This means LLVM's; codebase can use newer versions of C++ as they get standardized. Requiring newer; toolchains to build LLVM can be painful for those building LLVM; therefore, it; will only be done through the following process:. * It is a general goal to support LLVM and GCC versions from the last 3 years; at a minimum. This time-based guideline is not strict: we may support much; older compilers, or decide to support fewer versions. * An RFC is sent to the `LLVM Discourse forums`_. - Detail upsides of the version increase (e.g. which newer C++ language or; library features LLVM should use; avoid miscompiles in particular compiler; versions, etc).; - Detail downsides on important platforms (e.g. Ubuntu LTS status). * Once the RFC reaches consensus, update the CMake toolchain version checks as; well as the :doc:`getting started<GettingStarted>` guide. This provides a; softer transition path for developers compiling LLVM, because the; error can be turned into a warning using a CMake flag. This is an important; step: LLVM still doesn't have code which requires the new toolchains, but it; soon will. If you compile LLVM but don't read the forums, we should; tell you!. * Ensure that at least one LLVM release has had this soft-error. Not all; developers compile LLVM top-of-tree. These release-bound developers should; also be told about upcoming changes. * Turn the soft-error into a hard-error after said LLVM release has branched. * Update the :doc:`coding standards<CodingStandards>` to allow the new; features we've explicitly approved in the RFC. * Start using the new features in LLVM's codebase. Here's a `sample RFC; <https://discourse.llvm.org/t/rfc-migrating-past-c-11/50943>`_ and the; `corresponding change <https://reviews.llvm.org/D57264>`_. .. _ci-usage:. Working ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:34892,guid,guide,34892,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['guid'],['guide']
Usability," do so. Process(...) methods with the file; name argument replaced by 'TSelector *' have  introduced where; relevant (TProof, TProofPlayer and their derivatives, TDSet).  ; Add the possibility to force submerging at node level, i.e. one; submerger per physical machine. In this way the network traffic can be; minimized, for example when merging large output files. The new feature; is enabled by setting the Int_t parameter 'PROOF_MergersByHost' (or the; directive 'Proof.MergersByHost') to a non-null value.; Simplify enabling of basic feedback. In TProof::Process, add; support for switches ""fb=name1,name2,name3,... "" or; ""feedback=name1,name2,name3,... "" in the option field. This enables; feedback for the specified objects, creating a TDrawFeedback object; attached to the session. Feedback for the specified objects is disabled; at the end of the query and the created TDrawFeedback is destroyed. The; special name 'stats' enables the three feedback histograms required by; a dedicated new class TStatsFeedback, and uses a TStatsFeedback instead; of TDrawFeedback to display the feedback. . Improvements; ; Add to TProofMgr two static functions to upload files. These; functions are both called UploadFiles and differ in the first argument,; which is used to pass the files to be uploaded. These can be given as a; list (of TFileInfo or TObjString), a directory or specified in a text; file.; Add support for paralell dataset verification. This is; implemented via a dedicated TSelector (TSelVerifyDataSet) which is run; over the list of files in the dataset via TPacketizerFile. The file; order is preserved using the recently introduced index in TFileInfo.; In TProofOutputFile, add switch to control the way histograms; are merged by TFileMerger, i.e. one-by-one or all-in-one-go. The; default is one-by-one which requires much less memory. Merging in; one-go (the previous default) can be activated by passing 'H' in the; constructor options.; In ProofBench, add possibility to change the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html:2291,feedback,feedback,2291,proof/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html,2,['feedback'],['feedback']
Usability," document describing cycles as a generalization of loops. :doc:`Vectorizers`; This document describes the current status of vectorization in LLVM. :doc:`LinkTimeOptimization`; This document describes the interface between LLVM intermodular optimizer; and the linker and its design. :doc:`GoldPlugin`; How to build your programs with link-time optimization on Linux. :doc:`Remarks`; A reference on the implementation of remarks in LLVM. :doc:`Source Level Debugging with LLVM <SourceLevelDebugging>`; This document describes the design and philosophy behind the LLVM; source-level debugger. :doc:`How to Update Debug Info <HowToUpdateDebugInfo>`; This document specifies how to correctly update debug info in various kinds; of code transformations. :doc:`InstrRefDebugInfo`; This document explains how LLVM uses value tracking, or instruction; referencing, to determine variable locations for debug info in the final; stages of compilation. :doc:`RemoveDIsDebugInfo`; This is a migration guide describing how to move from debug info using; intrinsics such as dbg.value to using the non-instruction DPValue object. :doc:`InstrProfileFormat`; This document explains two binary formats of instrumentation-based profiles. Code Generation; ---------------. :doc:`WritingAnLLVMBackend`; Information on how to write LLVM backends for machine targets. :doc:`CodeGenerator`; The design and implementation of the LLVM code generator. Useful if you are; working on retargetting LLVM to a new architecture, designing a new codegen; pass, or enhancing existing components. :doc:`TableGen <TableGen/index>`; Describes the TableGen tool, which is used heavily by the LLVM code; generator. ==========; GlobalISel; ==========. :doc:`MIRPatterns <GlobalISel/MIRPatterns>`; Describes the design of MIR Patterns and how to use them. ===; JIT; ===. :doc:`MCJITDesignAndImplementation`; Describes the inner workings of MCJIT execution engine. :doc:`ORCv2`; Describes the design and implementation of the ORC APIs, including ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst:4395,guid,guide,4395,interpreter/llvm-project/llvm/docs/UserGuides.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst,1,['guid'],['guide']
Usability," dumps). .. option:: --print-delta-passes . Print list of delta passes, passable to --delta-passes as a comma separated liste. .. option:: --skip-delta-passes=<string> . Delta passes to not run, separated by commas. By default, run all delta passes. .. option:: --starting-granularity-level=<uint>. Number of times to divide chunks prior to first test. Note : Granularity refers to the level of detail at which the reduction process operates.; A lower granularity means that the reduction process operates at a more coarse-grained level,; while a higher granularity means that it operates at a more fine-grained level. .. option:: --test=<string> . Name of the interesting-ness test to be run. .. option:: --test-arg=<string> . Arguments passed onto the interesting-ness test. .. option:: --verbose . Print extra debugging information.; ; .. option:: --write-tmp-files-as-bitcode . Always write temporary files as bitcode instead of textual IR. .. option:: -x={ir|mir}. Input language as ir or mir. EXIT STATUS; ------------. :program:`llvm-reduce` returns 0 under normal operation. It returns a non-zero; exit code if there were any errors. EXAMPLE; -------. :program:`llvm-reduce` can be used to simplify a test that causes a; compiler crash. For example, let's assume that `opt` is crashing on the IR file; `test.ll` with error message `Assertion failed at line 1234 of; WhateverFile.cpp`, when running at `-O2`. The test case of `test.ll` can be reduced by invoking the following; command:. .. code-block:: bash. $(LLVM_BUILD_FOLDER)/bin/llvm-reduce --test=script.sh <path to>/test.ll. The shell script passed to the option `test` consists of the; following:. .. code-block:: bash. $(LLVM_BUILD_FOLDER)/bin/opt -O2 -disable-output $1 \; |& grep ""Assertion failed at line 1234 of WhateverFile.cpp"". (In this script, `grep` exits with 0 if it finds the string and that; becomes the whole script's status.). This example can be generalized to other tools that process IR files,; for example `llc`.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-reduce.rst:2886,simpl,simplify,2886,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-reduce.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-reduce.rst,1,['simpl'],['simplify']
Usability," enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data->Draw(""Current/Potential:Temperature""); ```. It should have become clear from these examples how to navigate in such; a multi-dimensional space of variables and unveil relations between; variables using n-tuples. ### Reading N-tuples. For completeness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the content of a n-tuple:; after loading the n-tuple, its branches are assigned to variables and; `GetEntry(long)` automatically fills them with the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:3825,clear,clear,3825,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['clear'],['clear']
Usability," end condition.; Value *EndCond = End->codegen();; if (!EndCond); return nullptr;. // Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.; Value *CurVar = Builder->CreateLoad(Alloca->getAllocatedType(), Alloca,; VarName.c_str());; Value *NextVar = Builder->CreateFAdd(CurVar, StepVal, ""nextvar"");; Builder->CreateStore(NextVar, Alloca);; ... This code is virtually identical to the code `before we allowed mutable; variables <LangImpl05.html#code-generation-for-the-for-loop>`_. The big difference is that we; no longer have to construct a PHI node, and we use load/store to access; the variable as needed. To support mutable argument variables, we need to also make allocas for; them. The code for this is also pretty simple:. .. code-block:: c++. Function *FunctionAST::codegen() {; ...; Builder->SetInsertPoint(BB);. // Record the function arguments in the NamedValues map.; NamedValues.clear();; for (auto &Arg : TheFunction->args()) {; // Create an alloca for this variable.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());. // Store the initial value into the alloca.; Builder->CreateStore(&Arg, Alloca);. // Add arguments to variable symbol table.; NamedValues[std::string(Arg.getName())] = Alloca;; }. if (Value *RetVal = Body->codegen()) {; ... For each argument, we make an alloca, store the input value to the; function into the alloca, and register the alloca as the memory location; for the argument. This method gets invoked by ``FunctionAST::codegen()``; right after it sets up the entry block for the function. The final missing piece is adding the mem2reg pass, which allows us to; get good codegen once again:. .. code-block:: c++. // Promote allocas to registers.; TheFPM->add(createPromoteMemoryToRegisterPass());; // Do simple ""peephole"" optimizations and bit-twiddling optzns.; TheFPM->add(createInstructionCombiningPass());; // Reassociate expressions.; TheFPM->add(createReassociatePass",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:15786,clear,clear,15786,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['clear'],['clear']
Usability," equivalent to; G_EXTRACT for scalar types, but acts elementwise on vectors. .. code-block:: none. %1:_(s16) = G_TRUNC %0:_(s32). Type Conversions; ----------------. G_INTTOPTR; ^^^^^^^^^^. Convert an integer to a pointer. .. code-block:: none. %1:_(p0) = G_INTTOPTR %0:_(s32). G_PTRTOINT; ^^^^^^^^^^. Convert a pointer to an integer. .. code-block:: none. %1:_(s32) = G_PTRTOINT %0:_(p0). G_BITCAST; ^^^^^^^^^. Reinterpret a value as a new type. This is usually done without; changing any bits but this is not always the case due a subtlety in the; definition of the :ref:`LLVM-IR Bitcast Instruction <i_bitcast>`. It; is allowed to bitcast between pointers with the same size, but; different address spaces. .. code-block:: none. %1:_(s64) = G_BITCAST %0:_(<2 x s32>). G_ADDRSPACE_CAST; ^^^^^^^^^^^^^^^^. Convert a pointer to an address space to a pointer to another address space. .. code-block:: none. %1:_(p1) = G_ADDRSPACE_CAST %0:_(p0). .. caution::. :ref:`i_addrspacecast` doesn't mention what happens if the cast is simply; invalid (i.e. if the address spaces are disjoint). Scalar Operations; -----------------. G_EXTRACT; ^^^^^^^^^. Extract a register of the specified size, starting from the block given by; index. This will almost certainly be mapped to sub-register COPYs after; register banks have been selected. .. code-block:: none. %3:_(s32) = G_EXTRACT %2:_(s64), 32. G_INSERT; ^^^^^^^^. Insert a smaller register into a larger one at the specified bit-index. .. code-block:: none. %2:_(s64) = G_INSERT %0:(_s64), %1:_(s32), 0. G_MERGE_VALUES; ^^^^^^^^^^^^^^. Concatenate multiple registers of the same size into a wider register.; The input operands are always ordered from lowest bits to highest:. .. code-block:: none. %0:(s32) = G_MERGE_VALUES %bits_0_7:(s8), %bits_8_15:(s8),; %bits_16_23:(s8), %bits_24_31:(s8). G_UNMERGE_VALUES; ^^^^^^^^^^^^^^^^. Extract multiple registers of the specified size, starting from blocks given by; indexes. This will almost certainly be mapped t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst:3460,simpl,simply,3460,interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,1,['simpl'],['simply']
Usability," errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where you absolutely must emit a non-programmatic error and; the ``Error`` model isn't workable you can call ``report_fatal_error``,; which will call installed error handlers, print a message, and abort the; program. The use of `report_fatal_error` in this case is discouraged. Recoverable errors are modeled using LLVM's ``Error`` scheme. This scheme; represents errors using function return values, similar to classic C integer; error codes, or C++'s ``std::error_code``. However, the ``Error`` class is; actually a lightweight wrapper for user-defined error types, allowing arbitrary; information to be attached to describe the error. This is similar to the way C++; exceptions allow throwing of user-defined types. Success values are created by calling ``Error::success()``, E",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:17934,simpl,simple,17934,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability," errors based on types; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". In some contexts, certain types of error are known to be benign. For example,; when walking an archive, some clients may be happy to skip over badly formatted; object files rather than terminating the walk immediately. Skipping badly; formatted objects could be achieved using an elaborate handler method, but the; Error.h header provides two utilities that make this idiom much cleaner: the; type inspection method, ``isA``, and the ``consumeError`` function:. .. code-block:: c++. Error walkArchive(Archive A) {; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()) {; if (Err.isA<BadFileFormat>()); consumeError(std::move(Err)); else; return Err;; }; auto &Child = *ChildOrErr;; // Use Child; ...; }; return Error::success();; }. Concatenating Errors with joinErrors; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". In the archive walking example above ``BadFileFormat`` errors are simply; consumed and ignored. If the client had wanted report these errors after; completing the walk over the archive they could use the ``joinErrors`` utility:. .. code-block:: c++. Error walkArchive(Archive A) {; Error DeferredErrs = Error::success();; for (unsigned I = 0; I != A.numMembers(); ++I) {; auto ChildOrErr = A.getMember(I);; if (auto Err = ChildOrErr.takeError()); if (Err.isA<BadFileFormat>()); DeferredErrs = joinErrors(std::move(DeferredErrs), std::move(Err));; else; return Err;; auto &Child = *ChildOrErr;; // Use Child; ...; }; return DeferredErrs;; }. The ``joinErrors`` routine builds a special error type called ``ErrorList``,; which holds a list of user defined errors. The ``handleErrors`` routine; recognizes this type and will attempt to handle each of the contained errors in; order. If all contained errors can be handled, ``handleErrors`` will return; ``Error::success()``, otherwise ``handleErrors`` will concatenate the remaining; errors and retur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:35808,simpl,simply,35808,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simply']
Usability," evaluated as for `TTree::Draw()`. Input and outputs; are taken from the **`TTree`** associated with the network. This; **`TTree`** can be given as argument of the constructor or defined; later with `TMultiLayerPerceptron::SetData()`. Events can also be; weighted. The weight expression can be given in the constructor or set; later with the method `SetWeight()` of the class; **`TMultiLayerPerceptron`**. Two datasets must be defined before; learning the network: a training dataset that is used when minimizing; the error, and a test dataset that will avoid bias. Those two datasets; can be built aside and then given to the network, or can be built from; a standard expression. By default, half of the events are put in both; datasets. ``` {.cpp}; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; ```. The method `TMultiLayerPerceptron::SetLearningMethod()` defines the; learning method. Learning methods are:. ```; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; ```. The training can start with; `TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options).` The; first argument is the number of epochs while option is a string that; can contain ""`text`"" (simple text output), ""`graph`"" (evaluating; graphical training curves), ""`update` `=` `X`"" (step for the; text/graph output update) or ""`+`"" (will skip the randomization and; start from the previous values). All combinations are available. ``` {.cpp}; network.Train(1000,""text,graph,update=10""); // full output every; // 10 epochs; network.Train(100,""text,+""); // 100 more epochs; //starts with existing weights; ```. The weights can be saved to a file (`DumpWeights`) and then reloaded; (`LoadWeights",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:76252,learn,learning,76252,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['learn'],['learning']
Usability," example if you want to; draw a graph connecting all the `x`, `y(or z)` points. Note that you may; have a tree (or chain) with 1 billion entries, but only a few may; survive the cuts and will fit without problems in these arrays. ## Using TTree::MakeClass; \index{tree!MakeClass}. The `TTree::Draw` method is convenient and easy to use; however it falls; short if you need to do some programming with the variable. For example, for plotting the masses of all oppositely changed pairs of; tracks, you would need to write a program that loops over all events,; finds all pairs of tracks, and calculates the required quantities. We; have shown how to retrieve the data arrays from the branches of the tree; in the previous section, and you could just write that program from; scratch. Since this is a very common task, ROOT provides a utility that; generates a skeleton class designed to loop over the entries of the; tree. This is the `TTree::MakeClass` method. We will now go through the steps; of using `MakeClass` with a simplified example. The methods used here; obviously work for complex event loop calculations. These are our assumptions: we would like to do selective plotting and; loop through each entry of the tree and tracks. We chose a simple; example: we want to plot `fPx` of the first 100 tracks of each entry. We; have a ROOT tree with a branch for each data member in the ""`Event`""; object. To build this file and tree follow the instructions on how to; build the examples in `$ROOTSYS/test`. Execute `Event` and instruct it; to split the object with this command (from the UNIX command line). ``` {.cpp}; > $ROOTSYS/test/Event 400 1 2 1; ```. This creates an `Event.root` file with 400 events, compressed, split,; and filled. See `$ROOTSYS/test/MainEvent.cxx` for more info. The person who designed the tree makes a shared library available to; you, which defines the classes needed. In this case, the classes are; Event, `EventHeader`, and Track and they are defined in the shared; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:121752,simpl,simplified,121752,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simplified']
Usability," example the following; toy program that we build with XRay instrumentation, we can see how the; generated graph may be a helpful indicator of where time is being spent for the; application. .. code-block:: c++. // sample.cc; #include <iostream>; #include <thread>. [[clang::xray_always_instrument]] void f() {; std::cerr << '.';; }. [[clang::xray_always_instrument]] void g() {; for (int i = 0; i < 1 << 10; ++i) {; std::cerr << '-';; }; }. int main(int argc, char* argv[]) {; std::thread t1([] {; for (int i = 0; i < 1 << 10; ++i); f();; });; std::thread t2([] {; g();; });; t1.join();; t2.join();; std::cerr << '\n';; }. We then build the above with XRay instrumentation:. ::. $ clang++ -o sample -O3 sample.cc -std=c++11 -fxray-instrument -fxray-instruction-threshold=1; $ XRAY_OPTIONS=""patch_premain=true xray_mode=xray-basic"" ./sample. We can then explore the graph rendering of the trace generated by this sample; application. We assume you have the graphviz tools available in your system,; including both ``unflatten`` and ``dot``. If you prefer rendering or exploring; the graph using another tool, then that should be feasible as well. ``llvm-xray; graph`` will create DOT format graphs which should be usable in most graph; rendering applications. One example invocation of the ``llvm-xray graph``; command should yield some interesting insights to the workings of C++; applications:. ::. $ llvm-xray graph xray-log.sample.* -m sample --color-edges=sum --edge-label=sum \; | unflatten -f -l10 | dot -Tsvg -o sample.svg. Next Steps; ----------. If you have some interesting analyses you'd like to implement as part of the; llvm-xray tool, please feel free to propose them on the llvm-dev@ mailing list.; The following are some ideas to inspire you in getting involved and potentially; making things better. - Implement a query/filtering library that allows for finding patterns in the; XRay traces.; - Collecting function call stacks and how often they're encountered in the; XRay trace.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRayExample.rst:15276,usab,usable,15276,interpreter/llvm-project/llvm/docs/XRayExample.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRayExample.rst,1,['usab'],['usable']
Usability," files,; useful if one wishes to do a lot of development across directories; and does not want to find each file. One way to use it is to run,; for example: ``xemacs `utils/getsources.sh``` from the top of the LLVM source; tree. ``llvmgrep``. Performs an ``egrep -H -n`` on each source file in LLVM and; passes to it a regular expression provided on ``llvmgrep``'s command; line. This is an efficient way of searching the source base for a; particular regular expression. ``TableGen/``. Contains the tool used to generate register; descriptions, instruction set descriptions, and even assemblers from common; TableGen description files. ``vim/``. vim syntax-highlighting for LLVM assembly files; and TableGen description files. See the ``README`` for how to use them. .. _simple example:. An Example Using the LLVM Tool Chain; ====================================. This section gives an example of using LLVM with the Clang front end. Example with clang; ------------------. #. First, create a simple C file, name it 'hello.c':. .. code-block:: c. #include <stdio.h>. int main() {; printf(""hello world\n"");; return 0;; }. #. Next, compile the C file into a native executable:. .. code-block:: console. % clang hello.c -o hello. .. note::. Clang works just like GCC by default. The standard -S and -c arguments; work as usual (producing a native .s or .o file, respectively). #. Next, compile the C file into an LLVM bitcode file:. .. code-block:: console. % clang -O3 -emit-llvm hello.c -c -o hello.bc. The -emit-llvm option can be used with the -S or -c options to emit an LLVM; ``.ll`` or ``.bc`` file (respectively) for the code. This allows you to use; the `standard LLVM tools <CommandGuide/index.html>`_ on the bitcode file. #. Run the program in both forms. To run the program, use:. .. code-block:: console. % ./hello. and. .. code-block:: console. % lli hello.bc. The second examples shows how to invoke the LLVM JIT, :doc:`lli; <CommandGuide/lli>`. #. Use the ``llvm-dis`` utility to take a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:42173,simpl,simple,42173,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['simpl'],['simple']
Usability," flags for test case. We must also tell; cmake that we wish to run the tests on ``qemu-arm``. * ``-DCOMPILER_RT_EMULATOR=""qemu-arm -L /path/to/armhf/sysroot``; * ``-DCOMPILER_RT_INCLUDE_TESTS=ON``; * ``-DCOMPILER_RT_TEST_COMPILER=""/path/to/clang""``; * ``-DCOMPILER_RT_TEST_COMPILER_CFLAGS=""test-c-flags""``. The ``/path/to/armhf/sysroot`` should be the same as the one passed to; ``--sysroot`` in the ""build-c-flags"". The ""test-c-flags"" need to include the target, architecture, gcc-toolchain,; sysroot and arm/thumb state. The additional cmake defines such as; ``CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN`` do not apply when building the tests. If; you have put all of these in ""build-c-flags"" then these can be repeated. If you; wish to use lld to link the tests then add ``""-fuse-ld=lld``. Once cmake has completed the tests can be built and run using; ``ninja check-builtins``. Troubleshooting; ===============. The cmake try compile stage fails; ---------------------------------; At an early stage cmake will attempt to compile and link a simple C program to; test if the toolchain is working. This stage can often fail at link time if the ``--sysroot=`` and; ``--gcc-toolchain=`` options are not passed to the compiler. Check the; ``CMAKE_C_FLAGS`` and ``CMAKE_C_COMPILER_TARGET`` flags. It can be useful to build a simple example outside of cmake with your toolchain; to make sure it is working. For example: ``clang --target=arm-linux-gnueabi -march=armv7a --gcc-toolchain=/path/to/gcc-toolchain --sysroot=/path/to/gcc-toolchain/arm-linux-gnueabihf/libc helloworld.c``. Clang uses the host header files; --------------------------------; On debian based systems it is possible to install multiarch support for; arm-linux-gnueabi and arm-linux-gnueabihf. In many cases clang can successfully; use this multiarch support when ``--gcc-toolchain=`` and ``--sysroot=`` are not supplied.; Unfortunately clang adds ``/usr/local/include`` before; ``/usr/include/arm-linux-gnueabihf`` leading to errors when",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst:5899,simpl,simple,5899,interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,1,['simpl'],['simple']
Usability," form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). TrainingMethod No BP BP, GA, BFGS Train with Back-Propagation (BP), BFGS Algorithm (BFGS), or Genetic Algorithm (GA - slower and worse). LearningRate No 0.02 − ANN learning rate parameter. DecayRate No 0.01 − Decay rate for learning parameter. TestRate No 10 − Test for overtraining performed at each #th epochs. EpochMonitoring No False − Provide epoch-wise monitoring plots according to TestRate (caution: causes big ROOT output file!). Sampling No 1 − Only 'Sampling' (randomly selected) events are trained each epoch. SamplingEpoch No 1 − Sampling is used for the first 'SamplingEpoch' epochs, afterwards, all events are taken for training. SamplingImportance No 1 − The sampling weights of events in epochs which successful (worse estimator than before) are multiplied with SamplingImportance, else they are divided. SamplingTraining No True − The training sample is sampled. SamplingTesting No False − The testing sample is sampled. ResetStep No 50 − How often BFGS should reset history. Tau No 3 − LineSearch size step. BPMode No sequential sequential, batch Back-propagation learning mode: sequential or batch. BatchSize No -1 − Batch size: number of events/batch, only set if in Batch Mode, -1 for BatchSize=number_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:22480,learn,learning,22480,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['learn'],['learning']
Usability," frame of the current volume and to; compute the distance to exit its shape from inside. The returned value; is again compared to the maximum allowed step (the proposed one) and in; case the distance is safe no other action is performed and the proposed; step is approved. In case the boundary is closer, the computed distance; is taken as maximum allowed step. For optimization purposed, for; particles starting very close to the current volume boundary (less than; 0.01 microns) and exiting the algorithm stops here. After computing the distance to exit the current node, the distance to; the daughter of the current volume which is crossed next is computed by; **`TGeoManager`**`::FindNextDaughterBoundary().` This computes the; distance to all daughter candidates that can be possibly crossed by; using volume voxelization. The algorithm is efficient in average only in; case the number of daughters is greater than 4. For fewer nodes, a; simple loop is performed and the minimum distance (from a point outside; each shape) is taken and compared to the maximum allowed step. The step; value is again updated if `step<stepmax` . A special case is when the current node is declared as possibly; overlapping with something else. If this is the case, the distance is; computed for all possibly overlapping candidates, taking into account; the overlapping priorities (see also: "" Overlapping volumes ""). The global matrix describing the next crossed physical node is; systematically computed in case the value of the proposed step is; negative. In this case, one can subsequently call; `TGeoManager::ComputeNormalFast()` to get the normal vector to the; crossed surface, after propagating the current point with the; `TGeoManager::GetStep()` value. This propagation can be done like:. ``` {.cpp}; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; ```. Note: Th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:163517,simpl,simple,163517,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability," from the example; above and creates from it the header file `MySelector.h` and a template; to insert your own analysis code, `MySelector.C`.; \newpage. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/makeMySelector.C; ```. The template contains the entry points `Begin()` and `SlaveBegin()`; called before processing of the `TChain` starts, `Process()` called for; every entry of the chain, and `SlaveTerminate()` and `Terminate()`; called after the last entry has been processed. Typically,; initialization like booking of histograms is performed in; `SlaveBegin()`, the analysis, i.e. the selection of entries,; calculations and filling of histograms, is done in `Process()`, and; final operations like plotting and storing of results happen in; `SlaveTerminate()` or `Terminate()`. The entry points `SlaveBegin()` and `SlaveTerminate()` are called on; so-called slave nodes only if parallel processing via `PROOF` or; `PROOF lite` is enabled, as will be explained below. A simple example of a selector class is shown in the macro; `MySelector.C`. The example is executed with the following sequence of; commands:. ``` {.cpp}; > TChain *ch=new TChain(""cond_data"", ""Chain for Example N-Tuple"");; > ch->Add(""conductivity_experiment*.root"");; > ch->Process(""MySelector.C+"");; ```. As usual, the ""`+`"" appended to the name of the macro to be executed; initiates the compilation of the `MySelector.C` with the system compiler; in order to improve performance. The code in `MySelector.C`, shown in the listing below, books some; histograms in `SlaveBegin()` and adds them to the instance `fOutput`,; which is of the class `TList` [^6]. The final processing in; `Terminate()` allows to access histograms and store, display or save; them as pictures. This is shown in the example via the `TList`; `fOutput`. See the commented listing below for more details; most of the; text is actually comments generated automatically by; `TTree::MakeSelector`. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/MySelector.C; ```. ### *For po",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:7821,simpl,simple,7821,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['simpl'],['simple']
Usability," from trees, data sources or `Define`d columns; - Add `OnPartialResult` and `OnPartialResultSlot`: users can now register one or more functions to be executed on partial results of TDF actions during the event loop.; This mechanism is meant to be used to inspect partial results of the analysis or print useful debug information.; For example, both in single- and multi-thread event loops, one can draw a result histogram and update the canvas every 100 entries like this:; ```c++; auto h = tdf.Histo1D(""x"");; TCanvas c(""c"",""x hist"");; h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; ```; See the tutorials for more examples.; - Add `Sum`, an action that sums all values of a column for the processed entries; - The new TDataSource interface allows developers to pipe any kind of columnar data format into TDataFrame. Two example data sources have been provided: the TRootDS and the TTrivialDS. The former allows to read via the novel data source mechanism ROOT data, while the latter is a simple generator, created for testing and didactic purposes. It is therefore now possible to interface *any* kind of dataset/data format to ROOT as long as an adaptor which implements the pure virtual methods of the TDataSource interface can be written in C++.; - TDF can now read CSV files through a specialized TDataSource. Just create the TDF with `MakeCsvDataFrame(""f.csv"")`. Just create the TDF with MakeCsvDataFrame(""f.csv""). The data types of the CSV columns are automatically inferred. You can also specify if you want to use a different delimiter or if your file does not have headers.; - Users can now configure Snapshot to use different file open modes (""RECREATE"" or ""UPDATE""), compression level, compression algorithm, TTree split-level and autoflush settings; - Users can now access multi-threading slot and entry number as pre-defined columns ""tdfslot_"" and ""tdfentry_"". Especially useful for pyROOT users.; - Users can now specify filters and definitions as strings ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:12686,simpl,simple,12686,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['simpl'],['simple']
Usability," frontend has to; create a landing pad. The frontend has to destroy the already; constructed argument ``b`` before restoring the stack pointer. If the; constructor does not unwind, ``g`` is called. In the Microsoft C++ ABI,; ``g`` will destroy its arguments, and then the stack is restored in; ``f``. Design Considerations; =====================. Lifetime; --------. The biggest design consideration for this feature is object lifetime.; We cannot model the arguments as static allocas in the entry block,; because all calls need to use the memory at the top of the stack to pass; arguments. We cannot vend pointers to that memory at function entry; because after code generation they will alias. The rule against allocas between argument allocations and the call site; avoids this problem, but it creates a cleanup problem. Cleanup and; lifetime is handled explicitly with stack save and restore calls. In; the future, we may want to introduce a new construct such as ``freea``; or ``afree`` to make it clear that this stack adjusting cleanup is less; powerful than a full stack save and restore. Nested Calls and Copy Elision; -----------------------------. We also want to be able to support copy elision into these argument; slots. This means we have to support multiple live argument; allocations. Consider the evaluation of:. .. code-block:: c++. // Foo is non-trivial.; struct Foo { int a; Foo(); Foo(const &Foo); ~Foo(); };; Foo bar(Foo b);; int main() {; bar(bar(Foo()));; }. In this case, we want to be able to elide copies into ``bar``'s argument; slots. That means we need to have more than one set of argument frames; active at the same time. First, we need to allocate the frame for the; outer call so we can pass it in as the hidden struct return pointer to; the middle call. Then we do the same for the middle call, allocating a; frame and passing its address to ``Foo``'s default constructor. By; wrapping the evaluation of the inner ``bar`` with stack save and; restore, we can have",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InAlloca.rst:3815,clear,clear,3815,interpreter/llvm-project/llvm/docs/InAlloca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InAlloca.rst,1,['clear'],['clear']
Usability," functions F1(x) and F2(x) are calculated. One finds takes a value 'y' of both c.d.fs and ; determines the corresponding x values x1,x2 at which F1(x1)=F2(x2)=y. The value of the interpolated ; p.d.f fbar(x) is then calculated as fbar(alpha*x1+(1-alpha)*x2) = f1(x1)*f2(x2) / ( alpha*f2(x2) + ; (1-alpha)*f1(x1) ). Given that it is not easily possible to calculate the value of RooLinearMorph; at a given value of x, the value for all values of x are calculated in one by (through a scan over y); and stored in a cache. NB: The range of the interpolation parameter does not need to be [0,1], it can; be anything. New workspace tool RooSimWSTool. A new tool to clone and customize p.d.f.s into a RooSimultaneous p.d.f has been added. This new; tool succeeds the original RooSimPdfBuilder tool which had a similar functionality but; has a much cleaner interface, partly thanks to its use of the RooWorkspace class for both input; of prototype p.d.fs and output of built p.d.f.s. The simplest use case to to take a workspace p.d.f as prototype and 'split' a parameter of that p.d.f ; into two specialized parameters depending on a category in the dataset. ; For example, given a Gaussian p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'.; Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. . SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:11773,simpl,simplest,11773,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['simpl'],['simplest']
Usability," generate a file-level summary of coverage statistics instead of a; line-oriented report, try:. .. code-block:: console. # Step 3(c): Create a coverage summary.; % llvm-cov report ./foo -instr-profile=foo.profdata; Filename Regions Missed Regions Cover Functions Missed Functions Executed Lines Missed Lines Cover Branches Missed Branches Cover; --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------; /tmp/foo.cc 13 0 100.00% 3 0 100.00% 13 0 100.00% 12 2 83.33%; --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------; TOTAL 13 0 100.00% 3 0 100.00% 13 0 100.00% 12 2 83.33%. The ``llvm-cov`` tool supports specifying a custom demangler, writing out; reports in a directory structure, and generating html reports. For the full; list of options, please refer to the `command guide; <https://llvm.org/docs/CommandGuide/llvm-cov.html>`_. A few final notes:. * The ``-sparse`` flag is optional but can result in dramatically smaller; indexed profiles. This option should not be used if the indexed profile will; be reused for PGO. * Raw profiles can be discarded after they are indexed. Advanced use of the; profile runtime library allows an instrumented program to merge profiling; information directly into an existing raw profile on disk. The details are; out of scope. * The ``llvm-profdata`` tool can be used to merge together multiple raw or; indexed profiles. To combine profiling data from multiple runs of a program,; try e.g:. .. code-block:: console. % llvm-profdata merge -sparse foo1.profraw foo2.profdata -o foo3.profdata. Exporting coverage data; =======================. Coverage data can be exported into JSON using the ``llvm-cov export``; sub-command. There is a comprehensive reference which defines the structure of; the exported data at",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:9600,guid,guide,9600,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,1,['guid'],['guide']
Usability," globals;; #pragma link off all classes;; #pragma link off all functions;; #pragma link C++ class EventHeader+;; #pragma link C++ class Event-;; #pragma link C++ class HistogramManager+;; #pragma link C++ class Track+;. #endif; #pragma link C++ class EventHeader+;; ```. The ""`+`"" sign tells `rootcling` to use the new `Streamer `system; introduced in ROOT 3.0. The following is an example of a customized; `Streamer `for `Event`. The `Streamer` takes a **`TBuffer`** as a; parameter, and first checks to see if this is a case of reading or; writing the buffer. ``` {.cpp}; void Event::Streamer(TBuffer &R__b) {; if (R__b.IsReading()) {; Event::Class()->ReadBuffer(R__b, this);; fTransient = gDirectory; //save current directory; fPt= TMath::Sqrt(fPx*fPx + fPy*fPy + fPz*fPz);; } else {; Event::Class()->WriteBuffer(R__b, this);; }; }; ```. ### Writing Objects. The `Streamer` decomposes the objects into data members and writes them; to a buffer. It does not write the buffer to a file, it simply populates; a buffer with bytes representing the object. This allows us to write the; buffer to a file or do anything else we could do with the buffer. For; example, we can write it to a socket to send it over the network. This; is beyond the scope of this chapter, but it is worthwhile to emphasize; the need and advantage of separating the creation of the buffer from its; use. Let us look how a buffer is written to a file. The dictionary for a; class needs to be loaded before any object of that type can be saved. The `TObject::Write` method does the following:. - Creates a **`TKey`** object in the current directory. - Creates a **`TBuffer`** object which is part of the newly created; **`TKey`**. - Fills the **`TBuffer`** with a call to the `class::Streamer` method. - Creates a second buffer for compression, if needed. - Reserves space by scanning the **`TFree`** list. At this point, the; size of the buffer is known. - Writes the buffer to the file. - Releases the **`TBuffer`** part of the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:51280,simpl,simply,51280,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simply']
Usability," histograms, all; inheriting from the `TH1` class. We will focus in this chapter on uni-; and bi- dimensional histograms the bin contents of which are represented by; floating point numbers [^4], the `TH1F` and `TH2F` classes respectively. ## Your First Histogram ##. Let's suppose you want to measure the counts of a Geiger detector located in; proximity of a radioactive source in a given time interval. This would; give you an idea of the activity of your source. The count distribution; in this case is a Poisson distribution. Let's see how operatively you; can fill and draw a histogram with the following example macro. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro5.C; ```. Which gives you the following plot (Figure [5.1](#f51)):. [f51]: figures/poisson.png ""f51""; <a name=""f51""></a>. ![The result of a counting (pseudo) experiment. Only bins corresponding; to integer values are filled given the discrete nature of the poissonian; distribution. \label{f51}][f51]. Using histograms is rather simple. The main differences with respect to; graphs that emerge from the example are:. - line *5*: The histograms have a name and a title right from the; start, no predefined number of entries but a number of bins and a; lower-upper range. - line *15*: An entry is stored in the histogram through the; `TH1F::Fill` method. - line *18* and *21*: The histogram can be drawn also normalised, ROOT; automatically takes cares of the necessary rescaling. - line *24* to *30*: This small snippet shows how easy it is to access; the moments and associated errors of a histogram. ## Add and Divide Histograms ##. Quite a large number of operations can be carried out with histograms.; The most useful are addition and division. In the following macro we; will learn how to manage these procedures within ROOT. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro6.C; ```. The plots that you will obtain are shown in Figures [5.2](#f52) and [5.3](#f53). [f52]: figures/histo_sum.png ""f52""; <a na",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:1216,simpl,simple,1216,documentation/primer/histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md,1,['simpl'],['simple']
Usability," in RooFit-based frameworks. If you make sure that your framework compiles both; with and without `ROOFIT_MEMORY_SAFE_INTERFACES`, you can get rid of all memory; leaks related to RooFit user error! After making the necessary changes, you can; remove the marco definition again to keep backwards compatibility. Note that the memory-safe interfaces might become the default at some point, so; doing this **backwards-compatible migration early** is strongly encouraged and; appreciated. ### Removal of some memory-unsafe interfaces. * The final `bool takeOwnership` parameter of the **RooAddition** and; **RooStats::HistFactory::PiecewiseInterpolation** constructors was removed.; This is to avoid situations where ownership is not clear to the compiler.; Now, ownership of the input RooAbsArgs is never passed in the constructor. If; you want the pass input ownership to the created object, please use; `addOwnedComponents`. If you want to be extra safe, make sure the inputs are; in an owning collection and then `std::move` the collection, so that the; ownership is always clear. Example:; ```c++; RooArgList sumSet;; sumSet.add(*(new RooRealVar(""var1"", ""var1"", 1.0)));; sumSet.add(*(new RooRealVar(""var2"", ""var2"", 3.0)));; RooAddition addition{""addition"", ""addition"", sumSet, /*takeOwnership=*/true};; ```; should become:; ```c++; RooArgList sumSet;; sumSet.addOwned(std::make_unique<RooRealVar>(""var1"", ""var1"", 1.0));; sumSet.addOwned(std::make_unique<RooRealVar>(""var2"", ""var2"", 3.0));; RooAddition addition{""addition"", ""addition"", sumSet};; addition.addOwnedComponents(std::move(sumSet));; ```. ### Deprecation of legacy iterators. The following methods related to the RooFit legacy iterators are deprecated and will be removed in ROOT 6.34.; They should be replaced with the suitable STL-compatible interfaces, or you can just use range-based loops:. - `RooAbsArg::clientIterator()`: use `clients()` and `begin()`, `end()` or range-based loops instead; - `RooAbsArg::valueClientIterator()`: use `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:11195,clear,clear,11195,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['clear'],['clear']
Usability," in the; definition of ``Foo``::. def Bar : SomeClass {; int X = 5;; }. def Foo {; SomeClass Baz = Bar;; }. * A field local to a record definition, such as the use of ``Bar`` in::. def Foo {; int Bar = 5;; int Baz = Bar;; }. Fields inherited from the record's parent classes can be accessed the same way. * A template argument of a ``multiclass``, such as the use of ``Bar`` in::. multiclass Foo <int Bar> {; def : SomeClass<Bar>;; }. * A variable defined with the ``defvar`` or ``defset`` statements. * The iteration variable of a ``foreach``, such as the use of ``i`` in::. foreach i = 0...5 in; def Foo#i;. .. productionlist::; SimpleValue8: `ClassID` ""<"" `ArgValueList` "">"". This form creates a new anonymous record definition (as would be created by an; unnamed ``def`` inheriting from the given class with the given template; arguments; see `def`_) and the value is that record. A field of the record can be; obtained using a suffix; see `Suffixed Values`_. Invoking a class in this manner can provide a simple subroutine facility.; See `Using Classes as Subroutines`_ for more information. .. productionlist::; SimpleValue9: `BangOperator` [""<"" `Type` "">""] ""("" `ValueListNE` "")""; :| `CondOperator` ""("" `CondClause` ("","" `CondClause`)* "")""; CondClause: `Value` "":"" `Value`. The bang operators provide functions that are not available with the other; simple values. Except in the case of ``!cond``, a bang operator takes a list; of arguments enclosed in parentheses and performs some function on those; arguments, producing a value for that bang operator. The ``!cond`` operator; takes a list of pairs of arguments separated by colons. See `Appendix A:; Bang Operators`_ for a description of each bang operator. Suffixed values; ---------------. The :token:`SimpleValue` values described above can be specified with; certain suffixes. The purpose of a suffix is to obtain a subvalue of the; primary value. Here are the possible suffixes for some primary *value*. *value*\ ``{17}``; The final val",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:17942,simpl,simple,17942,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability," in z. #### The SPEC Option. The ""SPEC"" option offers a large set of options/attributes to; visualize 2D histograms thanks to ""operators"" following the ""SPEC""; keyword. For example, to draw the 2-D histogram `h2` using all default; attributes except the viewing angles, one can do:. ``` {.cpp}; h2->Draw(""SPEC a(30,30,0)"");; ```. The operators' names are case insensitive (i.e. one can use ""a"" or; ""A"") and their parameters are separated by coma "","". Operators can be; put in any order in the option and must be separated by a space "" "".; No space characters should be put in an operator. All the available; operators are described below. The way how a 2D histogram will be painted is controlled by two; parameters: the ""Display modes groups"" and the ""Display Modes"".; ""Display modes groups"" can take the following values:. - 0 = Simple - simple display modes using one color only; - 1 = Light - the shading is carried out according to the position; of the fictive light source; - 2 = Height - the shading is carried out according to the channel; contents; - 3 = LightHeight - combination of two previous shading algorithms; (one can control the weight between both algorithms). ""Display modes"" can take the following values:. - 1 = Points; - 2 = Grid; - 3 = Contours; - 4 = Bars; - 5 = LinesX; - 6 = LinesY; - 7 = BarsX; - 8 = BarsY; - 9 = Needles; - 10 = Surface; - 11 = Triangles. These parameters can be set by using the ""`dm`"" operator in the; option. ``` {.cpp}; h2->Draw(""SPEC dm(1,2)"");; ```. The above example draws the histogram using the ""Light Display mode; group"" and the ""Grid Display mode"". The following tables summarize all; the possible combinations of both groups:. +-----------+------+----+--------+----+------+------+; | |Points|Grid|Contours|Bars|LinesX|LinesY|; +-----------+------+----+--------+----+------+------+; |Simple | x | x | x |x |x |x |; +-----------+------+----+--------+----+------+------+; |Light | x | x | - |- |x |x |; +-----------+------+----+--------+----+----",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:34629,simpl,simple,34629,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['simpl'],['simple']
Usability," inputs and outputs which have been; bound for this compilation sequence. Here clang is being used to; compile t0.c on the i386 architecture and darwin specific versions of; the tools are being used to assemble and link the result, but generic; gcc versions of the tools are being used on PowerPC. #. **Translate: Tool Specific Argument Translation**. Once a Tool has been selected to perform a particular Action, the; Tool must construct concrete Commands which will be executed during; compilation. The main work is in translating from the gcc style; command line options to whatever options the subprocess expects. Some tools, such as the assembler, only interact with a handful of; arguments and just determine the path of the executable to call and; pass on their input and output arguments. Others, like the compiler; or the linker, may translate a large number of arguments in addition. The ArgList class provides a number of simple helper methods to; assist with translating arguments; for example, to pass on only the; last of arguments corresponding to some option, or all arguments for; an option. The result of this stage is a list of Commands (executable paths and; argument strings) to execute. #. **Execute**. Finally, the compilation pipeline is executed. This is mostly; straightforward, although there is some interaction with options like; ``-pipe``, ``-pass-exit-codes`` and ``-time``. Additional Notes; ----------------. The Compilation Object; ^^^^^^^^^^^^^^^^^^^^^^. The driver constructs a Compilation object for each set of command line; arguments. The Driver itself is intended to be invariant during; construction of a Compilation; an IDE should be able to construct a; single long lived driver instance to use for an entire build, for; example. The Compilation object holds information that is particular to each; compilation sequence. For example, the list of used temporary files; (which must be removed once compilation is finished) and result files; (which should be re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:11565,simpl,simple,11565,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['simpl'],['simple']
Usability," insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :ref:`std::set <dss_set>`, the iterators of ``SmallPtrSet``; are invalidated whenever an insertion occurs. Also, the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSet.h; ^^^^^^^^^^^^^^^^^^^^. ``StringSet`` is a thin wrapper around :ref:`StringMap\<char\> <dss_stringmap>`,; and it allows efficient storage and retrieval of unique strings. Functionally analogous to ``SmallSet<StringRef>``, ``StringSet`` also supports; iteration. (The iterator dereferences to a ``StringMapEntry<char>``, so you; need to call ``i->getKey()`` to access the item of the StringSet.) On the; other hand, ``StringSet`` doesn't support range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^^^^^^^^^^^. DenseSet is a simple quadratically probed hash table. It excels at supporting; small values: it uses a single allocation to hold all of the pairs that are; currently inserted in the set. DenseSet is a great way to unique small values; that are not simple pointers (use :ref:`SmallPtrSet <dss_smallptrset>` for; pointers). Note that DenseSet has the same requirements for the value type that; :ref:`DenseMap <dss_densemap>` has. .. _dss_sparseset:. llvm/ADT/SparseSet.h; ^^^^^^^^^^^^^^^^^^^^. SparseSet holds a small number of objects identified by unsigned keys of; moderate size. It uses a lot of memory, but provides operations that are almost; as fast as a vector. Typical keys are physical registers, virtual registers, or; numbered basic blocks. SparseSet is useful for algorithms that need very fast clear/find/insert/erase; and fast iteration over small sets. It is not intended for building composite; data structures. .. _dss_sparsemultiset:. llvm/ADT/SparseMultiSet.h; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SparseMultiSet ad",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:80038,simpl,simple,80038,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability," is defined by; way of a *personality function* (e.g. ``__gxx_personality_v0`` in C++),; which receives the context of the exception, an *exception structure*; containing the exception object type and value, and a reference to the exception; table for the current function. The personality function for the current; compile unit is specified in a *common exception frame*. The organization of an exception table is language dependent. For C++, an; exception table is organized as a series of code ranges defining what to do if; an exception occurs in that range. Typically, the information associated with a; range defines which types of exception objects (using C++ *type info*) that are; handled in that range, and an associated action that should take place. Actions; typically pass control to a *landing pad*. A landing pad corresponds roughly to the code found in the ``catch`` portion of; a ``try``/``catch`` sequence. When execution resumes at a landing pad, it; receives an *exception structure* and a *selector value* corresponding to the; *type* of exception thrown. The selector is then used to determine which *catch*; should actually process the exception. LLVM Code Generation; ====================. From a C++ developer's perspective, exceptions are defined in terms of the; ``throw`` and ``try``/``catch`` statements. In this section we will describe the; implementation of LLVM exception handling in terms of C++ examples. Throw; -----. Languages that support exception handling typically provide a ``throw``; operation to initiate the exception process. Internally, a ``throw`` operation; breaks down into two steps. #. A request is made to allocate exception space for an exception structure.; This structure needs to survive beyond the current activation. This structure; will contain the type and value of the object being thrown. #. A call is made to the runtime to raise the exception, passing the exception; structure as an argument. In C++, the allocation of the exception st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:5525,resume,resumes,5525,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['resume'],['resumes']
Usability," is not provided in the API, due to the fact accessing the elements in order; would allocate all the iterated pages, defeating memory savings and the purpose; of the ``PagedVector``. Finally a ``materialized_begin()`` and ``materialized_end`` iterators are; provided to access the elements associated to the accessed pages, which could; speed up operations that need to iterate over initialized elements in a; non-ordered manner. .. _dss_vector:. <vector>; ^^^^^^^^. ``std::vector<T>`` is well loved and respected. However, ``SmallVector<T, 0>``; is often a better option due to the advantages listed above. std::vector is; still useful when you need to store more than ``UINT32_MAX`` elements or when; interfacing with code that expects vectors :). One worthwhile note about std::vector: avoid code like this:. .. code-block:: c++. for ( ... ) {; std::vector<foo> V;; // make use of V.; }. Instead, write this as:. .. code-block:: c++. std::vector<foo> V;; for ( ... ) {; // make use of V.; V.clear();; }. Doing so will save (at least) one heap allocation and free per iteration of the; loop. .. _dss_deque:. <deque>; ^^^^^^^. ``std::deque`` is, in some senses, a generalized version of ``std::vector``.; Like ``std::vector``, it provides constant time random access and other similar; properties, but it also provides efficient access to the front of the list. It; does not guarantee continuity of elements within memory. In exchange for this extra flexibility, ``std::deque`` has significantly higher; constant factor costs than ``std::vector``. If possible, use ``std::vector`` or; something cheaper. .. _dss_list:. <list>; ^^^^^^. ``std::list`` is an extremely inefficient class that is rarely useful. It; performs a heap allocation for every element inserted into it, thus having an; extremely high constant factor, particularly for small data types.; ``std::list`` also only supports bidirectional iteration, not random access; iteration. In exchange for this high cost, std::list supports eff",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:65214,clear,clear,65214,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['clear'],['clear']
Usability," is one exception table per function, except leaf functions and functions; that have calls only to non-throwing functions. They do not need an exception; table. .. _wineh:. Exception Handling using the Windows Runtime; =================================================. Background on Windows exceptions; ---------------------------------. Interacting with exceptions on Windows is significantly more complicated than; on Itanium C++ ABI platforms. The fundamental difference between the two models; is that Itanium EH is designed around the idea of ""successive unwinding,"" while; Windows EH is not. Under Itanium, throwing an exception typically involves allocating thread local; memory to hold the exception, and calling into the EH runtime. The runtime; identifies frames with appropriate exception handling actions, and successively; resets the register context of the current thread to the most recently active; frame with actions to run. In LLVM, execution resumes at a ``landingpad``; instruction, which produces register values provided by the runtime. If a; function is only cleaning up allocated resources, the function is responsible; for calling ``_Unwind_Resume`` to transition to the next most recently active; frame after it is finished cleaning up. Eventually, the frame responsible for; handling the exception calls ``__cxa_end_catch`` to destroy the exception,; release its memory, and resume normal control flow. The Windows EH model does not use these successive register context resets.; Instead, the active exception is typically described by a frame on the stack.; In the case of C++ exceptions, the exception object is allocated in stack memory; and its address is passed to ``__CxxThrowException``. General purpose structured; exceptions (SEH) are more analogous to Linux signals, and they are dispatched by; userspace DLLs provided with Windows. Each frame on the stack has an assigned EH; personality routine, which decides what actions to take to handle the exception.; Ther",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:20708,resume,resumes,20708,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['resume'],['resumes']
Usability," is the example how to create the first button:. ``` {.cpp}; TGPictureButton *fPicture = new TGPictureButton(parent,; gClient->GetPicture(""h1_s.xpm""), 11);; ```. The picture of file h1\_s.xpm is used in the button. All `.xpm` files; are located in the directory `$ROOTSYS/icons`. You can assign a command; directly as a parameter of the picture button constructor. The picture; of **`TGPictureButton`** can be changed by:. ``` {.cpp}; fPicture->SetPicture(""h2_s.xpm"");; ```. The advantage of command buttons is that they are always visible,; providing a reminder of their existence. They can be inscribed with a; meaningful description of what they do by; `TGToolTip(""Some describing text"").` Their activation is much easier and; faster than using a two-step menu bar/pull-down sequence. The only; disadvantage of the text and picture buttons is that they consume; considerable screen space if they are many. Having no more than six; command buttons per window or dialog box helps to appropriately balance; the application's effectiveness, its real efficiency, and the; operational simplicity. The classes **`TGRadioButton`** and **`TGCheckButton`** present the; option buttons in ROOT. Like the text buttons, they have text or hot; string as a label. Radio buttons are grouped in logical sets of two or; more and appear with a text label to the right. The choices are mutually; exclusive and only one setting is permitted at one time. They represent; visually all alternatives and it is easy to access and compare choices.; They facilitate the situations where all alternatives cannot be easily; remembered or where displaying the alternatives together helps to; understand and select the proper choice. It is very useful to provide a; default setting whenever it is possible. When it is not possible to; establish a default setting because of the nature of the information, it; is better to leave all radio buttons blank. ![](pictures/03000210.png). A columnar orientation is the preferred manner of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:58967,simpl,simplicity,58967,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simplicity']
Usability," is; a first-class value to insert. The following operands are constant; indices indicating the position at which to insert the value in a; similar manner as indices in a '``extractvalue``' instruction. The value; to insert must have the same type as the value identified by the; indices. Semantics:; """""""""""""""""""". The result is an aggregate of the same type as ``val``. Its value is; that of ``val`` except that the value at the position specified by the; indices is that of ``elt``. Example:; """""""""""""""". .. code-block:: llvm. %agg1 = insertvalue {i32, float} undef, i32 1, 0 ; yields {i32 1, float undef}; %agg2 = insertvalue {i32, float} %agg1, float %val, 1 ; yields {i32 1, float %val}; %agg3 = insertvalue {i32, {float}} undef, float %val, 1, 0 ; yields {i32 undef, {float %val}}. .. _memoryops:. Memory Access and Addressing Operations; ---------------------------------------. A key design point of an SSA-based representation is how it represents; memory. In LLVM, no memory locations are in SSA form, which makes things; very simple. This section describes how to read, write, and allocate; memory in LLVM. .. _i_alloca:. '``alloca``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = alloca [inalloca] <type> [, <ty> <NumElements>] [, align <alignment>] [, addrspace(<num>)] ; yields type addrspace(num)*:result. Overview:; """""""""""""""""". The '``alloca``' instruction allocates memory on the stack frame of the; currently executing function, to be automatically released when this; function returns to its caller. If the address space is not explicitly; specified, the object is allocated in the alloca address space from the; :ref:`datalayout string<langref_datalayout>`. Arguments:; """""""""""""""""""". The '``alloca``' instruction allocates ``sizeof(<type>)*NumElements``; bytes of memory on the runtime stack, returning a pointer of the; appropriate type to the program. If ""NumElements"" is specified, it is; the number of elements allocated, otherwise ""NumElements"" is defaulted",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:408753,simpl,simple,408753,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability," ivars and methods, designed to; allow a class's ``@interface`` to be split across multiple files; however,; there is still a primary implementation file which must see the; ``@interface``\ s of all class extensions. :arc-term:`Categories` allow; methods (but not ivars) to be declared *post hoc* on an arbitrary class; the; methods in the category's ``@implementation`` will be dynamically added to that; class's method tables which the category is loaded at runtime, replacing those; methods in case of a collision. In the standard environment, objects are allocated on the heap, and their; lifetime is manually managed using a reference count. This is done using two; instance methods which all classes are expected to implement: ``retain``; increases the object's reference count by 1, whereas ``release`` decreases it; by 1 and calls the instance method ``dealloc`` if the count reaches 0. To; simplify certain operations, there is also an :arc-term:`autorelease pool`, a; thread-local list of objects to call ``release`` on later; an object can be; added to this pool by calling ``autorelease`` on it. Block pointers may be converted to type ``id``; block objects are laid out in a; way that makes them compatible with Objective-C objects. There is a builtin; class that all block objects are considered to be objects of; this class; implements ``retain`` by adjusting the reference count, not by calling; ``Block_copy``. .. _arc.meta.evolution:. Evolution; ---------. ARC is under continual evolution, and this document must be updated as the; language progresses. If a change increases the expressiveness of the language, for example by; lifting a restriction or by adding new syntax, the change will be annotated; with a revision marker, like so:. ARC applies to Objective-C pointer types, block pointer types, and; :when-revised:`[beginning Apple 8.0, LLVM 3.8]` :revision:`BPTRs declared; within` ``extern ""BCPL""`` blocks. For now, it is sensible to version this document by the releases of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:6974,simpl,simplify,6974,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['simpl'],['simplify']
Usability," largest) while both i65 and i256 will use the; alignment of i64 (largest specified). The function of the data layout string may not be what you expect.; Notably, this is not a specification from the frontend of what alignment; the code generator should use. Instead, if specified, the target data layout is required to match what; the ultimate *code generator* expects. This string is used by the; mid-level optimizers to improve code, and this only works if it matches; what the ultimate code generator uses. There is no way to generate IR; that does not embed this target-specific detail into the IR. If you; don't specify the string, the default specifications will be used to; generate a Data Layout and the optimization phases will operate; accordingly and introduce target specificity into the IR with respect to; these default specifications. .. _langref_triple:. Target Triple; -------------. A module may specify a target triple string that describes the target; host. The syntax for the target triple is simply:. .. code-block:: llvm. target triple = ""x86_64-apple-macosx10.7.0"". The *target triple* string consists of a series of identifiers delimited; by the minus sign character ('-'). The canonical forms are:. ::. ARCHITECTURE-VENDOR-OPERATING_SYSTEM; ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT. This information is passed along to the backend so that it generates; code for the proper architecture. It's possible to override this on the; command line with the ``-mtriple`` command line option. .. _objectlifetime:. Object Lifetime; ----------------------. A memory object, or simply object, is a region of a memory space that is; reserved by a memory allocation such as :ref:`alloca <i_alloca>`, heap; allocation calls, and global variable definitions.; Once it is allocated, the bytes stored in the region can only be read or written; through a pointer that is :ref:`based on <pointeraliasing>` the allocation; value.; If a pointer that is not based on the object tries to read",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:139575,simpl,simply,139575,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability," limiting the transformation of; releases, this rule requires ARC to eliminate retains and release; only in pairs. ARC's power to reorder the destruction of objects is critical to its; ability to do any optimization, for essentially the same reason that; it must retain the power to decrease the lifetime of an object.; Unfortunately, while it's generally poor style for the destruction; of objects to have arbitrary side-effects, it's certainly possible.; Hence the caveat. .. _arc.optimization.precise:. Precise lifetime semantics; --------------------------. In general, ARC maintains an invariant that a retainable object pointer held in; a ``__strong`` object will be retained for the full formal lifetime of the; object. Objects subject to this invariant have :arc-term:`precise lifetime; semantics`. By default, local variables of automatic storage duration do not have precise; lifetime semantics. Such objects are simply strong references which hold; values of retainable object pointer type, and these values are still fully; subject to the optimizations on values under local control. .. admonition:: Rationale. Applying these precise-lifetime semantics strictly would be prohibitive.; Many useful optimizations that might theoretically decrease the lifetime of; an object would be rendered impossible. Essentially, it promises too much. A local variable of retainable object owner type and automatic storage duration; may be annotated with the ``objc_precise_lifetime`` attribute to indicate that; it should be considered to be an object with precise lifetime semantics. .. admonition:: Rationale. Nonetheless, it is sometimes useful to be able to force an object to be; released at a precise time, even if that object does not appear to be used.; This is likely to be uncommon enough that the syntactic weight of explicitly; requesting these semantics will not be burdensome, and may even make the code; clearer. .. _arc.misc:. Miscellaneous; =============. .. _arc.misc.special_methods:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:83910,simpl,simply,83910,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['simpl'],['simply']
Usability," line interface which is not fully; compatible with all of libFuzzer's features. See the notes above about; ``llvm-mc-assemble-fuzzer`` for details. .. |generic fuzzer| replace:: :ref:`generic fuzzer <fuzzing-llvm-generic>`; .. |protobuf fuzzer|; replace:: :ref:`libprotobuf-mutator based fuzzer <fuzzing-llvm-protobuf>`; .. |LLVM IR fuzzer|; replace:: :ref:`structured LLVM IR fuzzer <fuzzing-llvm-ir>`. lldb-target-fuzzer; ---------------------. A |generic fuzzer| that interprets inputs as object files and uses them to; create a target in lldb. Mutators and Input Generators; =============================. The inputs for a fuzz target are generated via random mutations of a; :ref:`corpus <libfuzzer-corpus>`. There are a few options for the kinds of; mutations that a fuzzer in LLVM might want. .. _fuzzing-llvm-generic:. Generic Random Fuzzing; ----------------------. The most basic form of input mutation is to use the built in mutators of; LibFuzzer. These simply treat the input corpus as a bag of bits and make random; mutations. This type of fuzzer is good for stressing the surface layers of a; program, and is good at testing things like lexers, parsers, or binary; protocols. Some of the in-tree fuzzers that use this type of mutator are `clang-fuzzer`_,; `clang-format-fuzzer`_, `llvm-as-fuzzer`_, `llvm-dwarfdump-fuzzer`_,; `llvm-mc-assemble-fuzzer`_, and `llvm-mc-disassemble-fuzzer`_. .. _fuzzing-llvm-protobuf:. Structured Fuzzing using ``libprotobuf-mutator``; ------------------------------------------------. We can use libprotobuf-mutator_ in order to perform structured fuzzing and; stress deeper layers of programs. This works by defining a protobuf class that; translates arbitrary data into structurally interesting input. Specifically, we; use this to work with a subset of the C++ language and perform mutations that; produce valid C++ programs in order to exercise parts of clang that are more; interesting than parser error handling. To build this kind of fuzzer you n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst:5892,simpl,simply,5892,interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,1,['simpl'],['simply']
Usability," llvm. #endif // LLVM_TRANSFORMS_HELLONEW_HELLOWORLD_H. This creates the class for the pass with a declaration of the ``run()``; method which actually runs the pass. Inheriting from ``PassInfoMixin<PassT>``; sets up some more boilerplate so that we don't have to write it ourselves. Our class is in the ``llvm`` namespace so that we don't pollute the global; namespace. Next we'll create ``llvm/lib/Transforms/Utils/HelloWorld.cpp``, starting; with. .. code-block:: c++. #include ""llvm/Transforms/Utils/HelloWorld.h"". ... to include the header file we just created. .. code-block:: c++. using namespace llvm;. ... is required because the functions from the include files live in the llvm; namespace. This should only be done in non-header files. Next we have the pass's ``run()`` definition:. .. code-block:: c++. PreservedAnalyses HelloWorldPass::run(Function &F,; FunctionAnalysisManager &AM) {; errs() << F.getName() << ""\n"";; return PreservedAnalyses::all();; }. ... which simply prints out the name of the function to stderr. The pass; manager will ensure that the pass will be run on every function in a module.; The ``PreservedAnalyses`` return value says that all analyses (e.g. dominator; tree) are still valid after this pass since we didn't modify any functions. That's it for the pass itself. Now in order to ""register"" the pass, we need; to add it to a couple places. Add the following to; ``llvm/lib/Passes/PassRegistry.def`` in the ``FUNCTION_PASS`` section. .. code-block:: c++. FUNCTION_PASS(""helloworld"", HelloWorldPass()). ... which adds the pass under the name ""helloworld"". ``llvm/lib/Passes/PassRegistry.def`` is #include'd into; ``llvm/lib/Passes/PassBuilder.cpp`` multiple times for various reasons. Since; it constructs our pass, we need to also add the proper #include in; ``llvm/lib/Passes/PassBuilder.cpp``:. .. code-block:: c++. #include ""llvm/Transforms/Utils/HelloWorld.h"". This should be all the code necessary for our pass, now it's time to compile; and run it. Runni",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst:4274,simpl,simply,4274,interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,1,['simpl'],['simply']
Usability," matcher does:. .. code-block:: c++. binaryOperator(hasOperatorName(""+""), hasLHS(integerLiteral(equals(0)))). Shockingly, it will match against addition expressions whose left hand; side is exactly the literal 0. It will not match against other forms of; 0, such as ``'\0'`` or ``NULL``, but it will match against macros that; expand to 0. The matcher will also not match against calls to the; overloaded operator ``'+'``, as there is a separate ``operatorCallExpr``; matcher to handle overloaded operators. There are AST matchers to match all the different nodes of the AST,; narrowing matchers to only match AST nodes fulfilling specific criteria,; and traversal matchers to get from one kind of AST node to another. For; a complete list of AST matchers, take a look at the `AST Matcher; References <LibASTMatchersReference.html>`_. All matcher that are nouns describe entities in the AST and can be; bound, so that they can be referred to whenever a match is found. To do; so, simply call the method ``bind`` on these matchers, e.g.:. .. code-block:: c++. variable(hasType(isInteger())).bind(""intvar""). Step 2: Using AST matchers; ==========================. Okay, on to using matchers for real. Let's start by defining a matcher; which will capture all ``for`` statements that define a new variable; initialized to zero. Let's start with matching all ``for`` loops:. .. code-block:: c++. forStmt(). Next, we want to specify that a single variable is declared in the first; portion of the loop, so we can extend the matcher to. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl())))). Finally, we can add the condition that the variable is initialized to; zero. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))). It is fairly easy to read and understand the matcher definition (""match; loops whose init portion declares a single variable which is initialized; to the integer literal 0""), but deciding that",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:7259,simpl,simply,7259,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['simpl'],['simply']
Usability," means apply to a memory object. - `cycle` = 9999 also means apply to a memory object. - `namecycle` = """" means the same as `namecycle` =""T\*"". - `namecycle` = `T*` delete subdirectories. For example to delete a directory from a file, you must specify the; directory cycle:. ``` {.cpp}; root[] f->Delete(""Wed011003;1""); ```. Some other examples of `namecycle` format are:. - `foo`:delete the object named `foo` from memory. - `foo;1`: delete the cycle 1 of the object named `foo` from the file. - `foo;*`: delete all cycles of `foo` from the file and also from; memory. - `*;2`: delete all objects with cycle number 2 from the file. - `*;*: delete` all objects from memory and from the file. - `T*;*`: delete all objects from memory and from the file including; all subdirectories. ## Streamers. To follow the discussion on `Streamers`, you need to know what a; *simple* data type is. A variable is of a simple data type if it cannot; be decomposed into other types. Examples of simple data types are longs,; shorts, floats, and chars. In contrast, a variable is of a *composite*; data type if it can be decomposed. For example, classes, structures, and; arrays are composite types. Simple types are also called primitive; types, basic types, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves up the; inheritance tree until it reaches an ancestor without a parent. To; s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:42047,simpl,simple,42047,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability," message then; exiting with an error code, the :ref:`ExitOnError <err_exitonerr>` utility; may be a better choice than handleErrors, as it simplifies control flow when; calling fallible functions. In situations where it is known that a particular call to a fallible function; will always succeed (for example, a call to a function that can only fail on a; subset of inputs with an input that is known to be safe) the; :ref:`cantFail <err_cantfail>` functions can be used to remove the error type,; simplifying control flow. StringError; """""""""""""""""""""". Many kinds of errors have no recovery strategy, the only action that can be; taken is to report them to the user so that the user can attempt to fix the; environment. In this case representing the error as a string makes perfect; sense. LLVM provides the ``StringError`` class for this purpose. It takes two; arguments: A string error message, and an equivalent ``std::error_code`` for; interoperability. It also provides a ``createStringError`` function to simplify; common usage of this class:. .. code-block:: c++. // These two lines of code are equivalent:; make_error<StringError>(""Bad executable"", errc::executable_format_error);; createStringError(errc::executable_format_error, ""Bad executable"");. If you're certain that the error you're building will never need to be converted; to a ``std::error_code`` you can use the ``inconvertibleErrorCode()`` function:. .. code-block:: c++. createStringError(inconvertibleErrorCode(), ""Bad executable"");. This should be done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it will trigger immediate program; termination. Unless you are certain that your errors will not need; interoperability you should look for an existing ``std::error_code`` that you; can convert to, and even (as painful as it is) consider introducing a new one as; a stopgap measure. ``createStringError`` can take ``printf`` style format specifiers to provide a; formatte",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:27086,simpl,simplify,27086,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simplify']
Usability," method `SetLabelFormat()` is used to customize the label format.; The format string must contain one of these modifiers:. - - `%txt` : to print the text label associated with the slice. - - `%val` : to print the numeric value of the slice. - - `%frac` : to print the relative fraction of this slice. - - `%perc` : to print the % of this slice. ``` {.cpp}; mypie->SetLabelFormat(""%txt (%frac)"");; ```. See the macro `$ROOTSYS/tutorials/graphics/piechart.C` . ![The picture generated by tutorial macro piechart.C](pictures/03000042.png). ## The User Interface for Histograms. The classes **`T`** **`H1`** **`Editor`** and **`T`** **`H2`**; **`Editor`** provides the user interface for setting histogram's; attributes and rebinning interactively. ### TH1Editor. ![](pictures/03000043.png). #### The Style Tab. ##### Title. sets the title of the histogram. ##### Plot. draw a 2D or 3D plot; according to the dimension, different drawing; possibilities can be set. ##### Error; add different error bars to the histogram (no errors, simple, etc.). ##### Add; further things which can be added to the histogram (None,; simple/smooth line, fill area, etc.). #### 2-D Plot. ##### Simple Drawing; draw a simple histogram without errors (= ""HIST"" draw; option). In combination with some other draw options an outer line is; drawn on top of the histogram. ##### Show markers; draw a marker on to of each bin (=""P"" draw option). ##### Draw bar chart; draw a bar chart (=""B"" draw option). ##### Bar option; draw a bar chart (=""BAR"" draw option); if selected, it will; show an additional interface elements for bars: width, offset,; percentage and the possibility to draw horizontal bars. #### 3-D Plot. ##### Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf,; Surf1...5). ##### Coords; set the coordinate system (Cartesian, Spheric, etc.). ##### Error; same as for 2D plot. ##### Bar; set the bar attributes: width and offset. ##### Horizontal Bar; draw a horizontal bar chart. #### The Binn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:71780,simpl,simple,71780,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['simpl'],['simple']
Usability," module A {; header ""A.h""; export *; }. explicit module B {; header ""B.h""; export *; }; }. Export declaration; ~~~~~~~~~~~~~~~~~~; An *export-declaration* specifies which imported modules will automatically be re-exported as part of a given module's API. .. parsed-literal::. *export-declaration*:; ``export`` *wildcard-module-id*. *wildcard-module-id*:; *identifier*; '*'; *identifier* '.' *wildcard-module-id*. The *export-declaration* names a module or a set of modules that will be re-exported to any translation unit that imports the enclosing module. Each imported module that matches the *wildcard-module-id* up to, but not including, the first ``*`` will be re-exported. **Example:** In the following example, importing ``MyLib.Derived`` also provides the API for ``MyLib.Base``:. .. parsed-literal::. module MyLib {; module Base {; header ""Base.h""; }. module Derived {; header ""Derived.h""; export Base; }; }. Note that, if ``Derived.h`` includes ``Base.h``, one can simply use a wildcard export to re-export everything ``Derived.h`` includes:. .. parsed-literal::. module MyLib {; module Base {; header ""Base.h""; }. module Derived {; header ""Derived.h""; export *; }; }. .. note::. The wildcard export syntax ``export *`` re-exports all of the; modules that were imported in the actual header file. Because; ``#include`` directives are automatically mapped to module imports,; ``export *`` provides the same transitive-inclusion behavior; provided by the C preprocessor, e.g., importing a given module; implicitly imports all of the modules on which it depends.; Therefore, liberal use of ``export *`` provides excellent backward; compatibility for programs that rely on transitive inclusion (i.e.,; all of them). Re-export Declaration; ~~~~~~~~~~~~~~~~~~~~~; An *export-as-declaration* specifies that the current module will have; its interface re-exported by the named module. .. parsed-literal::. *export-as-declaration*:; ``export_as`` *identifier*. The *export-as-declaration* names the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:43075,simpl,simply,43075,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['simpl'],['simply']
Usability," more complex builds. Many of the examples below are written assuming specific CMake Generators.; Unless otherwise explicitly called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cache; scripts to provide more complex options. By default, only a few CMake options will be passed between stages.; The list, called _BOOTSTRAP_DEFAULT_PASSTHROUGH, is defined in clang/CMakeLists.txt.; To force the passing of the variables between stages, use the -DCLANG_BOOTSTRAP_PASSTHROUGH; CMake option, each variable separated by a "";"". As example:. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DCLANG_BOOTSTRAP_PASSTHROUGH=""CMAKE_I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:1434,simpl,simple,1434,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['simpl'],['simple']
Usability," must; increment the PC and resume the wave.; reserved ``s_trap 0x04`` Reserved.; reserved ``s_trap 0x05`` Reserved.; reserved ``s_trap 0x06`` Reserved.; reserved ``s_trap 0x07`` Reserved.; reserved ``s_trap 0x08`` Reserved.; reserved ``s_trap 0xfe`` Reserved.; reserved ``s_trap 0xff`` Reserved.; =================== =============== =============== =======================================. .. .. table:: AMDGPU Trap Handler for AMDHSA OS Code Object V3; :name: amdgpu-trap-handler-for-amdhsa-os-v3-table. =================== =============== =============== =======================================; Usage Code Sequence Trap Handler Description; Inputs; =================== =============== =============== =======================================; reserved ``s_trap 0x00`` Reserved by hardware.; debugger breakpoint ``s_trap 0x01`` *none* Reserved for debugger to use for; breakpoints. Causes wave to be halted; with the PC at the trap instruction.; The debugger is responsible to resume; the wave, including the instruction; that the breakpoint overwrote.; ``llvm.trap`` ``s_trap 0x02`` ``SGPR0-1``: Causes wave to be halted with the PC at; ``queue_ptr`` the trap instruction. The associated; queue is signalled to put it into the; error state. When the queue is put in; the error state, the waves executing; dispatches on the queue will be; terminated.; ``llvm.debugtrap`` ``s_trap 0x03`` *none* - If debugger not enabled then behaves; as a no-operation. The trap handler; is entered and immediately returns to; continue execution of the wavefront.; - If the debugger is enabled, causes; the debug trap to be reported by the; debugger and the wavefront is put in; the halt state with the PC at the; instruction. The debugger must; increment the PC and resume the wave.; reserved ``s_trap 0x04`` Reserved.; reserved ``s_trap 0x05`` Reserved.; reserved ``s_trap 0x06`` Reserved.; reserved ``s_trap 0x07`` Reserved.; reserved ``s_trap 0x08`` Reserved.; reserved ``s_trap 0xfe`` Reserved.; reserved ``s_t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:382837,resume,resume,382837,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['resume'],['resume']
Usability," next are some; rules to remember:. - `name` = \* means all, but don't remove the subdirectories. - `cycle` =\* means all cycles (memory and file). - `cycle` ="""" means apply to a memory object. - `cycle` = 9999 also means apply to a memory object. - `namecycle` = """" means the same as `namecycle` =""T\*"". - `namecycle` = `T*` delete subdirectories. For example to delete a directory from a file, you must specify the; directory cycle:. ``` {.cpp}; root[] f->Delete(""Wed011003;1""); ```. Some other examples of `namecycle` format are:. - `foo`:delete the object named `foo` from memory. - `foo;1`: delete the cycle 1 of the object named `foo` from the file. - `foo;*`: delete all cycles of `foo` from the file and also from; memory. - `*;2`: delete all objects with cycle number 2 from the file. - `*;*: delete` all objects from memory and from the file. - `T*;*`: delete all objects from memory and from the file including; all subdirectories. ## Streamers. To follow the discussion on `Streamers`, you need to know what a; *simple* data type is. A variable is of a simple data type if it cannot; be decomposed into other types. Examples of simple data types are longs,; shorts, floats, and chars. In contrast, a variable is of a *composite*; data type if it can be decomposed. For example, classes, structures, and; arrays are composite types. Simple types are also called primitive; types, basic types, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:41931,simpl,simple,41931,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability," notion of a ""legal"" vs.; ""illegal"" DAG. A legal DAG for a target is one that only uses supported; operations and supported types. On a 32-bit PowerPC, for example, a DAG with a; value of type i1, i8, i16, or i64 would be illegal, as would a DAG that uses a; SREM or UREM operation. The `legalize types`_ and `legalize operations`_ phases; are responsible for turning an illegal DAG into a legal DAG. .. _SelectionDAG-Process:. SelectionDAG Instruction Selection Process; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SelectionDAG-based instruction selection consists of the following steps:. #. `Build initial DAG`_ --- This stage performs a simple translation from the; input LLVM code to an illegal SelectionDAG. #. `Optimize SelectionDAG`_ --- This stage performs simple optimizations on the; SelectionDAG to simplify it, and recognize meta instructions (like rotates; and ``div``/``rem`` pairs) for targets that support these meta operations.; This makes the resultant code more efficient and the `select instructions; from DAG`_ phase (below) simpler. #. `Legalize SelectionDAG Types`_ --- This stage transforms SelectionDAG nodes; to eliminate any types that are unsupported on the target. #. `Optimize SelectionDAG`_ --- The SelectionDAG optimizer is run to clean up; redundancies exposed by type legalization. #. `Legalize SelectionDAG Ops`_ --- This stage transforms SelectionDAG nodes to; eliminate any operations that are unsupported on the target. #. `Optimize SelectionDAG`_ --- The SelectionDAG optimizer is run to eliminate; inefficiencies introduced by operation legalization. #. `Select instructions from DAG`_ --- Finally, the target instruction selector; matches the DAG operations to target instructions. This process translates; the target-independent input DAG into another DAG of target instructions. #. `SelectionDAG Scheduling and Formation`_ --- The last phase assigns a linear; order to the instructions in the target-instruction DAG and emits them into; the MachineFunction",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:37391,simpl,simpler,37391,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simpler']
Usability," of commented code for all four of our expression nodes.; First we'll do numeric literals:. .. code-block:: c++. Value *NumberExprAST::codegen() {; return ConstantFP::get(*TheContext, APFloat(Val));; }. In the LLVM IR, numeric constants are represented with the; ``ConstantFP`` class, which holds the numeric value in an ``APFloat``; internally (``APFloat`` has the capability of holding floating point; constants of Arbitrary Precision). This code basically just creates; and returns a ``ConstantFP``. Note that in the LLVM IR that constants; are all uniqued together and shared. For this reason, the API uses the; ""foo::get(...)"" idiom instead of ""new foo(..)"" or ""foo::Create(..)"". .. code-block:: c++. Value *VariableExprAST::codegen() {; // Look this variable up in the function.; Value *V = NamedValues[Name];; if (!V); LogErrorV(""Unknown variable name"");; return V;; }. References to variables are also quite simple using LLVM. In the simple; version of Kaleidoscope, we assume that the variable has already been; emitted somewhere and its value is available. In practice, the only; values that can be in the ``NamedValues`` map are function arguments.; This code simply checks to see that the specified name is in the map (if; not, an unknown variable is being referenced) and returns the value for; it. In future chapters, we'll add support for `loop induction; variables <LangImpl05.html#for-loop-expression>`_ in the symbol table, and for `local; variables <LangImpl07.html#user-defined-local-variables>`_. .. code-block:: c++. Value *BinaryExprAST::codegen() {; Value *L = LHS->codegen();; Value *R = RHS->codegen();; if (!L || !R); return nullptr;. switch (Op) {; case '+':; return Builder->CreateFAdd(L, R, ""addtmp"");; case '-':; return Builder->CreateFSub(L, R, ""subtmp"");; case '*':; return Builder->CreateFMul(L, R, ""multmp"");; case '<':; L = Builder->CreateFCmpULT(L, R, ""cmptmp"");; // Convert bool 0/1 to double 0.0 or 1.0; return Builder->CreateUIToFP(L, Type::getDoubleTy(TheCont",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:5797,simpl,simple,5797,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simple']
Usability," of elements derived; fromCa53+Sr78](pictures/030001B4.png). ### Tracking Media. The class **`TGeoMedium`** describes tracking media properties. This has; a pointer to a material and the additional data members representing the; properties related to tracking. ``` {.cpp}; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);; ```. - `name:` name assigned to the medium; - `mat:` pointer to a material; - `params:` array of additional parameters. Another constructor allows effectively defining tracking parameters in; GEANT3 style:. ``` {.cpp}; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; ```. This constructor is reserved for creating tracking media from the VMC; interface [...]:. - `numed:` user-defined medium index; - `imat:` unique ID of the material; - `others:` see G3 documentation. Looking at our simple world example, one can see that for creating; volumes one needs to create tracking media before. The way to proceed; for those not interested in performing tracking with external MC's is to; define and use only one `dummy tracking medium` as in the example (or a; `NULL` pointer). ### User Interface for Handling Materials and Media. The **`TGeoManager`** class contains the API for accessing and handling; defined materials:. ``` {.cpp}; TGeoManager::GetMaterial(name);; ```. ## Shapes. Shapes are geometrical objects that provide the basic modeling; functionality. They provide the definition of the `local` coordinate; system of the volume. Any volume must have a shape. Any shape recognized; by the modeller has to derive from the base **`TGeoShape`** class,; providing methods for:. - Finding out if a point defined in their local frame is contained or; not by the shape;; - Computing the distance to enter/exit the shape from a local point,; given a known direction;; - Computing the maximum distance in any direction from a local ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:22647,simpl,simple,22647,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability," of the block containing `coro.end` instruction is discarded.; In landing pads it is replaced with an appropriate instruction to unwind to; caller. The handling of coro.end differs depending on whether the target is; using landingpad or WinEH exception model. For landingpad based exception model, it is expected that frontend uses the; `coro.end`_ intrinsic as follows:. .. code-block:: llvm. ehcleanup:; %InResumePart = call i1 @llvm.coro.end(ptr null, i1 true, token none); br i1 %InResumePart, label %eh.resume, label %cleanup.cont. cleanup.cont:; ; rest of the cleanup. eh.resume:; %exn = load ptr, ptr %exn.slot, align 8; %sel = load i32, ptr %ehselector.slot, align 4; %lpad.val = insertvalue { ptr, i32 } undef, ptr %exn, 0; %lpad.val29 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1; resume { ptr, i32 } %lpad.val29. The `CoroSpit` pass replaces `coro.end` with ``True`` in the resume functions,; thus leading to immediate unwind to the caller, whereas in start function it; is replaced with ``False``, thus allowing to proceed to the rest of the cleanup; code that is only needed during initial invocation of the coroutine. For Windows Exception handling model, a frontend should attach a funclet bundle; referring to an enclosing cleanuppad as follows:. .. code-block:: llvm. ehcleanup:; %tok = cleanuppad within none []; %unused = call i1 @llvm.coro.end(ptr null, i1 true, token none) [ ""funclet""(token %tok) ]; cleanupret from %tok unwind label %RestOfTheCleanup. The `CoroSplit` pass, if the funclet bundle is present, will insert; ``cleanupret from %tok unwind to caller`` before; the `coro.end`_ intrinsic and will remove the rest of the block. In the unwind path (when the argument is `true`), `coro.end` will mark the coroutine; as done, making it undefined behavior to resume the coroutine again and causing ; `llvm.coro.done` to return `true`. This is not necessary in the normal path because; the coroutine will already be marked as done by the final suspend. The following ta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:45269,resume,resume,45269,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability," of the coroutine. The `coro.suspend`_; intrinsic in combination with the following switch indicates what happens to; control flow when a coroutine is suspended (default case), resumed (case 0) or; destroyed (case 1). Coroutine Transformation; ------------------------. One of the steps of coroutine lowering is building the coroutine frame. The; def-use chains are analyzed to determine which objects need be kept alive across; suspend points. In the coroutine shown in the previous section, use of virtual register; `%inc` is separated from the definition by a suspend point, therefore, it; cannot reside on the stack frame since the latter goes away once the coroutine; is suspended and control is returned back to the caller. An i32 slot is; allocated in the coroutine frame and `%inc` is spilled and reloaded from that; slot as needed. We also store addresses of the resume and destroy functions so that the; `coro.resume` and `coro.destroy` intrinsics can resume and destroy the coroutine; when its identity cannot be determined statically at compile time. For our; example, the coroutine frame will be:. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32 }. After resume and destroy parts are outlined, function `f` will contain only the; code responsible for creation and initialization of the coroutine frame and; execution of the coroutine until a suspend point is reached:. .. code-block:: llvm. define ptr @f(i32 %n) {; entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %alloc = call noalias ptr @malloc(i32 24); %frame = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc); %1 = getelementptr %f.frame, ptr %frame, i32 0, i32 0; store ptr @f.resume, ptr %1; %2 = getelementptr %f.frame, ptr %frame, i32 0, i32 1; store ptr @f.destroy, ptr %2. %inc = add nsw i32 %n, 1; %inc.spill.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i32 0, i32 2; store i32 %inc, ptr %inc.spill.addr; call void @print(i32 %n). ret ptr %frame; }. Outlined resume part ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:14467,resume,resume,14467,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability," of the existence of ROOT's interactive features and use; them if you find them convenient. Some trial-and-error is certainly necessary; to find your way through the huge number of menus and parameter; settings. ## ROOT Beginners' FAQ ##. At this point of the guide, some basic questions could have already come; to your mind. We will try to clarify some of them with further; explanations in the following. ### ROOT type declarations for basic data types ###. In the official ROOT documentation, you find special data types; replacing the normal ones, e.g. `Double_t`, `Float_t` or `Int_t`; replacing the standard `double`, `float` or `int` types. Using the ROOT; types makes it easier to port code between platforms (64/32 bit) or; operating systems (windows/Linux), as these types are mapped to suitable; ones in the ROOT header files. If you want adaptive code of this type,; use the ROOT type declarations. However, usually you do not need such; adaptive code, and you can safely use the standard C type declarations; for your private code, as we did and will do throughout this guide. If; you intend to become a ROOT developer, however, you better stick to the; official coding rules!. ### Configure ROOT at start-up ###. The behaviour of a ROOT session can be tailored with the options in the; `.rootrc` file. Examples of the tunable parameters are the ones related; to the operating and window system, to the fonts to be used, to the; location of start-up files. At start-up, ROOT looks for a `.rootrc` file; in the following order:. - `./.rootrc //local directory`. - `$HOME/.rootrc //user directory`. - `$ROOTSYS/etc/system.rootrc //global ROOT directory`. If more than one `.rootrc` files are found in the search paths above,; the options are merged, with precedence local, user, global. The parsing; and interpretation of this file is handled by the ROOT class `TEnv`.; Have a look to its documentation if you need such rather advanced; features. The file `.rootrc` defines the location of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:17766,guid,guide,17766,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['guid'],['guide']
Usability," of two theorems:. 1- A linear combination of `sigmoids` can approximate any continuous; function. 2- Trained with `output=1` for the signal and 0 for the background,; the approximated function of inputs `X` is the probability of signal,; knowing `X`. ### Learning Methods. The aim of all learning methods is to minimize the total error on a; set of weighted examples. The error is defined as the sum in quadrate,; divided by two, of the error on each individual output neuron. In all; methods implemented in this library, one needs to compute the first; derivative of that error with respect to the weights. Exploiting the; well-known properties of the derivative, one can express this; derivative as the product of the local partial derivative by the; weighted sum of the outputs derivatives (for a neuron) or as the; product of the input value with the local partial derivative of the; output neuron (for a synapse). This computation is called; ""back-propagation of the errors"". Six learning methods are; implemented. #### Stochastic Minimization. This is the most trivial learning method. The Robbins-Monro stochastic; approximation is applied to multilayer perceptrons. The weights are; updated after each example according to the formula:. $$; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); $$. with:. $$; \Delta w_{ij}(t) = - \eta \left(; \frac{\partial e_p}{\partial w_{ij}} + \delta \right) +; \epsilon \Delta w_{ij}(t-1); $$. The parameters for this method are `Eta`, `EtaDecay`, `Delta` and; `Epsilon`. #### Steepest Descent With Fixed Step Size (Batch Learning). It is the same as the stochastic minimization, but the weights are; updated after considering all the examples, with the total derivative; `dEdw`. The parameters for this method are `Eta`, `EtaDecay`, `Delta`; and `Epsilon`. #### Steepest Descent Algorithm. Weights are set to the minimum along the line defined by the gradient.; The only parameter for this method is `Tau`. Lower `Tau` = higher; precision = slower search. A val",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:72114,learn,learning,72114,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['learn'],['learning']
Usability," on the worker machines for; processing. Any input list setting in the selector itself is not; streamed but temporarly moved to then standard input list, so that user; can use the selector input list as container of processing information; if they find convenient to do so. Process(...) methods with the file; name argument replaced by 'TSelector *' have  introduced where; relevant (TProof, TProofPlayer and their derivatives, TDSet).  ; Add the possibility to force submerging at node level, i.e. one; submerger per physical machine. In this way the network traffic can be; minimized, for example when merging large output files. The new feature; is enabled by setting the Int_t parameter 'PROOF_MergersByHost' (or the; directive 'Proof.MergersByHost') to a non-null value.; Simplify enabling of basic feedback. In TProof::Process, add; support for switches ""fb=name1,name2,name3,... "" or; ""feedback=name1,name2,name3,... "" in the option field. This enables; feedback for the specified objects, creating a TDrawFeedback object; attached to the session. Feedback for the specified objects is disabled; at the end of the query and the created TDrawFeedback is destroyed. The; special name 'stats' enables the three feedback histograms required by; a dedicated new class TStatsFeedback, and uses a TStatsFeedback instead; of TDrawFeedback to display the feedback. . Improvements; ; Add to TProofMgr two static functions to upload files. These; functions are both called UploadFiles and differ in the first argument,; which is used to pass the files to be uploaded. These can be given as a; list (of TFileInfo or TObjString), a directory or specified in a text; file.; Add support for paralell dataset verification. This is; implemented via a dedicated TSelector (TSelVerifyDataSet) which is run; over the list of files in the dataset via TPacketizerFile. The file; order is preserved using the recently introduced index in TFileInfo.; In TProofOutputFile, add switch to control the way histograms; are",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html:2037,feedback,feedback,2037,proof/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html,1,['feedback'],['feedback']
Usability," one (GEANT3 like). Divides `MOTHER` into `NDIV` divisions called `NAME` along axis `IAXIS`; starting at coordinate value `START` and having size `STEP`. The created; volumes will have tracking media `ID=NUMED` (if `NUMED=0` -\> same media; as `MOTHER`). The behavior of the division operation can be triggered using `OPTION`; (case insensitive):. - `N`divide all range in `NDIV` cells (same effect as `STEP<=0`); (GSDVN in G3); - `NX`divide range starting with `START` in `NDIV` cells (GSDVN2 in; G3); - `S`divide all range with given `STEP`; `NDIV` is computed and; divisions will be centered in full range (same effect as `NDIV<=0`); (GSDVS, GSDVT in G3); - `SX`same as `DVS`, but from `START` position (GSDVS2, GSDVT2 in G3). #### Volume Assemblies. In general, geometry contains structures of positioned volumes that have; to be grouped and handled together, for different possible reasons. One; of these is that the structure has to be replicated in several parts of; the geometry, or it may simply happen that they really represent a; single object, too complex to be described by a primitive shape. Usually handling structures like these can be easily done by positioning; all components in the same container volume, then positioning the; container itself. However, there are many practical cases when defining; such a container is not straightforward or even possible without; generating overlaps with the rest of the geometry. There are few ways; out of this:. - Defining the container for the structure as ""overlapping"" (see also; "" Overlapping Volumes **""**); - Representing the container as a composite shape - the Boolean union; of all components (see also "" Composite Shapes ""); - Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the; navigation performance with a factor increasing more than linear of the; number of components in the structure. The best solution is the third; one because it uses all vo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:88199,simpl,simply,88199,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simply']
Usability," one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems, you need to use structures with same length members.; If your structure does not qualify, you need to create one branch for; each element of the structure. The leaf name is NOT used to pick the variable out of the structure, but; is only used as the name for the leaf. This means that the list of; variables needs to be in a structure in the order described in the third; parameter. This third parameter is a string describing the leaf list. Each leaf has",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:19404,simpl,simple,19404,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability," optional filename to search through; (which defaults to standard input if a filename is not specified). Using the; CommandLine library, this would be specified as:. .. code-block:: c++. cl::opt<string> Regex (cl::Positional, cl::desc(""<regular expression>""), cl::Required);; cl::opt<string> Filename(cl::Positional, cl::desc(""<input file>""), cl::init(""-""));. Given these two option declarations, the ``-help`` output for our grep; replacement would look like this:. ::. USAGE: spiffygrep [options] <regular expression> <input file>. OPTIONS:; -help - display available options (-help-hidden for more). ... and the resultant program could be used just like the standard ``grep``; tool. Positional arguments are sorted by their order of construction. This means that; command line options will be ordered according to how they are listed in a .cpp; file, but will not have an ordering defined if the positional arguments are; defined in multiple .cpp files. The fix for this problem is simply to define; all of your positional arguments in one .cpp file. Specifying positional options with hyphens; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Sometimes you may want to specify a value to your positional argument that; starts with a hyphen (for example, searching for '``-foo``' in a file). At; first, you will have trouble doing this, because it will try to find an argument; named '``-foo``', and will fail (and single quotes will not save you). Note; that the system ``grep`` has the same problem:. ::. $ spiffygrep '-foo' test.txt; Unknown command line argument '-foo'. Try: spiffygrep -help'. $ grep '-foo' test.txt; grep: illegal option -- f; grep: illegal option -- o; grep: illegal option -- o; Usage: grep -hblcnsviw pattern file . . . The solution for this problem is the same for both your tool and the system; version: use the '``--``' marker. When the user specifies '``--``' on the; command line, it is telling the program that all options after the '``--``'; should be treated as positi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:27508,simpl,simply,27508,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simply']
Usability," order:. - `./.rootrc //local directory`. - `$HOME/.rootrc //user directory`. - `$ROOTSYS/etc/system.rootrc //global ROOT directory`. If more than one `.rootrc` files are found in the search paths above,; the options are merged, with precedence local, user, global. The parsing; and interpretation of this file is handled by the ROOT class `TEnv`.; Have a look to its documentation if you need such rather advanced; features. The file `.rootrc` defines the location of two rather; important files inspected at start-up: `rootalias.C` and `rootlogon.C`.; They can contain code that needs to be loaded and executed at ROOT; startup. `rootalias.C` is only loaded and best used to define some often; used functions. `rootlogon.C` contains code that will be executed at; startup: this file is extremely useful for example to pre-load a custom; style for the plots created with ROOT. This is done most easily by; creating a new `TStyle` object with your preferred settings, as; described in the class reference guide, and then use the command; `gROOT->SetStyle(""MyStyleName"");` to make this new style definition the; default one. As an example, have a look in the file `rootlogon.C` coming; with this tutorial. Another relevant file is `rootlogoff.C` that it; called when the session is finished. ### ROOT command history ###. Every command typed at the ROOT prompt is stored in a file `.root_hist`; in your home directory. ROOT uses this file to allow for navigation in; the command history with the up-arrow and down-arrow keys. It is also; convenient to extract successful ROOT commands with the help of a text; editor for use in your own macros. ### ROOT Global Pointers ###. All global pointers in ROOT begin with a small ""g"". Some of them were; already implicitly introduced (for example in the section; [Configure ROOT at start-up](#configure-root-at-start-up)).; The most important among them are presented in the following:. - **[gROOT](https://root.cern.ch/doc/master/classTROOT.html)**: the `gRO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:19220,guid,guide,19220,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['guid'],['guide']
Usability," order; that they are processed (which is in order from simplest/weakest to most; complex/powerful). Generally you want to use the first alias mechanism that; meets the needs of your instruction, because it will allow a more concise; description. Mnemonic Aliases; ^^^^^^^^^^^^^^^^. The first phase of alias processing is simple instruction mnemonic remapping for; classes of instructions which are allowed with two different mnemonics. This; phase is a simple and unconditionally remapping from one input mnemonic to one; output mnemonic. It isn't possible for this form of alias to look at the; operands at all, so the remapping must apply for all forms of a given mnemonic.; Mnemonic aliases are defined simply, for example X86 has:. ::. def : MnemonicAlias<""cbw"", ""cbtw"">;; def : MnemonicAlias<""smovq"", ""movsq"">;; def : MnemonicAlias<""fldcww"", ""fldcw"">;; def : MnemonicAlias<""fucompi"", ""fucomip"">;; def : MnemonicAlias<""ud2a"", ""ud2"">;. ... and many others. With a MnemonicAlias definition, the mnemonic is remapped; simply and directly. Though MnemonicAlias's can't look at any aspect of the; instruction (such as the operands) they can depend on global modes (the same; ones supported by the matcher), through a Requires clause:. ::. def : MnemonicAlias<""pushf"", ""pushfq"">, Requires<[In64BitMode]>;; def : MnemonicAlias<""pushf"", ""pushfl"">, Requires<[In32BitMode]>;. In this example, the mnemonic gets mapped into a different one depending on; the current instruction set. Instruction Aliases; ^^^^^^^^^^^^^^^^^^^. The most general phase of alias processing occurs while matching is happening:; it provides new forms for the matcher to match along with a specific instruction; to generate. An instruction alias has two parts: the string to match and the; instruction to generate. For example:. ::. def : InstAlias<""movsx $src, $dst"", (MOVSX16rr8W GR16:$dst, GR8 :$src)>;; def : InstAlias<""movsx $src, $dst"", (MOVSX16rm8W GR16:$dst, i8mem:$src)>;; def : InstAlias<""movsx $src, $dst"", (MOVSX32rr8 G",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:82887,simpl,simply,82887,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simply']
Usability," output of the macro; is shown in Figure [6.1](#f61):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro8.C; ```. Some step by step explanation is at this point necessary:. - Lines *1-3*: A simple function to ease the make-up of lines.; Remember that the class `TF1` inherits from `TAttLine`. - Lines *5-7* : Definition of a customised function, namely a Gaussian; (the ""signal"") plus a parabolic function, the ""background"". - Lines *10-12*: Some make-up for the Canvas. In particular we want; that the parameters of the fit appear very clearly and nicely on the; plot. - Lines *20-25*: Define and initialise an instance of `TF1`. - Lines *27-31*: Define and fill a histogram. - Lines *33-38*: For convenience, the same function as for the; generation of the pseudo-data is used in the fit; hence, we need to; reset the function parameters. This part of the code is very; important for each fit procedure, as it sets the initial values of; the fit. - Line *41*: A very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; better displaying your results. \label{f61}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:3411,simpl,simple,3411,documentation/primer/functions_and_parameter_estimation.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md,1,['simpl'],['simple']
Usability," overloaded four times. * ``PrintError(const Twine &Msg)``:; Prints the message with no source file location. * ``PrintError(ArrayRef<SMLoc> ErrorLoc, const Twine &Msg)``:; Prints the message followed by the specified source line,; along with a pointer to the item in error. The array of; source file locations is typically taken from a ``Record`` instance. * ``PrintError(const Record *Rec, const Twine &Msg)``:; Prints the message followed by the source line associated with the; specified record (see `Record`_). * ``PrintError(const RecordVal *RecVal, const Twine &Msg)``:; Prints the message followed by the source line associated with the; specified record field (see `RecordVal`_). Using these functions, the goal is to produce the most specific error report; possible. Debugging Tools; ===============. TableGen provides some tools to aid in debugging backends. The ``PrintRecords`` Backend; ----------------------------. The TableGen command option ``--print-records`` invokes a simple backend; that prints all the classes and records defined in the source files. This is; the default backend option. The format of the output is guaranteed to be; constant over time, so that the output can be compared in tests. The output; looks like this:. .. code-block:: text. ------------- Classes -----------------; ...; class XEntry<string XEntry:str = ?, int XEntry:val1 = ?> { // XBase; string Str = XEntry:str;; bits<8> Val1 = { !cast<bits<8>>(XEntry:val1){7}, ... };; bit Val3 = 1;; }; ...; ------------- Defs -----------------; def ATable {	// GenericTable; string FilterClass = ""AEntry"";; string CppTypeName = ""AEntry"";; list<string> Fields = [""Str"", ""Val1"", ""Val2""];; list<string> PrimaryKey = [""Val1"", ""Val2""];; string PrimaryKeyName = ""lookupATableByValues"";; bit PrimaryKeyEarlyOut = 0;; }; ...; def anonymous_0 {	// AEntry; string Str = ""Bob"";; bits<8> Val1 = { 0, 0, 0, 0, 0, 1, 0, 1 };; bits<10> Val2 = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1 };; }. Classes are shown with their template arguments,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:25280,simpl,simple,25280,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,1,['simpl'],['simple']
Usability," painful. Debuggers generally read debug information from object files on; disk, but for JITed code there is no such file to look for. In order to hand over the necessary debug info, `GDB established an; interface <https://sourceware.org/gdb/onlinedocs/gdb/JIT-Interface.html>`_; for registering JITed code with debuggers. LLDB implements it in the; JITLoaderGDB plugin. On the JIT side, LLVM MCJIT does implement the interface; for ELF object files. At a high level, whenever MCJIT generates new machine code, it does so in an; in-memory object file that contains the debug information in DWARF format.; MCJIT then adds this in-memory object file to a global list of dynamically; generated object files and calls a special function; ``__jit_debug_register_code`` that the debugger knows about. When the debugger; attaches to a process, it puts a breakpoint in this function and associates a; special handler with it. Once MCJIT calls the registration function, the; debugger catches the breakpoint signal, loads the new object file from the; inferior's memory and resumes execution. This way it can obtain debug; information for pure in-memory object files. GDB Version; ===========. In order to debug code JIT-ed by LLVM, you need GDB 7.0 or newer, which is; available on most modern distributions of Linux. The version of GDB that; Apple ships with Xcode has been frozen at 6.3 for a while. LLDB Version; ============. Due to a regression in release 6.0, LLDB didn't support JITed code debugging for; a while. The bug was fixed in mainline recently, so that debugging JITed ELF; objects should be possible again from the upcoming release 12.0 on. On macOS the; feature must be enabled explicitly using the ``plugin.jit-loader.gdb.enable``; setting. Debugging MCJIT-ed code; =======================. The emerging MCJIT component of LLVM allows full debugging of JIT-ed code with; GDB. This is due to MCJIT's ability to use the MC emitter to provide full; DWARF debugging information to GDB. Note th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DebuggingJITedCode.rst:1241,resume,resumes,1241,interpreter/llvm-project/llvm/docs/DebuggingJITedCode.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DebuggingJITedCode.rst,1,['resume'],['resumes']
Usability," parent class ``S`` with one set of template arguments, while record or class; ``B`` can request ``S`` with a different set of arguments. Without template; arguments, many more classes would be required, one for each combination of; the template arguments. Both classes and concrete records can include fields that are uninitialized.; The uninitialized ""value"" is represented by a question mark (``?``). Classes; often have uninitialized fields that are expected to be filled in when those; classes are inherited by concrete records. Even so, some fields of concrete; records may remain uninitialized. TableGen provides *multiclasses* to collect a group of record definitions in; one place. A multiclass is a sort of macro that can be ""invoked"" to define; multiple concrete records all at once. A multiclass can inherit from other; multiclasses, which means that the multiclass inherits all the definitions; from its parent multiclasses. `Appendix C: Sample Record`_ illustrates a complex record in the Intel X86; target and the simple way in which it is defined. Source Files; ============. TableGen source files are plain ASCII text files. The files can contain; statements, comments, and blank lines (see `Lexical Analysis`_). The standard file; extension for TableGen files is ``.td``. TableGen files can grow quite large, so there is an include mechanism that; allows one file to include the content of another file (see `Include; Files`_). This allows large files to be broken up into smaller ones, and; also provides a simple library mechanism where multiple source files can; include the same library file. TableGen supports a simple preprocessor that can be used to conditionalize; portions of ``.td`` files. See `Preprocessing Facilities`_ for more; information. Lexical Analysis; ================. The lexical and syntax notation used here is intended to imitate; `Python's`_ notation. In particular, for lexical definitions, the productions; operate at the character level and there is no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:5658,simpl,simple,5658,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability," pieces; is not defined by neighbors, but by ""containment"". In other words,; volumes are put one inside another making an in-depth hierarchy. From; outside, the whole thing looks like a big pack that you can open finding; out other smaller packs nicely arranged waiting to be opened at their; turn. The biggest one containing all others defines the ""world"" of the; model. We will often call this ""master reference system (MARS)"". Going; on and opening our packs, we will obviously find out some empty ones,; otherwise, something is very wrong... We will call these leaves (by; analogy with a tree structure). On the other hand, any volume is a small world by itself - what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. \anchor GP00a; ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does ""make map"" in root folder. ~~~{.cpp}; root[] gSystem->Load(""libGeom"");; ~~~. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; `gGeoManager`:. ~~~{.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ~~~. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ~~~{.cpp}; root[] TGeoMaterial *m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:4768,simpl,simplest,4768,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simplest']
Usability," platform.; * - `Implementation of GlobalModuleIndex in ROOT and Cling <https://indico.cern.ch/event/840376/contributions/3525646/attachments/1895398/3127159/GSoC_Presentation__GMI.pdf>`_; - *Arpitha Raghunandan* 2012 Google Summer of Code GSoC; - GlobalModuleIndex can be used for improving ROOT’s and Cling’s performance ; * - `Example project using cling as library <https://github.com/root-project/cling/tree/master/tools/demo>`_; - *Axel Naumann* 2016 GitHub; - This video showcases how to use Cling as a library, and shows how to set up a simple CMake configuration that uses Cling.; * - `Cling C++ interpreter testdrive <https://www.youtube.com/watch?v=1IGTHusaJ18>`_; - *Mika* 2015 Youtube; - In this tutorial, a developer tries Cling for the first time by uploading a few simple C++ user-cases onto Cling, involving also the loading of external files; * - `Building an Order Book in C++ <https://www.youtube.com/watch?v=fxN4xEZvrxI>`_; - *Dimitri Nesteruk* 2015 Youtube; - This demo shows how to build a simple order book using C++, CLion, Google Test and, of course, Cling. ; * - `Cling C++ interpreter testdrive <https://www.youtube.com/watch?v=1IGTHusaJ18>`_; - Dimitri Nesteruk 2015 Youtube; - This tutorial describes Cling’s general features. You will learn how to start Cling on Ubuntu, how to write a simple expression (N=5, N++) and how to define a Class for calculating body mass index. ; * - `Cling Interactive OpenGL Demo <https://www.youtube.com/watch?v=eoIuqLNvzFs>`_; - *Alexander Penev* 2012 Youtube; - This demo shows how to use Cling for interactive OpenGL. A rotating triangle with changing color, a static figure, and a figure with light effects are created.; ; . .. list-table:: Language Interoperability with Cling:; :widths: 25 25 50; :header-rows: 1. * - Link; - Info ; - Description; * - `Compiler Research - Calling C++ libraries from a D-written DSL: A cling/cppyy-based approach <https://www.youtube.com/watch?v=7teqrCNzrD8>`_; - *Alexandru Militaru* 2021 Compiler",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst:5049,simpl,simple,5049,interpreter/cling/docs/chapters/references.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst,1,['simpl'],['simple']
Usability," please start with the :doc:`GettingStarted` or; :doc:`CMake` pages. This page is intended for users doing more complex builds. Many of the examples below are written assuming specific CMake Generators.; Unless otherwise explicitly called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cache; scripts to provide more complex options. By default, only a few CMake options will be passed between stages.; The list, called _BOOTSTRAP_DEFAULT_PASSTHROUGH, is defined in clang/CMakeLists.txt.; To force the passing of the variables between stages, use the -DCLANG_BOOTSTRAP_PASSTHROUGH; CMake option, each variable separated by a "";"". As example:. .. code-block:: console. $ cmake -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:1371,simpl,simple,1371,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['simpl'],['simple']
Usability," ptr <resume function>,; ptr <context projection function>,; ... <function to call>; ... <arguments to function>). Overview:; """""""""""""""""". The '``llvm.coro.suspend.async``' intrinsic marks the point where; execution of an async coroutine is suspended and control is passed to a callee. Arguments:; """""""""""""""""""". The first argument should be the result of the `llvm.coro.async.resume` intrinsic.; Lowering will replace this intrinsic with the resume function for this suspend; point. The second argument is the `context projection function`. It should describe; how-to restore the `async context` in the continuation function from the first; argument of the continuation function. Its type is `ptr (ptr)`. The third argument is the function that models transfer to the callee at the; suspend point. It should take 3 arguments. Lowering will `musttail` call this; function. The fourth to six argument are the arguments for the third argument. Semantics:; """""""""""""""""""". The result of the intrinsic are mapped to the arguments of the resume function.; Execution is suspended at this intrinsic and resumed when the resume function is; called. .. _coro.prepare.async:. 'llvm.coro.prepare.async' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.prepare.async(ptr <coroutine function>). Overview:; """""""""""""""""". The '``llvm.coro.prepare.async``' intrinsic is used to block inlining of the; async coroutine until after coroutine splitting. Arguments:; """""""""""""""""""". The first argument should be an async coroutine of type `void (ptr, ptr, ptr)`.; Lowering will replace this intrinsic with its coroutine function argument. .. _coro.suspend.retcon:. 'llvm.coro.suspend.retcon' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i1 @llvm.coro.suspend.retcon(...). Overview:; """""""""""""""""". The '``llvm.coro.suspend.retcon``' intrinsic marks the point where; execution of a returned-continuation coroutine is suspended and control; is returned back to the caller. `llvm.coro.susp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:54371,resume,resume,54371,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability," quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes `TMinuitMinimizer` implemented using `TMinuit`, `TFumiliMinimizer`; implemented using `TFumili` for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62139,guid,guide,62139,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['guid'],['guide']
Usability," receives a request to compile an unknown; function. In our simple JIT this situation is unlikely to come up, so we'll; cheat and just pass '0' here. In a production quality JIT you could give the; address of a function that throws an exception in order to unwind the JIT'd; code's stack. Now we can construct our CompileOnDemandLayer. Following the pattern from; previous layers we start by passing a reference to the next layer down in our; stack -- the OptimizeLayer. Next we need to supply a 'partitioning function':; when a not-yet-compiled function is called, the CompileOnDemandLayer will call; this function to ask us what we would like to compile. At a minimum we need to; compile the function being called (given by the argument to the partitioning; function), but we could also request that the CompileOnDemandLayer compile other; functions that are unconditionally called (or highly likely to be called) from; the function being called. For KaleidoscopeJIT we'll keep it simple and just; request compilation of the function that was called. Next we pass a reference to; our CompileCallbackManager. Finally, we need to supply an ""indirect stubs; manager builder"": a utility function that constructs IndirectStubManagers, which; are in turn used to build the stubs for the functions in each module. The; CompileOnDemandLayer will call the indirect stub manager builder once for each; call to addModule, and use the resulting indirect stubs manager to create; stubs for all functions in all modules in the set. If/when the module set is; removed from the JIT the indirect stubs manager will be deleted, freeing any; memory allocated to the stubs. We supply this function by using the; createLocalIndirectStubsManagerBuilder utility. .. code-block:: c++. // ...; if (auto Sym = CODLayer.findSymbol(Name, false)); // ...; return cantFail(CODLayer.addModule(std::move(Ms),; std::move(Resolver)));; // ... // ...; return CODLayer.findSymbol(MangledNameStream.str(), true);; // ... // ...; CODLay",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst:6777,simpl,simple,6777,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,1,['simpl'],['simple']
Usability," remainder of the event.; * Refusal of alcoholic beverage purchases by the reportee at LLVM events.; * Ending a talk/tutorial/etc at an LLVM event early. See immediate response; checklist for further clarification.; * Not publishing the video or slides of a talk.; * Not allowing a speaker to give (further) talks at LLVM events for a specified; amount of time or ever.; * Requiring that the reportee immediately leave an event and not return.; * Immediately ending any volunteer responsibilities and privileges the reportee; holds.; * An imposed suspension (e.g., asking someone to ""take a week off"" from mailing; lists, bug tracker, IRC, Discord, repositories, or other communication; forms). ; * A permanent or temporary ban from some or all LLVM Project spaces (online or; in person). Once a resolution is agreed upon, but before it is enacted, the committee will; contact the reporter and any other affected parties to explain the proposed; resolution. They will ask if this resolution is acceptable and must note; feedback for the record. However, the committee is not required to act on this; feedback. .. _Appeal Process:. Appeal Process; ===============. Any individual(s) determined to have violated the CoC have the right to appeal; a decision. An appeal can be made directly to the committee by sending an email; to conduct@llvm.org with subject line Code of Conduct Incident Appeal. The email should include documentation related to the incident to support the; appeal. The said documentation may include, but does not have to be limited to:. * Information from the reportee justifying reasoning for the appeal.; * Statements from other individuals involved in the incident to support the; appeal. Appeals can be requested up to 30 days after a resolution has been communicated; to the individual(s). The committee will aim to evaluate appeals within two weeks of receipt. In the event that appeal can not be evaluated within that time, the CoC committee will respond with an updated and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:8769,feedback,feedback,8769,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['feedback'],['feedback']
Usability," removal algorithms, OpenGL viewing\* or ray tracing. The method TGeoManager::GetGeomPainter() loads the painting library in; memory. This is generally not needed since it is called automatically by; TGeoVolume::Draw() as well as by few other methods setting; visualization attributes. \anchor GP04a; ### Drawing Volumes and Hierarchies of Volumes. The first thing one would like to do after building some geometry is to; visualize the volume tree. This provides the fastest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ~~~{.cpp}; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; ~~~. Doing this ensures that the original top-level volume of the geometry is; drawn, even if another volume is currently the geometry `root`. OK, I; suppose you already did that with your simple geometry and immediately; noticed a new ROOT canvas popping-up and having some more or less; strange picture inside. Here are few questions that might come:. **Q:** ""The picture is strangely rotated; where are the coordinate axes?"". **A:** If drawn in a new canvas, any view has some default; viewpoint, center of view and size. One can then perform mouse/keyboard; actions to change them:. - Mouse left-click and drag will rotate the view;. - Some keys can be pressed when the view canvas is selected: J/K; zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes; display as well as changing top or side viewpoints can be activated from; the **`TView`** context menu: right-click on the picture when no object; is selected;. **Q:** ""Every line is black! I cannot figure out what is what..."". **A:** Volumes can have different colors (those known by %ROOT of; course). Think at using them after each volume creation:; `myvolume->SetLineColor(Int_t color);` otherwise everything is by; default black. **Q:** ""The to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:98536,simpl,simple,98536,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability," repetitive editing. In our experience, automated solutions become; worthwhile somewhere between 100 and 500 files. Getting Started; ---------------. Patterns in Transformer are expressed with :doc:`clang's AST matchers <LibASTMatchers>`.; Matchers are a language of combinators for describing portions of a clang; Abstract Syntax Tree (AST). Since clang's AST includes complete type information; (within the limits of single `Translation Unit (TU)`_,; these patterns can even encode rich constraints on the type properties of AST; nodes. .. _`Translation Unit (TU)`: https://en.wikipedia.org/wiki/Translation_unit_\(programming\). We assume a familiarity with the clang AST and the corresponding AST matchers; for the purpose of this tutorial. Users who are unfamiliar with either are; encouraged to start with the recommended references in `Related Reading`_. Example: style-checking names; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Assume you have a style-guide rule which forbids functions from being named; ""MkX"" and you want to write a check that catches any violations of this rule. We; can express this a Transformer rewrite rule:. .. code-block:: c++. makeRule(functionDecl(hasName(""MkX"").bind(""fun""),; 	 noopEdit(node(""fun"")),; 	 cat(""The name ``MkX`` is not allowed for functions; please rename""));. ``makeRule`` is our go-to function for generating rewrite rules. It takes three; arguments: the pattern, the edit, and (optionally) an explanatory note. In our; example, the pattern (``functionDecl(...)``) identifies the declaration of the; function ``MkX``. Since we're just diagnosing the problem, but not suggesting a; fix, our edit is an no-op. But, it contains an *anchor* for the diagnostic; message: ``node(""fun"")`` says to associate the message with the source range of; the AST node bound to ""fun""; in this case, the ill-named function declaration.; Finally, we use ``cat`` to build a message that explains the change. Regarding the; name ``cat`` -- we'll discuss it in more detail below, but",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:3054,guid,guide,3054,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['guid'],['guide']
Usability," replace an existing value if one is already; associated with a key, otherwise it should add a new value for the key.; No syntax is provided for removing elements from mutable dictionaries. Discussion; ----------. An Objective-C subscript expression occurs when the base operand of the; C subscript operator has an Objective-C object pointer type. Since this; potentially collides with pointer arithmetic on the value, these; expressions are only supported under the modern Objective-C runtime,; which categorically forbids such arithmetic. Currently, only subscripts of integral or Objective-C object pointer; type are supported. In C++, a class type can be used if it has a single; conversion function to an integral or Objective-C pointer type, in which; case that conversion is applied and analysis continues as appropriate.; Otherwise, the expression is ill-formed. An Objective-C object subscript expression is always an l-value. If the; expression appears on the left-hand side of a simple assignment operator; (=), the element is written as described below. If the expression; appears on the left-hand side of a compound assignment operator (e.g.; +=), the program is ill-formed, because the result of reading an element; is always an Objective-C object pointer and no binary operators are; legal on such pointers. If the expression appears in any other position,; the element is read as described below. It is an error to take the; address of a subscript expression, or (in C++) to bind a reference to; it. Programs can use object subscripting with Objective-C object pointers of; type ``id``. Normal dynamic message send rules apply; the compiler must; see *some* declaration of the subscripting methods, and will pick the; declaration seen first. Caveats; =======. Objects created using the literal or boxed expression syntax are not; guaranteed to be uniqued by the runtime, but nor are they guaranteed to; be newly-allocated. As such, the result of performing direct comparisons; against",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:16294,simpl,simple,16294,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['simpl'],['simple']
Usability," report; is sent to. If it specifies a regular file, the data are saved to this file in; CSV format:. .. code-block:: console. $ clang -fproc-stat-report=abc foo.c; $ cat abc; clang-11,""/tmp/foo-123456.o"",92000,84000,87536; ld,""a.out"",900,8000,53568. The data on each row represent:. * file name of the tool executable,; * output file name in quotes,; * total execution time in microseconds,; * execution time in user mode in microseconds,; * peak memory usage in Kb. It is possible to specify this option without any value. In this case statistics; are printed on standard output in human readable format:. .. code-block:: console. $ clang -fproc-stat-report foo.c; clang-11: output=/tmp/foo-855a8e.o, total=68.000 ms, user=60.000 ms, mem=86920 Kb; ld: output=a.out, total=8.000 ms, user=4.000 ms, mem=52320 Kb. The report file specified in the option is locked for write, so this option; can be used to collect statistics in parallel builds. The report file is not; cleared, new data is appended to it, thus making possible to accumulate build; statistics. You can also use environment variables to control the process statistics reporting.; Setting ``CC_PRINT_PROC_STAT`` to ``1`` enables the feature, the report goes to; stdout in human readable format.; Setting ``CC_PRINT_PROC_STAT_FILE`` to a fully qualified file path makes it report; process statistics to the given file in the CSV format. Specifying a relative; path will likely lead to multiple files with the same name created in different; directories, since the path is relative to a changing working directory. These environment variables are handy when you need to request the statistics; report without changing your build scripts or alter the existing set of compiler; options. Note that ``-fproc-stat-report`` take precedence over ``CC_PRINT_PROC_STAT``; and ``CC_PRINT_PROC_STAT_FILE``. .. code-block:: console. $ export CC_PRINT_PROC_STAT=1; $ export CC_PRINT_PROC_STAT_FILE=~/project-build-proc-stat.csv; $ make. Other Options; -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:27674,clear,cleared,27674,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['clear'],['cleared']
Usability," resolving.; Examples of reasons for resolving are:. * If the issue has been resolved by a particular commit, close the issue with; a brief comment mentioning which commit(s) fixed it. If you are authoring; the fix yourself, your git commit message may include the phrase; ``Fixes #<issue number>`` on a line by itself. GitHub recognizes such commit; messages and will automatically close the specified issue with a reference; to your commit. * If the reported behavior is not a bug, it is appropriate to close the issue; with a comment explaining why you believe it is not a bug, and adding the; ``invalid`` tag. * If the bug duplicates another issue, close it as a duplicate by adding the; ``duplicate`` label with a comment pointing to the issue it duplicates. * If there is a sound reason for not fixing the issue (difficulty, ABI, open; research questions, etc), add the ``wontfix`` label and a comment explaining; why no changes are expected. * If there is a specific and plausible reason to think that a given bug is; otherwise inapplicable or obsolete. One example is an open bug that doesn't; contain enough information to clearly understand the problem being reported; (e.g. not reproducible). It is fine to close such a bug, adding with the; ``worksforme`` label and leaving a comment to encourage the reporter to; reopen the bug with more information if it's still reproducible for them. .. _Maintenance of metadata:. Maintenance of metadata; =======================. Project member with write access to the project can create new labels, but we; discourage adding ad hoc labels because we want to control the proliferation of; labels and avoid single-use labels. If you would like a new label added, please; open an issue asking to create an issue label and add the ``infrastructure``; label to the issue. The request should include a description of what the label; is for. Alternatively, you can ask for the label to be created on the; ``#infrastructure`` channel on the LLVM Discord.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugLifeCycle.rst:4882,clear,clearly,4882,interpreter/llvm-project/llvm/docs/BugLifeCycle.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugLifeCycle.rst,1,['clear'],['clearly']
Usability," results than a; sampling profiler. It also provides reproducible results, at least to the; extent that the code behaves consistently across runs. Clang supports two types of instrumentation: frontend-based and IR-based.; Frontend-based instrumentation can be enabled with the option ``-fprofile-instr-generate``,; and IR-based instrumentation can be enabled with the option ``-fprofile-generate``.; For best performance with PGO, IR-based instrumentation should be used. It has; the benefits of lower instrumentation overhead, smaller raw profile size, and; better runtime performance. Frontend-based instrumentation, on the other hand,; has better source correlation, so it should be used with source line-based; coverage testing. The flag ``-fcs-profile-generate`` also instruments programs using the same; instrumentation method as ``-fprofile-generate``. However, it performs a; post-inline late instrumentation and can produce context-sensitive profiles. Here are the steps for using profile guided optimization with; instrumentation:. 1. Build an instrumented version of the code by compiling and linking with the; ``-fprofile-generate`` or ``-fprofile-instr-generate`` option. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate code.cc -o code. 2. Run the instrumented executable with inputs that reflect the typical usage.; By default, the profile data will be written to a ``default.profraw`` file; in the current directory. You can override that default by using option; ``-fprofile-instr-generate=`` or by setting the ``LLVM_PROFILE_FILE``; environment variable to specify an alternate file. If non-default file name; is specified by both the environment variable and the command line option,; the environment variable takes precedence. The file name pattern specified; can include different modifiers: ``%p``, ``%h``, ``%m``, ``%t``, and ``%c``. Any instance of ``%p`` in that file name will be replaced by the process; ID, so that you can easily distinguish the profile outp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:103362,guid,guided,103362,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['guid'],['guided']
Usability," results when they are no longer useful. The; ``releaseMemory`` virtual method is the way to do this. If you are writing an analysis or any other pass that retains a significant; amount of state (for use by another pass which ""requires"" your pass and uses; the :ref:`getAnalysis <writing-an-llvm-pass-getAnalysis>` method) you should; implement ``releaseMemory`` to, well, release the memory allocated to maintain; this internal state. This method is called after the ``run*`` method for the; class, before the next call of ``run*`` in your pass. Registering dynamically loaded passes; =====================================. *Size matters* when constructing production quality tools using LLVM, both for; the purposes of distribution, and for regulating the resident code size when; running on the target system. Therefore, it becomes desirable to selectively; use some passes, while omitting others and maintain the flexibility to change; configurations later on. You want to be able to do all this, and, provide; feedback to the user. This is where pass registration comes into play. The fundamental mechanisms for pass registration are the; ``MachinePassRegistry`` class and subclasses of ``MachinePassRegistryNode``. An instance of ``MachinePassRegistry`` is used to maintain a list of; ``MachinePassRegistryNode`` objects. This instance maintains the list and; communicates additions and deletions to the command line interface. An instance of ``MachinePassRegistryNode`` subclass is used to maintain; information provided about a particular pass. This information includes the; command line name, the command help string and the address of the function used; to create an instance of the pass. A global static constructor of one of these; instances *registers* with a corresponding ``MachinePassRegistry``, the static; destructor *unregisters*. Thus a pass that is statically linked in the tool; will be registered at start up. A dynamically loaded pass will register on; load and unregister at",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:48267,feedback,feedback,48267,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['feedback'],['feedback']
Usability," ret i8 %2; }. define zeroext i8 @p2(i8 zeroext %b, i8 zeroext %a) nounwind readnone ssp {; entry:; %0 = and i8 %b, 63 ; <i8> [#uses=1]; %.masked = and i8 %a, 64 ; <i8> [#uses=1]; %1 = and i8 %a, -128 ; <i8> [#uses=1]; %2 = or i8 %1, %0 ; <i8> [#uses=1]; %3 = or i8 %2, %.masked ; <i8> [#uses=1]; ret i8 %3; }. //===---------------------------------------------------------------------===//. IPSCCP does not currently propagate argument dependent constants through; functions where it does not not all of the callers. This includes functions; with normal external linkage as well as templates, C99 inline functions etc.; Specifically, it does nothing to:. define i32 @test(i32 %x, i32 %y, i32 %z) nounwind {; entry:; %0 = add nsw i32 %y, %z ; %1 = mul i32 %0, %x ; %2 = mul i32 %y, %z ; %3 = add nsw i32 %1, %2 ; ret i32 %3; }. define i32 @test2() nounwind {; entry:; %0 = call i32 @test(i32 1, i32 2, i32 4) nounwind; ret i32 %0; }. It would be interesting extend IPSCCP to be able to handle simple cases like; this, where all of the arguments to a call are constant. Because IPSCCP runs; before inlining, trivial templates and inline functions are not yet inlined.; The results for a function + set of constant arguments should be memoized in a; map. //===---------------------------------------------------------------------===//. The libcall constant folding stuff should be moved out of SimplifyLibcalls into; libanalysis' constantfolding logic. This would allow IPSCCP to be able to; handle simple things like this:. static int foo(const char *X) { return strlen(X); }; int bar() { return foo(""abcd""); }. //===---------------------------------------------------------------------===//. function-attrs doesn't know much about memcpy/memset. This function should be; marked readnone rather than readonly, since it only twiddles local memory, but; function-attrs doesn't handle memset/memcpy/memmove aggressively:. struct X { int *p; int *q; };; int foo() {; int i = 0, j = 1;; struct X x, y;; int ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:46183,simpl,simple,46183,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simple']
Usability," return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. And that's it! You can compile our new tool by running ninja from the; ``build`` directory. .. code-block:: console. cd ~/clang-llvm/build; ninja. You should now be able to run the syntax checker, which is located in; ``~/clang-llvm/build/bin``, on any source file. Try it!. .. code-block:: console. echo ""int main() { return 0; }"" > test.cpp; bin/loop-convert test.cpp --. Note the two dashes after we specify the source file. The additional; options for the compiler are passed after the dashes rather than loading; them from a compilation database - there just aren't any options needed; right now. Intermezzo: Learn AST matcher basics; ====================================. Clang recently introduced the :doc:`ASTMatcher; library <LibASTMatchers>` to provide a simple, powerful, and; concise way to describe specific patterns in the AST. Implemented as a; DSL powered by macros and templates (see; `ASTMatchers.h <../doxygen/ASTMatchers_8h_source.html>`_ if you're; curious), matchers offer the feel of algebraic data types common to; functional programming languages. For example, suppose you wanted to examine only binary operators. There; is a matcher to do exactly that, conveniently named ``binaryOperator``.; I'll give you one guess what this matcher does:. .. code-block:: c++. binaryOperator(hasOperatorName(""+""), hasLHS(integerLiteral(equals(0)))). Shockingly, it will match against addition expressions whose left hand; side is exactly the literal 0. It will not match against other forms of; 0, such as ``'\0'`` or ``NULL``, but it will match against macros that; expand to 0. The matcher will also not match against calls to the; overloaded operator ``'+'``, as there is a separate ``operatorCallExpr``; matcher to handle overloaded operators.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:5792,simpl,simple,5792,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['simpl'],['simple']
Usability," root session (like,; for instance, the axis titles).; When a THStack is drawn with the option ""pads"", the number of lines is; now optimized to make sure there is no empty line. . TUnfold. Introduces this new class for solving inverse problems:. data histograms with Gaussian errors are decomposed into; several template distributions (""generator level"" bins). The result are new normalisation constants for the template; distributions (the unfolded ""generator level"" distribution). The solution can be tuned by properly adjusting the; regularisation parameter tau. A standard method, the L-curve scan is; implemented to help finding a good choice of this parameter. Two example tutorials are included to show the usage of this class: tutorials/math/testUnfiold1.C and tutorials/math/testUnfiold2.C. FitPanel; Add a new revised version of the Fit Panel with the following functionality:. Add support now for fitting, in addition to the TH1 and TGraph; also for TH2, TH3, TMultiGraph and TGraph2D and TTree (with un-binned; fits); Add possibility to select the data object directly from the Fit; panel. The Fit Panel can also be open directly from the TCanvas menu; (under Tools); Improve the function selection by having the possibility to; support user defined function, predefined functions and functions; used before for fitting. ; Allow the opening of the parameter dialog in case of linear; fitter. This is needed for example for fixing some of the; parameters; Improve minimization panel by adding some extra methods, like; combined for a combined migrad-simplex minimization (option; ""MINIMIZE"" in Minuit).; Improve the slider by adding a numeric entry. ; Add the Advanced Graphics dialog, that allows the user to perform; Contour and Scan operation on the last fit.; Fix various bugs in setting the fit model function and in; setting the parameters (values, limits, etc..). Here is how the fit panel is now:; ; These are the currently support methods for the new Advance Graphics dialog:;  ; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:8730,simpl,simplex,8730,hist/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html,1,['simpl'],['simplex']
Usability," running other heavy applications - the number of your own threads; running at any time may be lower than the limit due to demand on the CPU.; - The 'Real Time' is similar to 'CPU Time / number of threads' AND 'Compressed Throughput' is lower than expected; for your storage medium: this would imply that your CPU threads aren't decompressing data as fast as your storage; medium can provide it, and so decompression is the bottleneck.; The best way to decrease your runtime would be to utilise a system with a faster CPU, or make use; use of more threads when running, or use a compression algorithm with a higher decompression rate such as LZ4,; possibly at the cost of some extra file size. ### A note on caching. If your data is stored on a local disk, the system may cache some/all of the file in memory after it is; first read. If this is realistic of how your analysis will run - then there is no concern. However, if; you expect to only read files once in a while - and as such the files are unlikely to be in the cache -; consider clearing the cache before running rootreadspeed.; On Linux this can be done by running 'echo 3 > /proc/sys/vm/drop_caches' as a superuser,; or a specific file can be dropped from the cache with; `dd of=<FILENAME> oflag=nocache conv=notrunc,fdatasync count=0 > /dev/null 2>&1`. ### Known overhead of TTreeReader, RDataFrame. `rootreadspeed` is designed to read all data present in the specified branches, trees and files at the highest; possible speed. When the application bottleneck is not in the computations performed by analysis logic,; higher-level interfaces built on top of TTree such as TTreeReader and RDataFrame are known to add a significant; runtime overhead with respect to the runtimes reported by `rootreadspeed` (up to a factor 2). In realistic analysis; applications it has been observed that a large part of that overhead is compensated by the ability of TTreeReader and; RDataFrame to read branch values selectively, based on event cuts, and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/README.md:3738,clear,clearing,3738,tree/readspeed/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/README.md,1,['clear'],['clearing']
Usability," scheduling a LoopPass.; After the loop optimizations are done, these extra phi nodes; will be deleted by :ref:`-instcombine <passes-instcombine>`. Note that an exit block is outside of a loop, so how can such a phi ""close""; the value inside the loop since it uses it outside of it ? First of all,; for phi nodes, as; `mentioned in the LangRef <https://llvm.org/docs/LangRef.html#id311>`_:; ""the use of each incoming value is deemed to occur on the edge from the; corresponding predecessor block to the current block"". Now, an; edge to an exit block is considered outside of the loop because; if we take that edge, it leads us clearly out of the loop. However, an edge doesn't actually contain any IR, so in source code,; we have to choose a convention of whether the use happens in; the current block or in the respective predecessor. For LCSSA's purpose,; we consider the use happens in the latter (so as to consider the; use inside) [#point-of-use-phis]_. The major benefit of LCSSA is that it makes many other loop optimizations; simpler. First of all, a simple observation is that if one needs to see all; the outside users, they can just iterate over all the (loop closing); PHI nodes in the exit blocks (the alternative would be to; scan the def-use chain [#def-use-chain]_ of all instructions in the loop). Then, consider for example; :ref:`simple-loop-unswitch <passes-simple-loop-unswitch>` ing the loop above.; Because it is in LCSSA form, we know that any value defined inside of; the loop will be used either only inside the loop or in a loop closing; PHI node. In this case, the only loop closing PHI node is X4.; This means that we can just copy the loop and change the X4; accordingly, like so:. .. code-block:: C. c = ...;; if (c) {; for (...) {; if (true); X1 = ...; else; X2 = ...; X3 = phi(X1, X2);; }; } else {; for (...) {; if (false); X1' = ...; else; X2' = ...; X3' = phi(X1', X2');; }; }; X4 = phi(X3, X3'). Now, all uses of X4 will get the updated value (in general,; if a l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:12937,simpl,simpler,12937,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['simpl'],['simpler']
Usability," sections. Further, section clusters can also be specified using the ``list=<arg>``; option. For example, ``list=spec.txt`` where ``spec.txt`` contains:. ::. !foo; !!1 !!3 !!5; !!2 !!4 !!6. will create two unique sections for function ``foo`` with the first; containing the odd numbered basic blocks and the second containing the; even numbered basic blocks. Basic block sections allow the linker to reorder basic blocks and enables; link-time optimizations like whole program inter-procedural basic block; reordering. Profile Guided Optimization; ---------------------------. Profile information enables better optimization. For example, knowing that a; branch is taken very frequently helps the compiler make better decisions when; ordering basic blocks. Knowing that a function ``foo`` is called more; frequently than another function ``bar`` helps the inliner. Optimization; levels ``-O2`` and above are recommended for use of profile guided optimization. Clang supports profile guided optimization with two different kinds of; profiling. A sampling profiler can generate a profile with very low runtime; overhead, or you can build an instrumented version of the code that collects; more detailed profile information. Both kinds of profiles can provide execution; counts for instructions in the code and information on branches taken and; function invocation. Regardless of which kind of profiling you use, be careful to collect profiles; by running your code with inputs that are representative of the typical; behavior. Code that is not exercised in the profile will be optimized as if it; is unimportant, and the compiler may make poor optimization choices for code; that is disproportionately used while profiling. Differences Between Sampling and Instrumentation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Although both techniques are used for similar purposes, there are important; differences between the two:. 1. Profile data generated with one cannot be used by the other, and the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:90022,guid,guided,90022,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['guid'],['guided']
Usability," see the :doc:`TestingGuide`. Cross compiling; ===============. See `this wiki page <https://gitlab.kitware.com/cmake/community/wikis/doc/cmake/CrossCompiling>`_ for; generic instructions on how to cross-compile with CMake. It goes into detailed; explanations and may seem daunting, but it is not. On the wiki page there are; several examples including toolchain files. Go directly to the; ``Information how to set up various cross compiling toolchains`` section; for a quick solution. Also see the `LLVM-related variables`_ section for variables used when; cross-compiling. Embedding LLVM in your project; ==============================. From LLVM 3.5 onwards the CMake build system exports LLVM libraries as; importable CMake targets. This means that clients of LLVM can now reliably use; CMake to develop their own LLVM-based projects against an installed version of; LLVM regardless of how it was built. Here is a simple example of a CMakeLists.txt file that imports the LLVM libraries; and uses them to build a simple application ``simple-tool``. .. code-block:: cmake. cmake_minimum_required(VERSION 3.20.0); project(SimpleProject). find_package(LLVM REQUIRED CONFIG). message(STATUS ""Found LLVM ${LLVM_PACKAGE_VERSION}""); message(STATUS ""Using LLVMConfig.cmake in: ${LLVM_DIR}""). # Set your project compile flags.; # E.g. if using the C++ header files; # you will need to enable C++11 support; # for your compiler. include_directories(${LLVM_INCLUDE_DIRS}); separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS}); add_definitions(${LLVM_DEFINITIONS_LIST}). # Now build our tools; add_executable(simple-tool tool.cpp). # Find the libraries that correspond to the LLVM components; # that we wish to use; llvm_map_components_to_libnames(llvm_libs support core irreader). # Link against LLVM libraries; target_link_libraries(simple-tool ${llvm_libs}). The ``find_package(...)`` directive when used in CONFIG mode (as in the above; example) will look for the ``LLVMConfig.cmak",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:41230,simpl,simple,41230,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,2,['simpl'],"['simple', 'simple-tool']"
Usability," set(CLANG_TOOL_CLANG_IMPORT_TEST_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_CLANG_OFFLOAD_BUNDLER_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_CLANG_RENAME_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_C_ARCMT_TEST_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_C_INDEX_TEST_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_DIAGTOOL_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_LIBCLANG_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_SCAN_BUILD_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_SCAN_VIEW_BUILD OFF CACHE BOOL """"); set(LLVM_BUILD_TOOLS OFF CACHE BOOL """"); set(LLVM_TOOL_LLVM_AR_BUILD OFF CACHE BOOL """"); set(CLANG_TOOL_CLANG_OFFLOAD_BUNDLER_BUILD OFF CACHE BOOL """"); set(LLVM_FORCE_USE_OLD_TOOLCHAIN ON CACHE BOOL """"). # Prevent Clang from finding CUDA just to determine the architecture for OpenMP; # offloading, which we are not interested in. If the CUDA package was already; # found before (because the user turned on cuda or tmva-gpu), this will not have; # an effect, which is fine.; # (Note that the option is very counter-intuitive: We turn *on* disabling it...); set(CMAKE_DISABLE_FIND_PACKAGE_CUDA ON). # will be set again in case NOT builtin_llvm; set(LLVM_DIR ""${CMAKE_BINARY_DIR}/interpreter/llvm-project/llvm""); if (clad); set(CLING_BUILD_PLUGINS ON); endif(). # We only use llvm/clang through TCling which is (with the help of core/meta) already taking a lock; # to serialize access to llvm. We can later review how to make this finer grained by using llvm's own locking; # mechanism.; set(LLVM_ENABLE_THREADS OFF CACHE BOOL """"). # The llvm::ReverseIterate<bool>::value symbol from llvm's SmallPtrSet.h; # somehow lands in our cling libraries on OS X and doesn't get hidden; # by visibility-inlines-hidden, so we suddenly have a global weak symbol; # from LLVM in cling which our visiblity=hidden compiled LLVM libraries; # reference. This is triggering some build system warnings like this:; # ld: warning: direct access in function '(anonymous namespace)::NewGVN::runGVN()'; # from file 'interpreter/llvm-projec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:2552,intuit,intuitive,2552,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['intuit'],['intuitive']
Usability," show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one per axis) are filled according to the number of lines passing; through the bins. ![The histogram’s axis can be represented with colors or as bar charts.](pictures/para4.png). These histograms can be represented which colors (get from a palette; according to the bin contents) or as bar charts. Both representations; can be cumulated on the same plot. This technique allows seeing clearly; where the clusters are on an individual axis but it does not give any; hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to define selections interactively. A selection is a set of ranges combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with log",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:99537,simpl,simple,99537,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability," significant impact on users and/or downstream code bases,; reviewers can request an RFC achieving consensus before proceeding with code; review. That having been said, posting initial patches can help with; discussions on an RFC. Code-Review Workflow; ====================. Code review can be an iterative process, which continues until the patch is; ready to be committed. Specifically, once a patch is sent out for review, it; needs an explicit approval before it is committed. Do not assume silent; approval, or solicit objections to a patch with a deadline. Acknowledge All Reviewer Feedback; ---------------------------------. All comments by reviewers should be acknowledged by the patch author. It is; generally expected that suggested changes will be incorporated into a future; revision of the patch unless the author and/or other reviewers can articulate a; good reason to do otherwise (and then the reviewers must agree). If a new patch; does not address all outstanding feedback, the author should explicitly state; that when providing the updated patch. When using the web-based code-review; tool, such notes can be provided in the ""Diff"" description (which is different; from the description of the ""Differential Revision"" as a whole used for the; commit message). If you suggest changes in a code review, but don't wish the suggestion to be; interpreted this strongly, please state so explicitly. Aim to Make Efficient Use of Everyone's Time; --------------------------------------------. Aim to limit the number of iterations in the review process. For example, when; suggesting a change, if you want the author to make a similar set of changes at; other places in the code, please explain the requested set of changes so that; the author can make all of the changes at once. If a patch will require; multiple steps prior to approval (e.g., splitting, refactoring, posting data; from specific performance tests), please explain as many of these up front as; possible. This allows the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:5310,feedback,feedback,5310,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,1,['feedback'],['feedback']
Usability," situation with; // this surprisingly long comment, so it would be unclear without the braces; // whether the following statement is in the scope of the `if`.; handleOtherDecl(D);; }. // This should also omit braces. The `for` loop contains only a single; // statement, so it shouldn't have braces. The `if` also only contains a; // single simple statement (the `for` loop), so it also should omit braces.; if (isa<FunctionDecl>(D)); for (auto *A : D.attrs()); handleAttr(A);. // Use braces for a `do-while` loop and its enclosing statement.; if (Tok->is(tok::l_brace)) {; do {; Tok = Tok->Next;; } while (Tok);; }. // Use braces for the outer `if` since the nested `for` is braced.; if (isa<FunctionDecl>(D)) {; for (auto *A : D.attrs()) {; // In this `for` loop body, it is necessary that we explain the situation; // with this surprisingly long comment, forcing braces on the `for` block.; handleAttr(A);; }; }. // Use braces on the outer block because there are more than two levels of; // nesting.; if (isa<FunctionDecl>(D)) {; for (auto *A : D.attrs()); for (ssize_t i : llvm::seq<ssize_t>(count)); handleAttrOnDecl(D, A, i);; }. // Use braces on the outer block because of a nested `if`; otherwise the; // compiler would warn: `add explicit braces to avoid dangling else`; if (auto *D = dyn_cast<FunctionDecl>(D)) {; if (shouldProcess(D)); handleVarDecl(D);; else; markAsIgnored(D);; }. See Also; ========. A lot of these comments and recommendations have been culled from other sources.; Two particularly important books for our work are:. #. `Effective C++; <https://www.amazon.com/Effective-Specific-Addison-Wesley-Professional-Computing/dp/0321334876>`_; by Scott Meyers. Also interesting and useful are ""More Effective C++"" and; ""Effective STL"" by the same author. #. `Large-Scale C++ Software Design; <https://www.amazon.com/Large-Scale-Software-Design-John-Lakos/dp/0201633620>`_; by John Lakos. If you get some free time, and you haven't read them: do so, you might learn; something.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:65844,learn,learn,65844,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['learn'],['learn']
Usability," some implicit; dependencies can sneak through: A depends on B and C, so valid orderings are; ""C B A"" or ""B C A"", in both cases the explicit dependencies come before their; use. But in the first case, B could still link successfully if it implicitly; depended on C, or the opposite in the second case). .. _minimal list of #includes:. ``#include`` as Little as Possible; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``#include`` hurts compile time performance. Don't do it unless you have to,; especially in header files. But wait! Sometimes you need to have the definition of a class to use it, or to; inherit from it. In these cases go ahead and ``#include`` that header file. Be; aware however that there are many cases where you don't need to have the full; definition of a class. If you are using a pointer or reference to a class, you; don't need the header file. If you are simply returning a class instance from a; prototyped function or method, you don't need it. In fact, for most cases, you; simply don't need the definition of a class. And not ``#include``\ing speeds up; compilation. It is easy to try to go too overboard on this recommendation, however. You; **must** include all of the header files that you are using --- you can include; them either directly or indirectly through another header file. To make sure; that you don't accidentally forget to include a header file in your module; header, make sure to include your module header **first** in the implementation; file (as mentioned above). This way there won't be any hidden dependencies that; you'll find out about later. Keep ""Internal"" Headers Private; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Many modules have a complex implementation that causes them to use more than one; implementation (``.cpp``) file. It is often tempting to put the internal; communication interface (helper classes, extra functions, etc) in the public; module header file. Don't do this!. If you really need to do something like this, put a private header file in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:32450,simpl,simply,32450,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['simpl'],['simply']
Usability," specified location list expression E is; evaluated. The evaluation of E uses the current context, except the result; kind is a location description, the compilation unit is the one that; contains D, and the initial stack is empty. The location description; result is pushed on the stack. .. note::. This rule avoids having to define how to execute a matched location list; entry operation expression on the same stack as the call when there are; multiple matches. But it allows the call to obtain the location; description for a variable or formal parameter which may use a location; list expression. An alternative is to treat the case when D has a ``DW_AT_location``; attribute that is encoded as a ``loclist`` or ``loclistsptr``, and the; specified location list expression E' matches a single location list; entry with operation expression E, the same as the ``exprloc`` case and; evaluate on the same stack. But this is not attractive as if the attribute is for a variable that; happens to end with a non-singleton stack, it will not simply put a; location description on the stack. Presumably the intent of using; ``DW_OP_call*`` on a variable or formal parameter debugger information; entry is to push just one location description on the stack. That; location description may have more than one single location description. The previous rule for ``exprloc`` also has the same problem, as normally; a variable or formal parameter location expression may leave multiple; entries on the stack and only return the top entry. GDB implements ``DW_OP_call*`` by always executing E on the same stack.; If the location list has multiple matching entries, it simply picks the; first one and ignores the rest. This seems fundamentally at odds with; the desire to support multiple places for variables. So, it feels like ``DW_OP_call*`` should both support pushing a location; description on the stack for a variable or formal parameter, and also; support being able to execute an operation expression on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:76911,simpl,simply,76911,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simply']
Usability," speedup in drawings; 8. SVG code improvement for TGraph, TF1, TAxis drawings; 9. Provide new tooltip kind; - created only when needed (minimizing SVG code); - tooltip can be drawn for every object in the frame; - touch devices are supported; 10. Fix - let draw same object on the canvas with different options; 11. Create cached list of known class methods. It can be extended by users.; 12. Use of cached methods improves binary I/O performance by 20%; 13. Support TGaxis; 14. Project now can be obtained via 'bower install jsroot'; 15. Support 'scat' and 'text' draw options for TH2; 16. Support in binary I/O zipped buffer bigger than 16M; 17. Correctly handle in binary I/O pointer on TArray object (like in THnSparseArrayChunk). ## Changes in 4.3; 1. Implement TGeoCtub, TGeoParaboloid and TGeoHype shapes; 2. Support TGeoTube with Rmin==0; 3. Exclude empty faces in TGeoArb8; 4. Improve TGeoSphere creation - handle all parameters combinations; 5. Introduce JSROOT.cleanup() function to safely clear all drawn objects; 6. Fix wrong resize method in 'tabs' and 'collapsible' layouts; 7. Fix canvas resize problem (issue #27); 8. Fix zero-height canvas when draw TGeo in collapsible layout; 9. Fix problem of simultaneous move TGeo drawings and canvas in flexible layout. ## Changes in 4.2; 1. Significant performance improvements in 3D drawings - TGeo/TH2/TH3; 2. Implement TGeoPara, TGeoGtra, TGeoXtru and TGeoEltu shapes; 3. Optimize (reduce vertices number) for others TGeo shapes; 4. Correct rotation/translation/scaling of TGeo nodes; 5. Workaround for axis reflection (not directly supported in three.js); 6. Support array of objects in I/O (like in TAxis3D); 7. Correct reading of multi-dim arrays like Double_t fXY[8][2];; 8. Provide canvas toolbar for actions like savepng or unzoom; 9. Implement JSROOT.resize() function to let resize drawing after changes in page layout; 10. Fix error with title display/update. ## Changes in 4.1; 1. Introduce object inspector - one could browse ob",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:57926,clear,clear,57926,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['clear'],['clear']
Usability," spill that reg, so be; it. ===-------------------------------------------------------------------------===. We compile this:; int test(_Bool X) {; return X ? 524288 : 0;; }. to: ; _test:; cmplwi cr0, r3, 0; lis r2, 8; li r3, 0; beq cr0, LBB1_2 ;entry; LBB1_1: ;entry; mr r3, r2; LBB1_2: ;entry; blr . instead of:; _test:; addic r2,r3,-1; subfe r0,r2,r3; slwi r3,r0,19; blr. This sort of thing occurs a lot due to globalopt. ===-------------------------------------------------------------------------===. We compile:. define i32 @bar(i32 %x) nounwind readnone ssp {; entry:; %0 = icmp eq i32 %x, 0 ; <i1> [#uses=1]; %neg = sext i1 %0 to i32 ; <i32> [#uses=1]; ret i32 %neg; }. to:. _bar:; 	cntlzw r2, r3; 	slwi r2, r2, 26; 	srawi r3, r2, 31; 	blr . it would be better to produce:. _bar: ; addic r3,r3,-1; subfe r3,r3,r3; blr. ===-------------------------------------------------------------------------===. We generate horrible ppc code for this:. #define N 2000000; double a[N],c[N];; void simpleloop() {; int j;; for (j=0; j<N; j++); c[j] = a[j];; }. LBB1_1: ;bb; lfdx f0, r3, r4; addi r5, r5, 1 ;; Extra IV for the exit value compare.; stfdx f0, r2, r4; addi r4, r4, 8. xoris r6, r5, 30 ;; This is due to a large immediate.; cmplwi cr0, r6, 33920; bne cr0, LBB1_1. //===---------------------------------------------------------------------===//. This:; #include <algorithm>; inline std::pair<unsigned, bool> full_add(unsigned a, unsigned b); { return std::make_pair(a + b, a + b < a); }; bool no_overflow(unsigned a, unsigned b); { return !full_add(a, b).second; }. Should compile to:. __Z11no_overflowjj:; add r4,r3,r4; subfc r3,r3,r4; li r3,0; adde r3,r3,r3; blr. (or better) not:. __Z11no_overflowjj:; add r2, r4, r3; cmplw cr7, r2, r3; mfcr r2; rlwinm r2, r2, 29, 31, 31; xori r3, r2, 1; blr . //===---------------------------------------------------------------------===//. We compile some FP comparisons into an mfcr with two rlwinms and an or. For; example:; #include <math.h>; int test(dou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt:8749,simpl,simpleloop,8749,interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,1,['simpl'],['simpleloop']
Usability," statement spacing).; Clang has a few additional coding standards:. cstdio is forbidden: library code should not output diagnostics; or other information using cstdio; debugging routines should; use llvm::errs(). Other uses of cstdio impose behavior; upon clients and block integrating Clang as a library. Libraries should; support raw_ostream based interfaces for textual; output. See Coding; Standards. Developer Documentation. Both Clang and LLVM use doxygen to provide API documentation. Their; respective web pages (generated nightly) are here:. Clang; LLVM. For work on the LLVM IR generation, the LLVM assembly language; reference manual is; also useful. Debugging. Inspecting data structures in a debugger:. Many LLVM and Clang data structures provide; a dump() method which will print a description of the; data structure to stderr.; The QualType; structure is used pervasively. This is a simple value class for; wrapping types with qualifiers; you can use; the isConstQualified(), for example, to get one of the; qualifiers, and the getTypePtr() method to get the; wrapped Type* which you can then dump.; For LLDB users there are; data formatters for clang data structures in; ; clang/utils/ClangDataFormat.py. Debugging using Visual Studio. The files; ; llvm/utils/LLVMVisualizers/llvm.natvis and; ; clang/utils/ClangVisualizers/clang.natvis provide debugger visualizers; that make debugging of more complex data types much easier.; Depending on how you configure the project, Visual Studio may automatically; use these visualizers when debugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERB",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:1555,simpl,simple,1555,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,1,['simpl'],['simple']
Usability," still valid.; PreservedAnalyses PA;; PA.preserveSet<CFGAnalyses>();; return PA;. The pass manager will call the analysis manager's ``invalidate()`` method; with the pass's returned ``PreservedAnalyses``. This can be also done; manually within the pass:. .. code-block:: c++. FooModulePass::run(Module& M, ModuleAnalysisManager& AM) {; auto &FAM = AM.getResult<FunctionAnalysisManagerModuleProxy>(M).getManager();. // Invalidate all analysis results for function F1.; FAM.invalidate(F1, PreservedAnalyses::none());. // Invalidate all analysis results across the entire module.; AM.invalidate(M, PreservedAnalyses::none());. // Clear the entry in the analysis manager for function F2 if we've completely removed it from the module.; FAM.clear(F2);. ...; }. One thing to note when accessing inner level IR analyses is cached results for; deleted IR. If a function is deleted in a module pass, its address is still used; as the key for cached analyses. Take care in the pass to either clear the; results for that function or not use inner analyses at all. ``AM.invalidate(M, PreservedAnalyses::none());`` will invalidate the inner; analysis manager proxy which will clear all cached analyses, conservatively; assuming that there are invalid addresses used as keys for cached analyses.; However, if you'd like to be more selective about which analyses are; cached/invalidated, you can mark the analysis manager proxy as preserved,; essentially saying that all deleted entries have been taken care of manually.; This should only be done with measurable compile time gains as it can be tricky; to make sure all the right analyses are invalidated. Implementing Analysis Invalidation; ==================================. By default, an analysis is invalidated if ``PreservedAnalyses`` says that; analyses on the IR unit it runs on are not preserved (see; ``AnalysisResultModel::invalidate()``). An analysis can implement; ``invalidate()`` to be more conservative when it comes to invalidation. For; example,. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:14247,clear,clear,14247,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['clear'],['clear']
Usability," succeeding, it isn't perfect: there are edges. The following sections; explain in some detail what you can expect, and what you need to watch; out for. #### Access to ROOT Classes. Before a ROOT class can be used from Python, its dictionary needs to be; loaded into the current process. Starting with ROOT version 4.00/06,; this happens automatically for all classes that are declared to the; auto-loading mechanism through so-called `rootmap` files. Effectively,; this means that all classes in the ROOT distributions are directly; available for import. For example:. ``` {.cpp}; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); ```. Although it is not recommended, a simple way of working with `PyROOT` is; doing a global import:. ``` {.cpp}; from ROOT import *. c = TCanvas(); l = TLorentzVector(); ```. Keeping the ROOT namespace (""`import ROOT`""), or only importing from; ROOT those classes that you will actually use (see above), however, will; always be cleaner and clearer:. ``` {.cpp}; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); ```. Since it is foreseen that most people will use the simple approach; anyway, the request to copy all from module ROOT will not actually; result in copying all ROOT classes into the current namespace. Instead,; classes will still be bound (and possibly loaded) on an as-needed basis.; Note carefully how this is different from other Python (extension); modules, and what to expect if you use the normal inspection tools (such; as e.g. '`dir()`'). This feature prevents the inspection tools from; being swamped by an enormous amount of classes, but they can no longer; be used to explore unknown parts of the system (e.g. to find out which; classes are available). Furthermore, because of this approach,; \<`tab`\>-completion will usually not be available until after the first; use (and hence creation) of a class. Access to class stati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:10288,clear,clearer,10288,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['clear'],['clearer']
Usability," suffix. This allows differentiating intrinsics with; different unnamed types as arguments. (For example:; ``llvm.ssa.copy.p0s_s.2(%42*)``) The number is tracked in the LLVM module and; it ensures unique names in the module. While linking together two modules, it is; still possible to get a name clash. In that case one of the names will be; changed by getting a new number. For target developers who are defining intrinsics for back-end code; generation, any intrinsic overloads based solely the distinction between; integer or floating point types should not be relied upon for correct; code generation. In such cases, the recommended approach for target; maintainers when defining intrinsics is to create separate integer and; FP intrinsics rather than rely on overloading. For example, if different; codegen is required for ``llvm.target.foo(<4 x i32>)`` and; ``llvm.target.foo(<4 x float>)`` then these should be split into; different intrinsics. To learn how to add an intrinsic function, please see the `Extending; LLVM Guide <ExtendingLLVM.html>`_. .. _int_varargs:. Variable Argument Handling Intrinsics; -------------------------------------. Variable argument support is defined in LLVM with the; :ref:`va_arg <i_va_arg>` instruction and these three intrinsic; functions. These functions are related to the similarly named macros; defined in the ``<stdarg.h>`` header file. All of these functions operate on arguments that use a target-specific; value type ""``va_list``"". The LLVM assembly language reference manual; does not define what this type is, so all transformations should be; prepared to handle these functions regardless of the type used. This example shows how the :ref:`va_arg <i_va_arg>` instruction and the; variable argument handling intrinsic functions are used. .. code-block:: llvm. ; This struct is different for every platform. For most platforms,; ; it is merely a ptr.; %struct.va_list = type { ptr }. ; For Unix x86_64 platforms, va_list is the following struct:; ;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:491441,learn,learn,491441,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['learn'],['learn']
Usability," supported. ### The Idea Behind TClonesArray. To reduce the very large number of new and delete calls in large loops; like this (O(100000) x O(10000) times new/delete):. ``` {.cpp}; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete();; }; ```. You better use a **`TClonesArray`** which reduces the number of; new/delete calls to only O(10000):. ``` {.cpp}; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); TTrack *track = (Track*)a.ConstructedAt(i);; track->Set(x,y,z,...);; ...; }; ...; a.Clear(); // Or Clear(""C"") if the track objects must be returned (via Track::Clear) to a default state.; }; ```. Considering that a pair of new/delete calls on average cost about 70 ms,; O(109) new/deletes will save about 19 hours. For the other collections,; see the class reference guide on the web and the test program; `$ROOTSYS/test/tcollex.cxx.`. ## Template Containers and STL. Some people dislike polymorphic containers because they are not truly; ""type safe"". In the end, the compiler leaves it the user to ensure that; the types are correct. This only leaves the other alternative: creating; a new class each time a new (container organization) / (contained; object) combination is needed. To say the least this could be very; tedious. Most people faced with this choice would, for each type of; container:. Define the class leaving a dummy name for the contained object type.; When a particular container was needed, copy the code and then do a; global search and replace for the contained class. C++ has a built in; template scheme that effectively does just this. For example:. ``` {.cpp}; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; ```. This is an array container with a 10-element array of pointers to T, it; could hold up to 10 T objects.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:17872,guid,guide,17872,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['guid'],['guide']
Usability," symbols in lego plos axis title; 10. Use frame margins when create 3D lego drawings; 11. Implement ""nomargins"" draw option for pad/canvas; 12. Support custom mouse click/dblcklick handlers in lego plots; 13. Implement marker styles 35 - 49; 14. Let switch orthographic camera in geometry via control gui (#217); 15. Fix drawing of custom markers on 3D, also in node.js (#205). ## Changes in 6.1.1; 1. Fix bug in TFrame drawing, some interactive features was not properly working. ## Changes in 6.1.0; 1. Support drawing produced by TRatioPlot, including interactive zooming; 2. Fix problem with TF1 drawing from histogram list of primitives; 3. Let disable showing of StreamerInfo in the GUI by adding &skipsi to URL; 4. Provide tooltips when TH1 drawn with ""E"" or ""P"" option; 5. Fix problem with zooming of many overlayed histograms; 6. API change -> PadPainter.zoom function returns Promise now; 7. Support gridx/y, tickx/y, logx/y options for (multi) graphs painter; 8. Provide simple Rebin functionality for TH1 (#210); 9. Use jQuery dialog to input values, avoid prompt() which not always supported (#216). ## Changes in 6.0.2; 1. Fix ZSTD size limitation, use streaming API (#214); 2. Prevent endless recursion in JSROOT.parse() function. ## Changes in 6.0.1; 1. Fix problem with matrix calculations in Eve classes (#206); 2. Fix errors in TNodejsFile (#208); 3. Fix TGraph tooltips handling; 4. Fix TH2Poly tooltips handling. ## Changes in 6.0.0; 1. Major release with:; - incompatible changes in API; - heavy use of Promise class; - upgrade all used packages; 2. Use generic naming convention - all class names always starts from; capital letter like ""ObjectPainter"", all function names starts from small; letter like ""painter.getObjectHint()""; 3. Rename JSRootCore.js -> JSRoot.core.js, eliminate all URL parameters.; Loading of extra JSROOT functionality should be done via JSROOT.require() method; All other scripts uses similar naming convention.; 4. JSROOT.draw()/JSROOT.redraw() functi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:24127,simpl,simple,24127,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['simpl'],['simple']
Usability," that even if present, its use may depend on run-time privilege or other OS; controlled state. ``__builtin_dump_struct``; -------------------------. **Syntax**:. .. code-block:: c++. __builtin_dump_struct(&some_struct, some_printf_func, args...);. **Examples**:. .. code-block:: c++. struct S {; int x, y;; float f;; struct T {; int i;; } t;; };. void func(struct S *s) {; __builtin_dump_struct(s, printf);; }. Example output:. .. code-block:: none. struct S {; int x = 100; int y = 42; float f = 3.141593; struct T t = {; int i = 1997; }; }. .. code-block:: c++. #include <string>; struct T { int a, b; };; constexpr void constexpr_sprintf(std::string &out, const char *format,; auto ...args) {; // ...; }; constexpr std::string dump_struct(auto &x) {; std::string s;; __builtin_dump_struct(&x, constexpr_sprintf, s);; return s;; }; static_assert(dump_struct(T{1, 2}) == R""(struct T {; int a = 1; int b = 2; }; )"");. **Description**:. The ``__builtin_dump_struct`` function is used to print the fields of a simple; structure and their values for debugging purposes. The first argument of the; builtin should be a pointer to a complete record type to dump. The second argument ``f``; should be some callable expression, and can be a function object or an overload; set. The builtin calls ``f``, passing any further arguments ``args...``; followed by a ``printf``-compatible format string and the corresponding; arguments. ``f`` may be called more than once, and ``f`` and ``args`` will be; evaluated once per call. In C++, ``f`` may be a template or overload set and; resolve to different functions for each call. In the format string, a suitable format specifier will be used for builtin; types that Clang knows how to format. This includes standard builtin types, as; well as aggregate structures, ``void*`` (printed with ``%p``), and ``const; char*`` (printed with ``%s``). A ``*%p`` specifier will be used for a field; that Clang doesn't know how to format, and the corresponding argument will be ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:104853,simpl,simple,104853,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['simpl'],['simple']
Usability," that is; derived at run-time from the header files.; It is still possible to fully embed header files rather than only storing; their names and search locations, to make the dictionary more self-contained. After generating the dictionary, it should be compiled into a shared library.; This provides additional dependency control: by linking it directly with any; further libraries needed, you can use standard mechanisms such as ``rpath``; to locate those library dependencies.; Alternatively, you can add the additional libraries to load to the mapping; files of the class loader (see below). .. note::. The JIT needs to resolve linker symbols in order to call them through; generated wrappers.; Thus, any classes, functions, and data that will be used in Python need; to be exported.; This is the default behavior on Mac and Linux, but not on Windows.; On that platform, use ``__declspec(dllexport)`` to explicitly export the; classes and function you expect to call.; CMake has simple `support for exporting all`_ C++ symbols. In tandem with any dictionary, a pre-compiled module (.pcm) file will be; generated.; C++ modules are still on track for inclusion in the C++20 standard and most; modern C++ compilers, ``clang`` among them, already have implementations.; The benefits for cppyy include faster bindings generation, lower memory; footprint, and isolation from preprocessor macros and compiler flags.; The use of modules is transparent, other than the requirement that they; need to be co-located with the compiled dictionary shared library. Optionally, the dictionary generation process also produces a mapping file,; which lists the libraries needed to load C++ classes on request (for details,; see the section on the class loader below). Structurally, you could have a single dictionary for a project as a whole,; but more likely a large project will have a pre-existing functional; decomposition that can be followed, with a dictionary per functional unit. Generation; ^^^^^^^^^^. The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:2404,simpl,simple,2404,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,1,['simpl'],['simple']
Usability," that the dialog; boxes and other windows do not result in black areas on the saved; image. The window must still be fully contained within the desktop. Improved camera controls. Three new orthographic cameras have; been added to TGLViewer, looking at the scene from another; side than the one present so far. Improved FTGL font management across rendering contexts and text; rendering support. New class TGLAxisPainter that can render 2D and 3D axes; via GL. For example see tutorials/eve/cms_calo.C. Possible performance issues with ATI drivers (fglrx). In late 2007 ATI switched to a new driver architecture. With these; drivers a significant degradation of GL performance in selection mode,; up to a factor of 50, was observed. Both linux and Windows drivers; were affected. The issue has been resolved in the latest driver; versions. Eve; Major changes. Support for multiple, parallel OpenGL views that can show different; projections of the same event. Provide object selection and feedback highlight across all GL-views and; list-trees. New classes for visualization of calorimeter data,; TEveCaloXYZ, see tutorials/eve/cms_calo.C. Available; representations: 3D-cylindrical view, projected views r-phi and rho-z,; and lego-view (with dedicated event handler allowing detailed; inspection of the data). Support for compound objects in view of selection, highlight and; color managament (see class TEveCompound). Optimize updates of GL-scenes by introducing change-stamping bits; into TEveElement. See methods AddStamp() and; StampXyzz(). Added support for central management of visualization parameters; of objects. Instead of specifying visual attributes individually by; set-methods a single string tag can be used to retrieve all of them; with a single command, e.g.,; track->ApplyVizTag(""MuonTrack""). The parameter-database can; be saved as a CINT script, edited manually and loaded. This provides more; flexibility as different users can share the same code to; instantiate visualziation o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v520/index.html:1524,feedback,feedback,1524,graf3d/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v520/index.html,1,['feedback'],['feedback']
Usability," the ""``=``"" in case of an output). This indicates that the asm; will write to or read from the contents of an *address* provided as an input; argument. (Note that in this way, indirect outputs act more like an *input* than; an output: just like an input, they consume an argument of the call expression,; rather than producing a return value. An indirect output constraint is an; ""output"" only in that the asm is expected to write to the contents of the input; memory location, instead of just read from it). This is most typically used for memory constraint, e.g. ""``=*m``"", to pass the; address of a variable as a value. It is also possible to use an indirect *register* constraint, but only on output; (e.g. ""``=*r``""). This will cause LLVM to allocate a register for an output; value normally, and then, separately emit a store to the address provided as; input, after the provided inline asm. (It's not clear what value this; functionality provides, compared to writing the store explicitly after the asm; statement, and it can only produce worse code, since it bypasses many; optimization passes. I would recommend not using it.). Call arguments for indirect constraints must have pointer type and must specify; the :ref:`elementtype <attr_elementtype>` attribute to indicate the pointer; element type. Clobber constraints; """""""""""""""""""""""""""""""""""""". A clobber constraint is indicated by a ""``~``"" prefix. A clobber does not; consume an input operand, nor generate an output. Clobbers cannot use any of the; general constraint code letters -- they may use only explicit register; constraints, e.g. ""``~{eax}``"". The one exception is that a clobber string of; ""``~{memory}``"" indicates that the assembly writes to arbitrary undeclared; memory locations -- not only the memory pointed to by a declared indirect; output. Note that clobbering named registers that are also present in output; constraints is not legal. Label constraints; """""""""""""""""""""""""""""""""". A label constraint is indicated by a ""``!``"" pre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:216600,clear,clear,216600,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['clear'],['clear']
Usability," the :doc:`ConvergentOperations` document for details. .. _moduleasm:. Module-Level Inline Assembly; ----------------------------. Modules may contain ""module-level inline asm"" blocks, which corresponds; to the GCC ""file scope inline asm"" blocks. These blocks are internally; concatenated by LLVM and treated as a single unit, but may be separated; in the ``.ll`` file if desired. The syntax is very simple:. .. code-block:: llvm. module asm ""inline asm code goes here""; module asm ""more can go here"". The strings can contain any character by escaping non-printable; characters. The escape sequence used is simply ""\\xx"" where ""xx"" is the; two digit hex code for the number. Note that the assembly string *must* be parseable by LLVM's integrated assembler; (unless it is disabled), even when emitting a ``.s`` file. .. _langref_datalayout:. Data Layout; -----------. A module may specify a target specific data layout string that specifies; how data is to be laid out in memory. The syntax for the data layout is; simply:. .. code-block:: llvm. target datalayout = ""layout specification"". The *layout specification* consists of a list of specifications; separated by the minus sign character ('-'). Each specification starts; with a letter and may include other information after the letter to; define some aspect of the data layout. The specifications accepted are; as follows:. ``E``; Specifies that the target lays out data in big-endian form. That is,; the bits with the most significance have the lowest address; location.; ``e``; Specifies that the target lays out data in little-endian form. That; is, the bits with the least significance have the lowest address; location.; ``S<size>``; Specifies the natural alignment of the stack in bits. Alignment; promotion of stack variables is limited to the natural stack; alignment to avoid dynamic stack realignment. The stack alignment; must be a multiple of 8-bits. If omitted, the natural stack; alignment defaults to ""unspecified"", which does no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:131092,simpl,simply,131092,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability," the LLVM coding standards and provides useful information on writing; efficient C++ code. :doc:`GitHub`; Describes how to use the llvm-project repository and code reviews on GitHub. :doc:`GitBisecting`; Describes how to use ``git bisect`` on LLVM's repository. :doc:`GitRepositoryPolicy`; Collection of policies around the git repositories. .. _development-process:. Development Process; -------------------. Information about LLVM's development process. .. toctree::; :hidden:. Projects; HowToReleaseLLVM; Packaging; ReleaseProcess; HowToAddABuilder; ReleaseNotes. :doc:`Projects`; How-to guide and templates for new projects that *use* the LLVM; infrastructure. The templates (directory organization, Makefiles, and test; tree) allow the project code to be located outside (or inside) the ``llvm/``; tree, while using LLVM header files and libraries. :doc:`HowToReleaseLLVM`; This is a guide to preparing LLVM releases. Most developers can ignore it. :doc:`ReleaseProcess`; This is a guide to validate a new release, during the release process. Most developers can ignore it. :doc:`HowToAddABuilder`; Instructions for adding new builder to LLVM buildbot master. :doc:`Packaging`; Advice on packaging LLVM into a distribution. :doc:`Release notes for the current release <ReleaseNotes>`; This describes new features, known bugs, and other limitations. .. _lists-forums:. Forums & Mailing Lists; ----------------------. If you can't find what you need in these docs, try consulting the; Discourse forums. There are also commit mailing lists for all commits to the LLVM Project.; The :doc:`CodeOfConduct` applies to all these forums and mailing lists. `LLVM Discourse`__; The forums for all things LLVM and related sub-projects. There are categories and subcategories for a wide variety of areas within LLVM. You can also view tags or search for a specific topic. .. __: https://discourse.llvm.org/. `Commits Archive (llvm-commits)`__; This list contains all commit messages that are made when LLVM d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:1997,guid,guide,1997,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['guid'],['guide']
Usability," the LLVM toolchain, and will reside in; the ""/llvm/tools/llvm-cfi-verify"" directory, relative to the LLVM trunk. It will; be tested in two methods:. - Unit tests to validate code sections, present in; ""/llvm/unittests/tools/llvm-cfi-verify"".; - Integration tests, present in ""/llvm/tools/clang/test/LLVMCFIVerify"". These; integration tests are part of clang as part of a continuous integration; framework, ensuring updates to the compiler that reduce CFI coverage on; indirect control flow instructions are identified. Background; ==========. This tool will continuously validate that CFI directives are properly; implemented around all indirect control flows by analysing the output machine; code. The analysis of machine code is important as it ensures that any bugs; present in linker or compiler do not subvert CFI protections in the final; shipped binary. Unprotected indirect control flow instructions will be flagged for manual; review. These unexpected control flows may simply have not been accounted for in; the compiler implementation of CFI (e.g. indirect jumps to facilitate switch; statements may not be fully protected). It may be possible in the future to extend this tool to flag unnecessary CFI; directives (e.g. CFI directives around a static call to a non-polymorphic base; type). This type of directive has no security implications, but may present; performance impacts. Design Ideas; ============. This tool will disassemble binaries and DSO's from their machine code format and; analyse the disassembled machine code. The tool will inspect virtual calls and; indirect function calls. This tool will also inspect indirect jumps, as inlined; functions and jump tables should also be subject to CFI protections. Non-virtual; calls (``-fsanitize=cfi-nvcall``) and cast checks (``-fsanitize=cfi-*cast*``); are not implemented due to a lack of information provided by the bytecode. The tool would operate by searching for indirect control flow instructions in; the disassembly. A con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CFIVerify.rst:1782,simpl,simply,1782,interpreter/llvm-project/llvm/docs/CFIVerify.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CFIVerify.rst,1,['simpl'],['simply']
Usability," the RNTuple is immutable and cannot be amended.; An RNTuple that is currently being written cannot be read. ### RNTupleReader; The RNTupleReader is the primary interface to read and inspect an RNTuple.; An RNTupleReader owns a model: either a model created from the on-disk information or an imposed, user-provided model.; The user-provided model can be limited to a subset of fields.; Data is populated to an explicit `REntry` or the model's default entry through `RNTupleReader::LoadEntry()`. The reader can create `RNTupleView` objects for the independent reading of individual fields.; The reader can create `RBulk` objects for bulk reading of individual fields. Additionally, the reader provides access to a cached copy of the descriptor.; It can display individual entries (`RNTupleReader::Show()`) and summary information (`RNTupleReader::PrintInfo()`). ### RNTupleView<T>; RNTuple views provide read access to individual fields.; Views are created from an RNTupleReader.; Views are templated; for simple types (e.g., `float`, `int`), views provide read-only access directly to an RNTuple page in memory.; Complex types and void views require additional memory copies to populate an object in memory from the column data. A view can iterate over the entry range, over the field range, and over the range of a collection within an entry.; For instance, for a field `std::vector<float> pt`, a view can iterate over all `pt` values of all entries, or over the `pt` values of a particular entry. A view can safely outlive its originating reader.; Once the reader is deconstructed, any attempt to read data will throw an exception, but the view is still properly destructed. Views that originate from the same reader _cannot_ be used concurrently by different threads. Internal Classes; ----------------. ### RNTupleDS; The `RNTupleDS` class is an internal class that provides an RNTuple data source for RDataFrame.; It is part of the `ROOTDataFrame` library.; The RNTuple data source supports chai",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:13615,simpl,simple,13615,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['simpl'],['simple']
Usability," the `arc` workflow and; recommended. Creating Pull Requests; ----------------------; Keep in mind that when creating a pull request, it should generally only contain one; self-contained commit initially.; This makes it easier for reviewers to understand the introduced changes and; provide feedback. It also helps maintain a clear and organized commit history; for the project. If you have multiple changes you want to introduce, it's; recommended to create separate pull requests for each change. Create a local branch per commit you want to submit and then push that branch; to your `fork <https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks>`_; of the llvm-project and; `create a pull request from the fork <https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork>`_.; As GitHub uses the first line of the commit message truncated to 72 characters; as the pull request title, you may have to edit to reword or to undo this; truncation. Creating Pull Requests with GitHub CLI; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; With the CLI it's enough to create the branch locally and then run:. ::. gh pr create. When prompted select to create and use your own fork and follow; the instructions to add more information needed. .. note::. When you let the GitHub CLI create a fork of llvm-project to; your user, it will change the git ""remotes"" so that ""origin"" points; to your fork and ""upstream"" points to the main llvm-project repository. Updating Pull Requests; ----------------------; In order to update your pull request, the only thing you need to do is to push; your new commits to the branch in your fork. That will automatically update; the pull request. When updating a pull request, you should push additional ""fix up"" commits to; your branch instead of force pushing. This makes it easier for GitHub to; track the context of previous review comments",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:2640,undo,undo,2640,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['undo'],['undo']
Usability," the apply button is; pressed, the changes are applied to the edited shape and drawn. The; ""Undo"" button becomes active after the first modification has been; applied. It allows restoring the initial parameters of the shape. NOTE: In this version the ""Undo"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. \anchor GP08d; ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection of components before creating the object. \anchor GP08e; ### Editing Volumes. Volumes are hierarchical components in the geometry, therefore their; editor is more complex. It provides the following functionalities:. - *General*. This category allows changing the name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""Position"" allows editing the; positioning matrix of a given node. \image html geometry022.jpg width=600p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:131689,undo,undoable,131689,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['undo'],['undoable']
Usability," the contributor of this policy over reverting. Minor corrections and; omissions can be handled by sending a reply to the commits mailing list. .. _revert_policy:. Patch reversion policy; ----------------------. As a community, we strongly value having the tip of tree in a good state while; allowing rapid iterative development. As such, we tend to make much heavier; use of reverts to keep the tree healthy than some other open source projects,; and our norms are a bit different. How should you respond if someone reverted your change?. * Remember, it is normal and healthy to have patches reverted. Having a patch; reverted does not necessarily mean you did anything wrong.; * We encourage explicitly thanking the person who reverted the patch for doing; the task on your behalf.; * If you need more information to address the problem, please follow up in the; original commit thread with the reverting patch author. When should you revert your own change?. * Any time you learn of a serious problem with a change, you should revert it.; We strongly encourage ""revert to green"" as opposed to ""fixing forward"". We; encourage reverting first, investigating offline, and then reapplying the; fixed patch - possibly after another round of review if warranted.; * If you break a buildbot in a way which can't be quickly fixed, please revert.; * If a test case that demonstrates a problem is reported in the commit thread,; please revert and investigate offline.; * If you receive substantial :ref:`post-commit review <post_commit_review>`; feedback, please revert and address said feedback before recommitting.; (Possibly after another round of review.); * If you are asked to revert by another contributor, please revert and discuss; the merits of the request offline (unless doing so would further destabilize; tip of tree). When should you revert someone else's change?. * In general, if the author themselves would revert the change per these; guidelines, we encourage other contributors to do so a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:19280,learn,learn,19280,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['learn'],['learn']
Usability," the examples.; - Make sure the python examples do not generate wrong namespaces in the documentation.; - The dataframe tutorials json spec files were not displayed properly. Moreover there was; no direct correspondence between the code source and the json file. Those files do not; have any doc in them. With a direct link to the GitHub source file the dependency between source; code and json is now more obvious.; - Document how to remove shadow of `TPave`, as it was not evident (only explanations were hidden here and there in the forum).; - Improve the `SetFillColorAlpha` documentation.; - Simplify some graphics examples: arrow.C, crown.C, diamond.C and ellipse.C.; - Fix a typo in the documentation of `TGraph::SetHighlight` in `TGraph.cxx`.; - Change the marker style in the tutorial `df014_CSVDataSource`.; - Remove useless settings in the tutorial `scatter.C`.; - Fix the tutorial `h1analysisTreeReader.C`.; - Fix doxygen formatting in `TGNumberEntry.cxx`.; - Avoid the CDT documentation to appear in the reference guide.; - Remove last references to the old ROOT `drupal` website. ## Build, Configuration and Testing Infrastructure. Release v6.32.00 is the first one integrated and tested entirely through the new GitHub based build system. ## Bugs and Issues fixed in this release. More than 200 items were addressed for this release. The full list is:. * [[#15621](https://github.com/root-project/root/issues/15621)] - Buffer overflow in TBranch::Init; * [[#15610](https://github.com/root-project/root/issues/15610)] - Memory leak in TTree __getattr__ pythonization; * [[#15590](https://github.com/root-project/root/issues/15590)] - Infinite recursion in TFile::Open; * [[#15460](https://github.com/root-project/root/issues/15460)] - TEnum::GetEnum(""B"")->GetUnderlyingType() does not following typedefs; * [[#15413](https://github.com/root-project/root/issues/15413)] - Fails to build with cuDNN version 9; * [[#15406](https://github.com/root-project/root/issues/15406)] - `TEnum::GetEn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:24517,guid,guide,24517,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['guid'],['guide']
Usability," the log scale along Z was on, the plot showed only the; first histogram. This can be reproduce by using the documentation example; illustrating `BOX SAME`and turning the canvas into log scale along Z.; - In TLatex:; - Do not paint the text when the text size is <= 0. This fixes; the problem mentioned [here](https://sft.its.cern.ch/jira/browse/ROOT-8305); - Do not paint text if the text string is empty.; - From: Sergey Linev: In `TPad::SaveAs` method json file extension is now handled; - Because of some precision issue some data points exactly on the plot limits of; a `TGraph2D` were not drawn (option `P`).; The problem was reported [here](https://sft.its.cern.ch/jira/browse/ROOT-8447).; - New options for automatic coloring of graphs and histograms. When several; histograms or graphs are painted in the same canvas thanks to the option ""SAME""; via a `THStack` or `TMultigraph` it might be useful to have an easy and automatic; way to choose their color. The simplest way is to pick colors in the current active color; palette. Palette coloring for histogram is activated thanks to the options `PFC`; (Palette Fill Color), `PLC` (Palette Line Color) and `AMC` (Palette Marker Color).; When one of these options is given to `TH1::Draw` the histogram get its color; from the current color palette defined by `gStyle->SetPalette(…)`. The color; is determined according to the number of objects having palette coloring in; the current pad.; - The line width and line style can be change on 2d histograms painted with; option `ARR`.; - When the angle of a TGraphPolar was not in radian, the error bars were misplaced.; The problem was reported [here](https://sft.its.cern.ch/jira/browse/ROOT-8476).; - In `TASimage::DrawLineInternal` the case of a line with 0 pixel along X and 0; pixel along Y was not treated properly. An horizontal line was drawn instead.; - In `TGraphPainter::PaintGrapHist`: Decouple the `P` option (histogram drawn with; a simple polymarker) from the `L` option (Histogram ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:9065,simpl,simplest,9065,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['simpl'],['simplest']
Usability," the native functions.; For example, given the ABI list example provided in the user manual, the; following wrappers will be generated under the args ABI:. .. code-block:: llvm. define linkonce_odr { i8*, i16 } @""dfsw$malloc""(i64 %0, i16 %1) {; entry:; %2 = call i8* @malloc(i64 %0); %3 = insertvalue { i8*, i16 } undef, i8* %2, 0; %4 = insertvalue { i8*, i16 } %3, i16 0, 1; ret { i8*, i16 } %4; }. define linkonce_odr { i32, i16 } @""dfsw$tolower""(i32 %0, i16 %1) {; entry:; %2 = call i32 @tolower(i32 %0); %3 = insertvalue { i32, i16 } undef, i32 %2, 0; %4 = insertvalue { i32, i16 } %3, i16 %1, 1; ret { i32, i16 } %4; }. define linkonce_odr { i8*, i16 } @""dfsw$memcpy""(i8* %0, i8* %1, i64 %2, i16 %3, i16 %4, i16 %5) {; entry:; %labelreturn = alloca i16; %6 = call i8* @__dfsw_memcpy(i8* %0, i8* %1, i64 %2, i16 %3, i16 %4, i16 %5, i16* %labelreturn); %7 = load i16* %labelreturn; %8 = insertvalue { i8*, i16 } undef, i8* %6, 0; %9 = insertvalue { i8*, i16 } %8, i16 %7, 1; ret { i8*, i16 } %9; }. As an optimization, direct calls to native ABI functions will call the; native ABI function directly and the pass will compute the appropriate label; internally. This has the advantage of reducing the number of union operations; required when the return value label is known to be zero (i.e. ``discard``; functions, or ``functional`` functions with known unlabelled arguments). Checking ABI Consistency; ------------------------. DFSan changes the ABI of each function in the module. This makes it possible; for a function with the native ABI to be called with the instrumented ABI,; or vice versa, thus possibly invoking undefined behavior. A simple way; of statically detecting instances of this problem is to append the suffix; "".dfsan"" to the name of each instrumented-ABI function. This will not catch every such problem; in particular function pointers passed; across the instrumented-native barrier cannot be used on the other side.; These problems could potentially be caught dynamically.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:12886,simpl,simple,12886,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,1,['simpl'],['simple']
Usability," the numeric value of the slice. - - `%frac` : to print the relative fraction of this slice. - - `%perc` : to print the % of this slice. ``` {.cpp}; mypie->SetLabelFormat(""%txt (%frac)"");; ```. See the macro `$ROOTSYS/tutorials/graphics/piechart.C` . ![The picture generated by tutorial macro piechart.C](pictures/03000042.png). ## The User Interface for Histograms. The classes **`T`** **`H1`** **`Editor`** and **`T`** **`H2`**; **`Editor`** provides the user interface for setting histogram's; attributes and rebinning interactively. ### TH1Editor. ![](pictures/03000043.png). #### The Style Tab. ##### Title. sets the title of the histogram. ##### Plot. draw a 2D or 3D plot; according to the dimension, different drawing; possibilities can be set. ##### Error; add different error bars to the histogram (no errors, simple, etc.). ##### Add; further things which can be added to the histogram (None,; simple/smooth line, fill area, etc.). #### 2-D Plot. ##### Simple Drawing; draw a simple histogram without errors (= ""HIST"" draw; option). In combination with some other draw options an outer line is; drawn on top of the histogram. ##### Show markers; draw a marker on to of each bin (=""P"" draw option). ##### Draw bar chart; draw a bar chart (=""B"" draw option). ##### Bar option; draw a bar chart (=""BAR"" draw option); if selected, it will; show an additional interface elements for bars: width, offset,; percentage and the possibility to draw horizontal bars. #### 3-D Plot. ##### Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf,; Surf1...5). ##### Coords; set the coordinate system (Cartesian, Spheric, etc.). ##### Error; same as for 2D plot. ##### Bar; set the bar attributes: width and offset. ##### Horizontal Bar; draw a horizontal bar chart. #### The Binning tab; The binning tab has two different layouts. One is for a histogram,; which is not drawn from an ntuple. The other one is available for a; histogram, which is drawn from an ntuple. In this case, the re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:71947,simpl,simple,71947,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['simpl'],['simple']
Usability," the original RooAcceptReject generator is still used. The choice of MC sampling algorithm can be steered through class RooNumGenConfig, which; is similar in style and structure, to RooNumIntConfig which configures the choice of; numeric integration algorithm. A new tutorial macro rf902_numgenconfig.C has been added to $ROOTSYS/tutorials/roofit; to illustrate the use of the steering. A macro that demonstrates of the power of these newly interface numeric algorithms is provided at the; end of the RooFit section of the release notes. Optional persistent caching of numeric integrals; For p.d.f.s with numeric integrals that remain difficult or very time consuming,; a new persistent caching technique is now available that allows to precalculate; these integrals and store their values for future use. This technique works transparently; for any p.d.f. stored in a RooWorkspace. One can store numeric integral values for problems with zero, one or two floating parameters.; In the first case, the value is simply stored. In cases with one or two floating parameters; a grid (histogram) of integral values is stored, which are interpolated to return integral; values for each value of the parameters. A new tutorial macro rf903_numintcache.C has been added to $ROOTSYS/tutorials/roofit; to illustrate the use of this feature. Representation of function and p.d.f. derivatives; A new class has been added that can represent the derivative of any p.d.f or function w.r.t. any; parameter or observable. To construct e.g. a first order derivative of a Gaussian p.d.f, do. RooAbsReal* dgdx = gauss.derivative(x,1) ;. A more complete example is available in the new tutorial macro rf111_derivatives.C. Improved handling of chi-squared fits; Chi-squared fits can now be performed through the same style of interface as likelihood fits,; through the newly added method RooAbsReal::chi2FitTo(const RooDataHist&,...). Functions that can be fitted with chi-squared minimization are any RooAbsReal based funct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:6738,simpl,simply,6738,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['simpl'],['simply']
Usability," the presence of; debugging information or whether or not LTO was used. The string entry table is; used to generically contain any arbitrary key-value pair. This is stored as an; array of the :ref:`string entry<table-binary_string>` format. .. table:: Offloading String Entry; :name: table-binary_string. +----------+--------------+-------------------------------------------------------+; | Type | Identifier | Description |; +==========+==============+=======================================================+; | uint64_t | key offset | Absolute byte offset of the key in the string table |; +----------+--------------+-------------------------------------------------------+; | uint64_t | value offset | Absolute byte offset of the value in the string table |; +----------+--------------+-------------------------------------------------------+. The string entries simply provide offsets to a key and value pair in the; binary images string table. The string table is simply a collection of null; terminated strings with defined offsets in the image. The string entry allows us; to create a key-value pair from this string table. This is used for passing; arbitrary arguments to the image, such as the triple and architecture. All of these structures are combined to form a single binary blob, the order; does not matter because of the use of absolute offsets. This makes it easier to; extend in the future. As mentioned previously, multiple offloading images are; bundled together by simply concatenating them in this format. Because we have; the magic bytes and size of each image, we can extract them as-needed. Usage; =====. This tool can be used with the following arguments. Generally information is; passed as a key-value pair to the ``image=`` argument. The ``file`` and; ``triple``, arguments are considered mandatory to make a valid image.; The ``arch`` argument is suggested. .. code-block:: console. OVERVIEW: A utility for bundling several object files into a single binary.; The output",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst:6908,simpl,simply,6908,interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,1,['simpl'],['simply']
Usability," the return value. Functions that return no value are marked; ``void``.; #. '``fnty``': shall be the signature of the function being invoked. The; argument types must match the types implied by this signature. This; type can be omitted if the function is not varargs.; #. '``fnptrval``': An LLVM value containing a pointer to a function to; be invoked. In most cases, this is a direct function invocation, but; indirect ``invoke``'s are just as possible, calling an arbitrary pointer; to function value.; #. '``function args``': argument list whose types match the function; signature argument types and parameter attributes. All arguments must; be of :ref:`first class <t_firstclass>` type. If the function signature; indicates the function accepts a variable number of arguments, the; extra arguments can be specified.; #. '``normal label``': the label reached when the called function; executes a '``ret``' instruction.; #. '``exception label``': the label reached when a callee returns via; the :ref:`resume <i_resume>` instruction or other exception handling; mechanism.; #. The optional :ref:`function attributes <fnattrs>` list.; #. The optional :ref:`operand bundles <opbundles>` list. Semantics:; """""""""""""""""""". This instruction is designed to operate as a standard '``call``'; instruction in most regards. The primary difference is that it; establishes an association with a label, which is used by the runtime; library to unwind the stack. This instruction is used in languages with destructors to ensure that; proper cleanup is performed in the case of either a ``longjmp`` or a; thrown exception. Additionally, this is important for implementation of; '``catch``' clauses in high-level languages that support them. For the purposes of the SSA form, the definition of the value returned; by the '``invoke``' instruction is deemed to occur on the edge from the; current block to the ""normal"" label. If the callee unwinds then no; return value is available. Example:; """""""""""""""". .. code-block:: ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:364516,resume,resume,364516,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['resume'],['resume']
Usability," the; execution known as 'safepoints' For most collectors, it is sufficient; to track at least one copy of each unique pointer value. However, for; a collector which wishes to relocate objects directly reachable from; running code, a higher standard is required. One additional challenge is that the compiler may compute intermediate; results (""derived pointers"") which point outside of the allocation or; even into the middle of another allocation. The eventual use of this; intermediate value must yield an address within the bounds of the; allocation, but such ""exterior derived pointers"" may be visible to the; collector. Given this, a garbage collector can not safely rely on the; runtime value of an address to indicate the object it is associated; with. If the garbage collector wishes to move any object, the; compiler must provide a mapping, for each pointer, to an indication of; its allocation. To simplify the interaction between a collector and the compiled code,; most garbage collectors are organized in terms of three abstractions:; load barriers, store barriers, and safepoints. #. A load barrier is a bit of code executed immediately after the; machine load instruction, but before any use of the value loaded.; Depending on the collector, such a barrier may be needed for all; loads, merely loads of a particular type (in the original source; language), or none at all. #. Analogously, a store barrier is a code fragment that runs; immediately before the machine store instruction, but after the; computation of the value stored. The most common use of a store; barrier is to update a 'card table' in a generational garbage; collector. #. A safepoint is a location at which pointers visible to the compiled; code (i.e. currently in registers or on the stack) are allowed to; change. After the safepoint completes, the actual pointer value; may differ, but the 'object' (as seen by the source language); pointed to will not. Note that the term 'safepoint' is somewhat overloaded. It",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:2387,simpl,simplify,2387,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['simpl'],['simplify']
Usability," these days,; but many people need them to get bigger goals accomplished: it makes sense for; everyone to work together.; For more information about the LLVM/clang license, please see the LLVM License; Description for more information. Internal Design and Implementation. A real-world, production quality compiler. Clang is designed and built by experienced compiler developers who are; increasingly frustrated with the problems that existing open source; compilers have. Clang is carefully and thoughtfully designed and; built to provide the foundation of a whole new generation of; C/C++/Objective C development tools, and we intend for it to be; production quality.; Being a production quality compiler means many things: it means being high; performance, being solid and (relatively) bug free, and it means eventually; being used and depended on by a broad range of people. While we are still in; the early development stages, we strongly believe that this will become a; reality. A simple and hackable code base. Our goal is to make it possible for anyone with a basic understanding; of compilers and working knowledge of the C/C++/ObjC languages to understand and; extend the clang source base. A large part of this falls out of our decision to; make the AST mirror the languages as closely as possible: you have your friendly; if statement, for statement, parenthesis expression, structs, unions, etc, all; represented in a simple and explicit way.; In addition to a simple design, we work to make the source base approachable; by commenting it well, including citations of the language standards where; appropriate, and designing the code for simplicity. Beyond that, clang offers; a set of AST dumpers, printers, and visualizers that make it easy to put code in; and see how it is represented. A single unified parser for C, Objective C, C++,; and Objective C++. Clang is the ""C Language Family Front-end"", which means we intend to support; the most popular members of the C family. We are co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:11937,simpl,simple,11937,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['simpl'],['simple']
Usability," these interfaces appropriately. The ``deleteValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``deleteValue`` method is called by transformations when they remove an; instruction or any other value from the program (including values that do not; use pointers). Typically alias analyses keep data structures that have entries; for each value in the program. When this method is called, they should remove; any entries for the specified value, if they exist. The ``copyValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^. The ``copyValue`` method is used when a new value is introduced into the; program. There is no way to introduce a value into the program that did not; exist before (this doesn't make sense for a safe compiler transformation), so; this is the only way to introduce a new value. This method indicates that the; new value has exactly the same properties as the value being copied. The ``replaceWithNewValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This method is a simple helper method that is provided to make clients easier to; use. It is implemented by copying the old analysis information to the new; value, then deleting the old value. This method cannot be overridden by alias; analysis implementations. The ``addEscapingUse`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``addEscapingUse`` method is used when the uses of a pointer value have; changed in ways that may invalidate precomputed analysis information.; Implementations may either use this callback to provide conservative responses; for points whose uses have change since analysis time, or may recompute some or; all of their internal state to continue providing accurate responses. In general, any new use of a pointer value is considered an escaping use, and; must be reported through this callback, *except* for the uses below:. * A ``bitcast`` or ``getelementptr`` of the pointer; * A ``store`` through the pointer (but not a ``store`` *of* the pointer); * A ``load`` through the pointer. Efficiency Issues; -----------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:15440,simpl,simple,15440,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['simpl'],['simple']
Usability," they could call:. ``` {.cpp}; TThread::SetCancelAsynchronous();; TThread::SetCancelOn();; // Now cancelation in any point is allowed.; ...; // Return to default; TThread::SetCancelOff();; TThread::SetCancelDeferred();; ```. To cancel a thread `TThread* th` call:. ``` {.cpp}; th->Kill();; ```. To cancel by thread name:. ``` {.cpp}; TThread::Kill(name);; ```. To cancel a thread by ID:. ``` {.cpp}; TThread::Kill(tid);; ```. To cancel a thread and delete `th` when cancel finished:. ``` {.cpp}; th->Delete();; ```. Deleting of the thread instance by the operator delete is dangerous. Use; `th->Delete()` instead. C++ delete is safe only if thread is not; running. Often during the canceling, some clean up actions must be; taken. To define clean up functions use:. ``` {.cpp}; void UserCleanUp(void *arg) {; // here the user cleanup is done; ...; }; TThread::CleanUpPush(&UserCleanUp,arg);; // push user function into cleanup stack""last in, first out""; TThread::CleanUpPop(1); // pop user function out of stack and; // execute it, thread resumes after this call; TThread::CleanUpPop(0); // pop user function out of stack; // _without_ executing it; ```. Note: `CleanUpPush` and `CleanUpPop` should be used as corresponding; pairs like brackets; unlike `pthreads` cleanup stack (which is *not*; implemented here), **`TThread`** does not force this usage. #### Finishing thread. When a thread returns from a user function the thread is finished. It; also can be finished by `TThread::Exit()`. Then, in case of; `thread`-detached mode, the thread vanishes completely. By default, on; finishing **`TThread`** executes the most recent cleanup function; (`CleanUpPop(1)` is called automatically once). ## Advanced TThread: Launching a Method in a Thread. Consider a class `Myclass` with a member function that shall be launched; as a thread. ``` {.cpp}; void* Myclass::Thread0((void* arg); ```. To start Thread0 as a **`TThread`**, class `Myclass` may provide a; method:. ``` {.cpp}; Int_t Myclass::Thread",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:12982,resume,resumes,12982,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['resume'],['resumes']
Usability," this scaffolding, we can now talk about parsing expressions and; function bodies in Kaleidoscope. Parser Basics; =============. Now that we have an AST to build, we need to define the parser code to; build it. The idea here is that we want to parse something like ""x+y""; (which is returned as three tokens by the lexer) into an AST that could; be generated with calls like this:. .. code-block:: c++. auto LHS = std::make_unique<VariableExprAST>(""x"");; auto RHS = std::make_unique<VariableExprAST>(""y"");; auto Result = std::make_unique<BinaryExprAST>('+', std::move(LHS),; std::move(RHS));. In order to do this, we'll start by defining some basic helper routines:. .. code-block:: c++. /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.; static int CurTok;; static int getNextToken() {; return CurTok = gettok();; }. This implements a simple token buffer around the lexer. This allows us; to look one token ahead at what the lexer is returning. Every function; in our parser will assume that CurTok is the current token that needs to; be parsed. .. code-block:: c++. /// LogError* - These are little helper functions for error handling.; std::unique_ptr<ExprAST> LogError(const char *Str) {; fprintf(stderr, ""Error: %s\n"", Str);; return nullptr;; }; std::unique_ptr<PrototypeAST> LogErrorP(const char *Str) {; LogError(Str);; return nullptr;; }. The ``LogError`` routines are simple helper routines that our parser will; use to handle errors. The error recovery in our parser will not be the; best and is not particular user-friendly, but it will be enough for our; tutorial. These routines make it easier to handle errors in routines; that have various return types: they always return null. With these basic helper functions, we can implement the first piece of; our grammar: numeric literals. Basic Expression Parsing; ======================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:6105,simpl,simple,6105,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['simpl'],['simple']
Usability," thread_local dynamic initialization; Not resolved. 2685; C++23; Aggregate CTAD, string, and brace elision; Unknown. 2686; open; Pack expansion into a non-pack parameter of a concept; Not resolved. 2687; C++23; Calling an explicit object member function via an address-of-overload-set; Clang 18. 2688; open; Calling explicit object member functions; Not resolved. 2689; tentatively ready; Are cv-qualified std::nullptr_t fundamental types?; Unknown. 2690; C++23; Semantics of defaulted move assignment operator for unions; Unknown. 2691; C++23; hexadecimal-escape-sequence is too greedy; Unknown. 2692; C++23; Static and explicit object member functions with the same parameter-type-lists; Unknown. 2693; open; Escape sequences for the string-literal of #line; Not resolved. 2694; open; string-literals of the _Pragma operator; Not resolved. 2695; C++23; Semantic ignorability of attributes; Unknown. 2696; dup; Relational comparisons of pointers to void; Unknown. 2697; DRWP; Deduction guides using abbreviated function syntax; Unknown. 2698; DRWP; Using extended integer types with z suffix; Unknown. 2699; DRWP; Inconsistency of throw-expression specification; Unknown. 2700; review; #error disallows existing implementation practice; Not resolved. 2701; open; Default arguments in multiple scopes / inheritance of array bounds in the same scope; Not resolved. 2702; open; Constant destruction of reference members; Not resolved. 2703; review; Three-way comparison requiring strong ordering for floating-point types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:186239,guid,guides,186239,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['guid'],['guides']
Usability," through memory. __m128i_shift_right:; 	.byte	 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15; 	.byte	 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1. ...; __m128i shift_right(__m128i value, unsigned long offset) {; return _mm_shuffle_epi8(value,; _mm_loadu_si128((__m128 *) (___m128i_shift_right + offset)));; }. //===---------------------------------------------------------------------===//. SSE has instructions for doing operations on complex numbers, we should pattern; match them. For example, this should turn into a horizontal add:. typedef float __attribute__((vector_size(16))) v4f32;; float f32(v4f32 A) {; return A[0]+A[1]+A[2]+A[3];; }. Instead we get this:. _f32: ## @f32; 	pshufd	$1, %xmm0, %xmm1 ## xmm1 = xmm0[1,0,0,0]; 	addss	%xmm0, %xmm1; 	pshufd	$3, %xmm0, %xmm2 ## xmm2 = xmm0[3,0,0,0]; 	movhlps	%xmm0, %xmm0 ## xmm0 = xmm0[1,1]; 	movaps	%xmm0, %xmm3; 	addss	%xmm1, %xmm3; 	movdqa	%xmm2, %xmm0; 	addss	%xmm3, %xmm0; 	ret. Also, there are cases where some simple local SLP would improve codegen a bit.; compiling this:. _Complex float f32(_Complex float A, _Complex float B) {; return A+B;; }. into:. _f32: ## @f32; 	movdqa	%xmm0, %xmm2; 	addss	%xmm1, %xmm2; 	pshufd	$1, %xmm1, %xmm1 ## xmm1 = xmm1[1,0,0,0]; 	pshufd	$1, %xmm0, %xmm3 ## xmm3 = xmm0[1,0,0,0]; 	addss	%xmm1, %xmm3; 	movaps	%xmm2, %xmm0; 	unpcklps	%xmm3, %xmm0 ## xmm0 = xmm0[0],xmm3[0],xmm0[1],xmm3[1]; 	ret. seems silly when it could just be one addps. //===---------------------------------------------------------------------===//. Expand libm rounding functions inline: Significant speedups possible.; http://gcc.gnu.org/ml/gcc-patches/2006-10/msg00909.html. //===---------------------------------------------------------------------===//. When compiled with unsafemath enabled, ""main"" should enable SSE DAZ mode and; other fast SSE modes. //===---------------------------------------------------------------------===//. Think about doing i64 math in SSE regs on x86-32. //===-----------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt:1430,simpl,simple,1430,interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,1,['simpl'],['simple']
Usability," to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other suitable container type;; or; allocate the array on the heap instead using new Type[] -; just remember to delete[] it. Unqualified lookup in templates. Some versions of GCC accept the following invalid code:. template <typename T> T Squared(T x) {; return Multiply(x, x);; }. int Multiply(int x, int y) {; return x * y;; }. int main() {; Squared(5);; }. Clang complains:. my_file.cpp:2:10: error: call to function 'Multiply' that is neither visible in the template definition nor found by argument-dependent lookup; return Multiply(x, x);; ^; my_file.cpp:10:3: note: in instantiation of function template specialization 'Squared<int>' requested here; Squared(5);; ^; my_file.cpp:5:5: note: 'Multiply' should be declared prior to the call site; int Multiply(int x, int y) {; ^. The C++ standard says tha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:11481,simpl,simple,11481,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['simpl'],['simple']
Usability," to be able to ""dlopen"" and ""dlclose"" JITDylibs, running all of; their initializers/deinitializers on the current thread. This would require; support from the runtime library described above. 3. **Debugging support**. ORC currently supports the GDBRegistrationListener API when using RuntimeDyld; as the underlying JIT linker. We will need a new solution for JITLink based; platforms. Further Future Work; -------------------. 1. **Speculative Compilation**. ORC's support for concurrent compilation allows us to easily enable; *speculative* JIT compilation: compilation of code that is not needed yet,; but which we have reason to believe will be needed in the future. This can be; used to hide compile latency and improve JIT throughput. A proof-of-concept; example of speculative compilation with ORC has already been developed (see; ``llvm/examples/SpeculativeJIT``). Future work on this is likely to focus on; re-using and improving existing profiling support (currently used by PGO) to; feed speculation decisions, as well as built-in tools to simplify use of; speculative compilation. .. [1] Formats/architectures vary in terms of supported features. MachO and; ELF tend to have better support than COFF. Patches very welcome!. .. [2] The ``LazyEmittingLayer``, ``RemoteObjectClientLayer`` and; ``RemoteObjectServerLayer`` do not have counterparts in the new; system. In the case of ``LazyEmittingLayer`` it was simply no longer; needed: in ORCv2, deferring compilation until symbols are looked up is; the default. The removal of ``RemoteObjectClientLayer`` and; ``RemoteObjectServerLayer`` means that JIT stacks can no longer be split; across processes, however this functionality appears not to have been; used. .. [3] Weak definitions are currently handled correctly within dylibs, but if; multiple dylibs provide a weak definition of a symbol then each will end; up with its own definition (similar to how weak definitions are handled; in Windows DLLs). This will be fixed in the future.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:37985,simpl,simply,37985,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['simpl'],['simply']
Usability," to completion by returning; a null continuation pointer. Any yielded values will be `undef`; should be ignored. - In yield-once returned-continuation lowering, the coroutine must; suspend itself exactly once (or throw an exception). The ramp; function returns a continuation function pointer and yielded; values, the continuation function may optionally return ordinary; results when the coroutine has run to completion. The coroutine frame is maintained in a fixed-size buffer that is; passed to the `coro.id` intrinsic, which guarantees a certain size; and alignment statically. The same buffer must be passed to the; continuation function(s). The coroutine will allocate memory if the; buffer is insufficient, in which case it will need to store at; least that pointer in the buffer; therefore the buffer must always; be at least pointer-sized. How the coroutine uses the buffer may; vary between suspend points. In addition to the buffer pointer, continuation functions take an; argument indicating whether the coroutine is being resumed normally; (zero) or abnormally (non-zero). LLVM is currently ineffective at statically eliminating allocations; after fully inlining returned-continuation coroutines into a caller.; This may be acceptable if LLVM's coroutine support is primarily being; used for low-level lowering and inlining is expected to be applied; earlier in the pipeline. Async Lowering; --------------. In async-continuation lowering, signaled by the use of `llvm.coro.id.async`,; handling of control-flow must be handled explicitly by the frontend. In this lowering, a coroutine is assumed to take the current `async context` as; one of its arguments (the argument position is determined by; `llvm.coro.id.async`). It is used to marshal arguments and return values of the; coroutine. Therefore an async coroutine returns `void`. .. code-block:: llvm. define swiftcc void @async_coroutine(ptr %async.ctxt, ptr, ptr) {; }. Values live across a suspend point need to be stored in the c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:7294,resume,resumed,7294,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resumed']
Usability," to respond to free-form comments in mail sent to the commits list. Sign up; -------. To get started with Phabricator, navigate to `https://reviews.llvm.org`_ and; click the power icon in the top right. You can register with a GitHub account,; a Google account, or you can create your own profile. Make *sure* that the email address registered with Phabricator is subscribed; to the relevant -commits mailing list. If you are not subscribed to the commit; list, all mail sent by Phabricator on your behalf will be held for moderation. Note that if you use your git user name as Phabricator user name,; Phabricator will automatically connect your submits to your Phabricator user in; the `Code Repository Browser`_. Requesting a review via the command line; ----------------------------------------. Phabricator has a tool called *Arcanist* to upload patches from; the command line. To get you set up, follow the; `Arcanist Quick Start`_ instructions. You can learn more about how to use arc to interact with; Phabricator in the `Arcanist User Guide`_.; The basic way of creating a revision for the current commit in your local; repository is to run:. ::. arc diff HEAD~. Sometime you may want to create a draft revision to show the proof of concept; or for experimental purposes, In that case you can use the `--draft` option. It; will create a new draft revision. The good part is: it will not send mail to; llvm-commit mailing list, patch reviewers, and all other subscribers, buildbot; will also run on every patch update:. ::. arc diff --draft HEAD~. If you later update your commit message, you need to add the `--verbatim`; option to have `arc` update the description on Phabricator:. ::. arc diff --edit --verbatim. .. _phabricator-request-review-web:. Requesting a review via the web interface; -----------------------------------------. The tool to create and review patches in Phabricator is called; *Differential*. Note that you can upload patches created through git, but using `arc` on th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:1661,learn,learn,1661,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['learn'],['learn']
Usability," to save a canvas into `file.xml` file; format instead of `file.root`. XML files do not have any advantages; compared to the normal ROOT files, except that the information in these; files can be edited via a normal editor. The main motivation for this; new format is to facilitate the communication with other non ROOT; applications. Currently writing and reading XML files is limited to ROOT; applications. It is our intention to develop a simple reader independent; of the ROOT libraries that could be used as an example for real; applications. The XML format should be used only for small data volumes, typically; histogram files, pictures, geometries, calibrations. The XML file is; built in memory before being dumped to disk. Like for normal ROOT files,; XML files use the same I/O mechanism exploiting the ROOT/Cling; dictionary. Any class having a dictionary can be saved in XML format.; This first implementation does not support subdirectories or trees. The shared library `libRXML.so` may be loaded dynamically via; `gSystem->Load(""libRXML"")`. This library is also automatically loaded by; the plug-in manager as soon a XML file is created. To create an XTM; file, simply specify a filename with an .xml extension when calling; **`TFile`**`::Open`. **`TFile`**`::Open` will recognize that you are trying to; open an XML file and return a **`TXMLFile`** object. When a XML file is; open in write mode, one can use the normal `TObject::Write` to write an; object in the file. ``` {.cpp}; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2); h->FillRandom(""gaus"");; h->Write();; delete f;; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();; ```. The canvas can be saved as a XML file format via File menu / Save or; Save As menu entries. One can do also:. ``` {.cpp}; canvas->Print(""Example.xml"");; ```; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:98267,simpl,simply,98267,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simply']
Usability," to the Clang C++ code paths and; share as much functionality as possible. Architectural Direction; =======================. HLSL support in Clang is expressed as C++ minus unsupported C and C++ features.; This is different from how other Clang languages are implemented. Most languages; in Clang are additive on top of C. HLSL is not a formally or fully specified language, and while our goals require; a high level of source compatibility, implementations can vary and we have some; flexibility to be more or less permissive in some cases. For modern HLSL DXC is; the reference implementation. The HLSL effort prioritizes following similar patterns for other languages,; drivers, runtimes and targets. Specifically, We will maintain separation between; HSLS-specific code and the rest of Clang as much as possible following patterns; in use in Clang code today (i.e. ParseHLSL.cpp, SemaHLSL.cpp, CGHLSL*.cpp...).; We will use inline checks on language options where the code is simple and; isolated, and prefer HLSL-specific implementation files for any code of; reasonable complexity. In places where the HLSL language is in conflict with C and C++, we will seek to; make minimally invasive changes guarded under the HLSL language options. We will; seek to make HLSL language support as minimal a maintenance burden as possible. DXC Driver; ----------. A DXC driver mode will provide command-line compatibility with DXC, supporting; DXC's options and flags. The DXC driver is HLSL-specific and will create an; HLSLToolchain which will provide the basis to support targeting both DirectX and; Vulkan. Parser; ------. Following the examples of other parser extensions HLSL will add a ParseHLSL.cpp; file to contain the implementations of HLSL-specific extensions to the Clang; parser. The HLSL grammar shares most of its structure with C and C++, so we will; use the existing C/C++ parsing code paths. Sema; ----. HLSL's Sema implementation will also provide an ``ExternalSemaSource``. In DXC,; an ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:2374,simpl,simple,2374,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,1,['simpl'],['simple']
Usability," to the source-based kind. The code coverage workflow; ==========================. The code coverage workflow consists of three main steps:. * Compiling with coverage enabled. * Running the instrumented program. * Creating coverage reports. The next few sections work through a complete, copy-'n-paste friendly example; based on this program:. .. code-block:: cpp. % cat <<EOF > foo.cc; #define BAR(x) ((x) || (x)); template <typename T> void foo(T x) {; for (unsigned I = 0; I < 10; ++I) { BAR(I); }; }; int main() {; foo<int>(0);; foo<float>(0);; return 0;; }; EOF. Compiling with coverage enabled; ===============================. To compile code with coverage enabled, pass ``-fprofile-instr-generate; -fcoverage-mapping`` to the compiler:. .. code-block:: console. # Step 1: Compile with coverage enabled.; % clang++ -fprofile-instr-generate -fcoverage-mapping foo.cc -o foo. Note that linking together code with and without coverage instrumentation is; supported. Uninstrumented code simply won't be accounted for in reports. To compile code with Modified Condition/Decision Coverage (MC/DC) enabled,; pass ``-fcoverage-mcdc`` in addition to the clang options specified above.; MC/DC is an advanced form of code coverage most applicable in the embedded; space. Running the instrumented program; ================================. The next step is to run the instrumented program. When the program exits it; will write a **raw profile** to the path specified by the ``LLVM_PROFILE_FILE``; environment variable. If that variable does not exist, the profile is written; to ``default.profraw`` in the current directory of the program. If; ``LLVM_PROFILE_FILE`` contains a path to a non-existent directory, the missing; directory structure will be created. Additionally, the following special; **pattern strings** are rewritten:. * ""%p"" expands out to the process ID. * ""%h"" expands out to the hostname of the machine running the program. * ""%t"" expands out to the value of the ``TMPDIR`` environment",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:1736,simpl,simply,1736,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,1,['simpl'],['simply']
Usability," to use; in an :ref:`icmp <i_icmp>` instruction. Target extension types have a name and optional type or integer parameters. The; meanings of name and parameters are defined by the target. When being defined in; LLVM IR, all of the type parameters must precede all of the integer parameters. Specific target extension types are registered with LLVM as having specific; properties. These properties can be used to restrict the type from appearing in; certain contexts, such as being the type of a global variable or having a; ``zeroinitializer`` constant be valid. A complete list of type properties may be; found in the documentation for ``llvm::TargetExtType::Property`` (`doxygen; <https://llvm.org/doxygen/classllvm_1_1TargetExtType.html>`_). :Syntax:. .. code-block:: llvm. target(""label""); target(""label"", void); target(""label"", void, i32); target(""label"", 0, 1, 2); target(""label"", void, i32, 0, 1, 2). .. _t_vector:. Vector Type; """""""""""""""""""""". :Overview:. A vector type is a simple derived type that represents a vector of; elements. Vector types are used when multiple primitive data are; operated in parallel using a single instruction (SIMD). A vector type; requires a size (number of elements), an underlying primitive data type,; and a scalable property to represent vectors where the exact hardware; vector length is unknown at compile time. Vector types are considered; :ref:`first class <t_firstclass>`. :Memory Layout:. In general vector elements are laid out in memory in the same way as; :ref:`array types <t_array>`. Such an analogy works fine as long as the vector; elements are byte sized. However, when the elements of the vector aren't byte; sized it gets a bit more complicated. One way to describe the layout is by; describing what happens when a vector such as <N x iM> is bitcasted to an; integer type with N*M bits, and then following the rules for storing such an; integer to memory. A bitcast from a vector type to a scalar integer type will see the elements; being packe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:174332,simpl,simple,174332,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability," type character.; - All functionalities of the other datatypes have been reimplemented.; - The documentation of `TTree` and `TBuffer` has been updated accordingly.; - The following example shows how to use the new features:; ~~~ {.cpp}; Float16_t floatVal;; Float16_t floatArray[7];; Double32_t doubleVal;; Double32_t doubleArray[5];; TTree *tree = new TTree(""tree"", ""An example tree using the new data types"");; tree->Branch(""floatVal"", &floatVal, ""floatVal/f""); // Float16_t value with default settings; tree->Branch(""floatArray"", floatArray, ""floatArray[7]/f[0,100]""); // Float16_t array with range from 0 to 100; tree->Branch(""doubleVal"", &doubleVal, ""doubleVal/d[0,1000,20]""); // Double32_t value with range from 0 to 1000 and 20 bits; tree->Branch(""doubleArray"", doubleArray, ""doubleArray[5]/d[0,0,18]""); // Double32_t array without range and 18 bits; ~~~. ### Bulk I/O; - The new `TBulkBranchRead` class (inside the `ROOT::Experimental::Internal` namespace) provides; a mechanism for reading, in a single library call, many events' worth of simple data (primitive types,; arrays of primitives, split structures) stored in a `TTree`. This allows for extremely fast delivery; of event data to the process. This is meant as an internal interface that allows the ROOT team to; implement faster high-level interface.; - The `TTreeReaderFast ` class (inside the `ROOT::Experimental::Internal` namespace) provides a simple; mechanism for reading ntuples with the bulk IO interface. ## Histogram Libraries. ### TH1; - Add a search range to the `TH1::FindFirstBinAbove(..)` and `TH1::FindLastBinAvove(..)` functions. ### TH2Poly; - Add implementation of `SetBinError` and fix a bug in `GetBinError` in case of weighted events. ### TF1; - The implementation of `TF1::GetX` has been improved. In case of the presence of multiple roots, the function will return the root with the lower x value. In case of no-roots a NaN will be returned instead of returning a random incorrect value. ### TKDE; - Add suppo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:11013,simpl,simple,11013,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['simpl'],['simple']
Usability," us; to look one token ahead at what the lexer is returning. Every function; in our parser will assume that CurTok is the current token that needs to; be parsed. .. code-block:: c++. /// LogError* - These are little helper functions for error handling.; std::unique_ptr<ExprAST> LogError(const char *Str) {; fprintf(stderr, ""Error: %s\n"", Str);; return nullptr;; }; std::unique_ptr<PrototypeAST> LogErrorP(const char *Str) {; LogError(Str);; return nullptr;; }. The ``LogError`` routines are simple helper routines that our parser will; use to handle errors. The error recovery in our parser will not be the; best and is not particular user-friendly, but it will be enough for our; tutorial. These routines make it easier to handle errors in routines; that have various return types: they always return null. With these basic helper functions, we can implement the first piece of; our grammar: numeric literals. Basic Expression Parsing; ========================. We start with numeric literals, because they are the simplest to; process. For each production in our grammar, we'll define a function; which parses that production. For numeric literals, we have:. .. code-block:: c++. /// numberexpr ::= number; static std::unique_ptr<ExprAST> ParseNumberExpr() {; auto Result = std::make_unique<NumberExprAST>(NumVal);; getNextToken(); // consume the number; return std::move(Result);; }. This routine is very simple: it expects to be called when the current; token is a ``tok_number`` token. It takes the current number value,; creates a ``NumberExprAST`` node, advances the lexer to the next token,; and finally returns. There are some interesting aspects to this. The most important one is; that this routine eats all of the tokens that correspond to the; production and returns the lexer buffer with the next token (which is; not part of the grammar production) ready to go. This is a fairly; standard way to go for recursive descent parsers. For a better example,; the parenthesis operator is defi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:7171,simpl,simplest,7171,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['simpl'],['simplest']
Usability," used by tools such as debuggers and profilers. It uses features defined in; :doc:`AMDGPUDwarfExtensionsForHeterogeneousDebugging` that are made available in; DWARF Version 4 and DWARF Version 5 as an LLVM vendor extension. This section defines the AMDGPU target architecture specific DWARF mappings. .. _amdgpu-dwarf-register-identifier:. Register Identifier; -------------------. This section defines the AMDGPU target architecture register numbers used in; DWARF operation expressions (see DWARF Version 5 section 2.5 and; :ref:`amdgpu-dwarf-operation-expressions`) and Call Frame Information; instructions (see DWARF Version 5 section 6.4 and; :ref:`amdgpu-dwarf-call-frame-information`). A single code object can contain code for kernels that have different wavefront; sizes. The vector registers and some scalar registers are based on the wavefront; size. AMDGPU defines distinct DWARF registers for each wavefront size. This; simplifies the consumer of the DWARF so that each register has a fixed size,; rather than being dynamic according to the wavefront size mode. Similarly,; distinct DWARF registers are defined for those registers that vary in size; according to the process address size. This allows a consumer to treat a; specific AMDGPU processor as a single architecture regardless of how it is; configured at run time. The compiler explicitly specifies the DWARF registers; that match the mode in which the code it is generating will be executed. DWARF registers are encoded as numbers, which are mapped to architecture; registers. The mapping for AMDGPU is defined in; :ref:`amdgpu-dwarf-register-mapping-table`. All AMDGPU targets use the same; mapping. .. table:: AMDGPU DWARF Register Mapping; :name: amdgpu-dwarf-register-mapping-table. ============== ================= ======== ==================================; DWARF Register AMDGPU Register Bit Size Description; ============== ================= ======== ==================================; 0 PC_32 32 Program Counter (PC)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:86136,simpl,simplifies,86136,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['simpl'],['simplifies']
Usability," uses *acc* and; *var* to calculate the accumulated value, which ``!foldl`` stores back in; *acc*. The type of *acc* is the same as *init*; the type of *var* is the; same as the elements of *list*; *expr* must have the same type as *init*. The following example computes the total of the ``Number`` field in the; list of records in ``RecList``::. int x = !foldl(0, RecList, total, rec, !add(total, rec.Number));. If your goal is to filter the list and produce a new list that includes only; some of the elements, see ``!filter``. ``!foreach(``\ *var*\ ``,`` *sequence*\ ``,`` *expr*\ ``)``; This operator creates a new ``list``/``dag`` in which each element is a; function of the corresponding element in the *sequence* ``list``/``dag``.; To perform the function, TableGen binds the variable *var* to an element; and then evaluates the expression. The expression presumably refers; to the variable *var* and calculates the result value. If you simply want to create a list of a certain length containing; the same value repeated multiple times, see ``!listsplat``. ``!ge(``\ *a*\ `,` *b*\ ``)``; This operator produces 1 if *a* is greater than or equal to *b*; 0 otherwise.; The arguments must be ``bit``, ``bits``, ``int``, or ``string`` values. ``!getdagarg<``\ *type*\ ``>(``\ *dag*\ ``,``\ *key*\ ``)``; This operator retrieves the argument from the given *dag* node by the; specified *key*, which is either an integer index or a string name. If that; argument is not convertible to the specified *type*, ``?`` is returned. ``!getdagname(``\ *dag*\ ``,``\ *index*\ ``)``; This operator retrieves the argument name from the given *dag* node by the; specified *index*. If that argument has no name associated, ``?`` is; returned. ``!getdagop(``\ *dag*\ ``)`` --or-- ``!getdagop<``\ *type*\ ``>(``\ *dag*\ ``)``; This operator produces the operator of the given *dag* node.; Example: ``!getdagop((foo 1, 2))`` results in ``foo``. Recall that; DAG operators are always records. The result of ``!getda",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:65119,simpl,simply,65119,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simply']
Usability," using a PHI node:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global i32 0 ; type of @H is i32*. define i32 @test(i1 %Condition) {; entry:; %X = alloca i32 ; type of %X is i32*.; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; store i32 %X.0, i32* %X ; Update X; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; store i32 %X.1, i32* %X ; Update X; br label %cond_next. cond_next:; %X.2 = load i32, i32* %X ; Read X; ret i32 %X.2; }. With this, we have discovered a way to handle arbitrary mutable; variables without the need to create Phi nodes at all:. #. Each mutable variable becomes a stack allocation.; #. Each read of the variable becomes a load from the stack.; #. Each update of the variable becomes a store to the stack.; #. Taking the address of a variable just uses the stack address; directly. While this solution has solved our immediate problem, it introduced; another one: we have now apparently introduced a lot of stack traffic; for very simple and common operations, a major performance problem.; Fortunately for us, the LLVM optimizer has a highly-tuned optimization; pass named ""mem2reg"" that handles this case, promoting allocas like this; into SSA registers, inserting Phi nodes as appropriate. If you run this; example through the pass, for example, you'll get:. .. code-block:: bash. $ llvm-as < example.ll | opt -passes=mem2reg | llvm-dis; @G = weak global i32 0; @H = weak global i32 0. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; br label %cond_next. cond_next:; %X.01 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]; ret i32 %X.01; }. The mem2reg pass implements the standard ""iterated dominance frontier""; algorithm for constructing SSA form and has a number of optimizations; that speed up (very common) degenerate cases.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:6601,simpl,simple,6601,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['simpl'],['simple']
Usability," var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-generate; Generate instrumented code to collect execution counts into default.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-use=<value>; Use instrumentation data for coverage testing or profile-guided optimization; -fprofile-use=<value>; Use instrumentation data for profile-guided optimization; -fprofile-remapping-file=<file>; Use the remappings described in <file> to match the profile data against names in the program; -fprofile-list=<file>; Filename defining the list of functions/files to instrument; -fsanitize-address-field-padding=<value>; Level of field padding for AddressSanitizer; -fsanitize-address-globals-dead-stripping; Enable linker dead stripping of globals in AddressSanitizer; -fsanitize-address-poison-custom-array-cookie; Enable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, defaul",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:182576,guid,guided,182576,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,2,['guid'],['guided']
Usability," viewer requires two publication passes - one to establish; the full tessellation capacity for all shapes, and another to; actually add them. Splitting avoids having to do the expensive; tessellation on the first pass. #### Shape Specific TBuffer3D Derived Classes. Currently we provide the following shape specific classes, which the GL; Viewer can take advantage of (see `TBuffer3D.h` and `TBuffer3DTypes.h`). - **`TBuffer3DSphere`** - solid, hollow and cut spheres (GL Viewer; only supports solid spheres at present - cut / hollow ones will be; requested as tessellated objects by client.). - **`TBuffer3DTube`** - basic tube with inner/outer radius and length. - **`TBuffer3DTubeSeg`** - angle tube segment. - **`TBuffer3DCutTube`** - angle tube segment with plane cut ends. See the above example from `TGeoSphere::GetBuffer3D` and also equivalent; functions in **`TGeoTube`**, **`TGeoTubeSeg`** and **`TGeoCtub`**.; Anyone is free to add new **`TBuffer3D`** classes, but it should be; clear that one or more viewers will require updating to be able to take; advantage of them. Hence we only provide classes which existing viewers; can benefit from. The number of native shapes in GL Viewer will be; expanded in the future. #### Master / Local Reference Frames. The Core section of **`TBuffer3D`** contains two members relating to; reference frames:. - `fLocalFrame`: indicates if any positions in the buffer (bounding; box and tessellation vertexes) are in local or master (world frame). - `fLocalMaster`: is a standard 4x4 translation matrix (OpenGL column; major ordering) for placing the object into the 3D master frame. If `fLocalFrame` is false, `fLocalMaster` should contain an identity; matrix. This is set by default, and can be reset using the; **`TBuffer3D::SetLocalMasterIdentity()` method.**. #### Bounding Boxes. You are not obliged to complete the `kBoundingBox` section, as any; viewer requiring one internally (GL Viewer) will build it if you do not; provide. However to do this ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:132276,clear,clear,132276,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['clear'],['clear']
Usability," what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. \anchor GP00a; ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does ""make map"" in root folder. ~~~{.cpp}; root[] gSystem->Load(""libGeom"");; ~~~. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; `gGeoManager`:. ~~~{.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ~~~. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ~~~{.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ~~~. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ~~~{.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ~~~. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the geometry. ~~~{.cpp}; root[] gGeoManager->SetTopVolume(top);; ~~~. This should be enough, b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:5460,simpl,simplest,5460,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simplest']
Usability," when coroutine state is prepared for suspension. If `none` token is passed,; the intrinsic behaves as if there were a `coro.save` immediately preceding; the `coro.suspend` intrinsic. The second argument indicates whether this suspension point is `final`_.; The second argument only accepts constants. If more than one suspend point is; designated as final, the resume and destroy branches should lead to the same; basic blocks. Example (normal suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. %0 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %0, label %suspend [i8 0, label %resume; i8 1, label %cleanup]. Example (final suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. while.end:; %s.final = call i8 @llvm.coro.suspend(token none, i1 true); switch i8 %s.final, label %suspend [i8 0, label %trap; i8 1, label %cleanup]; trap:; call void @llvm.trap(); unreachable. Semantics:; """""""""""""""""""". If a coroutine that was suspended at the suspend point marked by this intrinsic; is resumed via `coro.resume`_ the control will transfer to the basic block; of the 0-case. If it is resumed via `coro.destroy`_, it will proceed to the; basic block indicated by the 1-case. To suspend, coroutine proceed to the; default label. If suspend intrinsic is marked as final, it can consider the `true` branch; unreachable and can perform optimizations that can take advantage of that fact. .. _coro.save:. 'llvm.coro.save' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare token @llvm.coro.save(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.save``' marks the point where a coroutine need to update its; state to prepare for resumption to be considered suspended (and thus eligible; for resumption). It is illegal to merge two '``llvm.coro.save``' calls unless their; '``llvm.coro.suspend``' users are also merged. So '``llvm.coro.save``' is currently; tagged with the `no_merge` function attribute. Arguments:; """""""""""""""""""". The first argume",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:51247,resume,resumed,51247,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resumed']
Usability," whole new generation of; C/C++/Objective C development tools, and we intend for it to be; production quality.; Being a production quality compiler means many things: it means being high; performance, being solid and (relatively) bug free, and it means eventually; being used and depended on by a broad range of people. While we are still in; the early development stages, we strongly believe that this will become a; reality. A simple and hackable code base. Our goal is to make it possible for anyone with a basic understanding; of compilers and working knowledge of the C/C++/ObjC languages to understand and; extend the clang source base. A large part of this falls out of our decision to; make the AST mirror the languages as closely as possible: you have your friendly; if statement, for statement, parenthesis expression, structs, unions, etc, all; represented in a simple and explicit way.; In addition to a simple design, we work to make the source base approachable; by commenting it well, including citations of the language standards where; appropriate, and designing the code for simplicity. Beyond that, clang offers; a set of AST dumpers, printers, and visualizers that make it easy to put code in; and see how it is represented. A single unified parser for C, Objective C, C++,; and Objective C++. Clang is the ""C Language Family Front-end"", which means we intend to support; the most popular members of the C family. We are convinced that the right; parsing technology for this class of languages is a hand-built recursive-descent; parser. Because it is plain C++ code, recursive descent makes it very easy for; new developers to understand the code, it easily supports ad-hoc rules and other; strange hacks required by C/C++, and makes it straight-forward to implement; excellent diagnostics and error recovery.; We believe that implementing C/C++/ObjC in a single unified parser makes the; end result easier to maintain and evolve than maintaining a separate C and C++; parser which",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:12424,simpl,simple,12424,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,2,['simpl'],"['simple', 'simplicity']"
Usability," will be called CRISP, an acronym for *Coding Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreoffice.org/gitweb?p=core.git;a=blob_plain;f=compilerplugins/README;hb=HEAD>`_; ""LibreOffice uses a Clang plugin infrastructure to check during the build; various things, some more, some less specific to the LibreOffice source code.; There are currently around 50 such checkers, from flagging C-style casts and; uses of reserved identifiers to ensuring that code adheres to lifecycle; protocols for certain LibreOffice-specific classes. They may serve as; examples for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:3287,simpl,simplest,3287,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,1,['simpl'],['simplest']
Usability," with the gaussian pre-defined function; histo->Fit(""gaus"");; ```. In the following we will give some brief description of the minimization packages.; The packages all implement the `ROOT::Math::Minimizer` interface which can be use for; finding the minimum of a multi-dimensional function.; The interface is documented in the Mathematical Library Chapter. In addition packages like Minuit or Minuit2 provide their own interfaces. ## MINUIT (Old TMInuit Version). This package was originally written in FORTRAN by Fred James and part; of `PACKLIB` (patch D506). It has been converted to a C++ class by; René Brun. The current implementation in C++ is a straightforward; conversion of the original FORTRAN version. The main changes are:. - The variables in the various `Minuit` labeled common blocks have; been changed to the **`TMinuit`** class data members. - The internal arrays with a maximum dimension depending on the; maximum number of parameters are now data members' arrays with a; dynamic dimension such that one can fit very large problems by; simply initializing the **`TMinuit`** constructor with the maximum; number of parameters. - The include file `Minuit.h` has been commented as much as possible; using existing comments in the code or the printed documentation. - The original `Minuit` subroutines are now member functions. - Constructors and destructor have been added. - Instead of passing the `FCN` function in the argument list, the; addresses of this function is stored as pointer in the data; members of the class. This is by far more elegant and flexible in; an interactive environment. The member function `SetFCN` can be; used to define this pointer. - The ROOT static function `Printf` is provided to replace all; format statements and to print on currently defined output file. - The functions `SetObjectFit/GetObjectFit` can be used inside the; `FCN` function to set/get a referenced object instead of using; global variables. - By default `fGraphicsMode` is true. When c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:53579,simpl,simply,53579,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['simpl'],['simply']
Usability," without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arbitrary use cases. This feature is only enabled when clang; build is configured with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=SPIRV`` option. Linking is done using ``spirv-link`` from `the SPIRV-Tools project; <https://github.com/KhronosGroup/SPIRV-Tools#linker>`_. Similar to other external; linkers, Clang will expect ``spirv-link`` to be installed separately and to be; present in the ``PATH`` environment variable. Please refer to `the build and; installation instructions; <https://github.com/KhronosGroup/SPIRV-Tools#build>`_. .. code-block:: console. $ clang --target=spirv64 test1.cl test2.cl. More information about the SPIR-V target settings and supported versions of SPIR-V; format can be found in `the SPIR-V target guide; <https://llvm.org/docs/SPIRVUsage.html>`__. .. _clang-cl:. clang-cl; ========. clang-cl is an alternative command-line interface to Clang, designed for; compatibility with the Visual C++ compiler, cl.exe. To enable clang-cl to find system headers, libraries, and the linker when run; from the command-line, it should be executed inside a Visual Studio Native Tools; Command Prompt or a regular Command Prompt where the environment has been set; up using e.g. `vcvarsall.bat <https://msdn.microsoft.com/en-us/library/f2ccy3wt.aspx>`_. clang-cl can also be used from inside Visual Studio by selecting the LLVM; Platform Toolset. The toolset is not part of the installer, but may be installed; separately from the; `Visual Studio Marketplace <https://marketplace.visualstudio.com/items?itemName=LLVMExtensions.llvm-toolchain>`_.; To use the toolset, select a project in Solution Explorer, open its Property; Page (Alt+F7), and in the ""General""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:168305,guid,guide,168305,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['guid'],['guide']
Usability," would take the previous two and add the Parser library and; some actions for indexing. If you want a refactoring, static analysis, or; source-to-source compiler tool, you would then add the AST building and; semantic analyzer libraries.; For more information about the low-level implementation details of the; various clang libraries, please see the ; clang Internals Manual. Support Diverse Clients. Clang is designed and built with many grand plans for how we can use it. The; driving force is the fact that we use C and C++ daily, and have to suffer due to; a lack of good tools available for it. We believe that the C and C++ tools; ecosystem has been significantly limited by how difficult it is to parse and; represent the source code for these languages, and we aim to rectify this; problem in clang.; The problem with this goal is that different clients have very different; requirements. Consider code generation, for example: a simple front-end that; parses for code generation must analyze the code for validity and emit code; in some intermediate form to pass off to a optimizer or backend. Because; validity analysis and code generation can largely be done on the fly, there is; not hard requirement that the front-end actually build up a full AST for all; the expressions and statements in the code. TCC and GCC are examples of; compilers that either build no real AST (in the former case) or build a stripped; down and simplified AST (in the later case) because they focus primarily on; codegen.; On the opposite side of the spectrum, some clients (like refactoring) want; highly detailed information about the original source code and want a complete; AST to describe it with. Refactoring wants to have information about macro; expansions, the location of every paren expression '(((x)))' vs 'x', full; position information, and much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:6967,simpl,simple,6967,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['simpl'],['simple']
Usability," written to disk, with the class. When; it writes an object to file, it also writes the description of the; current class version along with it. This description is implemented in; the `StreamerInfo `class. ### The TStreamerInfo Class. Each class has a list of `StreamerInfo` objects, one for each version of; the class if that version was written to disk at least once. When; reading an object from a file, the system uses the `StreamerInfo` list; to decode an object into the current version. The `StreamerInfo` is made; up of **`TStreamerElements`** . Each describes one persistent data; member of the class. By default, all data members of a class are; persistent. To exclude a data member (i.e. make it not persistent), add; a ""`!`"" after the comment marks. For example the pointer \*`fPainter` of; a **`TH1`** is not persistent:. ``` {.cpp}; TVirtualHistPainter* fPainter //!pointer to histogram painter; ```. ### The TStreamerElement Class. A **`TStreamerElement`** describes a data member of a simple type,; object, array, pointer, or container. The offset in the; **`TStreamerElement`** is the starting address of the data for that data; member. ``` {.cpp}; BASE TNamed offset= 0 type=67 The basis for a named object; BASE TAttLine offset= 28 type= 0 Line attributes; ```. In this example, the **`TNamed`** data starts at byte 0, and; **`TAttLine`** starts at byte 28. The offset is machine and compiler; dependent and is computed when the `StreamerInfo` is analyzed. The types; are defined in the file `TStreamerInfo.h` and listed here:. ``` {.cpp}; enum EReadWrite {; kBase=0, kChar=1,kShort=2,kInt=3,kLong=4,; kFloat=5, kCounter=6,kCharStar=7, kDouble=8,kUChar=11,; kUShort=12, kUInt=13,kULong=14,kBits=15,kOffsetL=20,; kOffsetP=40, kObject=61,kAny=62,kObjectp=63,kObjectP=64,; kTString=65, kTObject=66,kTNamed=67,kSkip=100,kSkipL=120,; kSkipP=140, kConv=200, kConvL=220,kConvP=240,kStreamer=500,; kStreamLoop=501, kMissing=99999; };; ```. The method `TClass::GetStreamerInfo` analyzes th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:71019,simpl,simple,71019,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability," x, center y, top, bottom, expand x, expand y,; fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. - in response to actions widgets send messages and emit signals. - associated frames process these messages or the slot methods; connected to the signals are executed. ## TVirtualX. The GUI classes interface to the platform dependent low level graphics; system via the semi-abstract graphics base class **`TVirtualX`**.; Currently concrete implementations exist for X11 and Win32 (MacOS X is; fully supported via Apple's X11 implementation). Thanks to this single; graphics interface, porting the ROOT GUI to a new platform requires only; the implementation of **`TVirtualX`**. ![](pictures/02000201.jpg). ## A Simple Example. We will start with a simple example that builds a small application; containing a canvas and two buttons: Draw and Exit. Its functionality; will be very simple: every time you click on Draw button, the graphics; of the function `sin(x)/x` will be drawn in randomly chosen interval in; the canvas window, if you click on Exit - you close the application.; This example shows the basic concepts for almost any GUI-application in; ROOT and it is important to understand how it is constructed. The; example program is written as a named script. See ""Cling the C++; Interpreter"". Remember that the named script can be executed via. ``` {.cpp}; root[] .x example.C; ```. only if the filename (without extension) and the function entry point; are both the same. ![](pictures/02000202.jpg). We need to say a few words about the parent-children relationship; between the widgets before going through the real code. The widgets'; behaviors are based on this relationship. Every parent widget is; responsible for where the children are and it ensures all properties and; behavior for them. For example, if you want to hide several widgets, it; will be enough to hide their parent widget. Later you can show the; parent and the children will appear ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:2871,simpl,simple,2871,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability," you can also get objects with names that don't qualify as a Python variable. Here is a short demo:; ```python; import ROOT. with ROOT.TFile.Open(""my_file.root"", ""RECREATE"") as my_file:. # Populate the TFile with simple objects.; my_file.WriteObject(ROOT.std.string(""hello world""), ""my_string""); my_file.WriteObject(ROOT.vector[""int""]([1, 2, 3]), ""my vector""). print(my_file[""my_string""]) # new syntax; print(my_file.my_string) # old deprecated syntax. # With the dictionary syntax, you can also use names that don't qualify as; # a Python variable:; print(my_file[""my vector""]); # print(my_file.my vector) # the old syntax would not work here!; ```. The old pythonization with the `__getattr__` syntax still works, but emits a deprecation warning and will be removed from ROOT 6.34. ### Removal of Python 2 support. ROOT does no longer support Python 2. The minimum Python version necessary to use ROOT in a Python application is 3.8.; As a consequence, any reference to Python 2 in ROOT code was removed and certain configuration options are no longer; usable, e.g. * `root-config --python2-version`; * cmake -Dpyroot-python2. The cmake build system now looks for the standard `Python3` package and previously custom Python-related cmake variables; are now just the ones automatically produced by cmake (see https://cmake.org/cmake/help/latest/module/FindPython.html). ### More usage of the public cppyy API. Many implementation details of the ROOT pythonizations were moved from C++ functions to pure Python bindings using the; public cppyy API. This helps in the integration with the tool but also improves code efficiency and memory usage. ## Class Reference Guide. - Define missing doxygen groups.; - Fix a few typos in the `THStack` documentation.; - Small fixes in the `THistPainter` documentation.; - Improve the `TColor` documentation: use modern C++ in the examples.; - Make sure the python examples do not generate wrong namespaces in the documentation.; - The dataframe tutorials json sp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:22682,usab,usable,22682,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['usab'],['usable']
Usability," | over to the new structure |; +-----------------------------------------+----------------------------------+; | `SetSparseIndex` | copy the sparse map from matrix |; | `(const TMatrixDBase &a)` | `a` Note that this can be a |; | | dense matrix! |; +-----------------------------------------+----------------------------------+; | `SetSparseIndexAB` | set the sparse map to the same |; | `(const TMatrixDSparse &a,` ` | of the map of matrix `a` and `b` |; | const TMatrixDSparse &b)` | |; +-----------------------------------------+----------------------------------+. The second half of the table is only relevant for sparse matrices. These; methods define the sparse structure. It should be clear that a call to; any of these methods has to be followed by a **`SetMatrixArray`** (...); which will supply the matrix data, see the next chapter ""Creating and; Filling a Matrix"". ## Creating and Filling a Matrix. The matrix constructors are listed in the next table. In the simplest; ones, only the number of rows and columns is given. In a slightly more; elaborate version, one can define the row and column index range.; Finally, one can also define the matrix data in the constructor. In; Matrix Operators and Methods we will encounter more fancy constructors; that will allow arithmetic operations. +--------------------------------------------------------------------------+; | `TMatrixD(Int_t nrows,Int_t ncols)` |; | |; | `TMatrixD(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb)` |; | |; | `TMatrixD(Int_t nrows,Int_t ncols,const Double_t *data, Option_t option= |; | """")` |; | |; | `TMatrixD(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb,` |; | |; | ` const Double_t *data,Option_t *option="""")` |; +--------------------------------------------------------------------------+; | `TMatrixDSym(Int_t nrows)` |; | |; | `TMatrixDSym(Int_t row_lwb,Int_t row_upb) ` |; | |; | `TMatrixDSym(Int_t nrows,const Double_t *data,Option_t *option="""")` |; | |; | `TMatrixDSym(Int_t row_lwb",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:9657,simpl,simplest,9657,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['simpl'],['simplest']
Usability," |; +------------+------+--------+----------+-------+---------+-------------+----------+------------+; | *obj* | NO | | | **?** | **?** | **?** | **?** | **?** |; +------------+------+--------+----------+-------+---------+-------------+----------+------------+; | live | NO | | | **?** | **?** | **?** | **?** | **?** |; | analysis | | | | | | | | |; +------------+------+--------+----------+-------+---------+-------------+----------+------------+; | register | NO | | | **?** | **?** | **?** | **?** | **?** |; | map | | | | | | | | |; +------------+------+--------+----------+-------+---------+-------------+----------+------------+; | \* Derived pointers only pose a hazard to copying collections. |; +------------+------+--------+----------+-------+---------+-------------+----------+------------+; | **?** denotes a feature which could be utilized if available. |; +------------+------+--------+----------+-------+---------+-------------+----------+------------+. To be clear, the collection techniques above are defined as:. Shadow Stack; The mutator carefully maintains a linked list of stack roots. Reference Counting; The mutator maintains a reference count for each object and frees an object; when its count falls to zero. Mark-Sweep; When the heap is exhausted, the collector marks reachable objects starting; from the roots, then deallocates unreachable objects in a sweep phase. Copying; As reachability analysis proceeds, the collector copies objects from one heap; area to another, compacting them in the process. Copying collectors enable; highly efficient ""bump pointer"" allocation and can improve locality of; reference. Incremental; (Including generational collectors.) Incremental collectors generally have all; the properties of a copying collector (regardless of whether the mature heap; is compacting), but bring the added complexity of requiring write barriers. Threaded; Denotes a multithreaded mutator; the collector must still stop the mutator; (""stop the world"") before ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:30002,clear,clear,30002,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['clear'],['clear']
Usability,""") identifies the precise; code location of a fault, trap, or asynchronous interrupt rather than a return; address. At other times, even the first frame is actually a return address; (for example, backtraces collected at the time of an object allocation and; reported later when the allocated object is used or misused). When a system; supports in-thread trap handling, there may also be frames after the first; that represent a precise interrupted code location rather than a return; address, presented as the ""caller"" of a trap handler function (for example,; signal handlers in POSIX systems). Return address frames are identified by the ``:ra`` suffix. Precise code; location frames are identified by the ``:pc`` suffix. Traditional practice has often been to collect backtraces as simple address; lists, losing the distinction between return address code locations and; precise code locations. Some such code applies the ""subtract one"" adjustment; described above to the address values before reporting them, and it's not; always clear or consistent whether this adjustment has been applied or not.; These ambiguous cases are supported by the ``bt`` and ``pc`` forms with no; ``:ra`` or ``:pc`` suffix, which indicate it's unclear which sort of code; location this is. However, it's highly recommended that all emitters use the; suffixed forms and deliver address values with no adjustments applied. When; traditional practice has been ambiguous, the majority of cases seem to have; been of printing addresses that are return address code locations and printing; them without adjustment. So the symbolizing filter will usually apply the; ""subtract one byte"" adjustment to an address printed without a disambiguating; suffix. Assuming that a call instruction is longer than one byte on all; supported machines, applying the ""subtract one byte"" adjustment a second time; still results in an address somewhere in the call instruction, so a little; sloppiness here often does little or no harm. Examp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:12408,clear,clear,12408,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,1,['clear'],['clear']
Usability,"""); ```; or:; ```; TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...); ```; - `filename`: Name of ROOT file in which to save recorded events. 2] To stop recording; ```; recorder->Stop(); ```. IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. #### Example:. ```; t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording; ```. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. ### Replaying. 1] To start replaying; ```; TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""); ```; or:; ```; TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);; ```; - `filename`: A name of file with recorded events previously created with TRecorder::Start. - `showMouseCursor`: If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying; ```; recorder->Pause(); ```; Replaying is stopped until `recorder->Resume()` is called. 3] To resume paused replaying; ```; recorder->Resume(); ```; Resumes previously stopped replaying. 4] To stop replaying before its end; ```; recorder->Stop(); ```; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/doc/index.md:2283,pause,pause,2283,gui/recorder/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/doc/index.md,3,"['pause', 'resume']","['pause', 'paused', 'resume']"
Usability,""", and ""sequences"". A scalar is any number; or string. The pound/hash symbol (#) begins a comment line. A mapping is; a set of key-value pairs where the key ends with a colon. For example:. .. code-block:: yaml. # a mapping; name: Tom; hat-size: 7. A sequence is a list of items where each item starts with a leading dash ('-').; For example:. .. code-block:: yaml. # a sequence; - x86; - x86_64; - PowerPC. You can combine mappings and sequences by indenting. For example a sequence; of mappings in which one of the mapping values is itself a sequence:. .. code-block:: yaml. # a sequence of mappings with one key's value being a sequence; - name: Tom; cpus:; - x86; - x86_64; - name: Bob; cpus:; - x86; - name: Dan; cpus:; - PowerPC; - x86. Sometime sequences are known to be short and the one entry per line is too; verbose, so YAML offers an alternate syntax for sequences called a ""Flow; Sequence"" in which you put comma separated sequence elements into square; brackets. The above example could then be simplified to :. .. code-block:: yaml. # a sequence of mappings with one key's value being a flow sequence; - name: Tom; cpus: [ x86, x86_64 ]; - name: Bob; cpus: [ x86 ]; - name: Dan; cpus: [ PowerPC, x86 ]. Introduction to YAML I/O; ========================. The use of indenting makes the YAML easy for a human to read and understand,; but having a program read and write YAML involves a lot of tedious details.; The YAML I/O library structures and simplifies reading and writing YAML; documents. YAML I/O assumes you have some ""native"" data structures which you want to be; able to dump as YAML and recreate from YAML. The first step is to try; writing example YAML for your data structures. You may find after looking at; possible YAML representations that a direct mapping of your data structures; to YAML is not very readable. Often the fields are not in the order that; a human would find readable. Or the same information is replicated in multiple; locations, making it hard for a hu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:1354,simpl,simplified,1354,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['simpl'],['simplified']
Usability,""": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part""; }; ]; }; ],; ""version"": 1; }. In this way, we can pass the single command line options after the ``--``.; Then clang-scan-deps will extract the necessary information from the options.; Note that we need to specify the path to the compiler executable instead of saying; ``clang++`` simply. The users may want the scanner to get the transitional dependency information for headers.; Otherwise, the users have to scan twice for the project, once for headers and once for modules.; To address the requirement, clang-scan-deps will recognize the specified preprocessor options; in the given command line and generate the corresponding dependency information. For example,. .. code-block:: console. $ clang-scan-deps -format=p1689 -- ../bin/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o -MD -MT impl_part.ddi -MF impl_part.dep; $ cat impl_part.dep. We will get:. .. code-block:: text. impl_part.ddi: \; /usr/include/bits/wchar.h /usr/include/bits/types/wint_t.h \; /usr/include/bits/types/mbstate_t.h \; /usr/include/bits/types/__mbstate_t.h /usr/include/bits/types/__FILE.h \; /usr/include/bits/types/FILE.h /usr/include/bits/types/locale_t.h \; /usr/include/bits/types/__locale_t.h \; ... When clang-scan-deps detects ``-MF`` option, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:36952,simpl,simply,36952,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['simpl'],['simply']
Usability,"""my cool jit"", TheContext);; TheModule->setDataLayout(TheJIT->getDataLayout());. // Create a new builder for the module.; Builder = std::make_unique<IRBuilder<>>(*TheContext);. // Create a new pass manager attached to it.; TheFPM = std::make_unique<legacy::FunctionPassManager>(TheModule.get());; ... The KaleidoscopeJIT class is a simple JIT built specifically for these; tutorials, available inside the LLVM source code; at `llvm-src/examples/Kaleidoscope/include/KaleidoscopeJIT.h; <https://github.com/llvm/llvm-project/blob/main/llvm/examples/Kaleidoscope/include/KaleidoscopeJIT.h>`_.; In later chapters we will look at how it works and extend it with; new features, but for now we will take it as given. Its API is very simple:; ``addModule`` adds an LLVM IR module to the JIT, making its functions; available for execution (with its memory managed by a ``ResourceTracker``); and; ``lookup`` allows us to look up pointers to the compiled code. We can take this simple API and change our code that parses top-level expressions to; look like this:. .. code-block:: c++. static ExitOnError ExitOnErr;; ...; static void HandleTopLevelExpression() {; // Evaluate a top-level expression into an anonymous function.; if (auto FnAST = ParseTopLevelExpr()) {; if (FnAST->codegen()) {; // Create a ResourceTracker to track JIT'd memory allocated to our; // anonymous expression -- that way we can free it after executing.; auto RT = TheJIT->getMainJITDylib().createResourceTracker();. auto TSM = ThreadSafeModule(std::move(TheModule), std::move(TheContext));; ExitOnErr(TheJIT->addModule(std::move(TSM), RT));; InitializeModuleAndPassManager();. // Search the JIT for the __anon_expr symbol.; auto ExprSymbol = ExitOnErr(TheJIT->lookup(""__anon_expr""));; assert(ExprSymbol && ""Function not found"");. // Get the symbol's address and cast it to the right type (takes no; // arguments, returns a double) so we can call it as a native function.; double (*FP)() = ExprSymbol.getAddress().toPtr<double (*)()>();;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:12476,simpl,simple,12476,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['simpl'],['simple']
Usability,"# .. 8 entries skipped ..; # This entry describes the spill slot which is directly addressable; # off RSP with offset 0. Given the value was spilled with a pushq,; # that makes sense.; # Stack Maps: Loc 8: Direct RSP [encoding: .byte 2, .byte 8, .short 7, .int 0]; 	 .byte	2; 	 .byte	8; 	 .short	7; 	 .long	0. This example was taken from the tests for the :ref:`RewriteStatepointsForGC`; utility pass. As such, its full StackMap can be easily examined with the; following command. .. code-block:: bash. opt -rewrite-statepoints-for-gc test/Transforms/RewriteStatepointsForGC/basics.ll -S | llc -debug-only=stackmaps. Simplifications for Non-Relocating GCs; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Some of the complexity in the previous example is unnecessary for a; non-relocating collector. While a non-relocating collector still needs the; information about which location contain live references, it doesn't need to; represent explicit relocations. As such, the previously described explicit; lowering can be simplified to remove all of the ``gc.relocate`` intrinsic; calls and leave uses in terms of the original reference value. Here's the explicit lowering for the previous example for a non-relocating; collector:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; call token (i64, i32, void ()*, i32, i32, ...)* @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 0, i32 0, void ()* @foo, i32 0, i32 0, i32 0, i32 0, i8 addrspace(1)* %obj); ret i8 addrspace(1)* %obj; }. Recording On Stack Regions; ^^^^^^^^^^^^^^^^^^^^^^^^^^. In addition to the explicit relocation form previously described, the; statepoint infrastructure also allows the listing of allocas within the gc; pointer list. Allocas can be listed with or without additional explicit gc; pointer values and relocations. An alloca in the gc region of the statepoint operand list will cause the; address of the stack region to be listed in the stackmap for the statepoint. This mec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:11830,simpl,simplified,11830,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['simpl'],['simplified']
Usability,"# Automatic HTML Documentation; \index{documentation!class}. **`THtml`** is ROOT's documentation engine. It can be used to document; your classes in a reference guide, and to convert your text or source; files to HTML. ## Reference Guide. The Reference Guide for the ROOT classes at; <http://root.cern.ch/root/html/> has been generated by ROOT's; **`THtml`** class. Just as for ROOT's classes, it can generate (and; update) a reference guide for your classes, too. You document your; classes using source code comments. All comments will be automatically; put into a `<pre></pre>` environment to keep the indentation and line; length. You can write ""raw"" HTML by enclosing comments in the keywords; `Begin_Html` and `End_Html`. To generate documentation for the class **`TObject`** you could run the; following commands:. ``` {.cpp}; root[] THtml h; root[] h.SetInputDir(""$(ROOTSYS)"");; root[] h.MakeClass(""TObject"");; root[] h.CreateJavascript();; root[] h.CreateStylesheet();; ```. The comments following the first comment of the form; //\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_, before any method, is; assumed to be the **class description**. As with any other documentation; part, it has to be a continuous block of comments. Any documented class will have an **class index entry** in the; `ClassIndex.html`, showing their name with a link to their documentation; page and a miniature description. This description for e.g. the class; `MyClass` has to be given in `MyClass's` header file as documentation. A **method description** block starts immediately after '`{`' and looks; like this:. ``` {.cpp}; void TWorld::HelloWorldFunc(string *text); {; // This is a documentation example of the function TWorld::HelloWorldFunc; helloWorld.Print(text);; }; ```. Like in a class description block, everything until the first; non-commented line is considered as a valid member function description; block. **Data members** are documented by putting a C++ comment behind their; declaration in the header ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:161,guid,guide,161,documentation/users-guide/HTMLDoc.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md,2,['guid'],['guide']
Usability,"# C++ Modules in ROOT. Technology Overview. *Vassil Vassilev, Oksana Shadura, Yuka Takahashi and Raphael Isemann*. ## Overview. ROOT has several features which interact with libraries and require implicit; header inclusion. This can be triggered by reading or writing data on disk,; or user actions at the prompt. Often, the headers are immutable and reparsing is; redundant. C++ Modules are designed to minimize the reparsing of the same; header content by providing an efficient on-disk representation of C++ Code. The ROOT v6.16 release came with a preview of the module technology;; dedicated binaries have been built and can be reproduced by passing; `-Druntime_cxxmodules=On` as configure flag. The goals of this technology are:; * Gain feedback from early adoption -- the technology is being long anticipated; by some of the users of ROOT. It improves correctness of ROOT and improves; performance when carefully adopted.; * Study performance bottlenecks -- the feature is designed with performance; considerations in mind. In this document we describe the current performance; bottlenecks and trade-offs.; * Understand if the gradual migration policy is sufficient -- C++ Modules in; ROOT support gradual migration. In particular, ROOT can enable C++ Modules for; itself and still run in legacy mode for the third-party code (generating; rootmap files and other scaffolding). C++ Modules are here and we would like to give a brief introduction of how the; feature works, what are its pros and cons, what's the current state of the; implementation and how third-party code can use it. Read more [[1]]. C++ Modules in ROOT are default since v6.20 (Unix) and v6.22 (OSX). ## Design Goals. * Coherence with standard C++ -- C++ Modules TS is advancing and will be; likely part the upcoming C++20 standard;; * Performance -- provide performance that is competitive to ROOT with PCH and; advance further the implementation of the C++ Modules in clang to optimize; memory footprint and execution time;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:743,feedback,feedback,743,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['feedback'],['feedback']
Usability,"# Concluding Remarks #. This is the end of our guided tour for beginners through ROOT. There is; still a lot coming to mind to be said, but by now you are experienced; enough to use the ROOT documentation, most importantly the **[ROOT home; page](http://root.cern.ch)** and the **[ROOT reference; guide](https://root.cern/doc/master/)** with the; documentation of all ROOT classes, or the **[ROOT users; manual](https://root.cern/manual/)**. A very useful way for you to continue exploring ROOT is to study the; examples in the sub-directory `tutorials/` of any ROOT installation. There are some powerful features of ROOT which were not treated in this; document, e.g. packages named RooFit and RooStats providing an advanced; framework for model building, fitting and statistical analysis. The ROOT; namespace `TMVA` offers multi-variate analysis tools including an artificial; neural network and many other advanced tools for classification; problems. The remarkable ability of ROOT to handle large data volumes; was already mentioned in this guide, implemented through the class; `TTree`. But there is still much more for you to explore!. **End of this guide ... but hopefully not of your interaction with ROOT !**; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/concludingRemarks.md:47,guid,guided,47,documentation/primer/concludingRemarks.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/concludingRemarks.md,4,['guid'],"['guide', 'guided']"
Usability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. add_minuit2_test(Quad1F Quad1FMain.cxx Quad1F.h). add_minuit2_test(Quad4F Quad4FMain.cxx Quad4F.h). add_minuit2_test(Quad8F Quad8FMain.cxx Quad8F.h). add_minuit2_test(Quad12F Quad12FMain.cxx Quad12F.h). add_test(; NAME ExampleCMakeBuild; COMMAND ""${CMAKE_CTEST_COMMAND}""; --build-and-test; ""${Minuit2_SOURCE_DIR}/examples/simple/""; ""${CMAKE_CURRENT_BINARY_DIR}/simple/""; --build-generator ""${CMAKE_GENERATOR}""; --test-command ""${CMAKE_CTEST_COMMAND}""; ); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/MnTutorial/CMakeLists.txt:517,simpl,simple,517,math/minuit2/test/MnTutorial/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/MnTutorial/CMakeLists.txt,2,['simpl'],['simple']
Usability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. cmake_minimum_required(VERSION 3.10); # This is a test of the Minuit2 CMake build system. project(Quad1F LANGUAGES CXX). # CMake should be able to find the Minuit2 package if you have either built it or installed it; find_package(Minuit2 CONFIG REQUIRED). # Reusing the existing test file for simplicity; add_executable(Quad1F; ../../test/MnTutorial/Quad1FMain.cxx; ../../test/MnTutorial/Quad1F.h; ). # Linking with Minuit2::Minuit2 target; target_link_libraries(Quad1F PUBLIC Minuit2::Minuit2). # Run this executable as a test with make test; enable_testing(); add_test(NAME Quad1F COMMAND Quad1F); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/examples/simple/CMakeLists.txt:488,simpl,simplicity,488,math/minuit2/examples/simple/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/examples/simple/CMakeLists.txt,1,['simpl'],['simplicity']
Usability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. if(NOT DEFINED ROOT_SOURCE_DIR); cmake_minimum_required(VERSION 3.10); project(minuit2_tests); find_package(ROOT REQUIRED); include(${ROOT_USE_FILE}); endif(). set(TestSource testMinimizer.cxx); if (clad); list(APPEND TestSource testADMinim.cxx); endif(). set(TestSourceMnTutorial; MnTutorial/Quad1FMain.cxx; MnTutorial/Quad4FMain.cxx; MnTutorial/Quad8FMain.cxx; MnTutorial/Quad12FMain.cxx; ). set(TestSourceMnSim; MnSim/DemoGaussSim.cxx; MnSim/DemoFumili.cxx; MnSim/PaulTest.cxx; MnSim/PaulTest2.cxx; MnSim/PaulTest3.cxx; MnSim/PaulTest4.cxx; MnSim/ReneTest.cxx; MnSim/ParallelTest.cxx; MnSim/demoMinimizer.cxx; ). set(ParallelTest_LABELS longtest). #---For the simple Minuit2 tests build and defined them---------------; foreach(file ${TestSourceMnTutorial}); get_filename_component(testname ${file} NAME_WE); ROOT_EXECUTABLE(${testname} ${file} LIBRARIES Minuit2); ROOT_ADD_TEST(minuit2_${testname} COMMAND ${testname}); endforeach(). ROOT_LINKER_LIBRARY(Minuit2TestMnSim MnSim/GaussDataGen.cxx MnSim/GaussFcn.cxx MnSim/GaussFcn2.cxx LIBRARIES Minuit2). #input text files; configure_file(MnSim/paul.txt paul.txt COPYONLY); configure_file(MnSim/paul2.txt paul2.txt COPYONLY); configure_file(MnSim/paul3.txt paul3.txt COPYONLY); configure_file(MnSim/paul4.txt paul4.txt COPYONLY). foreach(file ${TestSourceMnSim}); get_filename_component(testname ${file} NAME_WE); ROOT_EXECUTABLE(${testname} ${file} LIBRARIES Minuit2 Minuit2TestMnSim MathCore); ROOT_ADD_TEST(minuit2_${testname} COMMAND ${testname}); endforeach(). #for the global tests using ROOT libs (Minuit2 should be taken via the PluginManager). set(RootLibraries Core RIO Net Hist Graf Graf3d Gpad Tree; Rint Postscript Matrix Physics MathCore Thread). foreach(file ${TestSource}); get_filename_component(testname ${file} NAME_WE); ROOT_EXECUTABL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/CMakeLists.txt:858,simpl,simple,858,math/minuit2/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/CMakeLists.txt,1,['simpl'],['simple']
Usability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. include(ExternalProject); include(FindPackageHandleStandardArgs). # find_package(OpenSSL) may not have found it,; # clear parent scope variables set to NOTFOUND; foreach(suffix FOUND INCLUDE_DIR INCLUDE_DIRS CRYPTO_LIBRARY SSL_LIBRARY LIBRARY LIBRARIES VERSION); unset(OPENSSL_${suffix} PARENT_SCOPE); endforeach(). set(OPENSSL_VERSION ""3.0.13""); set(OPENSSL_URL ""http://lcgpackages.web.cern.ch/lcgpackages/tarFiles/sources/openssl-${OPENSSL_VERSION}.tar.gz""); set(OPENSSL_URLHASH ""SHA256=88525753f79d3bec27d2fa7c66aa0b92b3aa9498dafd93d7cfa4b3780cdae313""); set(OPENSSL_PREFIX ${CMAKE_CURRENT_BINARY_DIR}/OPENSSL-prefix). foreach(lib ssl crypto); string(TOUPPER ${lib} libupper); set(libname ${CMAKE_STATIC_LIBRARY_PREFIX}${lib}${CMAKE_STATIC_LIBRARY_SUFFIX}); set(OPENSSL_${libupper}_LIBRARY ${OPENSSL_PREFIX}/lib/${libname}); endforeach(). if(APPLE); if(${ROOT_ARCHITECTURE} MATCHES ""macosxarm64""); set(OPENSSL_CONFIG_CMD ./Configure darwin64-arm64-cc); else(); set(OPENSSL_CONFIG_CMD ./Configure darwin64-x86_64-cc); endif(); if (CMAKE_OSX_SYSROOT); set(OSX_SYSROOT ""-isysroot ${CMAKE_OSX_SYSROOT}""); endif(); else(); set(OPENSSL_CONFIG_CMD ./config); endif(). ExternalProject_Add(OPENSSL; URL ${OPENSSL_URL} URL_HASH ${OPENSSL_URLHASH}; CONFIGURE_COMMAND ${OPENSSL_CONFIG_CMD} no-shared --prefix=<INSTALL_DIR>; BUILD_COMMAND make -j1 CC=${CMAKE_C_COMPILER}\ -fPIC\ ${OSX_SYSROOT}; INSTALL_COMMAND make install_sw; BUILD_IN_SOURCE 1; LOG_BUILD 1 LOG_CONFIGURE 1 LOG_DOWNLOAD 1 LOG_INSTALL 1; BUILD_BYPRODUCTS ${OPENSSL_CRYPTO_LIBRARY} ${OPENSSL_SSL_LIBRARY}; TIMEOUT 600). set(OPENSSL_FOUND TRUE CACHE BOOL """" FORCE); set(OPENSSL_VERSION ${OPENSSL_VERSION} CACHE INTERNAL """" FORCE); set(OPENSSL_VERSION_STRING ""${OPENSSL_VERSION}"" CACHE INTERNAL """" FORCE); set(OPENSSL_PREFIX ${OPENSSL_PREFIX} CACHE INTE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/openssl/CMakeLists.txt:311,clear,clear,311,builtins/openssl/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/openssl/CMakeLists.txt,1,['clear'],['clear']
Usability,"# Data flow analysis: an informal introduction. ## Abstract. This document introduces data flow analysis in an informal way. The goal is to; give the reader an intuitive understanding of how it works, and show how it; applies to a range of refactoring and bug finding problems. Data flow analysis is a well-established technique; it is described in many; papers, books, and videos. If you would like a more formal, or a more thorough; explanation of the concepts mentioned in this document, please refer to the; following resources:. * [The Lattice article in Wikipedia](https://en.wikipedia.org/wiki/Lattice_\(order\)).; * Videos on the PacketPrep YouTube channel that introduce lattices and the; necessary background information:; [#20](https://www.youtube.com/watch?v=73j_FXBXGm8),; [#21](https://www.youtube.com/watch?v=b5sDjo9tfE8),; [#22](https://www.youtube.com/watch?v=saOG7Uooeho),; [#23](https://www.youtube.com/watch?v=3EAYX-wZH0g),; [#24](https://www.youtube.com/watch?v=KRkHwQtW6Cc),; [#25](https://www.youtube.com/watch?v=7Gwzsc4rAgw).; * [Introduction to Dataflow Analysis](https://www.youtube.com/watch?v=OROXJ9-wUQE); * [Introduction to abstract interpretation](http://www.cs.tau.ac.il/~msagiv/courses/asv/absint-1.pdf).; * [Introduction to symbolic execution](https://www.cs.umd.edu/~mwh/se-tutorial/symbolic-exec.pdf).; * [Static Program Analysis by Anders Møller and Michael I. Schwartzbach](https://cs.au.dk/~amoeller/spa/).; * [EXE: automatically generating inputs of death](https://css.csail.mit.edu/6.858/2020/readings/exe.pdf); (a paper that successfully applies symbolic execution to real-world; software). ## Data flow analysis. ### The purpose of data flow analysis. Data flow analysis is a static analysis technique that proves facts about a; program or its fragment. It can make conclusions about all paths through the; program, while taking control flow into account and scaling to large programs.; The basic idea is propagating facts about the program through the edges",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:160,intuit,intuitive,160,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['intuit'],['intuitive']
Usability,"# Example analysis illustrating the use of rootdrawtree / TSimpleAnalysis.; # Run as:; # $ rootdrawtree tutorials/tree/simpleAnalysis.txt. file_output.root #the output file in which histograms are stored. # The next line has the name of the tree of the input data. It is; # optional if there is exactly one tree in the first input file.; ntuple #name of the input tree. # The lines of the next block correspond to .root input files that; # contain the tree. In this case we use only one input file.; tutorials/hsimple.root # this is the input file. # The next block is composed by lines that allow to configure the; # histograms. They have the following syntax:; # NAME = EXPRESSION if CUT; # which corresponds to chain->Draw(""EXPRESSION >> NAME"", ""CUT""); # i.e. it will create a histogram called NAME and store it in; # file_output.root.; # ""if CUT"" is optional; hpx=px if px<-3 #first histogram; hpxpy=px:py #second histogram. # End of the configuration file; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tree/simpleAnalysis.txt:119,simpl,simpleAnalysis,119,tutorials/tree/simpleAnalysis.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tree/simpleAnalysis.txt,1,['simpl'],['simpleAnalysis']
Usability,"# File I/O and Parallel Analysis #. ## Storing ROOT Objects ##. ROOT offers the possibility to write instances of classes on; disk, into a *ROOT-file* (see the `TFile` class for more details).; One says that the object is made ""persistent"" by storing; it on disk. When reading the file back, the object is reconstructed; in memory. The requirement to be satisfied to perform I/O of instances; of a certain class is that the ROOT type system is aware of the layout; in memory of that class.; This topic is beyond the scope of this document: it is worth to mention; that I/O can be performed out of the box for the almost complete set; of ROOT classes. We can explore this functionality with histograms and two simple macros. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_to_file.C; ```. Not bad, eh ? Especially for a language that does not foresees; persistency natively like C++. The *RECREATE* option forces ROOT to; create a new file even if a file with the same name exists on disk. Now, you may use the Cling command line to access information in the file; and draw the previously written histogram:. ``` {.cpp}; > root my_rootfile.root; root [0]; Attaching file my_rootfile.root as _file0...; root [1] _file0->ls(); TFile** my_rootfile.root; TFile* my_rootfile.root; KEY: TH1F	my_histogram;1 My Title; root [2] my_histogram->Draw(); ```; \newpage; Alternatively, you can use a simple macro to carry out the job:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss bri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:709,simpl,simple,709,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['simpl'],['simple']
Usability,"# Getting Started. We begin by showing you how to use ROOT interactively. There are two; examples to click through and learn how to use the GUI. We continue by; using the command line, and explaining the coding conventions, global; variables and the environment setup. If you have not installed ROOT,; you can do so by following the instructions in the appendix, or on the; ROOT web site: <http://root.cern.ch/root/Availability.html>. ## Setting the Environment Variables. Before you can run ROOT you need to set the environment variable; `ROOTSYS` and change your path to include `root/bin` and library path; variables to include `root/lib`. Please note: the syntax is for; `bash`, if you are running `tcsh` you will have to use `setenv`; instead of `export`. 1. Define the variable \$ROOTSYS to the directory where you unpacked; the ROOT:. ```; $ export ROOTSYS=$HOME/root; ```. 2. Add ROOTSYS/bin to your PATH:. ```; $ export PATH=$PATH:$ROOTSYS/bin; ```. 3. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the; library path:. ```; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; ```. On AIX, before executing the interactive module, you must set the; library path:. ```; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export LIBPATH=$LIBPATH:$ROOTSYS/lib; ```. On Linux, Solaris, Alpha OSF and SGI, before executing the interactive; module, you must set the library path:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; ```. On Solaris, in case your LD\_LIBRARY\_PATH is empty, you should set; it:. ```; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:/usr/dt/lib; ```. If you use the `afs` version you should set (*vers* = version number,; *arch* = architecture):. ```; $ export ROOTSYS=/afs/cern.ch/sw/lcg/external/root/vers/arch/root; ```. If ROOT was installed in `$HOME/myroot` directory on a local machine,; one can do:. ```; cd $HOME/myroot; . bin/thisroot.sh // or source bin/thisroot.sh; ```. The new `$ROOTSYS/bin/this",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:119,learn,learn,119,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['learn'],['learn']
Usability,"# Graphs #. In this Chapter we will learn how to exploit some of the functionalities; ROOT provides to display data exploiting the class `TGraphErrors`,; which you already got to know previously. ## Read Graph Points from File ##. The fastest way in which you can fill a graph with experimental data is; to use the constructor which reads data points and their errors from an; ASCII file (i.e. standard text) format:. ``` {.cpp}; TGraphErrors(const char *filename,; const char *format=""%lg %lg %lg %lg"", Option_t *option="""");; ```. The format string can be:. - `""%lg %lg""` read only 2 first columns into X,Y. - `""%lg %lg %lg""` read only 3 first columns into X,Y and EY. - `""%lg %lg %lg %lg""` read only 4 first columns into X,Y,EX,EY. This approach has the nice feature of allowing the user to reuse the; macro for many different data sets. Here is an example of an input file.; The nice graphic result shown is produced by the macro below, which; reads two such input files and uses different options to display the; data points. ```; # Measurement of Friday 26 March; # Experiment 2 Physics Lab. 1 6 5; 2 12 5; 3 14 4.7; 4 20 4.5; 5 22 4.2; 6 24 5.1; 7 35 2.9; 8 45 4.1; 9 44 4.8; 10 53 5.43; ```; \newpage; ![](figures/graph_with_expectation.png). ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro2.C; ```. In addition to the inspection of the plot, you can check the actual; contents of the graph with the `TGraph::Print()` method at any time,; obtaining a printout of the coordinates of data points on screen. The; macro also shows us how to print a coloured band around a graph instead; of error bars, quite useful for example to represent the errors of a; theoretical prediction. ## Polar Graphs ##. With ROOT you can profit from rather advanced plotting routines, like; the ones implemented in the `TPolarGraph`, a class to draw graphs in; polar coordinates. You can see the example macro in the following and the; resulting Figure is [4.2](#f42):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md:36,learn,learn,36,documentation/primer/graphs.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md,1,['learn'],['learn']
Usability,"# How to Contribute Code to ROOT. Thank you for your interest in contributing to ROOT! We strongly welcome and appreciate such contributions!; This short guide tries to make contributing as quick and painless as possible. > [!NOTE]; > These guidelines should be applicable to most contributes. At the same time, these are not 'one-size-fits-all' rules,; > and there might be cases where diverging from these guidelines is warranted. If you are unsure about how to structure; > your contribution, don't hesitate to reach out! We are always happy to provide help and feedback. ## Your Code Contribution. The source code for ROOT is kept in [GitHub](https://github.com/root-project/root).; Changes go through pull requests (""PRs"").; The primary branch for development is `master`. > [!IMPORTANT]; > We require PRs to cleanly apply to master without a merge commit, i.e. through ""fast-forward"".; > Please follow the [coding conventions](https://root.cern.ch/coding-conventions), as this is a simple item for; > reviewers to otherwise get stuck on.; > To make your (and our own) life easier, we provide a; > [`clang-format` configuration file](https://github.com/root-project/root/blob/master/.clang-format). By providing code, you agree to transfer your copyright on the code to the ""ROOT project"".; Of course you will be duly credited: for sizable contributions your name will appear in the; [CREDITS](https://raw.githubusercontent.com/root-project/root/master/README/CREDITS); file shipped with every binary and source distribution.; The copyright transfer helps us with effectively defending the project in case of litigation. ## Your Commit. Each commit is a self-contained, _atomic_ change. This means that:; 1. **Each commit should be able to successfully build ROOT.**; Doing so makes traveling through the git history, for example during a `git bisect` much easier.; Ideally, the commit also should not depend on other commits to _run_ ROOT.; 2. **Each commit does not contain more than one indepe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md:154,guid,guide,154,CONTRIBUTING.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md,5,"['feedback', 'guid', 'simpl']","['feedback', 'guide', 'guidelines', 'simple']"
Usability,"# Motivation and Introduction #. ***Welcome to data analysis!***. Comparison of measurements to theoretical models is one of the standard; tasks in experimental physics. In the most simple case, a ""model"" is; just a function providing predictions of measured data. Very often, the; model depends on parameters. Such a model may simply state ""the current; *I* is proportional to the voltage *U*"", and the task of the; experimentalist consists of determining the resistance, *R*, from a set; of measurements. As a first step, a visualisation of the data is needed. Next, some; manipulations typically have to be applied, e.g. corrections or; parameter transformations. Quite often, these manipulations are complex; ones, and a powerful library of mathematical functions and procedures; should be provided - think for example of an integral or peak-search or; a Fourier transformation applied to an input spectrum to obtain the; actual measurement described by the model. One specialty of experimental physics are the inevitable uncertainties; affecting each measurement, and visualisation tools have to include; these. In subsequent analysis, the statistical nature of the errors must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:182,simpl,simple,182,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,2,['simpl'],"['simple', 'simply']"
Usability,"# Networking. In this chapter, you will learn how to send data over the network using; the ROOT socket classes. ## Setting-up a Connection. *On the serverside*, we create a **`TServerSocket`** to wait for a; connection request over the network. If the request is accepted, it; returns a full-duplex socket. Once the connection is accepted, we can; communicate to the client that we are ready to go by sending the string; ""go"", and we can close the server socket. ``` {.cpp}; { // server; TServerSocket *ss = new TServerSocket(9090,kTRUE);; TSocket *socket = ss->Accept();; socket->Send(""go"");; ss->Close();; }; ```. *On the clientside*, we create a socket and ask the socket to receive; input. ``` {.cpp}; { // client; TSocket *socket = new TSocket(""localhost"",9090);; Char str[32];; socket->Recv(str,32);; }; ```. ## Sending Objects over the Network. We have just established a connection and you just saw how to send and; receive a string with the example ""go"". Now let's send a histogram. *To send an object (in our case on the client side*) it has to derive; from **`TObject`** class because it uses the `Streamers` to fill a; buffer that is then sent over the connection. On the receiving side, the; `Streamers` are used to read the object from the message sent via the; socket. For network communication, we have a specialized **`TBuffer`**,; a descendant of **`TBuffer`** called **`TMessage`**. In the following; example, we create a **`TMessage`** with the intention to store an; object, hence the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; soc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:40,learn,learn,40,documentation/users-guide/Networking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md,1,['learn'],['learn']
Usability,"# OS X 10.11 El Capitan has just been released. One of the new features, System; # Integrity Protection, prevents modifying the base OS install, even with sudo.; # This prevents LLVM developers on OS X from being able to easily install new; # system compilers. The feature can be disabled, but to make it easier for; # developers to work without disabling SIP, this file can generate an Xcode; # toolchain. Xcode toolchains are a mostly-undocumented feature that allows; # multiple copies of low level tools to be installed to different locations, and; # users can easily switch between them. # Setting an environment variable TOOLCHAINS to the toolchain's identifier will; # result in /usr/bin/<tool> or xcrun <tool> to find the tool in the toolchain. # To make this work with Xcode 7.1 and later you can install the toolchain this; # file generates anywhere on your system and set EXTERNAL_TOOLCHAINS_DIR to the; # path specified by $CMAKE_INSTALL_PREFIX/Toolchains. # This file generates a custom install-xcode-toolchain target which constructs; # and installs a toolchain with the identifier in the pattern:; # org.llvm.${PACKAGE_VERSION}. This toolchain can then be used to override the; # system compiler by setting TOOLCHAINS=org.llvm.${PACKAGE_VERSION} in the; # in the environment. # Example usage:; # cmake -G Ninja -DLLVM_CREATE_XCODE_TOOLCHAIN=On; # -DCMAKE_INSTALL_PREFIX=$PWD/install; # ninja install-xcode-toolchain; # export EXTERNAL_TOOLCHAINS_DIR=$PWD/install/Toolchains; # export TOOLCHAINS=org.llvm.3.8.0svn. # `xcrun -find clang` should return the installed clang, and `clang --version`; # should show 3.8.0svn. if(NOT APPLE); return(); endif(). option(LLVM_CREATE_XCODE_TOOLCHAIN ""Create a target to install LLVM into an Xcode toolchain"" Off). if(NOT LLVM_CREATE_XCODE_TOOLCHAIN); return(); endif(). # XCODE_VERSION is set by CMake when using the Xcode generator, otherwise we need; # to detect it manually here.; if(NOT XCODE_VERSION); execute_process(; COMMAND xcodebuild -vers",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt:437,undo,undocumented,437,interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt,1,['undo'],['undocumented']
Usability,"# Policies on git repositories. This document explains our current policies around git repositories. Everything; not covered in this document is most likely a case-by-case decision. In these; cases please create an issue with the; [Infrastructure Working Group](https://github.com/llvm/llvm-iwg/issues). ## New GitHub repositories. Requirements for *new* repositories as part of the; [LLVM organisation on GitHub](https://github.com/llvm):. * The repo will be used for something related to the LLVM ecosystem or community.; * The repo contains a `README.md` explaining the contents.; * The repo contains a `CONTRIBUTING.md`, ideally copy this from; [llvm-project](https://github.com/llvm/llvm-project/blob/main/CONTRIBUTING.md).; * The repo contains a `LICENSE.TXT`, preferably copy this from; [llvm-project](https://github.com/llvm/llvm-project/blob/main/LICENSE.TXT).; Other licences need to be discussed case-by-case. If you want to integrate your project as part of the Monorepo, please take a; look at the; [Developer Policy](project:DeveloperPolicy.rst#Adding an Established Project To the LLVM Monorepo). To request a new repository, please create an issue with the; [Infrastructure Working Group](https://github.com/llvm/llvm-iwg/issues). ## Repo access on GitHub. Some 3rd party applications require write access to our GitHub organisation in; order to work properly. Typical examples are continuous integration services; reporting build results back to GitHub. We consider granting access to such; application if they provide benefits to the LLVM community and do not raise; privacy or security concerns. To request access please run an RFC on the mailing list and get community; feedback.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitRepositoryPolicy.md:1690,feedback,feedback,1690,interpreter/llvm-project/llvm/docs/GitRepositoryPolicy.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitRepositoryPolicy.md,1,['feedback'],['feedback']
Usability,"# Preface {.unnumbered}. In late 1994, we decided to learn; and investigate Object Oriented programming and C++ to better judge; the suitability of these relatively new techniques for scientific; programming. We knew that there is no better way to learn a new; programming environment than to use it to write a program that can; solve a real problem. After a few weeks, we had our first; histogramming package in C++. A few weeks later we had a rewrite of; the same package using the, at that time, very new template features; of C++. Again, a few weeks later we had another rewrite of the package; without templates since we could only compile the version with; templates on one single platform using a specific compiler. Finally,; after about four months we had a histogramming package that was faster; and more efficient than the well-known FORTRAN based HBOOK; histogramming package. This gave us enough confidence in the new; technologies to decide to continue the development. Thus was born; ROOT. Since its first public release at the end of 1995, ROOT has; enjoyed an ever-increasing popularity. Currently it is being used in; all major High Energy and Nuclear Physics laboratories around the; world to monitor, to store and to analyse data. In the other sciences; as well as the medical and financial industries, many people are using; ROOT. We estimate the current user base to be around several thousand; people. In 1997, Eric Raymond analysed in his paper ""The Cathedral and; the Bazaar"" the development method that makes Linux such a success.; The essence of that method is: ""release early, release often and; listen to your customers"". This is precisely how ROOT is being; developed. Over the last five years, many of our ""customers"" became; co-developers. Here we would like to thank our main co-developers and; contributors:. **Masaharu Goto** wrote the C++ interpreter CINT that was an; essential part of ROOT before ROOT 6. Despite being 8 time zones ahead; of us, we have the feelin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md:53,learn,learn,53,documentation/users-guide/Preface.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md,2,['learn'],['learn']
Usability,"# ROOT Basics #. Now that you have installed ROOT, what's this interactive shell thing; you're running ? It's like this: ROOT leads a double life. It has an; interpreter for macros (Cling [@Cling]) that you can run from the command; line or run like applications. But it is also an interactive shell that; can evaluate arbitrary statements and expressions. This is extremely; useful for debugging, quick hacking and testing. Let us first have a; look at some very simple examples. ## ROOT as calculator ##. You can even use the ROOT interactive shell in lieu of a calculator!; Launch the ROOT interactive shell with the command. ``` {.cpp}; > root; ```. on your Linux box. The prompt should appear shortly:. ``` {.cpp}; root [0]; ```. and let's dive in with the steps shown here:. ``` {.cpp}; root [0] 1+1; (int) 2; root [1] 2*(4+2)/12.; (double) 1.000000; root [2] sqrt(3.); (double) 1.732051; root [3] 1 > 2; (bool) false; root [4] TMath::Pi(); (double) 3.141593; root [5] TMath::Erf(.2); (double) 0.222703; ```. Not bad. You can see that ROOT offers you the possibility not only to; type in `C++` statements, but also advanced mathematical functions,; which live in the `TMath` namespace. Now let's do something more elaborated. A numerical example with the; well known geometrical series:. ``` {.cpp}; root [6] double x=.5; (double) 0.500000; root [7] int N=30; (int) 30; root [8] double geom_series=0; (double) 0.000000; root [9] for (int i=0;i<N;++i)geom_series+=TMath::Power(x,i); root [10] cout << TMath::Abs(geom_series - (1-TMath::Power(x,N-1))/(1-x)) <<endl;; 1.86265e-09; ```. Here we made a step forward. We even declared variables and used a *for*; control structure. Note that there are some subtle differences between; Cling and the standard `C++` language. You do not need the "";"" at the end; of line in interactive mode -- try the difference e.g. using the command; at line `root [6]`. ## Learn C++ at the ROOT prompt ##; Behind the ROOT prompt there is an interpreter based on a rea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:464,simpl,simple,464,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['simpl'],['simple']
Usability,"# ROOT Macros #. You know how other books go on and on about programming fundamentals and; finally work up to building a complete, working program ? Let's skip all; that. In this guide, we will describe macros executed by the ROOT C++; interpreter Cling. It is relatively easy to compile a macro, either as a pre-compiled; library to load into ROOT, or as a stand-alone application, by adding; some include statements for header file or some ""dressing code"" to any; macro. ## General Remarks on ROOT macros ##. If you have a number of lines which you were able to execute at the ROOT; prompt, they can be turned into a ROOT macro by giving them a name which; corresponds to the file name without extension. The general structure; for a macro stored in file `MacroName.C` is. ``` {.cpp}; void MacroName() {; < ...; your lines of C++ code; ... >; }; ```. The macro is executed by typing. ``` {.cpp}; > root MacroName.C; ```. at the system prompt, or executed using `.x`. ``` {.cpp}; > root; root [0] .x MacroName.C; ```. at the ROOT prompt. or it can be loaded into a ROOT session and then; be executed by typing. ``` {.cpp}; root [0].L MacroName.C; root [1] MacroName();; ```. at the ROOT prompt. Note that more than one macro can be loaded this; way, as each macro has a unique name in the ROOT name space. A small set; of options can help making your plot nicer. ``` {.cpp}; gROOT->SetStyle(""Plain""); // set plain TStyle; gStyle->SetOptStat(111111); // draw statistics on plots,; // (0) for no output; gStyle->SetOptFit(1111); // draw fit results on plot,; // (0) for no ouput; gStyle->SetPalette(57); // set color map; gStyle->SetOptTitle(0); // suppress title box; ...; ```. Next, you should create a canvas for graphical output, with size,; subdivisions and format suitable to your needs, see documentation of; class `TCanvas`:. ``` {.cpp}; TCanvas c1(""c1"",""<Title>"",0,0,400,300); // create a canvas, specify position and size in pixels; c1.Divide(2,2); //set subdivisions, called pads; c1.cd(1); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:179,guid,guide,179,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['guid'],['guide']
Usability,"# ROOT in Python #. ROOT offers the possibility to interface to Python via a set of bindings called; PyROOT.; Python is used in a wide variety of application areas and one of the most used; scripting languages today.; With the help of PyROOT it becomes possible to combine the power of a scripting; language with ROOT tools. Introductory material to Python is available from many; sources on the web, see e. g. http://docs.python.org. ## PyROOT ##. The access to ROOT classes and their methods in PyROOT is almost identical to C++; macros, except for the special language features of Python, most importantly dynamic; type declaration at the time of assignment. Coming back to our first example, simply; plotting a function in ROOT, the following C++ code:. ``` {.cpp}; TF1 *f1 = new TF1(""f2"",""[0]*sin([1]*x)/x"",0.,10.);; f1->SetParameter(0,1);; f1->SetParameter(1,1);; f1->Draw();; ```. in Python becomes:. ``` {.python}; import ROOT; f1 = ROOT.TF1(""f2"",""[0]*sin([1]*x)/x"",0.,10.); f1.SetParameter(0,1);; f1.SetParameter(1,1);; f1.Draw();; ```. A slightly more advanced example hands over data defined in the macro to the ROOT; class `TGraphErrors`. Note that a Python array can be used to pass data between; Python and ROOT. The first line in the Python script allows it to be executed; directly from the operating system, without the need to start the script from; python or the highly recommended powerful interactive shell ipython. The last line; in the python script is there to allow you to have a look at the graphical output; in the ROOT canvas before it disappears upon termination of the script. Here is the C++ version:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/TGraphFit.C; ```. In Python it looks like this:. ``` {.python}; @ROOT_INCLUDE_FILE macros/TGraphFit.py; ```. Comparing the C++ and Python versions in these two examples, it now should be; clear how easy it is to convert any ROOT Macro in C++ to a Python version. As another example, let us revisit macro3 from Chapter 4. A straigh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md:696,simpl,simply,696,documentation/primer/root_in_python.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md,1,['simpl'],['simply']
Usability,"# ROOT requirements for third-party Python packages. # PyROOT: Interoperability with numpy arrays; numpy; pandas. # TMVA: SOFIE; dm-sonnet ; python_version < ""3.13"" # used for GNNs, not available for Python 3.13 yet; graph_nets ; python_version < ""3.13"" # not available for Python 3.13 yet; onnx. # TMVA: PyMVA interfaces; scikit-learn; tensorflow<2.16 ; python_version < ""3.12""; torch<2.5 ; python_version < ""3.13"" # no torch version that fullfills version constraint available for Python 3.13; xgboost. # PyROOT: ROOT.Numba.Declare decorator; numba>=0.48 ; python_version < ""3.13"" # no numba available for Python 3.13 yet; cffi>=1.9.1. # Notebooks: ROOT C++ kernel; notebook>=4.4.1; metakernel>=0.20.0. # Distributed RDataFrame; pyspark>=2.4 # Spark backend; dask>=2022.08.1 # Dask backend; distributed>=2022.08.1 # Dask backend. # JsMVA: Jupyter notebook magic for TMVA; ipywidgets. # Look for CPU-only versions of PyTorch to avoid pulling CUDA in the CI docker images.; -f https://download.pytorch.org/whl/cpu/torch_stable.html; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/requirements.txt:330,learn,learn,330,requirements.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/requirements.txt,1,['learn'],['learn']
Usability,"# Support library for diagnostic handling in ROOT unit tests.; # This library is linked into all googletest executables. It installs; # a ROOT message handler that triggers test failures when diagnostics; # higher than kInfo are issued by tests.; # Stephan Hageboeck, CERN, 2022. if(NOT testsupport); return(); endif(). set(libname TestSupport); set(header_dir ROOT/). add_library(${libname} OBJECT src/TestSupport.cxx); target_include_directories(${libname} PUBLIC; $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/inc/>; $<INSTALL_INTERFACE:./>; ); target_link_libraries(${libname} PUBLIC Core gtest). # Installation of header and library:; set_target_properties(${libname} PROPERTIES PUBLIC_HEADER inc/${header_dir}/TestSupport.hxx); install(TARGETS ${libname}; EXPORT ${CMAKE_PROJECT_NAME}Exports; OBJECTS DESTINATION ${CMAKE_INSTALL_LIBDIR}/${libname}; PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/${header_dir}); set_property(GLOBAL APPEND PROPERTY ROOT_EXPORTED_TARGETS ${libname}). # Make it usable inside and outside of ROOT under a single name if somebody writes their own tests using ROOT_ADD_GTEST; add_library(ROOT::${libname} ALIAS ${libname}). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/CMakeLists.txt:1006,usab,usable,1006,core/testsupport/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/CMakeLists.txt,1,['usab'],['usable']
Usability,"# TODO: This file assumes the Clang toolchain so it'd be better if it lived in; # Clang, except there already is clang/runtime directory which contains; # similar although simpler functionality. We should figure out how to merge; # the two files. set(COMMON_CMAKE_ARGS ""-DHAVE_LLVM_LIT=ON;-DCLANG_RESOURCE_DIR=${CLANG_RESOURCE_DIR}""); foreach(proj ${LLVM_ENABLE_RUNTIMES}); set(proj_dir ""${CMAKE_CURRENT_SOURCE_DIR}/../../${proj}""); if(IS_DIRECTORY ${proj_dir} AND EXISTS ${proj_dir}/CMakeLists.txt); list(APPEND runtimes ${proj_dir}); else(); message(FATAL_ERROR ""LLVM_ENABLE_RUNTIMES requests ${proj} but directory not found: ${proj_dir}""); endif(); string(TOUPPER ""${proj}"" canon_name); STRING(REGEX REPLACE ""-"" ""_"" canon_name ${canon_name}); set(LLVM_EXTERNAL_${canon_name}_SOURCE_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../../${proj}""); endforeach(). function(get_compiler_rt_path path); foreach(entry ${runtimes}); get_filename_component(projName ${entry} NAME); if(""${projName}"" MATCHES ""compiler-rt""); set(${path} ${entry} PARENT_SCOPE); return(); endif(); endforeach(); endfunction(). include(LLVMExternalProjectUtils). if(NOT LLVM_BUILD_RUNTIMES); set(EXTRA_ARGS EXCLUDE_FROM_ALL); endif(). function(check_apple_target triple builtin_or_runtime); set(error ""\; compiler-rt for Darwin builds for all platforms and architectures using a \; single configuration. Specify only a single darwin triple (e.g. x86_64-apple-darwin) \; in your targets list (and not a triple for a specific platform such as macos). \; You can use variables such as COMPILER_RT_ENABLE_IOS and DARWIN_ios_ARCHS to \; control the specific platforms and architectures to build.""). set(seen_property ${builtin_or_runtime}_darwin_triple_seen); string(REPLACE ""-"" "";"" triple_components ${triple}); foreach(component ${triple_components}); string(TOLOWER ""${component}"" component_lower); if(component_lower MATCHES ""^darwin""); get_property(darwin_triple_seen GLOBAL PROPERTY ${seen_property}); if(darwin_triple_seen); message(FATAL_E",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt:172,simpl,simpler,172,interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,1,['simpl'],['simpler']
Usability,"# The Tutorials and Tests. This chapter is a guide to the examples that come with the installation; of ROOT. They are located in two directories: `$ROOTSYS/tutorials` and; `$ROOTSYS/test`. ## \$ROOTSYS/tutorials. ![](pictures/030001F9.png). The tutorials directory contains many example; scripts. *To have all examples working you must have write permission; and you will need to execute`hsimple.C` first*. If you do not have write; permission in the directory` $ROOTSYS/tutorials`, copy the entire; directory to your area. The script `hsimple.C` displays a histogram as; it is being filled, and creates a ROOT file used by the other examples. To execute it type:. ``` {.cpp}; $ cd $ROOTSYS/tutorials; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0] .x hsimple.C; ```. Now execute `demos.C`, which brings up the button bar shown on the left.; You can click on any button to execute another example. To see the; source, open the corresponding source file (for example `fit1.C`). Once; you are done, and want to quit the ROOT session, you can do so by typing; **`.q`**. ``` {.cpp}; root[] .x demos.C; root[] .q; ```. ## \$ROOTSYS/test. The test directory contains a set of examples that represent all areas; of the framework. When a new release is cut, the examples in this; directory are compiled and run to test the new release's backward; compatibility. We see these source files:. +-------------------+--------------------------------------------------------+; | `Makefile` | Makefile to build all test programs. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test progra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:45,guid,guide,45,documentation/users-guide/TutorialsandTests.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md,1,['guid'],['guide']
Usability,"# Trees. ## Why Should You Use a Tree?. In the ""Input/Output"" chapter, we saw how objects can be saved in ROOT; files. In case you want to store large quantities of same-class objects,; ROOT has designed the **`TTree`** and **`TNtuple`** classes specifically; for that purpose. The **`TTree`** class is optimized to reduce disk; space and enhance access speed. A **`TNtuple`** is a **`TTree`** that is; limited to only hold floating-point numbers; a **`TTree`** on the other; hand can hold all kind of data, such as objects or arrays in addition to; all the simple types. When using a **`TTree`**, we fill its branch buffers with leaf data and; the buffers are written to disk when it is full. Branches, buffers, and; leafs, are explained a little later in this chapter, but for now, it is; important to realize that each object is not written individually, but; rather collected and written a bunch at a time. This is where the **`TTree`** takes advantage of compression and will; produce a much smaller file than if the objects were written; individually. Since the unit to be compressed is a buffer, and the; **`TTree`** contains many same-class objects, the header of the objects; can be compressed. The **`TTree`** reduces the header of each object, but it still contains; the class name. Using compression, the class name of each same-class; object has a good chance of being compressed, since the compression; algorithm recognizes the bit pattern representing the class name. Using; a **`TTree`** and compression the header is reduced to about 4 bytes; compared to the original 60 bytes. However, if compression is turned; off, you will not see these large savings. The **`TTree`** is also used to optimize the data access. A tree uses a; hierarchy of branches, and each branch can be read independently from; any other branch. Now, assume that `Px` and `Py` are data members of the; event, and we would like to compute `Px2 + Py2` for every event; and histogram the result. If we had saved the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:558,simpl,simple,558,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"# Writing a TableGen Backend in Python. This tutorial is going to walk through creating a TableGen backend using Python. We are using Python to better fit into a notebook, but backends in LLVM are written in C++. The principles you learn here will still apply and you could port this tutorial to any language that has a JSON parser. This is the process in LLVM, using a C++ backend:; ```; TableGen source -> llvm-tblgen -> backend (within llvm-tblgen) -> results; ```; This is what we will be doing:; ```; TableGen source -> llvm-tblgen -> JSON -> Python -> results; ```. The backend here is ported from one of several in ""SQLGen"" which was written by Min-Yih Hsu.; * SQLGen C++ sources - https://github.com/mshockwave/SQLGen; * LLVM dev presentation - https://www.youtube.com/watch?v=UP-LBRbvI_U. I encourage you to use those resources to supplement this notebook. ## Compiling TableGen. Unlike the other tutorial notebooks we are not using the TableGen kernel. This is an iPython notebook and we're going to run `llvm-tblgen` as a subprocess. First let's find it, in the same way the TableGen kernel does. ```python; import os; import shutil. def find_tblgen():; path = os.environ.get(""LLVM_TBLGEN_EXECUTABLE""); if path is not None and os.path.isfile(path) and os.access(path, os.X_OK):; return path; else:; path = shutil.which(""llvm-tblgen""); if path is None:; raise OSError(""llvm-tblgen not found""); return path; ; _ = find_tblgen(); ```. If the above cell raises an exception, either put `llvm-tblgen` on your `PATH` or point to it using the `LLVM_TBLGEN_EXECUTABLE` environment variable. Alternatively, edit the code to use whatever path you want. Then we need to compile some TableGen by passing it to `llvm-tblgen`'s stdin. We will be using the option `--dump-json` and returning the JSON as a Python dictionary if the compilation succeeds. If it fails, we raise an exception. ```python; import subprocess; import tempfile; import json. def run_tblgen(src):; # Passing to stdin requires a file",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/sql_query_backend.md:232,learn,learn,232,interpreter/llvm-project/llvm/utils/TableGen/jupyter/sql_query_backend.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/sql_query_backend.md,1,['learn'],['learn']
Usability,"## GUI Libraries. ### Attributes editors. - The transparency sliders change the transparency only for the currently edited object. ### Object editing on canvas. - The ""move opaque"" way to edit object on canvas, has been extended to all kind of objects.; - When in move opaque mode, a canvas can show guide lines to place object relatively to each other. A new resource in `etc/system.rootrc` allows to turn the feature on or off: `Canvas.ShowGuideLines`.; - For a fine adjustment at the pixel level, the arrow keys can be used to move object on pad.; - The zoom on axis and on 2D histogram has been improved. A shaded area is shown instead of simple lines. Also it is possible to zoom a 2D histogram with a shaded rectangle. ### Saving Files; - When saving files from a canvas, the default file type is now .pdf instead of .ps, since pdf is probably becoming more popular than ps.; - In the ""File Save Dialog"", there is now a default file name and its extension (if a specific one is selected), and the name is highlighted, so when the user types something, only the file name is changed.; - The default file type can be changed with a new `Canvas.SaveAsDefaultType` option in `etc/system.rootrc` (default being pdf). ### ROOT browser and pad editor; - The Pad Editor is now embedded in the left tab of the browser instead of inside the canvas itself, so the layout of the canvas remains untouched when opening the editor. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v600/index.md:300,guid,guide,300,gui/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v600/index.md,2,"['guid', 'simpl']","['guide', 'simple']"
Usability,"## OPENUI5 Panel example. This is simplest way to use openui5 widget with RWebWindow. It is normal xml::View, but controller should be derived from rootui5/panel/Controller.; This class provides methods, which simplify handling of communication between server and client. First of all, when creating RWebWindow, one should configure panel name. Like:. auto win = ROOT::RWebWindow::Create();. win->SetPanelName(""localapp.view.TestPanel"");. Namespace ""localapp"" in this case corresponds to openui5 files, which will be loaded from current directory.; Therefore `""localapp.view.TestPanel""` means view, which will be loaded from `./view/TestPanel.view.xml` file. Controller is configured in the XML file and called `""localapp.controller.TestPanel""`.; Means it will be loaded from `./controller/TestPanel.controller.js` file. In the controller one use `onPanelInit` and `onPanelExit` methods to handle initialization and close of widget.; Method `panelSend` should be used to send string data to the server. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/panel/Readme.md:34,simpl,simplest,34,tutorials/webgui/panel/Readme.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/panel/Readme.md,2,['simpl'],"['simplest', 'simplify']"
Usability,"## Tree Libraries. ### TTreeReader. ROOT offers a new class `TTreeReader` that gives simple, safe and fast access to the content of a `TTree`.; Using it is trivial:. ``` {.cpp}; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"". void hsimpleReader() {; TH1F *myHist = new TH1F(""h1"",""ntuple"",100,-4,4);; TFile *myFile = TFile::Open(""hsimple.root"");. // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);. // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");. // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }. myHist->Draw();; }; ```. TTreeReader checks whether the type that you expect can be extracted from the tree's branch and will clearly complain if not.; It reads on demand: only data that are actually needed are read, there is no need for `SetBranchStatus()`, `SetBranchAddress()`, `LoadTree()` or anything alike.; It uses the memory management of TTree, removing possible double deletions or memory leaks and relieveing you from the need to manage the memory yourself.; It turns on the tree cache, accelerating the reading of data.; It has been extensively tested on all known types of TTree branches and is thus a generic, fits-all access method for data stored in TTrees. ### TTreePlayer. - The TEntryList for ||-Coord plot was not defined correctly. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v600/index.md:85,simpl,simple,85,tree/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v600/index.md,2,"['clear', 'simpl']","['clearly', 'simple']"
Usability,"## What is FOAM ?. FOAM is simplified version of multi-dimensional general; purpose Monte Carlo event generator (integrator) with hyper-cubical; ""foam of cells"". Certain features of full version of FOAM are omitted.; mFOAM is intended as an easy to use tool for MC; simulation/integration in few dimensions. It relies heavily on ROOT package,; borrowing persistency of classes from ROOT. mFOAM can be easily used from; the ROOT shell. For more difficult problems the full FOAM may be better. ### How to run application programs ?. The application program can be run in two modes: it can be simply; interpreted by CLING or compiled. The first method is simpler but; results in slower execution. The second method employs ACLiC -; The Automatic Compiler of Libraries, which automatizes the; process of compilation and linking. In $(ROOTSYS)/tutorials there are 3 demonstration programs:. #### foam_kanwa.C; is a simple example how to run FOAM in interactive; mode. To run this macro issue the following simple command from the; Linux shell:. ```; root foam_kanwa.C; ```. or from CLING:. ```; root [0] .x foam_kanwa.C; ```. Simulation will start and graphical canvas with plot; of the distribution function appear. In this example; we defined the distribution function simply as a global; function function Camel2. #### foam_demo.C; shows usage of FOAM in compiled mode, which is; the preferred method. The integrand function is defined; now as a Density method from class TFDISTR inheriting from; abstract class TFoamIntegrand. User can modify interface to; integrand function according to their needs but they should; always remember to define Density method which provides the; density distribution.; Enter CLING interpreter and type:. ```; root [0] gSystem->Load(""libFoam.so""); root [1] .x foam_demo.C+; ```. to load FOAM library, compile and execute macro foam_demo.C.; A shared object foam_demo_C.so is created in the current; directory. At the end of exploration phase FOAM object; including distr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/foam/index.md:1033,simpl,simple,1033,tutorials/foam/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/foam/index.md,1,['simpl'],['simple']
Usability,"## What the user must supply ###. The user must supply to M. - a valid implementation of the FCNBase base class. - parameters with their starting values. - expected uncertainties on the parameters. The input parameters can be simply defined via an; std::vector$<$double$>$, which means that all parameters are variables.; If the user wants fix a parameter or put limits on it before; minimization, they have to instantiate a MnUserParameters object and then; add parameters one by one, giving them a name, value, uncertainty. Once; all parameters are added to MnUserParameters, they can fix a parameter or; put limits on another one before handing them over to Minuit for; minimization. ### What the user can supply ###. Optionally the user can supply their own gradient calculator by; implementing the FCNGradientBase interface or supply a full covariance; matrix for input if one is available. The covariance matrix can be; supplied in form of a std::vector$<$double$>$ in packed storage format; (upper triangular), or in a more user-friendly way by using the; interface provided by the MnUserCovariance. ## Running a M minimization ##. Two use cases are addressed for minimization:. - The user just wants the function to be minimized in one go. - The user wants to minimize the $\mbox{FCN}$ in several; minimization steps, re-using the result of the preceeding; minimization in the next step and change parameters in between; (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main]. ### Direct usage of minimizers ###. Minimizers such as the VariableMetricMinimizer are designed as; state-less minimization engines, which means that they do not depend on; the current function and its parameters. Any $\mbox{FCN}$ function; can be minimized with the same minimizer. The interface is restricted to; minimization and no parameter interaction is possible. ### Using an application (MnMigrad) ###. MnMigrad uses the VariableMetricMinimizer for minimizati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:33365,user-friendly,user-friendly,33365,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['user-friendly'],['user-friendly']
Usability,"### Example project using cling as library. This example project uses cling as an external library.; It compiles code and calls it, moving values from the compiled part to the; interpreted part and back. It showcases how to use cling as a library, and shows how to set up a simple; CMake configuration that uses cling. ### How to build. After installing cling (say into /where/cling/is/installed), configure this; project using CMake like this:; ```bash; cmake -Dcling_DIR=/cling-install-dir/lib/cmake/cling /cling-source-dir/tools/cling/tools/demo; make && ./cling-demo; ```; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/demo/README.md:274,simpl,simple,274,interpreter/cling/tools/demo/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/demo/README.md,1,['simpl'],['simple']
Usability,"'s AST files are loaded ""lazily"" from disk. When an AST file is initially; loaded, Clang reads only a small amount of data from the AST file to establish; where certain important data structures are stored. The amount of data read in; this initial load is independent of the size of the AST file, such that a; larger AST file does not lead to longer AST load times. The actual header data; in the AST file --- macros, functions, variables, types, etc. --- is loaded; only when it is referenced from the user's code, at which point only that; entity (and those entities it depends on) are deserialized from the AST file.; With this approach, the cost of using an AST file for a translation unit is; proportional to the amount of code actually used from the AST file, rather than; being proportional to the size of the AST file itself. When given the `-print-stats` option, Clang produces statistics; describing how much of the AST file was actually loaded from disk. For a; simple ""Hello, World!"" program that includes the Apple ``Cocoa.h`` header; (which is built as a precompiled header), this option illustrates how little of; the actual precompiled header is required:. .. code-block:: none. *** AST File Statistics:; 895/39981 source location entries read (2.238563%); 19/15315 types read (0.124061%); 20/82685 declarations read (0.024188%); 154/58070 identifiers read (0.265197%); 0/7260 selectors read (0.000000%); 0/30842 statements read (0.000000%); 4/8400 macros read (0.047619%); 1/4995 lexical declcontexts read (0.020020%); 0/4413 visible declcontexts read (0.000000%); 0/7230 method pool entries read (0.000000%); 0 method pool misses. For this small program, only a tiny fraction of the source locations, types,; declarations, identifiers, and macros were actually deserialized from the; precompiled header. These statistics can be useful to determine whether the; AST file implementation can be improved by making more of the implementation; lazy. Precompiled headers can be chained. Wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:4367,simpl,simple,4367,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['simpl'],['simple']
Usability,"(#f22). [f22]: figures/TGraphErrors_Example.png ""f22""; <a name=""f22""></a>. ![Visualisation of data points with errors using the class TGraphErrors. \label{f22}][f22]. Make sure the file `ExampleData.txt` is available in the directory from; which you started ROOT. Inspect this file now with your favourite; editor, or use the command `less ExampleData.txt` to inspect the file,; you will see that the format is very simple and easy to understand.; Lines beginning with `#` are ignored. It is very convenient to add some; comments about the type of data. The data itself consist of lines with; four real numbers each, representing the x- and y- coordinates and their; errors of each data point. The argument of the method `Draw(""AP"")` is important here. Behind the scenes,; it tells the `TGraphPainter` class to show the axes and to plot markers at the; *x* and *y* positions of the specified data points. Note that this simple; example relies on the default settings of ROOT, concerning the size of; the canvas holding the plot, the marker type and the line colours and; thickness used and so on. In a well-written, complete example, all this; would need to be specified explicitly in order to obtain nice and well; readable results. A full chapter on graphs will explain many; more of the features of the class `TGraphErrors` and its relation to; other ROOT classes in much more detail. ## Histograms in ROOT ##. Frequency distributions in ROOT are handled by a set of classes derived; from the histogram class `TH1`, in our case `TH1F`. The letter `F`; stands for ""float"", meaning that the data type `float` is used to store; the entries in one histogram bin. ``` {.cpp}; root [0] TF1 efunc(""efunc"",""exp([0]+[1]*x)"",0.,5.);; root [1] efunc.SetParameter(0,1);; root [2] efunc.SetParameter(1,-1);; root [3] TH1F h(""h"",""example histogram"",100,0.,5.);; root [4] for (int i=0;i<1000;i++) {h.Fill(efunc.GetRandom());}; root [5] h.Draw();; ```. The first three lines of this example define a function, an ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:10095,simpl,simple,10095,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['simpl'],['simple']
Usability,"()` before use. Refer back to the other; example of the use of **`TPython`** that was given in ""Access to Python; from ROOT"". To show in detail how Python access can be used, an example Python; module is needed, as follows:. ``` {.cpp}; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; ```. This module can now be loaded into a Cling session, the class used to; instantiate objects, and their member functions called for showing how; different types can cross:. ``` {.cpp}; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; ```. Note that the `LoadMacro()` call makes the class automatically; available, such that it can be used directly. Otherwise, a; `gROOT->GetClass()` call is required first. #### Callbacks. The simplest way of setting a callback to Python from Cling, e.g. for a; button, is by providing the execution string. See for example; `tutorials/pyroot/demo.py` that comes with the ROOT installation:. ``` {.cpp}; # [..]; bar = ROOT.TControlBar('vertical','Demos'); bar.AddButton('Help on Demos',r'TPython::Exec(""execfile('demoshelp.py')"");','Click Here For Help on Running the Demos'); bar.AddButton('browser',r'TPython::Exec(""b = Tbrowser()"");','Start the ROOT browser'); # [..]; ```. Here, the callback is a string that will be interpreted by Cling to call; `TPython::Exec()`, which will, in turn, interpret and execute the string; given to it. Note the use of raw strings (the '`r`' in front of the; second argument string), in order to remove the need of escaping the; backslashes. #### Cling Commands. In interactive mode, the Python exception hook is used to mimic some of; the Cling commands available. These are: `.q`, **`.!`**, **`.x`**,; **`.L`**, **`.cd`**, **`.ls`**, **`.pwd`**, **`.?`** and **`.help`**.; Note that ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:18364,simpl,simplest,18364,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['simpl'],['simplest']
Usability,"(0); ```. If you have a divided pad, you need to set the scale on each of the; sub-pads. Setting it on the containing pad does not automatically; propagate to the sub-pads. Here is an example of how to set the log; scale for the x-axis on a canvas with four sub-pads:. ``` {.cpp}; root[] TCanvas MyCanvas(""MyCanvas"",""My Canvas""); root[] MyCanvas->Divide(2,2); root[] MyCanvas->cd(1); root[] gPad->SetLogx(); root[] MyCanvas->cd(2); root[] gPad->SetLogx(); root[] MyCanvas->cd(3); root[] gPad->SetLogx(); ```. ### WaitPrimitive method. When the `TPad::WaitPrimitive()` method is called with no arguments, it; will wait until a double click or any key pressed is executed in the; canvas. A call to `gSystem->Sleep(10)` has been added in the loop to; avoid consuming at all the CPU. This new option is convenient when; executing a macro. By adding statements like:. ``` {.cpp}; canvas->WaitPrimitive();; ```. You can monitor the progress of a running macro, stop it at convenient; places with the possibility to interact with the canvas and resume the; execution with a double click or a key press. ### Locking the Pad. You can make the **`TPad`** non-editable. Then no new objects can be; added, and the existing objects and the pad can not be changed with the; mouse or programmatically. By default the **`TPad`** is editable. ``` {.cpp}; TPad::SetEditable(kFALSE); ```. ## Graphical Objects. In this paragraph, we describe the various simple 2D graphical objects; defined in ROOT. Usually, one defines these objects with their; constructor and draws them with their `Draw()` method. Therefore, the; examples will be very brief. Most graphical objects have line and fill; attributes (color, width) that will be described in ""Graphical objects; attributes"". If the user wants more information, the class names are; given and they may refer to the online developer documentation. This is; especially true for functions and methods that set and get internal; values of the objects described here. By defa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:31236,resume,resume,31236,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['resume'],['resume']
Usability,"(CurTok == ',') {; getNextToken();; Step = ParseExpression();; if (!Step); return nullptr;; }. if (CurTok != tok_in); return LogError(""expected 'in' after for"");; getNextToken(); // eat 'in'. auto Body = ParseExpression();; if (!Body); return nullptr;. return std::make_unique<ForExprAST>(IdName, std::move(Start),; std::move(End), std::move(Step),; std::move(Body));; }. And again we hook it up as a primary expression:. .. code-block:: c++. static std::unique_ptr<ExprAST> ParsePrimary() {; switch (CurTok) {; default:; return LogError(""unknown token when expecting an expression"");; case tok_identifier:; return ParseIdentifierExpr();; case tok_number:; return ParseNumberExpr();; case '(':; return ParseParenExpr();; case tok_if:; return ParseIfExpr();; case tok_for:; return ParseForExpr();; }; }. LLVM IR for the 'for' Loop; --------------------------. Now we get to the good part: the LLVM IR we want to generate for this; thing. With the simple example above, we get this LLVM IR (note that; this dump is generated with optimizations disabled for clarity):. .. code-block:: llvm. declare double @putchard(double). define double @printstar(double %n) {; entry:; ; initial value = 1.0 (inlined into phi); br label %loop. loop: ; preds = %loop, %entry; %i = phi double [ 1.000000e+00, %entry ], [ %nextvar, %loop ]; ; body; %calltmp = call double @putchard(double 4.200000e+01); ; increment; %nextvar = fadd double %i, 1.000000e+00. ; termination test; %cmptmp = fcmp ult double %i, %n; %booltmp = uitofp i1 %cmptmp to double; %loopcond = fcmp one double %booltmp, 0.000000e+00; br i1 %loopcond, label %loop, label %afterloop. afterloop: ; preds = %loop; ; loop always returns 0.0; ret double 0.000000e+00; }. This loop contains all the same constructs we saw before: a phi node,; several expressions, and some basic blocks. Let's see how this fits; together. Code Generation for the 'for' Loop; ----------------------------------. The first part of codegen is very simple: we just output the sta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:19418,simpl,simple,19418,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['simpl'],['simple']
Usability,"(Double_t x); {; return 2*cos(x);; }. Int_t myfun(Int_t x); {; return x;; }. void fun(); {; ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; r[""myfund""]<<(Double_t (*)(Double_t))myfun;; r[""myfuni""]<<(Int_t (*)(Int_t))myfun;. r<<""print(myfund(0.0))"";; r<<""print(myfuni(1))"";; }; ~~~. ## Wrapping a class; You can wrap a class and expose it in R environment using only a pair of macrodefinitions and the template class; `ROOT::R::class_<>`; The `ROOTR_EXPOSED_CLASS(Class)` macro allows you to expose the class as a new datatype of R, but it has to be alongside; the `ROOTR_MODULE(Module)` macro which allows you to create an internal R module and make the class wrapping; To do this you must use inside the `ROOTR_MODULE` braces the class `ROOT::R::class_<>` and specify; each constructor, attribute or method that the class to export has.; Then the macrodefinition `LOAD_ROOTR_MODULE(Module)` can load the module and the class in R's environment.; You can find a more clear instruction by looking at a example below in Functor section. ##DataFrames; DataFrame? is a very important datatype in R and in ROOTR we have a class to manipulate; dataframes called TRDataFrame, with a lot of very useful operators overloaded to work with TRDataFrame's objects; in a similar way that in the R environment but from c++ in ROOT.; Example:. Lets to create need data to play with dataframe features. ~~~{.cxx}; ////////////////////////; //creating variables//; ////////////////////////; TVectorD v1(3);; std::vector<Double_t> v2(3);; std::array<Int_t,3> v3{ {1,2,3} };; std::list<std::string> names;. //////////////////////; //assigning values//; //////////////////////; v1[0]=1;; v1[1]=2;; v1[2]=3;. v2[0]=0.101;; v2[1]=0.202;; v2[2]=0.303;. names.push_back(""v1"");; names.push_back(""v2"");; names.push_back(""v3"");. ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; ~~~; In R the dataframe have associate to every column a label, in ROOTR you can have the same label using the class ROOT::R::Labe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md:7407,clear,clear,7407,bindings/r/doc/users-guide/ROOTR_Users_Guide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md,1,['clear'],['clear']
Usability,"(X1, X2) X3 = phi(X1, X2); ... = X3 + 4 X4 = phi(X3); ... = X4 + 4. This is still valid LLVM; the extra phi nodes are purely redundant, and will be; trivially eliminated by ``InstCombine``. The major benefit of this; transformation is that it makes many other loop optimizations, such as; ``LoopUnswitch``\ ing, simpler. You can read more in the; :ref:`loop terminology section for the LCSSA form <loop-terminology-lcssa>`. .. _passes-licm:. ``licm``: Loop Invariant Code Motion; ------------------------------------. This pass performs loop invariant code motion, attempting to remove as much; code from the body of a loop as possible. It does this by either hoisting code; into the preheader block, or by sinking code to the exit blocks if it is safe.; This pass also promotes must-aliased memory locations in the loop to live in; registers, thus hoisting and sinking ""invariant"" loads and stores. Hoisting operations out of loops is a canonicalization transform. It enables; and simplifies subsequent optimizations in the middle-end. Rematerialization; of hoisted instructions to reduce register pressure is the responsibility of; the back-end, which has more accurate information about register pressure and; also handles other optimizations than LICM that increase live-ranges. This pass uses alias analysis for two purposes:. #. Moving loop invariant loads and calls out of loops. If we can determine; that a load or call inside of a loop never aliases anything stored to, we; can hoist it or sink it like any other instruction. #. Scalar Promotion of Memory. If there is a store instruction inside of the; loop, we try to move the store to happen AFTER the loop instead of inside of; the loop. This can only happen if a few conditions are true:. #. The pointer stored through is loop invariant.; #. There are no stores or loads in the loop which *may* alias the pointer.; There are no calls in the loop which mod/ref the pointer. If these conditions are true, we can promote the loads and store",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:23955,simpl,simplifies,23955,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simplifies']
Usability,"(i = 0; i != 25; ++i). * Any use outside of the loop of an expression derived from the indvar is; changed to compute the derived value outside of the loop, eliminating the; dependence on the exit value of the induction variable. If the only purpose; of the loop is to compute the exit value of some derived expression, this; transformation will make the loop dead. This transformation should be followed by strength reduction after all of the; desired loop transformations have been performed. Additionally, on targets; where it is profitable, the loop could be transformed to count down to zero; (the ""do loop"" optimization). ``inline``: Function Integration/Inlining; -----------------------------------------. Bottom-up inlining of functions into callees. .. _passes-instcombine:. ``instcombine``: Combine redundant instructions; -----------------------------------------------. Combine instructions to form fewer, simple instructions. This pass does not; modify the CFG. This pass is where algebraic simplification happens. This pass combines things like:. .. code-block:: llvm. %Y = add i32 %X, 1; %Z = add i32 %Y, 1. into:. .. code-block:: llvm. %Z = add i32 %X, 2. This is a simple worklist driven algorithm. This pass guarantees that the following canonicalizations are performed on the; program:. #. If a binary operator has a constant operand, it is moved to the right-hand; side.; #. Bitwise operators with constant operands are always grouped so that shifts; are performed first, then ``or``\ s, then ``and``\ s, then ``xor``\ s.; #. Compare instructions are converted from ``<``, ``>``, ``≤``, or ``≥`` to; ``=`` or ``≠`` if possible.; #. All ``cmp`` instructions on boolean values are replaced with logical; operations.; #. ``add X, X`` is represented as ``mul X, 2`` ⇒ ``shl X, 1``; #. Multiplies with a constant power-of-two argument are transformed into; shifts.; #. … etc. This pass can also simplify calls to specific well-known function calls (e.g.; runtime library functions). For",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:19512,simpl,simplification,19512,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simplification']
Usability,"(see TStyle::SetStatFormat); - fitfmt - formatting for fit values in stat box, default 5.4g (see TStyle::SetFitFormat); - optdate - plot specified date on the canvas, 1 - current time, 2 - file creation date, 3 - file modification date; - utc - select timeZone to 'UTC'; - datex - X position of date; - datey - Y position of date; - optfile - plot file name on the canvas, 1 - file name, 2 - full file URL, 3 - object item name; - opttitle - disable/enable drawing of object title in the canvas; - nomenu - disable context menu; - notouch - disable touch events handling; - progress - switch progress display mode between 'off', 'on' and 'modal'. For instance:. - <https://root.cern/js/latest/?file=../files/hsimple.root&item=hpx;1>; - <https://root.cern/js/latest/?file=../files/hsimple.root&nobrowser&item=hpxpy;1&opt=colz>; - <https://root.cern/js/latest/?file=../files/hsimple.root&noselect&layout=grid2x2&item=hprof;1>. Following layouts are supported:. - simple - available space used for single object (default); - [flex](https://root.cern/js/latest/api.htm#url_syntax_flexible_layout) - creates as many frames as necessary, each can be individually moved/enlarged; - [tabs](https://root.cern/js/latest/api.htm#url_syntax_tabs_layout) - tabs for each object drawing; - [gridNxM](https://root.cern/js/latest/api.htm#url_syntax_grid_layout) - fixed-size grid with NxM frames; - vertN - N frames sorted in vertical direction (like gridi1xN); - horizN - N frames sorted in horizontal direction (like gridiNx1); - [vert121](https://root.cern//js/latest/api.htm#url_syntax_veritcal_layout) - 3 frames sorted in vertical direction, second frame divided on two sub-frames; - [horiz32_12](https://root.cern//js/latest/api.htm#url_syntax_horizontal_layout) - 2 horizontal frames with 3 and 2 subframes, and 1/3 and 2/3 as relative size. When specifying `files`, `items` or `opts` parameters, array of strings could be provided like `files=['file1.root','file2.root']`. One could skip quotes when specify",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:4166,simpl,simple,4166,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['simpl'],['simple']
Usability,") ;; ww->factory(""Gaussian::g(x[-10,10],mean[-10,10],sigma[3,0.1,10])"") ;. RooGenFitStudy gfs ;; gfs.setGenConfig(""g"",""x"",NumEvents(1000)) ;; gfs.setFitConfig(""g"",""x"",PrintLevel(-1)) ;. RooStudyManager mgr(*ww,gfs) ;. mgr.run(1000) ; // execute 1000 toys inline; mgr.runProof(10000,"""") ; // execute 10000 toys through PROOF-lite. gfs.summaryData()->Print() ;. Workspace and factory improvements. The workspace class RooWorkspace has been augmented with several; new features. The import() method now supports a new argument RenameAllVariablesExcept(const char* suffix, const char keepList) which; will rename all variables of the imported function by extended them with a supplied suffix,; except for a given list of variables, which are not renamed.; A new utility function importFromFile() has been added, which is similar to import, except that it take a string; specifier for the object to be imported rather than a reference. The string is expected to be of the form ; fileName:workspaceName:objectName and simplifies import of objects from other workspaces on file. The importFromFile; accepts all arguments accepted by the standard import() method.; Generic objects (inheriting from TObject) can now also be stored in the workspace under an alias name, rather; under their own name, which simplifies management of objects of types like TMatrixD that do not have a settable name. ws.import(matrix,""cov_matrix"") ;. New accessors have been added that return a RooArgSet of all elements of the workspace of a given type, e.g.; allVars(), allPdfs(). The Print() method now accepts option ""t"", which prints the contents tree-style instead of a flat list of components,; as illustrated below. *** Print() ***. p.d.f.s; -------; RooProdPdf::bkg[ ptBkgPdf * mllBkgPdf * effBkgPdf|pt ] = 0.267845; RooEfficiency::effBkgPdf[ cat=cut effFunc=effBkg ] = 0.76916; RooEfficiency::effSigPdf[ cat=cut effFunc=effSig ] = 0.899817; RooAddPdf::genmodel[ Nsig * sig + Nbkg * bkg ] = 0.502276; RooPolynomial::mllBkgP",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:2431,simpl,simplifies,2431,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,1,['simpl'],['simplifies']
Usability,") and set(). While named sets merely group objects logically, methods loadSnapshot and; saveSnapshot allow to make copies of the values, errors and 'constant' status of; sets of variable objects that live in the workspace. A newly added tutorial macro rf510_namedsets.C illustrates the functionality of both; of these features.; Improved printing of contents -- Many operator p.d.f. and function components now show; a more intuitive natural representation of their contents (these changes are mostly in the; respective p.d.f.s, but are most relevant in the context of a workspace). New object factory interface to workspace to facilitate script driven model definition; A object factory has been added to RooFit to simplify the process of creating p.d.f.; and function expressions consisting of multiple objects. The factory has two goals:; the first is to provide a back-end for higher level factories and tools to process; the creation of objects. The second is to provide a simple end-user language to; populate a RooWorkspace with function and p.d.f. objects. For the latter purpose the object creation language is executed through the factory() method; of a workspace object. RooWorkspace w(""w"") ;; RooAbsArg* arg = w.factory(""expression_goes_here"") ;. Basic Syntax; The rules at its simplest level are as follows. Expressions with square brackets create variables (discrete and continuous). ""m[-10,10]"" - Creates a RooRealVar named 'm' with range [-10,10]; ""m[5,-10,10]"" - Idem, but with initial value 5; ""m[5]"" - Creates a constant RooRealVar with name 'm' and value 5. ""tagCat[Lep,Kao,NT1,NT2]"" -- Creates a RooCategory with name tagCat and labeled states Lep,Kao,NT1,NT2; ""b0flav[B0=1,B0bar=-1]"" -- Creates a RooCategory with name b0flav and states B0 and B0bar with explicit index assignments. Expressions with parentheses create RooAbsArg function objects of any type. ""RooGaussian::g(x,m,s)"" -- Create a RooGaussian named g with variables x,m,s; This expression maps 1-1 to a createArg() ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:18456,simpl,simple,18456,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['simpl'],['simple']
Usability,") containing the bounds; information of the pointer. In the following example, ``__counted_by(count)``; annotation expresses the bounds of parameter p using another parameter count.; This model works naturally with many C interfaces and structs because the bounds; of a pointer is often available adjacent to the pointer itself, e.g., at another; parameter of the same function prototype, or at another field of the same struct; declaration. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, size_t count) {; // off-by-one error; for (size_t i = 0; i <= count; ++i); p[i] = i;; }. External bounds annotations include ``__counted_by``, ``__sized_by``, and; ``__ended_by``. These annotations do not change the pointer representation,; meaning they do not have ABI implications. * ``__counted_by(N)`` : The pointer points to memory that contains ``N``; elements of pointee type. ``N`` is an expression of integer type which can be; a simple reference to declaration, a constant including calls to constant; functions, or an arithmetic expression that does not have side effect. The; ``__counted_by`` annotation cannot apply to pointers to incomplete types or; types without size such as ``void *``. Instead, ``__sized_by`` can be used to; describe the byte count.; * ``__sized_by(N)`` : The pointer points to memory that contains ``N`` bytes.; Just like the argument of ``__counted_by``, ``N`` is an expression of integer; type which can be a constant, a simple reference to a declaration, or an; arithmetic expression that does not have side effects. This is mainly used for; pointers to incomplete types or types without size such as ``void *``.; * ``__ended_by(P)`` : The pointer has the upper bound of value ``P``, which is; one past the last element of the pointer. In other words, this annotation; describes a range that starts with the pointer that has this annotation and; ends with ``P`` which is the argument of the annotation. ``P`` itself may be; annotated with ``__",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:10078,simpl,simple,10078,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['simpl'],['simple']
Usability,") operator. For maximum flexibility and minimize memory; allocation, the coordinate system classes are templated on the scalar; type. To avoid exposing templated parameter to the users, typedefs are; defined for all types of vectors based on doubles. See in the examples; for all the possible types of vector classes, which can be constructed; by users with the available coordinate system types. #### Coordinate System Tag. The 2D and 3D points and vector classes can be associated to a tag; defining the coordinate system. This can be used to distinguish between; vectors of different coordinate systems like global or local vectors.; The coordinate system tag is a template parameter of the; **`ROOT::Math::`**`DisplacementVector3D` and; `ROOT::Math::PositionVector3D` (and also for 2D classes). A default tag; exists for users who do not need this functionality,; `ROOT::Math::DefaultCoordinateSystemTag`. #### Transformations. The transformations are modeled using simple (non-template) classes,; using double as the scalar type to avoid too large numerical errors. The; transformations are grouped in rotations (in 3 dimensions), Lorentz; transformations and Poincare transformations, which are; translation`/`rotation combinations. Each group has several members; which may model physically equivalent transformations but with different; internal representations. Transformation classes can operate on all type; of vectors by using the operator `() `or the operator `*` and the; transformations can be combined via the operator `*`. The available; transformations are:. - 3D rotation classes. - rotation described by a 3x3 matrix (**`ROOT::Math::Rotation3D`**). - rotation described by Euler angles (**`ROOT::Math::EulerAngles`**). - rotation described by a direction axis and an angle; (**`ROOT::Math::AxisAngle`**). - rotation described by a quaternion (**`ROOT::Math::Quaternion`**). - optimized rotation around `x` (**`ROOT::Math::RotationX`**), `y`; (**`ROOT::Math::RotationY`**) and `z` (",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:72529,simpl,simple,72529,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['simpl'],['simple']
Usability,")'); return LogError(""expected ')'"");; getNextToken(); // eat ).; return V;; }. This function illustrates a number of interesting things about the; parser:. 1) It shows how we use the LogError routines. When called, this function; expects that the current token is a '(' token, but after parsing the; subexpression, it is possible that there is no ')' waiting. For example,; if the user types in ""(4 x"" instead of ""(4)"", the parser should emit an; error. Because errors can occur, the parser needs a way to indicate that; they happened: in our parser, we return null on an error. 2) Another interesting aspect of this function is that it uses recursion; by calling ``ParseExpression`` (we will soon see that; ``ParseExpression`` can call ``ParseParenExpr``). This is powerful; because it allows us to handle recursive grammars, and keeps each; production very simple. Note that parentheses do not cause construction; of AST nodes themselves. While we could do it this way, the most; important role of parentheses are to guide the parser and provide; grouping. Once the parser constructs the AST, parentheses are not; needed. The next simple production is for handling variable references and; function calls:. .. code-block:: c++. /// identifierexpr; /// ::= identifier; /// ::= identifier '(' expression* ')'; static std::unique_ptr<ExprAST> ParseIdentifierExpr() {; std::string IdName = IdentifierStr;. getNextToken(); // eat identifier. if (CurTok != '(') // Simple variable ref.; return std::make_unique<VariableExprAST>(IdName);. // Call.; getNextToken(); // eat (; std::vector<std::unique_ptr<ExprAST>> Args;; if (CurTok != ')') {; while (true) {; if (auto Arg = ParseExpression()); Args.push_back(std::move(Arg));; else; return nullptr;. if (CurTok == ')'); break;. if (CurTok != ','); return LogError(""Expected ')' or ',' in argument list"");; getNextToken();; }; }. // Eat the ')'.; getNextToken();. return std::make_unique<CallExprAST>(IdName, std::move(Args));; }. This routine follows the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:9399,guid,guide,9399,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['guid'],['guide']
Usability,")) unless the two adds only have a single use.; There are a lot of cases that we're refusing to fold in (e.g.) 256.bzip2, for; example:. %indvar.next90 = add i64 %indvar89, 1 ;; Has 2 uses; %tmp96 = add i64 %tmp95, 1 ;; Has 1 use; %exitcond97 = icmp eq i64 %indvar.next90, %tmp96. We don't fold this because we don't want to introduce an overlapped live range; of the ivar. However if we can make this more aggressive without causing; performance issues in two ways:. 1. If *either* the LHS or RHS has a single use, we can definitely do the; transformation. In the overlapping liverange case we're trading one register; use for one fewer operation, which is a reasonable trade. Before doing this; we should verify that the llc output actually shrinks for some benchmarks.; 2. If both ops have multiple uses, we can still fold it if the operations are; both sinkable to *after* the icmp (e.g. in a subsequent block) which doesn't; increase register pressure. There are a ton of icmp's we aren't simplifying because of the reg pressure; concern. Care is warranted here though because many of these are induction; variables and other cases that matter a lot to performance, like the above.; Here's a blob of code that you can drop into the bottom of visitICmp to see some; missed cases:. { Value *A, *B, *C, *D;; if (match(Op0, m_Add(m_Value(A), m_Value(B))) && ; match(Op1, m_Add(m_Value(C), m_Value(D))) &&; (A == C || A == D || B == C || B == D)) {; errs() << ""OP0 = "" << *Op0 << "" U="" << Op0->getNumUses() << ""\n"";; errs() << ""OP1 = "" << *Op1 << "" U="" << Op1->getNumUses() << ""\n"";; errs() << ""CMP = "" << I << ""\n\n"";; }; }. //===---------------------------------------------------------------------===//. define i1 @test1(i32 %x) nounwind {; %and = and i32 %x, 3; %cmp = icmp ult i32 %and, 2; ret i1 %cmp; }. Can be folded to (x & 2) == 0. define i1 @test2(i32 %x) nounwind {; %and = and i32 %x, 3; %cmp = icmp ugt i32 %and, 1; ret i1 %cmp; }. Can be folded to (x & 2) != 0. SimplifyDemandedBits sh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:64574,simpl,simplifying,64574,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplifying']
Usability,")));. To test to see if ``instsimplify`` was specified, we can use the ``cl:bits::isSet``; function:. .. code-block:: c++. if (OptimizationBits.isSet(instsimplify)) {; ...; }. It's also possible to get the raw bit vector using the ``cl::bits::getBits``; function:. .. code-block:: c++. unsigned bits = OptimizationBits.getBits();. Finally, if external storage is used, then the location specified must be of; **type** ``unsigned``. In all other ways a `cl::bits`_ option is equivalent to a; `cl::list`_ option. .. _additional extra text:. Adding freeform text to help output; -----------------------------------. As our program grows and becomes more mature, we may decide to put summary; information about what it does into the help output. The help output is styled; to look similar to a Unix ``man`` page, providing concise information about a; program. Unix ``man`` pages, however often have a description about what the; program does. To add this to your CommandLine program, simply pass a third; argument to the `cl::ParseCommandLineOptions`_ call in main. This additional; argument is then printed as the overview information for your program, allowing; you to include any additional information that you want. For example:. .. code-block:: c++. int main(int argc, char **argv) {; cl::ParseCommandLineOptions(argc, argv, "" CommandLine compiler example\n\n""; "" This program blah blah blah...\n"");; ...; }. would yield the help output:. ::. **OVERVIEW: CommandLine compiler example. This program blah blah blah...**. USAGE: compiler [options] <input file>. OPTIONS:; ...; -help - display available options (-help-hidden for more); -o <filename> - Specify output filename. .. _grouping options into categories:. Grouping options into categories; --------------------------------. If our program has a large number of options it may become difficult for users; of our tool to navigate the output of ``-help``. To alleviate this problem we; can put our options into categories. This can be done by d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:23417,simpl,simply,23417,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simply']
Usability,"), the ``let`` statement has unusual power. For example:. .. code-block:: text. class C <int x> {; int Y = x;; int Yplus1 = !add(Y, 1);; int xplus1 = !add(x, 1);; }. let Y = 10 in {; def rec1 : C<5> {; }; }. def rec2 : C<5> {; let Y = 10;; }. In both cases, one where a top-level ``let`` is used to bind ``Y`` and one; where a local ``let`` does the same thing, the results are:. .. code-block:: text. def rec1 { // C; int Y = 10;; int Yplus1 = 11;; int xplus1 = 6;; }; def rec2 { // C; int Y = 10;; int Yplus1 = 11;; int xplus1 = 6;; }. ``Yplus1`` is 11 because the ``let Y`` is performed before the ``!add(Y,; 1)`` is resolved. Use this power wisely. Using Classes as Subroutines; ============================. As described in `Simple values`_, a class can be invoked in an expression; and passed template arguments. This causes TableGen to create a new anonymous; record inheriting from that class. As usual, the record receives all the; fields defined in the class. This feature can be employed as a simple subroutine facility. The class can; use the template arguments to define various variables and fields, which end; up in the anonymous record. Those fields can then be retrieved in the; expression invoking the class as follows. Assume that the field ``ret``; contains the final value of the subroutine. .. code-block:: text. int Result = ... CalcValue<arg>.ret ...;. The ``CalcValue`` class is invoked with the template argument ``arg``. It; calculates a value for the ``ret`` field, which is then retrieved at the; ""point of call"" in the initialization for the Result field. The anonymous; record created in this example serves no other purpose than to carry the; result value. Here is a practical example. The class ``isValidSize`` determines whether a; specified number of bytes represents a valid data size. The bit ``ret`` is; set appropriately. The field ``ValidSize`` obtains its initial value by; invoking ``isValidSize`` with the data size and retrieving the ``ret`` field; from th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:55321,simpl,simple,55321,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,"). The meaning and use of these parameters is test suite; dependent. .. _output-options:. OUTPUT OPTIONS; --------------. .. option:: -q, --quiet. Suppress any output except for test failures. .. option:: -s, --succinct. Show less output, for example don't show information on tests that pass.; Also show a progress bar, unless ``--no-progress-bar`` is specified. .. option:: -v, --verbose. Show more information on test failures, for example the entire test output; instead of just the test result. Each command is printed before it is executed. This can be valuable for; debugging test failures, as the last printed command is the one that failed.; Moreover, :program:`lit` inserts ``'RUN: at line N'`` before each; command pipeline in the output to help you locate the source line of; the failed command. .. option:: -vv, --echo-all-commands. Deprecated alias for -v. .. option:: -a, --show-all. Enable -v, but for all tests not just failed tests. .. option:: --no-progress-bar. Do not use curses based progress bar. .. option:: --show-unsupported. Show the names of unsupported tests. .. option:: --show-xfail. Show the names of tests that were expected to fail. .. _execution-options:. EXECUTION OPTIONS; -----------------. .. option:: --path=PATH. Specify an additional ``PATH`` to use when searching for executables in tests. .. option:: --vg. Run individual tests under valgrind (using the memcheck tool). The; ``--error-exitcode`` argument for valgrind is used so that valgrind failures; will cause the program to exit with a non-zero status. When this option is enabled, :program:`lit` will also automatically provide a; ""``valgrind``"" feature that can be used to conditionally disable (or expect; failure in) certain tests. .. option:: --vg-arg=ARG. When :option:`--vg` is used, specify an additional argument to pass to; :program:`valgrind` itself. .. option:: --vg-leak. When :option:`--vg` is used, enable memory leak checks. When this option is; enabled, :program:`lit` will also autom",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:3898,progress bar,progress bar,3898,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['progress bar'],['progress bar']
Usability,").; Images can be saved (canvas->Print) from within threads. Miscellaneous; TColor. CreateGradientColorTable now calls; TColor::InitializeColors(). This is needed because is some cases; TColor::InitializeColors() has not been called before and the; following erro messages were issued:; ; Warning in : color 1 already defined; Warning in : color 2 already defined; Warning in : color 3 already defined; [...]; ; TColor::AsHexString was not returning the proper value in case; of gray scale mode. Before this change gray scale mode did not work in; pictures generated in batch. TLatex. TLatex in now centered vertically like TText. When centered vertically, TLatex; was not aligned on the control box. Some additionnal tiny adjustment of one; pixel was also needed in order to look better when the text is enclosed in a box; like in TPaveText. TPaveText. The vertical text aligment is now done using the text alignment attributes; instead of the trick used before. Histograms' titles are look much better; centered vertically after this modification. TGraph; TGraph::DrawPanel is now implemented. TGraphErrors. The drawing option ""[]"" has been change to ""||"". The new; option ""[]"" is the same as ""||"" except that some ticks are; drawn at the end of the horizontal and vertical lines at the end of the error; bars. This new way of drawing the option ""[]"" shows better to which error; bar the additional tick marks belong. The following example, which has been; provided by Thomas Ullrich , shows it clearly. TGraphPolargram.cxx. An extra empty canvas was created each time a TGraphPolar was painted; in ""Not Editable"" mode. TPad. Improvments in TPad::BuildLegend: If the pad contains some; TMultiGraph or THStack the individual graphs or histograms; in them are automatically added to the TLegend produced by; TPad::BuildLegend. TGaxis. When drawn with the option; X+ or Y+ the histogram axis were wrong in; case of alphanumeric labels. The tick marks were in the right; place but the labels were not. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v522/index.html:3154,clear,clearly,3154,graf2d/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v522/index.html,1,['clear'],['clearly']
Usability,"); ```. ### Compile a Macro with the Compiler. A plethora of excellent compilers are available, both free and; commercial. We will refer to the `GCC` compiler in the following. In; this case, you have to include the appropriate headers in the code and; then exploit the *root-config* tool for the automatic settings of all; the compiler flags. *root-config* is a script that comes with ROOT; it; prints all flags and libraries needed to compile code and link it with; the ROOT libraries. In order to make the code executable stand-alone, an; entry point for the operating system is needed, in C++ this is the; procedure `int main();`. The easiest way to turn a ROOT macro code into; a stand-alone application is to add the following ""dressing code"" at the; end of the macro file. This defines the procedure main, the only purpose; of which is to call your macro:. ``` {.cpp}; int main() {; ExampleMacro();; return 0;; }; ```. To create a stand-alone program from a macro called `ExampleMacro.C`, simply type. ``` {.cpp}; > g++ -o ExampleMacro ExampleMacro.C `root-config --cflags --libs`; ```. and execute it by typing. ``` {.cpp}; > ./ExampleMacro; ```. This procedure will, however, not give access to the ROOT graphics, as; neither control of mouse or keyboard events nor access to the graphics; windows of ROOT is available. If you want your stand-alone application; have display graphics output and respond to mouse and keyboard, a; slightly more complex piece of code can be used. In the example below, a; macro `ExampleMacro_GUI` is executed by the ROOT class `TApplication`. As; a additional feature, this code example offers access to parameters; eventually passed to the program when started from the command line.; Here is the code fragment:. ``` {.cpp}; void StandaloneApplication(int argc, char** argv) {; // eventually, evaluate the application parameters argc, argv; // ==>> here the ROOT macro is called; ExampleMacro_GUI();; }; // This is the standard ""main"" of C++ starting; // a RO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:10884,simpl,simply,10884,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['simpl'],['simply']
Usability,"); or will be set to the address of the histogram read from the file.; - Add the ability to store the 'same' object several time (assumingly with different data) in a single buffer. Instead of. ```; while(...) {; TObjArray arr;; ... update the content of ""arr""; buffer << arr;; }; ```; which would only really stream the array at the first iteration because it will be detected has having the same address and thus assumed to be the same object. We can now do:; ```; while(...) {; TObjArray arr;; ... update the content of ""arr""; buffer.WriteObject(&arr, kFALSE);; }; ```; where the last argument of WriteObject tells the buffer do *not* remember this object's address and to always stream it. This feature is also available via WriteObjectAny. - Added a new mechanism for providing clean forward-compatibility breaks in a ``TTree`` (i.e., a newer version of ROOT writes a ``TTree`` an older version cannot read). When future versions of ROOT utilize an IO feature that this version does not support, ROOT will provide a clear error message instead of crashing or returning garbage data. In future ROOT6 releases, forward-compatibility breaks will only be allowed if a non-default feature is enabled via the ``ROOT::Experimental`` namespace; it is expected ROOT7 will enable forward-compatibility breaks by default. - When a file using an unsupported file format feature is encountered, the error message will be similar to the following:; ```; Error in <TBasket::Streamer>: The value of fIOBits (00000000000000000000000001111110) contains unknown flags (supported flags are 00000000000000000000000000000001), indicating this was written with a newer version of ROOT utilizing critical IO features this version of ROOT does not support. Refusing to deserialize.; ```; - When an older version of ROOT, without this logic, encounters the file, the error message will be similar to the following:; ```; Error in <TBasket::Streamer>: The value of fNevBufSize is incorrect (-72) ; trying to recover by set",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:7649,clear,clear,7649,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['clear'],['clear']
Usability,"); unreachable. .. _coro.suspend:; .. _suspend points:. 'llvm.coro.suspend' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i8 @llvm.coro.suspend(token <save>, i1 <final>). Overview:; """""""""""""""""". The '``llvm.coro.suspend``' marks the point where execution of a; switched-resume coroutine is suspended and control is returned back; to the caller. Conditional branches consuming the result of this; intrinsic lead to basic blocks where coroutine should proceed when; suspended (-1), resumed (0) or destroyed (1). Arguments:; """""""""""""""""""". The first argument refers to a token of `coro.save` intrinsic that marks the; point when coroutine state is prepared for suspension. If `none` token is passed,; the intrinsic behaves as if there were a `coro.save` immediately preceding; the `coro.suspend` intrinsic. The second argument indicates whether this suspension point is `final`_.; The second argument only accepts constants. If more than one suspend point is; designated as final, the resume and destroy branches should lead to the same; basic blocks. Example (normal suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. %0 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %0, label %suspend [i8 0, label %resume; i8 1, label %cleanup]. Example (final suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. while.end:; %s.final = call i8 @llvm.coro.suspend(token none, i1 true); switch i8 %s.final, label %suspend [i8 0, label %trap; i8 1, label %cleanup]; trap:; call void @llvm.trap(); unreachable. Semantics:; """""""""""""""""""". If a coroutine that was suspended at the suspend point marked by this intrinsic; is resumed via `coro.resume`_ the control will transfer to the basic block; of the 0-case. If it is resumed via `coro.destroy`_, it will proceed to the; basic block indicated by the 1-case. To suspend, coroutine proceed to the; default label. If suspend intrinsic is marked as final, it can consider the `true` branch; unreachable and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:50575,resume,resume,50575,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,");; h->SetDirectory(0);; h->FillRandom(""gaus"", 1000);; return h;; }. TProcPool pool;; auto hist = pool.MapReduce(CreateAndFillHists, 10, PoolUtils::ReduceObjects);; hist->DrawClone();; }; ```. Tutorials illustrating other usages of the new class TProcPool are available under tutorials/multicore. ## Language Bindings. ### Notebooks; We provided integration of ROOT with the Jupyter technology, integrating ROOT with Python Notebooks and providing a ROOT Kernel like functionality - de facto an enhanced C++ web based shell. Tab completion, output and graphics inlining have been added. These functionalities are automatically available upon import of the ROOT module in a Notebook or at startup of a ROOT prompt kernel.; We made it easier to use ROOT notebooks locally, by providing a 'root --notebook' command option to start a local notebook server customised with all the ROOT features. New tutorials and code examples have been provided. The simplest example showing the integration of ROOT with the notebook technology can be found [here](https://root.cern.ch/notebooks/HowTos/HowTo_ROOT-Notebooks.html) and many more snippets [here](https://root.cern.ch/code-examples#notebooks). Support for capturing large outputs (stderr/stdout) coming from C++ libraries has been added. ## JavaScript ROOT. - support registered in THttpServer commands with arguments.; - provide workaround for websites using require.js and older jquery-ui; - support custom requests to remote objects, demonstrated in httptextlog.C tutorial; - rewrite draw.htm (page for individual object drawing) to support all custom features as main gui does; - See also the [JSRoot 3.9 examples page](https://root.cern.ch/js/3.9/) and the [JSRoot 3.9 release notes](https://github.com/linev/jsroot/releases/tag/3.9). ## Class Reference Guide. The ROOT [reference guide](https://root.cern.ch/doc/master/index.html) is moving; to the Doxygen system. Doxygen is the de-facto standard for code documentation. It offers; many nice features",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:22695,simpl,simplest,22695,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['simpl'],['simplest']
Usability,"* The staging buildmaster at `<https://lab.llvm.org/staging>`_. All builders; attached to this machine will be completely silent by default when the build; is broken. This buildmaster is reconfigured every two hours with any new; commits from the llvm-zorg repository. In order to remain connected to the main buildmaster (and thus notify; developers of failures), a builbot must:. * Be building a supported configuration. Builders for experimental backends; should generally be attached to staging buildmaster.; * Be able to keep up with new commits to the main branch, or at a minimum; recover to tip of tree within a couple of days of falling behind. Additionally, we encourage all bot owners to point their bots towards the; staging master during maintenance windows, instability troubleshooting, and; such. Roles & Expectations; ====================. Each buildbot has an owner who is the responsible party for addressing problems; which arise with said buildbot. We generally expect the bot owner to be; reasonably responsive. For some bots, the ownership responsibility is split between a ""resource owner""; who provides the underlying machine resource, and a ""configuration owner"" who; maintains the build configuration. Generally, operational responsibility lies; with the ""config owner"". We do expect ""resource owners"" - who are generally; the contact listed in a workers attributes - to proxy requests to the relevant; ""config owner"" in a timely manner. Most issues with a buildbot should be addressed directly with a bot owner; via email. Please CC `Galina Kistanova <mailto:gkistanova@gmail.com>`_. Steps To Add Builder To LLVM Buildbot; =====================================; Volunteers can provide their build machines to work as build workers to; public LLVM Buildbot. Here are the steps you can follow to do so:. #. Check the existing build configurations to make sure the one you are; interested in is not covered yet or gets built on your computer much; faster than on the existing ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:1633,responsiv,responsive,1633,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['responsiv'],['responsive']
Usability,"*)malloc(sizeof(int) * nelems);; sbuf->count = nelems;; }. To implement this rule, the compiler requires a linear representation of; statements to understand the ordering and the adjacency between the two or more; assignments. The Clang CFG is used to implement this analysis as Clang CFG; provides a linear view of statements within each ``CFGBlock`` (Clang; ``CFGBlock`` represents a single basic block in a source-level CFG). Bounds check optimizations; ==========================. In ``-fbounds-safety``, the Clang frontend emits run-time checks for every; memory dereference if the type system or analyses in the frontend couldn’t; verify its bounds safety. The implementation relies on LLVM optimizations to; remove redundant run-time checks. Using this optimization strategy, if the; original source code already has bounds checks, the fewer additional checks; ``-fbounds-safety`` will introduce. The LLVM ``ConstraintElimination`` pass is; design to remove provable redundant checks (please check Florian Hahn’s; presentation in 2021 LLVM Dev Meeting and the implementation to learn more). In; the following example, ``-fbounds-safety`` implicitly adds the redundant bounds; checks that the optimizer can remove:. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, size_t count) {; for (size_t i = 0; i < count; ++i) {; // implicit bounds checks:; // if (p + i < p || p + i + 1 > p + count) trap();; p[i] = i;; }; }. ``ConstraintElimination`` collects the following facts and determines if the; bounds checks can be safely removed:. * Inside the for-loop, ``0 <= i < count``, hence ``1 <= i + 1 <= count``.; * Pointer arithmetic ``p + count`` in the if-condition doesn’t wrap.; * ``-fbounds-safety`` treats pointer arithmetic overflow as deterministically; two’s complement computation, not an undefined behavior. Therefore,; getelementptr does not typically have inbounds keyword. However, the compiler; does emit inbounds for ``p + count`` in this case because; ``_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:6613,learn,learn,6613,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['learn'],['learn']
Usability,"**tools**; that will contain that program's source code. **test**. This subdirectory should contain tests that verify that your code works; correctly. Automated tests are especially useful. Currently, the LLVM build system provides basic support for tests. The LLVM; system provides the following:. * LLVM contains regression tests in ``llvm/test``. These tests are run by the; :doc:`Lit <CommandGuide/lit>` testing tool. This test procedure uses ``RUN``; lines in the actual test case to determine how to run the test. See the; :doc:`TestingGuide` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefiles will only need to define a few; variables. Below is a list of the variables one can set and what they can; do:. Required Variables; ------------------. ``LEVEL``. This variable is the relative path from this ``Makefile`` to the top; directory of your project's source code. For example, if your source code; is in ``/tmp/src``, then the ``Makefile`` in ``/tmp/src/jump/high``; would set ``LEVEL`` to ``""../..""``. Variables for Building Subdirectories; -------------------------------------. ``DIRS``. This is a space separated list of subdirectories that should be built. They; will be built, one at a time, in the order specified. ``PARALLEL_DIRS``. This is a list of dir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:3902,simpl,simply,3902,interpreter/llvm-project/llvm/docs/Projects.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst,1,['simpl'],['simply']
Usability,"*, which is the number of; times any of the backedges is taken before the loop. It is one less than; the trip count for executions that enter the header. .. _loopinfo:. LoopInfo; ========. LoopInfo is the core analysis for obtaining information about loops.; There are few key implications of the definitions given above which; are important for working successfully with this interface. * LoopInfo does not contain information about non-loop cycles. As a; result, it is not suitable for any algorithm which requires complete; cycle detection for correctness. * LoopInfo provides an interface for enumerating all top level loops; (e.g. those not contained in any other loop). From there, you may; walk the tree of sub-loops rooted in that top level loop. * Loops which become statically unreachable during optimization *must*; be removed from LoopInfo. If this can not be done for some reason,; then the optimization is *required* to preserve the static; reachability of the loop. .. _loop-terminology-loop-simplify:. Loop Simplify Form; ==================. The Loop Simplify Form is a canonical form that makes; several analyses and transformations simpler and more effective.; It is ensured by the LoopSimplify; (:ref:`-loop-simplify <passes-loop-simplify>`) pass and is automatically; added by the pass managers when scheduling a LoopPass.; This pass is implemented in; `LoopSimplify.h <https://llvm.org/doxygen/LoopSimplify_8h_source.html>`_.; When it is successful, the loop has:. * A preheader.; * A single backedge (which implies that there is a single latch).; * Dedicated exits. That is, no exit block for the loop; has a predecessor that is outside the loop. This implies; that all exit blocks are dominated by the loop header. .. _loop-terminology-lcssa:. Loop Closed SSA (LCSSA); =======================. A program is in Loop Closed SSA Form if it is in SSA form; and all values that are defined in a loop are used only inside; this loop. Programs written in LLVM IR are always in SSA for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:9928,simpl,simplify,9928,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['simpl'],['simplify']
Usability,"*`TStyle`** setters or getters. Some functions have an extended; description, in particular:. - `TStyle::SetLabelFont`. - `TStyle::SetLineStyleString`: set the format of dashed lines. - `TStyle::SetOptStat`. - `TStyle::SetPalette` to change the colors palette. - `TStyle::SetTitleOffset`. - `TStyle::SetOptDate(Int_t optdate)` to support several date formats.; If `optdate` is non-null, the current date/time will be printed in; the canvas. The position of the date string can be controlled by:; `optdate = 10*format `+` mode`. - `mode = 1` the date is printed in the bottom/left corner. - `mode = 2` date is printed in the bottom/right corner. - `mode = 3` date is printed in the top/right corner. - `format = 0` (default) date format is like: ""Wed Sep 25 17:10:35; 2002"". - `format = 1` date format is: ""2002-09-25"". - `format = 2` date format is: ""2002-09-25 17:10:35"". ## 3D Viewers. ROOT provides several viewers capable of displaying 3D content:. - the Pad - simple line drawing using **`TPad`** and associated; projection class **`TView`**;. - GL Viewer - high quality and performance viewer(See ""The GL; Viewer"");. - X3D viewer - simple legacy viewer (See ""The X3D Viewer"");. - GL-in-pad - combination of basic GL viewer in **`TPad`**, with no; hardware acceleration. The X3D and GL viewers are created as external windows, associated with; a pad, and displaying the same content as it. Only these external; viewers are detailed here - for Pad (**`TPad`**, **`TView`** classes); you should refer to ""Graphical Containers: Canvas and Pad"" and the class; definitions. All viewers use a common architecture to publish 3D objects to the; viewer - described in ""Common 3D Viewer Architecture"" below. In most; cases, you will **not** need to use this, working instead with a; package, such as the ""The Geometry Package"", which provides; comprehensive, high level functionality to create and place objects into; complex 3D scenes, and uses the viewer architecture internally to show; the result in y",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:105143,simpl,simple,105143,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simple']
Usability,"++++++++++................. ...............++++++++++++++++; ++++++++++++.................. .................++++++++++++++; +++++++++.................. .................+++++++++++++; ++++++........ . ......... ..++++++++++++; ++............ ...... ....++++++++++; .............. ...++++++++++; .............. ....+++++++++; .............. .....++++++++; ............. ......++++++++; ........... .......++++++++; ......... ........+++++++; ......... ........+++++++; ......... ....+++++++; ........ ...+++++++; ....... ...+++++++; ....+++++++; .....+++++++; ....+++++++; ....+++++++; ....+++++++; Evaluated to 0.000000; ready> ^D. At this point, you may be starting to realize that Kaleidoscope is a; real and powerful language. It may not be self-similar :), but it can be; used to plot things that are!. With this, we conclude the ""adding user-defined operators"" chapter of; the tutorial. We have successfully augmented our language, adding the; ability to extend the language in the library, and we have shown how; this can be used to build a simple but interesting end-user application; in Kaleidoscope. At this point, Kaleidoscope can build a variety of; applications that are functional and can call functions with; side-effects, but it can't actually define and mutate a variable itself. Strikingly, variable mutation is an important feature of some languages,; and it is not at all obvious how to `add support for mutable; variables <LangImpl07.html>`_ without having to add an ""SSA construction""; phase to your front-end. In the next chapter, we will describe how you; can add variable mutation without building SSA in your front-end. Full Code Listing; =================. Here is the complete code listing for our running example, enhanced with; the support for user-defined operators. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. On some platforms, yo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:26130,simpl,simple,26130,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simple']
Usability,"+++++++. .. option:: -all. Implies most other options. .. option:: -section-contribs. Dump section contributions. .. option:: -section-headers. Dump image section headers. .. option:: -section-map. Dump section map. .. option:: -string-table. Dump PDB string table. .. _bytes_subcommand:. bytes; ~~~~~. USAGE: :program:`llvm-pdbutil` bytes [*options*] <input PDB file>. .. program:: llvm-pdbutil bytes. Summary; ^^^^^^^. Like the **dump** subcommand, the **bytes** subcommand displays low level; information about the structure of a PDB file, but it is used for even deeper; forensics. The **bytes** subcommand finds various structures in a PDB file; based on the command line options specified, and dumps them in hex. Someone; working on support for emitting PDBs would use this heavily, for example, to; compare one PDB against another PDB to ensure byte-for-byte compatibility. It; is not enough to simply compare the bytes of an entire file, or an entire stream; because it's perfectly fine for the same structure to exist at different; locations in two different PDBs, and ""finding"" the structure is half the battle. Options; ^^^^^^^. MSF File Options; ++++++++++++++++. .. option:: -block-range=<start[-end]>. Dump binary data from specified range of MSF file blocks. .. option:: -byte-range=<start[-end]>. Dump binary data from specified range of bytes in the file. .. option:: -fpm. Dump the MSF free page map. .. option:: -stream-data=<string>. Dump binary data from the specified streams. Format is SN[:Start][@Size].; For example, `-stream-data=7:3@12` dumps 12 bytes from stream 7, starting; at offset 3 in the stream. PDB Stream Options; ++++++++++++++++++. .. option:: -name-map. Dump bytes of PDB Name Map. DBI Stream Options; ++++++++++++++++++. .. option:: -ec. Dump the edit and continue map substream of the DBI stream. .. option:: -files. Dump the file info substream of the DBI stream. .. option:: -modi. Dump the modi substream of the DBI stream. .. option:: -sc. Dump section co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst:11325,simpl,simply,11325,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,1,['simpl'],['simply']
Usability,"+--------------------------------------+; | ... `->` ... | `DATA` | Data bytes associated to the object |; +--------------------+-------------------+--------------------------------------+. You see a reference to **`TKey`**. It is explained in detail in the next; section. ### The Class Description List (StreamerInfo List). The histogram records are followed by the `StreamerInfo` list of class; descriptions. The list contains the description of each class that has; been written to file. ``` {.cpp}; 20010404/092347 At:5854 N=2390 StreamerInfo CX = 3.41; ```. The class description is recursive, because to fully describe a class,; its ancestors and object data members have to be described also. In; `demo.root`, the class description list contains the description for:. - **`TH1F`**. - all classes in the **`TH1F`** inheritance tree. - all classes of the object data members. - all classes in the object data members' inheritance tree. This description is implemented by the **`TStreamerInfo`** class`,` and; is often referred to as simply `StreamerInfo`. You can print a file's; `StreamerInfo`list with the `TFile::ShowStreamerInfo` method. Below is; an example of the output. Only the first line of each class description; is shown. The `demo.root` example contains only **`TH1F`** objects. Here; we see the recursive nature of the class description; it contains the; `StreamerInfo`of all the classes needed to describe **`TH1F`**. ``` {.cpp}; root[] f.ShowStreamerInfo(); StreamerInfo for class: TH1F, version=1; BASE TH1 offset=0 type= 0 1-Dim histogram base class; BASE TArrayF offset=0 type= 0 Array of floats. StreamerInfo for class: TH1, version=3; BASE TNamed offset=0 type=67 The basis for named object(name,title); BASE TAttLine offset=0 type=0 Line attributes; BASE TAttFill offset=0 type=0 Fill area attributes; BASE TAttMarker offset=0 type=0 Marker attributes; Int_t fNcells offset=0 type=3 number bins(1D),cells(2D)+U/Overflows; TAxis fXaxis offset=0 type=61 X axis descriptor; T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:11107,simpl,simply,11107,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simply']
Usability,"+. KaleidoscopeJIT(); : TM(EngineBuilder().selectTarget()), DL(TM->createDataLayout()),; ObjectLayer([]() { return std::make_shared<SectionMemoryManager>(); }),; CompileLayer(ObjectLayer, SimpleCompiler(*TM)),; OptimizeLayer(CompileLayer,; [this](std::shared_ptr<Module> M) {; return optimizeModule(std::move(M));; }),; CompileCallbackManager(; orc::createLocalCompileCallbackManager(TM->getTargetTriple(), 0)),; CODLayer(OptimizeLayer,; [this](Function &F) { return std::set<Function*>({&F}); },; *CompileCallbackManager,; orc::createLocalIndirectStubsManagerBuilder(; TM->getTargetTriple())) {; llvm::sys::DynamicLibrary::LoadLibraryPermanently(nullptr);; }. Next we have to update our constructor to initialize the new members. To create; an appropriate compile callback manager we use the; createLocalCompileCallbackManager function, which takes a TargetMachine and an; ExecutorAddr to call if it receives a request to compile an unknown; function. In our simple JIT this situation is unlikely to come up, so we'll; cheat and just pass '0' here. In a production quality JIT you could give the; address of a function that throws an exception in order to unwind the JIT'd; code's stack. Now we can construct our CompileOnDemandLayer. Following the pattern from; previous layers we start by passing a reference to the next layer down in our; stack -- the OptimizeLayer. Next we need to supply a 'partitioning function':; when a not-yet-compiled function is called, the CompileOnDemandLayer will call; this function to ask us what we would like to compile. At a minimum we need to; compile the function being called (given by the argument to the partitioning; function), but we could also request that the CompileOnDemandLayer compile other; functions that are unconditionally called (or highly likely to be called) from; the function being called. For KaleidoscopeJIT we'll keep it simple and just; request compilation of the function that was called. Next we pass a reference to; our CompileCallback",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst:5854,simpl,simple,5854,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,1,['simpl'],['simple']
Usability,"+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int zlight; // z position of fictive light source, applies only for rainbowed display; // modes with shading according to light; i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:77988,simpl,simple,77988,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['simpl'],['simple']
Usability,", a2, a3, a4; extern int b0, b1, b2, b3, b4; ; void f () { /* this can be optimized to four additions... */ ; b4 = a4 + a3 + a2 + a1 + a0; ; b3 = a3 + a2 + a1 + a0; ; b2 = a2 + a1 + a0; ; b1 = a1 + a0; ; } . This requires reassociating to forms of expressions that are already available,; something that reassoc doesn't think about yet. //===---------------------------------------------------------------------===//. These two functions should generate the same code on big-endian systems:. int g(int *j,int *l) { return memcmp(j,l,4); }; int h(int *j, int *l) { return *j - *l; }. this could be done in SelectionDAGISel.cpp, along with other special cases,; for 1,2,4,8 bytes. //===---------------------------------------------------------------------===//. It would be nice to revert this patch:; http://lists.llvm.org/pipermail/llvm-commits/Week-of-Mon-20060213/031986.html. And teach the dag combiner enough to simplify the code expanded before ; legalize. It seems plausible that this knowledge would let it simplify other; stuff too. //===---------------------------------------------------------------------===//. For vector types, DataLayout.cpp::getTypeInfo() returns alignment that is equal; to the type size. It works but can be overly conservative as the alignment of; specific vector types are target dependent. //===---------------------------------------------------------------------===//. We should produce an unaligned load from code like this:. v4sf example(float *P) {; return (v4sf){P[0], P[1], P[2], P[3] };; }. //===---------------------------------------------------------------------===//. Add support for conditional increments, and other related patterns. Instead; of:. 	movl 136(%esp), %eax; 	cmpl $0, %eax; 	je LBB16_2	#cond_next; LBB16_1:	#cond_true; 	incl _foo; LBB16_2:	#cond_next. emit:; 	movl	_foo, %eax; 	cmpl	$1, %edi; 	sbbl	$-1, %eax; 	movl	%eax, _foo. //===---------------------------------------------------------------------===//. Combine: a = sin(x), b = cos(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:3562,simpl,simplify,3562,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplify']
Usability,", and several books on; the subject that you can get, so it will not be discussed in this document. Here are some useful links:. #. `cppreference.com; <https://en.cppreference.com/w/>`_ - an excellent; reference for the STL and other parts of the standard C++ library. #. `cplusplus.com; <https://cplusplus.com/reference/>`_ - another excellent; reference like the one above. #. `C++ In a Nutshell <http://www.tempest-sw.com/cpp/>`_ - This is an O'Reilly; book in the making. It has a decent Standard Library Reference that rivals; Dinkumware's, and is unfortunately no longer free since the book has been; published. #. `C++ Frequently Asked Questions <https://www.parashift.com/c++-faq-lite/>`_. #. `Bjarne Stroustrup's C++ Page; <https://www.stroustrup.com/C++.html>`_. #. `Bruce Eckel's Thinking in C++, 2nd ed. Volume 2.; (even better, get the book); <https://archive.org/details/TICPP2ndEdVolTwo>`_. You are also encouraged to take a look at the :doc:`LLVM Coding Standards; <CodingStandards>` guide which focuses on how to write maintainable code more; than where to put your curly braces. .. _resources:. Other useful references; -----------------------. #. `Using static and shared libraries across platforms; <http://www.fortran-2000.com/ArnaudRecipes/sharedlib.html>`_. .. _apis:. Important and useful LLVM APIs; ==============================. Here we highlight some LLVM APIs that are generally useful and good to know; about when writing transformations. .. _isa:. The ``isa<>``, ``cast<>`` and ``dyn_cast<>`` templates; ------------------------------------------------------. The LLVM source-base makes extensive use of a custom form of RTTI. These; templates have many similarities to the C++ ``dynamic_cast<>`` operator, but; they don't have some drawbacks (primarily stemming from the fact that; ``dynamic_cast<>`` only works on classes that have a v-table). Because they are; used so often, you must know what they do and how they work. All of these; templates are defined in the ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:3076,guid,guide,3076,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['guid'],['guide']
Usability,", and; each result may be what an analysis wants (IE; TBAA may say no-alias, and something else may say must-alias), it is; not possible to partition the memory the way every optimization wants.; Second, some alias analysis results are not transitive (IE A noalias B,; and B noalias C, does not mean A noalias C), so it is not possible to; come up with a precise partitioning in all cases without variables to; represent every pair of possible aliases. Thus, partitioning; precisely may require introducing at least N^2 new virtual variables,; phi nodes, etc. Each of these variables may be clobbered at multiple def sites. To give an example, if you were to split up struct fields into; individual variables, all aliasing operations that may-def multiple struct; fields, will may-def more than one of them. This is pretty common (calls,; copies, field stores, etc). Experience with SSA forms for memory in other compilers has shown that; it is simply not possible to do this precisely, and in fact, doing it; precisely is not worth it, because now all the optimizations have to; walk tons and tons of virtual variables and phi nodes. So we partition. At the point at which you partition, again,; experience has shown us there is no point in partitioning to more than; one variable. It simply generates more IR, and optimizations still; have to query something to disambiguate further anyway. As a result, LLVM partitions to one variable. Precision in practice; ^^^^^^^^^^^^^^^^^^^^^. In practice, there are implementation details in LLVM that also affect the; results' precision provided by ``MemorySSA``. For example, AliasAnalysis has various; caps, or restrictions on looking through phis which can affect what ``MemorySSA``; can infer. Changes made by different passes may make MemorySSA either ""overly; optimized"" (it can provide a more accurate result than if it were recomputed; from scratch), or ""under optimized"" (it could infer more if it were recomputed).; This can lead to challenges to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:17961,simpl,simply,17961,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['simpl'],['simply']
Usability,", check for an existing function from a previous 'extern' declaration.; Function *TheFunction = TheModule->getFunction(Proto->getName());. if (!TheFunction); TheFunction = Proto->codegen();. if (!TheFunction); return nullptr;. if (!TheFunction->empty()); return (Function*)LogErrorV(""Function cannot be redefined."");. For function definitions, we start by searching TheModule's symbol table for an; existing version of this function, in case one has already been created using an; 'extern' statement. If Module::getFunction returns null then no previous version; exists, so we'll codegen one from the Prototype. In either case, we want to; assert that the function is empty (i.e. has no body yet) before we start. .. code-block:: c++. // Create a new basic block to start insertion into.; BasicBlock *BB = BasicBlock::Create(*TheContext, ""entry"", TheFunction);; Builder->SetInsertPoint(BB);. // Record the function arguments in the NamedValues map.; NamedValues.clear();; for (auto &Arg : TheFunction->args()); NamedValues[std::string(Arg.getName())] = &Arg;. Now we get to the point where the ``Builder`` is set up. The first line; creates a new `basic block <http://en.wikipedia.org/wiki/Basic_block>`_; (named ""entry""), which is inserted into ``TheFunction``. The second line; then tells the builder that new instructions should be inserted into the; end of the new basic block. Basic blocks in LLVM are an important part; of functions that define the `Control Flow; Graph <http://en.wikipedia.org/wiki/Control_flow_graph>`_. Since we; don't have any control flow, our functions will only contain one block; at this point. We'll fix this in `Chapter 5 <LangImpl05.html>`_ :). Next we add the function arguments to the NamedValues map (after first clearing; it out) so that they're accessible to ``VariableExprAST`` nodes. .. code-block:: c++. if (Value *RetVal = Body->codegen()) {; // Finish off the function.; Builder->CreateRet(RetVal);. // Validate the generated code, checking for consistency.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:14541,clear,clear,14541,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['clear'],['clear']
Usability,", names, and random strings. Depending on; the class of the argument, it can be optionally formatted in different ways.; This gives the ``DiagnosticConsumer`` information about what the argument means; without requiring it to use a specific presentation (consider this MVC for; Clang :). It is really easy to add format specifiers to the Clang diagnostics system, but; they should be discussed before they are added. If you are creating a lot of; repetitive diagnostics and/or have an idea for a useful formatter, please bring; it up on the cfe-dev mailing list. Here are the different diagnostic argument formats currently supported by; Clang:. **""s"" format**. Example:; ``""requires %0 parameter%s0""``; Class:; Integers; Description:; This is a simple formatter for integers that is useful when producing English; diagnostics. When the integer is 1, it prints as nothing. When the integer; is not 1, it prints as ""``s``"". This allows some simple grammatical forms to; be to be handled correctly, and eliminates the need to use gross things like; ``""requires %1 parameter(s)""``. Note, this only handles adding a simple; ""``s``"" character, it will not handle situations where pluralization is more; complicated such as turning ``fancy`` into ``fancies`` or ``mouse`` into; ``mice``. You can use the ""plural"" format specifier to handle such situations. **""select"" format**. Example:; ``""must be a %select{unary|binary|unary or binary}0 operator""``; Class:; Integers; Description:; This format specifier is used to merge multiple related diagnostics together; into one common one, without requiring the difference to be specified as an; English string argument. Instead of specifying the string, the diagnostic; gets an integer argument and the format string selects the numbered option.; In this case, the ""``%0``"" value must be an integer in the range [0..2]. If; it is 0, it prints ""unary"", if it is 1 it prints ""binary"" if it is 2, it; prints ""unary or binary"". This allows other language translatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:10626,simpl,simple,10626,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,", so a TGeoVolumeAssembly does not need to have a; medium. Due to the self-containment of assemblies, they are very; practical to use when a container is hard to define due to possible; overlaps during positioning. For instance, it is very easy creating; honeycomb structures. A very useful example for creating and using; assemblies can be found at: assembly.C. Creation of an assembly is very easy: one has just to create a; TGeoVolumeAssembly object and position the components inside as; for any volume:. ~~~{.cpp}; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; ~~~. Note that components cannot be declared as ""overlapping"" and that a; component can be an assembly volume. For existing flat volume; structures, one can define assemblies to force a hierarchical structure; therefore optimizing the performance. Usage of assemblies does NOT imply; penalties in performance, but in some cases, it can be observed that it; is not as performing as bounding the structure in a container volume; with a simple shape. Choosing a normal container is therefore; recommended whenever possible. \image html geometry006.png ""Assemblies of volumes"" width=600px. \anchor GP01c; ### Geometrical Transformations. All geometrical transformations handled by the modeller are provided as; a built-in package. This was designed to minimize memory requirements; and optimize performance of point/vector master-to-local and; local-to-master computation. We need to have in mind that a; transformation in **`TGeo`** has two major use-cases. The first one is; for defining the placement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:51139,simpl,simple,51139,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,", the class RooCatType was used to store category states. It stores; two members, an integer for the category index, and up to 256 characters for a category name. Now, such states are; stored only using an integer, and category names can have arbitrary length. This will use 4 instead of 288 bytes; per category entry in a dataset, and make computations that rely on category states faster. The interface to define or manipulate category states was also updated. Since categories are mappings from state names; to state index, this is now reflected in the interface. Among others, this is now possible:; | ROOT 6.22 | Before (still supported) |; |------------------------------------------------|----------------------------------------------------------------|; | `RooCategory cat(""cat"", ""Lepton flavour"");` | `RooCategory cat(""cat"", ""Lepton flavour"");` |; | `cat[""electron""] = 1;` | `cat.defineType(""electron"", 1);` |; | `cat[""muon""] = 2;` | `cat.defineType(""muon"", 2);` |. See also [Category reference guide](https://root.cern.ch/doc/master/classRooCategory.html). ### Type-safe proxies for RooFit objects; RooFit's proxy classes have been modernised. The class `RooTemplateProxy` allows for access to other RooFit objects; similarly to a smart pointer. In older versions of RooFit, the objects held by *e.g.* `RooRealProxy` had to be; accessed like this:; RooAbsArg* absArg = realProxy.absArg();; RooAbsPdf* pdf = dynamic_cast<RooAbsPdf*>(absArg);; assert(pdf); // This *should* work, but the proxy doesn't have a way to check; pdf->fitTo(...);; That is, a `RooRealProxy` stores a pointer to a RooAbsArg, and this pointer has to be cast. There was no type; safety, *i.e.*, any object deriving from RooAbsArg could be stored in that proxy, and the user had to take care; of ensuring that types are correct.; Now, if one uses; RooTemplateProxy<RooAbsPdf> pdfProxy;; instead of; RooRealProxy realProxy;; in RooFit classes, the above code can be simplified to; pdfProxy->fitTo(...);. Check the [doxyg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:4006,guid,guide,4006,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['guid'],['guide']
Usability,", then maybe it makes more sense to move language; construct modeling to the engine when the checker API is not sufficient instead; of complicating the API. Right now I have no preference or objections between the alternatives but there; are some random thoughts:. * Maybe it would be great to have a guideline how to evolve the analyzer and; follow it, so it can help us to decide in similar situations. * I do care about performance in this case. The reason is that we have a; limited performance budget. And I think we should not expect most of the checker; writers to add modeling of language constructs. So, in my opinion, it is ok to; have less nice/more verbose API for language modeling if we can have better; performance this way, since it only needs to be done once, and is done by the; framework developers. **Artem:** These are some great questions, i guess it'd be better to discuss; them more openly. As a quick dump of my current mood:. * To me it seems obvious that we need to aim for a checker API that is both; simple and powerful. This can probably by keeping the API as powerful as; necessary while providing a layer of simple ready-made solutions on top of it.; Probably a few reusable components for assembling checkers. And this layer; should ideally be pleasant enough to work with, so that people would prefer to; extend it when something is lacking, instead of falling back to the complex; omnipotent API. I'm thinking of AST matchers vs. AST visitors as a roughly; similar situation: matchers are not omnipotent, but they're so nice. * Separation between core and checkers is usually quite strange. Once we have; shared state traits, i generally wouldn't mind having region store or range; constraint manager as checkers (though it's probably not worth it to transform; them - just a mood). The main thing to avoid here would be the situation when; the checker overwrites stuff written by the core because it thinks it has a; better idea what's going on, so the core should",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:6227,simpl,simple,6227,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['simpl'],['simple']
Usability,", this would be represented as follows:. .. code-block:: C. c = ...;; for (...) {; if (c); X1 = ...; else; X2 = ...; X3 = phi(X1, X2);; }; X4 = phi(X3);. ... = X4 + 4;. This is still valid LLVM; the extra phi nodes are purely redundant,; but all LoopPass'es are required to preserve them.; This form is ensured by the LCSSA (:ref:`-lcssa <passes-lcssa>`); pass and is added automatically by the LoopPassManager when; scheduling a LoopPass.; After the loop optimizations are done, these extra phi nodes; will be deleted by :ref:`-instcombine <passes-instcombine>`. Note that an exit block is outside of a loop, so how can such a phi ""close""; the value inside the loop since it uses it outside of it ? First of all,; for phi nodes, as; `mentioned in the LangRef <https://llvm.org/docs/LangRef.html#id311>`_:; ""the use of each incoming value is deemed to occur on the edge from the; corresponding predecessor block to the current block"". Now, an; edge to an exit block is considered outside of the loop because; if we take that edge, it leads us clearly out of the loop. However, an edge doesn't actually contain any IR, so in source code,; we have to choose a convention of whether the use happens in; the current block or in the respective predecessor. For LCSSA's purpose,; we consider the use happens in the latter (so as to consider the; use inside) [#point-of-use-phis]_. The major benefit of LCSSA is that it makes many other loop optimizations; simpler. First of all, a simple observation is that if one needs to see all; the outside users, they can just iterate over all the (loop closing); PHI nodes in the exit blocks (the alternative would be to; scan the def-use chain [#def-use-chain]_ of all instructions in the loop). Then, consider for example; :ref:`simple-loop-unswitch <passes-simple-loop-unswitch>` ing the loop above.; Because it is in LCSSA form, we know that any value defined inside of; the loop will be used either only inside the loop or in a loop closing; PHI node. In this ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:12530,clear,clearly,12530,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['clear'],['clearly']
Usability,", we will just need to; replicate the ones that we have already created. ``` {.cpp}; chamber->AddNode(wire_co,1,new TGeoTranslation(0.2,0,0));; chamber->AddNode(wire_co,2,new TGeoTranslation(0.2,0,0));; ```. The 2 nodes that we have created inside chamber will both point to a; `wire_co` object, but will be completely distinct: `WIRE_CO_1` and; `WIRE_CO_2`. We will want now to place symmetrically 1000 chambers on a; pad, following a pattern of 20 rows and 50 columns. One way to do this; will be to replicate our chamber by positioning it 1000 times in; different positions of the pad. Unfortunately, this is far from being; the optimal way of doing what we want. Imagine that we would like to; find out which of the 1000 chambers is containing a `(x,y,z)` point; defined in the pad reference. You will never have to do that, since the; modeller will take care of it for you, but let's guess what it has to; do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current; chamber contains the point or not. This might be efficient for pads with; few chambers, but definitely not for 1000. Fortunately the modeller is; smarter than that and creates for each volume some optimization; structures called `voxels` to minimize the penalty having too many; daughters, but if you have 100 pads like this in your geometry you will; anyway lose a lot in your tracking performance. The way out when; volumes can be arranged according to simple patterns is the usage of; divisions. We will describe them in detail later on. Let's think now at; a different situation: instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical; and have a wire inside, but their dimensions are different. However, we; would like all to be represented by a single volume family, since they; have the same properties. #### Volume Families. A volume family is represented by the class **`T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:80089,simpl,simple,80089,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,", which C is NOT). In fact, I would assert; > that most programmers TODAY do not understand pointers to member; > functions, and have to look up an example when they have to write them. Again, I don't disagree with this at all. But to some extent this; particular problem is inherently difficult. Your syntax for the above; example may be easier for you to read because this is the way you have been; thinking about it. Honestly, I don't find it much easier than the C syntax.; In either case, I would have to look up an example to write pointers to; member functions. But pointers to member functions are nowhere near as common as arrays. And; the old array syntax:; type [ int, int, ...]; is just much more familiar and clear to people than anything new you; introduce, no matter how logical it is. Introducing a new syntax that may; make function pointers easier but makes arrays much more difficult seems; very risky to me. > In my opinion, it is critically important to have clear and concise type; > specifications, because types are going to be all over the programs. I absolutely agree. But the question is, what is more clear and concise?; The syntax programmers are used to out of years of experience or a new; syntax that they have never seen that has a more logical structure. I think; the answer is the former. Sometimes, you have to give up a better idea; because you can't overcome sociological barriers to it. Qwerty keyboards; and Windows are two classic examples of bad technology that are difficult to; root out. P.S. Also, while I agree that most your syntax is more logical, there is; one part that isn't:. Arrays (without and with size):; type ::= '[' type ']' | '[' INT ',' type ']'. The arrays with size lists the dimensions and the type in a single list.; That is just too confusing:; [10, 40, int]; This seems to be a 3-D array where the third dimension is something strange.; It is too confusing to have a list of 3 things, some of which are dimensions; and one is a type. E",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt:2059,clear,clear,2059,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt,1,['clear'],['clear']
Usability,",x,y); root[] gr5->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] gr5->Draw(""ALP""); root[] gr5->GetXaxis()->SetTitle(""X-Axis""); root[] gr5->GetYaxis()->SetTitle(""Y-Axis""); root[] gr5->GetXaxis()->CenterTitle(); root[] gr5->GetYaxis()->CenterTitle(); root[] gr5->Draw(""ALP""); ```. For more graph examples see the scripts: `$ROOTSYS/tutorials` directory; `graph.C`, `gerrors.C`, `zdemo.C`, and `gerrors2.C`. ![A graph with axis titles](pictures/0300005D.png). ## Zooming a Graph. To zoom a graph you can create a histogram with the desired axis range; first. Draw the empty histogram and then draw the graph using the; existing axis from the histogram. ``` {.cpp}; {; c1 = new TCanvas(""c1"",""A Zoomed Graph"",200,10,700,500);; hpx = new TH2F(""hpx"",""Zoomed Graph Example"",10,0,0.5,10,1.0,8.0);; hpx->SetStats(kFALSE); // no statistics; hpx->Draw();; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; gr = new TGraph(n,x,y);; gr->SetMarkerColor(4);; gr->SetMarkerStyle(20);; gr->Draw(""LP"");// and draw it without an axis; }; ```. The next example is the same graph as above with a zoom in the x and y; directions. ![A zoomed graph](pictures/0300005E.png). ## The User Interface for Graphs. The class **`TGraphEditor`** provides the user interface for setting; the following graph attributes interactively:. - Title text entry field ... sets the title of the graph. - Shape radio button group - sets the graph shapes:. - *No Line*: draw unconnected points;; - *Smooth Line*: a smooth curve;; - *Simple Line*: a simple poly-line;; - *Bart Chart*: a bar chart at each point.; - *Fill Area*: a fill area is drawn. - Show Marker - sets markers as visible or invisible. - Exclusion Zone - specifies the exclusion zone parameters :. - *'+-‘ check button*: sets on which side of the line the; exclusion zone will be drawn;; - *Width combo box*: defines the width of the zone. ![](pictures/0300005F.png). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:22962,simpl,simple,22962,documentation/users-guide/Graphs.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md,1,['simpl'],['simple']
Usability,"- Algorithms for dividing the shape along a given axis. The modeller currently provides a set of 20 basic shapes, which we will; call `primitives`. It also provides a special class allowing the; creation of shapes as a result of Boolean operations between primitives.; These are called `composite shapes` and the composition operation can be; recursive (combined composites). This allows the creation of a quite; large number of different shape topologies and combinations. You can; have a look and run the tutorial:; <http://root.cern.ch/root/html/examples/geodemo.C.html>. ![Primitive Shapes - the general inheritance scheme](pictures/030001B5.png). Shapes are named objects and all primitives have constructors like:. ``` {.cpp}; TGeoXXX(const char *name,<type> param1,<type> param2, ...);; TGeoXXX(<type> param1,<type> param2, ...);; ```. Naming shape primitive is mandatory only for the primitives used in; Boolean composites (see ""Composite Shapes""). For the sake of simplicity,; we will describe only the constructors in the second form. ### Units. The length units used in the geometry are **arbitrary**. However, there; are certain functionalities that work with the assumption that the used; lengths are expressed in centimeters. This is the case for shape; capacity or volume weight computation. The same is valid when using the; ROOT geometry as navigator for an external transport MC package (e.g.; GEANT) via the VMC interface. Other units in use: All angles used for defining rotation matrices or; some shape parameters are expressed in **degrees**. Material density is; expressed in [**g/cm3**]. ### Primitive Shapes. #### Boxes - TGeoBBox Class. Normally a box has to be built only with 3 parameters: `DX,DY,DZ`; representing the half-lengths on X, Y and Z-axes. In this case, the; origin of the box will match the one of its reference frame and the box; will range from: `-DX` to `DX` on X-axis, from `-DY` to `DY` on Y and; from `-DZ` to `DZ` on Z. On the other hand, any other sha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:25199,simpl,simplicity,25199,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simplicity']
Usability,"--+---------------------------------------+. The flags are used to signify certain conditions, such as the presence of; debugging information or whether or not LTO was used. The string entry table is; used to generically contain any arbitrary key-value pair. This is stored as an; array of the :ref:`string entry<table-binary_string>` format. .. table:: Offloading String Entry; :name: table-binary_string. +----------+--------------+-------------------------------------------------------+; | Type | Identifier | Description |; +==========+==============+=======================================================+; | uint64_t | key offset | Absolute byte offset of the key in the string table |; +----------+--------------+-------------------------------------------------------+; | uint64_t | value offset | Absolute byte offset of the value in the string table |; +----------+--------------+-------------------------------------------------------+. The string entries simply provide offsets to a key and value pair in the; binary images string table. The string table is simply a collection of null; terminated strings with defined offsets in the image. The string entry allows us; to create a key-value pair from this string table. This is used for passing; arbitrary arguments to the image, such as the triple and architecture. All of these structures are combined to form a single binary blob, the order; does not matter because of the use of absolute offsets. This makes it easier to; extend in the future. As mentioned previously, multiple offloading images are; bundled together by simply concatenating them in this format. Because we have; the magic bytes and size of each image, we can extract them as-needed. Usage; =====. This tool can be used with the following arguments. Generally information is; passed as a key-value pair to the ``image=`` argument. The ``file`` and; ``triple``, arguments are considered mandatory to make a valid image.; The ``arch`` argument is suggested. .. code-b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst:6805,simpl,simply,6805,interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,1,['simpl'],['simply']
Usability,"-------+; | 5 | 429,871 | 7.03 | 0.06 |; +---------------------+------------------+-------------------+-------------------+; | 9 | 426,899 | 8.47 | 0.05 |; +---------------------+------------------+-------------------+-------------------+. The time to uncompress an object is small compared to the compression; time and is independent of the selected compression level. Note that the; compression level may be changed at any time, but the new compression; level will only apply to newly written objects. Consequently, a ROOT; file may contain objects with different compression levels. This table; shows four runs of the demo script that creates 15 histograms with; different compression parameters. To make the numbers more significant,; the macro was modified to create 1000 histograms. We have included two; more examples to show the impact of compression on Trees in the next; chapter. ### Using the General Open Function of TFile. To make life simple we provide a general function to open any type of; file (except shared memory files of class **`TMapFile`**). This; functionality is provided by the static `TFile::Open()` function:. ``` {.cpp}; TFile *TFile::Open(const Text_t *name,Option_t *option="""",; const Text_t *title="""",Int_t compress,Int_t netopt); ```. Depending on the `name` argument, the function returns a **`TFile`** or one; of its derivations, for example a; **`TNetXNGFile`** or a **`TDavixFile`** object. In case a URL; specifies a local file, a **`TFile`** object will be returned (and of; course no login information is needed). The arguments of the `Open()`; function are the same as the ones for the **`TFile`** constructor. Using `ReOpen()` method it is possible to reopen a file with a; different access mode, like from READ to UPDATE or from NEW, CREATE,; RECREATE, UPDATE to READ. Thus the mode argument can be either ""READ"" or; ""UPDATE"". The method returns:. - 0 in case the mode was successfully modified;. - 1 in case the mode did not change (it was already as requ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:94325,simpl,simple,94325,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability,"----------------------+---------------------------------------------------------------------------------------------+; |LANGUAGE_STANDARD std | The version of C++ in use, ""14"" by default. |; +----------------------+---------------------------------------------------------------------------------------------+; |IMPORTS pcm | Files which contain previously-generated bindings |; | | which pkg depends on. |; +----------------------+---------------------------------------------------------------------------------------------+; |GENERATE_OPTIONS optio| Options which are to be passed into the rootcling |; | | command. For example, bindings which depend on Qt |; | | may need ""-D__PIC__;-Wno-macro-redefined"". |; +----------------------+---------------------------------------------------------------------------------------------+; |LINKDEFS def | Files or lines which contain extra #pragma content |; | | for the linkdef.h file used by rootcling. See |; | | https://root.cern.ch/root/html/guides/users-guide/AddingaClass.html#the-linkdef.h-file. |; | | |; | | In lines, literal semi-colons must be escaped: ""\;"". |; +----------------------+---------------------------------------------------------------------------------------------+; |EXTRA_CODES code | Files which contain extra code needed by the bindings. |; | | Customization is by routines named ""c13n_<something>""; |; | | each such routine is passed the module for <pkg>: |; | | |; | | :: code-block python |; | | |; | | def c13n_doit(pkg_module): |; | | print(pkg_module.__dict__) |; | | |; | | The files and individual routines within files are |; | | processed in alphabetical order. |; +----------------------+---------------------------------------------------------------------------------------------+; |EXTRA_HEADERS hdr | Files which contain extra headers needed by the bindings. |; +----------------------+---------------------------------------------------------------------------------------------+; |EXTRA_PYTHONS py | Files whi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst:7808,guid,guides,7808,bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,2,['guid'],"['guide', 'guides']"
Usability,"-------------------------------------------------------+; | task | inoutset in depend clause | :good:`done` | D97085, D118383 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | nowait clause on taskwait | :part:`partial` | parsing/sema done: D131830, D141531 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+. OpenMP Extensions; =================. The following table provides a quick overview over various OpenMP; extensions and their implementation status. These extensions are not; currently defined by any standard, so links to associated LLVM; documentation are provided. As these extensions mature, they will be; considered for standardization. Please post on the; `Discourse forums (Runtimes - OpenMP category)`_ to provide feedback. +------------------------------+-----------------------------------------------------------------------------------+--------------------------+--------------------------------------------------------+; |Category | Feature | Status | Reviews |; +==============================+===================================================================================+==========================+========================================================+; | atomic extension | `'atomic' strictly nested within 'teams' | :good:`prototyped` | D126323 |; | | <https://openmp.llvm.org/docs/openacc/OpenMPExtensions.html#atomicWithinTeams>`_ | | |; +------------------------------+-----------------------------------------------------------------------------------+--------------------------+--------------------------------------------------------+; | device extension | `'ompx_hold' map type modifier | :good:`prototyped` | D106509, D106510 |; | | <https://openmp.llv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:35964,feedback,feedback,35964,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['feedback'],['feedback']
Usability,"---------------------------------------------------------------------------------+; | New functionality | Subgroup functions | :good:`done` | https://reviews.llvm.org/D105858, https://reviews.llvm.org/D118999 |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | New functionality | Atomic mem scopes: subgroup, all devices including functions | :good:`done` | https://reviews.llvm.org/D103241 |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+. .. _opencl_experimenal:. Experimental features; =====================. Clang provides the following new WIP features for the developers to experiment; and provide early feedback or contribute with further improvements.; Feel free to contact us on `the Discourse forums (Clang Frontend category); <https://discourse.llvm.org/c/clang/6>`_ or file `a GitHub issue; <https://github.com/llvm/llvm-project/issues/new>`_. .. _opencl_experimental_cxxlibs:. C++ libraries for OpenCL; ------------------------. There is ongoing work to support C++ standard libraries from `LLVM's libcxx; <https://libcxx.llvm.org/>`_ in OpenCL kernel code using C++ for OpenCL mode. It is currently possible to include `type_traits` from C++17 in the kernel; sources when the following clang extensions are enabled; ``__cl_clang_function_pointers`` and ``__cl_clang_variadic_functions``,; see :doc:`LanguageExtensions` for more details. The use of non-conformant; features enabled by the extensions does not expose non-conformant behavior; beyond the compilation i.e. does not get generated in IR or binary.; The extension only appear in metaprogramming; mechanism to ide",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:22510,feedback,feedback,22510,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst,1,['feedback'],['feedback']
Usability,"-----------------------------------------------. To run the CTU analysis, a compilation database file has to be created:. $ intercept-build <your build command>. To run the Clang Static Analyzer against a compilation database; with CTU analysis enabled, execute:; ; $ analyze-build --ctu. For CTU analysis an additional (external definition) collection-phase is required. ; For debugging purposes, it is possible to separately execute the collection ; and the analysis phase. By doing this, the intermediate files used for ; the analysis are kept on the disk in `./ctu-dir`.; ; # Collect and store the data required by the CTU analysis; $ analyze-build --ctu-collect-only; ; # Analyze using the previously collected data; $ analyze-build --ctu-analyze-only. Use `--help` to get more information about the commands. Limitations; -----------. Generally speaking, the `intercept-build` and `analyze-build` tools together; does the same job as `scan-build` does. So, you can expect the same output; from this line as simple `scan-build` would do:. $ intercept-build <your build command> && analyze-build. The major difference is how and when the analyzer is run. The `scan-build`; tool has three distinct model to run the analyzer:. 1. Use compiler wrappers to make actions.; The compiler wrappers does run the real compiler and the analyzer.; This is the default behaviour, can be enforced with `--override-compiler`; flag. 2. Use special library to intercept compiler calls during the build process.; The analyzer run against each modules after the build finished.; Use `--intercept-first` flag to get this model. 3. Use compiler wrappers to intercept compiler calls during the build process.; The analyzer run against each modules after the build finished.; Use `--intercept-first` and `--override-compiler` flags together to get; this model. The 1. and 3. are using compiler wrappers, which works only if the build; process respects the `CC` and `CXX` environment variables. (Some build; process can o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/README.md:2071,simpl,simple,2071,interpreter/llvm-project/clang/tools/scan-build-py/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/README.md,1,['simpl'],['simple']
Usability,"---------------------------------------------. A pass wrapper around the ``ExtractLoop()`` scalar transformation to extract; each top-level loop into its own new function. If the loop is the *only* loop; in a given function, it is not touched. This is a pass most useful for; debugging via bugpoint. ``loop-reduce``: Loop Strength Reduction; ----------------------------------------. This pass performs a strength reduction on array references inside loops that; have as one or more of their components the loop induction variable. This is; accomplished by creating a new value to hold the initial value of the array; access for the first iteration, and then creating a new GEP instruction in the; loop to increment the value by the appropriate amount. .. _passes-loop-rotate:. ``loop-rotate``: Rotate Loops; -----------------------------. A simple loop rotation transformation. A summary of it can be found in; :ref:`Loop Terminology for Rotated Loops <loop-terminology-loop-rotate>`. .. _passes-loop-simplify:. ``loop-simplify``: Canonicalize natural loops; ---------------------------------------------. This pass performs several transformations to transform natural loops into a; simpler form, which makes subsequent analyses and transformations simpler and; more effective. A summary of it can be found in; :ref:`Loop Terminology, Loop Simplify Form <loop-terminology-loop-simplify>`. Loop pre-header insertion guarantees that there is a single, non-critical entry; edge from outside of the loop to the loop header. This simplifies a number of; analyses and transformations, such as :ref:`LICM <passes-licm>`. Loop exit-block insertion guarantees that all exit blocks from the loop (blocks; which are outside of the loop that have predecessors inside of the loop) only; have predecessors from inside of the loop (and are thus dominated by the loop; header). This simplifies transformations such as store-sinking that are built; into LICM. This pass also guarantees that loops will have exactly ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:26589,simpl,simplify,26589,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simplify']
Usability,"---------------------------------------. **Abstract**. ROOT is a software framework for data analysis and I/O: a powerful tool to cope; with the demanding tasks typical of state of the art scientific data analysis.; Among its prominent features are an advanced graphical user; interface, ideal for interactive analysis, an interpreter for the C++; programming language, for rapid and efficient prototyping and a; persistency mechanism for C++ objects, used also to write every year; petabytes of data recorded by the Large Hadron Collider experiments.; This introductory guide illustrates the main features of ROOT which are; relevant for the typical problems of data analysis: input and plotting of data; from measurements and fitting of analytical functions. *Original Authors*; - D. Piparo; - G. Quast; - M. Zeise. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/abstract.md:571,guid,guide,571,documentation/primer/abstract.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/abstract.md,1,['guid'],['guide']
Usability,"--------------------------------------. The Clang compiler frontend, ``clang -cc1``, supports two command line options; for generating and using PCH files. To generate PCH files using ``clang -cc1``, use the option `-emit-pch`:. .. code-block:: bash. $ clang -cc1 test.h -emit-pch -o test.h.pch. This option is transparently used by ``clang`` when generating PCH files. The; resulting PCH file contains the serialized form of the compiler's internal; representation after it has completed parsing and semantic analysis. The PCH; file can then be used as a prefix header with the `-include-pch`; option:. .. code-block:: bash. $ clang -cc1 -include-pch test.h.pch test.c -o test.s. Design Philosophy; -----------------. Precompiled headers are meant to improve overall compile times for projects, so; the design of precompiled headers is entirely driven by performance concerns.; The use case for precompiled headers is relatively simple: when there is a; common set of headers that is included in nearly every source file in the; project, we *precompile* that bundle of headers into a single precompiled; header (PCH file). Then, when compiling the source files in the project, we; load the PCH file first (as a prefix header), which acts as a stand-in for that; bundle of headers. A precompiled header implementation improves performance when:. * Loading the PCH file is significantly faster than re-parsing the bundle of; headers stored within the PCH file. Thus, a precompiled header design; attempts to minimize the cost of reading the PCH file. Ideally, this cost; should not vary with the size of the precompiled header file. * The cost of generating the PCH file initially is not so large that it; counters the per-source-file performance improvement due to eliminating the; need to parse the bundled headers in the first place. This is particularly; important on multi-core systems, because PCH file generation serializes the; build when all compilations require the PCH file to be up-to-date",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:1345,simpl,simple,1345,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['simpl'],['simple']
Usability,"----------------------------------===//. int f(int i, int j) { return i < j + 1; }; int g(int i, int j) { return j > i - 1; }; Should combine to ""i <= j"" (the add/sub has nsw). Currently not; optimized with ""clang -emit-llvm-bc | opt -O3"". //===---------------------------------------------------------------------===//. unsigned f(unsigned x) { return ((x & 7) + 1) & 15; }; The & 15 part should be optimized away, it doesn't change the result. Currently; not optimized with ""clang -emit-llvm-bc | opt -O3"". //===---------------------------------------------------------------------===//. This was noticed in the entryblock for grokdeclarator in 403.gcc:. %tmp = icmp eq i32 %decl_context, 4 ; %decl_context_addr.0 = select i1 %tmp, i32 3, i32 %decl_context ; %tmp1 = icmp eq i32 %decl_context_addr.0, 1 ; %decl_context_addr.1 = select i1 %tmp1, i32 0, i32 %decl_context_addr.0. tmp1 should be simplified to something like:; (!tmp || decl_context == 1). This allows recursive simplifications, tmp1 is used all over the place in; the function, e.g. by:. %tmp23 = icmp eq i32 %decl_context_addr.1, 0 ; <i1> [#uses=1]; %tmp24 = xor i1 %tmp1, true ; <i1> [#uses=1]; %or.cond8 = and i1 %tmp23, %tmp24 ; <i1> [#uses=1]. later. //===---------------------------------------------------------------------===//. [STORE SINKING]. Store sinking: This code:. void f (int n, int *cond, int *res) {; int i;; *res = 0;; for (i = 0; i < n; i++); if (*cond); *res ^= 234; /* (*) */; }. On this function GVN hoists the fully redundant value of *res, but nothing; moves the store out. This gives us this code:. bb:		; preds = %bb2, %entry; 	%.rle = phi i32 [ 0, %entry ], [ %.rle6, %bb2 ]	; 	%i.05 = phi i32 [ 0, %entry ], [ %indvar.next, %bb2 ]; 	%1 = load i32* %cond, align 4; 	%2 = icmp eq i32 %1, 0; 	br i1 %2, label %bb2, label %bb1. bb1:		; preds = %bb; 	%3 = xor i32 %.rle, 234	; 	store i32 %3, i32* %res, align 4; 	br label %bb2. bb2:		; preds = %bb, %bb1; 	%.rle6 = phi i32 [ %3, %bb1 ], [ %.rle, %bb ]	; 	%ind",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:28051,simpl,simplifications,28051,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplifications']
Usability,"--------------------------------. ADCE aggressively tries to eliminate code. This pass is similar to :ref:`DCE; <passes-dce>` but it assumes that values are dead until proven otherwise. This; is similar to :ref:`SCCP <passes-sccp>`, except applied to the liveness of; values. ``always-inline``: Inliner for ``always_inline`` functions; ----------------------------------------------------------. A custom inliner that handles only functions that are marked as ""always; inline"". ``argpromotion``: Promote 'by reference' arguments to scalars; -------------------------------------------------------------. This pass promotes ""by reference"" arguments to be ""by value"" arguments. In; practice, this means looking for internal functions that have pointer; arguments. If it can prove, through the use of alias analysis, that an; argument is *only* loaded, then it can pass the value into the function instead; of the address of the value. This can cause recursive simplification of code; and lead to the elimination of allocas (especially in C++ template code like; the STL). This pass also handles aggregate arguments that are passed into a function,; scalarizing them if the elements of the aggregate are only loaded. Note that; it refuses to scalarize aggregates which would require passing in more than; three operands to the function, because passing thousands of operands for a; large array or structure is unprofitable!. Note that this transformation could also be done for arguments that are only; stored to (returning the value instead), but does not currently. This case; would be best handled when and if LLVM starts supporting multiple return values; from functions. ``block-placement``: Profile Guided Basic Block Placement; ---------------------------------------------------------. This pass is a very simple profile guided basic block placement algorithm. The; idea is to put frequently executed blocks together at the start of the function; and hopefully increase the number of fall-through",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:12805,simpl,simplification,12805,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simplification']
Usability,"-------------------------------. Clang provides support for C++11 enumerations with a fixed underlying type; within Objective-C. For example, one can write an enumeration type as:. .. code-block:: c++. typedef enum : unsigned char { Red, Green, Blue } Color;. This specifies that the underlying type, which is used to store the enumeration; value, is ``unsigned char``. Use ``__has_feature(objc_fixed_enum)`` to determine whether support for fixed; underlying types is available in Objective-C. Interoperability with C++11 lambdas; -----------------------------------. Clang provides interoperability between C++11 lambdas and blocks-based APIs, by; permitting a lambda to be implicitly converted to a block pointer with the; corresponding signature. For example, consider an API such as ``NSArray``'s; array-sorting method:. .. code-block:: objc. - (NSArray *)sortedArrayUsingComparator:(NSComparator)cmptr;. ``NSComparator`` is simply a typedef for the block pointer ``NSComparisonResult; (^)(id, id)``, and parameters of this type are generally provided with block; literals as arguments. However, one can also use a C++11 lambda so long as it; provides the same signature (in this case, accepting two parameters of type; ``id`` and returning an ``NSComparisonResult``):. .. code-block:: objc. NSArray *array = @[@""string 1"", @""string 21"", @""string 12"", @""String 11"",; @""String 02""];; const NSStringCompareOptions comparisonOptions; = NSCaseInsensitiveSearch | NSNumericSearch |; NSWidthInsensitiveSearch | NSForcedOrderingSearch;; NSLocale *currentLocale = [NSLocale currentLocale];; NSArray *sorted; = [array sortedArrayUsingComparator:[=](id s1, id s2) -> NSComparisonResult {; NSRange string1Range = NSMakeRange(0, [s1 length]);; return [s1 compare:s2 options:comparisonOptions; range:string1Range locale:currentLocale];; }];; NSLog(@""sorted: %@"", sorted);. This code relies on an implicit conversion from the type of the lambda; expression (an unnamed, local class type called the *closure ty",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:74768,simpl,simply,74768,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['simpl'],['simply']
Usability,"----------------------------. In ORC, all symbol definitions reside in JITDylibs. JITDylibs are created by; calling the ``ExecutionSession::createJITDylib`` method with a unique name:. .. code-block:: c++. ExecutionSession ES;; auto &JD = ES.createJITDylib(""libFoo.dylib"");. The JITDylib is owned by the ``ExecutionEngine`` instance and will be freed; when it is destroyed. How to remove code; ------------------. To remove an individual module from a JITDylib it must first be added using an; explicit ``ResourceTracker``. The module can then be removed by calling; ``ResourceTracker::remove``:. .. code-block:: c++. auto &JD = ... ;; auto M = ... ;. auto RT = JD.createResourceTracker();; Layer.add(RT, std::move(M)); // Add M to JD, tracking resources with RT. RT.remove(); // Remove M from JD. Modules added directly to a JITDylib will be tracked by that JITDylib's default; resource tracker. All code can be removed from a JITDylib by calling ``JITDylib::clear``. This; leaves the cleared JITDylib in an empty but usable state. JITDylibs can be removed by calling ``ExecutionSession::removeJITDylib``. This; clears the JITDylib and then puts it into a defunct state. No further operations; can be performed on the JITDylib, and it will be destroyed as soon as the last; handle to it is released. An example of how to use the resource management APIs can be found at; ``llvm/examples/OrcV2Examples/LLJITRemovableCode``. How to add the support for custom program representation; --------------------------------------------------------; In order to add the support for a custom program representation, a custom ``MaterializationUnit``; for the program representation, and a custom ``Layer`` are needed. The Layer will have two; operations: ``add`` and ``emit``. The ``add`` operation takes an instance of your program; representation, builds one of your custom ``MaterializationUnits`` to hold it, then adds it; to a ``JITDylib``. The emit operation takes a ``MaterializationResponsibility`` objec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:24131,clear,cleared,24131,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,2,"['clear', 'usab']","['cleared', 'usable']"
Usability,"-------------------------. Intrinsics described in this section are used to manipulate an existing; coroutine. They can be used in any function which happen to have a pointer; to a `coroutine frame`_ or a pointer to a `coroutine promise`_. .. _coro.destroy:. 'llvm.coro.destroy' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.coro.destroy(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.destroy``' intrinsic destroys a suspended; switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a coroutine handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.destroy` intrinsic is replaced with a direct call to; the coroutine destroy function. Otherwise it is replaced with an indirect call; based on the function pointer for the destroy function stored in the coroutine; frame. Destroying a coroutine that is not suspended leads to undefined behavior. .. _coro.resume:. 'llvm.coro.resume' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare void @llvm.coro.resume(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.resume``' intrinsic resumes a suspended switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.resume` intrinsic is replaced with a direct call to the; coroutine resume function. Otherwise it is replaced with an indirect call based; on the function pointer for the resume function stored in the coroutine frame.; Resuming a coroutine that is not suspended leads to undefined behavior. .. _coro.done:. 'llvm.coro.done' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare i1 @llvm.coro.done(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.done``' intrinsic checks whether a suspended; switched-resume coroutine is at the final suspend point or not. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". Using this intrinsic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:27735,resume,resume,27735,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"------------------------. The well-known scalar replacement of aggregates transformation. This transform; breaks up ``alloca`` instructions of aggregate type (structure or array) into; individual ``alloca`` instructions for each member if possible. Then, if; possible, it transforms the individual ``alloca`` instructions into nice clean; scalar SSA form. .. _passes-sccp:. ``sccp``: Sparse Conditional Constant Propagation; -------------------------------------------------. Sparse conditional constant propagation and merging, which can be summarized; as:. * Assumes values are constant unless proven otherwise; * Assumes BasicBlocks are dead unless proven otherwise; * Proves values to be constant, and replaces them with constants; * Proves conditional branches to be unconditional. Note that this pass has a habit of making definitions be dead. It is a good; idea to run a :ref:`DCE <passes-dce>` pass sometime after running this pass. .. _passes-simplifycfg:. ``simplifycfg``: Simplify the CFG; ---------------------------------. Performs dead code elimination and basic block merging. Specifically:. * Removes basic blocks with no predecessors.; * Merges a basic block into its predecessor if there is only one and the; predecessor only has one successor.; * Eliminates PHI nodes for basic blocks with a single predecessor.; * Eliminates a basic block that only contains an unconditional branch. ``sink``: Code sinking; ----------------------. This pass moves instructions into successor blocks, when possible, so that they; aren't executed on paths where their results aren't needed. .. _passes-simple-loop-unswitch:. ``simple-loop-unswitch``: Unswitch loops; ----------------------------------------. This pass transforms loops that contain branches on loop-invariant conditions; to have multiple loops. For example, it turns the left into the right code:. .. code-block:: c++. for (...) if (lic); A for (...); if (lic) A; B; C; B else; C for (...); A; C. This can increase the size of the c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:34733,simpl,simplifycfg,34733,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simplifycfg']
Usability,"-----------------. Changes to the Windows Target; -----------------------------. * The LLVM filesystem class ``UniqueID`` and function ``equivalent()``; no longer determine that distinct different path names for the same; hard linked file actually are equal. This is an intentional tradeoff in a; bug fix, where the bug used to cause distinct files to be considered; equivalent on some file systems. This change fixed the issues; https://github.com/llvm/llvm-project/issues/61401 and; https://github.com/llvm/llvm-project/issues/22079. Changes to the X86 Backend; --------------------------. * The ``i128`` type now matches GCC and clang's ``__int128`` type. This mainly; benefits external projects such as Rust which aim to be binary compatible; with C, but also fixes code generation where LLVM already assumed that the; type matched and called into libgcc helper functions.; * Support ISA of ``USER_MSR``.; * Support ISA of ``AVX10.1-256`` and ``AVX10.1-512``.; * ``-mcpu=pantherlake`` and ``-mcpu=clearwaterforest`` are now supported.; * ``-mapxf`` is supported.; * Marking global variables with ``code_model = ""small""/""large""`` in the IR now; overrides the global code model to allow 32-bit relocations or require 64-bit; relocations to the global variable.; * The medium code model's code generation was audited to be more similar to the; small code model where possible. Changes to the OCaml bindings; -----------------------------. Changes to the Python bindings; ------------------------------. * The python bindings have been removed. Changes to the C API; --------------------. * Added ``LLVMGetTailCallKind`` and ``LLVMSetTailCallKind`` to; allow getting and setting ``tail``, ``musttail``, and ``notail``; attributes on call instructions.; * The following functions for creating constant expressions have been removed,; because the underlying constant expressions are no longer supported. Instead,; an instruction should be created using the ``LLVMBuildXYZ`` APIs, which will; constant fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:9847,clear,clearwaterforest,9847,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['clear'],['clearwaterforest']
Usability,"---------------===//. We compile vector multiply-by-constant into poor code:. define <4 x i32> @f(<4 x i32> %i) nounwind {; 	%A = mul <4 x i32> %i, < i32 10, i32 10, i32 10, i32 10 >; 	ret <4 x i32> %A; }. On targets without SSE4.1, this compiles into:. LCPI1_0:					## <4 x i32>; 	.long	10; 	.long	10; 	.long	10; 	.long	10; 	.text; 	.align	4,0x90; 	.globl	_f; _f:; 	pshufd	$3, %xmm0, %xmm1; 	movd	%xmm1, %eax; 	imull	LCPI1_0+12, %eax; 	movd	%eax, %xmm1; 	pshufd	$1, %xmm0, %xmm2; 	movd	%xmm2, %eax; 	imull	LCPI1_0+4, %eax; 	movd	%eax, %xmm2; 	punpckldq	%xmm1, %xmm2; 	movd	%xmm0, %eax; 	imull	LCPI1_0, %eax; 	movd	%eax, %xmm1; 	movhlps	%xmm0, %xmm0; 	movd	%xmm0, %eax; 	imull	LCPI1_0+8, %eax; 	movd	%eax, %xmm0; 	punpckldq	%xmm0, %xmm1; 	movaps	%xmm1, %xmm0; 	punpckldq	%xmm2, %xmm0; 	ret. It would be better to synthesize integer vector multiplication by constants; using shifts and adds, pslld and paddd here. And even on targets with SSE4.1,; simple cases such as multiplication by powers of two would be better as; vector shifts than as multiplications. //===---------------------------------------------------------------------===//. We compile this:. __m128i; foo2 (char x); {; return _mm_set_epi8 (1, 0, 0, 0, 0, 0, 0, 0, 0, x, 0, 1, 0, 0, 0, 0);; }. into:; 	movl	$1, %eax; 	xorps	%xmm0, %xmm0; 	pinsrw	$2, %eax, %xmm0; 	movzbl	4(%esp), %eax; 	pinsrw	$3, %eax, %xmm0; 	movl	$256, %eax; 	pinsrw	$7, %eax, %xmm0; 	ret. gcc-4.2:; 	subl	$12, %esp; 	movzbl	16(%esp), %eax; 	movdqa	LC0, %xmm0; 	pinsrw	$3, %eax, %xmm0; 	addl	$12, %esp; 	ret; 	.const; 	.align 4; LC0:; 	.word	0; 	.word	0; 	.word	1; 	.word	0; 	.word	0; 	.word	0; 	.word	0; 	.word	256. With SSE4, it should be; movdqa .LC0(%rip), %xmm0; pinsrb $6, %edi, %xmm0. //===---------------------------------------------------------------------===//. We should transform a shuffle of two vectors of constants into a single vector; of constants. Also, insertelement of a constant into a vector of constants; should also result in a vector of con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt:17510,simpl,simple,17510,interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,1,['simpl'],['simple']
Usability,"-----------. :program:`llvm-mca` returns 0 on success. Otherwise, an error message is printed; to standard error, and the tool returns 1. USING MARKERS TO ANALYZE SPECIFIC CODE BLOCKS; ---------------------------------------------; :program:`llvm-mca` allows for the optional usage of special code comments to; mark regions of the assembly code to be analyzed. A comment starting with; substring ``LLVM-MCA-BEGIN`` marks the beginning of an analysis region. A; comment starting with substring ``LLVM-MCA-END`` marks the end of a region.; For example:. .. code-block:: none. # LLVM-MCA-BEGIN; ...; # LLVM-MCA-END. If no user-defined region is specified, then :program:`llvm-mca` assumes a; default region which contains every instruction in the input file. Every region; is analyzed in isolation, and the final performance report is the union of all; the reports generated for every analysis region. Analysis regions can have names. For example:. .. code-block:: none. # LLVM-MCA-BEGIN A simple example; add %eax, %eax; # LLVM-MCA-END. The code from the example above defines a region named ""A simple example"" with a; single instruction in it. Note how the region name doesn't have to be repeated; in the ``LLVM-MCA-END`` directive. In the absence of overlapping regions,; an anonymous ``LLVM-MCA-END`` directive always ends the currently active user; defined region. Example of nesting regions:. .. code-block:: none. # LLVM-MCA-BEGIN foo; add %eax, %edx; # LLVM-MCA-BEGIN bar; sub %eax, %edx; # LLVM-MCA-END bar; # LLVM-MCA-END foo. Example of overlapping regions:. .. code-block:: none. # LLVM-MCA-BEGIN foo; add %eax, %edx; # LLVM-MCA-BEGIN bar; sub %eax, %edx; # LLVM-MCA-END foo; add %eax, %edx; # LLVM-MCA-END bar. Note that multiple anonymous regions cannot overlap. Also, overlapping regions; cannot have the same name. There is no support for marking regions from high-level source code, like C or; C++. As a workaround, inline assembly directives may be used:. .. code-block:: c++. int foo(i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:8932,simpl,simple,8932,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['simpl'],['simple']
Usability,"----------===//. //===---------------------------------------------------------------------===//. Some targets (e.g. athlons) prefer freep to fstp ST(0):; http://gcc.gnu.org/ml/gcc-patches/2004-04/msg00659.html. //===---------------------------------------------------------------------===//. This should use fiadd on chips where it is profitable:; double foo(double P, int *I) { return P+*I; }. We have fiadd patterns now but the followings have the same cost and; complexity. We need a way to specify the later is more profitable. def FpADD32m : FpI<(ops RFP:$dst, RFP:$src1, f32mem:$src2), OneArgFPRW,; [(set RFP:$dst, (fadd RFP:$src1,; (extloadf64f32 addr:$src2)))]>;; // ST(0) = ST(0) + [mem32]. def FpIADD32m : FpI<(ops RFP:$dst, RFP:$src1, i32mem:$src2), OneArgFPRW,; [(set RFP:$dst, (fadd RFP:$src1,; (X86fild addr:$src2, i32)))]>;; // ST(0) = ST(0) + [mem32int]. //===---------------------------------------------------------------------===//. The FP stackifier should handle simple permutates to reduce number of shuffle; instructions, e.g. turning:. fld P	->		fld Q; fld Q			fld P; fxch. or:. fxch	->		fucomi; fucomi			jl X; jg X. Ideas:; http://gcc.gnu.org/ml/gcc-patches/2004-11/msg02410.html. //===---------------------------------------------------------------------===//. Add a target specific hook to DAG combiner to handle SINT_TO_FP and; FP_TO_SINT when the source operand is already in memory. //===---------------------------------------------------------------------===//. Open code rint,floor,ceil,trunc:; http://gcc.gnu.org/ml/gcc-patches/2004-08/msg02006.html; http://gcc.gnu.org/ml/gcc-patches/2004-08/msg02011.html. Opencode the sincos[f] libcall. //===---------------------------------------------------------------------===//. None of the FPStack instructions are handled in; X86RegisterInfo::foldMemoryOperand, which prevents the spiller from; folding spill code into the instructions. //===---------------------------------------------------------------------===//. Cur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-FPStack.txt:1191,simpl,simple,1191,interpreter/llvm-project/llvm/lib/Target/X86/README-FPStack.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-FPStack.txt,1,['simpl'],['simple']
Usability,"---------. To be more precise, let ``classof`` be inside a class ``C``. Then the; contract for ``classof`` is ""return ``true`` if the dynamic type of the; argument is-a ``C``"". As long as your implementation fulfills this; contract, you can tweak and optimize it as much as you want. For example, LLVM-style RTTI can work fine in the presence of; multiple-inheritance by defining an appropriate ``classof``.; An example of this in practice is; `Decl <https://clang.llvm.org/doxygen/classclang_1_1Decl.html>`_ vs.; `DeclContext <https://clang.llvm.org/doxygen/classclang_1_1DeclContext.html>`_; inside Clang.; The ``Decl`` hierarchy is done very similarly to the example setup; demonstrated in this tutorial.; The key part is how to then incorporate ``DeclContext``: all that is needed; is in ``bool DeclContext::classof(const Decl *)``, which asks the question; ""Given a ``Decl``, how can I determine if it is-a ``DeclContext``?"".; It answers this with a simple switch over the set of ``Decl`` ""kinds"", and; returning true for ones that are known to be ``DeclContext``'s. .. TODO::. Touch on some of the more advanced features, like ``isa_impl`` and; ``simplify_type``. However, those two need reference documentation in; the form of doxygen comments as well. We need the doxygen so that we can; say ""for full details, see https://llvm.org/doxygen/..."". Rules of Thumb; ==============. #. The ``Kind`` enum should have one entry per concrete class, ordered; according to a preorder traversal of the inheritance tree.; #. The argument to ``classof`` should be a ``const Base *``, where ``Base``; is some ancestor in the inheritance hierarchy. The argument should; *never* be a derived class or the class itself: the template machinery; for ``isa<>`` already handles this case and optimizes it.; #. For each class in the hierarchy that has no children, implement a; ``classof`` that checks only against its ``Kind``.; #. For each class in the hierarchy that has children, implement a; ``classof`` that c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst:11718,simpl,simple,11718,interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,1,['simpl'],['simple']
Usability,"--------; class Register {; int size = 4;; }; ------------- Defs -----------------; def W0 {	// Register; int size = 4;; }; def X0 {	// Register; int size = 8;; }. (for anyone curious that's AArch64's register naming). The use case here is that we are describing registers. Some are 32 bits wide and some are 64 bits wide. We start by setting a default value of `size` which is 4 (4x8=32 bits) in the class `Register`. Then using a top level `let` we override that value and set it to 8 for all the 64 bit registers at once. So we don't need to do `size=8` over and over again. ## Classes As Class Members. In addition to the built in types, class members can be user defined classes. ```tablegen; class Inner {}; class Outer {; Inner i;; }; ```. ------------- Classes -----------------; class Inner {; }; class Outer {; Inner i = ?;; }; ------------- Defs -----------------. Of course that raises the question, how do we construct an instance of `Inner` to use as the value?. We simply use a `def` like we have done before. ```tablegen; class Inner {}; def AnInner: Inner {}; class Outer {; Inner i = AnInner;; }; def AnOuter: Outer {}; ```. ------------- Classes -----------------; class Inner {; }; class Outer {; Inner i = AnInner;; }; ------------- Defs -----------------; def AnInner {	// Inner; }; def AnOuter {	// Outer; Inner i = AnInner;; }. ## Class Template Arguments. Class template arguments are used to pass parameters to classes when you `def` them. ```tablegen; class C <int a, int b> {; int c = a;; int d = b;; }; def X: C<0, 1> {}; ```. ------------- Classes -----------------; class C<int C:a = ?, int C:b = ?> {; int c = C:a;; int d = C:b;; }; ------------- Defs -----------------; def X {	// C; int c = 0;; int d = 1;; }. This means that to `def` a `C` we must now provide 2 arguments that have type `int` (type checking applies here as it does elsewhere). This is going to look familiar if you have written C++. In C++ it might look like:; ```; template<int a, int b>; class C ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md:10633,simpl,simply,10633,interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,1,['simpl'],['simply']
Usability,"-------. Immutability; ^^^^^^^^^^^^. Clang AST nodes (types, declarations, statements, expressions, and so on) are; generally designed to be immutable once created. This provides a number of key; benefits:. * Canonicalization of the ""meaning"" of nodes is possible as soon as the nodes; are created, and is not invalidated by later addition of more information.; For example, we :ref:`canonicalize types <CanonicalType>`, and use a; canonicalized representation of expressions when determining whether two; function template declarations involving dependent expressions declare the; same entity.; * AST nodes can be reused when they have the same meaning. For example, we; reuse ``Type`` nodes when representing the same type (but maintain separate; ``TypeLoc``\s for each instance where a type is written), and we reuse; non-dependent ``Stmt`` and ``Expr`` nodes across instantiations of a; template.; * Serialization and deserialization of the AST to/from AST files is simpler:; we do not need to track modifications made to AST nodes imported from AST; files and serialize separate ""update records"". There are unfortunately exceptions to this general approach, such as:. * The first declaration of a redeclarable entity maintains a pointer to the; most recent declaration of that entity, which naturally needs to change as; more declarations are parsed.; * Name lookup tables in declaration contexts change after the namespace; declaration is formed.; * We attempt to maintain only a single declaration for an instantiation of a; template, rather than having distinct declarations for an instantiation of; the declaration versus the definition, so template instantiation often; updates parts of existing declarations.; * Some parts of declarations are required to be instantiated separately (this; includes default arguments and exception specifications), and such; instantiations update the existing declaration. These cases tend to be fragile; mutable AST state should be avoided where; possible. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:58511,simpl,simpler,58511,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simpler']
Usability,"-------; VPlan-based vectorization involves three major steps, taking a ""scenario-based; approach"" to vectorization planning:. 1. Legal Step: check if a loop can be legally vectorized; encode constraints and; artifacts if so.; 2. Plan Step:. a. Build initial VPlans following the constraints and decisions taken by; Legal Step 1, and compute their cost.; b. Apply optimizations to the VPlans, possibly forking additional VPlans.; Prune sub-optimal VPlans having relatively high cost.; 3. Execute Step: materialize the best VPlan. Note that this is the only step; that modifies the IR. Design Guidelines; -----------------; In what follows, the term ""input IR"" refers to code that is fed into the; vectorizer whereas the term ""output IR"" refers to code that is generated by the; vectorizer. The output IR contains code that has been vectorized or ""widened""; according to a loop Vectorization Factor (VF), and/or loop unroll-and-jammed; according to an Unroll Factor (UF).; The design of VPlan follows several high-level guidelines:. 1. Analysis-like: building and manipulating VPlans must not modify the input IR.; In particular, if the best option is not to vectorize at all, the; vectorization process terminates before reaching Step 3, and compilation; should proceed as if VPlans had not been built. 2. Align Cost & Execute: each VPlan must support both estimating the cost and; generating the output IR code, such that the cost estimation evaluates the; to-be-generated code reliably. 3. Support vectorizing additional constructs:. a. Outer-loop vectorization. In particular, VPlan must be able to model the; control-flow of the output IR which may include multiple basic-blocks and; nested loops.; b. SLP vectorization.; c. Combinations of the above, including nested vectorization: vectorizing; both an inner loop and an outer-loop at the same time (each with its own; VF and UF), mixed vectorization: vectorizing a loop with SLP patterns; inside [4]_, (re)vectorizing input IR containing vector",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/VectorizationPlan.rst:1892,guid,guidelines,1892,interpreter/llvm-project/llvm/docs/VectorizationPlan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/VectorizationPlan.rst,1,['guid'],['guidelines']
Usability,"------. Python has an elaborate array interface (buffer) specification, but no; standard library array type that completely implements it; instead, the; canonical Python array type is the NumPy one.; cppyy introduces the basic ``LowLevelView`` array class to avoid having a; direct dependency on NumPy and to guarantee zero copy.; The ``LowLevelView`` type gives access to array details such as the size,; type, etc. and allows reading/writing of array elements, both for interactive; use and through the buffer interface to allow NumPy to interface with them.; For more complex operations, it's recommended to copy from the; ``LowLevelView`` inta a NumPy array, or to create a NumPy view (see below,; under :ref:`NumPy Casts <npcasts>`). `C/C++ casts`; -------------. C++ instances are auto-casted to the most derived available type, so do not; require explicit casts even when a function returns a pointer to a base; class or interface.; However, when given only a ``void*`` or ``intptr_t`` type on return, a cast; is required to turn it into something usable. * **bind_object**: This is the preferred method to proxy a C++ address,; and lives in ``cppyy``, not ``cppyy.ll``, as it is not a low-level C++; cast, but a ``cppyy`` API that is also used internally.; It thus plays well with object identity, references, etc.; Example:. .. code-block:: python. >>> cppyy.cppdef(""""""; ... struct MyStruct { int fInt; };; ... void* create_mystruct() { return new MyStruct{42}; }; ... """"""); ... ; >>> s = cppyy.gbl.create_mystruct(); >>> print(s); <cppyy.LowLevelView object at 0x10559d430>; >>> sobj = cppyy.bind_object(s, 'MyStruct'); >>> print(sobj); <cppyy.gbl.MyStruct object at 0x7ff25e28eb20>; >>> print(sobj.fInt); 42; >>>. Instead of the type name as a string, ``bind_object`` can also take the; actual class (here: ``cppyy.gbl.MyStruct``). * **Typed nullptr**: A Python side proxy can pass through a pointer to; pointer function argument, but if the C++ side allocates memory and; stores it in the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:2119,usab,usable,2119,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['usab'],['usable']
Usability,"---. Clang provides several builtins for working with variadic functions from the C; standard library ``<stdarg.h>`` header:. * ``__builtin_va_list``. A predefined typedef for the target-specific ``va_list`` type. * ``void __builtin_va_start(__builtin_va_list list, <parameter-name>)``. A builtin function for the target-specific ``va_start`` function-like macro.; The ``parameter-name`` argument is the name of the parameter preceding the; ellipsis (``...``) in the function signature. Alternatively, in C23 mode or; later, it may be the integer literal ``0`` if there is no parameter preceding; the ellipsis. This function initializes the given ``__builtin_va_list`` object.; It is undefined behavior to call this function on an already initialized; ``__builin_va_list`` object. * ``void __builtin_va_end(__builtin_va_list list)``. A builtin function for the target-specific ``va_end`` function-like macro. This; function finalizes the given ``__builtin_va_list`` object such that it is no; longer usable unless re-initialized with a call to ``__builtin_va_start`` or; ``__builtin_va_copy``. It is undefined behavior to call this function with a; ``list`` that has not been initialized by either ``__builtin_va_start`` or; ``__builtin_va_copy``. * ``<type-name> __builtin_va_arg(__builtin_va_list list, <type-name>)``. A builtin function for the target-specific ``va_arg`` function-like macro. This; function returns the value of the next variadic argument to the call. It is; undefined behavior to call this builtin when there is no next variadic argument; to retrieve or if the next variadic argument does not have a type compatible; with the given ``type-name``. The return type of the function is the; ``type-name`` given as the second argument. It is undefined behavior to call; this function with a ``list`` that has not been initialized by either; ``__builtin_va_start`` or ``__builtin_va_copy``. * ``void __builtin_va_copy(__builtin_va_list dest, __builtin_va_list src)``. A builtin function",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:136081,usab,usable,136081,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['usab'],['usable']
Usability,"---; name: Bug report; about: Create a report to get an issue fixed; title: ''; labels: bug; ---. - [ ] Checked for duplicates; <!--; Please search in; * https://github.com/root-project/cling/issues; * and meta issues - https://github.com/root-project/cling/issues/406 and https://github.com/root-project/cling/issues/407; for existing reports of your issue. If you find one, you are very welcome to add details to the existing report, for instance.; -->. ### Describe the bug; <!--; A clear and concise description of what the wrong behavior is.; -->. ### Expected behavior; <!--; A clear and concise description of what you expected to happen.; -->. ### To Reproduce; <!--; Steps to reproduce the behavior:; 1. Your code that triggers the issue: at least a part; ideally something we can run ourselves.; 2. Don't forget to attach the required input files!; 3. How to run your code and / or build it.; -->. ### Setup; <!--; 1. Cling version; 2. Operating system; 3. How you obtained Cling, such as with cpt.py (also mention flags) / you built it yourself.; -->. ### Additional context; <!--; Add any other context about the problem here.; -->; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/.github/ISSUE_TEMPLATE/bug_report.md:486,clear,clear,486,interpreter/cling/.github/ISSUE_TEMPLATE/bug_report.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/.github/ISSUE_TEMPLATE/bug_report.md,2,['clear'],['clear']
Usability,"---; name: Feature request; about: Propose a new feature for Cling; title: ''; labels: new feature; ---. ### Is your feature request related to a problem? Please describe.; <!--; A clear and concise description of what the problem is. E.g ""I always have to [...] when I want to [...]""; -->. ### Describe the solution you'd like; <!--; A clear and concise description of what you want to happen.; -->. ### Describe alternatives you've considered; <!--; Can you think of alternative solutions or features?; -->. ### Additional context; <!--; Add any other context or screenshots about the feature requested here.; -->; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/.github/ISSUE_TEMPLATE/feature_request.md:181,clear,clear,181,interpreter/cling/.github/ISSUE_TEMPLATE/feature_request.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/.github/ISSUE_TEMPLATE/feature_request.md,2,['clear'],['clear']
Usability,"--===//. Reassociate should handle the example in GCC PR16157:. extern int a0, a1, a2, a3, a4; extern int b0, b1, b2, b3, b4; ; void f () { /* this can be optimized to four additions... */ ; b4 = a4 + a3 + a2 + a1 + a0; ; b3 = a3 + a2 + a1 + a0; ; b2 = a2 + a1 + a0; ; b1 = a1 + a0; ; } . This requires reassociating to forms of expressions that are already available,; something that reassoc doesn't think about yet. //===---------------------------------------------------------------------===//. These two functions should generate the same code on big-endian systems:. int g(int *j,int *l) { return memcmp(j,l,4); }; int h(int *j, int *l) { return *j - *l; }. this could be done in SelectionDAGISel.cpp, along with other special cases,; for 1,2,4,8 bytes. //===---------------------------------------------------------------------===//. It would be nice to revert this patch:; http://lists.llvm.org/pipermail/llvm-commits/Week-of-Mon-20060213/031986.html. And teach the dag combiner enough to simplify the code expanded before ; legalize. It seems plausible that this knowledge would let it simplify other; stuff too. //===---------------------------------------------------------------------===//. For vector types, DataLayout.cpp::getTypeInfo() returns alignment that is equal; to the type size. It works but can be overly conservative as the alignment of; specific vector types are target dependent. //===---------------------------------------------------------------------===//. We should produce an unaligned load from code like this:. v4sf example(float *P) {; return (v4sf){P[0], P[1], P[2], P[3] };; }. //===---------------------------------------------------------------------===//. Add support for conditional increments, and other related patterns. Instead; of:. 	movl 136(%esp), %eax; 	cmpl $0, %eax; 	je LBB16_2	#cond_next; LBB16_1:	#cond_true; 	incl _foo; LBB16_2:	#cond_next. emit:; 	movl	_foo, %eax; 	cmpl	$1, %edi; 	sbbl	$-1, %eax; 	movl	%eax, _foo. //===------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:3464,simpl,simplify,3464,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplify']
Usability,"->Inspect()`, see ""Inspecting Objects"". ### Collections. To store an object in a ROOT collection, it must be a descendent of; **`TObject`**. This is convenient if you want to store objects of; different classes in the same collection and execute the method of the; same name on all members of the collection. For example, the list of; graphics primitives are in a ROOT collection called **`TList`**. When; the canvas is drawn, the `Paint` method is executed on the entire; collection. Each member may be a different class, and if the `Paint`; method is not implemented, **`TObject::Paint`** will be executed. ### Input/Output. The `TObject::Write` method is the interface to the ROOT I/O system. It; streams the object into a buffer using the `Streamer` method. It; supports cycle numbers and automatic schema evolution. See; ""Input/Output"". ### Paint/Draw. These graphics methods are defaults; their implementation in; **`TObject`** does not use the graphics subsystem. The `TObject::Draw`; method is simply a call to `AppendPad`. The `Paint` method is empty. The; default is provided so that one can call `Paint` in a collection. The; method `GetDrawOption` returns the draw option that was used when the; object was drawn on the canvas. This is especially relevant with; histograms and graphs. ### Clone/DrawClone. Two useful methods are `Clone` and `DrawClone`. The `Clone` method takes; a snapshot of the object with the `Streamer` and creates a new object.; The `DrawClone` method does the same thing and in addition draws the; clone. ### Browse. This method is called if the object is browse-able and is to be; displayed in the object browser. For example the **`TTree`**; implementation of `Browse`, calls the Browse method for each branch. The; `TBranch::Browse` method displays the name of each leaf. For the; object's `Browse` method to be called, the `IsFolder()` method must be; overridden to return true. This does not mean it has to be a folder, it; just means that it is browse-able. #",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:2922,simpl,simply,2922,documentation/users-guide/AddingaClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md,1,['simpl'],['simply']
Usability,"-callgraph``: Print a call graph; ---------------------------------------. This pass, only available in ``opt``, prints the call graph to standard error; in a human-readable form. ``print-callgraph-sccs``: Print SCCs of the Call Graph; ------------------------------------------------------. This pass, only available in ``opt``, prints the SCCs of the call graph to; standard error in a human-readable form. ``print-cfg-sccs``: Print SCCs of each function CFG; ---------------------------------------------------. This pass, only available in ``opt``, printsthe SCCs of each function CFG to; standard error in a human-readable fom. ``print-function``: Print function to stderr; --------------------------------------------. The ``PrintFunctionPass`` class is designed to be pipelined with other; ``FunctionPasses``, and prints out the functions of the module as they are; processed. ``print-module``: Print module to stderr; ----------------------------------------. This pass simply prints out the entire module when it is executed. ``regions``: Detect single entry single exit regions; ----------------------------------------------------. The ``RegionInfo`` pass detects single entry single exit regions in a function,; where a region is defined as any subgraph that is connected to the remaining; graph at only two spots. Furthermore, a hierarchical region tree is built. .. _passes-scalar-evolution:. ``scalar-evolution``: Scalar Evolution Analysis; -----------------------------------------------. The ``ScalarEvolution`` analysis can be used to analyze and categorize scalar; expressions in loops. It specializes in recognizing general induction; variables, representing them with the abstract and opaque ``SCEV`` class.; Given this analysis, trip counts of loops and other important properties can be; obtained. This analysis is primarily useful for induction variable substitution and; strength reduction. ``scev-aa``: ScalarEvolution-based Alias Analysis; ----------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:9942,simpl,simply,9942,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simply']
Usability,"-constructed subobjects; Unknown. 2337; open; Incorrect implication of logic ladder for conversion sequence tiebreakers; Not resolved. 2338; CD5; Undefined behavior converting to short enums with fixed underlying types; Clang 12. 2339; CD5; Underspecified template arguments in structured bindings; Unknown. 2340; open; Reference collapsing and structured bindings; Not resolved. 2341; CD5; Structured bindings with static storage duration; Unknown. 2342; CD5; Reference reinterpret_cast and pointer-interconvertibility; Unknown. 2343; C++20; void* non-type template parameters; Unknown. 2344; NAD; Redeclaration of names in init-statements; Unknown. 2345; CD5; Jumping across initializers in init-statements and conditions; Unknown. 2346; CD5; Local variables in default arguments; Clang 11. 2347; C++20; Passing short scoped enumerations to ellipsis; Unknown. 2348; NAD; Non-templated constexpr if; Unknown. 2349; NAD; Class/enumeration names vs conditions; Unknown. 2350; NAD; Forwarding references and deduction guides; Unknown. 2351; CD5; void{}; Unknown. 2352; CD5; Similar types and reference binding; Clang 10. 2353; CD5; Potential results of a member access expression for a static data member; Clang 9. 2354; CD5; Extended alignment and object representation; Clang 15. 2355; CD6; Deducing noexcept-specifiers; Unknown. 2356; CD5; Base class copy and move constructors should not be inherited; Unknown. 2357; NAD; Lookup in member function declarations; Unknown. 2358; CD5; Explicit capture of value; Clang 16. 2359; CD5; Unintended copy initialization with designated initializers; Unknown. 2360; CD5; [[maybe_unused]] and structured bindings; Unknown. 2361; open; Unclear description of longjmp undefined behavior; Not resolved. 2362; open; __func__ should be constexpr; Not resolved. 2363; NAD; Opaque enumeration friend declarations; Unknown. 2364; NAD; Constant expressions, aggregate initialization, and modifications; Unknown. 2365; CD5; Confusing specification for dynamic_cast; Unk",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:160510,guid,guides,160510,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['guid'],['guides']
Usability,"-dependent expressions; Unknown. 2406; CD5; [[fallthrough]] attribute and iteration statements; Clang 5. 2407; C++23; Missing entry in Annex C for defaulted comparison operators; Unknown. 2408; NAD; Temporaries and previously-initialized elements in aggregate initialization; Unknown. 2409; drafting; Explicit specializations of constexpr static data members; Not resolved. 2410; C++23; Implicit calls of immediate functions; Unknown. 2411; C++20; Comparison of pointers to members in template non-type arguments; Unknown. 2412; review; SFINAE vs undeduced placeholder type; Not resolved. 2413; CD6; typename in conversion-function-ids; Unknown. 2414; C++20; Unclear results if both member and friend operator<=> are declared; Unknown. 2415; NAD; using-declarations vs copy assignment operators; Unknown. 2416; C++20; Explicit specializations vs constexpr and consteval; Unknown. 2417; open; Explicit instantiation and exception specifications; Not resolved. 2418; CD5; Missing cases in definition of “usable in constant expressions”; Unknown. 2419; C++20; Loss of generality treating pointers to objects as one-element arrays; Unknown. 2420; dup; Exception specifications in explicit instantiation; Unknown. 2421; drafting; Explicit instantiation of constrained member functions; Not resolved. 2422; C++20; Incorrect grammar for deduction-guide; Unknown. 2423; NAD; Typedefs, names, and entities; Unknown. 2424; C++20; constexpr initialization requirements for variant members; Unknown. 2425; open; Confusing wording for deduction from a type; Not resolved. 2426; C++20; Reference to destructor that cannot be invoked; Unknown. 2427; C++20; Deprecation of volatile operands and unevaluated contexts; Unknown. 2428; C++23; Deprecating a concept; Unknown. 2429; C++20; Initialization of thread_local variables referenced by lambdas; Unknown. 2430; C++20; Completeness of return and parameter types of member functions; Unknown. 2431; C++20; Full-expressions and temporaries bound to references; Unknown",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:165468,usab,usable,165468,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['usab'],['usable']
Usability,"-editable. Then no new objects can be; added, and the existing objects and the pad can not be changed with the; mouse or programmatically. By default the **`TPad`** is editable. ``` {.cpp}; TPad::SetEditable(kFALSE); ```. ## Graphical Objects. In this paragraph, we describe the various simple 2D graphical objects; defined in ROOT. Usually, one defines these objects with their; constructor and draws them with their `Draw()` method. Therefore, the; examples will be very brief. Most graphical objects have line and fill; attributes (color, width) that will be described in ""Graphical objects; attributes"". If the user wants more information, the class names are; given and they may refer to the online developer documentation. This is; especially true for functions and methods that set and get internal; values of the objects described here. By default 2D graphical objects; are created in User Coordinates with (0, 0) in the lower left corner. ### Lines, Arrows and Polylines. The simplest graphical object is a line. It is implemented in the; **`TLine`** class. The line constructor is:. ``` {.cpp}; TLine(Double_t x1,Double_t y1,Double_t x2,Double_t y2); ```. The arguments `x1`, `y1`, `x2`, `y2` are the coordinates of the first; and second point. It can be used:. ``` {.cpp}; root[] l = new TLine(0.2,0.2,0.8,0.3); root[] l->Draw(); ```. The arrow constructor is:. ``` {.cpp}; TArrow(Double_t x1, Double_t y1,; Double_t x2, Double_t y2,; Float_t arrowsize, Option_t *option); ```. It defines an arrow between points `x1,y1` and `x2,y2`. The arrow size; is in percentage of the pad height. The `option` parameter has the; following meanings:. ![](pictures/020000A7.jpg) ""\>"". ![](pictures/020000A8.jpg) ""\<|"". ![](pictures/020000A9.jpg) ""\<"". ![](pictures/020000AA.jpg) ""|\>"". ![](pictures/020000AB.jpg) ""\<\>"". ![](pictures/020000AC.jpg) ""\<|\>"". Once an arrow is drawn on the screen, one can:. - click on one of the edges and move this edge. - click on any other arrow part to move the entire",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:32331,simpl,simplest,32331,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simplest']
Usability,"-read periodically to; check for new inputs; this allows detection of new inputs that were discovered; by other fuzzing processes.; ``-jobs``; Number of fuzzing jobs to run to completion. Default value is 0, which runs a; single fuzzing process until completion. If the value is >= 1, then this; number of jobs performing fuzzing are run, in a collection of parallel; separate worker processes; each such worker process has its; ``stdout``/``stderr`` redirected to ``fuzz-<JOB>.log``.; ``-workers``; Number of simultaneous worker processes to run the fuzzing jobs to completion; in. If 0 (the default), ``min(jobs, NumberOfCpuCores()/2)`` is used.; ``-dict``; Provide a dictionary of input keywords; see Dictionaries_.; ``-use_counters``; Use `coverage counters`_ to generate approximate counts of how often code; blocks are hit; defaults to 1.; ``-reduce_inputs``; Try to reduce the size of inputs while preserving their full feature sets;; defaults to 1.; ``-use_value_profile``; Use `value profile`_ to guide corpus expansion; defaults to 0.; ``-only_ascii``; If 1, generate only ASCII (``isprint``+``isspace``) inputs. Defaults to 0.; ``-artifact_prefix``; Provide a prefix to use when saving fuzzing artifacts (crash, timeout, or; slow inputs) as ``$(artifact_prefix)file``. Defaults to empty.; ``-exact_artifact_path``; Ignored if empty (the default). If non-empty, write the single artifact on; failure (crash, timeout) as ``$(exact_artifact_path)``. This overrides; ``-artifact_prefix`` and will not use checksum in the file name. Do not use; the same path for several parallel processes.; ``-print_pcs``; If 1, print out newly covered PCs. Defaults to 0.; ``-print_final_stats``; If 1, print statistics at exit. Defaults to 0.; ``-detect_leaks``; If 1 (default) and if LeakSanitizer is enabled; try to detect memory leaks during fuzzing (i.e. not only at shut down).; ``-close_fd_mask``; Indicate output streams to close at startup. Be careful, this will; remove diagnostic output from targe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:13336,guid,guide,13336,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['guid'],['guide']
Usability,"-specific set of; ""extra"" possible NaN payloads. The set can depend on the input operand values.; This set is empty on x86 and ARM, but can be non-empty on other architectures.; (For instance, on wasm, if any input NaN does not have the preferred all-zero; payload or any input NaN is an SNaN, then this set contains all possible; payloads; otherwise, it is empty. On SPARC, this set consists of the all-one; payload.). In particular, if all input NaNs are quiet (or if there are no input NaNs), then; the output NaN is definitely quiet. Signaling NaN outputs can only occur if they; are provided as an input value. For example, ""fmul SNaN, 1.0"" may be simplified; to SNaN rather than QNaN. Similarly, if all input NaNs are preferred (or if; there are no input NaNs) and the target does not have any ""extra"" NaN payloads,; then the output NaN is guaranteed to be preferred. Floating-point math operations are allowed to treat all NaNs as if they were; quiet NaNs. For example, ""pow(1.0, SNaN)"" may be simplified to 1.0. Code that requires different behavior than this should use the; :ref:`Constrained Floating-Point Intrinsics <constrainedfp>`.; In particular, constrained intrinsics rule out the ""Unchanged NaN propagation""; case; they are guaranteed to return a QNaN. Unfortunately, due to hard-or-impossible-to-fix issues, LLVM violates its own; specification on some architectures:. - x86-32 without SSE2 enabled may convert floating-point values to x86_fp80 and; back when performing floating-point math operations; this can lead to results; with different precision than expected and it can alter NaN values. Since; optimizations can make contradicting assumptions, this can lead to arbitrary; miscompilations. See `issue #44218; <https://github.com/llvm/llvm-project/issues/44218>`_.; - x86-32 (even with SSE2 enabled) may implicitly perform such a conversion on; values returned from a function for some calling conventions. See `issue; #66803 <https://github.com/llvm/llvm-project/issues/668",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:160217,simpl,simplified,160217,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simplified']
Usability,"-tokens]</span></b>; #endif bad; <span style=""color:green"">^</span>; <span style=""color:green"">//</span>; </pre>. When this is disabled, Clang will just print:. ::. test.c:2:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. If the ``NO_COLOR`` environment variable is defined and not empty; (regardless of value), color diagnostics are disabled. If ``NO_COLOR`` is; defined and ``-fcolor-diagnostics`` is passed on the command line, Clang; will honor the command line argument. .. option:: -fansi-escape-codes. Controls whether ANSI escape codes are used instead of the Windows Console; API to output colored diagnostics. This option is only used on Windows and; defaults to off. .. option:: -fdiagnostics-format=clang/msvc/vi. Changes diagnostic output format to better match IDEs and command line tools. This option controls the output format of the filename, line number,; and column printed in diagnostic messages. The options, and their; affect on formatting a simple conversion diagnostic, follow:. **clang** (default); ::. t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int'. **msvc**; ::. t.c(3,11) : warning: conversion specifies type 'char *' but the argument has type 'int'. **vi**; ::. t.c +3:11: warning: conversion specifies type 'char *' but the argument has type 'int'. .. _opt_fdiagnostics-show-option:. .. option:: -f[no-]diagnostics-show-option. Enable ``[-Woption]`` information in diagnostic line. This option, which defaults to on, controls whether or not Clang; prints the associated :ref:`warning group <cl_diag_warning_groups>`; option name when outputting a warning diagnostic. For example, in; this output:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. Passing **-fno-diagnostics-show-option** will prevent Clang from; printing the [:option:`-Wextra-tokens`] information in; the diagnostic. This information tells you the flag needed to enabl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:8625,simpl,simple,8625,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['simpl'],['simple']
Usability,"-types sequence; of the coroutine. They will be turned into return values from the ramp; and continuation functions, along with the next continuation function. Semantics:; """""""""""""""""""". The result of the intrinsic indicates whether the coroutine should resume; abnormally (non-zero). In a normal coroutine, it is undefined behavior if the coroutine executes; a call to ``llvm.coro.suspend.retcon`` after resuming abnormally. In a yield-once coroutine, it is undefined behavior if the coroutine; executes a call to ``llvm.coro.suspend.retcon`` after resuming in any way. Coroutine Transformation Passes; ===============================; CoroEarly; ---------; The pass CoroEarly lowers coroutine intrinsics that hide the details of the; structure of the coroutine frame, but, otherwise not needed to be preserved to; help later coroutine passes. This pass lowers `coro.frame`_, `coro.done`_,; and `coro.promise`_ intrinsics. .. _CoroSplit:. CoroSplit; ---------; The pass CoroSplit builds coroutine frame and outlines resume and destroy parts; into separate functions. CoroElide; ---------; The pass CoroElide examines if the inlined coroutine is eligible for heap; allocation elision optimization. If so, it replaces; `coro.begin` intrinsic with an address of a coroutine frame placed on its caller; and replaces `coro.alloc` and `coro.free` intrinsics with `false` and `null`; respectively to remove the deallocation code.; This pass also replaces `coro.resume` and `coro.destroy` intrinsics with direct; calls to resume and destroy functions for a particular coroutine where possible. CoroCleanup; -----------; This pass runs late to lower all coroutine related intrinsics not replaced by; earlier passes. Attributes; ==========. coro_only_destroy_when_complete; -------------------------------. When the coroutine are marked with coro_only_destroy_when_complete, it indicates; the coroutine must reach the final suspend point when it get destroyed. This attribute only works for switched-resume corou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:56672,resume,resume,56672,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,". ## 3D Graphics Libraries. ### Gl in Pad. - Transparency is now implemented for ""GL in Pad"" (`gStyle->SetCanvasPreferGL(1)`).; - Introduce the flag `CanvasPreferGL` in `rootrc.in`. So OpenGL can be use by; default. The default value for this flag is 0 (no OpenGL).; - Fix size issues with the FTGL text.; - Make `TMathText` work with FTGL; - Linear and radial color gradients are implemented for ""GL in Pad""; (only a simple radial color gradient),; see also the notes about TLinearGradient and TRadialGradient classes.; - ""GL in Pad"" and gl hist painters were updated to support Retina displays; (OS X + Cocoa).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v600/index.md:418,simpl,simple,418,graf3d/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v600/index.md,1,['simpl'],['simple']
Usability,". ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position $\vec{r}$ and direction $\vec{n}$ with respect to the world; reference frame. The direction $\vec{n}$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of **`TGeo`** to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with ROOT. The interface methods related to tracking are incorporated into; **`TGeoManager`** class and implemented in the navigator class; **`TGeoNavigator`**. In order to be able to start tracking, one has to; define the initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ```. Upon closing the geometry a default navigator is provided as first one; in this list, b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:101832,simpl,simple,101832,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,". - ‘ `s` ' - errors are:. - `spread` for a non-zero spread. - `SQRT(Y)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `i` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `1/SQRT(12*N)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `G` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `sigma/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. The option ' `i` ' is used for integer Y values with the uncertainty; of $\pm 0.5$, assuming the probability that Y takes any value between Y-0.5; and Y+0.5 is uniform (the same argument for Y uniformly distributed; between Y and Y+1). An example is an ADC measurement. The '`G`' option; is useful, if all Y variables are distributed according to some known; Gaussian of standard deviation Sigma. For example when all Y's are; experimental quantities measured with the same instrument with; precision Sigma. The next figure shows the graphic output of this; simple example of a profile histogram. ``` {.cpp}; {; // Create a canvas giving the coordinates and the size; TCanvas *c1 = new TCanvas(""c1"", ""Profile example"",200,10,700,500);. // Create a profile with the name, title, the number of bins,; // the low and high limit of the x-axis and the low and high; // limit of the y-axis.; // No option is given so the default is used.; hprof = new TProfile(""hprof"",; ""Profile of pz versus px"",100,-4,4,0,20);. // Fill the profile 25000 times with random numbers; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; // Use the random number generator to get two numbers following; // a gaussian distribution with mean=0 and sigma=1; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof->Fill(px,pz,1);; }; hprof->Draw();; }; ```. ![A profile histogram example](pictures/0300003E.png). ### Drawing a Profile without Error Bars. To draw a profile histogram and not show the error bars use the; ""`HIST`"" option in the **`TProfile`**`::Draw` method. This wil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:65675,simpl,simple,65675,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['simpl'],['simple']
Usability,". --target ${target}; --config $<CONFIG> PARENT_SCOPE); endif(); endfunction(). set(COMPILER_RT_SRC_ROOT ${LLVM_MAIN_SRC_DIR}/projects/compiler-rt); # Fallback to the external path, if the other one isn't available.; # This is the same behavior (try ""internal"", then check the LLVM_EXTERNAL_...; # variable) as in add_llvm_external_project; if(NOT EXISTS ${COMPILER_RT_SRC_ROOT}); # We don't want to set it if LLVM_EXTERNAL_COMPILER_RT_SOURCE_DIR is """"; if(LLVM_EXTERNAL_COMPILER_RT_SOURCE_DIR); set(COMPILER_RT_SRC_ROOT ${LLVM_EXTERNAL_COMPILER_RT_SOURCE_DIR}); endif(); endif(). if(LLVM_BUILD_EXTERNAL_COMPILER_RT AND EXISTS ${COMPILER_RT_SRC_ROOT}/). # Add compiler-rt as an external project.; set(COMPILER_RT_PREFIX ${CMAKE_BINARY_DIR}/projects/compiler-rt). set(STAMP_DIR ${CMAKE_CURRENT_BINARY_DIR}/compiler-rt-stamps/); set(BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/compiler-rt-bins/). add_custom_target(compiler-rt-clear; COMMAND ${CMAKE_COMMAND} -E remove_directory ${BINARY_DIR}; COMMAND ${CMAKE_COMMAND} -E remove_directory ${STAMP_DIR}; COMMENT ""Clobberring compiler-rt build and stamp directories""; ). # Find all variables that start with COMPILER_RT and populate a variable with; # them.; get_cmake_property(variableNames VARIABLES); foreach(variableName ${variableNames}); if(variableName MATCHES ""^COMPILER_RT""); string(REPLACE "";"" ""\;"" value ""${${variableName}}""); list(APPEND COMPILER_RT_PASSTHROUGH_VARIABLES; -D${variableName}=${value}); endif(); endforeach(). set(compiler_rt_configure_deps); if(TARGET cxx-headers); list(APPEND compiler_rt_configure_deps ""cxx-headers""); endif(); if(LLVM_INCLUDE_TESTS); list(APPEND compiler_rt_configure_deps LLVMTestingSupport); endif(). include(GetClangResourceDir); get_clang_resource_dir(output_resource_dir PREFIX ${LLVM_BINARY_DIR}); get_clang_resource_dir(install_resource_dir); ExternalProject_Add(compiler-rt; DEPENDS llvm-config clang ${compiler_rt_configure_deps}; PREFIX ${COMPILER_RT_PREFIX}; SOURCE_DIR ${COMPILER_RT_SRC_ROOT}; STAMP",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/runtime/CMakeLists.txt:1439,clear,clear,1439,interpreter/llvm-project/clang/runtime/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/runtime/CMakeLists.txt,1,['clear'],['clear']
Usability,". .. code-block:: c++. /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.; static int CurTok;; static int getNextToken() {; return CurTok = gettok();; }. This implements a simple token buffer around the lexer. This allows us; to look one token ahead at what the lexer is returning. Every function; in our parser will assume that CurTok is the current token that needs to; be parsed. .. code-block:: c++. /// LogError* - These are little helper functions for error handling.; std::unique_ptr<ExprAST> LogError(const char *Str) {; fprintf(stderr, ""Error: %s\n"", Str);; return nullptr;; }; std::unique_ptr<PrototypeAST> LogErrorP(const char *Str) {; LogError(Str);; return nullptr;; }. The ``LogError`` routines are simple helper routines that our parser will; use to handle errors. The error recovery in our parser will not be the; best and is not particular user-friendly, but it will be enough for our; tutorial. These routines make it easier to handle errors in routines; that have various return types: they always return null. With these basic helper functions, we can implement the first piece of; our grammar: numeric literals. Basic Expression Parsing; ========================. We start with numeric literals, because they are the simplest to; process. For each production in our grammar, we'll define a function; which parses that production. For numeric literals, we have:. .. code-block:: c++. /// numberexpr ::= number; static std::unique_ptr<ExprAST> ParseNumberExpr() {; auto Result = std::make_unique<NumberExprAST>(NumVal);; getNextToken(); // consume the number; return std::move(Result);; }. This routine is very simple: it expects to be called when the current; token is a ``tok_number`` token. It takes the current number value,; creates a ``NumberExprAST`` node, advances the lexer to the next token,; and finally returns. The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:6790,user-friendly,user-friendly,6790,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['user-friendly'],['user-friendly']
Usability,". .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:78775,simpl,simple,78775,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['simpl'],['simple']
Usability,". .. option:: -fforce-emit-vtables. In order to improve devirtualization, forces emitting of vtables even in; modules where it isn't necessary. It causes more inline virtual functions; to be emitted. .. option:: -fno-assume-sane-operator-new. Don't assume that the C++'s new operator is sane. This option tells the compiler to do not assume that C++'s global; new operator will always return a pointer that does not alias any; other pointer when the function returns. .. option:: -fassume-nothrow-exception-dtor. Assume that an exception object' destructor will not throw, and generate; less code for catch handlers. A throw expression of a type with a; potentially-throwing destructor will lead to an error. By default, Clang assumes that the exception object may have a throwing; destructor. For the Itanium C++ ABI, Clang generates a landing pad to; destroy local variables and call ``_Unwind_Resume`` for the code; ``catch (...) { ... }``. This option tells Clang that an exception object's; destructor will not throw and code simplification is possible. .. option:: -ftrap-function=[name]. Instruct code generator to emit a function call to the specified; function name for ``__builtin_trap()``. LLVM code generator translates ``__builtin_trap()`` to a trap; instruction if it is supported by the target ISA. Otherwise, the; builtin is translated into a call to ``abort``. If this option is; set, then the code generator will always lower the builtin to a call; to the specified function regardless of whether the target ISA has a; trap instruction. This option is useful for environments (e.g.; deeply embedded) where a trap cannot be properly handled, or when; some custom behavior is desired. .. option:: -ftls-model=[model]. Select which TLS model to use. Valid values are: ``global-dynamic``, ``local-dynamic``,; ``initial-exec`` and ``local-exec``. The default value is; ``global-dynamic``. The compiler may use a different model if the; selected model is not supported by the target, or if",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:82722,simpl,simplification,82722,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['simpl'],['simplification']
Usability,". // Emit the start code first, without 'variable' in scope.; Value *StartVal = Start->codegen();; if (!StartVal); return nullptr;. // Store the value into the alloca.; Builder->CreateStore(StartVal, Alloca);; ... // Compute the end condition.; Value *EndCond = End->codegen();; if (!EndCond); return nullptr;. // Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.; Value *CurVar = Builder->CreateLoad(Alloca->getAllocatedType(), Alloca,; VarName.c_str());; Value *NextVar = Builder->CreateFAdd(CurVar, StepVal, ""nextvar"");; Builder->CreateStore(NextVar, Alloca);; ... This code is virtually identical to the code `before we allowed mutable; variables <LangImpl05.html#code-generation-for-the-for-loop>`_. The big difference is that we; no longer have to construct a PHI node, and we use load/store to access; the variable as needed. To support mutable argument variables, we need to also make allocas for; them. The code for this is also pretty simple:. .. code-block:: c++. Function *FunctionAST::codegen() {; ...; Builder->SetInsertPoint(BB);. // Record the function arguments in the NamedValues map.; NamedValues.clear();; for (auto &Arg : TheFunction->args()) {; // Create an alloca for this variable.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());. // Store the initial value into the alloca.; Builder->CreateStore(&Arg, Alloca);. // Add arguments to variable symbol table.; NamedValues[std::string(Arg.getName())] = Alloca;; }. if (Value *RetVal = Body->codegen()) {; ... For each argument, we make an alloca, store the input value to the; function into the alloca, and register the alloca as the memory location; for the argument. This method gets invoked by ``FunctionAST::codegen()``; right after it sets up the entry block for the function. The final missing piece is adding the mem2reg pass, which allows us to; get good codegen once again:. .. code-block:: c++. // Promote allocas to registers",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:15615,simpl,simple,15615,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['simpl'],['simple']
Usability,". 2. More robust interfaces; * Compile-time type safety by default; * Decomposition into layers: logical layer, primitives layer, storage layer; * Separation of data model and live data; * Self-contained I/O code to support creation of a standalone I/O library. Concepts; --------. At the **logical layer**, the user defines a data model using the RNTupleModel class.; The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree.; The data model can contain (nested) collections, e.g., a type can be `std::vector<std::vector<float>>`. Each serializable type is represented by a **field**, concretely by a templated version of RField,; e.g. `RField<double>`. A field can generate or adopt an associated **value**, which represents a memory location; storing a value of the given C++ type. These distinguished memory locations are the destinations and sources for the; deserialization and serialization. The (de-)serialization is a mapping from the C++ type to the more simple **column** type system. A column contains; an arbitrary number of fixed-sized elements of a well-defined set of types: integers and floats of different; bit sizes. A C++ type may be mapped to multiple columns. For instance, an `std::vector<float>` maps to two columns,; an offset column indicating the size of the vector per entry, and a payload column with the float data. Columns are partitioned into **pages** (roughly: TTree baskets) of a few kB -- a few tens of kB each.; The **physical layer** (only) needs to provide the means to store and retrieve pages. The physical layer is; decoupled from the high-level C++ logic. The physical layer implements an abstract page storage interface,; so that dedicated implementations for key-value stores and other storage systems are conceivable.; At this point, the only provided backend stores the pages in ROOT files. RNTuples are further grouped into **clusters**, which are, like TTree clusters, self-contained blocks of; con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md:2248,simpl,simple,2248,tree/ntuple/v7/doc/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md,1,['simpl'],['simple']
Usability,". 4. Build a final release Clang (along with whatever other binaries you need); using the profile collected from your benchmark. In more detailed steps:. 1. Configure a Clang build as you normally would. It's highly recommended that; you use the Release configuration for this, since it will be used to build; another Clang. Because you need Clang and supporting libraries, you'll want; to build the ``all`` target (e.g. ``ninja all`` or ``make -j4 all``). 2. Configure a Clang build as above, but add the following CMake args:. - ``-DLLVM_BUILD_INSTRUMENTED=IR`` -- This causes us to build everything; with instrumentation.; - ``-DLLVM_BUILD_RUNTIME=No`` -- A few projects have bad interactions when; built with profiling, and aren't necessary to build. This flag turns them; off.; - ``-DCMAKE_C_COMPILER=/path/to/stage1/clang`` - Use the Clang we built in; step 1.; - ``-DCMAKE_CXX_COMPILER=/path/to/stage1/clang++`` - Same as above. In this build directory, you simply need to build the ``clang`` target (and; whatever supporting tooling your benchmark requires). 3. As mentioned above, this has two steps: gathering profile data, and then; massaging it into a useful form:. a. Build your benchmark using the Clang generated in step 2. The 'standard'; benchmark recommended is to run ``check-clang`` and ``check-llvm`` in your; instrumented Clang's build directory, and to do a full build of Clang/LLVM; using your instrumented Clang. So, create yet another build directory,; with the following CMake arguments:. - ``-DCMAKE_C_COMPILER=/path/to/stage2/clang`` - Use the Clang we built in; step 2.; - ``-DCMAKE_CXX_COMPILER=/path/to/stage2/clang++`` - Same as above. If your users are fans of debug info, you may want to consider using; ``-DCMAKE_BUILD_TYPE=RelWithDebInfo`` instead of; ``-DCMAKE_BUILD_TYPE=Release``. This will grant better coverage of; debug info pieces of clang, but will take longer to complete and will; result in a much larger build directory. It's recommended to build the ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst:4489,simpl,simply,4489,interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst,1,['simpl'],['simply']
Usability,". Big endian vector load using ``LDR``. A vector is a consecutive sequence of items that are operated on simultaneously. To load a 64-bit vector, 64 bits need to be read from memory. In little endian mode, we can do this by just performing a 64-bit load - ``LDR q0, [foo]``. However if we try this in big endian mode, because of the byte swapping the lane indices end up being swapped! The zero'th item as laid out in memory becomes the n'th lane in the vector. .. figure:: ARM-BE-ld1.png; :align: right. Big endian vector load using ``LD1``. Note that the lanes retain the correct ordering. Because of this, the instruction ``LD1`` performs a vector load but performs byte swapping not on the entire 64 bits, but on the individual items within the vector. This means that the register content is the same as it would have been on a little endian system. It may seem that ``LD1`` should suffice to perform vector loads on a big endian machine. However there are pros and cons to the two approaches that make it less than simple which register format to pick. There are two options:. 1. The content of a vector register is the same *as if* it had been loaded with an ``LDR`` instruction.; 2. The content of a vector register is the same *as if* it had been loaded with an ``LD1`` instruction. Because ``LD1 == LDR + REV`` and similarly ``LDR == LD1 + REV`` (on a big endian system), we can simulate either type of load with the other type of load plus a ``REV`` instruction. So we're not deciding which instructions to use, but which format to use (which will then influence which instruction is best to use). .. The 'clearer' container is required to make the following section header come after the floated; images above.; .. container:: clearer. Note that throughout this section we only mention loads. Stores have exactly the same problems as their associated loads, so have been skipped for brevity. Considerations; ==============. LLVM IR Lane ordering; ---------------------. LLVM IR has first c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst:3684,simpl,simple,3684,interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,1,['simpl'],['simple']
Usability,". Checker Developer Manual. This Page Is Under Construction; Checker Developer Manual; The static analyzer engine performs path-sensitive exploration of the program and; relies on a set of checkers to implement the logic for detecting and; constructing specific bug reports. Anyone who is interested in implementing their own; checker, should check out the Building a Checker in 24 Hours talk; (slides; video); and refer to this page for additional information on writing a checker. The static analyzer is a; part of the Clang project, so consult Hacking on Clang; and LLVM Programmer's Manual; for developer guidelines and post your questions and proposals to the; Static Analyzer subcategory at; the official LLVM Discourse server. Getting Started; Static Analyzer Overview. Interaction with Checkers; Representing Values. Idea for a Checker; Checker Registration; Events, Callbacks, and Checker Class Structure; Custom Program States; Bug Reports; AST Visitors; Testing; Useful Commands/Debugging Hints. Attaching the Debugger; Narrowing Down the Problem; Visualizing the Analysis; Debug Prints and Tricks. Additional Sources of Information; Useful Links. Getting Started. To check out the source code and build the project, follow steps 1-4 of; the Clang Getting Started; page.; The analyzer source code is located under the Clang source tree:; ; $ cd llvm/tools/clang. See: include/clang/StaticAnalyzer, lib/StaticAnalyzer,; test/Analysis.; The analyzer regression tests can be executed from the Clang's build; directory:; ; $ cd ../../../; cd build/tools/clang; TESTDIRS=Analysis make test. Analyze a file with the specified checker:; ; $ clang -cc1 -analyze -analyzer-checker=core.DivideZero test.c. List the available checkers:; ; $ clang -cc1 -analyzer-checker-help. See the analyzer help for different output formats, fine tuning, and; debug options:; ; $ clang -cc1 -help | grep ""analyzer"". Static Analyzer Overview; The analyzer core performs symbolic execution of the given program. All t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:609,guid,guidelines,609,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['guid'],['guidelines']
Usability,". Clang - Features and Goals. Clang - Features and Goals. This page describes the features and goals of; Clang in more detail and gives a more broad explanation about what we mean.; These features are:. End-User Features:. Fast compiles and low memory use; Expressive diagnostics; GCC compatibility. Utility and Applications:. Library based architecture; Support diverse clients; Integration with IDEs; Use the LLVM 'BSD' License. Internal Design and Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++,; and Objective C++; Conformance with C/C++/ObjC and their; variants. End-User Features. Fast compiles and Low Memory Use. A major focus of our work on clang is to make it fast, light and scalable.; The library-based architecture of clang makes it straight-forward to time and; profile the cost of each layer of the stack, and the driver has a number of; options for performance analysis. Many detailed benchmarks can be found online.; Compile time performance is important, but when using clang as an API, often; memory use is even more so: the less memory the code takes the more code you can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:513,simpl,simple,513,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['simpl'],['simple']
Usability,". Clang - Open Projects. Open Clang Projects; Here are a few tasks that are available for anyone to work on, depending; on what your interests are. This list is provided to generate ideas, it is not; intended to be comprehensive. Please ask on; Discourse for more specifics; or to verify that one of these isn't already completed. Refresh and improve Clang's documentation: Clang is inconsistent; with documenting implementation-defined behaviors. We have significant; documentation in the ; Language Extensions page, but the information is incomplete and the page is; difficult to navigate. We would appreciate help with:. improving the way this information is presented to users,; table generating; documentation where possible, such as for implementation limits or other; target-specific information,; adding documentation for currently; ; undocumented attributes,; documenting ; diagnostic group flags (adding code examples of what is diagnosed, or; other relevant information), or; documenting ; command line options, or; help with completing other missing documentation. These projects are independent of each other.; Complete the investigation into Clang's C conformance: Clang's; C status page contain a number of entries marked as; Unknown. Completing the investigation involves adding; test; coverage for the various standards papers and updating the documentation; accordingly. Improve Clang's C and C++ standard conformance test coverage:; Clang's test suite is structured such that most tests are written to provide; coverage for what part of the compiler the feature's implementation exists in;; we have parsing tests in clang/test/Parser, and semantic analysis; tests in clang/test/Sema*, etc. We also have tests written to; provide coverage for the standard requirements (clang/test/CXX and; clang/test/C). The standards coverage is not structured in a way; that makes it easy to maintain as the standards change over time. No commercial; conformance test suite has a license model sui",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:843,undo,undocumented,843,interpreter/llvm-project/clang/www/OpenProjects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html,1,['undo'],['undocumented']
Usability,". Clang C Language Family Frontend for LLVM. Clang: a C language family frontend for LLVM. The Clang project provides a language front-end and tooling infrastructure; for languages in the C language family (C, C++, Objective C/C++, OpenCL,; CUDA, and RenderScript) for the LLVM; project. Both a GCC-compatible compiler driver (clang) and an; MSVC-compatible compiler driver (clang-cl.exe) are provided. You; can get and build the source today. Features and Goals. Some of the goals for the project include the following:; End-User Features:. Fast compiles and low memory use; Expressive diagnostics (examples); GCC & MSVC compatibility. Utility and; Applications:. Modular library based architecture; Support diverse clients (refactoring, static analysis, code generation,; etc.); Allow tight integration with IDEs; Use the LLVM 'Apache 2'; License. Internal Design and; Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++, and Objective C++; Conformance with C/C++/ObjC and their variants. Of course this is only a rough outline of the goals and features of; Clang. To get a true sense of what it is all about, see the Features section, which breaks; each of these down and explains them in more detail. Why?. Development of the new front-end was started out of a need; for a compiler that allows better diagnostics, better integration with; IDEs, a license that is compatible with commercial products, and a; nimble compiler that is easy to develop and maintain. All of these were; motivations for starting work on a new front-end that could; meet these needs. Current Status. Clang is considered to; be a production quality C, Objective-C, C++ and Objective-C++ compiler when; targeting any target supported by LLVM. As example, Clang is used in; production to build performance-critical software like Chrome or Firefox.; If you are looking for source analysis or source-to-source; transformation tools, Clang",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html:933,simpl,simple,933,interpreter/llvm-project/clang/www/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/index.html,1,['simpl'],['simple']
Usability,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; . Cling has been developed as prototype since quite a while. We have got more manpower and we managed to improve the prototype a lot. We have gotten to stage where the project could be useful.; . Since cling heavily depends on clang and LLVM we feel responsible to offer the project to the community. On July the 25-th 2011 we have announced the stable status we have and kindly asked the community for feedback. It became clear there are many people interested in it. Some of the them even asked for the status of objC/objC++!; . The overall good mark is a good motivation to keep walking in that direction. We follow our milestones and we are getting there!; ; << Back. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html:569,learn,learn,569,interpreter/cling/www/news/ClingAnnouncement.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/news/ClingAnnouncement.html,3,"['clear', 'feedback', 'learn']","['clear', 'feedback', 'learn']"
Usability,". Cling Website. Cling Website; Interactive Compiler Interface. Home; Download; News; Docs. Documentation. Developer. Doxygen; Extensions; Error Recovery; Late Binding. End User. User Manual; Status of ObjectiveC[++]. Get Involved. Useful Links. CERN. Cling Goes Public; July 25th, 2011. Cling is a completely new development, based on the opensource projects clang and LLVM. Cling is a new generation interpreter implemented as an interactive compiler interface of clang. The developer team has carefully designed the project, taking in mind the lessons that they had learn from CINT.; ; Read more >>. New Website Launched; July 1st, 2011. Welcome to our website!; ; The website contains vast information of the cling interactive compiler interface project. Information could be found at here as well.; ; Read more >>. Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/news.html:569,learn,learn,569,interpreter/cling/www/old/news.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/news.html,1,['learn'],['learn']
Usability,". Cling. Cling interprets C++. ****************** CLING ******************; * Type C++ code and press enter to run it *; * Type .q to exit *; *******************************************; [cling]$ #include <string>; [cling]$ std::string s(""abc"");; [cling]$ s.find('b'); (std::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type) 1; [cling]$. Cling is built on the top of LLVM and Clang libraries. In addition to standard interpreters it has a command line prompt and uses just-in-time (JIT) compiler. This kind of software application is commonly known as an interactive compiler.; ; Cling started off as a contemporary, high-performance alternative of the current C++ interpreter in the ROOT project - CINT.; ; Why interpreting C++ with Cling?. Learning C++ . ; One use case of cling is to aid the C++ learning process. Offering imediate feedback the user can easily get familiar with the structures and spelling of the language. ; . Creating scripts; ; The power of an interpreter lays as well in the compactness and ease of repeatedly running a small snippet of code - aka a script. This can be done in cling by inserting the bash-like style line: ; . #!/usr/bin/cling; . Rapid Application Development (RAD) . ; Cling can be used successfully for Rapid Application Development allowing for prototyping and proofs of concept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compila",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:827,learn,learning,827,interpreter/cling/www/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html,2,"['feedback', 'learn']","['feedback', 'learning']"
Usability,". Cling. Collaborate With Us . Every contribution is considered a donation and its copyright and any other; related rights become exclusive ownership of the person who merged the code or; in any other case the main developers of the ""Cling Project"". We warmly welcome external contributions to the Cling! By providing code,; you agree to transfer your copyright on the code to the ""Cling project"".; Of course you will be duly credited and your name will appear on the; contributors page, the release notes, and in the; CREDITS; shipped with every binary and source distribution. The copyright transfer is; necessary for us to be able to effectively defend the project in case of; litigation. You can send us a patch or a pull request with Github, provided that you follow these two simple rules:. Make sure you follow the Cling coding conventions in your code.; . Make sure you provide a set of tests for your feature/bug fix.; . Often it is useful to contact us first to discuss the code you want to develop or the bug you want to fix. Picking up an Idea . We maintain a set of ""ideas"" for talented scientists and developers to pick up. An ""idea"" can be a sketch of a development project, a functionality, a missing feature we would like to see in our tool.; A list that we propose is the following:. Ideas. Extending and improving the multiline input mode - The multiline mode has to figure out automatically whether the user's input is still incomplete. For example ""if (a < 0) {"" is not fully completed input. Cling should'n try to process the line but to be smart enough to understand that it should wait for continuation. Currently cling switches multiline mode only when there is trailing ""{"". It has to be extended to detect trailing +, unbalanced ',"" and so on. Implementing error recovery verifier - One of the most important parts in cling is the error recovery. The error recovery takes care of reverting clang's internal structures on error in the user input. For instance, user types int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html:782,simpl,simple,782,interpreter/cling/www/contribute.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/contribute.html,1,['simpl'],['simple']
Usability,". Core Libraries; ROOT Error Handlers; There is a new rootrc variable which allows to control the; installation of the ROOT error handlers. By default the handlers; are activated:. Root.ErrorHandlers: 1. but setting the value to 0 result in no error handlers being installed; and the originals remaining in place. This can be useful if ROOT is used in; conjunction with other frameworks that already installed their own handlers. TString; TString::Hash() and thus also TMath::Hash() now use MurmurHash3_x64_128; from http://code.google.com/p/smhasher/ which is public domain.; To accelerate the hash in the case of pointers even further, pointers (and same-sized texts) are hashed using a simple bitwise xor.; This dramatically increases the hash performance for long texts, and still by a factor 5 for pointers.; The pointer case is most visible for certain I/O operations (TExMap).; TColor; Add the method SetAlpha() to set the alpha value (transparency; level) for an existing color. TStyle. The default font set by gStyle->SetLegendFont() was ignored. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v534/index.html:689,simpl,simple,689,core/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v534/index.html,1,['simpl'],['simple']
Usability,". Core. The ROOT source directory has been drastically reorganized and simplified.; Each source directory containing the code for a single library or plugin,; were all in the same top level directory, without logical grouping.; This made it difficult to see which libraries were related and belonged; together. In the new structure we've added a set of meta directories; that are used to group the sources of related libraries, and that also; reflects the ROOT team work package structure.; Note, the name and number of libraries has not been changed.; This new structure also facilitates the maintaining of the release notes; and other documentation items per meta package. On Linux, MacOS X and Windows, there is no need anymore to define the; environment variable ROOTSYS. Internally ROOTSYS is set depending on the; location of the ROOT libraries. ROOTSYS was never needed when ROOT was; configured using --prefix. On MacOS X when configure'ing with --enable-rpath (and not specifying; --prefix) the installation does not need (DY)LD_LIBRARY_PATH to be set; anymore. The installation is completely relocatable. The (DY)LD_LIBRARY_PATH; is determined relative to the location of the root executable. On Windows .root files are now associated with the most recently executed; ROOT installation, i.e. run ROOT once and .root files open with ROOT. Class TMessageHandler derives now from TQObject and does emit signals.; This allows for easier usage of this class. In this release xrootd and libAfterImage are managed in Subversion; via so called ""vendor branches"". This is completely transparent; except for people who do directly use svn. You will get the message:. $ svn up; svn: Failed to add directory 'xrootd/src/xrootd': object of the same name already exists; $ rm -rf xrootd/src/xrootd; $ svn up; svn: Failed to add directory 'asimage/src/libAfterImage': object of the same name already exists; $ rm -rf asimage/src/libAfterImage; $ svn up. Port to gcc 4.3.1. This version of gcc is much stric",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html:71,simpl,simplified,71,core/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html,1,['simpl'],['simplified']
Usability,". Due to the self-containment of assemblies, they are very; practical to use when a container is hard to define due to possible; overlaps during positioning. For instance, it is very easy creating; honeycomb structures. A very useful example for creating and using; assemblies can be found at:; <http://root.cern.ch/root/html/examples/assembly.C.html>`.`. Creation of an assembly is very easy: one has just to create a; **`TGeoVolumeAssembly`** object and position the components inside as; for any volume:. ``` {.cpp}; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; ```. Note that components cannot be declared as ""overlapping"" and that a; component can be an assembly volume. For existing flat volume; structures, one can define assemblies to force a hierarchical structure; therefore optimizing the performance. Usage of assemblies does NOT imply; penalties in performance, but in some cases, it can be observed that it; is not as performing as bounding the structure in a container volume; with a simple shape. Choosing a normal container is therefore; recommended whenever possible. ![Assemblies of volumes](pictures/080001CF.png). ### Geometrical Transformations. All geometrical transformations handled by the modeller are provided as; a built-in package. This was designed to minimize memory requirements; and optimize performance of point/vector master-to-local and; local-to-master computation. We need to have in mind that a; transformation in **`TGeo`** has two major use-cases. The first one is; for defining the placement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversion. The second use case is the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:90843,simpl,simple,90843,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,". Extensible: It is very simple to add a new argument type to CommandLine.; Simply specify the parser that you want to use with the command line option; when you declare it. `Custom parsers`_ are no problem. #. Labor Saving: The CommandLine library cuts down on the amount of grunt work; that you, the user, have to do. For example, it automatically provides a; ``-help`` option that shows the available command line options for your tool.; Additionally, it does most of the basic correctness checking for you. #. Capable: The CommandLine library can handle lots of different forms of; options often found in real programs. For example, `positional`_ arguments,; ``ls`` style `grouping`_ options (to allow processing '``ls -lad``'; naturally), ``ld`` style `prefix`_ options (to parse '``-lmalloc; -L/usr/lib``'), and interpreter style options. This document will hopefully let you jump in and start using CommandLine in your; utility quickly and painlessly. Additionally it should be a simple reference; manual to figure out how stuff works. Quick Start Guide; =================. This section of the manual runs through a simple CommandLine'ification of a; basic compiler tool. This is intended to show you how to jump into using the; CommandLine library in your own program, and show you some of the cool things it; can do. To start out, you need to include the CommandLine header file into your program:. .. code-block:: c++. #include ""llvm/Support/CommandLine.h"". Additionally, you need to add this as the first line of your main program:. .. code-block:: c++. int main(int argc, char **argv) {; cl::ParseCommandLineOptions(argc, argv);; ...; }. ... which actually parses the arguments and fills in the variable declarations. Now that you are ready to support command line arguments, we need to tell the; system which ones we want, and what type of arguments they are. The CommandLine; library uses a declarative syntax to model command line arguments with the; global variable declarations that ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:3580,simpl,simple,3580,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,". GUI Libraries; TRootBrowser. Following a user request on savannah,; a filtering mechanism in the browser has been implemented. To filter the content of a file; (or a folder inside a file), simply click on the ""Filter"" button. A dialog will popup, asking; for a filtering expression string (regexp like). The filter will then be applied on the current; list tree item (folder) and will stay active until a wildcard (""*"") expression or an empty; string ("""") is entered as new filtering value. The filter button automatically reflects the; status of any selected list tree item, and if a filter is active on it, the button state is; ""engaged"" and its tooltip shows what is actually displayed in this file/folder. It is possible; to filter several files/folders, each one having its own filtering argument. TGNumberEntry. Fix a possible overflow when entering a float having its fraction part exceeding kMaxInt (e.g 9.9999999999). This fix the bug #84033, TGNumberEntryField. TTreeViewer. Make the ""Histogram"" text entry expanding in X direction (i.e. resize it when resizing the tree viewer). TGInputDialog. Implemented a hack to detect if user press cancel or if an empty string ("""") has been selected.; When the Cancel button is pressed, the first two characters are reset to 0, and if the user select; an empty string ("""") the first character is reset to 0 and the second one is set to 1. TGPrintDialog. The ""Printer"" text entry has been replaced by a combo box populated with the list of available printers on the system, and select the default one, if any. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v532/index.html:191,simpl,simply,191,gui/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v532/index.html,1,['simpl'],['simply']
Usability,". GUI; TRootCanvas. In SetWindowSize the event queue is flushed to make sure; the window size change is really done. TRootContextMenu. When creating the dialog from the context menu, skip arguments that are pointers (but not char *) and have a default value. This should avoid confusing input fields in dialog.; Implemented online help in root dialogs (the dialog boxes used with contextual menus) via a new ""Online Help"" button. This opens a Root HTML browser at the right class/method location in the Root reference guide on the web.; The base url can be changed with the Browser.StartUrl option in system.rootrc (by default: http://root.cern.ch/root/html/ClassIndex.html); Added a small '?' on the right of the context menu entries, giving access to online help. TGMenu. Add possibility to add a right aligned shortcut by using a tab character ('\t') before the shortcut string, as shown below:; fMenuFile->AddEntry(""&Open...\tCtrl+O"", kOpenFile);; Use new way of adding right aligned shortcuts in the menu entries in most of the GUI classes using shortcuts in their menu. TGSlider. Added HandleConfigureNotify() to handle resizing events. New Browser. Automatically browse ROOT files if there is any open when starting the browser.; Correct system files manipulations (copy, rename, delete) and automatic update of the list tree. GUIHTML; TGHtmlBrowser. Added ability to display single picture from the web and to open pdf files with external viewer (Windows only); Implemented anchor navigation (e.g. http://root.cern.ch/root/html/TH1.html#TH1:Multiply). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v524/index.html:518,guid,guide,518,gui/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v524/index.html,1,['guid'],['guide']
Usability,". Graphical Output; PostScript and PDF. The marker size between the screen output and the output file formats; was not consistent.; Implement the text kerning. The effect is clearly illustrated with; the following script. Without kerning the red X is overlaped by the; the rest of the text.; ; {; TCanvas *c = new TCanvas;; TLatex *l = new TLatex(0.5, 0.5, ""AVAVAVAVAVAVAVAVAVA#color[2]{X}"");; l->Draw();; c->SaveAs(""c1.eps"");; }; ; The original idea came from Oleksandr Grebenyuk. It has been implemented; in a such way that the kerning mechanism is activated only when needed. If; not needed the old way of text rendering is used. It was done that way; because most of the time kerning is not needed and text rendered using; the kerning mechanism takes more space in the PS/PDF files.; Very long text strings made wrong PS files.; PDF also allows to define table of contents. Now, this facility can be used; in ROOT. The following example shows how to proceed:; ; {; TCanvas* canvas = new TCanvas(""canvas"");; TH1F* histo = new TH1F(""histo"",""test 1"",10,0.,10.);; histo->SetFillColor(2);; histo->Fill(2.);; histo->Draw();; canvas->Print(""plots.pdf("",""Title:One bin filled"");; histo->Fill(4.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Two bins filled"");; histo->Fill(6.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Three bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Four bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf)"",""Title:The fourth bin content is 2"");; }; ; Each character string following the keyword ""Title:"" makes a new entry in; the table of contents.; TPostScript::Text: Inside a string, the backslash itself is now; escaped. The PS file generated by the two following lines did not work.; ; TText t(.5,.5,""\\t\\"");; t.Draw();; . Small fix regarding line width in TPDF.; In some cases there was some extra blanck page at the beginning of the; PDF files. In particular when generated using the ""[]"" mechanism. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v528/index.html:174,clear,clearly,174,graf2d/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v528/index.html,1,['clear'],['clearly']
Usability,". Graphical Output; TASImage / libAfterImage. In TImageDump the way the markers 6 and 7 are drawn; (medium dot and big dot) has been changed to make sure they have; the same size as the one on screen.; Changes in libAfterImage (draw.c & draw.h), TASImage.cxx; and TImageDump.cxx in order to produce nice looking; circular (hollow and solid) markers. Previously the line; used to draw hollow circular markers looked very thick and; the solid ones did not look circular.; Remove the global variable named ""dpy"" in libAfterImage. It produced; an error if a user program used that simple variable name. ""dpy""; was a pointer to a ""Display"". PostScript and PDF. Now, a text with size 0 is not drawn in PDF files. An invalid; PDF file is created if a text with size 0 is produced.; The landscape orientation is now correct in pdf files. gv recognizes; the files as ""Landscape"" and the orientation is not upside down; as it was before (seascape).; In PostScript and PDF files the method DrawPS is used to write; a single (x,y) position.; This case was not treated correctly and, because of that, the PS and PDF; files might contain useless attributes settings. That was only a few; bytes more in the file but they were useless. TLegend. When a object is added ""by name"" in a legend, the; TMultiGraph and THStack present in the current pad; are scanned if an object with this name has not been; found in the pad. Previously the graphs and histograms; were hidden in multi-graphs and histogram-stacks when one; tried to add them by name.; New reference guide. TGaxis. In PaintAxis The option ""U"", for unlabeled axis, was not; implemented in case of alphanumeric axis' labels.; On log-scale TGAxis, with labels having lower values than 1 and ticks marks; set to the positive side, alignement issues seem to come up.; The following example shows four TGAxis drawn respectively with the; following options: RG-, RG+, LG-, LG+. For the RG+ and LG+ options,; the 10E-1 and 10E-2 labels were ill-aligned, showing a sh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v524/index.html:577,simpl,simple,577,graf2d/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v524/index.html,1,['simpl'],['simple']
Usability,". Histogram package; TGraphDelaunay. New version of the method TGraphDelaunay::Enclose(). This method; decides if a point is inside a triangle or not. The way it was implemented; produced infinite numbers and generated wrong peaks. It was visible on some; machines only (for instance MacOsX). Now this method uses; TMath::IsInside(). It is much safer, it runs faster, and the; code is simpler. The problem could be seen with a simple macro like the; following one:; ; {; TCanvas *c1 = new TCanvas(""c1"", ""c1"",0,0,600,600);; c1->SetTheta(90.);; c1->SetPhi(0.0001);; gStyle->SetPalette(1);; TGraph2D *graph2d = new TGraph2D();; graph2d->SetPoint(0, 110, 110, 0.0);; graph2d->SetPoint(1, -80, 50, 1.0);; graph2d->SetPoint(2, -70, 40, 2.0);; graph2d->SetPoint(3,-110, -50, 3.0);; graph2d->SetNpx(9);; graph2d->SetNpy(9);; graph2d->Draw(""surf1"");; graph2d->SetLineWidth(2);; graph2d->Draw("" triw p0 same"");; }; . The X and Y vectors are normalized in order to compute the triangles.; The scale factor used was the same for the X and Y axis.; This generated problems (very long triangles instead of the obvious ones); in some cases when the X and Y axis had very different ranges. Having two; scale factors, one for the X axis and one for the Y axis, cures the problem. TGraph2D. In case all the points are in the same Z-plane Z0 (zmin = zmax), the graph; minimum is set to Z0-0.01*Z0 and the maximum to Z0+0.01*Z0. This; allow to make TGraph2D like:; ; {; double *x = new double[2];; double *y = new double[2];; double *z = new double[2];; x[0] = 6215.;; x[1] = 5542.;; y[0] = 3853.;; y[1] = 5270.;; z[0] = 2723.;; z[1] = 2723.;; TGraph2D * g = new TGraph2D(2, x, y, z);; g->Draw(""LINE"");; }; . TGraph2DPainter. When a TGraph2D was painted with the option TRI1 the; color distribution in case of log scale along the Z axis was wrong. THistPainter. After executing the following macro, zooming the X axis interactively; generated the error message:; ; Error in <TGraphPainter::PaintGraphHist>: X must have N+",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:385,simpl,simpler,385,hist/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html,2,['simpl'],"['simple', 'simpler']"
Usability,". Html; THtml is now using the leyout of the new ROOT web site. There is a number of other improvements:. The sources now show line numbers. Each line number is a link and an anchor, i.e. it can be jumped to.; The line number can be copy&pasted: mark the line number from the right and drag your mouse to the left until teh line number and a space next to it are marked. When you paste this you will get the file and line number in the GDB-format (MyFile.cxx:123), e.g. to set breakpoints.; THtml now uses short class names, e.g. map<A,B,less<A>,allocator<pair<A,B> > > now simply becomes map<A,B>. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/doc/v524/index.html:574,simpl,simply,574,html/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/doc/v524/index.html,1,['simpl'],['simply']
Usability,". I/O Libraries; TFileCacheRead. Support for multiple TFileCacheRead per TFile.; Multiple TFileCacheRead per TFile are supported by augmenting the existing TFile::SetCacheRead() function with an optional TObject* argument specifying the owner (i.e. tree) of the cache. This function will assign a TFileCacheRead to a TFile for the given TTree. A cache can be removed by setting the pointer TFileCacheRead to 0.; Similarly, in TFile::GetCacheRead() an optional TObject* argument was added to obtain the TFileCacheRead from a TFile.; In addition to the unassigned TFileCacheRead pointer, TFile will maintain a map of tree specific cache pointers.; Backward compatibility in both functions is handled by making the TObject* argument optional. If it is not specified in the TFile::SetCacheRead() call, only the unassigned TFileCacheRead pointer is updated, otherwise the map and the unassigned cache are updated. In TFile::GetCacheRead(), if an owner is not specified or doesn't exist in the file's cache map, the unassigned cache is returned, unless it is 0 and there is exactly one entry in the cache map.; Distinguish counter for bytes read and read calls for learning phase. TFileMerger. Improve efficiency of TFileMerger when merging a single file by doing a TFile::Cp rather than a load/write of the objects.; In TFileMerger and hadd when objects can not be merged do not overwrite the last object in the set with the first!; Renable warning about not being able to merge objects in TFileMerger and hadd.; Fix hadd problem where the incremental merging fails if the TTree are stored in sub-directories.; Improve the code used for forward compatibility (record the type as TDirectory even-though the class is now TDirectoryFile) by delaying the switching of the class name until it is written (to the buffer). This avoids problem where a TKey is created (by TFile::mkdir) and then immediately used for reading (this happens in the incremental file merger). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v534/index.html:1159,learn,learning,1159,io/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v534/index.html,1,['learn'],['learning']
Usability,". It tells ROOT not to; save that data member in a root file when saving the class. For example,; in this version of Event, the `fPt` and `fTransient` data members are; not persistent. ``` {.cpp}; class Event : public TObject {; private:; TDirectory *fTransient; //! current directory; Float_t fPt; //! transient value; ...; ```. ### The Pointer to Objects (//-\>). The string ""`->`"" in the comment field of the members `*fH` and; `*fTracks` instruct the automatic `Streamer` to assume these will point; to valid objects and the `Streamer `of the objects can be called rather; than the more expensive `R__b << fH`. It is important to note that no; check is done on the validity of the pointer value. In particular if the; pointer points, directly or indirectly, back to the current object, this; will result in an infinite recursion and the abrupt end of the process. ``` {.cpp}; TClonesArray *fTracks; //->; TH1F *fH; //->; ```. ### Variable Length Array. When the `Streamer `comes across a pointer to a simple type, it assumes; it is an array. Somehow, it has to know how many elements are in the; array to reserve enough space in the buffer and write out the; appropriate number of elements. This is done in the class definition.; For example:. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; ...; Float_t *fClosestDistance; //[fNvertex]; ```. The array `fClosestDistance` is defined as a pointer of floating point; numbers. A comment mark (//), and the number in square brackets tell the; `Streamer `the length of the array for this object. In general the; syntax is:. ``` {.cpp}; <simple type> *<name>//[<length>]; ```. The length cannot be an expression. If a variable is used, it needs to; be an integer data member of the class. It must be defined ahead of its; use, or in a base class. The same notation also applies to variable length array of object and; variable length array of pointer to objects. ``` {.cpp}; MyObject",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:46743,simpl,simple,46743,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability,". Note that when an object is created, its attributes are taken from the; current style. For example, you may have created a histogram in a; previous session and saved it in a file. Meanwhile, if you have changed; the style, the histogram will be drawn with the old attributes. You can; force the current style attributes to be set when you read an object; from a file by calling `ForceStyle` before reading the objects from the; file. ``` {.cpp}; gROOT->ForceStyle();; ```. When you call `gROOT->ForceStyle()` and read an object from a ROOT file,; the object's method `UseCurrentStyle` is called. The attributes saved; with the object are replaced by the current style attributes. You call; also call `myObject->UseCurrentStyle()` directly. For example if you; have a canvas or pad with your histogram or any other object, you can; force these objects to get the attributes of the current style by:. ``` {.cpp}; canvas->UseCurrentStyle();; ```. The description of the style functions should be clear from the name of; the **`TStyle`** setters or getters. Some functions have an extended; description, in particular:. - `TStyle::SetLabelFont`. - `TStyle::SetLineStyleString`: set the format of dashed lines. - `TStyle::SetOptStat`. - `TStyle::SetPalette` to change the colors palette. - `TStyle::SetTitleOffset`. - `TStyle::SetOptDate(Int_t optdate)` to support several date formats.; If `optdate` is non-null, the current date/time will be printed in; the canvas. The position of the date string can be controlled by:; `optdate = 10*format `+` mode`. - `mode = 1` the date is printed in the bottom/left corner. - `mode = 2` date is printed in the bottom/right corner. - `mode = 3` date is printed in the top/right corner. - `format = 0` (default) date format is like: ""Wed Sep 25 17:10:35; 2002"". - `format = 1` date format is: ""2002-09-25"". - `format = 2` date format is: ""2002-09-25 17:10:35"". ## 3D Viewers. ROOT provides several viewers capable of displaying 3D content:. - the Pad - simple line",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:104149,clear,clear,104149,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['clear'],['clear']
Usability,". Open Projects. Open Projects; This page lists several projects that would boost analyzer's usability and; power. Most of the projects listed here are infrastructure-related so this list; is an addition to the potential checkers; list. If you are interested in tackling one of these, please send an email; to the cfe-dev; mailing list to notify other members of the community. Release checkers from ""alpha""; New checkers which were contributed to the analyzer,; but have not passed a rigorous evaluation process,; are committed as ""alpha checkers"" (from ""alpha version""),; and are not enabled by default.; Ideally, only the checkers which are actively being worked on should be in; ""alpha"",; but over the years the development of many of those has stalled.; Such checkers should either be improved; up to a point where they can be enabled by default,; or removed from the analyzer entirely. ; alpha.security.ArrayBound and; alpha.security.ArrayBoundV2; Array bounds checking is a desired feature,; but having an acceptable rate of false positives might not be possible; without a proper; loop widening support.; Additionally, it might be more promising to perform index checking based on; tainted index values.; (Difficulty: Medium). alpha.unix.StreamChecker; A SimpleStreamChecker has been presented in the Building a Checker in 24; Hours talk; (slides; video).; This alpha checker is an attempt to write a production grade stream checker.; However, it was found to have an unacceptably high false positive rate.; One of the found problems was that eagerly splitting the state; based on whether the system call may fail leads to too many reports.; A delayed split where the implication is stored in the state; (similarly to nullability implications in TrustNonnullChecker); may produce much better results.; (Difficulty: Medium). Improve C++ support; ; Handle construction as part of aggregate initialization.; Aggregates; are objects that can be brace-initialized without calling a; constructor (th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:93,usab,usability,93,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,1,['usab'],['usability']
Usability,". OpenGL. Add support for showing tooltips for objects shown in; TGLViewer. See TGLEventHandler::TriggerTooltip(const; char* text) and RemoveTooltip(). Usage example is in; class TEveViewerList. Add new overlay element TGLCameraOverlay that allows to; display: a) coordinate axes for orthographic mode; b) intersection of; center of screen with a given plane. Add suport for fading in/out of the viewer contents. Many improvements in text and axis rendering for orthographic; view markup. In TGLSceneBase add data-member Bool_t; fSelectable allowing one to preventing any of its elements to be; selected. Useful when given scene is used as background to help guid; the eye. Eve. Added support for internal window management. Windows can be; arranged in horizontal/vertical stacks, tabs and main windows.; The containers and individaul windows can be moved to arbitrary; window-slot. See classes TEveWindow and TEveWindowManager. See tutorial tutorials/eve/test_windows.C. TEveQuadSet -- Add flag 'Bool_t fAntiFlick'. If on (now the; default) it causes each quad to be also rendered as a pixel, thus; preventing it from disappearing when zoomed away. This is needed for visualization of small quads, e.g. silicon; detectors digits. TEveCalo classes -- Add support for automatic rebinning; of 3D views (only supported for 2D views before). In 2D mode support; automatic determination of the cell color based on the most energetic; contribution from available calo slices. Add support for enumerative registration of calorimeter towers. Before; one had to provide THStack as input. See TEveCaloDataVec; class. TEveTrackList -- Generalized API for finding of momentum; limits. TEveTrackPropagator now supports propagation of charged; particles in arbitrary / external magnetic field. Propagation can be; done with the helix-stepper or with the Runge-Kutta method. New abstract interface to magnetic field TEveMagField to get; field vector at given position. Implement two interfaces:; TEveMagFieldConst fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v522/index.html:659,guid,guid,659,graf3d/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v522/index.html,1,['guid'],['guid']
Usability,". OpenGL; Major changes. Reorganization of scene rendering in TGLViewer - render opaque; objects from all scenes first, then all transparent ones. Modularization of input event-handling in TGLViewer: all; event-handling is done by the TGLEventHandler class. One can; sub-class it now and modify behaviour of a given viewer. For; example, see TEveLegoEventHandler. Support highlighting of physical shapes for providing feedback and; showing selection. Minor changes, fixes and improvements. Improve saving of images from the GL-viewer so that the dialog; boxes and other windows do not result in black areas on the saved; image. The window must still be fully contained within the desktop. Improved camera controls. Three new orthographic cameras have; been added to TGLViewer, looking at the scene from another; side than the one present so far. Improved FTGL font management across rendering contexts and text; rendering support. New class TGLAxisPainter that can render 2D and 3D axes; via GL. For example see tutorials/eve/cms_calo.C. Possible performance issues with ATI drivers (fglrx). In late 2007 ATI switched to a new driver architecture. With these; drivers a significant degradation of GL performance in selection mode,; up to a factor of 50, was observed. Both linux and Windows drivers; were affected. The issue has been resolved in the latest driver; versions. Eve; Major changes. Support for multiple, parallel OpenGL views that can show different; projections of the same event. Provide object selection and feedback highlight across all GL-views and; list-trees. New classes for visualization of calorimeter data,; TEveCaloXYZ, see tutorials/eve/cms_calo.C. Available; representations: 3D-cylindrical view, projected views r-phi and rho-z,; and lego-view (with dedicated event handler allowing detailed; inspection of the data). Support for compound objects in view of selection, highlight and; color managament (see class TEveCompound). Optimize updates of GL-scenes by introducing c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v520/index.html:418,feedback,feedback,418,graf3d/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v520/index.html,1,['feedback'],['feedback']
Usability,". PROOF System. Added functionality; ; Added interface to simplify the creation of the performance; tree: two new methods TProof::SetPerfTree(""<file>"") and; TProof::SavePerfTree(""<file>"", ""<queryref>"") allow set; and/or save the information to a given file path. The perfomance tree; settim=ngs are diabled after each query, so they need to be enabled; each time.; Add support for a command line test run of 'proofserv'; this is; useful to test that the environment is setup correctly.; In TProofBench::DrawCPU, add possibility to extract of a couple; of numbers supposed to give an idea of the computing specs of the; cluster being benchmarked. These are the maximum rate for the standard; CPU intensive task and the normalized, per worker, rate. Both are; expressed in RNGPS (RaNdom Generation Per Second).; Add class TProofPerfAnalysis collecting a set of tools to; analyse the performance tree.; Add support for selector-by-object processing in PROOF. The; selector object, created and configured locally by the user, is added; to the input list and recuperated from there on the worker machines for; processing. Any input list setting in the selector itself is not; streamed but temporarly moved to then standard input list, so that user; can use the selector input list as container of processing information; if they find convenient to do so. Process(...) methods with the file; name argument replaced by 'TSelector *' have  introduced where; relevant (TProof, TProofPlayer and their derivatives, TDSet).  ; Add the possibility to force submerging at node level, i.e. one; submerger per physical machine. In this way the network traffic can be; minimized, for example when merging large output files. The new feature; is enabled by setting the Int_t parameter 'PROOF_MergersByHost' (or the; directive 'Proof.MergersByHost') to a non-null value.; Simplify enabling of basic feedback. In TProof::Process, add; support for switches ""fb=name1,name2,name3,... "" or; ""feedback=name1,name2,name3,... """,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html:58,simpl,simplify,58,proof/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html,1,['simpl'],['simplify']
Usability,". RooFit. HistFactory. One of the core classes used by HistFactory models (RooRealSumPdf) was modified leading to substantial speed improvements (for models that use the default -standard_form option). . This new version supports a few types of interpolation for the normalization of the histograms:. code = 0: piece-wise linear (old default); code = 1: piece-wise log (new default); code = 2: parabolic interp with linear extrap ( common at tevatron, avoids kink for asymmetric uncert). The piece-wise logarithmic interpolation paired with a Gaussian constraint is equivalent to a log-normal constraint in a transformed version of the nuisance parameter. The benefit of this approach is that it is easy to avoid the normalization from taking on unphysical negative values. This is the prescription used by the CMS Higgs group, and agreed upon by the LHC Higgs Combination Group. There is not yet XML-based steering for the different interpolation types, but there is a simple script to modify it. . results/example_combined_GaussExample_model.root . Near term goals for HistFactory. Utilities for dealing with Monte Carlo statistical uncertainty in the template histograms; Support for N-D histograms; A new style of histogram variations without a constraint term attached (for shapes determined from control samples); XML steering for interpolation types. RooStats; General Improvements. This release brings several speed improvements to the RooStats tools and improved stability and performance with PROOF. This comes mainly through changes to the ToyMCSampler. In addition the HypoTestInverter tool has been rewritten, leading to some changes in the HypoTestResult. Finally, a new hypothesis test new called FrequentistCalculator was written, which plays the same role as the HybridCalculator but eliminates nuisance parameters in a frequentist way. ToyMCSampler. The primary interface for this class is to return a SamplingDistribution of a given TestStatistic.; The ToyMCSampler had a number of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html:970,simpl,simple,970,roofit/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html,1,['simpl'],['simple']
Usability,". Running the analyzer from the command line. Running the analyzer from the command line; Static Analyzer is by design a GUI tool. Its purpose is to find buggy execution; paths in the program, and such paths are very hard to comprehend by looking at; a non-interactive standard output. It is possible, however, to invoke the; Static Analyzer from the command line in order to obtain analysis results, and; then later view them interactively in a graphical interface. The following; tools are used commonly to run the analyzer from the command line. Both tools; are wrapper scripts to drive the analysis and the underlying invocations of the; Clang compiler:. Scan-Build; is an old and simple command-line tool that emits static analyzer warnings as HTML files while compiling your project. You can view the analysis results in your web browser.; . Useful for individual developers who simply want to view static analysis results at their desk, or in a very simple collaborative environment.; . Works on all major platforms (Windows, Linux, macOS) and is available as a package in many Linux distributions.; . Does not include support for cross-translation-unit analysis.; . CodeChecker; is a web server that runs the Static Analyzer on your projects on demand and maintains a database of issues.; . Perfect for managing large amounts of Static Analyzer warnings in a collaborative environment.; . Generally much more feature-rich than scan-build.; ; Supports incremental analysis: Results can be stored in a database, subsequent analysis runs can be compared to list the newly added defects.; Cross Translation Unit (CTU) analysis is supported fully on Linux via CodeChecker.; Can run clang-tidy checkers too.; Open source, but out-of-tree, i.e. not part of the LLVM project. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/command-line.html:685,simpl,simple,685,interpreter/llvm-project/clang/www/analyzer/command-line.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/command-line.html,3,['simpl'],"['simple', 'simply']"
Usability,". TASImage - libAfterImage library; TASImage. Protection added in DrawCircle. Problem seen with gcc version 4.2.3.; Fixed byte swapping issues. With that fix the pictures generated in batch; mode on Solaris and Mac are now correct (cf stressGraphics -k).; The Alpha Blending code has been rewritten in a simpler way in order to; work on linux with gcc 4.2.3. Here also the pictures generated in batch; mode were wrong.; In FillRectangleInternal when the rectangle to be drawn had its width or; its height equal to 0, they were set to the current image width or height.; This was not a good solution because this obscured completely the picture.; In particular, some markers being drawn with a filled rectangle, they; obscured the picture when they were really small because in that case the; rectangle drawn had width=height=0. Now, when a rectangle has its width or; height equal to 0 it is set to 1 (pixel) with makes sense because; ""0"" means ""tiny"" not ""huge"" ...; New method to retrieve the last zoom position on an image:; ; void TASImage::GetZoomPosition(UInt_t &x, UInt_t &y, UInt_t &w, UInt_t &h) const; ; This is useful when the zoom has been done interactively using the mouse.; In batch, when a picture was saved in a binary file (gif for instance) from; an image containing more than one pad, only the first pad was saved. The; following macro demonstrates the problem: ccc2.gif was wrong compared to; ccc1.gif. {; gROOT->SetBatch();; TCanvas *c = new TCanvas;; c->Divide(1,2);; TH1F *h = new TH1F(""gaus"", ""gaus"", 100, -5, 5);; h->FillRandom(""gaus"", 10000);; c->cd(1); h->Draw();; c->cd(2); h->Draw(""c*"");; c->Print(""ccc1.gif"");; TImage *img = TImage::Create();; img->FromPad(c);; img->WriteImage(""ccc2.gif"");; }. libAfterImage. There no need anymore for the special version we had up to now. The; modifications we needed have been introduced in the official version.; This version also fixes the color problem on BigEndian machines.; On these machines (Mac and Solaris for instance) the c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v520/index.html:304,simpl,simpler,304,graf2d/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v520/index.html,1,['simpl'],['simpler']
Usability,". The `TTree::Draw` method is convenient and easy to use; however it falls; short if you need to do some programming with the variable. For example, for plotting the masses of all oppositely changed pairs of; tracks, you would need to write a program that loops over all events,; finds all pairs of tracks, and calculates the required quantities. We; have shown how to retrieve the data arrays from the branches of the tree; in the previous section, and you could just write that program from; scratch. Since this is a very common task, ROOT provides a utility that; generates a skeleton class designed to loop over the entries of the; tree. This is the `TTree::MakeClass` method. We will now go through the steps; of using `MakeClass` with a simplified example. The methods used here; obviously work for complex event loop calculations. These are our assumptions: we would like to do selective plotting and; loop through each entry of the tree and tracks. We chose a simple; example: we want to plot `fPx` of the first 100 tracks of each entry. We; have a ROOT tree with a branch for each data member in the ""`Event`""; object. To build this file and tree follow the instructions on how to; build the examples in `$ROOTSYS/test`. Execute `Event` and instruct it; to split the object with this command (from the UNIX command line). ``` {.cpp}; > $ROOTSYS/test/Event 400 1 2 1; ```. This creates an `Event.root` file with 400 events, compressed, split,; and filled. See `$ROOTSYS/test/MainEvent.cxx` for more info. The person who designed the tree makes a shared library available to; you, which defines the classes needed. In this case, the classes are; Event, `EventHeader`, and Track and they are defined in the shared; library `libEvent.so`. The designer also gives you the `Event.h` file to; see the definition of the classes. You can locate `Event.h` in; `$ROOTSYS/test`, and if you have not yet built `libEvent.so`, please see; the instructions of how to build it (typing make in \$ROOTSYS/test i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:121977,simpl,simple,121977,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,". The driver expects to understand all available; options, although there is some facility for just passing certain; classes of options through (like ``-Wl,``). Each argument corresponds to exactly one abstract ``Option``; definition, which describes how the option is parsed along with some; additional metadata. The Arg instances themselves are lightweight and; merely contain enough information for clients to determine which; option they correspond to and their values (if they have additional; parameters). For example, a command line like ""-Ifoo -I foo"" would parse to two; Arg instances (a JoinedArg and a SeparateArg instance), but each; would refer to the same Option. Options are lazily created in order to avoid populating all Option; classes when the driver is loaded. Most of the driver code only needs; to deal with options by their unique ID (e.g., ``options::OPT_I``),. Arg instances themselves do not generally store the values of; parameters. In many cases, this would simply result in creating; unnecessary string copies. Instead, Arg instances are always embedded; inside an ArgList structure, which contains the original vector of; argument strings. Each Arg itself only needs to contain an index into; this vector instead of storing its values directly. The clang driver can dump the results of this stage using the; ``-###`` flag (which must precede any actual command; line arguments). For example:. .. code-block:: console. $ clang -### -Xarch_i386 -fomit-frame-pointer -Wa,-fast -Ifoo -I foo t.c; Option 0 - Name: ""-Xarch_"", Values: {""i386"", ""-fomit-frame-pointer""}; Option 1 - Name: ""-Wa,"", Values: {""-fast""}; Option 2 - Name: ""-I"", Values: {""foo""}; Option 3 - Name: ""-I"", Values: {""foo""}; Option 4 - Name: ""<input>"", Values: {""t.c""}. After this stage is complete the command line should be broken down; into well defined option objects with their appropriate parameters.; Subsequent stages should rarely, if ever, need to do any string; processing. #. **Pipeline: Compilat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:4980,simpl,simply,4980,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['simpl'],['simply']
Usability,". To have services like telephone and; electricity you will need to route the wires to your home. In; addition, you cannot build some things yourself. For example, you; cannot build a commercial airport on your patch of land. From a global; perspective, it would make no sense for everyone to build their; own airport. You see you will be very busy building the infrastructure; (or framework) before you can use the phone to communicate with your; collaborators and have a drink of water at the same time. In software; engineering, it is much the same way. In a framework, the basic; utilities and services, such as I/O and graphics, are provided. In; addition, ROOT being a HEP analysis framework, it provides a large; selection of HEP specific utilities such as histograms and fitting.; The drawback of a framework is that you are constrained to it, as you; are constraint to use the routing algorithm provided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a telephone. If you are interested in doing physics, a good HEP framework will save; you much work. Next is a list of the more commonly used components of; ROOT: Command Line Interpreter, Histograms and Fitting, Writing a; Graphical User Interface, 2D Graphics, Input/Output , Collection; Classes, Script Processor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:6508,learn,learn,6508,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,2,['learn'],"['learn', 'learning']"
Usability,". Tree. Significantly improve performance of TTree Proxy.; Improve read performance of sub-branch containing vector of single types.; Fix TTree::LoadBasket to properly handle the (new) case where no basket is stored with the TTree object.; Fix the axis used for an histogram created by TTree::Draw for a branch of TString or std::string objects.; MakeProxy now correctly support branches that created with a leaflist with more than one leaf; (usually used for C-struct).; TTree::CloneTree and TChain::Merge in fast mode now can recover from some mismatch errors between; the input and output TTrees by falling back to using the 'slow' mode. In particular this allow; a 'fast cloning' to handle files that requires schema evolution (albeit it is of course much slower).; Make sure that the TTreeCache is not attempting to cache (wrongly) the content of branches that are in an auxiliary files.; Make sure that FillBuffer does it work when the learning phase is over even if the entry number is 'low' for the 'current' file of a chain.; If TTree::SetEventList is called, TTree::GetEntryList no longer relinquish ownership of the automatically created TEntryList; Add the ability to see the TTree UserInfo list from the TBrowser; Fix the case of reading a TTree containing an 'old' class layout that contained a std::vector that is no longer part of the current class layout; Implement direct interfaces from TTree to the result of TSelector::Draw; TTree:GetVal(int) and TTree::GetVar(int); In TTree::ReadFile add the possibility to read multiple input files and add support for large/wide Trees definition.; Added support for ""5-D"" plotting.; Added support for std::bitset; Reduce the memory used by the mechanism keeping track of the entry of variables sizes within a basket (fEntryOffset).; The memory used now automatically decrease if the number of entries in the basket is less than 1/4 oflength of fEntryOffset.; Also the default length fEntryOffset can be set via TTree::SetDefaultEntryOffsetLen ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v524/index.html:942,learn,learning,942,tree/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v524/index.html,1,['learn'],['learning']
Usability,". Tutorials. New tutorial $ROOTSYS/tutorials/graphics/mass_spectrum.C. It; produces the following output:; . New tutorial $ROOTSYS/math/goftest.C showing the example; usage of the new ROOT::Math::GoFTest class. New tutorial $ROOTSYS/math/multiDimSampling.C showing the example; usage of the new ROOT::Math::DistSampler interface for; random generation from arbitrary functions using Unuran or Foam. New tutorial $ROOTSYS/math/kdTreeBinning.C showing the example; usage of the new TKDTreeBinning class. New tutorial $ROOTSYS/fit/NumericalMinimization.C showing; a minimization example (Rosenbrock function) using the; ROOT::Math::Minimizer interface. New tutorial $ROOTSYS/fit/exampleFit3D.C showing; a simple fit example of 3D points with a 3D function. New tutorial $ROOTSYS/fit/TSVDUnfoldExample.C showing; an example of the new TSVDUnfold class. New Roostats tutorials:. New Demos that take name for file, workspace, modelconfig, and data, then use the corresponding calculator tool. If the file is not specified it will read an file produced from running the HistFactory tutorial example. StandardProfileLikelihoodDemo.C: ; StandardFeldmanCousinsDemo.C: ; StandardBayesianMCMCDemo.C: ; StandardBayesianNumericalDemo.C: ; StandardProfileInspectorDemo.C: . Demonstrate some new PDFs. TestNonCentral.C: demonstrates non central chi-square; JeffreysPriorDemo.C: demonstrates Jeffreys Prior. Instructional Examples. IntervalExamples.C: Standard Gaussian with known answer using 4 techniques; FourBinInstructional.C: Example of a standard data-driven approach for estimating backgrounds. A lot of discussion.; HybridInstructional.C: Example of protoype on/off problem with a data-driven background estimate. A lot of discussion; HybridStandardForm.C: Variant on above in 'standard form'; MultivariateGaussianTest.C: A validation example with an N-D multivariate Gaussian . Renamed the rs201_hybridcalculator.C to; HybridOriginalDemo.C; Removed some obsolete roostats tutorials (all the rs500 types). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/doc/v528/index.html:702,simpl,simple,702,tutorials/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/doc/v528/index.html,1,['simpl'],['simple']
Usability,". When there is no; way to reconstitute the value of the lost instruction, this is the best; possible outcome. However, it's often possible to do better:. * If the dying instruction can be RAUW'd, do so. The; ``Value::replaceAllUsesWith`` API transparently updates debug uses of the; dying instruction to point to the replacement value. * If the dying instruction cannot be RAUW'd, call ``llvm::salvageDebugInfo`` on; it. This makes a best-effort attempt to rewrite debug uses of the dying; instruction by describing its effect as a ``DIExpression``. * If one of the **operands** of a dying instruction would become trivially; dead, use ``llvm::replaceAllDbgUsesWith`` to rewrite the debug uses of that; operand. Consider the following example function:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %b = sext i16 %a to i32; %c = and i32 %b, 15; call void @llvm.dbg.value(metadata i32 %c, ...); %d = trunc i32 %c to i16; ret i16 %d; }. Now, here's what happens after the unnecessary truncation instruction ``%d`` is; replaced with a simplified instruction:. .. code-block:: llvm. define i16 @foo(i16 %a) {; call void @llvm.dbg.value(metadata i32 undef, ...); %simplified = and i16 %a, 15; ret i16 %simplified; }. Note that after deleting ``%d``, all uses of its operand ``%c`` become; trivially dead. The debug use which used to point to ``%c`` is now ``undef``,; and debug info is needlessly lost. To solve this problem, do:. .. code-block:: cpp. llvm::replaceAllDbgUsesWith(%c, theSimplifiedAndInstruction, ...). This results in better debug info because the debug use of ``%c`` is preserved:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %simplified = and i16 %a, 15; call void @llvm.dbg.value(metadata i16 %simplified, ...); ret i16 %simplified; }. You may have noticed that ``%simplified`` is narrower than ``%c``: this is not; a problem, because ``llvm::replaceAllDbgUsesWith`` takes care of inserting the; necessary conversion operations into the DIExpressions of updated debug uses. D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:7808,simpl,simplified,7808,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['simpl'],['simplified']
Usability,".. -*- mode: rst -*-. CPyCppyy: Python-C++ bindings interface based on Cling/LLVM; ===========================================================. CPyCppyy is the CPython equivalent of _cppyy in PyPy.; It provides dynamic Python-C++ bindings by leveraging the Cling C++; interpreter and LLVM.; Details and performance are described in; `this paper <http://conferences.computer.org/pyhpc/2016/papers/5220a027.pdf>`_. CPyCppyy is a CPython extension module built on top of the same backend API; as PyPy/_cppyy.; It thus requires the installation of the; `cppyy backend <https://pypi.python.org/pypi/cppyy-backend/>`_; for use, which will pull in Cling.; CPython/cppyy and PyPy/cppyy are designed to be compatible, although there; are differences due to the former being reference counted and the latter; being garbage collected, as well as temporary differences due to different; release cycles of the respective projects. ----. Find the cppyy documentation here:; http://cppyy.readthedocs.io. Change log:; https://cppyy.readthedocs.io/en/latest/changelog.html. Bug reports/feedback:; https://github.com/wlav/cppyy/issues; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/README.rst:1069,feedback,feedback,1069,bindings/pyroot/cppyy/CPyCppyy/README.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/README.rst,1,['feedback'],['feedback']
Usability,".. -*- mode: rst -*-. cppyy: Python-C++ bindings interface based on Cling/LLVM; ========================================================. cppyy provides fully automatic, dynamic Python-C++ bindings by leveraging; the Cling C++ interpreter and LLVM.; It supports both PyPy (natively), CPython, and C++ language standards; through C++17 (and parts of C++20). Details and performance are described in; `this paper <http://cern.ch/wlav/Cppyy_LavrijsenDutta_PyHPC16.pdf>`_,; originally presented at PyHPC'16, but since updated with improved performance; numbers. Full documentation: `cppyy.readthedocs.io <http://cppyy.readthedocs.io/>`_. Notebook-based tutorial: `Cppyy Tutorial <https://github.com/wlav/cppyy/blob/master/doc/tutorial/CppyyTutorial.ipynb>`_. For Anaconda/miniconda, install cppyy from `conda-forge <https://anaconda.org/conda-forge/cppyy>`_. ----. Change log:; https://cppyy.readthedocs.io/en/latest/changelog.html. Bug reports/feedback:; https://github.com/wlav/cppyy/issues; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/README.rst:941,feedback,feedback,941,bindings/pyroot/cppyy/cppyy/README.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/README.rst,1,['feedback'],['feedback']
Usability,".. _basic_types:. Basic types; ===========. C++ has a far richer set of builtin types than Python.; Most Python code can remain relatively agnostic to that, and ``cppyy``; provides automatic conversions as appropriate.; On the other hand, Python builtin types such as lists and maps are far; richer than any builtin types in C++.; These are mapped to their Standard Template Library equivalents instead. The C++ code used for the examples below can be found; :doc:`here <cppyy_features_header>`, and it is assumed that that code is; loaded before running any of the example code snippets.; Download it, save it under the name ``features.h``, and simply include it:. .. code-block:: python. >>> import cppyy; >>> cppyy.include('features.h'); >>>. `Builtins`; """""""""""""""""""". The selection of builtin data types varies greatly between Python and C++.; Where possible, builtin data types map onto the expected equivalent Python; types, with the caveats that there may be size differences, different; precision or rounding, etc.; For example, a C++ ``float`` is returned as a Python ``float``, which is in; fact a C++ ``double``.; If sizes allow, conversions are automatic.; For example, a C++ ``unsigned int`` becomes a Python2 ``long`` or Python3; ``int``, but unsigned-ness is still honored:. .. code-block:: python. >>> cppyy.gbl.gUint; 0L; >>> type(cppyy.gbl.gUint); <type 'long'>; >>> cppyy.gbl.gUint = -1; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; ValueError: cannot convert negative integer to unsigned; >>>. On some platforms, 8-bit integer types such as ``int8_t`` and ``uint8_t`` are; represented as `char` types.; For consistency, these are mapped onto Python `int`. Some types are builtin in Python, but (STL) classes in C++.; Examples are ``str`` vs. ``std::string`` (see also the; :doc:`Strings <strings>` section) and ``complex`` vs. ``std::complex``.; These classes have been pythonized to behave the same wherever possible.; For example, string comparison work",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst:646,simpl,simply,646,bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,1,['simpl'],['simply']
Usability,".. _bugs:. Bugs and feedback; =================. Please report bugs, ask questions, request improvements, and post general; comments on the `issue tracker`_ or on `stack overflow`_ (marked with the; ""cppyy"" tag). .. _`issue tracker`: https://github.com/wlav/cppyy/issues; .. _`stack overflow`: https://stackoverflow.com/questions/tagged/cppyy; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/bugs.rst:20,feedback,feedback,20,bindings/pyroot/cppyy/cppyy/doc/source/bugs.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/bugs.rst,1,['feedback'],['feedback']
Usability,".. _philosophy:. Philosophy; ==========. .. toctree::; :hidden:. As a Python-C++ language binder, cppyy has several unique features: it fills; gaps and covers use cases not available through other binders.; This document explains some of the design choices made and the thinking; behind the implementations of those features.; It's categorized as ""philosophy"" because a lot of it is open to; interpretation.; Its main purpose is simply to help you decide whether cppyy covers your use; cases and binding requirements, before committing any time to; :ref:`trying it out <starting>`. Run-time v.s. compile-time; --------------------------. What performs better, run-time or compile-time?; The obvious answer is compile-time: see the performance differences between; C++ and Python, for example.; Obvious, but completely wrong, however.; In fact, when it comes to Python, it is even the `wrong question.`. Everything in Python is run-time: modules, classes, functions, etc. are all; run-time constructs.; A Python module that defines a class is a set of instructions to the Python; interpreter that lead to the construction of the desired class object.; A C/C++ extension module that defines a class does the same thing by calling; a succession of Python interpreter Application Programming Interfaces (APIs;; the exact same that Python uses itself internally).; If you use a compile-time binder such as `SWIG`_ or `pybind11`_ to bind a C++; class, then what gets compiled is the series of API calls necessary to; construct a Python-side equivalent at `run-time` (when the module gets; loaded), not the Python class object.; In short, whether a binding is created at ""compile-time"" or at run-time has; no measurable bearing on performance. What does affect performance is the overhead to cross the language barrier.; This consists of unboxing Python objects to extract or convert the underlying; objects or data to something that matches what C++ expects; overload; resolution based on the unboxed argume",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:429,simpl,simply,429,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['simpl'],['simply']
Usability,".. _repositories:. Repositories; ============. The ``cppyy`` module is a frontend that requires an intermediate (Python; interpreter dependent) layer, and a backend (see; :ref:`Package Structure <package-structure>`).; Because of this layering and because it leverages several existing packages; through reuse, the relevant codes are contained across a number of; repositories. * Frontend, cppyy: https://github.com/wlav/cppyy; * CPython (v2/v3) intermediate: https://github.com/wlav/CPyCppyy; * PyPy intermediate (module _cppyy): https://foss.heptapod.net/pypy; * Backend, cppyy: https://github.com/wlav/cppyy-backend. The backend repo contains both the cppyy-cling (under ""cling"") and; cppyy-backend (under ""clingwrapper"") packages. .. _building_from_source:. Building from source; --------------------. Except for cppyy-cling, the structure in the repositories follows a normal; PyPA package and they are thus ready to build with `setuptools`_: simply; clone the package and either run ``python setup.py``, or use ``pip``. It is highly recommended to follow the dependency chain when manually; upgrading packages individually (i.e. ``cppyy-cling``, ``cppyy-backend``,; ``CPyCppyy`` if on CPython, and then finally ``cppyy``), because upstream; packages expose headers that are used by the ones downstream.; Of course, if only building for a patch/point release, there is no need to; re-install the full chain (or follow the order).; Always run the local updates from the package directories (i.e. where the; ``setup.py`` file is located), as some tools rely on the package structure. The ``STDCXX`` envar can be used to control the C++ standard version; use; ``MAKE`` to change the ``make`` command; and ``MAKE_NPROCS`` to control the; maximum number of parallel jobs.; Compilation of the backend, which contains a customized version of; Clang/LLVM, can take a long time, so by default the setup script will use all; cores (x2 if hyperthreading is enabled). On MS Windows, some temporary path names",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst:948,simpl,simply,948,bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,1,['simpl'],['simply']
Usability,".. _starting:. Trying it out; =============. This is a basic guide to try cppyy and see whether it works for you.; Large code bases will benefit from more advanced features such as; :doc:`pythonizations <pythonizations>` for a cleaner interface to clients;; precompiled modules for faster parsing and reduced memory usage;; "":ref:`dictionaries <dictionaries>`"" to package locations and manage; dependencies; and mapping files for automatic, lazy, loading.; You can, however, get very far with just the basics and it may even be; completely sufficient for small packages with fewer classes. cppyy works by parsing C++ definitions through ``cling``, generating tiny; wrapper codes to honor compile-time features and create standardized; interfaces, then compiling/linking those wrappers with the ``clang`` JIT.; It thus requires only those two ingredients: *C++ definitions* and; *linker symbols*.; All cppyy uses, the basic and the more advanced, are variations on the; theme of bringing these two together at the point of use. Definitions typically live in header files and symbols in libraries.; Headers can be loaded with ``cppyy.include`` and libraries with the; ``cppyy.load_library`` call.; Loading the header is sufficient to start exploring, with ``cppyy.gbl`` the; starting point of all things C++, while the linker symbols are only needed at ; the point of first use. Here is an example using the `zlib`_ library, which is likely available on; your system:. .. code-block:: python. >>> import cppyy; >>> cppyy.include('zlib.h') # bring in C++ definitions; >>> cppyy.load_library('libz') # load linker symbols; >>> cppyy.gbl.zlibVersion() # use a zlib API; '1.2.11'; >>>. Since header files can include other header files, it is easy to aggregate; all relevant ones into a single header to include.; If there are project-specific include paths, you can add those paths through; ``cppyy.add_include_path``.; If a header is C-only and not set for use with C++, use ``cppyy.c_include``,; which ad",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/starting.rst:61,guid,guide,61,bindings/pyroot/cppyy/cppyy/doc/source/starting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/starting.rst,1,['guid'],['guide']
Usability,".. role:: raw-html(raw); :format: html. =================================; LLVM Code Coverage Mapping Format; =================================. .. contents::; :local:. Introduction; ============. LLVM's code coverage mapping format is used to provide code coverage; analysis using LLVM's and Clang's instrumentation based profiling; (Clang's ``-fprofile-instr-generate`` option). This document is aimed at those who would like to know how LLVM's code coverage; mapping works under the hood. A prior knowledge of how Clang's profile guided; optimization works is useful, but not required. For those interested in using; LLVM to provide code coverage analysis for their own programs, see the `Clang; documentation <https://clang.llvm.org/docs/SourceBasedCodeCoverage.html>`. We start by briefly describing LLVM's code coverage mapping format and the; way that Clang and LLVM's code coverage tool work with this format. After; the basics are down, more advanced features of the coverage mapping format; are discussed - such as the data structures, LLVM IR representation and; the binary encoding. High Level Overview; ===================. LLVM's code coverage mapping format is designed to be a self contained; data format that can be embedded into the LLVM IR and into object files.; It's described in this document as a **mapping** format because its goal is; to store the data that is required for a code coverage tool to map between; the specific source ranges in a file and the execution counts obtained; after running the instrumented version of the program. The mapping data is used in two places in the code coverage process:. 1. When clang compiles a source file with ``-fcoverage-mapping``, it; generates the mapping information that describes the mapping between the; source ranges and the profiling instrumentation counters.; This information gets embedded into the LLVM IR and conveniently; ends up in the final executable file when the program is linked. 2. It is also used by *llvm-cov* -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst:533,guid,guided,533,interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst,1,['guid'],['guided']
Usability,".. you get the idea. The `bool parser`_ just turns the string values into; boolean values, and rejects things like '``compiler -f=foo``'. Similarly, the; `float`_, `double`_, and `int`_ parsers work like you would expect, using the; '``strtol``' and '``strtod``' C library calls to parse the string value into the; specified data type. With the declarations above, ""``compiler -help``"" emits this:. ::. USAGE: compiler [options] <input file>. OPTIONS:; -f - Enable binary output on terminals; -o - Override output filename; -quiet - Don't print informational messages; -help - display available options (-help-hidden for more). and ""``compiler -help-hidden``"" prints this:. ::. USAGE: compiler [options] <input file>. OPTIONS:; -f - Enable binary output on terminals; -o - Override output filename; -q - Don't print informational messages; -quiet - Don't print informational messages; -help - display available options (-help-hidden for more). This brief example has shown you how to use the '`cl::opt`_' class to parse; simple scalar command line arguments. In addition to simple scalar arguments,; the CommandLine library also provides primitives to support CommandLine option; `aliases`_, and `lists`_ of options. .. _aliases:. Argument Aliases; ----------------. So far, the example works well, except for the fact that we need to check the; quiet condition like this now:. .. code-block:: c++. ...; if (!Quiet && !Quiet2) printInformationalMessage(...);; ... ... which is a real pain! Instead of defining two values for the same; condition, we can use the ""`cl::alias`_"" class to make the ""``-q``"" option an; **alias** for the ""``-quiet``"" option, instead of providing a value itself:. .. code-block:: c++. cl::opt<bool> Force (""f"", cl::desc(""Overwrite output files""));; cl::opt<bool> Quiet (""quiet"", cl::desc(""Don't print informational messages""));; cl::alias QuietA(""q"", cl::desc(""Alias for -quiet""), cl::aliasopt(Quiet));. The third line (which is the only one we modified from above) defines ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:11550,simpl,simple,11550,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,"... <arguments to function>). Overview:; """""""""""""""""". The '``llvm.coro.suspend.async``' intrinsic marks the point where; execution of an async coroutine is suspended and control is passed to a callee. Arguments:; """""""""""""""""""". The first argument should be the result of the `llvm.coro.async.resume` intrinsic.; Lowering will replace this intrinsic with the resume function for this suspend; point. The second argument is the `context projection function`. It should describe; how-to restore the `async context` in the continuation function from the first; argument of the continuation function. Its type is `ptr (ptr)`. The third argument is the function that models transfer to the callee at the; suspend point. It should take 3 arguments. Lowering will `musttail` call this; function. The fourth to six argument are the arguments for the third argument. Semantics:; """""""""""""""""""". The result of the intrinsic are mapped to the arguments of the resume function.; Execution is suspended at this intrinsic and resumed when the resume function is; called. .. _coro.prepare.async:. 'llvm.coro.prepare.async' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.prepare.async(ptr <coroutine function>). Overview:; """""""""""""""""". The '``llvm.coro.prepare.async``' intrinsic is used to block inlining of the; async coroutine until after coroutine splitting. Arguments:; """""""""""""""""""". The first argument should be an async coroutine of type `void (ptr, ptr, ptr)`.; Lowering will replace this intrinsic with its coroutine function argument. .. _coro.suspend.retcon:. 'llvm.coro.suspend.retcon' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i1 @llvm.coro.suspend.retcon(...). Overview:; """""""""""""""""". The '``llvm.coro.suspend.retcon``' intrinsic marks the point where; execution of a returned-continuation coroutine is suspended and control; is returned back to the caller. `llvm.coro.suspend.retcon`` does not support separate save points;; they are not useful when the cont",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:54434,resume,resumed,54434,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,2,['resume'],"['resume', 'resumed']"
Usability,"..; > Instead, it could a great topic for a separate study. Agreed. :). > What is the semantics of the IA64 stop bit?. Basically, the IA64 writes instructions like this:; mov ...; add ...; sub ...; op xxx; op xxx; ;;; mov ...; add ...; sub ...; op xxx; op xxx; ;;. Where the ;; delimits a group of instruction with no dependencies between; them, which can all be executed concurrently (to the limits of the; available functional units). The ;; gets translated into a bit set in one; of the opcodes. The advantages of this representation is that you don't have to do some; kind of 'thread id scheduling' pass by having to specify ahead of time how; many threads to use, and the representation doesn't have a per instruction; overhead... > And finally, another thought about the syntax for arrays :-); > Although this syntax:; > array <dimension-list> of <type>; > is verbose, it will be used only in the human-readable assembly code so; > size should not matter. I think we should consider it because I find it; > to be the clearest syntax. It could even make arrays of function; > pointers somewhat readable. My only comment will be to give you an example of why this is a bad; idea. :). Here is an example of using the switch statement (with my recommended; syntax):. switch uint %val, label %otherwise, ; [%3 x {uint, label}] [ { uint %57, label %l1 }, ; { uint %20, label %l2 }, ; { uint %14, label %l3 } ]. Here it is with the syntax you are proposing:. switch uint %val, label %otherwise, ; array %3 of {uint, label} ; array of {uint, label}; { uint %57, label %l1 },; { uint %20, label %l2 },; { uint %14, label %l3 }. Which is ambiguous and very verbose. It would be possible to specify; constants with [] brackets as in my syntax, which would look like this:. switch uint %val, label %otherwise,; array %3 of {uint, label} [ { uint %57, label %l1 },; { uint %20, label %l2 },; { uint %14, label %l3 } ]. But then the syntax is inconsistent between type definition and constant; definition (wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt:8091,clear,clearest,8091,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,1,['clear'],['clearest']
Usability,"..; This work is licensed under a Creative Commons Attribution 3.0 Unported License.; SPDX-License-Identifier: CC-BY-3.0. ===============; Response Guide; ===============. This is a :doc:`Code of Conduct<CodeOfConduct>` (CoC) incident response guide; used by the Code of Conduct Committee and LLVM event organizers. Code of Conduct Committee; =========================. All responses to Code of Conduct reports will be managed by a Code of Conduct; Committee. . Additional Code of Conduct Response Teams; =========================================. In-person events will have an additional response team to immediately respond; to an incident. For example:. * Each LLVM Developers' Meeting has a Code of Conduct response team.; * For LLVM meetups, the local organizers will be the first point of contact.; * Any other event funded by the LLVM Foundation or listed on the LLVM website,; will have a code of conduct response team or point of contact for CoC ; reports. These teams should determine if an :ref:`immediate response<Immediate Response; Checklist>` is needed before sending the report to the Code of Conduct; committee. .. _Receiving a report:. Receiving a Report; ==================. Reports are typically received by email (conduct@llvm.org) or in person from; the reporter or event CoC response team. When receiving a report by email, the CoC Committee should acknowledge receipt; within 24 hours. The acknowledgement should be understanding and compassionate; but no commitment should be made on whether this is a violation or which action; will be taken. Specific guidance is in the checklist below. For in-person events that have a violation reported, the report should be sent; to the Code of Conduct committee within 24 hours by the on-site CoC response; team. . .. _Immediate Response Checklist:. Immediate Response Checklist; ============================. The CoC committee generally works, decides, and communicates together. If the; report indicates that an immediate response is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:244,guid,guide,244,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['guid'],['guide']
Usability,"..; This work is licensed under a Creative Commons Attribution 3.0 Unported License.; SPDX-License-Identifier: CC-BY-3.0. ==============================; LLVM Community Code of Conduct; ==============================. The LLVM community has always worked to be a welcoming and respectful; community, and we want to ensure that doesn't change as we grow and evolve. To; that end, we have a few ground rules that we ask people to adhere to:. * `be friendly and patient`_,; * `be welcoming`_,; * `be considerate`_,; * `be respectful`_,; * `be careful in the words that you choose and be kind to others`_, and; * `when we disagree, try to understand why`_. This isn't an exhaustive list of things that you can't do. Rather, take it in; the spirit in which it's intended - a guide to make it easier to communicate; and participate in the community. This code of conduct applies to all spaces managed by the LLVM project or The; LLVM Foundation. This includes IRC channels, mailing lists, bug trackers, LLVM; events such as the developer meetings and socials, and any other forums created; by the project that the community uses for communication. It applies to all of; your communication and conduct in these spaces, including emails, chats, things; you say, slides, videos, posters, signs, or even t-shirts you display in these; spaces. . In rare cases, violations of this code outside of these spaces may affect a ; person’s ability to participate within these spaces. Important examples ; include `sexual and gender-based violence`_, `hate crimes`_, and `hate speech`_. ; We do not conduct proactive research, but we have an obligation to respond ; to any reported concerns. We are not interested in evaluating severity, ; responding punitively, or holding people accountable. Both the relevance ; and our response is instead focused on how a person’s continued participation ; impacts the community’s safety, wellbeing, and inclusivity. We specifically ; prioritize remaining a welcoming community to v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst:770,guid,guide,770,interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,1,['guid'],['guide']
Usability,"..; This work is licensed under a Creative Commons Attribution 3.0 Unported License.; SPDX-License-Identifier: CC-BY-3.0. =================================; LLVM CoC Incident Reporting Guide; =================================. First of all, please do not feel like you may be a burden to us by reporting; incidents. We consider reports an opportunity for us to act: by knowing about; an incident, we can act on it if appropriate, and reduce continuation of; problematic behavior. If we don't know, we can't learn or take any appropriate; actions. If you are not sure the situation being reported was a :doc:`Code of; Conduct<CodeOfConduct>` violation, we encourage you to still report it. We; would much rather have reports where we decide to take no action, rather than; miss a report of an actual violation. There is no harm in reporting an incident; which is later determined not to be a violation, and knowing about incidents; that are not violations can also help us to improve the Code of Conduct or the; processes surrounding it. Reporting and Contact Information; =================================. * For any incident involving an online platform (e.g., mailing lists, forums, ; irc/discord/slack, etc) we ask that you make any reports by emailing ; conduct@llvm.org. This is received by all members of the CoC Committee. * For LLVM Developers' Meetings, please file a report with the on-site Code ; of Conduct team. Their names and contact details are listed on the event ; webpage. You can also approach any other staff member, who can be ; identified by special badges and often found at the registration desk, ; to help you locate a member of the Code of Conduct team. All incidents ; reported in-person at a LLVM Developers' Meeting will be emailed to the ; Code of Conduct Committee. . * For meetups, please report the incident to the local meetup organizers first; and then email conduct@llvm.org with your report. Each meetup will have a ; contact listed on the associated meetup page.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:507,learn,learn,507,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst,1,['learn'],['learn']
Usability,".; 2. Implement JSROOT.extend instead of jQuery.extend, reduce; usage of jquery.js in core JSROOT classes; 3. Implement main graphics without jquery at all,; such mode used in `nobrowser` mode.; 4. Provide optional latex drawing with MathJax SVG.; TMathText always drawn with MathJax,; other classes require `mathjax` option in URL; 5. Improve drawing of different text classes, correctly handle; their alignment and scaling, special handling for IE; 6. Fix error with time axes - time offset was not correctly interpreted. ## Changes in 3.3; 1. Use d3.time.scale for display of time scales; 2. Within JSRootCore.js script URL one could specify JSROOT; functionality to be loaded: '2d', '3d', 'io', 'load', 'onload'.; Old method with JSROOT.AssertPrerequisites will also work.; 3. With THttpServer JSROOT now provides simple control functionality.; One could publish commands and execute them from the browser; 4. One could open several ROOT files simultaneously; 5. Add 'simple' layout - drawing uses full space on the right side; 6. Allow to open ROOT files in online session (via url parameter); 7. One could monitor simultaneously objects from server and root files; 8. Implement 'autocol' draw option - when superimposing histograms,; their line colors will be automatically assigned; 9. Implement 'nostat' draw option - disabled stat drawing; 10. Using '_same_' identifier in item name, one can easily draw or superimpose; similar items from different files. Could be used in URL like:; `...&files=[file1.root,file2.root]&items=[file1.root/hpx, file2.root/_same_]`; `...&files=[file1.root,file2.root]&item=file1.root/hpx+file2.root/_same_`; Main limitation - file names should have similar length.; 11. When 'autozoom' specified in draw options, histogram zoomed into; non-empty content. Same command available via context menu.; 12. Item of 'Text' kind can be created. It is displayed as; plain text in the browser. If property 'mathjax' specified,; MathJax.js library will be loaded and used ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:67369,simpl,simple,67369,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['simpl'],['simple']
Usability,".; Any volume is an un-positioned object in the sense that it defines only; a ***`local frame`*** (matching the one of its ***`shape`***). In order; to fully define the mother-daughter relationship between two volumes one; has to specify how the daughter will be positioned inside. This is; accomplished by defining a ***`local geometrical transformation`*** of; the daughter with respect to the mother coordinate system. These; transformations will be subsequently used in the example. ***`Q:`*** ""I see the lines defining the top level volume as in the previous example,; but what about the other volumes named REPLICA and ROOT?"". ***`A:`*** You will also notice that several other volumes are created; by using lines like:. ``` {.cpp}; TGeoVolume *someVolume = gGeoManager->MakeXXX(""someName"",; ptrMedium, /* parameters coresponding to XXX ...*/); ```. In the method above **`XXX`** represent some shape name (Box, Tube,; etc.). This is just a simple way of creating a volume having a given; shape in one-step (see also section: ""Creating and Positioning; Volumes""). As for REPLICA and ROOT volumes, they are just some; ***`virtual volumes`*** used for grouping and positioning together other; ***`real volumes`***. See ""Positioned Volumes (Nodes)"". The same; structure represented by (a real or) a virtual volume can be; ***`replicated`*** several times in the geometry. ***`Q:`*** ""Fine, so probably the real volumes are the ones composing the letters R,; O and T. Why one have to define so many volumes to make an R?"". ***`A:`*** Well, in real life some objects have much more complex shapes; that an ***`R`***. The modeller cannot just know all of them; the idea; is to make a complex object by using elementary building blocks that; have known shapes (called ***`primitive shapes`***). Gluing these; together in the appropriate way is the user responsibility. ***`Q:`*** ""I am getting the global picture but not making much out of it... There; are also a lot of calls to TGeoVolume::AddNode()",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:6493,simpl,simple,6493,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,".; MI = BuildMI(MBB, DL, TII.get(X86::SAHF));. // Create a self looping branch instruction.; BuildMI(MBB, DL, TII.get(X86::JNE)).addMBB(&MBB);. If you need to add a definition operand (other than the optional destination; register), you must explicitly mark it as such:. .. code-block:: c++. MI.addReg(Reg, RegState::Define);. Fixed (preassigned) registers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. One important issue that the code generator needs to be aware of is the presence; of fixed registers. In particular, there are often places in the instruction; stream where the register allocator *must* arrange for a particular value to be; in a particular register. This can occur due to limitations of the instruction; set (e.g., the X86 can only do a 32-bit divide with the ``EAX``/``EDX``; registers), or external factors like calling conventions. In any case, the; instruction selector should emit code that copies a virtual register into or out; of a physical register when needed. For example, consider this simple LLVM example:. .. code-block:: llvm. define i32 @test(i32 %X, i32 %Y) {; %Z = sdiv i32 %X, %Y; ret i32 %Z; }. The X86 instruction selector might produce this machine code for the ``div`` and; ``ret``:. .. code-block:: text. ;; Start of div; %EAX = mov %reg1024 ;; Copy X (in reg1024) into EAX; %reg1027 = sar %reg1024, 31; %EDX = mov %reg1027 ;; Sign extend X into EDX; idiv %reg1025 ;; Divide by Y (in reg1025); %reg1026 = mov %EAX ;; Read the result (Z) out of EAX. ;; Start of ret; %EAX = mov %reg1026 ;; 32-bit return value goes in EAX; ret. By the end of code generation, the register allocator would coalesce the; registers and delete the resultant identity moves producing the following; code:. .. code-block:: text. ;; X is in EAX, Y is in ECX; mov %EAX, %EDX; sar %EDX, 31; idiv %ECX; ret. This approach is extremely general (if it can handle the X86 architecture, it; can handle anything!) and allows all of the target specific knowledge about the; instruction stream to be isolat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:19869,simpl,simple,19869,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,".; Such new versions will be similar in spirit to the present version,; but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library; specifies a version number of this License which applies to it and; ""any later version"", you have the option of following the terms and; conditions either of that version or of any later version published by; the Free Software Foundation. If the Library does not specify a; license version number, you may choose any version ever published by; the Free Software Foundation.; ; 14. If you wish to incorporate parts of the Library into other free; programs whose distribution conditions are incompatible with these,; write to the author to ask for permission. For software which is; copyrighted by the Free Software Foundation, write to the Free; Software Foundation; we sometimes make exceptions for this. Our; decision will be guided by the two goals of preserving the free status; of all derivatives of our free software and of promoting the sharing; and reuse of software generally. NO WARRANTY. 15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO; WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.; EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR; OTHER PARTIES PROVIDE THE LIBRARY ""AS IS"" WITHOUT WARRANTY OF ANY; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR; PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE; LIBRARY IS WITH YOU. SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME; THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN; WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY; AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU; FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR; CONSEQUENTIAL DAMAGES A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt:22823,guid,guided,22823,LGPL2_1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt,1,['guid'],['guided']
Usability,".; This environment can use the Windows SDK headers directly and does not required additional; headers or additional runtime machinery (such as is used by mingw). Windows Itanium Stack:. * Uses the Itanium C++ abi.; * libc++.; * libc++-abi.; * libunwind.; * The MS VS CRT.; * Is compatible with MS Windows SDK include headers.; * COFF/PE file format.; * LLD. Note: compiler-rt is not used. This functionality is supplied by the MS VCRT. Prerequisites; =============. * The MS SDK is installed as part of MS Visual Studio.; * Clang with support for the windows-itanium triple.; * COFF LLD with support for the -autoimport switch. Known issues:; =============. SJLJ exceptions, ""-fsjlj-exceptions"", are the only currently supported model. link.exe (the MS linker) is unsuitable as it doesn't support auto-importing which; is currently required to link correctly. However, if that limitation is removed; then there are no other known issues with using link.exe. Currently, there is a lack of a usable Windows compiler driver for Windows Itanium.; A reasonable work-around is to build clang with a windows-msvc default target and; then override the triple with e.g. ""-Xclang -triple -Xclang x86_64-unknown-windows-itanium"".; The linker can be specified with: ""-fuse-ld=lld"". In the Itanium C++ ABI the first member of an object is a pointer to the vtable; for its class. The vtable is often emitted into the object file with the key function; and must be imported for classes marked dllimport. The pointers must be globally; unique. Unfortunately, the COFF/PE file format does not provide a mechanism to; store a runtime address from another DLL into this pointer (although runtime; addresses are patched into the IAT). Therefore, the compiler must emit some code,; that runs after IAT patching but before anything that might use the vtable pointers,; and sets the vtable pointer to the address from the IAT. For the special case of; the references to vtables for __cxxabiv1::__class_type_info from typei",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst:1329,usab,usable,1329,interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst,1,['usab'],['usable']
Usability,".begin(token %id, ptr %alloc); ...; store i32 42, ptr %promise ; store something into the promise; ...; ret ptr %hdl; }. define i32 @main() {; entry:; %hdl = call ptr @f(i32 4) ; starts the coroutine and returns its handle; %promise.addr = call ptr @llvm.coro.promise(ptr %hdl, i32 4, i1 false); %val = load i32, ptr %promise.addr ; load a value from the promise; call void @print(i32 %val); call void @llvm.coro.destroy(ptr %hdl); ret i32 0; }. .. _coroutine intrinsics:. Coroutine Structure Intrinsics; ------------------------------; Intrinsics described in this section are used within a coroutine to describe; the coroutine structure. They should not be used outside of a coroutine. .. _coro.size:. 'llvm.coro.size' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i32 @llvm.coro.size.i32(); declare i64 @llvm.coro.size.i64(). Overview:; """""""""""""""""". The '``llvm.coro.size``' intrinsic returns the number of bytes; required to store a `coroutine frame`_. This is only supported for; switched-resume coroutines. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". The `coro.size` intrinsic is lowered to a constant representing the size of; the coroutine frame. .. _coro.align:. 'llvm.coro.align' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare i32 @llvm.coro.align.i32(); declare i64 @llvm.coro.align.i64(). Overview:; """""""""""""""""". The '``llvm.coro.align``' intrinsic returns the alignment of a `coroutine frame`_.; This is only supported for switched-resume coroutines. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". The `coro.align` intrinsic is lowered to a constant representing the alignment of; the coroutine frame. .. _coro.begin:. 'llvm.coro.begin' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.begin(token <id>, ptr <mem>). Overview:; """""""""""""""""". The '``llvm.coro.begin``' intrinsic returns an address of the coroutine frame. Arguments:; """""""""""""""""""". The first argument is a token returned by a call to '``llvm.coro.id`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:31660,resume,resume,31660,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,".llvm_stackmaps"". The segment name is ""__LLVM_STACKMAPS"". Stack Map Usage; ===============. The stack map support described in this document can be used to; precisely determine the location of values at a specific position in; the code. LLVM does not maintain any mapping between those values and; any higher-level entity. The runtime must be able to interpret the; stack map record given only the ID, offset, and the order of the; locations, records, and functions, which LLVM preserves. Note that this is quite different from the goal of debug information,; which is a best-effort attempt to track the location of named; variables at every instruction. An important motivation for this design is to allow a runtime to; commandeer a stack frame when execution reaches an instruction address; associated with a stack map. The runtime must be able to rebuild a; stack frame and resume program execution using the information; provided by the stack map. For example, execution may resume in an; interpreter or a recompiled version of the same function. This usage restricts LLVM optimization. Clearly, LLVM must not move; stores across a stack map. However, loads must also be handled; conservatively. If the load may trigger an exception, hoisting it; above a stack map could be invalid. For example, the runtime may; determine that a load is safe to execute without a type check given; the current state of the type system. If the type system changes while; some activation of the load's function exists on the stack, the load; becomes unsafe. The runtime can prevent subsequent execution of that; load by immediately patching any stack map location that lies between; the current call site and the load (typically, the runtime would; simply patch all stack map locations to invalidate the function). If; the compiler had hoisted the load above the stack map, then the; program could crash before the runtime could take back control. To enforce these semantics, stackmap and patchpoint intrinsics are;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:17795,resume,resume,17795,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['resume'],['resume']
Usability,"/ create frame record; mov x1, #2 // set x1 to a constant indicating the type of failure; adrp x16, :got:__hwasan_tag_mismatch_v2 // call runtime function to save remaining registers and report error; ldr x16, [x16, :got_lo12:__hwasan_tag_mismatch_v2] // (load address from GOT to avoid potential register clobbers in delay load handler); br x16. Heap; ----. Tagging the heap memory/pointers is done by `malloc`.; This can be based on any malloc that forces all objects to be TG-aligned.; `free` tags the memory with a different tag. Stack; -----. Stack frames are instrumented by aligning all non-promotable allocas; by `TG` and tagging stack memory in function prologue and epilogue. Tags for different allocas in one function are **not** generated; independently; doing that in a function with `M` allocas would require; maintaining `M` live stack pointers, significantly increasing register; pressure. Instead we generate a single base tag value in the prologue,; and build the tag for alloca number `M` as `ReTag(BaseTag, M)`, where; ReTag can be as simple as exclusive-or with constant `M`. Stack instrumentation is expected to be a major source of overhead,; but could be optional. Globals; -------. Most globals in HWASAN instrumented code are tagged. This is accomplished; using the following mechanisms:. * The address of each global has a static tag associated with it. The first; defined global in a translation unit has a pseudorandom tag associated; with it, based on the hash of the file path. Subsequent global tags are; incremental from the previously-assigned tag. * The global's tag is added to its symbol address in the object file's symbol; table. This causes the global's address to be tagged when its address is; taken. * When the address of a global is taken directly (i.e. not via the GOT), a special; instruction sequence needs to be used to add the tag to the address,; because the tag would otherwise take the address outside of the small code; model (4GB on AArch64). No c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst:6060,simpl,simple,6060,interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HardwareAssistedAddressSanitizerDesign.rst,1,['simpl'],['simple']
Usability,"//. Shrink: (setlt (loadi32 P), 0) -> (setlt (loadi8 Phi), 0). //===---------------------------------------------------------------------===//. Reassociate should turn things like:. int factorial(int X) {; return X*X*X*X*X*X*X*X;; }. into llvm.powi calls, allowing the code generator to produce balanced; multiplication trees. First, the intrinsic needs to be extended to support integers, and second the; code generator needs to be enhanced to lower these to multiplication trees. //===---------------------------------------------------------------------===//. Interesting? testcase for add/shift/mul reassoc:. int bar(int x, int y) {; return x*x*x+y+x*x*x*x*x*y*y*y*y;; }; int foo(int z, int n) {; return bar(z, n) + bar(2*z, 2*n);; }. This is blocked on not handling X*X*X -> powi(X, 3) (see note above). The issue; is that we end up getting t = 2*X s = t*t and don't turn this into 4*X*X,; which is the same number of multiplies and is canonical, because the 2*X has; multiple uses. Here's a simple example:. define i32 @test15(i32 %X1) {; %B = mul i32 %X1, 47 ; X1*47; %C = mul i32 %B, %B; ret i32 %C; }. //===---------------------------------------------------------------------===//. Reassociate should handle the example in GCC PR16157:. extern int a0, a1, a2, a3, a4; extern int b0, b1, b2, b3, b4; ; void f () { /* this can be optimized to four additions... */ ; b4 = a4 + a3 + a2 + a1 + a0; ; b3 = a3 + a2 + a1 + a0; ; b2 = a2 + a1 + a0; ; b1 = a1 + a0; ; } . This requires reassociating to forms of expressions that are already available,; something that reassoc doesn't think about yet. //===---------------------------------------------------------------------===//. These two functions should generate the same code on big-endian systems:. int g(int *j,int *l) { return memcmp(j,l,4); }; int h(int *j, int *l) { return *j - *l; }. this could be done in SelectionDAGISel.cpp, along with other special cases,; for 1,2,4,8 bytes. //===----------------------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:2281,simpl,simple,2281,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simple']
Usability,"//===----------------------------------------------------------------------===//; // Clang Static Analyzer; //===----------------------------------------------------------------------===//. = Library Structure =. The analyzer library has two layers: a (low-level) static analysis; engine (ExprEngine.cpp and friends), and some static checkers; (*Checker.cpp). The latter are built on top of the former via the; Checker and CheckerVisitor interfaces (Checker.h and; CheckerVisitor.h). The Checker interface is designed to be minimal; and simple for checker writers, and attempts to isolate them from much; of the gore of the internal analysis engine. = How It Works =. The analyzer is inspired by several foundational research papers ([1],; [2]). (FIXME: kremenek to add more links). In a nutshell, the analyzer is basically a source code simulator that; traces out possible paths of execution. The state of the program; (values of variables and expressions) is encapsulated by the state; (ProgramState). A location in the program is called a program point; (ProgramPoint), and the combination of state and program point is a; node in an exploded graph (ExplodedGraph). The term ""exploded"" comes; from exploding the control-flow edges in the control-flow graph (CFG). Conceptually the analyzer does a reachability analysis through the; ExplodedGraph. We start at a root node, which has the entry program; point and initial state, and then simulate transitions by analyzing; individual expressions. The analysis of an expression can cause the; state to change, resulting in a new node in the ExplodedGraph with an; updated program point and an updated state. A bug is found by hitting; a node that satisfies some ""bug condition"" (basically a violation of a; checking invariant). The analyzer traces out multiple paths by reasoning about branches and; then bifurcating the state: on the true branch the conditions of the; branch are assumed to be true and on the false branch the conditions; of the branc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt:537,simpl,simple,537,interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,1,['simpl'],['simple']
Usability,"//===----------------------------------------------------------------------===//; // ModuleMaker Sample project; //===----------------------------------------------------------------------===//. This project is an extremely simple example of using some simple pieces of the ; LLVM API. The actual executable generated by this project simply emits an ; LLVM bitcode file to standard output. It is designed to show some basic ; usage of LLVM APIs, and how to link to LLVM libraries.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ModuleMaker/README.txt:224,simpl,simple,224,interpreter/llvm-project/llvm/examples/ModuleMaker/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ModuleMaker/README.txt,3,['simpl'],"['simple', 'simply']"
Usability,"/64162>`_); - Fix a crash when calling a consteval function in an expression used as; the size of an array.; (`#65520 <https://github.com/llvm/llvm-project/issues/65520>`_). - Clang no longer tries to capture non-odr-used variables that appear; in the enclosing expression of a lambda expression with a noexcept specifier.; (`#67492 <https://github.com/llvm/llvm-project/issues/67492>`_). - Fix crash when fold expression was used in the initialization of default; argument. Fixes:; (`#67395 <https://github.com/llvm/llvm-project/issues/67395>`_). - Fixed a bug causing destructors of constant-evaluated structured bindings; initialized by array elements to be called in the wrong evaluation context. - Fix crash where ill-formed code was being treated as a deduction guide and; we now produce a diagnostic. Fixes:; (`#65522 <https://github.com/llvm/llvm-project/issues/65522>`_). - Fixed a bug where clang incorrectly considered implicitly generated deduction; guides from a non-templated constructor and a templated constructor as ambiguous,; rather than prefer the non-templated constructor as specified in; [standard.group]p3. - Fixed a crash caused by incorrect handling of dependence on variable templates; with non-type template parameters of reference type. Fixes:; (`#65153 <https://github.com/llvm/llvm-project/issues/65153>`_). - Clang now properly compares constraints on an out of line class template; declaration definition. Fixes:; (`#61763 <https://github.com/llvm/llvm-project/issues/61763>`_). - Fix a bug where implicit deduction guides are not correctly generated for nested template; classes. Fixes:; (`#46200 <https://github.com/llvm/llvm-project/issues/46200>`_); (`#57812 <https://github.com/llvm/llvm-project/issues/57812>`_). - Diagnose use of a variable-length array in a coroutine. The design of; coroutines is such that it is not possible to support VLA use. Fixes:; (`#65858 <https://github.com/llvm/llvm-project/issues/65858>`_). - Fix bug where we were overriding zero-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:51422,guid,guides,51422,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['guid'],['guides']
Usability,"/; __stop_omp_offloading_entries /*EntriesEnd*/; }; };; static const __tgt_bin_desc BinDesc = {; sizeof(Images) / sizeof(Images[0]), /*NumDeviceImages*/; Images, /*DeviceImages*/; __start_omp_offloading_entries, /*HostEntriesBegin*/; __stop_omp_offloading_entries /*HostEntriesEnd*/; };. Global Constructor and Destructor; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The global constructor (``.omp_offloading.descriptor_reg()``) registers the; device images with the runtime by calling the ``__tgt_register_lib()`` runtime; function. The constructor is explicitly defined in ``.text.startup`` section and; is run once when the program starts. Similarly, the global destructor; (``.omp_offloading.descriptor_unreg()``) calls ``__tgt_unregister_lib()`` for; the destructor and is also defined in ``.text.startup`` section and run when the; program exits. Offloading Example; ------------------. This section contains a simple example of generating offloading code using; OpenMP offloading. We will use a simple ``ZAXPY`` BLAS routine. .. code-block:: c++. #include <complex>. using complex = std::complex<double>;. void zaxpy(complex *X, complex *Y, complex D, std::size_t N) {; #pragma omp target teams distribute parallel for; for (std::size_t i = 0; i < N; ++i); Y[i] = D * X[i] + Y[i];; }. int main() {; const std::size_t N = 1024;; complex X[N], Y[N], D;; #pragma omp target data map(to:X[0 : N]) map(tofrom:Y[0 : N]); zaxpy(X, Y, D, N);; }. This code is compiled using the following Clang flags. .. code-block:: console. $ clang++ -fopenmp -fopenmp-targets=nvptx64 -O3 zaxpy.cpp -c. The output section in the object file can be seen using the ``readelf`` utility.; The ``.llvm.offloading`` section has the ``SHF_EXCLUDE`` flag so it will be; removed from the final executable or shared library by the linker. .. code-block:: text. $ llvm-readelf -WS zaxpy.o; Section Headers:; [Nr] Name Type Address Off Size ES Flg Lk Inf Al; [11] omp_offloading_entries PROGBITS 0000000000000000 0001f0 000040 00 A 0 0 1;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:21838,simpl,simple,21838,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst,1,['simpl'],['simple']
Usability,"/F"").; - Allow reading of older version of TTreePerfStats (ROOT-8520); - In `TTree::OptimizeBaskets()` do not call GetBasket(0) to avoid disc reads; - It is now possible to define the precision of the default histogram created; by `TTree::Draw`. Three new parameters are available in `$ROOTSYS/etcsystem.rootrc`; ```{.cpp}; Hist.Precision.1D: float; Hist.Precision.2D: float; Hist.Precision.3D: float; ```; the default values are `float`. They can be set to `double`.; - Fix ROOT-8742: TTree::SetBranchAddress could not be invoked safely even when dealing with the same tree obtained from the same file opened in different threads.; - TTree::Branch() now complains if a ""name[size]/F"" branch specification is passed wrongly (e.g. as ""name/F[size]""). ### TDataFrame; - Creation of the TDataFrame class. The TDataFrame allows to interact with data; stored in columnar format in a functional and intuitive way in order to perform; data analysis. Parallelism is accessible simply by activating implicit; multi-threading with the ROOT::EnableImplicitMT() function.; In a nutshell, the functionality provided is:; - Create and fill histograms with one single method invocation; - Express filtering of entries with strings, lambdas or functions; - Easy creation of efficiencies of cut-flows; - Possibility to run on ranges of entries; - Creating columns not present in the original dataset; - Chain multiple actions to be executed on the same event loop; - Creation of events on-the-fly (e.g. via Pythia or user-define generator functors), with no need for an input TTree; - Snapshot on a rootfile the dataset after cuts and after augmentation with columns created by the user; - Run analyses expressed as chains of actions in parallel in a transparent way for the user; See [the online documentation](https://root.cern.ch/doc/master/classROOT_1_1Experimental_1_1TDF_1_1TDataFrame.html) for more details. ## 2D Graphics Libraries; - If one used ""col2"" or ""colz2"", the value of `TH1::fMaximum` got modified.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:6310,simpl,simply,6310,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['simpl'],['simply']
Usability,"/WLCG-AuthZ-WG/bearer-token-discovery/blob/master/specification.md). Short overview:. 1. If the `BEARER_TOKEN` environment variable is set, then the value is taken to be the token contents.; 2. If the `BEARER_TOKEN_FILE` environment variable is set, then its value is interpreted as a filename. The contents of the specified file are taken to be the token contents.; 3. If the `XDG_RUNTIME_DIR` environment variable is set, then take the token from the contents of `$XDG_RUNTIME_DIR/bt_u$ID`(this additional location is intended to provide improved security for shared login environments as `$XDG_RUNTIME_DIR` is defined to be user-specific as opposed to a system-wide directory.).; 4. Otherwise, take the token from `/tmp/bt_u$ID`. ## GUI Libraries. ### RBrowser improvements. - central factory methods to handle browsing, editing and drawing of different classes; - simple possibility to extend RBrowser on user-defined classes; - support of web-based geometry viewer; - better support of TTree drawing; - server-side handling of code editor and image viewer widgets; - rbrowser content is fully recovered when web-browser is reloaded; - load of widgets code only when really required (shorter startup time for RBrowser). ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ### Major JSROOT update to version 6. - update all used libraries `d3.js`, `three.js`, `MathJax.js`, openui5; - change to Promise based interface for all async methods, remove call-back arguments; - change scripts names, core scripts name now `JSRoot.core.js`; - unify function/methods naming conventions, many changes in method names; - provide central code loader via `JSROOT.require`, supporting 4 different loading engines; - many nice features and many bug fixes; see JSROOT v6 release notes. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. - a new cmake variable, `CMAKE_INSTALL_PYTHONDIR`, has been added: it allows customization of the i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:26910,simpl,simple,26910,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['simpl'],['simple']
Usability,"/github.com/root-project/root/issues/15197)] - RBDT does not support xgboost inference; * [[#15156](https://github.com/root-project/root/issues/15156)] - Segfault in TMVA::Experimental::SOFIE::RModel::Streamer; * [[#15139](https://github.com/root-project/root/issues/15139)] - cmake option -Dall=YES breaks the cmake; * [[#15118](https://github.com/root-project/root/issues/15118)] - jsoninterface does not build if provided with RapidYAML; * [[#15108](https://github.com/root-project/root/issues/15108)] - Turn off clang-format for Linkdef files; * [[#15090](https://github.com/root-project/root/issues/15090)] - TClass::GetClassInfo() is not thread safe; * [[#15077](https://github.com/root-project/root/issues/15077)] - Passing different floating point types to `RVec` utility functions; * [[#15048](https://github.com/root-project/root/issues/15048)] - [ntuple] Handling of virtual inheritance broken; * [[#15040](https://github.com/root-project/root/issues/15040)] - [RDataFrame] Inaccurate example of progress bar from documentation; * [[#15028](https://github.com/root-project/root/issues/15028)] - [RDataFrame] Unable to cacheread remote file; * [[#15027](https://github.com/root-project/root/issues/15027)] - spurrious cmake message about AfterImage with -Dminimal=ON; * [[#14981](https://github.com/root-project/root/issues/14981)] - RVecs leak memory with np.asarray in pyROOT; * [[#14964](https://github.com/root-project/root/issues/14964)] - ROOT-HEAD fails with ""cling interactive line includer >>>: fatal error: module file '[snip]/Vc.pcm' not found: module file not found""; * [[#14958](https://github.com/root-project/root/issues/14958)] - ROOT_HEAD failed with error message: Fail to detect cryptographic random generator; * [[#14921](https://github.com/root-project/root/issues/14921)] - ROOT Fails to build macOS 14.4 arm64 Xcode 15.3; * [[#14914](https://github.com/root-project/root/issues/14914)] - VecOps::Take with default argument doesn't check correctly the out of boundary ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:27150,progress bar,progress bar,27150,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['progress bar'],['progress bar']
Usability,"/sft.cern.ch/lcg/external/PoD/3.12/x86_64-slc5-gcc41-python24-boost1.53; ** Server is started. Use ""pod-info -sd"" to check the status of the server. ### Request and wait for workers. Now the server is started but you don't have any worker available. To; request for `<n>` workers, do:. vafreq <n>. To check how many workers became available for use:. pod-info -n. To continuously update the check (`Ctrl-C` to terminate):. vafcount. Example of output:. Updating every 5 seconds. Press Ctrl-C to stop monitoring...; [20130411-172235] 0; [20130411-172240] 0; [20130411-172245] 12; [20130411-172250] 12; ... To execute a command after a certain number of workers is available (in; the example we wait for 5 workers then start ROOT):. vafwait 5 && root -l. > Workers take some time before becoming available. Also, it is possible; > that not all the requested workers will be satisfied. ### Start ROOT and use PROOF. When you are satisfied with the available number of active workers, you; may start your PROOF analysis. Start ROOT, and from its prompt connect; to PROOF like this:. root [0] TProof::Open(""pod://"");. Example of output:. Starting master: opening connection ...; Starting master: OK; Opening connections to workers: OK (12 workers); Setting up worker servers: OK (12 workers); PROOF set to parallel mode (12 workers). ### Stop or restart your PoD cluster. At the end of your session, remember to free the workers by stopping; your PoD server:. vafctl --stop. > PoD will stop the PROOF master and the workers after detecting they've; > been idle for a certain amount of time anyway, but it is a good habit; > to stop it for yourself when you're finished using it, so that you are; > immediately freeing resources and let them be available for other; > users. In case of a major PROOF failure (i.e., crash), you can simply restart; your personal PROOF cluster by running:. vafctl --start. PoD will stop and restart the PROOF master. You'll need to request the; workers again at this point.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:12587,simpl,simply,12587,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['simpl'],['simply']
Usability,"0, %entry ], [ %indvar.next, %bb2 ]; 	%1 = load i32* %cond, align 4; 	%2 = icmp eq i32 %1, 0; 	br i1 %2, label %bb2, label %bb1. bb1:		; preds = %bb; 	%3 = xor i32 %.rle, 234	; 	store i32 %3, i32* %res, align 4; 	br label %bb2. bb2:		; preds = %bb, %bb1; 	%.rle6 = phi i32 [ %3, %bb1 ], [ %.rle, %bb ]	; 	%indvar.next = add i32 %i.05, 1	; 	%exitcond = icmp eq i32 %indvar.next, %n; 	br i1 %exitcond, label %return, label %bb. DSE should sink partially dead stores to get the store out of the loop. Here's another partial dead case:; http://gcc.gnu.org/bugzilla/show_bug.cgi?id=12395. //===---------------------------------------------------------------------===//. Scalar PRE hoists the mul in the common block up to the else:. int test (int a, int b, int c, int g) {; int d, e;; if (a); d = b * c;; else; d = b - c;; e = b * c + g;; return d + e;; }. It would be better to do the mul once to reduce codesize above the if.; This is GCC PR38204. //===---------------------------------------------------------------------===//; This simple function from 179.art:. int winner, numf2s;; struct { double y; int reset; } *Y;. void find_match() {; int i;; winner = 0;; for (i=0;i<numf2s;i++); if (Y[i].y > Y[winner].y); winner =i;; }. Compiles into (with clang TBAA):. for.body: ; preds = %for.inc, %bb.nph; %indvar = phi i64 [ 0, %bb.nph ], [ %indvar.next, %for.inc ]; %i.01718 = phi i32 [ 0, %bb.nph ], [ %i.01719, %for.inc ]; %tmp4 = getelementptr inbounds %struct.anon* %tmp3, i64 %indvar, i32 0; %tmp5 = load double* %tmp4, align 8, !tbaa !4; %idxprom7 = sext i32 %i.01718 to i64; %tmp10 = getelementptr inbounds %struct.anon* %tmp3, i64 %idxprom7, i32 0; %tmp11 = load double* %tmp10, align 8, !tbaa !4; %cmp12 = fcmp ogt double %tmp5, %tmp11; br i1 %cmp12, label %if.then, label %for.inc. if.then: ; preds = %for.body; %i.017 = trunc i64 %indvar to i32; br label %for.inc. for.inc: ; preds = %for.body, %if.then; %i.01719 = phi i32 [ %i.01718, %for.body ], [ %i.017, %if.then ]; %indvar.next = add i6",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:29796,simpl,simple,29796,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simple']
Usability,"0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ```. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ``` {.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ```. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the geometry. ``` {.cpp}; root[] gGeoManager->SetTopVolume(top);; ```. This should be enough, but it is not since always after defining some; geometry hierarchy, **`TGeo`** needs to build some optimization; structures and perform some checks. Note the messages posted after the; statement is executed. We will describe the corresponding operations; later. ``` {.cpp}; root[] gGeoManager->CloseGeometry();; ```. Now we are really done with geometry building stage, but we would like; to see our simple world:. ``` {.cpp}; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; ```. ### Example 2: A Geometrical Hierarchy Look and Feel. Before going further, let us get a look and feel of interacting with the; modeller. For this, we will use one of the examples illustrating the; geometry package. To get an idea on the geometry structure created in; this example, just look at the link:; <http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html>. You will; notice that this is a bit more complex that just creating the ""world""; since several other volumes are created and put together in a hierarchy.; The purpose here is just to learn how to interact with a geometry that; is already built, but just few hints on the building steps in this; example might be useful. The geometry here represents the word ROOT that; is replicated in some symmetric manner. You might for instance ask some; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:4067,simpl,simple,4067,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"000] {File} 'pr-46466-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr-46466.cpp'; [002] 1 {Struct} 'Struct'; [003] 2 {Union} 'Union'; [004] 3 {Enumeration} 'NestedEnum' -> 'int'; [005] {Enumerator} 'BLUE' = '0x1'; [005] {Enumerator} 'RED' = '0x0'. Logical View:; [000] {File} 'pr-46466-codeview-msvc.o' -> COFF-i386. [001] {CompileUnit} 'pr-46466.cpp'; [002] 1 {Struct} 'Struct'; [003] 2 {Union} 'Union'; [004] 3 {Enumeration} 'NestedEnum' -> 'int'; [005] {Enumerator} 'BLUE' = '0x1'; [005] {Enumerator} 'RED' = '0x0'. Logical View:; [000] {File} 'pr-46466-dwarf-clang.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-46466.cpp'. Logical View:; [000] {File} 'pr-46466-dwarf-gcc.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-46466.cpp'; [002] 1 {Struct} 'Struct'; [003] 2 {Union} 'Union'; [004] 3 {Enumeration} 'NestedEnum' -> 'unsigned int'; [005] {Enumerator} 'BLUE' = '0x1'; [005] {Enumerator} 'RED' = '0x0'. Using the :program:`llvm-debuginfo-analyzer` selection facilities, we; can produce a simple tabular output including a summary for the logical; types that are **Enumerator**. The logical view is sorted by the types; name. .. code-block:: none. llvm-debuginfo-analyzer --attribute=format,level; --output-sort=name; --select-types=Enumerator; --print=types,summary; pr-46466-*.o. .. code-block:: none. Logical View:; [000] {File} 'pr-46466-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr-46466.cpp'; [005] {Enumerator} 'BLUE' = '0x1'; [005] {Enumerator} 'RED' = '0x0'. -----------------------------; Element Total Found; -----------------------------; Scopes 5 0; Symbols 2 0; Types 6 2; Lines 0 0; -----------------------------; Total 13 2. Logical View:; [000] {File} 'pr-46466-codeview-msvc.o' -> COFF-i386. [001] {CompileUnit} 'pr-46466.cpp'; [005] {Enumerator} 'BLUE' = '0x1'; [005] {Enumerator} 'RED' = '0x0'. -----------------------------; Element Total Found; -----------------------------; Scopes 5 0; Symbols 2 0; Types 7 2; Lines 0 0; -----------------------------; To",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:46584,simpl,simple,46584,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['simpl'],['simple']
Usability,"081287804; i=11, fSumw2 type= 62, offset=528, len=1, method=1081287924; i=12, fOption type= 65, offset=540, len=1, method=1081288044; i=13, fFunctions type= 63, offset=548, len=1, method=1081288164; ```. ### Optimized StreamerInfo. The entries starting with ""`i = 0`"" is the optimized format of the; `StreamerInfo`. Consecutive data members of the same simple type and; size are collapsed and read at once into an array for performance; optimization. ``` {.cpp}; i= 0, TNamed type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; ```. For example, the five data members beginning with `fEnties `and the; three data members beginning with `fMaximum`, are put into an array; called `fEntries` (`i = 9`) with the length 8. ``` {.cpp}; i= 9, fEntries type= 28, offset=452, len=8, method=0; ```. Only simple type data members are combined, object data members are not; combined. For example the three axis data members remain separate. The; ""method"" is a handle to the method that reads the object. ### Automatic Schema Evolution. When a class is defined in ROOT, it must include the `ClassDef` macro as; the last line in the header file inside the class definition. The syntax; is:. ``` {.cpp}; ClassDef(<ClassName>,<VersionNumber>); ```. The version number identifies this particular version of the class. When; a class has version 0 it is not stored in a root file but its base; class(es) is(are). The reason can be that this class has no data members; worth saving or all real info is in the base classes. The version number; is written to the file in the `Streamer` by the call; `TBuffer::WriteVersion`. You, as the designer of the class, do not need; to do any manual modification in the `Streamer`. ROOT schema evolution; mechanism is automatic and handled by the `StreamerInfo`. ### Manual Data Model Evolution Capabilities. The ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:75581,simpl,simple,75581,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability,"10-6). If we multiply the number of tracks by 7 s,; (1,000,000,000 \* 7 \* 10-6) we calculate that the time allocating and; freeing memory is about 2 hours. This is the chunk of time saved when a; **`TClonesArray`** is used rather than a **`TObjArray`**. If you do not; want to wait 2 hours for your tracks (or equivalent objects), be sure to; use a **`TClonesArray`** for same-class objects arrays. Branches with; **`TClonesArrays`** use the same method (`TTree::Branch`) as any other; object described above. If splitting is specified the objects in the; **`TClonesArray`** are split, not the **`TClonesArray`** itself. ### Identical Branch Names. When a top-level object (say `event`), has two data members of the same; class the sub branches end up with identical names. To distinguish the; sub branch we must associate them with the master branch by including a; ""`.`"" (a dot) at the end of the master branch name. This will force the; name of the sub branch to be `master.sub` branch instead of simply `sub`; branch. For example, a tree has two branches `Trigger` and; `MuonTrigger`, each containing an object of the same class (`Trigger`).; To identify uniquely the sub branches we add the dot:. ``` {.cpp}; tree->Branch(""Trigger."",""Trigger"",&b1,8000,1);; tree->Branch(""MuonTrigger."",""Trigger"",&b2,8000,1);; ```. If `Trigger` has three members, `T1`, `T2`, `T3`, the two instructions; above will generate sub branches called: `Trigger.T1`, `Trigger.T2`,; `Trigger.T3`, `MuonTrigger.T1`, `MuonTrigger.T2`, and` MuonTrigger.T3`. ## Adding a Branch with a Folder. Use the syntax below to add a branch from a folder:. ``` {.cpp}; tree->Branch(""/aFolder"");; ```. This method creates one branch for each element in the folder. The; method returns the total number of branches created. ## Adding a Branch with a Collection. This `Branch` method creates one branch for each element in the; collection. ``` {.cpp}; tree->Branch(*aCollection, 8000, 99);; // Int_t TTree::Branch(TCollection *list, Int_t ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:30693,simpl,simply,30693,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simply']
Usability,"100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimizat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62072,guid,guide,62072,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['guid'],['guide']
Usability,"2d to make it possible to use ROOT's; graphics on iOS devices (iPad, iPhone, iPod touch).; Among other things, it has the ROOT::iOS::Pad class, which is a version; of TPad for iOS (pad with TF2 example below). Two applications, based on this module, were developed for iOS (currently,; for iPad only): ""Tutorials"" and ""RootBrowser"".; They can be found in $ROOTSYS/test/ios. ""Tutorials"" app; Small application with several demos, ""iOS version"" of the $ROOTSYS/tutorlas/demos.C. ""Tutorials"" application:. supports portrait and landscape orientation; has several demos (can be selected by tapping on table's cells); supports different gestures (pinch, single and double tap, pan, etc. - active gestures are shown by hint icons); has ""zoom"" mode - pinch or double tap gesture will zoom in/out pad's contents; has ""selection"" mode - with single tap user can select different objects inside pad - axes, histograms, pavestats etc.; 3D objects can be rotated.; has a simple editor to modify pad's parameters : fill color, logarithmic scale, grid, ticks, etc. ""RootBrowser"" app; This application is a simplified version of TBrowser and TCanvas; for iOS. User can open ROOT's file (application uses TWebFile) and; browse file's contents.; RootBrower registers *.root file extension in a system, so for; example, attached root files from a mail client can be opened by; RootBrowser.; Application has several views. In a top level view, user can see; opened files, open new files, close files (long press gesture on; a file icon):. Tap gesture on a file's icon will open ""File contents"" view. This; view shows objects and nested directories. For objects small; previews are generated. Tapping on a directory's icon will open; new view with directory's contents. Simple search is supported; (in the current TDirectoryFile). Tap on a object's preview will open detailed view for this object.; Using pinch gesture or double tap, you can zoom in/zoom out pad's; contents.; If you have several objects in a file or dir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v532/index.html:2273,simpl,simple,2273,graf2d/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v532/index.html,1,['simpl'],['simple']
Usability,"32 = SUB32rr %6, %0, implicit-def $eflags, debug-location !5; JB_1 %bb.1, implicit $eflags, debug-location !5; JMP_1 %bb.2, debug-location !5. bb.2.bb2:; %8:gr32 = MOV32r0 implicit-def dead $eflags; $eax = COPY %8, debug-location !5; RET 0, $eax, debug-location !5. Observe first that there is a DBG_VALUE instruction for every ``llvm.dbg.value``; intrinsic in the source IR, ensuring no source level assignments go missing.; Then consider the different ways in which variable locations have been recorded:. * For the first dbg.value an immediate operand is used to record a zero value.; * The dbg.value of the PHI instruction leads to a DBG_VALUE of virtual register; ``%0``.; * The first GEP has its effect folded into the first load instruction; (as a 4-byte offset), but the variable location is salvaged by folding; the GEPs effect into the DIExpression.; * The second GEP is also folded into the corresponding load. However, it is; insufficiently simple to be salvaged, and is emitted as a ``$noreg``; DBG_VALUE, indicating that the variable takes on an undefined location.; * The final dbg.value has its Value placed in virtual register ``%1``. Instruction Scheduling; ----------------------. A number of passes can reschedule instructions, notably instruction selection; and the pre-and-post RA machine schedulers. Instruction scheduling can; significantly change the nature of the program -- in the (very unlikely) worst; case the instruction sequence could be completely reversed. In such; circumstances LLVM follows the principle applied to optimizations, that it is; better for the debugger not to display any state than a misleading state.; Thus, whenever instructions are advanced in order of execution, any; corresponding DBG_VALUE is kept in its original position, and if an instruction; is delayed then the variable is given an undefined location for the duration; of the delay. To illustrate, consider this pseudo-MIR:. .. code-block:: text. %1:gr32 = MOV32rm %0, 1, $noreg, 4, $nor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:32445,simpl,simple,32445,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['simpl'],['simple']
Usability,"4020e-02; root[] f1.Derivative(3); (Double_t)(-3.45675056671992330e-01); root[] f1.Integral(0,3); (Double_t)1.84865252799946810e+00; root[] f1.Draw(); ```. By default the method `TF1::Paint()`, that draws the function,; computes 100 equidistant points to draw it. The number of points can; be set to a higher value with:. ``` {.cpp}; root[] f1.SetNpx(2000);; ```. Note that while the ROOT framework is an object-oriented framework,; this does not prevent the user from calling plain functions. ### User Interaction. Now we will look at some interactive capabilities. Try to draw the; function `sin(x)/x` again. Every object in a window (which is called a; canvas) is, in fact, a graphical object in the sense that you can grab; it, resize it, and change its characteristics with a mouse click. For; example, bring the cursor over the x-axis. The cursor changes to a; hand with a pointing finger when it is over the axis. Now, left click; and drag the mouse along the axis to the right. You have a very simple; zoom. When you move the mouse over any object, you can get access to; selected methods by pressing the right mouse button and obtaining a; context menu. If you try this on the function **`TF1`**, you will get; a menu showing available methods. The other objects on this canvas are; the title, a **`TPaveText`** object`;` the x and y-axis, **`TAxis`**; objects, the frame, a **`TFrame`** object, and the canvas a; **`TCanvas `** object. Try clicking on these and observe the context; menu with their methods. ![A context menu](pictures/0300002A.png). For example try selecting the `SetRange()` method and putting `-10`,; `10` in the dialog box fields. This is equivalent to executing; `f1.SetRange(-10,10)` from the command line, followed by `f1.Draw()`.; Here are some other options you can try. Once the picture suits your wishes, you may want to see the code you; should put in a script to obtain the same result. To do that, choose; Save / `canvas.C` entry of the File menu. This will ge",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:20972,simpl,simple,20972,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['simpl'],['simple']
Usability,"5.4.3.3 Type Conversion Operations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. note::. This section is the same as DWARF Version 5 section 2.5.1.6. .. _amdgpu-dwarf-general-operations:. A.2.5.4.3.4 Special Value Operations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. note::. This section replaces parts of DWARF Version 5 sections 2.5.1.2, 2.5.1.3, and; 2.5.1.7. There are these special value operations currently defined:. 1. ``DW_OP_regval_type``. ``DW_OP_regval_type`` has two operands. The first is an unsigned LEB128; integer that represents a register number R. The second is an unsigned; LEB128 integer DR that represents the byte offset of a debugging information; entry D relative to the beginning of the current compilation unit, that; provides the type T of the register value. The operation is equivalent to performing ``DW_OP_regx R; DW_OP_deref_type; DR``. .. note::. Should DWARF allow the type T to be a larger size than the size of the; register R? Restricting a larger bit size avoids any issue of conversion; as the, possibly truncated, bit contents of the register is simply; interpreted as a value of T. If a conversion is wanted it can be done; explicitly using a ``DW_OP_convert`` operation. GDB has a per register hook that allows a target specific conversion on a; register by register basis. It defaults to truncation of bigger registers.; Removing use of the target hook does not cause any test failures in common; architectures. If the compiler for a target architecture did want some; form of conversion, including a larger result type, it could always; explicitly use the ``DW_OP_convert`` operation. If T is a larger type than the register size, then the default GDB; register hook reads bytes from the next register (or reads out of bounds; for the last register!). Removing use of the target hook does not cause; any test failures in common architectures (except an illegal hand written; assembly test). If a target architecture requires this behavior, these; extensions",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:87669,simpl,simply,87669,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simply']
Usability,"5sbHZtLndnQGdtYWlsLmNvbQ>`__; - `Meeting details/agenda <https://docs.google.com/document/d/1ivYDSn_5ChTeiZ7TiO64WC_jYJnGwAUiT9Ngi9cAdFU/edit?usp=sharing>`__; * - GlobalISel; - Every 2nd Tuesday of the month; - `gcal <https://calendar.google.com/calendar/u/0?cid=ZDcyMjc0ZjZiZjNhMzFlYmE3NTNkMWM2MGM2NjM5ZWU3ZDE2MjM4MGFlZDc2ZjViY2UyYzMwNzVhZjk4MzQ4ZEBncm91cC5jYWxlbmRhci5nb29nbGUuY29t>`__; - `Meeting details/agenda <https://docs.google.com/document/d/1Ry8O4-Tm5BFj9AMjr8qTQFU80z-ptiNQ62687NaIvLs/edit?usp=sharing>`__; * - Floating Point Working Group; - Every 3rd Wednesday of the month; - `gcal <https://calendar.google.com/calendar/u/0?cid=MDI1ODI1MDdiYWM3OWQxODY5MDA3MTI1NjZlYzNmYzY5YjMzYWMyNGQ3ZGUwYThjNzZjN2IxOTk3NmYxOTBjMEBncm91cC5jYWxlbmRhci5nb29nbGUuY29t>`__; - `Meeting details/agenda: <https://docs.google.com/document/d/1QcmUlWftPlBi-Wz6b6PipqJfvjpJ-OuRMRnN9Dm2t0c>`__. .. _office-hours:. Office hours; ------------. A number of experienced LLVM contributors make themselves available for a chat; on a regular schedule, to anyone who is looking for some guidance. Please find; the list of who is available when, through which medium, and what their area of; expertise is. Don't be too shy to dial in!. The :doc:`CodeOfConduct` applies to all office hours. Of course, people take time off from time to time, so if you dial in and you; don't find anyone present, chances are they happen to be off that day. .. list-table:: LLVM office hours; :widths: 15 40 15 15 15; :header-rows: 1. * - Name; - In-scope topics; - When?; - Where?; - Languages; * - Kristof Beyls; - General questions on how to contribute to LLVM; organizing meetups;; submitting talks; and other general LLVM-related topics. Arm/AArch64; codegen. LLVM security group. LLVM Office Hours.; - Every 2nd and 4th Wednesday of the month at 9.30am CET, for 30 minutes.; `ics <https://calendar.google.com/calendar/ical/co0h4ndpvtfe64opn7eraiq3ac%40group.calendar.google.com/public/basic.ics>`__; - `Jitsi <https://meet.jit.si/Kristof",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:10145,guid,guidance,10145,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['guid'],['guidance']
Usability,": ""-I"", Values: {""foo""}; Option 3 - Name: ""-I"", Values: {""foo""}; Option 4 - Name: ""<input>"", Values: {""t.c""}. After this stage is complete the command line should be broken down; into well defined option objects with their appropriate parameters.; Subsequent stages should rarely, if ever, need to do any string; processing. #. **Pipeline: Compilation Action Construction**. Once the arguments are parsed, the tree of subprocess jobs needed for; the desired compilation sequence are constructed. This involves; determining the input files and their types, what work is to be done; on them (preprocess, compile, assemble, link, etc.), and constructing; a list of Action instances for each task. The result is a list of one; or more top-level actions, each of which generally corresponds to a; single output (for example, an object or linked executable). The majority of Actions correspond to actual tasks, however there are; two special Actions. The first is InputAction, which simply serves to; adapt an input argument for use as an input to other Actions. The; second is BindArchAction, which conceptually alters the architecture; to be used for all of its input Actions. The clang driver can dump the results of this stage using the; ``-ccc-print-phases`` flag. For example:. .. code-block:: console. $ clang -ccc-print-phases -x c t.c -x assembler t.s; 0: input, ""t.c"", c; 1: preprocessor, {0}, cpp-output; 2: compiler, {1}, assembler; 3: assembler, {2}, object; 4: input, ""t.s"", assembler; 5: assembler, {4}, object; 6: linker, {3, 5}, image. Here the driver is constructing seven distinct actions, four to; compile the ""t.c"" input into an object file, two to assemble the; ""t.s"" input, and one to link them together. A rather different compilation pipeline is shown here; in this; example there are two top level actions to compile the input files; into two separate object files, where each object file is built using; ``lipo`` to merge results built for two separate architectures. .. code-blo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:6622,simpl,simply,6622,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['simpl'],['simply']
Usability,": If an LLVM subcomponent has a C API already; included, then expanding that C API is acceptable. Adding C API for; subcomponents that don't currently have one needs to be discussed on the; `LLVM Discourse forums`_ for design and maintainability feedback prior to implementation. * Documentation: Any changes to the C API are required to be documented in the; release notes so that it's clear to external users who do not follow the; project how the C API is changing and evolving. .. _toolchain:. Updating Toolchain Requirements; -------------------------------. We intend to require newer toolchains as time goes by. This means LLVM's; codebase can use newer versions of C++ as they get standardized. Requiring newer; toolchains to build LLVM can be painful for those building LLVM; therefore, it; will only be done through the following process:. * It is a general goal to support LLVM and GCC versions from the last 3 years; at a minimum. This time-based guideline is not strict: we may support much; older compilers, or decide to support fewer versions. * An RFC is sent to the `LLVM Discourse forums`_. - Detail upsides of the version increase (e.g. which newer C++ language or; library features LLVM should use; avoid miscompiles in particular compiler; versions, etc).; - Detail downsides on important platforms (e.g. Ubuntu LTS status). * Once the RFC reaches consensus, update the CMake toolchain version checks as; well as the :doc:`getting started<GettingStarted>` guide. This provides a; softer transition path for developers compiling LLVM, because the; error can be turned into a warning using a CMake flag. This is an important; step: LLVM still doesn't have code which requires the new toolchains, but it; soon will. If you compile LLVM but don't read the forums, we should; tell you!. * Ensure that at least one LLVM release has had this soft-error. Not all; developers compile LLVM top-of-tree. These release-bound developers should; also be told about upcoming changes. * Turn the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:34374,guid,guideline,34374,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['guid'],['guideline']
Usability,": c++. void InitializeModuleAndPassManager(void) {; // Open a new context and module.; TheContext = std::make_unique<LLVMContext>();; TheModule = std::make_unique<Module>(""my cool jit"", TheContext);; TheModule->setDataLayout(TheJIT->getDataLayout());. // Create a new builder for the module.; Builder = std::make_unique<IRBuilder<>>(*TheContext);. // Create a new pass manager attached to it.; TheFPM = std::make_unique<legacy::FunctionPassManager>(TheModule.get());; ... The KaleidoscopeJIT class is a simple JIT built specifically for these; tutorials, available inside the LLVM source code; at `llvm-src/examples/Kaleidoscope/include/KaleidoscopeJIT.h; <https://github.com/llvm/llvm-project/blob/main/llvm/examples/Kaleidoscope/include/KaleidoscopeJIT.h>`_.; In later chapters we will look at how it works and extend it with; new features, but for now we will take it as given. Its API is very simple:; ``addModule`` adds an LLVM IR module to the JIT, making its functions; available for execution (with its memory managed by a ``ResourceTracker``); and; ``lookup`` allows us to look up pointers to the compiled code. We can take this simple API and change our code that parses top-level expressions to; look like this:. .. code-block:: c++. static ExitOnError ExitOnErr;; ...; static void HandleTopLevelExpression() {; // Evaluate a top-level expression into an anonymous function.; if (auto FnAST = ParseTopLevelExpr()) {; if (FnAST->codegen()) {; // Create a ResourceTracker to track JIT'd memory allocated to our; // anonymous expression -- that way we can free it after executing.; auto RT = TheJIT->getMainJITDylib().createResourceTracker();. auto TSM = ThreadSafeModule(std::move(TheModule), std::move(TheContext));; ExitOnErr(TheJIT->addModule(std::move(TSM), RT));; InitializeModuleAndPassManager();. // Search the JIT for the __anon_expr symbol.; auto ExprSymbol = ExitOnErr(TheJIT->lookup(""__anon_expr""));; assert(ExprSymbol && ""Function not found"");. // Get the symbol's address and ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:12235,simpl,simple,12235,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['simpl'],['simple']
Usability,": int}; HotPatchTableOffset: {type: int}; EnclaveConfigurationPointer: {type: int}; VolatileMetadataPointer: {type: int}; GuardEHContinuationTable: {type: int}; GuardEHContinuationCount: {type: int}; GuardXFGCheckFunctionPointer: {type: int}; GuardXFGDispatchFunctionPointer: {type: int}; GuardXFGTableDispatchFunctionPointer: {type: int}; CastGuardOsDeterminedFailureMode: {type: int}. symbols:; - Name: .text; Value: 0; SectionNumber: 1; SimpleType: IMAGE_SYM_TYPE_NULL # (0); ComplexType: IMAGE_SYM_DTYPE_NULL # (0); StorageClass: IMAGE_SYM_CLASS_STATIC # (3); NumberOfAuxSymbols: 1; AuxiliaryData:; ""\x24\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00"" # |$.................|. - Name: _main; Value: 0; SectionNumber: 1; SimpleType: IMAGE_SYM_TYPE_NULL # (0); ComplexType: IMAGE_SYM_DTYPE_NULL # (0); StorageClass: IMAGE_SYM_CLASS_EXTERNAL # (2). Here's a simplified Kwalify_ schema with an extension to allow alternate types. .. _Kwalify: http://www.kuwata-lab.com/kwalify/ruby/users-guide.html. .. code-block:: yaml. type: map; mapping:; header:; type: map; mapping:; Machine: [ {type: str, enum:; [ IMAGE_FILE_MACHINE_UNKNOWN; , IMAGE_FILE_MACHINE_AM33; , IMAGE_FILE_MACHINE_AMD64; , IMAGE_FILE_MACHINE_ARM; , IMAGE_FILE_MACHINE_ARMNT; , IMAGE_FILE_MACHINE_ARM64; , IMAGE_FILE_MACHINE_EBC; , IMAGE_FILE_MACHINE_I386; , IMAGE_FILE_MACHINE_IA64; , IMAGE_FILE_MACHINE_M32R; , IMAGE_FILE_MACHINE_MIPS16; , IMAGE_FILE_MACHINE_MIPSFPU; , IMAGE_FILE_MACHINE_MIPSFPU16; , IMAGE_FILE_MACHINE_POWERPC; , IMAGE_FILE_MACHINE_POWERPCFP; , IMAGE_FILE_MACHINE_R4000; , IMAGE_FILE_MACHINE_SH3; , IMAGE_FILE_MACHINE_SH3DSP; , IMAGE_FILE_MACHINE_SH4; , IMAGE_FILE_MACHINE_SH5; , IMAGE_FILE_MACHINE_THUMB; , IMAGE_FILE_MACHINE_WCEMIPSV2; ]}; , {type: int}; ]; Characteristics:; - type: seq; sequence:; - type: str; enum: [ IMAGE_FILE_RELOCS_STRIPPED; , IMAGE_FILE_EXECUTABLE_IMAGE; , IMAGE_FILE_LINE_NUMS_STRIPPED; , IMAGE_FILE_LOCAL_SYMS_STRIPPED; , IMAGE_FILE_AGGRESSIVE_WS_TRIM; , IMAGE_FIL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/yaml2obj.rst:3179,guid,guide,3179,interpreter/llvm-project/llvm/docs/yaml2obj.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/yaml2obj.rst,1,['guid'],['guide']
Usability,":"");; ExitOnErr.setExitCodeMapper(; [](const Error &Err) {; if (Err.isA<BadFileFormat>()); return 2;; return 1;; });. Use ``ExitOnError`` in your tool code where possible as it can greatly improve; readability. .. _err_cantfail:. Using cantFail to simplify safe callsites; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Some functions may only fail for a subset of their inputs, so calls using known; safe inputs can be assumed to succeed. The cantFail functions encapsulate this by wrapping an assertion that their; argument is a success value and, in the case of Expected<T>, unwrapping the; T value:. .. code-block:: c++. Error onlyFailsForSomeXValues(int X);; Expected<int> onlyFailsForSomeXValues2(int X);. void foo() {; cantFail(onlyFailsForSomeXValues(KnownSafeValue));; int Y = cantFail(onlyFailsForSomeXValues2(KnownSafeValue));; ...; }. Like the ExitOnError utility, cantFail simplifies control flow. Their treatment; of error cases is very different however: Where ExitOnError is guaranteed to; terminate the program on an error input, cantFail simply asserts that the result; is success. In debug builds this will result in an assertion failure if an error; is encountered. In release builds the behavior of cantFail for failure values is; undefined. As such, care must be taken in the use of cantFail: clients must be; certain that a cantFail wrapped call really can not fail with the given; arguments. Use of the cantFail functions should be rare in library code, but they are; likely to be of more use in tool and unit-test code where inputs and/or; mocked-up classes or functions may be known to be safe. Fallible constructors; """""""""""""""""""""""""""""""""""""""""". Some classes require resource acquisition or other complex initialization that; can fail during construction. Unfortunately constructors can't return errors,; and having clients test objects after they're constructed to ensure that they're; valid is error prone as it's all too easy to forget the test. To work around; this, use the named",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:32850,simpl,simply,32850,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simply']
Usability,":. .. code-block:: text. refs: ((Ref)[, (Ref)]*). where each ``Ref`` contains a reference to the summary id of the referenced; value (e.g. ``^1``). .. _typeidinfo_summary:. TypeIdInfo; ^^^^^^^^^^. The optional ``TypeIdInfo`` field, used for; `Control Flow Integrity <https://clang.llvm.org/docs/ControlFlowIntegrity.html>`_,; looks like:. .. code-block:: text. typeIdInfo: [(TypeTests)]?[, (TypeTestAssumeVCalls)]?[, (TypeCheckedLoadVCalls)]?[, (TypeTestAssumeConstVCalls)]?[, (TypeCheckedLoadConstVCalls)]?. These optional fields have the following forms:. TypeTests; """""""""""""""""". .. code-block:: text. typeTests: (TypeIdRef[, TypeIdRef]*). Where each ``TypeIdRef`` refers to a :ref:`type id<typeid_summary>`; by summary id or ``GUID``. TypeTestAssumeVCalls; """""""""""""""""""""""""""""""""""""""". .. code-block:: text. typeTestAssumeVCalls: (VFuncId[, VFuncId]*). Where each VFuncId has the format:. .. code-block:: text. vFuncId: (TypeIdRef, offset: 16). Where each ``TypeIdRef`` refers to a :ref:`type id<typeid_summary>`; by summary id or ``GUID`` preceded by a ``guid:`` tag. TypeCheckedLoadVCalls; """""""""""""""""""""""""""""""""""""""""". .. code-block:: text. typeCheckedLoadVCalls: (VFuncId[, VFuncId]*). Where each VFuncId has the format described for ``TypeTestAssumeVCalls``. TypeTestAssumeConstVCalls; """""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: text. typeTestAssumeConstVCalls: (ConstVCall[, ConstVCall]*). Where each ConstVCall has the format:. .. code-block:: text. (VFuncId, args: (Arg[, Arg]*)). and where each VFuncId has the format described for ``TypeTestAssumeVCalls``,; and each Arg is an integer argument number. TypeCheckedLoadConstVCalls; """""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: text. typeCheckedLoadConstVCalls: (ConstVCall[, ConstVCall]*). Where each ConstVCall has the format described for; ``TypeTestAssumeConstVCalls``. .. _typeid_summary:. Type ID Summary Entry; ---------------------. Each type id summary entry corresponds to a type identifier resolution; which is generated during the LTO link porti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:347563,guid,guid,347563,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['guid'],['guid']
Usability,":. Formatting strings (the ``formatv`` function); ---------------------------------------------; While LLVM doesn't necessarily do a lot of string manipulation and parsing, it; does do a lot of string formatting. From diagnostic messages, to llvm tool; outputs such as ``llvm-readobj`` to printing verbose disassembly listings and; LLDB runtime logging, the need for string formatting is pervasive. The ``formatv`` is similar in spirit to ``printf``, but uses a different syntax; which borrows heavily from Python and C#. Unlike ``printf`` it deduces the type; to be formatted at compile time, so it does not need a format specifier such as; ``%d``. This reduces the mental overhead of trying to construct portable format; strings, especially for platform-specific types like ``size_t`` or pointer types.; Unlike both ``printf`` and Python, it additionally fails to compile if LLVM does; not know how to format the type. These two properties ensure that the function; is both safer and simpler to use than traditional formatting methods such as; the ``printf`` family of functions. Simple formatting; ^^^^^^^^^^^^^^^^^. A call to ``formatv`` involves a single **format string** consisting of 0 or more; **replacement sequences**, followed by a variable length list of **replacement values**.; A replacement sequence is a string of the form ``{N[[,align]:style]}``. ``N`` refers to the 0-based index of the argument from the list of replacement; values. Note that this means it is possible to reference the same parameter; multiple times, possibly with different style and/or alignment options, in any order. ``align`` is an optional string specifying the width of the field to format; the value into, and the alignment of the value within the field. It is specified as; an optional **alignment style** followed by a positive integral **field width**. The; alignment style can be one of the characters ``-`` (left align), ``=`` (center align),; or ``+`` (right align). The default is right aligned. ``s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:12119,simpl,simpler,12119,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simpler']
Usability,":. declare void @llvm.coro.destroy(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.destroy``' intrinsic destroys a suspended; switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a coroutine handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.destroy` intrinsic is replaced with a direct call to; the coroutine destroy function. Otherwise it is replaced with an indirect call; based on the function pointer for the destroy function stored in the coroutine; frame. Destroying a coroutine that is not suspended leads to undefined behavior. .. _coro.resume:. 'llvm.coro.resume' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare void @llvm.coro.resume(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.resume``' intrinsic resumes a suspended switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.resume` intrinsic is replaced with a direct call to the; coroutine resume function. Otherwise it is replaced with an indirect call based; on the function pointer for the resume function stored in the coroutine frame.; Resuming a coroutine that is not suspended leads to undefined behavior. .. _coro.done:. 'llvm.coro.done' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare i1 @llvm.coro.done(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.done``' intrinsic checks whether a suspended; switched-resume coroutine is at the final suspend point or not. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". Using this intrinsic on a coroutine that does not have a `final suspend`_ point; or on a coroutine that is not suspended leads to undefined behavior. .. _coro.promise:. 'llvm.coro.promise' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare ptr @llvm.coro.promise(ptr <ptr>, i32 <alignment>, i1 <from>). Overview:; """""""""""""""""". The '``llvm.coro.promise``' intr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:28077,resume,resume,28077,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,2,['resume'],['resume']
Usability,":. double %test3(bool %B) {; %C = select bool %B, double 123.412, double 523.01123123; ret double %C; }. Currently, the select is being lowered, which prevents the dag combiner from; turning 'select (load CPI1), (load CPI2)' -> 'load (select CPI1, CPI2)'. The pattern isel got this one right. //===---------------------------------------------------------------------===//. Lower memcpy / memset to a series of SSE 128 bit move instructions when it's; feasible. //===---------------------------------------------------------------------===//. Codegen:; if (copysign(1.0, x) == copysign(1.0, y)); into:; if (x^y & mask); when using SSE. //===---------------------------------------------------------------------===//. Use movhps to update upper 64-bits of a v4sf value. Also movlps on lower half; of a v4sf value. //===---------------------------------------------------------------------===//. Better codegen for vector_shuffles like this { x, 0, 0, 0 } or { x, 0, x, 0}.; Perhaps use pxor / xorp* to clear a XMM register first?. //===---------------------------------------------------------------------===//. External test Nurbs exposed some problems. Look for; __ZN15Nurbs_SSE_Cubic17TessellateSurfaceE, bb cond_next140. This is what icc; emits:. movaps (%edx), %xmm2 #59.21; movaps (%edx), %xmm5 #60.21; movaps (%edx), %xmm4 #61.21; movaps (%edx), %xmm3 #62.21; movl 40(%ecx), %ebp #69.49; shufps $0, %xmm2, %xmm5 #60.21; movl 100(%esp), %ebx #69.20; movl (%ebx), %edi #69.20; imull %ebp, %edi #69.49; addl (%eax), %edi #70.33; shufps $85, %xmm2, %xmm4 #61.21; shufps $170, %xmm2, %xmm3 #62.21; shufps $255, %xmm2, %xmm2 #63.21; lea (%ebp,%ebp,2), %ebx #69.49; negl %ebx #69.49; lea -3(%edi,%ebx), %ebx #70.33; shll $4, %ebx #68.37; addl 32(%ecx), %ebx #68.37; testb $15, %bl #91.13; jne L_B1.24 # Prob 5% #91.13. This is the llvm code after instruction scheduling:. cond_next140 (0xa910740, LLVM BB @0xa90beb0):; 	%reg1078 = MOV32ri -3; 	%reg1079 = ADD32rm %reg1078, %reg1068, 1, %noreg, 0; 	%re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt:3588,clear,clear,3588,interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,1,['clear'],['clear']
Usability,"::createJITDylib`` method with a unique name:. .. code-block:: c++. ExecutionSession ES;; auto &JD = ES.createJITDylib(""libFoo.dylib"");. The JITDylib is owned by the ``ExecutionEngine`` instance and will be freed; when it is destroyed. How to remove code; ------------------. To remove an individual module from a JITDylib it must first be added using an; explicit ``ResourceTracker``. The module can then be removed by calling; ``ResourceTracker::remove``:. .. code-block:: c++. auto &JD = ... ;; auto M = ... ;. auto RT = JD.createResourceTracker();; Layer.add(RT, std::move(M)); // Add M to JD, tracking resources with RT. RT.remove(); // Remove M from JD. Modules added directly to a JITDylib will be tracked by that JITDylib's default; resource tracker. All code can be removed from a JITDylib by calling ``JITDylib::clear``. This; leaves the cleared JITDylib in an empty but usable state. JITDylibs can be removed by calling ``ExecutionSession::removeJITDylib``. This; clears the JITDylib and then puts it into a defunct state. No further operations; can be performed on the JITDylib, and it will be destroyed as soon as the last; handle to it is released. An example of how to use the resource management APIs can be found at; ``llvm/examples/OrcV2Examples/LLJITRemovableCode``. How to add the support for custom program representation; --------------------------------------------------------; In order to add the support for a custom program representation, a custom ``MaterializationUnit``; for the program representation, and a custom ``Layer`` are needed. The Layer will have two; operations: ``add`` and ``emit``. The ``add`` operation takes an instance of your program; representation, builds one of your custom ``MaterializationUnits`` to hold it, then adds it; to a ``JITDylib``. The emit operation takes a ``MaterializationResponsibility`` object and an; instance of your program representation and materializes it, usually by compiling it and handing; the resulting object off to an ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:24258,clear,clears,24258,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['clear'],['clears']
Usability,"::vector<std::unique_ptr<ExprAST>> Args;; if (CurTok != ')') {; while (true) {; if (auto Arg = ParseExpression()); Args.push_back(std::move(Arg));; else; return nullptr;. if (CurTok == ')'); break;. if (CurTok != ','); return LogError(""Expected ')' or ',' in argument list"");; getNextToken();; }; }. // Eat the ')'.; getNextToken();. return std::make_unique<CallExprAST>(IdName, std::move(Args));; }. This routine follows the same style as the other routines. (It expects; to be called if the current token is a ``tok_identifier`` token). It; also has recursion and error handling. One interesting aspect of this is; that it uses *look-ahead* to determine if the current identifier is a; stand alone variable reference or if it is a function call expression.; It handles this by checking to see if the token after the identifier is; a '(' token, constructing either a ``VariableExprAST`` or; ``CallExprAST`` node as appropriate. Now that we have all of our simple expression-parsing logic in place, we; can define a helper function to wrap it together into one entry point.; We call this class of expressions ""primary"" expressions, for reasons; that will become more clear `later in the; tutorial <LangImpl06.html#user-defined-unary-operators>`_. In order to parse an arbitrary; primary expression, we need to determine what sort of expression it is:. .. code-block:: c++. /// primary; /// ::= identifierexpr; /// ::= numberexpr; /// ::= parenexpr; static std::unique_ptr<ExprAST> ParsePrimary() {; switch (CurTok) {; default:; return LogError(""unknown token when expecting an expression"");; case tok_identifier:; return ParseIdentifierExpr();; case tok_number:; return ParseNumberExpr();; case '(':; return ParseParenExpr();; }; }. Now that you see the definition of this function, it is more obvious why; we can assume the state of CurTok in the various functions. This uses; look-ahead to determine which sort of expression is being inspected, and; then parses it with a function call. Now that bas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:10910,simpl,simple,10910,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['simpl'],['simple']
Usability,"; 	%tmp614615 = sext i16 %tmp101 to i32		; <i32> [#uses=1]; 	%tmp621622 = sext i16 %tmp104 to i32		; <i32> [#uses=1]; 	%tmp623 = sub i32 32, %tmp621622		; <i32> [#uses=1]; 	br label %bb114. produces:. LBB3_5:	# bb114.preheader; 	movswl	-68(%ebp), %eax; 	movl	$32, %ecx; 	movl	%ecx, -80(%ebp); 	subl	%eax, -80(%ebp); 	movswl	-52(%ebp), %eax; 	movl	%ecx, -84(%ebp); 	subl	%eax, -84(%ebp); 	movswl	-70(%ebp), %eax; 	movl	%ecx, -88(%ebp); 	subl	%eax, -88(%ebp); 	movswl	-50(%ebp), %eax; 	subl	%eax, %ecx; 	movl	%ecx, -76(%ebp); 	movswl	-42(%ebp), %eax; 	movl	%eax, -92(%ebp); 	movswl	-66(%ebp), %eax; 	movl	%eax, -96(%ebp); 	movw	$0, -98(%ebp). This appears to be bad because the RA is not folding the store to the stack ; slot into the movl. The above instructions could be:; 	movl $32, -80(%ebp); ...; 	movl $32, -84(%ebp); ...; This seems like a cross between remat and spill folding. This has redundant subtractions of %eax from a stack slot. However, %ecx doesn't; change, so we could simply subtract %eax from %ecx first and then use %ecx (or; vice-versa). //===---------------------------------------------------------------------===//. This code:. 	%tmp659 = icmp slt i16 %tmp654, 0		; <i1> [#uses=1]; 	br i1 %tmp659, label %cond_true662, label %cond_next715. produces this:. 	testw	%cx, %cx; 	movswl	%cx, %esi; 	jns	LBB4_109	# cond_next715. Shark tells us that using %cx in the testw instruction is sub-optimal. It; suggests using the 32-bit register (which is what ICC uses). //===---------------------------------------------------------------------===//. We compile this:. void compare (long long foo) {; if (foo < 4294967297LL); abort();; }. to:. compare:; subl $4, %esp; cmpl $0, 8(%esp); setne %al; movzbw %al, %ax; cmpl $1, 12(%esp); setg %cl; movzbw %cl, %cx; cmove %ax, %cx; testb $1, %cl; jne .LBB1_2 # UnifiedReturnBlock; .LBB1_1: # ifthen; call abort; .LBB1_2: # UnifiedReturnBlock; addl $4, %esp; ret. (also really horrible code on ppc). This is due to the expand code for 64-bit; c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:16615,simpl,simply,16615,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['simpl'],['simply']
Usability,"; ![Editors for shapes, materials, media, matrices](pictures/020001F1.jpg); ![Editors for shapes, materials, media, matrices](pictures/020001F2.jpg); ![Editors for shapes, materials, media, matrices](pictures/020001F3.jpg); ![Editors for shapes, materials, media, matrices](pictures/030001F4.png). For most editors, the functionalities Apply and Undo are provided. For shapes, changing any of the shape parameters will activate the; ""*Apply*"" button only if the check button ""*Delayed draw*"" is checked,; otherwise the changes are immediately applied. Once the apply button is; pressed, the changes are applied to the edited shape and drawn. The; ""*Undo*"" button becomes active after the first modification has been; applied. It allows restoring the initial parameters of the shape. NOTE: In this version the ""*Undo*"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:171187,undo,undoable,171187,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['undo'],['undoable']
Usability,"; # Foreword #. ## What M is intended to do ##. M is conceived as a tool to find the minimum value of a multi-parameter; function (the ""$\mbox{FCN}$"") and analyze the shape of the function; around the minimum. The principal application is foreseen for; statistical analysis, working on chisquare or log-likelihood functions,; to compute the best-fit parameter values and uncertainties, including; correlations between the parameters. It is especially suited to handle; difficult problems, including those which may require guidance in order; to find the correct solution. ## What M is not intended to do ##. Although M will of course solve easy problems faster than complicated; ones, it is not intended for the repeated solution of identically; parametrized problems (such as track fitting in a detector) where a; specialized program will in general be much more efficient. ## Further remarks ##. M was initially written in Fortran around 1975-1980 at CERN by Fred; James @bib-MINUIT. Its main field of usage is statistical data analysis; of experimental data recorded at CERN, but it is also used by people; doing data analysis outside CERN or outside high energy physics (HEP).; In 2002 Fred James started a project aiming to re-implement M in an; object-oriented way using . More information about recent developments, releases and installation; can be obtained from the M homepage @bib-C++MINUIT. The names of M applications are written in capital letters (e.g.; $\mbox{MIGRAD}$, $\mbox{MINOS}$, $\mbox{CONTOURS}$), the; corresponding names of the classes are written using sans-serif font; type (MnMigrad, MnMinos, MnContours). # Introduction: M basic concepts #. [sec:intro]. ## The organization of M ##. The M package acts on a multiparameter *objective function* which is; called — for historical reasons — the $\mbox{FCN}$ function (see; [howto:fcn]). This function is usually a chisquared or a log–likelihood,; but it could also be a mathematical function. The $\mbox{FCN}$; function needs ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:523,guid,guidance,523,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['guid'],['guidance']
Usability,"; * - `Compiler Research - Calling C++ libraries from a D-written DSL: A cling/cppyy-based approach <https://www.youtube.com/watch?v=7teqrCNzrD8>`_; - *Alexandru Militaru* 2021 Compiler-Research Meeting; - This video presents D and C++ interoperability through SIL-Cling architecture. .. list-table:: Interactive CUDA C++ with Cling:; :widths: 25 25 50; :header-rows: 1. * - Link; - Info ; - Description; * - `Adding CUDA® Support to Cling: JIT Compile to GPUs <https://www.youtube.com/watch?v=XjjZRhiFDVs>`_; - *Simeon Ehrig* 2020 LLVM Developer Meeting; - Interactive CUDA-C++ through Cling is presented. Cling-CUDA architecture is discussed in detail, and an example of interactive simulation for laser plasma applications is shown. . .. list-table:: C++ in Jupyter Notebook - Xeus Cling:; :widths: 25 25 50; :header-rows: 1; ; * - Link; - Info ; - Description; * - `Interactive C++ code development using C++Explorer and GitHub Classroom for educational purposes <https://www.youtube.com/watch?v=HBgF2Yr0foA>`_; - *Patrick Diehl* 2020 Youtube; - C++Explorer is a novel teaching environment based on Jupyterhub and Cling, adapted to teaching C++ programming and source code management.; * - `Deep dive into the Xeus-based Cling kernel for Jupyter <https://www.youtube.com/watch?v=kx3wvKk4Qss>`_; - *Vassil Vassilev* 2021 Youtube; - Xeus-Cling is a Cling-based notebook kernel which delivers interactive C++. ; * - `Xeus-Cling: Run C++ code in Jupyter Notebook <https://www.youtube.com/watch?v=4fcKlJ_5QQk>`_ ; - *LearnOpenCV* 2019 Youtube; - In this demo, you will learn an example of C++ code in Jupyter Notebook using Xeus-Cling kernel. . .. list-table:: Clad:; :widths: 25 25 50; :header-rows: 1; ; * - Link; - Info ; - Description; * - `Clad: Automatic differentiation plugin for C++ <https://clad.readthedocs.io/en/latest/index.html>`_ ; - Read The Docs webpage; - Clad is a plugin for Cling. It allows to perform Automatic Differentiation (AD) on multivariate functions and functor objects. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst:7419,learn,learn,7419,interpreter/cling/docs/chapters/references.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst,1,['learn'],['learn']
Usability,"; -----------------------. The storage layout of raw profile data format is illustrated below. Basically,; when the raw profile is read into an memory buffer, the actual byte offset of a; section is inferred from the section's order in the layout and size information; of all the sections ahead of it. ::. +----+-----------------------+; | | Magic |; | +-----------------------+; | | Version |; | +-----------------------+; H | Size Info for |; E | Section 1 |; A +-----------------------+; D | Size Info for |; E | Section 2 |; R +-----------------------+; | | ... |; | +-----------------------+; | | Size Info for |; | | Section N |; +----+-----------------------+; P | Section 1 |; A +-----------------------+; Y | Section 2 |; L +-----------------------+; O | ... |; A +-----------------------+; D | Section N |; +----+-----------------------+. .. note::; Sections might be padded to meet specific alignment requirements. For; simplicity, header fields and data sections solely for padding purpose are; omitted in the data layout graph above and the rest of this document. Header; -------. ``Magic``; Magic number encodes profile format (raw, indexed or text). For the raw format,; the magic number also encodes the endianness (big or little) and C pointer; size (4 or 8 bytes) of the platform on which the profile is generated. A factory method reads the magic number to construct reader properly and returns; error upon unrecognized format. Specifically, the factory method and raw profile; reader implementation make sure that a raw profile file could be read back on; a platform with the opposite endianness and/or the other C pointer size. ``Version``; The lower 32 bits specify the actual version and the most significant 32 bits; specify the variant types of the profile. IR-based instrumentation PGO and; context-sensitive IR-based instrumentation PGO are two variant types. ``BinaryIdsSize``; The byte size of `binary id`_ section. ``NumData``; The number of profile metadata. The byte si",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrProfileFormat.rst:2758,simpl,simplicity,2758,interpreter/llvm-project/llvm/docs/InstrProfileFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrProfileFormat.rst,1,['simpl'],['simplicity']
Usability,"; -------------------. .. note::. To Be Written. Instruction Alias Processing; ----------------------------. Once the instruction is parsed, it enters the MatchInstructionImpl function.; The MatchInstructionImpl function performs alias processing and then does actual; matching. Alias processing is the phase that canonicalizes different lexical forms of the; same instructions down to one representation. There are several different kinds; of alias that are possible to implement and they are listed below in the order; that they are processed (which is in order from simplest/weakest to most; complex/powerful). Generally you want to use the first alias mechanism that; meets the needs of your instruction, because it will allow a more concise; description. Mnemonic Aliases; ^^^^^^^^^^^^^^^^. The first phase of alias processing is simple instruction mnemonic remapping for; classes of instructions which are allowed with two different mnemonics. This; phase is a simple and unconditionally remapping from one input mnemonic to one; output mnemonic. It isn't possible for this form of alias to look at the; operands at all, so the remapping must apply for all forms of a given mnemonic.; Mnemonic aliases are defined simply, for example X86 has:. ::. def : MnemonicAlias<""cbw"", ""cbtw"">;; def : MnemonicAlias<""smovq"", ""movsq"">;; def : MnemonicAlias<""fldcww"", ""fldcw"">;; def : MnemonicAlias<""fucompi"", ""fucomip"">;; def : MnemonicAlias<""ud2a"", ""ud2"">;. ... and many others. With a MnemonicAlias definition, the mnemonic is remapped; simply and directly. Though MnemonicAlias's can't look at any aspect of the; instruction (such as the operands) they can depend on global modes (the same; ones supported by the matcher), through a Requires clause:. ::. def : MnemonicAlias<""pushf"", ""pushfq"">, Requires<[In64BitMode]>;; def : MnemonicAlias<""pushf"", ""pushfl"">, Requires<[In32BitMode]>;. In this example, the mnemonic gets mapped into a different one depending on; the current instruction set. Instruction",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:82321,simpl,simple,82321,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"; .. _instructionselect:. InstructionSelect; -----------------. This pass transforms generic machine instructions into equivalent; target-specific instructions. It traverses the ``MachineFunction`` bottom-up,; selecting uses before definitions, enabling trivial dead code elimination. .. _api-instructionselector:. API: InstructionSelector; ^^^^^^^^^^^^^^^^^^^^^^^^. The target implements the ``InstructionSelector`` class, containing the; target-specific selection logic proper. The instance is provided by the subtarget, so that it can specialize the; selector by subtarget feature (with, e.g., a vector selector overriding parts; of a general-purpose common selector).; We might also want to parameterize it by MachineFunction, to enable selector; variants based on function attributes like optsize. The simple API consists of:. .. code-block:: c++. virtual bool select(MachineInstr &MI). This target-provided method is responsible for mutating (or replacing) a; possibly-generic MI into a fully target-specific equivalent.; It is also responsible for doing the necessary constraining of gvregs into the; appropriate register classes as well as passing through COPY instructions to; the register allocator. The ``InstructionSelector`` can fold other instructions into the selected MI,; by walking the use-def chain of the vreg operands.; As GlobalISel is Global, this folding can occur across basic blocks. SelectionDAG Rule Imports; ^^^^^^^^^^^^^^^^^^^^^^^^^. TableGen will import SelectionDAG rules and provide the following function to; execute them:. .. code-block:: c++. bool selectImpl(MachineInstr &MI). The ``--stats`` option can be used to determine what proportion of rules were; successfully imported. The easiest way to use this is to copy the; ``-gen-globalisel`` tablegen command from ``ninja -v`` and modify it. Similarly, the ``--warn-on-skipped-patterns`` option can be used to obtain the; reasons that rules weren't imported. This can be used to focus on the most; important rejec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/InstructionSelect.rst:807,simpl,simple,807,interpreter/llvm-project/llvm/docs/GlobalISel/InstructionSelect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/InstructionSelect.rst,1,['simpl'],['simple']
Usability,"; === TextInput. = Purpose. Read and edit text lines, and write what was read. This library is a simplistic alternative to readline / editline. It offers; less functionality but it has a more liberal license (see LICENSE.TXT in; the topmost) directory, it has no external dependencies, and it works on; all platforms that I tested:; - Linux; - Windows (probably >= 2000); - MacOS; - Solaris; Adding other platforms is trivial. = Internal Design. TextInput.h contains the main interface. The reading can be extended by; adding classes that derive from Reader; the displaying can be extended; by deriving from Display. There can be multiple readers and multiple displays. All displays are; equal, all readers are equal. All displays show the input of all; readers. The terminal / console implementations for readers and; displays are provided. Both readers and displays only attach while; textinput is acively reading input. As soon as the input is done (enter; was pressed), they detach from the terminal, allowing the application; to take control of the terminal, and even to crash without leaving the; terminal in a non-default state. The editor provides basic emacs-like keybinding, as known from e.g.; bash. It supports ^O, ^R (for now without regex), and most word-centric; editing commands. See KeyBinding for details. KeyBinding maps the InputData read from the Reader to Editor::Commands.; The Editor performs the requested editing actions, and the Displays; are informed about the changes. TextInput gives access to the read; state (""are we done?"") and the input. = Why no [N]Curses?. Because of platform independence (well, one could still have a; TerminalDisplayCurses) and because nowadays this is actually rarely; needed. Sure, it's the ""right"" way of interfacing terminals. But the; number of terminal types in the wild has siginifantly decreased, so; just hard-coding escape sequences became a viable alternative. = References. These pages helped when writing libtextinput:; http://tldp.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/doc/textinput.txt:97,simpl,simplistic,97,core/textinput/src/textinput/doc/textinput.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/doc/textinput.txt,1,['simpl'],['simplistic']
Usability,"; CHECK-LABEL: C_ctor_base:; ; CHECK: mov [[SAVETHIS:r[0-9]+]], r0; ; CHECK: bl A_ctor_base; ; CHECK: mov r0, [[SAVETHIS]]; %0 = bitcast %struct.C* %this to %struct.A*; %call = tail call %struct.A* @A_ctor_base(%struct.A* %0); %1 = bitcast %struct.C* %this to %struct.B*; %call2 = tail call %struct.B* @B_ctor_base(%struct.B* %1, i32 %x); ret %struct.C* %this; }. define %struct.D* @D_ctor_base(%struct.D* %this, i32 %x) {; entry:; ; CHECK-LABEL: D_ctor_base:. The use of ``CHECK-LABEL:`` directives in this case ensures that the three; ``CHECK:`` directives only accept lines corresponding to the body of the; ``@C_ctor_base`` function, even if the patterns match lines found later in; the file. Furthermore, if one of these three ``CHECK:`` directives fail,; FileCheck will recover by continuing to the next block, allowing multiple test; failures to be detected in a single invocation. There is no requirement that ``CHECK-LABEL:`` directives contain strings that; correspond to actual syntactic labels in a source or output language: they must; simply uniquely match a single line in the file being verified. ``CHECK-LABEL:`` directives cannot contain variable definitions or uses. Directive modifiers; ~~~~~~~~~~~~~~~~~~~. A directive modifier can be append to a directive by following the directive; with ``{<modifier>}`` where the only supported value for ``<modifier>`` is; ``LITERAL``. The ``LITERAL`` directive modifier can be used to perform a literal match. The; modifier results in the directive not recognizing any syntax to perform regex; matching, variable capture or any substitutions. This is useful when the text; to match would require excessive escaping otherwise. For example, the; following will perform literal matches rather than considering these as; regular expressions:. .. code-block:: text. Input: [[[10, 20]], [[30, 40]]]; Output %r10: [[10, 20]]; Output %r10: [[30, 40]]. ; CHECK{LITERAL}: [[[10, 20]], [[30, 40]]]; ; CHECK-DAG{LITERAL}: [[30, 40]]; ; CHECK-DAG{LITERA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:23580,simpl,simply,23580,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['simpl'],['simply']
Usability,"; Design doc for a redesign of the Bugpoint tool. :doc:`Proposals/TestSuite`; Proposals for additional benchmarks/programs for llvm's test-suite. :doc:`Proposals/VariableNames`; Proposal to change the variable names coding standard. :doc:`Proposals/VectorPredication`; Proposal for predicated vector instructions in LLVM. .. _llvm-community-calendar:. LLVM community calendar; -----------------------. We aim to maintain a public calendar view of all events happening in the LLVM; community such as :ref:`online-sync-ups` and :ref:`office-hours`. The calendar; can be found at; https://calendar.google.com/calendar/u/0/embed?src=calendar@llvm.org and can; also be seen inline below:. .. raw:: html. <iframe src=""https://calendar.google.com/calendar/embed?height=600&wkst=1&bgcolor=%23ffffff&ctz=UTC&showCalendars=0&showDate=1&showNav=1&src=Y2FsZW5kYXJAbGx2bS5vcmc&color=%23039BE5"" style=""border:solid 1px #777"" width=""800"" height=""600"" frameborder=""0"" scrolling=""no""></iframe>. .. _llvm-community-calendar-host-guidance:. Guidance on what to put into LLVM community calendar invites; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. To add your event, create a calendar event for it and invite calendar@llvm.org; on it. Your event should then show up on the community calendar. Please put the following pieces of information in your calendar invite:. * Write a single paragraph describing what the event is about. Include things; such as who the event is for and what sort of topics are discussed.; * State explicitly that the :doc:`CodeOfConduct` applies to this event.; * Make it clear who:. * the organizer is. * the person to contact is in case of any code-of-conduct issues. Typically,; this would be the organizer. * If you have meeting minutes for your event, add a pointer to where those live.; A good place for meeting minutes could be as a post on LLVM Discourse. An example invite looks as follows. .. code-block:: none. This event is a meetup for all developers of LLDB. Meeti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:19580,guid,guidance,19580,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['guid'],['guidance']
Usability,"; Structured bindings __cpp_structured_bindings C++17 C++03; template template arguments __cpp_template_template_args C++17 C++03; ``static operator[]`` __cpp_multidimensional_subscript C++20 C++03; Designated initializers __cpp_designated_initializers C++20 C++03; Conditional ``explicit`` __cpp_conditional_explicit C++20 C++03; ``using enum`` __cpp_using_enum C++20 C++03; ``if consteval`` __cpp_if_consteval C++23 C++20; ``static operator()`` __cpp_static_call_operator C++23 C++03; Attributes on Lambda-Expressions C++23 C++11; -------------------------------------- -------------------------------- ------------- -------------; Designated initializers (N494) C99 C89; Array & element qualification (N2607) C23 C89; Attributes (N2335) C23 C89; ====================================== ================================ ============= =============. Type Trait Primitives; =====================. Type trait primitives are special builtin constant expressions that can be used; by the standard C++ library to facilitate or simplify the implementation of; user-facing type traits in the <type_traits> header. They are not intended to be used directly by user code because they are; implementation-defined and subject to change -- as such they're tied closely to; the supported set of system headers, currently:. * LLVM's own libc++; * GNU libstdc++; * The Microsoft standard C++ library. Clang supports the `GNU C++ type traits; <https://gcc.gnu.org/onlinedocs/gcc/Type-Traits.html>`_ and a subset of the; `Microsoft Visual C++ type traits; <https://msdn.microsoft.com/en-us/library/ms177194(v=VS.100).aspx>`_,; as well as nearly all of the; `Embarcadero C++ type traits; <http://docwiki.embarcadero.com/RADStudio/Rio/en/Type_Trait_Functions_(C%2B%2B11)_Index>`_. The following type trait primitives are supported by Clang. Those traits marked; (C++) provide implementations for type traits specified by the C++ standard;; ``__X(...)`` has the same semantics and constraints as the corresponding; ``std:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:57049,simpl,simplify,57049,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['simpl'],['simplify']
Usability,"; a convergence token operand to define the set of communicating threads relative; to the operation that defined the token. Let ``U`` be a convergent operation other than a call to a convergence; control intrinsic, and ``D`` be the convergent operation that defines; the token value used as the ``convergencectrl`` operand to ``U``. Two; threads execute converged dynamic instances of ``U`` if and only if the; token value in both threads was returned by converged dynamic; instances of ``D``. .. note::. The text defines convergence token values as representing dynamic instances.; But if we were to assume that converged dynamic instances produce the same; token value, then we could almost think of the token value as representing a; set of threads instead -- specifically, the set ``S`` of threads that; executed converged dynamic instances of the defining instruction ``D``. In this intuitive picture, when a convergence token value ``T`` is used by a; ``convergencectrl`` bundle on an instruction ``I``, then the set of threads that; communicates in ``I`` is a subset of the set ``S`` represented by the token value.; Specifically, it is the subset of threads that ends up executing ``I`` while; using the token value. This by itself wouldn't quite work as a definition: what if ``I`` is executed; multiple times by the same threads? Which execution of ``I`` in thread 1; communicates with which execution of ``I`` in thread 2? Leaning on the notion; of dynamic instances gives a robust answer to this question as long as ``D``; and ``I`` are at the same loop (or cycle) nesting level. The case where ``D`` and ``I`` are at different loop nesting levels is; forbidden by the :ref:`static rules <convergence_static_rules>` -- handling; that case is the purpose of :ref:`llvm.experimental.convergence.loop; <llvm.experimental.convergence.loop>`. .. _convergence_control_intrinsics:. Convergence Control Intrinsics; ==============================. This section describes target-independent intrinsi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:20874,intuit,intuitive,20874,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['intuit'],['intuitive']
Usability,"; an error if a user program used that simple variable name. ""dpy""; was a pointer to a ""Display"". PostScript and PDF. Now, a text with size 0 is not drawn in PDF files. An invalid; PDF file is created if a text with size 0 is produced.; The landscape orientation is now correct in pdf files. gv recognizes; the files as ""Landscape"" and the orientation is not upside down; as it was before (seascape).; In PostScript and PDF files the method DrawPS is used to write; a single (x,y) position.; This case was not treated correctly and, because of that, the PS and PDF; files might contain useless attributes settings. That was only a few; bytes more in the file but they were useless. TLegend. When a object is added ""by name"" in a legend, the; TMultiGraph and THStack present in the current pad; are scanned if an object with this name has not been; found in the pad. Previously the graphs and histograms; were hidden in multi-graphs and histogram-stacks when one; tried to add them by name.; New reference guide. TGaxis. In PaintAxis The option ""U"", for unlabeled axis, was not; implemented in case of alphanumeric axis' labels.; On log-scale TGAxis, with labels having lower values than 1 and ticks marks; set to the positive side, alignement issues seem to come up.; The following example shows four TGAxis drawn respectively with the; following options: RG-, RG+, LG-, LG+. For the RG+ and LG+ options,; the 10E-1 and 10E-2 labels were ill-aligned, showing a shift to the right; compared to the 1E2, 1E1 and 1 labels.; ; {; c1 = new TCanvas(""c1"",""Examples of Log TGaxis"",10,10,700,500);; c1->Range(-10,-1,10,1);; TGaxis *axis1 = new TGaxis(-7,-0.8,-7,0.8,0.01,100,50510,""RG-"");; axis1->SetTitle(""RG-""); axis1->Draw();; TGaxis *axis2 = new TGaxis(-2,-0.8,-2,0.8,0.01,100,50510,""RG+"");; axis2->SetLabelOffset(-0.04); axis2->SetTitleOffset(-1.5);; axis2->SetTitle(""RG+""); axis2->Draw();; TGaxis *axis3 = new TGaxis(2,-0.8,2,0.8,0.01,100,50510,""LG-"");; axis3->SetLabelOffset(-0.04);; axis3->SetTitle(""L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v524/index.html:1543,guid,guide,1543,graf2d/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v524/index.html,1,['guid'],['guide']
Usability,"; and functions that capture the builtin function data from the TableGen; definitions in a compact manner. - OpenCL specific code in ``SemaLookup.cpp``. When ``Sema::LookupBuiltin``; encounters a potential builtin function, it will check if the name corresponds; to a valid OpenCL builtin function. If so, all overloads of the function are; inserted using ``InsertOCLBuiltinDeclarationsFromTable`` and overload; resolution takes place. OpenCL Extensions and Features; ------------------------------. Clang implements various extensions to OpenCL kernel languages. New functionality is accepted as soon as the documentation is detailed to the; level sufficient to be implemented. There should be an evidence that the; extension is designed with implementation feasibility in consideration and; assessment of complexity for C/C++ based compilers. Alternatively, the; documentation can be accepted in a format of a draft that can be further; refined during the implementation. Implementation guidelines; ^^^^^^^^^^^^^^^^^^^^^^^^^. This section explains how to extend clang with the new functionality. **Parsing functionality**. If an extension modifies the standard parsing it needs to be added to; the clang frontend source code. This also means that the associated macro; indicating the presence of the extension should be added to clang. The default flow for adding a new extension into the frontend is to; modify `OpenCLExtensions.def; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/OpenCLExtensions.def>`__,; containing the list of all extensions and optional features supported by; the frontend. This will add the macro automatically and also add a field in the target; options ``clang::TargetOptions::OpenCLFeaturesMap`` to control the exposure; of the new extension during the compilation. Note that by default targets like `SPIR-V`, `SPIR` or `X86` expose all the OpenCL; extensions. For all other targets the configuration has to be made explicitly. Note that the ta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:8233,guid,guidelines,8233,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst,1,['guid'],['guidelines']
Usability,"; and greater than 0.0 to enable cache. This value can be overridden by the; environment variable ROOT_TTREECACHE_SIZE. The resource variable TTreeCache.Prefill sets the default TTreeCache prefilling; type. The prefill type may be: 0 for no prefilling and 1 to prefill all; the branches. It can be overridden by the environment variable ROOT_TTREECACHE_PREFILL. In particular the default can be set back to the same as in version 5 by; setting TTreeCache.Size (or ROOT_TTREECACHE_SIZE) and TTreeCache.Prefill; (or ROOT_TTREECACHE_PREFILL) both to zero. TTree methods which are expected to modify a cache, like AddBranchToCache, will; attempt to setup a cache of default size if one does not exist, irrespective of; whether the auto cache creation is enabled. Additionally several methods giving; control of the cache have changed return type from void to Int_t, to be able to; return a code to indicate if there was an error. Usually TTree::SetCacheSize will no longer reset the list of branches to be; cached (either set or previously learnt) nor restart the learning phase.; The learning phase is restarted when a new cache is created, e.g. after having; removed a cache with SetCacheSize(0). ### TSelectorDraw. The axis titles in case of a `x:y:z` plot with the option `COLZ` were not correct. ### TParallelCoordVar. Change the format used to print the variables limit for ||-Coord to `%g`. It was; `%6.4f` before. ## Histogram Libraries. ### TFormula. - New version of the TFormula class based on Cling. Formula expressions are now used to create functions which are passed to Cling to be Just In Time compiled.; The expression is therefore compiled using Clang/LLVVM which will give execution time as compiled code and in addition correctness of the result obtained.; - This class is not 100% backward compatible with the old TFormula class, which is still available in ROOT as =ROOT::v5::TFormula=.; Some of the TFormula member funtions available in version 5, such as =Analyze= and =AnalyzeFun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:14772,learn,learnt,14772,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,2,['learn'],"['learning', 'learnt']"
Usability,"; arrays are composite types. Simple types are also called primitive; types, basic types, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves up the; inheritance tree until it reaches an ancestor without a parent. To; serialize the object data members it calls their `Streamer`. They in; turn move up their own inheritance tree and so forth. The simple data; members are written to the buffer directly. Eventually the buffer; contains all simple data members of all the classes that make up this; particular object. Data members that are references (as; `MyClass &fObj;`) are never saved, it is always the responsibility of; the object's constructor to set them properly. ### Automatically Generated Streamers. A `Streamer `usually calls other `Streamers`: the `Streamer `of its; parents and data members. This architecture depends on all classes; having `Streamers`, because eventually they will be called. To ensure; that a class has a `Streamer`, `rootcling` automatically creates one in; the `ClassDef` macro that is defined in `$ROOTSYS/include/Rtypes.h`.; `ClassDef` defines several methods for any class, and one of them is the; `Streamer`. The automatically generated `Streamer `is complete and can; be used as long as no customization is needed. The `Event` class is defined in `$ROOTSYS/test/Event.h`. Looking at the; class definition, we find that it inherits f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:43196,simpl,simple,43196,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['simpl'],['simple']
Usability,"; call GCC. Although this makes the driver much more complicated than; might otherwise be necessary, we decided that being very compatible with; the gcc command line interface was worth it in order to allow users to; quickly test clang on their projects. Flexible; --------. The driver was designed to be flexible and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possible.; - Don't parse arguments more than once.; - Provide a few simple interfaces for efficiently searching arguments. Simple; ------. Finally, the driver was designed to be ""as simple as possible"", given; the other goals. Notably, trying to be completely compatible with the; gcc driver adds a significant amount of complexity. However, the design; of the driver attempts to mitigate this complexity by dividing the; process into a number of independent stages instead of a single; monolithic task. Internal Design and Implementation; ==================================. .. contents::; :local:; :depth: 1. Internals Introduction; ----------------------. In order to satisfy the stated goals, the driver was designed to; completely subsume the functionality of the gcc executable; that is, the; driver should not need to delegate to gcc to perform subtasks. On; Darwin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:1974,simpl,simple,1974,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['simpl'],['simple']
Usability,"; calling it undefined behavior. Therefore we chose to delay destroying the; instance variables to a point at which message sends are clearly disallowed:; the point at which the root class's deallocation routines take over. In most code, the difference is not observable. It can, however, be observed; if an instance variable holds a strong reference to an object whose; deallocation will trigger a side-effect which must be carefully ordered with; respect to the destruction of the super class. Such code violates the design; principle that semantically important behavior should be explicit. A simple; fix is to clear the instance variable manually during ``dealloc``; a more; holistic solution is to move semantically important side-effects out of; ``dealloc`` and into a separate teardown phase which can rely on working with; well-formed objects. .. _arc.misc.autoreleasepool:. ``@autoreleasepool``; --------------------. To simplify the use of autorelease pools, and to bring them under the control; of the compiler, a new kind of statement is available in Objective-C. It is; written ``@autoreleasepool`` followed by a *compound-statement*, i.e. by a new; scope delimited by curly braces. Upon entry to this block, the current state; of the autorelease pool is captured. When the block is exited normally,; whether by fallthrough or directed control flow (such as ``return`` or; ``break``), the autorelease pool is restored to the saved state, releasing all; the objects in it. When the block is exited with an exception, the pool is not; drained. ``@autoreleasepool`` may be used in non-ARC translation units, with equivalent; semantics. A program is ill-formed if it refers to the ``NSAutoreleasePool`` class. .. admonition:: Rationale. Autorelease pools are clearly important for the compiler to reason about, but; it is far too much to expect the compiler to accurately reason about control; dependencies between two calls. It is also very easy to accidentally forget; to drain an autorelea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:90509,simpl,simplify,90509,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['simpl'],['simplify']
Usability,"; configuration for the LLVM project which will build the fastest or; **RelWithDebInfo** which is also several time larger than Release.; Another technique is to build all of LLVM in Release mode and change; compiler flags, disabling optimization and enabling debug information, only; for specific libraries or source files you actually need to debug. 14. Test LLVM in Visual Studio:. You can run LLVM tests by merely building the project ""check-all"". The test; results will be shown in the VS output window. Once the build succeeds, you; have verified a working LLVM development environment!. You should not see any unexpected failures, but will see many unsupported; tests and expected failures:. ::. 114>Testing Time: 1124.66s; 114> Skipped : 39; 114> Unsupported : 21649; 114> Passed : 51615; 114> Expectedly Failed: 93; ========== Build: 114 succeeded, 0 failed, 321 up-to-date, 0 skipped ==========``. Alternatives to manual installation; ===================================; Instead of the steps above, to simplify the installation procedure you can use; `Chocolatey <https://chocolatey.org/>`_ as package manager.; After the `installation <https://chocolatey.org/install>`_ of Chocolatey,; run these commands in an admin shell to install the required tools:. .. code-block:: bat. choco install -y git cmake python3; pip3 install psutil. There is also a Windows; `Dockerfile <https://github.com/llvm/llvm-zorg/blob/main/buildbot/google/docker/windows-base-vscode2019/Dockerfile>`_; with the entire build tool chain. This can be used to test the build with a; tool chain different from your host installation or to create build servers. Next steps; ==========; 1. Read the documentation.; 2. Seriously, read the documentation.; 3. Remember that you were warned twice about reading the documentation. Test LLVM on the command line:; ------------------------------; The LLVM tests can be run by changing directory to the llvm source; directory and running:. .. code-block:: bat. c:\llvm> python ..",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:8088,simpl,simplify,8088,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,1,['simpl'],['simplify']
Usability,"; def : InstAlias<""movsx $src, $dst"", (MOVSX64rr32 GR64:$dst, GR32 :$src)>;. This shows a powerful example of the instruction aliases, matching the same; mnemonic in multiple different ways depending on what operands are present in; the assembly. The result of instruction aliases can include operands in a; different order than the destination instruction, and can use an input multiple; times, for example:. ::. def : InstAlias<""clrb $reg"", (XOR8rr GR8 :$reg, GR8 :$reg)>;; def : InstAlias<""clrw $reg"", (XOR16rr GR16:$reg, GR16:$reg)>;; def : InstAlias<""clrl $reg"", (XOR32rr GR32:$reg, GR32:$reg)>;; def : InstAlias<""clrq $reg"", (XOR64rr GR64:$reg, GR64:$reg)>;. This example also shows that tied operands are only listed once. In the X86; backend, XOR8rr has two input GR8's and one output GR8 (where an input is tied; to the output). InstAliases take a flattened operand list without duplicates; for tied operands. The result of an instruction alias can also use immediates; and fixed physical registers which are added as simple immediate operands in the; result, for example:. ::. // Fixed Immediate operand.; def : InstAlias<""aad"", (AAD8i8 10)>;. // Fixed register operand.; def : InstAlias<""fcomi"", (COM_FIr ST1)>;. // Simple alias.; def : InstAlias<""fcomi $reg"", (COM_FIr RST:$reg)>;. Instruction aliases can also have a Requires clause to make them subtarget; specific. If the back-end supports it, the instruction printer can automatically emit the; alias rather than what's being aliased. It typically leads to better, more; readable code. If it's better to print out what's being aliased, then pass a '0'; as the third parameter to the InstAlias definition. Instruction Matching; --------------------. .. note::. To Be Written. .. _Implementations of the abstract target description interfaces:; .. _implement the target description:. Target-specific Implementation Notes; ====================================. This section of the document explains features or design decisions that are;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:85139,simpl,simple,85139,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"; function with parameters, called `[0]`, `[1]` and so on in the ROOT; formula syntax. We now need a way to assign values to these parameters;; this is achieved with the method; `SetParameter(<parameter_number>,<parameter_value>)` of class `TF1`.; Here is an example:. ``` {.cpp}; root [13] TF1 f2(""f2"",""[0]*sin([1]*x)/x"",0.,10.);; root [14] f2.SetParameter(0,1);; root [15] f2.SetParameter(1,1);; root [16] f2.Draw();; ```. Of course, this version shows the same results as the initial one. Try; playing with the parameters and plot the function again. The class `TF1`; has a large number of very useful methods, including integration and; differentiation. To make full use of this and other ROOT classes, visit; the documentation on the Internet under; <https://root.cern/doc/master/>. Formulae in ROOT; are evaluated using the class `TFormula`, so also look up the relevant; class documentation for examples, implemented functions and syntax. You should definitely download this guide to your own system to have it; at you disposal whenever you need it. To extend a little bit on the above example, consider a more complex; function you would like to define. You can also do this using standard; `C` or `C++` code. Consider the example below, which calculates and displays the; interference pattern produced by light falling on a multiple slit.; Please do not type in the example below at the ROOT command line, there; is a much simpler way: Make sure you have the file `slits.C` on disk,; and type `root slits.C` in the shell. This will start root and make it; read the ""macro"" `slits.C`, i.e. all the lines in the file will be; executed one after the other. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/slits.C; ```; [f21]: figures/TF1_DoubleSlit.png ""f21""; <a name=""f21""></a>. ![Output of slits.C with parameters 0.2 and 2.\label{f21}][f21]. The example first asks for user input, namely the ratio of slit width; over slit distance, and the number of slits. After entering this; informatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:4888,guid,guide,4888,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['guid'],['guide']
Usability,"; something goes wrong. As the method described here also works without; using PROOF, the development work on an analysis script can be done in; the standard way on a small subset of the data, and only for the full; processing one would use parallelism via PROOF. It is worth to remind the reader that the speed of typical data analysis; programs limited by the I/O speed (for example the latencies implied by; reading data from a hard drive). It is therefore expected that this; limitation cannot be eliminated with the usage of any parallel analysis; toolkit. ### Optimisation Regarding N-tuples ###. ROOT automatically applies compression algorithms on n-tuples to reduce; the memory consumption. A value that is in most cases the same will; consume only small space on your disk (but it has to be decompressed on; reading). Nevertheless, you should think about the design of your; n-tuples and your analyses as soon as the processing time exceeds some; minutes. - Try to keep your n-tuples simple and use appropriate variable types.; If your measurement has only a limited precision, it is needless to; store it with double precision. - Experimental conditions that do not change with every single; measurement should be stored in a separate tree. Although the; compression can handle redundant values, the processing time; increase with every variable that has to be filled. - The function `SetCacheSize(long)` specifies the size of the cache; for reading a `TTree` object from a file. The default value is 30MB.; A manual increase may help in certain situations. Please note that; the caching mechanism can cover only one `TTree` object per `TFile`; object. - You can select the branches to be covered by the caching algorithm; with `AddBranchToCache` and deactivate unneeded branches with; `SetBranchStatus`. This mechanism can result in a significant; speed-up for simple operations on trees with many branches. - You can measure the performance easily with `TTreePerfStats`. The; ROOT documen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:13664,simpl,simple,13664,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['simpl'],['simple']
Usability,"; type operand provided as input, the input value will be split into multiple; registers, and all of them passed to the inline asm. However, this feature is often not as useful as you might think. Firstly, the registers are *not* guaranteed to be consecutive. So, on those; architectures that have instructions which operate on multiple consecutive; instructions, this is not an appropriate way to support them. (e.g. the 32-bit; SparcV8 has a 64-bit load, which instruction takes a single 32-bit register. The; hardware then loads into both the named register, and the next register. This; feature of inline asm would not be useful to support that.). A few of the targets provide a template string modifier allowing explicit access; to the second register of a two-register operand (e.g. MIPS ``L``, ``M``, and; ``D``). On such an architecture, you can actually access the second allocated; register (yet, still, not any subsequent ones). But, in that case, you're still; probably better off simply splitting the value into two separate operands, for; clarity. (e.g. see the description of the ``A`` constraint on X86, which,; despite existing only for use with this feature, is not really a good idea to; use). Indirect inputs and outputs; """""""""""""""""""""""""""""""""""""""""""""""""""""". Indirect output or input constraints can be specified by the ""``*``"" modifier; (which goes after the ""``=``"" in case of an output). This indicates that the asm; will write to or read from the contents of an *address* provided as an input; argument. (Note that in this way, indirect outputs act more like an *input* than; an output: just like an input, they consume an argument of the call expression,; rather than producing a return value. An indirect output constraint is an; ""output"" only in that the asm is expected to write to the contents of the input; memory location, instead of just read from it). This is most typically used for memory constraint, e.g. ""``=*m``"", to pass the; address of a variable as a value. It is als",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:215317,simpl,simply,215317,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,";. The ``CalcValue`` class is invoked with the template argument ``arg``. It; calculates a value for the ``ret`` field, which is then retrieved at the; ""point of call"" in the initialization for the Result field. The anonymous; record created in this example serves no other purpose than to carry the; result value. Here is a practical example. The class ``isValidSize`` determines whether a; specified number of bytes represents a valid data size. The bit ``ret`` is; set appropriately. The field ``ValidSize`` obtains its initial value by; invoking ``isValidSize`` with the data size and retrieving the ``ret`` field; from the resulting anonymous record. .. code-block:: text. class isValidSize<int size> {; bit ret = !cond(!eq(size, 1): 1,; !eq(size, 2): 1,; !eq(size, 4): 1,; !eq(size, 8): 1,; !eq(size, 16): 1,; true: 0);; }. def Data1 {; int Size = ...;; bit ValidSize = isValidSize<Size>.ret;; }. Preprocessing Facilities; ========================. The preprocessor embedded in TableGen is intended only for simple; conditional compilation. It supports the following directives, which are; specified somewhat informally. .. productionlist::; LineBegin: beginning of line; LineEnd: newline | return | EOF; WhiteSpace: space | tab; CComment: ""/*"" ... ""*/""; BCPLComment: ""//"" ... `LineEnd`; WhiteSpaceOrCComment: `WhiteSpace` | `CComment`; WhiteSpaceOrAnyComment: `WhiteSpace` | `CComment` | `BCPLComment`; MacroName: `ualpha` (`ualpha` | ""0""...""9"")*; PreDefine: `LineBegin` (`WhiteSpaceOrCComment`)*; : ""#define"" (`WhiteSpace`)+ `MacroName`; : (`WhiteSpaceOrAnyComment`)* `LineEnd`; PreIfdef: `LineBegin` (`WhiteSpaceOrCComment`)*; : (""#ifdef"" | ""#ifndef"") (`WhiteSpace`)+ `MacroName`; : (`WhiteSpaceOrAnyComment`)* `LineEnd`; PreElse: `LineBegin` (`WhiteSpaceOrCComment`)*; : ""#else"" (`WhiteSpaceOrAnyComment`)* `LineEnd`; PreEndif: `LineBegin` (`WhiteSpaceOrCComment`)*; : ""#endif"" (`WhiteSpaceOrAnyComment`)* `LineEnd`. ..; PreRegContentException: `PreIfdef` | `PreElse` | `PreEndif` | EOF; Pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:56705,simpl,simple,56705,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,";; const int a = 5;; static_assert(*p == 5, ""x"");. TargetPointer; ~~~~~~~~~~~~~. While null pointer arithmetic or integer-to-pointer conversion is; banned in constexpr, some expressions on target offsets must be folded,; replicating the behaviour of the ``offsetof`` builtin. Target pointers; are characterised by 3 offsets: a field offset, an array offset and a; base offset, along with a descriptor specifying the type the pointer is; supposed to refer to. Array indexing adjusts the array offset, while the; field offset is adjusted when a pointer to a member is created. Casting; an integer to a pointer sets the value of the base offset. As a special; case, null pointers are target pointers with all offsets set to 0. TypeInfoPointer; ~~~~~~~~~~~~~~~. ``TypeInfoPointer`` tracks two types: the type assigned to; ``std::type_info`` and the type which was passed to ``typeinfo``. InvalidPointer; ~~~~~~~~~~~~~~. Such pointers are built by operations which cannot generate valid; pointers, allowing the interpreter to continue execution after emitting; a warning. Inspecting such a pointer stops execution. TODO; ====. Missing Language Features; -------------------------. * Changing the active field of unions; * ``volatile``; * ``__builtin_constant_p``; * ``dynamic_cast``; * ``new`` and ``delete``; * Fixed Point numbers and arithmetic on Complex numbers; * Several builtin methods, including string operations and; ``__builtin_bit_cast``; * Continue-after-failure: a form of exception handling at the bytecode; level should be implemented to allow execution to resume. As an example,; argument evaluation should resume after the computation of an argument fails.; * Pointer-to-Integer conversions; * Lazy descriptors: the interpreter creates a ``Record`` and ``Descriptor``; when it encounters a type: ones which are not yet defined should be lazily; created when required. Known Bugs; ----------. * If execution fails, memory storing APInts and APFloats is leaked when the; stack is cleared; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:14626,resume,resume,14626,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,3,"['clear', 'resume']","['cleared', 'resume']"
Usability,";; return nullptr;; }. The ``LogError`` routines are simple helper routines that our parser will; use to handle errors. The error recovery in our parser will not be the; best and is not particular user-friendly, but it will be enough for our; tutorial. These routines make it easier to handle errors in routines; that have various return types: they always return null. With these basic helper functions, we can implement the first piece of; our grammar: numeric literals. Basic Expression Parsing; ========================. We start with numeric literals, because they are the simplest to; process. For each production in our grammar, we'll define a function; which parses that production. For numeric literals, we have:. .. code-block:: c++. /// numberexpr ::= number; static std::unique_ptr<ExprAST> ParseNumberExpr() {; auto Result = std::make_unique<NumberExprAST>(NumVal);; getNextToken(); // consume the number; return std::move(Result);; }. This routine is very simple: it expects to be called when the current; token is a ``tok_number`` token. It takes the current number value,; creates a ``NumberExprAST`` node, advances the lexer to the next token,; and finally returns. There are some interesting aspects to this. The most important one is; that this routine eats all of the tokens that correspond to the; production and returns the lexer buffer with the next token (which is; not part of the grammar production) ready to go. This is a fairly; standard way to go for recursive descent parsers. For a better example,; the parenthesis operator is defined like this:. .. code-block:: c++. /// parenexpr ::= '(' expression ')'; static std::unique_ptr<ExprAST> ParseParenExpr() {; getNextToken(); // eat (.; auto V = ParseExpression();; if (!V); return nullptr;. if (CurTok != ')'); return LogError(""expected ')'"");; getNextToken(); // eat ).; return V;; }. This function illustrates a number of interesting things about the; parser:. 1) It shows how we use the LogError routines. When called",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:7563,simpl,simple,7563,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['simpl'],['simple']
Usability,"<< ""Hello.\n"";; }. with the following one:. .. code-block:: c++. module;; #include <iostream>; export module M;; export void Hello() {; std::cout << ""Hello.\n"";; }. .. code-block:: console. $ clang++ -std=c++20 -xc++-system-header --precompile iostream -o iostream.pcm; $ clang++ -std=c++20 -fmodule-file=iostream.pcm --precompile M.cppm -o M.cpp. In the latter example, the Clang could find the BMI for the ``<iostream>``; so it would try to replace the ``#include <iostream>`` to ``import <iostream>;`` automatically. Relationships between Clang modules; -----------------------------------. Header units have pretty similar semantics with Clang modules.; The semantics of both of them are like headers. In fact, we could even ""mimic"" the sytle of header units by Clang modules:. .. code-block:: c++. module ""iostream"" {; export *; header ""/path/to/libstdcxx/iostream""; }. .. code-block:: console. $ clang++ -std=c++20 -fimplicit-modules -fmodule-map-file=.modulemap main.cpp. It would be simpler if we are using libcxx:. .. code-block:: console. $ clang++ -std=c++20 main.cpp -fimplicit-modules -fimplicit-module-maps. Since there is already one; `module map <https://github.com/llvm/llvm-project/blob/main/libcxx/include/module.modulemap.in>`_; in the source of libcxx. Then immediately leads to the question: why don't we implement header units through Clang header modules?. The main reason for this is that Clang modules have more semantics like hierarchy or; wrapping multiple headers together as a big module.; However, these things are not part of Standard C++ Header units,; and we want to avoid the impression that these additional semantics get interpreted as Standard C++ behavior. Another reason is that there are proposals to introduce module mappers to the C++ standard; (for example, https://wg21.link/p1184r2).; If we decide to reuse Clang's modulemap, we may get in trouble once we need to introduce another module mapper. So the final answer for why we don't reuse the interface o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:31389,simpl,simpler,31389,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['simpl'],['simpler']
Usability,"<char> >::size_type) 1; [cling]$. Cling is built on the top of LLVM and Clang libraries. In addition to standard interpreters it has a command line prompt and uses just-in-time (JIT) compiler. This kind of software application is commonly known as an interactive compiler.; ; Cling started off as a contemporary, high-performance alternative of the current C++ interpreter in the ROOT project - CINT.; ; Why interpreting C++ with Cling?. Learning C++ . ; One use case of cling is to aid the C++ learning process. Offering imediate feedback the user can easily get familiar with the structures and spelling of the language. ; . Creating scripts; ; The power of an interpreter lays as well in the compactness and ease of repeatedly running a small snippet of code - aka a script. This can be done in cling by inserting the bash-like style line: ; . #!/usr/bin/cling; . Rapid Application Development (RAD) . ; Cling can be used successfully for Rapid Application Development allowing for prototyping and proofs of concept taking advantage of dynamicity and feedback during the implementation process.; . Runtime-Generated Code ; ; Sometime it's convenient to create code as a reaction to input; (user/network/configuration).; Runtime-generated code can interface with C++ libraries.; . Embedding Cling . The functionality of an application can be enriched by embedding Cling. To embed Cling, the main program has to be provided. One of the things this main program has to do is initialize the Cling interpreter. There are optional calls to pass command line arguments to Cling. Afterwards, you can call the interpreter from any anywhere within the application. For compilation and linkage the application needs the path to the clang and llvm libraries and the invocation is order dependent since the linker cannot do backward searches. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html:1386,feedback,feedback,1386,interpreter/cling/www/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/index.html,1,['feedback'],['feedback']
Usability,"=. Coroutine Manipulation Intrinsics; ---------------------------------. Intrinsics described in this section are used to manipulate an existing; coroutine. They can be used in any function which happen to have a pointer; to a `coroutine frame`_ or a pointer to a `coroutine promise`_. .. _coro.destroy:. 'llvm.coro.destroy' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.coro.destroy(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.destroy``' intrinsic destroys a suspended; switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a coroutine handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.destroy` intrinsic is replaced with a direct call to; the coroutine destroy function. Otherwise it is replaced with an indirect call; based on the function pointer for the destroy function stored in the coroutine; frame. Destroying a coroutine that is not suspended leads to undefined behavior. .. _coro.resume:. 'llvm.coro.resume' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare void @llvm.coro.resume(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.resume``' intrinsic resumes a suspended switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.resume` intrinsic is replaced with a direct call to the; coroutine resume function. Otherwise it is replaced with an indirect call based; on the function pointer for the resume function stored in the coroutine frame.; Resuming a coroutine that is not suspended leads to undefined behavior. .. _coro.done:. 'llvm.coro.done' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare i1 @llvm.coro.done(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.done``' intrinsic checks whether a suspended; switched-resume coroutine is at the final suspend point or not. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:27715,resume,resume,27715,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"====. .. contents::; :local:. **This tutorial is under active development. It is incomplete and details may; change frequently.** Nonetheless we invite you to try it out as it stands, and; we welcome any feedback. Chapter 3 Introduction; ======================. **Warning: This text is currently out of date due to ORC API updates.**. **The example code has been updated and can be used. The text will be updated; once the API churn dies down.**. Welcome to Chapter 3 of the ""Building an ORC-based JIT in LLVM"" tutorial. This; chapter discusses lazy JITing and shows you how to enable it by adding an ORC; CompileOnDemand layer the JIT from `Chapter 2 <BuildingAJIT2.html>`_. Lazy Compilation; ================. When we add a module to the KaleidoscopeJIT class from Chapter 2 it is; immediately optimized, compiled and linked for us by the IRTransformLayer,; IRCompileLayer and RTDyldObjectLinkingLayer respectively. This scheme, where all the; work to make a Module executable is done up front, is simple to understand and; its performance characteristics are easy to reason about. However, it will lead; to very high startup times if the amount of code to be compiled is large, and; may also do a lot of unnecessary compilation if only a few compiled functions; are ever called at runtime. A truly ""just-in-time"" compiler should allow us to; defer the compilation of any given function until the moment that function is; first called, improving launch times and eliminating redundant work. In fact,; the ORC APIs provide us with a layer to lazily compile LLVM IR:; *CompileOnDemandLayer*. The CompileOnDemandLayer class conforms to the layer interface described in; Chapter 2, but its addModule method behaves quite differently from the layers; we have seen so far: rather than doing any work up front, it just scans the; Modules being added and arranges for each function in them to be compiled the; first time it is called. To do this, the CompileOnDemandLayer creates two small; utilities for e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst:1135,simpl,simple,1135,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,1,['simpl'],['simple']
Usability,"====. In addition to the regular ""whole program"" tests, the ``test-suite``; module also provides a mechanism for compiling the programs in different; ways. If the variable TEST is defined on the ``gmake`` command line, the; test system will include a Makefile named; ``TEST.<value of TEST variable>.Makefile``. This Makefile can modify; build rules to yield different results. For example, the LLVM nightly tester uses ``TEST.nightly.Makefile`` to; create the nightly test reports. To run the nightly tests, run; ``gmake TEST=nightly``. There are several TEST Makefiles available in the tree. Some of them are; designed for internal LLVM research and will not work outside of the; LLVM research group. They may still be valuable, however, as a guide to; writing your own TEST Makefile for any optimization or analysis passes; that you develop with LLVM. Generating Test Output; ======================. There are a number of ways to run the tests and generate output. The; most simple one is simply running ``gmake`` with no arguments. This will; compile and run all programs in the tree using a number of different; methods and compare results. Any failures are reported in the output,; but are likely drowned in the other output. Passes are not reported; explicitly. Somewhat better is running ``gmake TEST=sometest test``, which runs the; specified test and usually adds per-program summaries to the output; (depending on which sometest you use). For example, the ``nightly`` test; explicitly outputs TEST-PASS or TEST-FAIL for every test after each; program. Though these lines are still drowned in the output, it's easy; to grep the output logs in the Output directories. Even better are the ``report`` and ``report.format`` targets (where; ``format`` is one of ``html``, ``csv``, ``text`` or ``graphs``). The; exact contents of the report are dependent on which ``TEST`` you are; running, but the text results are always shown at the end of the run and; the results are always stored in the ``re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:3771,simpl,simple,3771,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,2,['simpl'],"['simple', 'simply']"
Usability,"=====; reserved ``s_trap 0x00`` Reserved by hardware.; debugger breakpoint ``s_trap 0x01`` *none* Reserved for debugger to use for; breakpoints. Causes wave to be halted; with the PC at the trap instruction.; The debugger is responsible to resume; the wave, including the instruction; that the breakpoint overwrote.; ``llvm.trap`` ``s_trap 0x02`` ``SGPR0-1``: Causes wave to be halted with the PC at; ``queue_ptr`` the trap instruction. The associated; queue is signalled to put it into the; error state. When the queue is put in; the error state, the waves executing; dispatches on the queue will be; terminated.; ``llvm.debugtrap`` ``s_trap 0x03`` *none* - If debugger not enabled then behaves; as a no-operation. The trap handler; is entered and immediately returns to; continue execution of the wavefront.; - If the debugger is enabled, causes; the debug trap to be reported by the; debugger and the wavefront is put in; the halt state with the PC at the; instruction. The debugger must; increment the PC and resume the wave.; reserved ``s_trap 0x04`` Reserved.; reserved ``s_trap 0x05`` Reserved.; reserved ``s_trap 0x06`` Reserved.; reserved ``s_trap 0x07`` Reserved.; reserved ``s_trap 0x08`` Reserved.; reserved ``s_trap 0xfe`` Reserved.; reserved ``s_trap 0xff`` Reserved.; =================== =============== =============== =======================================. .. .. table:: AMDGPU Trap Handler for AMDHSA OS Code Object V4 and Above; :name: amdgpu-trap-handler-for-amdhsa-os-v4-onwards-table. =================== =============== ================ ================= =======================================; Usage Code Sequence GFX6-GFX8 Inputs GFX9-GFX11 Inputs Description; =================== =============== ================ ================= =======================================; reserved ``s_trap 0x00`` Reserved by hardware.; debugger breakpoint ``s_trap 0x01`` *none* *none* Reserved for debugger to use for; breakpoints. Causes wave to be halted; with the PC at the trap instr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:383610,resume,resume,383610,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['resume'],['resume']
Usability,"======. The JIT linker concept was introduced in LLVM's earlier generation of JIT APIs,; MCJIT. In MCJIT the *RuntimeDyld* component enabled re-use of LLVM as an; in-memory compiler by adding an in-memory link step to the end of the usual; compiler pipeline. Rather than dumping relocatable objects to disk as a compiler; usually would, MCJIT passed them to RuntimeDyld to be linked into a target; process. This approach to linking differs from standard *static* or *dynamic* linking:. A *static linker* takes one or more relocatable object files as input and links; them into an executable or dynamic library on disk. A *dynamic linker* applies relocations to executables and dynamic libraries that; have been loaded into memory. A *JIT linker* takes a single relocatable object file at a time and links it; into a target process, usually using a context object to allow the linked code; to resolve symbols in the target. RuntimeDyld; -----------. In order to keep RuntimeDyld's implementation simple MCJIT imposed some; restrictions on compiled code:. #. It had to use the Large code model, and often restricted available relocation; models in order to limit the kinds of relocations that had to be supported. #. It required strong linkage and default visibility on all symbols -- behavior; for other linkages/visibilities was not well defined. #. It constrained and/or prohibited the use of features requiring runtime; support, e.g. static initializers or thread local storage. As a result of these restrictions not all language features supported by LLVM; worked under MCJIT, and objects to be loaded under the JIT had to be compiled to; target it (precluding the use of precompiled code from other sources under the; JIT). RuntimeDyld also provided very limited visibility into the linking process; itself: Clients could access conservative estimates of section size; (RuntimeDyld bundled stub size and padding estimates into the section size; value) and the final relocated bytes, but could not ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:35759,simpl,simple,35759,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['simpl'],['simple']
Usability,"=======. Debug information is a hard problem for a few different reasons - mostly; centered around optimized code. First, optimization makes keeping source; locations more difficult. In LLVM IR we keep the original source location; for each IR level instruction on the instruction. Optimization passes; should keep the source locations for newly created instructions, but merged; instructions only get to keep a single location - this can cause jumping; around when stepping through optimized programs. Secondly, optimization; can move variables in ways that are either optimized out, shared in memory; with other variables, or difficult to track. For the purposes of this; tutorial we're going to avoid optimization (as you'll see with one of the; next sets of patches). Ahead-of-Time Compilation Mode; ==============================. To highlight only the aspects of adding debug information to a source; language without needing to worry about the complexities of JIT debugging; we're going to make a few changes to Kaleidoscope to support compiling; the IR emitted by the front end into a simple standalone program that; you can execute, debug, and see results. First we make our anonymous function that contains our top level; statement be our ""main"":. .. code-block:: udiff. - auto Proto = std::make_unique<PrototypeAST>("""", std::vector<std::string>());; + auto Proto = std::make_unique<PrototypeAST>(""main"", std::vector<std::string>());. just with the simple change of giving it a name. Then we're going to remove the command line code wherever it exists:. .. code-block:: udiff. @@ -1129,7 +1129,6 @@ static void HandleTopLevelExpression() {; /// top ::= definition | external | expression | ';'; static void MainLoop() {; while (true) {; - fprintf(stderr, ""ready> "");; switch (CurTok) {; case tok_eof:; return;; @@ -1184,7 +1183,6 @@ int main() {; BinopPrecedence['*'] = 40; // highest. // Prime the first token.; - fprintf(stderr, ""ready> "");; getNextToken();. Lastly we're going to disable",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:2746,simpl,simple,2746,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,1,['simpl'],['simple']
Usability,"=======. Generating LLVM code for expression nodes is very straightforward: less; than 45 lines of commented code for all four of our expression nodes.; First we'll do numeric literals:. .. code-block:: c++. Value *NumberExprAST::codegen() {; return ConstantFP::get(*TheContext, APFloat(Val));; }. In the LLVM IR, numeric constants are represented with the; ``ConstantFP`` class, which holds the numeric value in an ``APFloat``; internally (``APFloat`` has the capability of holding floating point; constants of Arbitrary Precision). This code basically just creates; and returns a ``ConstantFP``. Note that in the LLVM IR that constants; are all uniqued together and shared. For this reason, the API uses the; ""foo::get(...)"" idiom instead of ""new foo(..)"" or ""foo::Create(..)"". .. code-block:: c++. Value *VariableExprAST::codegen() {; // Look this variable up in the function.; Value *V = NamedValues[Name];; if (!V); LogErrorV(""Unknown variable name"");; return V;; }. References to variables are also quite simple using LLVM. In the simple; version of Kaleidoscope, we assume that the variable has already been; emitted somewhere and its value is available. In practice, the only; values that can be in the ``NamedValues`` map are function arguments.; This code simply checks to see that the specified name is in the map (if; not, an unknown variable is being referenced) and returns the value for; it. In future chapters, we'll add support for `loop induction; variables <LangImpl05.html#for-loop-expression>`_ in the symbol table, and for `local; variables <LangImpl07.html#user-defined-local-variables>`_. .. code-block:: c++. Value *BinaryExprAST::codegen() {; Value *L = LHS->codegen();; Value *R = RHS->codegen();; if (!L || !R); return nullptr;. switch (Op) {; case '+':; return Builder->CreateFAdd(L, R, ""addtmp"");; case '-':; return Builder->CreateFSub(L, R, ""subtmp"");; case '*':; return Builder->CreateFMul(L, R, ""multmp"");; case '<':; L = Builder->CreateFCmpULT(L, R, ""cmptmp"");; // C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:5771,simpl,simple,5771,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simple']
Usability,"=======; Modules; =======. .. contents::; :local:. Introduction; ============; Most software is built using a number of software libraries, including libraries supplied by the platform, internal libraries built as part of the software itself to provide structure, and third-party libraries. For each library, one needs to access both its interface (API) and its implementation. In the C family of languages, the interface to a library is accessed by including the appropriate header files(s):. .. code-block:: c. #include <SomeLib.h>. The implementation is handled separately by linking against the appropriate library. For example, by passing ``-lSomeLib`` to the linker. Modules provide an alternative, simpler way to use software libraries that provides better compile-time scalability and eliminates many of the problems inherent to using the C preprocessor to access the API of a library. Problems with the current model; -------------------------------; The ``#include`` mechanism provided by the C preprocessor is a very poor way to access the API of a library, for a number of reasons:. * **Compile-time scalability**: Each time a header is included, the; compiler must preprocess and parse the text in that header and every; header it includes, transitively. This process must be repeated for; every translation unit in the application, which involves a huge; amount of redundant work. In a project with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:705,simpl,simpler,705,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['simpl'],['simpler']
Usability,"=========. If clang successfully produces an executable, but that executable doesn't run; right, this is either a bug in the code or a bug in the compiler. The first; thing to check is to make sure it is not using undefined behavior (e.g.; reading a variable before it is defined). In particular, check to see if the; program is clean under various `sanitizers; <https://github.com/google/sanitizers>`_ (e.g. ``clang; -fsanitize=undefined,address``) and `valgrind <http://valgrind.org/>`_. Many; ""LLVM bugs"" that we have chased down ended up being bugs in the program being; compiled, not LLVM. Once you determine that the program itself is not buggy, you should choose; which code generator you wish to compile the program with (e.g. LLC or the JIT); and optionally a series of LLVM passes to run. For example:. .. code-block:: bash. bugpoint -run-llc [... optzn passes ...] file-to-test.bc --args -- [program arguments]. bugpoint will try to narrow down your list of passes to the one pass that; causes an error, and simplify the bitcode file as much as it can to assist; you. It will print a message letting you know how to reproduce the; resulting error. The :doc:`OptBisect <OptBisect>` page shows an alternative method for finding; incorrect optimization passes. Incorrect code generation; =========================. Similarly to debugging incorrect compilation by mis-behaving passes, you; can debug incorrect code generation by either LLC or the JIT, using; ``bugpoint``. The process ``bugpoint`` follows in this case is to try to; narrow the code down to a function that is miscompiled by one or the other; method, but since for correctness, the entire program must be run,; ``bugpoint`` will compile the code it deems to not be affected with the C; Backend, and then link in the shared object it generates. To debug the JIT:. .. code-block:: bash. bugpoint -run-jit -output=[correct output file] [bitcode file] \; --tool-args -- [arguments to pass to lli] \; --args -- [program arguments]. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst:8985,simpl,simplify,8985,interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,1,['simpl'],['simplify']
Usability,"=========. The next thing missing is handling of function prototypes. In; Kaleidoscope, these are used both for 'extern' function declarations as; well as function body definitions. The code to do this is; straight-forward and not very interesting (once you've survived; expressions):. .. code-block:: c++. /// prototype; /// ::= id '(' id* ')'; static std::unique_ptr<PrototypeAST> ParsePrototype() {; if (CurTok != tok_identifier); return LogErrorP(""Expected function name in prototype"");. std::string FnName = IdentifierStr;; getNextToken();. if (CurTok != '('); return LogErrorP(""Expected '(' in prototype"");. // Read the list of argument names.; std::vector<std::string> ArgNames;; while (getNextToken() == tok_identifier); ArgNames.push_back(IdentifierStr);; if (CurTok != ')'); return LogErrorP(""Expected ')' in prototype"");. // success.; getNextToken(); // eat ')'. return std::make_unique<PrototypeAST>(FnName, std::move(ArgNames));; }. Given this, a function definition is very simple, just a prototype plus; an expression to implement the body:. .. code-block:: c++. /// definition ::= 'def' prototype expression; static std::unique_ptr<FunctionAST> ParseDefinition() {; getNextToken(); // eat def.; auto Proto = ParsePrototype();; if (!Proto) return nullptr;. if (auto E = ParseExpression()); return std::make_unique<FunctionAST>(std::move(Proto), std::move(E));; return nullptr;; }. In addition, we support 'extern' to declare functions like 'sin' and; 'cos' as well as to support forward declaration of user functions. These; 'extern's are just prototypes with no body:. .. code-block:: c++. /// external ::= 'extern' prototype; static std::unique_ptr<PrototypeAST> ParseExtern() {; getNextToken(); // eat extern.; return ParsePrototype();; }. Finally, we'll also let the user type in arbitrary top-level expressions; and evaluate them on the fly. We will handle this by defining anonymous; nullary (zero argument) functions for them:. .. code-block:: c++. /// toplevelexpr ::= expressio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:21629,simpl,simple,21629,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['simpl'],['simple']
Usability,"=========; At first, let's define how exactly we compare complex objects. Complex object comparison (function, basic-block, etc) is mostly based on its; sub-object comparison results. It is similar to the next ""tree"" objects; comparison:. #. For two trees *T1* and *T2* we perform *depth-first-traversal* and have; two sequences as a product: ""*T1Items*"" and ""*T2Items*"". #. We then compare chains ""*T1Items*"" and ""*T2Items*"" in; the most-significant-item-first order. The result of items comparison; would be the result of *T1* and *T2* comparison itself. FunctionComparator::compare(void); ---------------------------------; A brief look at the source code tells us that the comparison starts in the; “``int FunctionComparator::compare(void)``” method. 1. The first parts to be compared are the function's attributes and some; properties that is outside the “attributes” term, but still could make the; function different without changing its body. This part of the comparison is; usually done within simple *cmpNumbers* or *cmpFlags* operations (e.g.; ``cmpFlags(F1->hasGC(), F2->hasGC())``). Below is a full list of function's; properties to be compared on this stage:. * *Attributes* (those are returned by ``Function::getAttributes()``; method). * *GC*, for equivalence, *RHS* and *LHS* should be both either without; *GC* or with the same one. * *Section*, just like a *GC*: *RHS* and *LHS* should be defined in the; same section. * *Variable arguments*. *LHS* and *RHS* should be both either with or; without *var-args*. * *Calling convention* should be the same. 2. Function type. Checked by ``FunctionComparator::cmpType(Type*, Type*)``; method. It checks return type and parameters type; the method itself will be; described later. 3. Associate function formal parameters with each other. Then comparing function; bodies, if we see the usage of *LHS*'s *i*-th argument in *LHS*'s body, then,; we want to see usage of *RHS*'s *i*-th argument at the same place in *RHS*'s; body, otherwise fun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:12206,simpl,simple,12206,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['simpl'],['simple']
Usability,"============; HLSL Support; ============. .. contents::; :local:. Introduction; ============. HLSL Support is under active development in the Clang codebase. This document; describes the high level goals of the project, the guiding principles, as well; as some idiosyncrasies of the HLSL language and how we intend to support them in; Clang. Project Goals; =============. The long term goal of this project is to enable Clang to function as a; replacement for the `DirectXShaderCompiler (DXC); <https://github.com/microsoft/DirectXShaderCompiler/>`_ in all its supported; use cases. Accomplishing that goal will require Clang to be able to process most; existing HLSL programs with a high degree of source compatibility. Non-Goals; ---------. HLSL ASTs do not need to be compatible between DXC and Clang. We do not expect; identical code generation or that features will resemble DXC's implementation or; architecture. In fact, we explicitly expect to deviate from DXC's implementation; in key ways. Guiding Principles; ==================. This document lacks details for architectural decisions that are not yet; finalized. Our top priorities are quality, maintainability, and flexibility. In; accordance with community standards we are expecting a high level of test; coverage, and we will engineer our solutions with long term maintenance in mind.; We are also working to limit modifications to the Clang C++ code paths and; share as much functionality as possible. Architectural Direction; =======================. HLSL support in Clang is expressed as C++ minus unsupported C and C++ features.; This is different from how other Clang languages are implemented. Most languages; in Clang are additive on top of C. HLSL is not a formally or fully specified language, and while our goals require; a high level of source compatibility, implementations can vary and we have some; flexibility to be more or less permissive in some cases. For modern HLSL DXC is; the reference implementation. The HLSL ef",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:224,guid,guiding,224,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,1,['guid'],['guiding']
Usability,"=============; Clang Plugins; =============. Clang Plugins make it possible to run extra user defined actions during a; compilation. This document will provide a basic walkthrough of how to write and; run a Clang Plugin. Introduction; ============. Clang Plugins run FrontendActions over code. See the :doc:`FrontendAction; tutorial <RAVFrontendAction>` on how to write a ``FrontendAction`` using the; ``RecursiveASTVisitor``. In this tutorial, we'll demonstrate how to write a; simple clang plugin. Writing a ``PluginASTAction``; =============================. The main difference from writing normal ``FrontendActions`` is that you can; handle plugin command line options. The ``PluginASTAction`` base class declares; a ``ParseArgs`` method which you have to implement in your plugin. .. code-block:: c++. bool ParseArgs(const CompilerInstance &CI,; const std::vector<std::string>& args) {; for (unsigned i = 0, e = args.size(); i != e; ++i) {; if (args[i] == ""-some-arg"") {; // Handle the command line argument.; }; }; return true;; }. Registering a plugin; ====================. A plugin is loaded from a dynamic library at runtime by the compiler. To; register a plugin in a library, use ``FrontendPluginRegistry::Add<>``:. .. code-block:: c++. static FrontendPluginRegistry::Add<MyPlugin> X(""my-plugin-name"", ""my plugin description"");. Defining pragmas; ================. Plugins can also define pragmas by declaring a ``PragmaHandler`` and; registering it using ``PragmaHandlerRegistry::Add<>``:. .. code-block:: c++. // Define a pragma handler for #pragma example_pragma; class ExamplePragmaHandler : public PragmaHandler {; public:; ExamplePragmaHandler() : PragmaHandler(""example_pragma"") { }; void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,; Token &PragmaTok) {; // Handle the pragma; }; };. static PragmaHandlerRegistry::Add<ExamplePragmaHandler> Y(""example_pragma"",""example pragma description"");. Defining attributes; ===================. Plugins can define attributes by",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:479,simpl,simple,479,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,1,['simpl'],['simple']
Usability,"==============; MyFirstTypoFix; ==============. .. contents::; :local:. Introduction; ============. This tutorial will guide you through the process of making a change to; LLVM, and contributing it back to the LLVM project. We'll be making a; change to Clang, but the steps for other parts of LLVM are the same.; Even though the change we'll be making is simple, we're going to cover; steps like building LLVM, running the tests, and code review. This is; good practice, and you'll be prepared for making larger changes. We'll assume you:. - know how to use an editor,. - have basic C++ knowledge,. - know how to install software on your system,. - are comfortable with the command line,. - have basic knowledge of git. The change we're making; -----------------------. Clang has a warning for infinite recursion:. .. code:: console. $ echo ""void foo() { foo(); }"" > ~/test.cc; $ clang -c -Wall ~/test.cc; input.cc:1:14: warning: all paths through this function will call; itself [-Winfinite-recursion]. This is clear enough, but not exactly catchy. Let's improve the wording; a little:. .. code:: console. input.cc:1:14: warning: to understand recursion, you must first; understand recursion [-Winfinite-recursion]. Dependencies; ------------. We're going to need some tools:. - git: to check out the LLVM source code,. - a C++ compiler: to compile LLVM source code. You'll want `a recent; version <https://llvm.org/docs/GettingStarted.html#host-c-toolchain-both-compiler-and-standard-library>`__; of Clang, GCC, or Visual Studio. - CMake: used to configure how LLVM should be built on your system,. - ninja: runs the C++ compiler to (re)build specific parts of LLVM,. - python: to run the LLVM tests,. As an example, on Ubuntu:. .. code:: console. $ sudo apt-get install git clang cmake ninja-build python arcanist. Building LLVM; =============. Checkout; --------. The source code is stored `on; Github <https://github.com/llvm/llvm-project>`__ in one large repository; (""the monorepo""). It may tak",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:119,guid,guide,119,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,2,"['guid', 'simpl']","['guide', 'simple']"
Usability,"==============; SanitizerStats; ==============. .. contents::; :local:. Introduction; ============. The sanitizers support a simple mechanism for gathering profiling statistics; to help understand the overhead associated with sanitizers. How to build and run; ====================. SanitizerStats can currently only be used with :doc:`ControlFlowIntegrity`.; In addition to ``-fsanitize=cfi*``, pass the ``-fsanitize-stats`` flag.; This will cause the program to count the number of times that each control; flow integrity check in the program fires. At run time, set the ``SANITIZER_STATS_PATH`` environment variable to direct; statistics output to a file. The file will be written on process exit.; The following substitutions will be applied to the environment variable:. - ``%b`` -- The executable basename.; - ``%p`` -- The process ID. You can also send the ``SIGUSR2`` signal to a process to make it write; sanitizer statistics immediately. The ``sanstats`` program can be used to dump statistics. It takes as a; command line argument the path to a statistics file produced by a program; compiled with ``-fsanitize-stats``. The output of ``sanstats`` is in four columns, separated by spaces. The first; column is the file and line number of the call site. The second column is; the function name. The third column is the type of statistic gathered (in; this case, the type of control flow integrity check). The fourth column is; the call count. Example:. .. code-block:: console. $ cat -n vcall.cc; 1 struct A {; 2 virtual void f() {}; 3 };; 4; 5 __attribute__((noinline)) void g(A *a) {; 6 a->f();; 7 }; 8; 9 int main() {; 10 A a;; 11 g(&a);; 12 }; $ clang++ -fsanitize=cfi -fvisibility=hidden -flto -fuse-ld=gold vcall.cc -fsanitize-stats -g; $ SANITIZER_STATS_PATH=a.stats ./a.out; $ sanstats a.stats; vcall.cc:6 _Z1gP1A cfi-vcall 1; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst:125,simpl,simple,125,interpreter/llvm-project/clang/docs/SanitizerStats.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst,1,['simpl'],['simple']
Usability,"===============. .. contents::; :local:. **This tutorial is under active development. It is incomplete and details may; change frequently.** Nonetheless we invite you to try it out as it stands, and; we welcome any feedback. Chapter 2 Introduction; ======================. **Warning: This tutorial is currently being updated to account for ORC API; changes. Only Chapters 1 and 2 are up-to-date.**. **Example code from Chapters 3 to 5 will compile and run, but has not been; updated**. Welcome to Chapter 2 of the ""Building an ORC-based JIT in LLVM"" tutorial. In; `Chapter 1 <BuildingAJIT1.html>`_ of this series we examined a basic JIT; class, KaleidoscopeJIT, that could take LLVM IR modules as input and produce; executable code in memory. KaleidoscopeJIT was able to do this with relatively; little code by composing two off-the-shelf *ORC layers*: IRCompileLayer and; ObjectLinkingLayer, to do much of the heavy lifting. In this layer we'll learn more about the ORC layer concept by using a new layer,; IRTransformLayer, to add IR optimization support to KaleidoscopeJIT. Optimizing Modules using the IRTransformLayer; =============================================. In `Chapter 4 <LangImpl04.html>`_ of the ""Implementing a language with LLVM""; tutorial series the llvm *FunctionPassManager* is introduced as a means for; optimizing LLVM IR. Interested readers may read that chapter for details, but; in short: to optimize a Module we create an llvm::FunctionPassManager; instance, configure it with a set of optimizations, then run the PassManager on; a Module to mutate it into a (hopefully) more optimized but semantically; equivalent form. In the original tutorial series the FunctionPassManager was; created outside the KaleidoscopeJIT and modules were optimized before being; added to it. In this Chapter we will make optimization a phase of our JIT; instead. For now this will provide us a motivation to learn more about ORC; layers, but in the long term making optimization part of our JIT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:1142,learn,learn,1142,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['learn'],['learn']
Usability,"===============; Support Library; ===============. Abstract; ========. This document provides some details on LLVM's Support Library, located in the; source at ``lib/Support`` and ``include/llvm/Support``. The library's purpose; is to shield LLVM from the differences between operating systems for the few; services LLVM needs from the operating system. Much of LLVM is written using; portability features of standard C++. However, in a few areas, system dependent; facilities are needed and the Support Library is the wrapper around those; system calls. By centralizing LLVM's use of operating system interfaces, we make it possible; for the LLVM tool chain and runtime libraries to be more easily ported to new; platforms since (theoretically) only ``lib/Support`` needs to be ported. This; library also unclutters the rest of LLVM from #ifdef use and special cases for; specific operating systems. Such uses are replaced with simple calls to the; interfaces provided in ``include/llvm/Support``. Note that the Support Library is not intended to be a complete operating system; wrapper (such as the Adaptive Communications Environment (ACE) or Apache; Portable Runtime (APR)), but only provides the functionality necessary to; support LLVM. The Support Library was originally referred to as the System Library, written; by Reid Spencer who formulated the design based on similar work originating; from the eXtensible Programming System (XPS). Several people helped with the; effort; especially, Jeff Cohen and Henrik Bach on the Win32 port. Keeping LLVM Portable; =====================. In order to keep LLVM portable, LLVM developers should adhere to a set of; portability rules associated with the Support Library. Adherence to these rules; should help the Support Library achieve its goal of shielding LLVM from the; variations in operating system interfaces and doing so efficiently. The; following sections define the rules needed to fulfill this objective. Don't Include System Headers; ------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:929,simpl,simple,929,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['simpl'],['simple']
Usability,"=================; SanitizerCoverage; =================. .. contents::; :local:. Introduction; ============. LLVM has a simple code coverage instrumentation built in (SanitizerCoverage).; It inserts calls to user-defined functions on function-, basic-block-, and edge- levels.; Default implementations of those callbacks are provided and implement; simple coverage reporting and visualization,; however if you need *just* coverage visualization you may want to use; :doc:`SourceBasedCodeCoverage <SourceBasedCodeCoverage>` instead. Tracing PCs with guards; =======================. With ``-fsanitize-coverage=trace-pc-guard`` the compiler will insert the following code; on every edge:. .. code-block:: none. __sanitizer_cov_trace_pc_guard(&guard_variable). Every edge will have its own `guard_variable` (uint32_t). The compiler will also insert calls to a module constructor:. .. code-block:: c++. // The guards are [start, stop).; // This function will be called at least once per DSO and may be called; // more than once with the same values of start/stop.; __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop);. With an additional ``...=trace-pc,indirect-calls`` flag; ``__sanitizer_cov_trace_pc_indirect(void *callee)`` will be inserted on every indirect call. The functions `__sanitizer_cov_trace_pc_*` should be defined by the user. Example:. .. code-block:: c++. // trace-pc-guard-cb.cc; #include <stdint.h>; #include <stdio.h>; #include <sanitizer/coverage_interface.h>. // This callback is inserted by the compiler as a module constructor; // into every DSO. 'start' and 'stop' correspond to the; // beginning and end of the section with the guards for the entire; // binary (executable or DSO). The callback will be called at least; // once per DSO and may be called multiple times with the same parameters.; extern ""C"" void __sanitizer_cov_trace_pc_guard_init(uint32_t *start,; uint32_t *stop) {; static uint64_t N; // Counter for the guards.; if (start == stop || *start) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:120,simpl,simple,120,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,2,['simpl'],['simple']
Usability,"===================; Misexpect; ===================; .. contents::. .. toctree::; :maxdepth: 1. When developers use ``llvm.expect`` intrinsics, i.e., through use of; ``__builtin_expect(...)``, they are trying to communicate how their code is; expected to behave at runtime to the optimizer. These annotations, however, can; be incorrect for a variety of reasons: changes to the code base invalidate them; silently, the developer mis-annotated them (e.g., using ``LIKELY`` instead of; ``UNLIKELY``), or perhaps they assumed something incorrectly when they wrote; the annotation. Regardless of why, it is useful to detect these situations so; that the optimizer can make more useful decisions about the code. MisExpect; diagnostics are intended to help developers identify and address these; situations, by comparing the use of the ``llvm.expect`` intrinsic to the ground; truth provided by a profiling input. The MisExpect checks in the LLVM backend follow a simple procedure: if there is; a mismatch between the branch weights collected during profiling and those; supplied by an ``llvm.expect`` intrinsic, then it will emit a diagnostic; message to the user. The most natural place to perform the verification is just prior to when; branch weights are assigned to the target instruction in the form of; branch weight metadata. There are 3 key places in the LLVM backend where branch weights are; created and assigned based on profiling information or the use of the; ``llvm.expect`` intrinsic, and our implementation focuses on these; places to perform the verification. We calculate the threshold for emitting MisExpect related diagnostics; based on the values the compiler assigns to ``llvm.expect`` intrinsics,; which can be set through the ``-likely-branch-weight`` and; ``-unlikely-branch-weight`` LLVM options. During verification, if the; profile weights mismatch the calculated threshold, then we will emit a; remark or warning detailing a potential performance regression. The; diagnostic al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MisExpect.rst:958,simpl,simple,958,interpreter/llvm-project/llvm/docs/MisExpect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MisExpect.rst,1,['simpl'],['simple']
Usability,"====================; Objective-C Literals; ====================. Introduction; ============. Three new features were introduced into clang at the same time:; *NSNumber Literals* provide a syntax for creating ``NSNumber`` from; scalar literal expressions; *Collection Literals* provide a short-hand; for creating arrays and dictionaries; *Object Subscripting* provides a; way to use subscripting with Objective-C objects. Users of Apple; compiler releases can use these features starting with the Apple LLVM; Compiler 4.0. Users of open-source LLVM.org compiler releases can use; these features starting with clang v3.1. These language additions simplify common Objective-C programming; patterns, make programs more concise, and improve the safety of; container creation. This document describes how the features are implemented in clang, and; how to use them in your own programs. NSNumber Literals; =================. The framework class ``NSNumber`` is used to wrap scalar values inside; objects: signed and unsigned integers (``char``, ``short``, ``int``,; ``long``, ``long long``), floating point numbers (``float``,; ``double``), and boolean values (``BOOL``, C++ ``bool``). Scalar values; wrapped in objects are also known as *boxed* values. In Objective-C, any character, numeric or boolean literal prefixed with; the ``'@'`` character will evaluate to a pointer to an ``NSNumber``; object initialized with that value. C's type suffixes may be used to; control the size of numeric literals. Examples; --------. The following program illustrates the rules for ``NSNumber`` literals:. .. code-block:: objc. void main(int argc, const char *argv[]) {; // character literals.; NSNumber *theLetterZ = @'Z'; // equivalent to [NSNumber numberWithChar:'Z']. // integral literals.; NSNumber *fortyTwo = @42; // equivalent to [NSNumber numberWithInt:42]; NSNumber *fortyTwoUnsigned = @42U; // equivalent to [NSNumber numberWithUnsignedInt:42U]; NSNumber *fortyTwoLong = @42L; // equivalent to [NSNumber n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:646,simpl,simplify,646,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['simpl'],['simplify']
Usability,"=====================; LLVM Coding Standards; =====================. .. contents::; :local:. Introduction; ============. This document describes coding standards that are used in the LLVM project.; Although no coding standards should be regarded as absolute requirements to be; followed in all instances, coding standards are; particularly important for large-scale code bases that follow a library-based; design (like LLVM). While this document may provide guidance for some mechanical formatting issues,; whitespace, or other ""microscopic details"", these are not fixed standards.; Always follow the golden rule:. .. _Golden Rule:. **If you are extending, enhancing, or bug fixing already implemented code,; use the style that is already being used so that the source is uniform and; easy to follow.**. Note that some code bases (e.g. ``libc++``) have special reasons to deviate; from the coding standards. For example, in the case of ``libc++``, this is; because the naming and other conventions are dictated by the C++ standard. There are some conventions that are not uniformly followed in the code base; (e.g. the naming convention). This is because they are relatively new, and a; lot of code was written before they were put in place. Our long term goal is; for the entire codebase to follow the convention, but we explicitly *do not*; want patches that do large-scale reformatting of existing code. On the other; hand, it is reasonable to rename the methods of a class if you're about to; change it in some other way. Please commit such changes separately to; make code review easier. The ultimate goal of these guidelines is to increase the readability and; maintainability of our common source base. Languages, Libraries, and Standards; ===================================. Most source code in LLVM and other LLVM projects using these coding standards; is C++ code. There are some places where C code is used either due to; environment restrictions, historical restrictions, or due to third-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:458,guid,guidance,458,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['guid'],['guidance']
Usability,"=====================; LLVM Developer Policy; =====================. .. contents::; :local:. Introduction; ============. This document contains the LLVM Developer Policy which defines the project's; policy towards developers and their contributions. The intent of this policy is; to eliminate miscommunication, rework, and confusion that might arise from the; distributed nature of LLVM's development. By stating the policy in clear terms,; we hope each developer can know ahead of time what to expect when making LLVM; contributions. This policy covers all llvm.org subprojects, including Clang,; LLDB, libc++, etc. This policy is also designed to accomplish the following objectives:. #. Attract both users and developers to the LLVM project. #. Make life as simple and easy for contributors as possible. #. Keep the top of tree as stable as possible. #. Establish awareness of the project's :ref:`copyright, license, and patent; policies <copyright-license-patents>` with contributors to the project. This policy is aimed at frequent contributors to LLVM. People interested in; contributing one-off patches can do so in an informal way by sending them to the; `llvm-commits mailing list; <http://lists.llvm.org/mailman/listinfo/llvm-commits>`_ and engaging another; developer to see it through the process. Developer Policies; ==================. This section contains policies that pertain to frequent LLVM developers. We; always welcome `one-off patches`_ from people who do not routinely contribute to; LLVM, but we expect more from frequent contributors to keep the system as; efficient as possible for everyone. Frequent LLVM contributors are expected to; meet the following requirements in order for LLVM to maintain a high standard of; quality. Stay Informed; -------------. Developers should stay informed by reading the `LLVM Discourse forums`_ and subscribing; to the categories of interest for notifications. Paying attention to changes being made by others is a good way to see what oth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:427,clear,clear,427,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,2,"['clear', 'simpl']","['clear', 'simple']"
Usability,"=====================; YAML I/O; =====================. .. contents::; :local:. Introduction to YAML; ====================. YAML is a human readable data serialization language. The full YAML language; spec can be read at `yaml.org; <http://www.yaml.org/spec/1.2/spec.html#Introduction>`_. The simplest form of; yaml is just ""scalars"", ""mappings"", and ""sequences"". A scalar is any number; or string. The pound/hash symbol (#) begins a comment line. A mapping is; a set of key-value pairs where the key ends with a colon. For example:. .. code-block:: yaml. # a mapping; name: Tom; hat-size: 7. A sequence is a list of items where each item starts with a leading dash ('-').; For example:. .. code-block:: yaml. # a sequence; - x86; - x86_64; - PowerPC. You can combine mappings and sequences by indenting. For example a sequence; of mappings in which one of the mapping values is itself a sequence:. .. code-block:: yaml. # a sequence of mappings with one key's value being a sequence; - name: Tom; cpus:; - x86; - x86_64; - name: Bob; cpus:; - x86; - name: Dan; cpus:; - PowerPC; - x86. Sometime sequences are known to be short and the one entry per line is too; verbose, so YAML offers an alternate syntax for sequences called a ""Flow; Sequence"" in which you put comma separated sequence elements into square; brackets. The above example could then be simplified to :. .. code-block:: yaml. # a sequence of mappings with one key's value being a flow sequence; - name: Tom; cpus: [ x86, x86_64 ]; - name: Bob; cpus: [ x86 ]; - name: Dan; cpus: [ PowerPC, x86 ]. Introduction to YAML I/O; ========================. The use of indenting makes the YAML easy for a human to read and understand,; but having a program read and write YAML involves a lot of tedious details.; The YAML I/O library structures and simplifies reading and writing YAML; documents. YAML I/O assumes you have some ""native"" data structures which you want to be; able to dump as YAML and recreate from YAML. The first step is to try",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:294,simpl,simplest,294,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['simpl'],['simplest']
Usability,"======================; Matching the Clang AST; ======================. This document explains how to use Clang's LibASTMatchers to match interesting; nodes of the AST and execute code that uses the matched nodes. Combined with; :doc:`LibTooling`, LibASTMatchers helps to write code-to-code transformation; tools or query tools. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create tutorial and link to the tutorial. Introduction; ------------. LibASTMatchers provides a domain specific language to create predicates on; Clang's AST. This DSL is written in and can be used from C++, allowing users; to write a single program to both match AST nodes and access the node's C++; interface to extract attributes, source locations, or any other information; provided on the AST level. AST matchers are predicates on nodes in the AST. Matchers are created by; calling creator functions that allow building up a tree of matchers, where; inner matchers are used to make the match more specific. For example, to create a matcher that matches all class or union declarations; in the AST of a translation unit, you can call `recordDecl(); <LibASTMatchersReference.html#recordDecl0Anchor>`_. To narrow the match down,; for example to find all class or union declarations with the name ""``Foo``"",; insert a `hasName <LibASTMatchersReference.html#hasName0Anchor>`_ matcher: the; call ``recordDecl(hasName(""Foo""))`` returns a matcher that matches classes or; unions that are named ""``Foo``"", in any namespace. By default, matchers that; accept multiple inner matchers use an implicit `allOf(); <LibASTMatchersReference.html#allOf0Anchor>`_. This allows further narrowing; down the match, for example to match all classes that are derived from; ""``Bar``"": ``recordDecl(hasName(""Foo""), isDerivedFrom(""Bar""))``. How to create a matcher; -----------------------. With more th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst:465,learn,learn,465,interpreter/llvm-project/clang/docs/LibASTMatchers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst,1,['learn'],['learn']
Usability,"=======================; External Clang Examples; =======================. Introduction; ============. This page provides some examples of the kinds of things that people have; done with Clang that might serve as useful guides (or starting points) from; which to develop your own tools. They may be helpful even for something as; banal (but necessary) as how to set up your build to integrate Clang. Clang's library-based design is deliberately aimed at facilitating use by; external projects, and we are always interested in improving Clang to; better serve our external users. Some typical categories of applications; where Clang is used are:. - Static analysis.; - Documentation/cross-reference generation. If you know of (or wrote!) a tool or project using Clang, please post on; `the Discourse forums (Clang Frontend category); <https://discourse.llvm.org/c/clang/6>`_ to have it added.; (or if you are already a Clang contributor, feel free to directly commit; additions). Since the primary purpose of this page is to provide examples; that can help developers, generally they must have code available. List of projects and tools; ==========================. `<https://github.com/Andersbakken/rtags/>`_; ""RTags is a client/server application that indexes c/c++ code and keeps; a persistent in-memory database of references, symbolnames, completions; etc."". `<https://rprichard.github.io/CxxCodeBrowser/>`_; ""A C/C++ source code indexer and navigator"". `<https://github.com/etaoins/qconnectlint>`_; ""qconnectlint is a Clang tool for statically verifying the consistency; of signal and slot connections made with Qt's ``QObject::connect``."". `<https://github.com/woboq/woboq_codebrowser>`_; ""The Woboq Code Browser is a web-based code browser for C/C++ projects.; Check out `<https://code.woboq.org/>`_ for an example!"". `<https://github.com/mozilla/dxr>`_; ""DXR is a source code cross-reference tool that uses static analysis; data collected by instrumented compilers."". `<https://github.com/esch",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:220,guid,guides,220,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,1,['guid'],['guides']
Usability,"=======================; Writing an LLVM Backend; =======================. .. toctree::; :hidden:. HowToUseInstrMappings. .. contents::; :local:. Introduction; ============. This document describes techniques for writing compiler backends that convert; the LLVM Intermediate Representation (IR) to code for a specified machine or; other languages. Code intended for a specific machine can take the form of; either assembly code or binary code (usable for a JIT compiler). The backend of LLVM features a target-independent code generator that may; create output for several types of target CPUs --- including X86, PowerPC,; ARM, and SPARC. The backend may also be used to generate code targeted at SPUs; of the Cell processor or GPUs to support the execution of compute kernels. The document focuses on existing examples found in subdirectories of; ``llvm/lib/Target`` in a downloaded LLVM release. In particular, this document; focuses on the example of creating a static compiler (one that emits text; assembly) for a SPARC target, because SPARC has fairly standard; characteristics, such as a RISC instruction set and straightforward calling; conventions. Audience; --------. The audience for this document is anyone who needs to write an LLVM backend to; generate code for a specific hardware or software target. Prerequisite Reading; --------------------. These essential documents must be read before reading this document:. * `LLVM Language Reference Manual <LangRef.html>`_ --- a reference manual for; the LLVM assembly language. * :doc:`CodeGenerator` --- a guide to the components (classes and code; generation algorithms) for translating the LLVM internal representation into; machine code for a specified target. Pay particular attention to the; descriptions of code generation stages: Instruction Selection, Scheduling and; Formation, SSA-based Optimization, Register Allocation, Prolog/Epilog Code; Insertion, Late Machine Code Optimizations, and Code Emission. * :doc:`TableGen/index` --",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:444,usab,usable,444,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['usab'],['usable']
Usability,"========================. From LLVM 3.5 onwards the CMake build system exports LLVM libraries as; importable CMake targets. This means that clients of LLVM can now reliably use; CMake to develop their own LLVM-based projects against an installed version of; LLVM regardless of how it was built. Here is a simple example of a CMakeLists.txt file that imports the LLVM libraries; and uses them to build a simple application ``simple-tool``. .. code-block:: cmake. cmake_minimum_required(VERSION 3.20.0); project(SimpleProject). find_package(LLVM REQUIRED CONFIG). message(STATUS ""Found LLVM ${LLVM_PACKAGE_VERSION}""); message(STATUS ""Using LLVMConfig.cmake in: ${LLVM_DIR}""). # Set your project compile flags.; # E.g. if using the C++ header files; # you will need to enable C++11 support; # for your compiler. include_directories(${LLVM_INCLUDE_DIRS}); separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS}); add_definitions(${LLVM_DEFINITIONS_LIST}). # Now build our tools; add_executable(simple-tool tool.cpp). # Find the libraries that correspond to the LLVM components; # that we wish to use; llvm_map_components_to_libnames(llvm_libs support core irreader). # Link against LLVM libraries; target_link_libraries(simple-tool ${llvm_libs}). The ``find_package(...)`` directive when used in CONFIG mode (as in the above; example) will look for the ``LLVMConfig.cmake`` file in various locations (see; cmake manual for details). It creates a ``LLVM_DIR`` cache entry to save the; directory where ``LLVMConfig.cmake`` is found or allows the user to specify the; directory (e.g. by passing ``-DLLVM_DIR=/usr/lib/cmake/llvm`` to; the ``cmake`` command or by setting it directly in ``ccmake`` or ``cmake-gui``). This file is available in two different locations. * ``<LLVM_INSTALL_PACKAGE_DIR>/LLVMConfig.cmake`` where; ``<LLVM_INSTALL_PACKAGE_DIR>`` is the location where LLVM CMake modules are; installed as part of an installed version of LLVM. This is typically; ``cmake/llvm/`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:41838,simpl,simple-tool,41838,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['simpl'],['simple-tool']
Usability,"=========================; Compiling CUDA with clang; =========================. .. contents::; :local:. Introduction; ============. This document describes how to compile CUDA code with clang, and gives some; details about LLVM and clang's CUDA implementations. This document assumes a basic familiarity with CUDA. Information about CUDA; programming can be found in the; `CUDA programming guide; <http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html>`_. Compiling CUDA Code; ===================. Prerequisites; -------------. CUDA is supported since llvm 3.9. Clang currently supports CUDA 7.0 through; 12.1. If clang detects a newer CUDA version, it will issue a warning and will; attempt to use detected CUDA SDK it as if it were CUDA 12.1. Before you build CUDA code, you'll need to have installed the CUDA SDK. See; `NVIDIA's CUDA installation guide; <https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html>`_ for; details. Note that clang `maynot support; <https://bugs.llvm.org/show_bug.cgi?id=26966>`_ the CUDA toolkit as installed by; some Linux package managers. Clang does attempt to deal with specific details of; CUDA installation on a handful of common Linux distributions, but in general the; most reliable way to make it work is to install CUDA in a single directory from; NVIDIA's `.run` package and specify its location via `--cuda-path=...` argument. CUDA compilation is supported on Linux. Compilation on MacOS and Windows may or; may not work and currently have no maintainers. Invoking clang; --------------. Invoking clang for CUDA compilation works similarly to compiling regular C++.; You just need to be aware of a few additional flags. You can use `this <https://gist.github.com/855e277884eb6b388cd2f00d956c2fd4>`_; program as a toy example. Save it as ``axpy.cu``. (Clang detects that you're; compiling CUDA code by noticing that your filename ends with ``.cu``.; Alternatively, you can pass ``-x cuda``.). To build and run, run the following com",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst:391,guid,guide,391,interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,4,['guid'],"['guide', 'guide-linux']"
Usability,"=========================; Dependence Graphs in LLVM; =========================. .. contents::; :local:. Introduction; ============; Dependence graphs are useful tools in compilers for analyzing relationships; between various program elements to help guide optimizations. The ideas; behind these graphs are described in papers [1]_ and [2]_. The implementation of these ideas in LLVM may be slightly different than; what is mentioned in the papers. These differences are documented in; the `implementation details <implementation-details_>`_. .. _DataDependenceGraph:. Data Dependence Graph; =====================; In its simplest form the Data Dependence Graph (or DDG) represents data; dependencies between individual instructions. Each node in such a graph; represents a single instruction and is referred to as an ""atomic"" node.; It is also possible to combine some atomic nodes that have a simple; def-use dependency between them into larger nodes that contain multiple-; instructions. As described in [1]_ the DDG uses graph abstraction to group nodes; that are part of a strongly connected component of the graph; into special nodes called pi-blocks. pi-blocks represent cycles of data; dependency that prevent reordering transformations. Since any strongly; connected component of the graph is a maximal subgraph of all the nodes; that form a cycle, pi-blocks are at most one level deep. In other words,; no pi-blocks are nested inside another pi-block, resulting in a; hierarchical representation that is at most one level deep. For example, consider the following:. .. code-block:: c++. for (int i = 1; i < n; i++) {; b[i] = c[i] + b[i-1];; }. This code contains a statement that has a loop carried dependence on; itself creating a cycle in the DDG. The figure below illustrates; how the cycle of dependency is carried through multiple def-use relations; and a memory access dependency. .. image:: cycle.png. The DDG corresponding to this example would have a pi-block that contains; all the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:251,guid,guide,251,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,3,"['guid', 'simpl']","['guide', 'simple', 'simplest']"
Usability,"==========================; Clang's refactoring engine; ==========================. This document describes the design of Clang's refactoring engine and provides; a couple of examples that show how various primitives in the refactoring API; can be used to implement different refactoring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer supp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:883,learn,learn,883,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['learn'],['learn']
Usability,==========================; Performance Training Data; ==========================. This directory contains simple source files for use as training data for; generating PGO data and linker order files for clang.; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/README.txt:107,simpl,simple,107,interpreter/llvm-project/clang/utils/perf-training/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/README.txt,1,['simpl'],['simple']
Usability,"===============================; ASTImporter: Merging Clang ASTs; ===============================. The ``ASTImporter`` class is part of Clang's core library, the AST library.; It imports nodes of an ``ASTContext`` into another ``ASTContext``. In this document, we assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured.; Knowledge about :doc:`matching the Clang AST <LibASTMatchers>` and the `reference for the matchers <https://clang.llvm.org/docs/LibASTMatchersReference.html>`_ are also useful. .. contents::; :local:. Introduction; ------------. ``ASTContext`` holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic analysis of a file.; In some cases it is preferable to work with more than one ``ASTContext``.; For example, we'd like to parse multiple different files inside the same Clang tool.; It may be convenient if we could view the set of the resulting ASTs as if they were one AST resulting from the parsing of each file together.; ``ASTImporter`` provides the way to copy types or declarations from one ``ASTContext`` to another.; We refer to the context from which we import as the **""from"" context** or *source context*; and the context into which we import as the **""to"" context** or *destination context*. Existing clients of the ``ASTImporter`` library are Cross Translation Unit (CTU) static analysis and the LLDB expression parser.; CTU static analysis imports a definition of a function if its definition is found in another translation unit (TU).; This way the analysis can breach out from the single TU limitation.; LLDB's ``expr`` command parses a user-defined expression, creates an ``ASTContext`` for that and then imports the missing definitions from the AST what we got from the debug information (DWARF, etc). Algorithm of the import; -----------------------. Importing one AST node copies that node int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:397,learn,learn,397,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,1,['learn'],['learn']
Usability,"===============================; ORC Design and Implementation; ===============================. .. contents::; :local:. Introduction; ============. This document aims to provide a high-level overview of the design and; implementation of the ORC JIT APIs. Except where otherwise stated all discussion; refers to the modern ORCv2 APIs (available since LLVM 7). Clients wishing to; transition from OrcV1 should see Section :ref:`transitioning_orcv1_to_orcv2`. Use-cases; =========. ORC provides a modular API for building JIT compilers. There are a number; of use cases for such an API. For example:. 1. The LLVM tutorials use a simple ORC-based JIT class to execute expressions; compiled from a toy language: Kaleidoscope. 2. The LLVM debugger, LLDB, uses a cross-compiling JIT for expression; evaluation. In this use case, cross compilation allows expressions compiled; in the debugger process to be executed on the debug target process, which may; be on a different device/architecture. 3. In high-performance JITs (e.g. JVMs, Julia) that want to make use of LLVM's; optimizations within an existing JIT infrastructure. 4. In interpreters and REPLs, e.g. Cling (C++) and the Swift interpreter. By adopting a modular, library-based design we aim to make ORC useful in as many; of these contexts as possible. Features; ========. ORC provides the following features:. **JIT-linking**; ORC provides APIs to link relocatable object files (COFF, ELF, MachO) [1]_; into a target process at runtime. The target process may be the same process; that contains the JIT session object and jit-linker, or may be another process; (even one running on a different machine or architecture) that communicates; with the JIT via RPC. **LLVM IR compilation**; ORC provides off the shelf components (IRCompileLayer, SimpleCompiler,; ConcurrentIRCompiler) that make it easy to add LLVM IR to a JIT'd process. **Eager and lazy compilation**; By default, ORC will compile symbols as soon as they are looked up in the JIT; se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:627,simpl,simple,627,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['simpl'],['simple']
Usability,"===============================; TableGen Programmer's Reference; ===============================. .. sectnum::. .. contents::; :local:. Introduction; ============. The purpose of TableGen is to generate complex output files based on; information from source files that are significantly easier to code than the; output files would be, and also easier to maintain and modify over time. The; information is coded in a declarative style involving classes and records,; which are then processed by TableGen. The internalized records are passed on; to various *backends*, which extract information from a subset of the records; and generate one or more output files. These output files are typically; ``.inc`` files for C++, but may be any type of file that the backend; developer needs. This document describes the LLVM TableGen facility in detail. It is intended; for the programmer who is using TableGen to produce code for a project. If; you are looking for a simple overview, check out the :doc:`TableGen Overview; <./index>`. The various ``*-tblgen`` commands used to invoke TableGen are; described in :doc:`tblgen Family - Description to C++; Code<../CommandGuide/tblgen>`. An example of a backend is ``RegisterInfo``, which generates the register; file information for a particular target machine, for use by the LLVM; target-independent code generator. See :doc:`TableGen Backends <./BackEnds>`; for a description of the LLVM TableGen backends, and :doc:`TableGen; Backend Developer's Guide <./BackGuide>` for a guide to writing a new; backend. Here are a few of the things backends can do. * Generate the register file information for a particular target machine. * Generate the instruction definitions for a target. * Generate the patterns that the code generator uses to match instructions; to intermediate representation (IR) nodes. * Generate semantic attribute identifiers for Clang. * Generate abstract syntax tree (AST) declaration node definitions for Clang. * Generate AST statement nod",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:960,simpl,simple,960,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,"===============================; lit - A Software Testing Tool; ===============================. About; =====. *lit* is a portable tool for executing LLVM and Clang style test suites,; summarizing their results, and providing indication of failures. *lit* is; designed to be a lightweight testing tool with as simple a user interface as; possible. Features; ========. * Portable!; * Flexible test discovery.; * Parallel test execution.; * Support for multiple test formats and test suite designs. Documentation; =============. The official *lit* documentation is in the man page, available online at the LLVM; Command Guide: http://llvm.org/cmds/lit.html. Source; ======. The *lit* source is available as part of LLVM, in the LLVM source repository:; https://github.com/llvm/llvm-project/tree/main/llvm/utils/lit. Contributing to lit; ===================. Please browse the issues labeled *tools:llvm-lit* in LLVM's issue tracker for; ideas on what to work on:; https://github.com/llvm/llvm-project/labels/tools%3Allvm-lit. Before submitting patches, run the test suite to ensure nothing has regressed::. # From within your LLVM source directory.; utils/lit/lit.py \; --path /path/to/your/llvm/build/bin \; utils/lit/tests. Note that lit's tests depend on ``not`` and ``FileCheck``, LLVM utilities.; You will need to have built LLVM tools in order to run lit's test suite; successfully. You'll also want to confirm that lit continues to work when testing LLVM.; Follow the instructions in http://llvm.org/docs/TestingGuide.html to run the; regression test suite:. make check-llvm. And be sure to run the llvm-lit wrapper script as well:. /path/to/your/llvm/build/bin/llvm-lit utils/lit/tests. Finally, make sure lit works when installed via setuptools:. python utils/lit/setup.py install; lit --path /path/to/your/llvm/build/bin utils/lit/tests. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/README.rst:310,simpl,simple,310,interpreter/llvm-project/llvm/utils/lit/README.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/README.rst,1,['simpl'],['simple']
Usability,"================================; LLVM Tutorial: Table of Contents; ================================. Kaleidoscope: Implementing a Language with LLVM; ===============================================. .. toctree::; :hidden:. MyFirstLanguageFrontend/index. :doc:`MyFirstLanguageFrontend/index`; This is the ""Kaleidoscope"" Language tutorial, showing how to implement a simple; language using LLVM components in C++. .. toctree::; :titlesonly:; :glob:; :numbered:. MyFirstLanguageFrontend/LangImpl*. Building a JIT in LLVM; ===============================================. .. toctree::; :titlesonly:; :glob:; :numbered:. BuildingAJIT*. External Tutorials; ==================. `Tutorial: Creating an LLVM Backend for the Cpu0 Architecture <http://jonathan2251.github.io/lbd/>`_; A step-by-step tutorial for developing an LLVM backend. Under; active development at `<https://github.com/Jonathan2251/lbd>`_ (please; contribute!). `Howto: Implementing LLVM Integrated Assembler`_; A simple guide for how to implement an LLVM integrated assembler for an; architecture. .. _`Howto: Implementing LLVM Integrated Assembler`: http://www.embecosm.com/appnotes/ean10/ean10-howto-llvmas-1.0.html. Advanced Topics; ===============. #. `Writing an Optimization for LLVM <https://llvm.org/pubs/2004-09-22-LCPCLLVMTutorial.html>`_. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/index.rst:366,simpl,simple,366,interpreter/llvm-project/llvm/docs/tutorial/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/index.rst,3,"['guid', 'simpl']","['guide', 'simple']"
Usability,"=================================; How To Release LLVM To The Public; =================================. Introduction; ============. This document contains information about successfully releasing LLVM ---; including sub-projects: e.g., ``clang`` and ``compiler-rt`` --- to the public.; It is the Release Manager's responsibility to ensure that a high quality build; of LLVM is released. If you're looking for the document on how to test the release candidates and; create the binary packages, please refer to the :doc:`ReleaseProcess` instead. .. _timeline:. Release Timeline; ================. LLVM is released on a time based schedule --- with major releases roughly; every 6 months. In between major releases there may be dot releases.; The release manager will determine if and when to make a dot release based; on feedback from the community. Typically, dot releases should be made if; there are large number of bug-fixes in the stable branch or a critical bug; has been discovered that affects a large number of users. Unless otherwise stated, dot releases will follow the same procedure as; major releases. Annual Release Schedule; -----------------------. Here is the annual release schedule for LLVM. This is meant to be a; guide, and release managers are not required to follow this exactly.; Releases should be tagged on Tuesdays. =============================== =========================; Release Approx. Date; =============================== =========================; *release branch: even releases* *4th Tue in January*; *release branch: odd releases* *4th Tue in July*; X.1.0-rc1 3 days after branch.; X.1.0-rc2 2 weeks after branch.; X.1.0-rc3 4 weeks after branch; **X.1.0-final** **6 weeks after branch**; **X.1.1** **8 weeks after branch**; **X.1.2** **10 weeks after branch**; **X.1.3** **12 weeks after branch**; **X.1.4** **14 weeks after branch**; **X.1.5** **16 weeks after branch**; **X.1.6 (if necessary)** **18 weeks after branch**; =============================== =======",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:820,feedback,feedback,820,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['feedback'],['feedback']
Usability,"=================================; MergeFunctions pass, how it works; =================================. .. contents::; :local:. Introduction; ============; Sometimes code contains equal functions, or functions that does exactly the same; thing even though they are non-equal on the IR level (e.g.: multiplication on 2; and 'shl 1'). It could happen due to several reasons: mainly, the usage of; templates and automatic code generators. Though, sometimes the user itself could; write the same thing twice :-). The main purpose of this pass is to recognize such functions and merge them. This document is the extension to pass comments and describes the pass logic. It; describes the algorithm that is used in order to compare functions and; explains how we could combine equal functions correctly to keep the module; valid. Material is brought in a top-down form, so the reader could start to learn pass; from high level ideas and end with low-level algorithm details, thus preparing; him or her for reading the sources. The main goal is to describe the algorithm and logic here and the concept. If; you *don't want* to read the source code, but want to understand pass; algorithms, this document is good for you. The author tries not to repeat the; source-code and covers only common cases to avoid the cases of needing to; update this document after any minor code changes. What should I know to be able to follow along with this document?; -----------------------------------------------------------------. The reader should be familiar with common compile-engineering principles and; LLVM code fundamentals. In this article, we assume the reader is familiar with; `Single Static Assignment; <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_; concept and has an understanding of; `IR structure <https://llvm.org/docs/LangRef.html#high-level-structure>`_. We will use terms such as; ""`module <https://llvm.org/docs/LangRef.html#high-level-structure>`_"",; ""`function <https://llvm.org/do",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:893,learn,learn,893,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['learn'],['learn']
Usability,"===================================; Stack maps and patch points in LLVM; ===================================. .. contents::; :local:; :depth: 2. Definitions; ===========. In this document we refer to the ""runtime"" collectively as all; components that serve as the LLVM client, including the LLVM IR; generator, object code consumer, and code patcher. A stack map records the location of ``live values`` at a particular; instruction address. These ``live values`` do not refer to all the; LLVM values live across the stack map. Instead, they are only the; values that the runtime requires to be live at this point. For; example, they may be the values the runtime will need to resume; program execution at that point independent of the compiled function; containing the stack map. LLVM emits stack map data into the object code within a designated; :ref:`stackmap-section`. This stack map data contains a record for; each stack map. The record stores the stack map's instruction address; and contains an entry for each mapped value. Each entry encodes a; value's location as a register, stack offset, or constant. A patch point is an instruction address at which space is reserved for; patching a new instruction sequence at run time. Patch points look; much like calls to LLVM. They take arguments that follow a calling; convention and may return a value. They also imply stack map; generation, which allows the runtime to locate the patchpoint and; find the location of ``live values`` at that point. Motivation; ==========. This functionality is currently experimental but is potentially useful; in a variety of settings, the most obvious being a runtime (JIT); compiler. Example applications of the patchpoint intrinsics are; implementing an inline call cache for polymorphic method dispatch or; optimizing the retrieval of properties in dynamically typed languages; such as JavaScript. The intrinsics documented here are currently used by the JavaScript; compiler within the open source WebKit pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:677,resume,resume,677,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['resume'],['resume']
Usability,"===================================; TableGen Backend Developer's Guide; ===================================. .. sectnum::. .. contents::; :local:. Introduction; ============. The purpose of TableGen is to generate complex output files based on; information from source files that are significantly easier to code than the; output files would be, and also easier to maintain and modify over time. The; information is coded in a declarative style involving classes and records,; which are then processed by TableGen. The internalized records are passed on; to various backends, which extract information from a subset of the records; and generate an output file. These output files are typically ``.inc`` files; for C++, but may be any type of file that the backend developer needs. This document is a guide to writing a backend for TableGen. It is not a; complete reference manual, but rather a guide to using the facilities; provided by TableGen for the backends. For a complete reference to the; various data structures and functions involved, see the primary TableGen; header file (``record.h``) and/or the Doxygen documentation. This document assumes that you have read the :doc:`TableGen Programmer's; Reference <./ProgRef>`, which provides a detailed reference for coding; TableGen source files. For a description of the existing backends, see; :doc:`TableGen BackEnds <./BackEnds>`. Data Structures; ===============. The following sections describe the data structures that contain the classes; and records that are collected from the TableGen source files by the; TableGen parser. Note that the term *class* refers to an abstract record; class, while the term *record* refers to a concrete record. Unless otherwise noted, functions associated with classes are instance; functions. ``RecordKeeper``; ----------------. An instance of the ``RecordKeeper`` class acts as the container for all the; classes and records parsed and collected by TableGen. The ``RecordKeeper``; instance is passed to t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:801,guid,guide,801,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,2,['guid'],['guide']
Usability,"=====================================; Coroutines in LLVM; =====================================. .. contents::; :local:; :depth: 3. .. warning::; Compatibility across LLVM releases is not guaranteed. Introduction; ============. .. _coroutine handle:. LLVM coroutines are functions that have one or more `suspend points`_.; When a suspend point is reached, the execution of a coroutine is suspended and; control is returned back to its caller. A suspended coroutine can be resumed; to continue execution from the last suspend point or it can be destroyed. In the following example, we call function `f` (which may or may not be a; coroutine itself) that returns a handle to a suspended coroutine; (**coroutine handle**) that is used by `main` to resume the coroutine twice and; then destroy it:. .. code-block:: llvm. define i32 @main() {; entry:; %hdl = call ptr @f(i32 4); call void @llvm.coro.resume(ptr %hdl); call void @llvm.coro.resume(ptr %hdl); call void @llvm.coro.destroy(ptr %hdl); ret i32 0; }. .. _coroutine frame:. In addition to the function stack frame which exists when a coroutine is; executing, there is an additional region of storage that contains objects that; keep the coroutine state when a coroutine is suspended. This region of storage; is called the **coroutine frame**. It is created when a coroutine is called; and destroyed when a coroutine either runs to completion or is destroyed; while suspended. LLVM currently supports two styles of coroutine lowering. These styles; support substantially different sets of features, have substantially; different ABIs, and expect substantially different patterns of frontend; code generation. However, the styles also have a great deal in common. In all cases, an LLVM coroutine is initially represented as an ordinary LLVM; function that has calls to `coroutine intrinsics`_ defining the structure of; the coroutine. The coroutine function is then, in the most general case,; rewritten by the coroutine lowering passes to become t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:473,resume,resumed,473,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,4,['resume'],"['resume', 'resumed']"
Usability,"=======================================; LLVM's Optional Rich Disassembly Output; =======================================. .. contents::; :local:. Introduction; ============. LLVM's default disassembly output is raw text. To allow consumers more ability; to introspect the instructions' textual representation or to reformat for a more; user friendly display there is an optional rich disassembly output. This optional output is sufficient to reference into individual portions of the; instruction text. This is intended for clients like disassemblers, list file; generators, and pretty-printers, which need more than the raw instructions and; the ability to print them. To provide this functionality the assembly text is marked up with annotations.; The markup is simple enough in syntax to be robust even in the case of version; mismatches between consumers and producers. That is, the syntax generally does; not carry semantics beyond ""this text has an annotation,"" so consumers can; simply ignore annotations they do not understand or do not care about. After calling ``LLVMCreateDisasm()`` to create a disassembler context the; optional output is enable with this call:. .. code-block:: c. LLVMSetDisasmOptions(DC, LLVMDisassembler_Option_UseMarkup);. Then subsequent calls to ``LLVMDisasmInstruction()`` will return output strings; with the marked up annotations. Instruction Annotations; =======================. .. _contextual markups:. Contextual markups; ------------------. Annotated assembly display will supply contextual markup to help clients more; efficiently implement things like pretty printers. Most markup will be target; independent, so clients can effectively provide good display without any target; specific knowledge. Annotated assembly goes through the normal instruction printer, but optionally; includes contextual tags on portions of the instruction string. An annotation; is any '<' '>' delimited section of text(1). .. code-block:: bat. annotation: '<' tag-name tag-mod",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MarkedUpDisassembly.rst:765,simpl,simple,765,interpreter/llvm-project/llvm/docs/MarkedUpDisassembly.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MarkedUpDisassembly.rst,2,['simpl'],"['simple', 'simply']"
Usability,"=======================================; The Often Misunderstood GEP Instruction; =======================================. .. contents::; :local:. Introduction; ============. This document seeks to dispel the mystery and confusion surrounding LLVM's; `GetElementPtr <LangRef.html#getelementptr-instruction>`_ (GEP) instruction.; Questions about the wily GEP instruction are probably the most frequently; occurring questions once a developer gets down to coding with LLVM. Here we lay; out the sources of confusion and show that the GEP instruction is really quite; simple. Address Computation; ===================. When people are first confronted with the GEP instruction, they tend to relate; it to known concepts from other programming paradigms, most notably C array; indexing and field selection. GEP closely resembles C array indexing and field; selection, however it is a little different and this leads to the following; questions. What is the first index of the GEP instruction?; -----------------------------------------------. Quick answer: The index stepping through the second operand. The confusion with the first index usually arises from thinking about the; GetElementPtr instruction as if it was a C index operator. They aren't the; same. For example, when we write, in ""C"":. .. code-block:: c++. AType *Foo;; ...; X = &Foo->F;. it is natural to think that there is only one index, the selection of the field; ``F``. However, in this example, ``Foo`` is a pointer. That pointer; must be indexed explicitly in LLVM. C, on the other hand, indices through it; transparently. To arrive at the same address location as the C code, you would; provide the GEP instruction with two index operands. The first operand indexes; through the pointer; the second operand indexes the field ``F`` of the; structure, just as if you wrote:. .. code-block:: c++. X = &Foo[0].F;. Sometimes this question gets rephrased as:. .. _GEP index through first pointer:. *Why is it okay to index through the first",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:565,simpl,simple,565,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['simpl'],['simple']
Usability,"=========================================+; | uint64_t | key offset | Absolute byte offset of the key in the string table |; +----------+--------------+-------------------------------------------------------+; | uint64_t | value offset | Absolute byte offset of the value in the string table |; +----------+--------------+-------------------------------------------------------+. The string entries simply provide offsets to a key and value pair in the; binary images string table. The string table is simply a collection of null; terminated strings with defined offsets in the image. The string entry allows us; to create a key-value pair from this string table. This is used for passing; arbitrary arguments to the image, such as the triple and architecture. All of these structures are combined to form a single binary blob, the order; does not matter because of the use of absolute offsets. This makes it easier to; extend in the future. As mentioned previously, multiple offloading images are; bundled together by simply concatenating them in this format. Because we have; the magic bytes and size of each image, we can extract them as-needed. Usage; =====. This tool can be used with the following arguments. Generally information is; passed as a key-value pair to the ``image=`` argument. The ``file`` and; ``triple``, arguments are considered mandatory to make a valid image.; The ``arch`` argument is suggested. .. code-block:: console. OVERVIEW: A utility for bundling several object files into a single binary.; The output binary can then be embedded into the host section table; to create a fatbinary containing offloading code. USAGE: clang-offload-packager [options]. OPTIONS:. Generic Options:. --help - Display available options (--help-hidden for more); --help-list - Display list of available options (--help-list-hidden for more); --version - Display the version of this program. clang-offload-packager options:. --image=<<key>=<value>,...> - List of key and value arguments. Requir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst:7425,simpl,simply,7425,interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,1,['simpl'],['simply']
Usability,"=========================================; A guide to Dockerfiles for building LLVM; =========================================. Introduction; ============; You can find a number of sources to build docker images with LLVM components in; ``llvm/utils/docker``. They can be used by anyone who wants to build the docker; images for their own use, or as a starting point for someone who wants to write; their own Dockerfiles. We currently provide Dockerfiles with ``debian10`` and ``nvidia-cuda`` base images.; We also provide an ``example`` image, which contains placeholders that one would need; to fill out in order to produce Dockerfiles for a new docker image. Why?; ----; Docker images provide a way to produce binary distributions of; software inside a controlled environment. Having Dockerfiles to builds docker images; inside LLVM repo makes them much more discoverable than putting them into any other; place. Docker basics; -------------; If you've never heard about Docker before, you might find this section helpful; to get a very basic explanation of it.; `Docker <https://www.docker.com/>`_ is a popular solution for running programs in; an isolated and reproducible environment, especially to maintain releases for; software deployed to large distributed fleets.; It uses linux kernel namespaces and cgroups to provide a lightweight isolation; inside currently running linux kernel.; A single active instance of dockerized environment is called a *docker; container*.; A snapshot of a docker container filesystem is called a *docker image*.; One can start a container from a prebuilt docker image. Docker images are built from a so-called *Dockerfile*, a source file written in; a specialized language that defines instructions to be used when build; the docker image (see `official; documentation <https://docs.docker.com/engine/reference/builder/>`_ for more; details). A minimal Dockerfile typically contains a base image and a number; of RUN commands that have to be executed to build ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst:45,guid,guide,45,interpreter/llvm-project/llvm/docs/Docker.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst,1,['guid'],['guide']
Usability,"==========================================; The LLVM Target-Independent Code Generator; ==========================================. .. role:: raw-html(raw); :format: html. .. raw:: html. <style>; .unknown { background-color: #C0C0C0; text-align: center; }; .unknown:before { content: ""?"" }; .no { background-color: #C11B17 }; .no:before { content: ""N"" }; .partial { background-color: #F88017 }; .yes { background-color: #0F0; }; .yes:before { content: ""Y"" }; .na { background-color: #6666FF; }; .na:before { content: ""N/A"" }; </style>. .. contents::; :local:. .. warning::; This is a work in progress. Introduction; ============. The LLVM target-independent code generator is a framework that provides a suite; of reusable components for translating the LLVM internal representation to the; machine code for a specified target---either in assembly form (suitable for a; static compiler) or in binary machine code format (usable for a JIT; compiler). The LLVM target-independent code generator consists of six main; components:. 1. `Abstract target description`_ interfaces which capture important properties; about various aspects of the machine, independently of how they will be used.; These interfaces are defined in ``include/llvm/Target/``. 2. Classes used to represent the `code being generated`_ for a target. These; classes are intended to be abstract enough to represent the machine code for; *any* target machine. These classes are defined in; ``include/llvm/CodeGen/``. At this level, concepts like ""constant pool; entries"" and ""jump tables"" are explicitly exposed. 3. Classes and algorithms used to represent code at the object file level, the; `MC Layer`_. These classes represent assembly level constructs like labels,; sections, and instructions. At this level, concepts like ""constant pool; entries"" and ""jump tables"" don't exist. 4. `Target-independent algorithms`_ used to implement various phases of native; code generation (register allocation, scheduling, stack frame representati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:921,usab,usable,921,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['usab'],['usable']
Usability,"=============================================; Building a JIT: Per-function Lazy Compilation; =============================================. .. contents::; :local:. **This tutorial is under active development. It is incomplete and details may; change frequently.** Nonetheless we invite you to try it out as it stands, and; we welcome any feedback. Chapter 3 Introduction; ======================. **Warning: This text is currently out of date due to ORC API updates.**. **The example code has been updated and can be used. The text will be updated; once the API churn dies down.**. Welcome to Chapter 3 of the ""Building an ORC-based JIT in LLVM"" tutorial. This; chapter discusses lazy JITing and shows you how to enable it by adding an ORC; CompileOnDemand layer the JIT from `Chapter 2 <BuildingAJIT2.html>`_. Lazy Compilation; ================. When we add a module to the KaleidoscopeJIT class from Chapter 2 it is; immediately optimized, compiled and linked for us by the IRTransformLayer,; IRCompileLayer and RTDyldObjectLinkingLayer respectively. This scheme, where all the; work to make a Module executable is done up front, is simple to understand and; its performance characteristics are easy to reason about. However, it will lead; to very high startup times if the amount of code to be compiled is large, and; may also do a lot of unnecessary compilation if only a few compiled functions; are ever called at runtime. A truly ""just-in-time"" compiler should allow us to; defer the compilation of any given function until the moment that function is; first called, improving launch times and eliminating redundant work. In fact,; the ORC APIs provide us with a layer to lazily compile LLVM IR:; *CompileOnDemandLayer*. The CompileOnDemandLayer class conforms to the layer interface described in; Chapter 2, but its addModule method behaves quite differently from the layers; we have seen so far: rather than doing any work up front, it just scans the; Modules being added and arranges for each",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst:339,feedback,feedback,339,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,1,['feedback'],['feedback']
Usability,"=============================================; My First Language Frontend with LLVM Tutorial; =============================================. .. toctree::; :hidden:. LangImpl01; LangImpl02; LangImpl03; LangImpl04; LangImpl05; LangImpl06; LangImpl07; LangImpl08; LangImpl09; LangImpl10. **Requirements:** This tutorial assumes you know C++, but no previous; compiler experience is necessary. Welcome to the ""My First Language Frontend with LLVM"" tutorial. Here we; run through the implementation of a simple language, showing; how fun and easy it can be. This tutorial will get you up and running; fast and show a concrete example of something that uses LLVM to generate; code. This tutorial introduces the simple ""Kaleidoscope"" language, building it; iteratively over the course of several chapters, showing how it is built; over time. This lets us cover a range of language design and LLVM-specific; ideas, showing and explaining the code for it all along the way,; and reduces the overwhelming amount of details up front. We strongly; encourage that you *work with this code* - make a copy and hack it up and; experiment. **Warning**: In order to focus on teaching compiler techniques and LLVM; specifically,; this tutorial does *not* show best practices in software engineering; principles. For example, the code uses global variables; pervasively, doesn't use; `visitors <http://en.wikipedia.org/wiki/Visitor_pattern>`_, etc... but; instead keeps things simple and focuses on the topics at hand. This tutorial is structured into chapters covering individual topics,; allowing you to skip ahead as you wish:. - `Chapter #1: Kaleidoscope language and Lexer <LangImpl01.html>`_ -; This shows where we are; going and the basic functionality that we want to build. A lexer; is also the first part of building a parser for a language, and we; use a simple C++ lexer which is easy to understand.; - `Chapter #2: Implementing a Parser and AST <LangImpl02.html>`_ -; With the lexer in place, we can talk abo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst:499,simpl,simple,499,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,2,['simpl'],['simple']
Usability,"==============================================; Kaleidoscope: Adding JIT and Optimizer Support; ==============================================. .. contents::; :local:. Chapter 4 Introduction; ======================. Welcome to Chapter 4 of the ""`Implementing a language with; LLVM <index.html>`_"" tutorial. Chapters 1-3 described the implementation; of a simple language and added support for generating LLVM IR. This; chapter describes two new techniques: adding optimizer support to your; language, and adding JIT compiler support. These additions will; demonstrate how to get nice, efficient code for the Kaleidoscope; language. Trivial Constant Folding; ========================. Our demonstration for Chapter 3 is elegant and easy to extend.; Unfortunately, it does not produce wonderful code. The IRBuilder,; however, does give us obvious optimizations when compiling simple code:. ::. ready> def test(x) 1+2+x;; Read function definition:; define double @test(double %x) {; entry:; %addtmp = fadd double 3.000000e+00, %x; ret double %addtmp; }. This code is not a literal transcription of the AST built by parsing the; input. That would be:. ::. ready> def test(x) 1+2+x;; Read function definition:; define double @test(double %x) {; entry:; %addtmp = fadd double 2.000000e+00, 1.000000e+00; %addtmp1 = fadd double %addtmp, %x; ret double %addtmp1; }. Constant folding, as seen above, in particular, is a very common and; very important optimization: so much so that many language implementors; implement constant folding support in their AST representation. With LLVM, you don't need this support in the AST. Since all calls to; build LLVM IR go through the LLVM IR builder, the builder itself checked; to see if there was a constant folding opportunity when you call it. If; so, it just does the constant fold and return the constant instead of; creating an instruction. Well, that was easy :). In practice, we recommend always using; ``IRBuilder`` when generating code like this. It has no ""s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:355,simpl,simple,355,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,2,['simpl'],['simple']
Usability,"=================================================; Choosing the Right Interface for Your Application; =================================================. Clang provides infrastructure to write tools that need syntactic and semantic; information about a program. This document will give a short introduction of; the different ways to write clang tools, and their pros and cons. LibClang; --------. `LibClang <https://clang.llvm.org/doxygen/group__CINDEX.html>`_ is a stable high; level C interface to clang. When in doubt LibClang is probably the interface; you want to use. Consider the other interfaces only when you have a good; reason not to use LibClang. Canonical examples of when to use LibClang:. * Xcode; * Clang Python Bindings. Use LibClang when you...:. * want to interface with clang from other languages than C++; * need a stable interface that takes care to be backwards compatible; * want powerful high-level abstractions, like iterating through an AST with a; cursor, and don't want to learn all the nitty gritty details of Clang's AST. Do not use LibClang when you...:. * want full control over the Clang AST. Clang Plugins; -------------. :doc:`Clang Plugins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project whi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:1001,learn,learn,1001,interpreter/llvm-project/clang/docs/Tooling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst,1,['learn'],['learn']
Usability,"==================================================; Kaleidoscope: Extending the Language: Control Flow; ==================================================. .. contents::; :local:. Chapter 5 Introduction; ======================. Welcome to Chapter 5 of the ""`Implementing a language with; LLVM <index.html>`_"" tutorial. Parts 1-4 described the implementation of; the simple Kaleidoscope language and included support for generating; LLVM IR, followed by optimizations and a JIT compiler. Unfortunately, as; presented, Kaleidoscope is mostly useless: it has no control flow other; than call and return. This means that you can't have conditional; branches in the code, significantly limiting its power. In this episode; of ""build that compiler"", we'll extend Kaleidoscope to have an; if/then/else expression plus a simple 'for' loop. If/Then/Else; ============. Extending Kaleidoscope to support if/then/else is quite straightforward.; It basically requires adding support for this ""new"" concept to the; lexer, parser, AST, and LLVM code emitter. This example is nice, because; it shows how easy it is to ""grow"" a language over time, incrementally; extending it as new ideas are discovered. Before we get going on ""how"" we add this extension, let's talk about; ""what"" we want. The basic idea is that we want to be able to write this; sort of thing:. ::. def fib(x); if x < 3 then; 1; else; fib(x-1)+fib(x-2);. In Kaleidoscope, every construct is an expression: there are no; statements. As such, the if/then/else expression needs to return a value; like any other. Since we're using a mostly functional form, we'll have; it evaluate its conditional, then return the 'then' or 'else' value; based on how the condition was resolved. This is very similar to the C; ""?:"" expression. The semantics of the if/then/else expression is that it evaluates the; condition to a boolean equality value: 0.0 is considered to be false and; everything else is considered to be true. If the condition is true, the; first ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:366,simpl,simple,366,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,2,['simpl'],['simple']
Usability,"=====================================================; Kaleidoscope: Kaleidoscope Introduction and the Lexer; =====================================================. .. contents::; :local:. The Kaleidoscope Language; =========================. This tutorial is illustrated with a toy language called; ""`Kaleidoscope <http://en.wikipedia.org/wiki/Kaleidoscope>`_"" (derived; from ""meaning beautiful, form, and view""). Kaleidoscope is a procedural; language that allows you to define functions, use conditionals, math,; etc. Over the course of the tutorial, we'll extend Kaleidoscope to; support the if/then/else construct, a for loop, user defined operators,; JIT compilation with a simple command line interface, debug info, etc. We want to keep things simple, so the only datatype in Kaleidoscope; is a 64-bit floating point type (aka 'double' in C parlance). As such,; all values are implicitly double precision and the language doesn't; require type declarations. This gives the language a very nice and; simple syntax. For example, the following simple example computes; `Fibonacci numbers: <http://en.wikipedia.org/wiki/Fibonacci_number>`_. ::. # Compute the x'th fibonacci number.; def fib(x); if x < 3 then; 1; else; fib(x-1)+fib(x-2). # This expression will compute the 40th number.; fib(40). We also allow Kaleidoscope to call into standard library functions - the; LLVM JIT makes this really easy. This means that you can use the; 'extern' keyword to define a function before you use it (this is also; useful for mutually recursive functions). For example:. ::. extern sin(arg);; extern cos(arg);; extern atan2(arg1 arg2);. atan2(sin(.4), cos(42)). A more interesting example is included in Chapter 6 where we write a; little Kaleidoscope application that `displays a Mandelbrot; Set <LangImpl06.html#kicking-the-tires>`_ at various levels of magnification. Let's dive into the implementation of this language!. The Lexer; =========. When it comes to implementing a language, the first thing n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst:680,simpl,simple,680,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,3,['simpl'],['simple']
Usability,"=======================================================; Building a JIT: Starting out with KaleidoscopeJIT; =======================================================. .. contents::; :local:. Chapter 1 Introduction; ======================. **Warning: This tutorial is currently being updated to account for ORC API; changes. Only Chapters 1 and 2 are up-to-date.**. **Example code from Chapters 3 to 5 will compile and run, but has not been; updated**. Welcome to Chapter 1 of the ""Building an ORC-based JIT in LLVM"" tutorial. This; tutorial runs through the implementation of a JIT compiler using LLVM's; On-Request-Compilation (ORC) APIs. It begins with a simplified version of the; KaleidoscopeJIT class used in the; `Implementing a language with LLVM <LangImpl01.html>`_ tutorials and then; introduces new features like concurrent compilation, optimization, lazy; compilation and remote execution. The goal of this tutorial is to introduce you to LLVM's ORC JIT APIs, show how; these APIs interact with other parts of LLVM, and to teach you how to recombine; them to build a custom JIT that is suited to your use-case. The structure of the tutorial is:. - Chapter #1: Investigate the simple KaleidoscopeJIT class. This will; introduce some of the basic concepts of the ORC JIT APIs, including the; idea of an ORC *Layer*. - `Chapter #2 <BuildingAJIT2.html>`_: Extend the basic KaleidoscopeJIT by adding; a new layer that will optimize IR and generated code. - `Chapter #3 <BuildingAJIT3.html>`_: Further extend the JIT by adding a; Compile-On-Demand layer to lazily compile IR. - `Chapter #4 <BuildingAJIT4.html>`_: Improve the laziness of our JIT by; replacing the Compile-On-Demand layer with a custom layer that uses the ORC; Compile Callbacks API directly to defer IR-generation until functions are; called. - `Chapter #5 <BuildingAJIT5.html>`_: Add process isolation by JITing code into; a remote process with reduced privileges using the JIT Remote APIs. To provide input for our JIT we will us",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:655,simpl,simplified,655,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['simpl'],['simplified']
Usability,"=======================================================; Kaleidoscope: Extending the Language: Mutable Variables; =======================================================. .. contents::; :local:. Chapter 7 Introduction; ======================. Welcome to Chapter 7 of the ""`Implementing a language with; LLVM <index.html>`_"" tutorial. In chapters 1 through 6, we've built a; very respectable, albeit simple, `functional programming; language <http://en.wikipedia.org/wiki/Functional_programming>`_. In our; journey, we learned some parsing techniques, how to build and represent; an AST, how to build LLVM IR, and how to optimize the resultant code as; well as JIT compile it. While Kaleidoscope is interesting as a functional language, the fact; that it is functional makes it ""too easy"" to generate LLVM IR for it. In; particular, a functional language makes it very easy to build LLVM IR; directly in `SSA; form <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_.; Since LLVM requires that the input code be in SSA form, this is a very; nice property and it is often unclear to newcomers how to generate code; for an imperative language with mutable variables. The short (and happy) summary of this chapter is that there is no need; for your front-end to build SSA form: LLVM provides highly tuned and; well tested support for this, though the way it works is a bit; unexpected for some. Why is this a hard problem?; ===========================. To understand why mutable variables cause complexities in SSA; construction, consider this extremely simple C example:. .. code-block:: c. int G, H;; int test(_Bool Condition) {; int X;; if (Condition); X = G;; else; X = H;; return X;; }. In this case, we have the variable ""X"", whose value depends on the path; executed in the program. Because there are two different possible values; for X before the return instruction, a PHI node is inserted to merge the; two values. The LLVM IR that we want for this example looks like this:. .. code-b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:399,simpl,simple,399,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,2,"['learn', 'simpl']","['learned', 'simple']"
Usability,"=======================================================; libFuzzer – a library for coverage-guided fuzz testing.; =======================================================; .. contents::; :local:; :depth: 1. Introduction; ============. LibFuzzer is an in-process, coverage-guided, evolutionary fuzzing engine. LibFuzzer is linked with the library under test, and feeds fuzzed inputs to the; library via a specific fuzzing entrypoint (aka ""target function""); the fuzzer; then tracks which areas of the code are reached, and generates mutations on the; corpus of input data in order to maximize the code coverage.; The code coverage; information for libFuzzer is provided by LLVM's SanitizerCoverage_; instrumentation. Contact: libfuzzer(#)googlegroups.com. Status; ======. The original authors of libFuzzer have stopped active work on it and switched; to working on another fuzzing engine, Centipede_. LibFuzzer is still fully; supported in that important bugs will get fixed. However, please do not expect; major new features or code reviews, other than for bug fixes. Versions; ========. LibFuzzer requires a matching version of Clang. Getting Started; ===============. .. contents::; :local:; :depth: 1. Fuzz Target; -----------. The first step in using libFuzzer on a library is to implement a; *fuzz target* -- a function that accepts an array of bytes and; does something interesting with these bytes using the API under test.; Like this:. .. code-block:: c++. // fuzz_target.cc; extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {; DoSomethingInterestingWithMyAPI(Data, Size);; return 0; // Values other than 0 and -1 are reserved for future use.; }. Note that this fuzz target does not depend on libFuzzer in any way; and so it is possible and even desirable to use it with other fuzzing engines; e.g. AFL_ and/or Radamsa_. Some important things to remember about fuzz targets:. * The fuzzing engine will execute the fuzz target many times with different inputs in the same ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:92,guid,guided,92,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,2,['guid'],['guided']
Usability,"==========================================================; How to write RecursiveASTVisitor based ASTFrontendActions.; ==========================================================. Introduction; ============. In this tutorial you will learn how to create a FrontendAction that uses; a RecursiveASTVisitor to find CXXRecordDecl AST nodes with a specified; name. Creating a FrontendAction; =========================. When writing a clang based tool like a Clang Plugin or a standalone tool; based on LibTooling, the common entry point is the FrontendAction.; FrontendAction is an interface that allows execution of user specific; actions as part of the compilation. To run tools over the AST clang; provides the convenience interface ASTFrontendAction, which takes care; of executing the action. The only part left is to implement the; CreateASTConsumer method that returns an ASTConsumer per translation; unit. ::. class FindNamedClassAction : public clang::ASTFrontendAction {; public:; virtual std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(; clang::CompilerInstance &Compiler, llvm::StringRef InFile) {; return std::make_unique<FindNamedClassConsumer>();; }; };. Creating an ASTConsumer; =======================. ASTConsumer is an interface used to write generic actions on an AST,; regardless of how the AST was produced. ASTConsumer provides many; different entry points, but for our use case the only one needed is; HandleTranslationUnit, which is called with the ASTContext for the; translation unit. ::. class FindNamedClassConsumer : public clang::ASTConsumer {; public:; virtual void HandleTranslationUnit(clang::ASTContext &Context) {; // Traversing the translation unit decl via a RecursiveASTVisitor; // will visit all nodes in the AST.; Visitor.TraverseDecl(Context.getTranslationUnitDecl());; }; private:; // A RecursiveASTVisitor implementation.; FindNamedClassVisitor Visitor;; };. Using the RecursiveASTVisitor; =============================. Now that everything is hooked up, t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst:234,learn,learn,234,interpreter/llvm-project/clang/docs/RAVFrontendAction.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst,1,['learn'],['learn']
Usability,"============================================================; Kaleidoscope: Extending the Language: User-defined Operators; ============================================================. .. contents::; :local:. Chapter 6 Introduction; ======================. Welcome to Chapter 6 of the ""`Implementing a language with; LLVM <index.html>`_"" tutorial. At this point in our tutorial, we now; have a fully functional language that is fairly minimal, but also; useful. There is still one big problem with it, however. Our language; doesn't have many useful operators (like division, logical negation, or; even any comparisons besides less-than). This chapter of the tutorial takes a wild digression into adding; user-defined operators to the simple and beautiful Kaleidoscope; language. This digression now gives us a simple and ugly language in; some ways, but also a powerful one at the same time. One of the great; things about creating your own language is that you get to decide what; is good or bad. In this tutorial we'll assume that it is okay to use; this as a way to show some interesting parsing techniques. At the end of this tutorial, we'll run through an example Kaleidoscope; application that `renders the Mandelbrot set <#kicking-the-tires>`_. This gives an; example of what you can build with Kaleidoscope and its feature set. User-defined Operators: the Idea; ================================. The ""operator overloading"" that we will add to Kaleidoscope is more; general than in languages like C++. In C++, you are only allowed to; redefine existing operators: you can't programmatically change the; grammar, introduce new operators, change precedence levels, etc. In this; chapter, we will add this capability to Kaleidoscope, which will let the; user round out the set of operators that are supported. The point of going into user-defined operators in a tutorial like this; is to show the power and flexibility of using a hand-written parser.; Thus far, the parser we have been implement",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:736,simpl,simple,736,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,2,['simpl'],['simple']
Usability,"=============================================================; How To Build Clang and LLVM with Profile-Guided Optimizations; =============================================================. Introduction; ============. PGO (Profile-Guided Optimization) allows your compiler to better optimize code; for how it actually runs. Users report that applying this to Clang and LLVM can; decrease overall compile time by 20%. This guide walks you through how to build Clang with PGO, though it also applies; to other subprojects, such as LLD. If you want to build other software with PGO, see the `end-user documentation; for PGO <https://clang.llvm.org/docs/UsersManual.html#profile-guided-optimization>`_. Using preconfigured CMake caches; ================================. See https://llvm.org/docs/AdvancedBuilds.html#multi-stage-pgo. Using the script; ================. We have a script at ``utils/collect_and_build_with_pgo.py``. This script is; tested on a few Linux flavors, and requires a checkout of LLVM, Clang, and; compiler-rt. Despite the name, it performs four clean builds of Clang, so it; can take a while to run to completion. Please see the script's ``--help`` for; more information on how to run it, and the different options available to you.; If you want to get the most out of PGO for a particular use-case (e.g. compiling; a specific large piece of software), please do read the section below on; 'benchmark' selection. Please note that this script is only tested on a few Linux distros. Patches to; add support for other platforms, as always, are highly appreciated. :). This script also supports a ``--dry-run`` option, which causes it to print; important commands instead of running them. Selecting 'benchmarks'; ======================. PGO does best when the profiles gathered represent how the user plans to use the; compiler. Notably, highly accurate profiles of llc building x86_64 code aren't; incredibly helpful if you're going to be targeting ARM. By default, the script above ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst:421,guid,guide,421,interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst,2,['guid'],"['guide', 'guided-optimization']"
Usability,"===============================================================; Tutorial for building tools using LibTooling and LibASTMatchers; ===============================================================. This document is intended to show how to build a useful source-to-source; translation tool based on Clang's `LibTooling <LibTooling.html>`_. It is; explicitly aimed at people who are new to Clang, so all you should need; is a working knowledge of C++ and the command line. In order to work on the compiler, you need some basic knowledge of the; abstract syntax tree (AST). To this end, the reader is encouraged to; skim the :doc:`Introduction to the Clang; AST <IntroductionToTheClangAST>`. Step 0: Obtaining Clang; =======================. As Clang is part of the LLVM project, you'll need to download LLVM's; source code first. Both Clang and LLVM are in the same git repository,; under different directories. For further information, see the `getting; started guide <https://llvm.org/docs/GettingStarted.html>`_. .. code-block:: console. mkdir ~/clang-llvm && cd ~/clang-llvm; git clone https://github.com/llvm/llvm-project.git. Next you need to obtain the CMake build system and Ninja build tool. .. code-block:: console. cd ~/clang-llvm; git clone https://github.com/martine/ninja.git; cd ninja; git checkout release; ./configure.py --bootstrap; sudo cp ninja /usr/bin/. cd ~/clang-llvm; git clone https://gitlab.kitware.com/cmake/cmake.git; cd cmake; git checkout next; ./bootstrap; make; sudo make install. Okay. Now we'll build Clang!. .. code-block:: console. cd ~/clang-llvm; mkdir build && cd build; cmake -G Ninja ../llvm-project/llvm -DLLVM_ENABLE_PROJECTS=""clang;clang-tools-extra"" -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TESTS=ON; ninja; ninja check # Test LLVM only.; ninja clang-test # Test Clang only.; ninja install. And we're live. All of the tests should pass. Finally, we want to set Clang as its own compiler. .. code-block:: console. cd ~/clang-llvm/build; ccmake ../llvm-project/ll",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:958,guid,guide,958,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['guid'],['guide']
Usability,"===================================================================; Cross-compilation using Clang; ===================================================================. Introduction; ============. This document will guide you in choosing the right Clang options; for cross-compiling your code to a different architecture. It assumes you; already know how to compile the code in question for the host architecture,; and that you know how to choose additional include and library paths. However, this document is *not* a ""how to"" and won't help you setting your; build system or Makefiles, nor choosing the right CMake options, etc.; Also, it does not cover all the possible options, nor does it contain; specific examples for specific architectures. For a concrete example, the; `instructions for cross-compiling LLVM itself; <https://llvm.org/docs/HowToCrossCompileLLVM.html>`_ may be of interest. After reading this document, you should be familiar with the main issues; related to cross-compilation, and what main compiler options Clang provides; for performing cross-compilation. Cross compilation issues; ========================. In GCC world, every host/target combination has its own set of binaries,; headers, libraries, etc. So, it's usually simple to download a package; with all files in, unzip to a directory and point the build system to; that compiler, that will know about its location and find all it needs to; when compiling your code. On the other hand, Clang/LLVM is natively a cross-compiler, meaning that; one set of programs can compile to all targets by setting the ``-target``; option. That makes it a lot easier for programmers wishing to compile to; different platforms and architectures, and for compiler developers that; only have to maintain one build system, and for OS distributions, that; need only one set of main packages. But, as is true to any cross-compiler, and given the complexity of; different architectures, OS's and options, it's not always easy finding; the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:216,guid,guide,216,interpreter/llvm-project/clang/docs/CrossCompilation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst,1,['guid'],['guide']
Usability,"=====================================================================; Building a JIT: Adding Optimizations -- An introduction to ORC Layers; =====================================================================. .. contents::; :local:. **This tutorial is under active development. It is incomplete and details may; change frequently.** Nonetheless we invite you to try it out as it stands, and; we welcome any feedback. Chapter 2 Introduction; ======================. **Warning: This tutorial is currently being updated to account for ORC API; changes. Only Chapters 1 and 2 are up-to-date.**. **Example code from Chapters 3 to 5 will compile and run, but has not been; updated**. Welcome to Chapter 2 of the ""Building an ORC-based JIT in LLVM"" tutorial. In; `Chapter 1 <BuildingAJIT1.html>`_ of this series we examined a basic JIT; class, KaleidoscopeJIT, that could take LLVM IR modules as input and produce; executable code in memory. KaleidoscopeJIT was able to do this with relatively; little code by composing two off-the-shelf *ORC layers*: IRCompileLayer and; ObjectLinkingLayer, to do much of the heavy lifting. In this layer we'll learn more about the ORC layer concept by using a new layer,; IRTransformLayer, to add IR optimization support to KaleidoscopeJIT. Optimizing Modules using the IRTransformLayer; =============================================. In `Chapter 4 <LangImpl04.html>`_ of the ""Implementing a language with LLVM""; tutorial series the llvm *FunctionPassManager* is introduced as a means for; optimizing LLVM IR. Interested readers may read that chapter for details, but; in short: to optimize a Module we create an llvm::FunctionPassManager; instance, configure it with a set of optimizations, then run the PassManager on; a Module to mutate it into a (hopefully) more optimized but semantically; equivalent form. In the original tutorial series the FunctionPassManager was; created outside the KaleidoscopeJIT and modules were optimized before being; added to it. In thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:411,feedback,feedback,411,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['feedback'],['feedback']
Usability,"=======================================================================; Building a JIT: Extreme Laziness - Using LazyReexports to JIT from ASTs; =======================================================================. .. contents::; :local:. **This tutorial is under active development. It is incomplete and details may; change frequently.** Nonetheless we invite you to try it out as it stands, and; we welcome any feedback. Chapter 4 Introduction; ======================. Welcome to Chapter 4 of the ""Building an ORC-based JIT in LLVM"" tutorial. This; chapter introduces custom MaterializationUnits and Layers, and the lazy; reexports API. Together these will be used to replace the CompileOnDemandLayer; from `Chapter 3 <BuildingAJIT3.html>`_ with a custom lazy-JITing scheme that JITs; directly from Kaleidoscope ASTs. **To be done:**. **(1) Describe the drawbacks of JITing from IR (have to compile to IR first,; which reduces the benefits of laziness).**. **(2) Describe CompileCallbackManagers and IndirectStubManagers in detail.**. **(3) Run through the implementation of addFunctionAST.**. Full Code Listing; =================. Here is the complete code listing for our running example that JITs lazily from; Kaleidoscope ASTS. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../examples/Kaleidoscope/BuildingAJIT/Chapter4/KaleidoscopeJIT.h; :language: c++. `Next: Remote-JITing -- Process-isolation and laziness-at-a-distance <BuildingAJIT5.html>`_; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT4.rst:417,feedback,feedback,417,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT4.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT4.rst,1,['feedback'],['feedback']
Usability,"> But in fact, if you read the entire answer carefully, he came to the same; > conclusion I do: that you have to go with familiar syntax over logical; > syntax because familiarity is such a strong force:; > ""However, familiarity is a strong force. To compare, in English, we; live; > more or less happily with the absurd rules for ""to be"" (am, are, is, been,; > was, were, ...) and all attempts to simplify are treated with contempt or; > (preferably) humor. It be a curious world and it always beed."". Although you have to remember that his situation was considerably; different than ours. He was in a position where he was designing a high; level language that had to be COMPATIBLE with C. Our language is such; that a new person would have to learn the new, different, syntax; anyways. Making them learn about the type system does not seem like much; of a stretch from learning the opcodes and how SSA form works, and how; everything ties together... > > Basically, my argument for this type construction system is that it is; > > VERY simple to use and understand (although it IS different than C, it is; > > very simple and straightforward, which C is NOT). In fact, I would assert; > > that most programmers TODAY do not understand pointers to member; > > functions, and have to look up an example when they have to write them. > Again, I don't disagree with this at all. But to some extent this; > particular problem is inherently difficult. Your syntax for the above; > example may be easier for you to read because this is the way you have been; > thinking about it. Honestly, I don't find it much easier than the C syntax.; > In either case, I would have to look up an example to write pointers to; > member functions. I would argue that because the lexical structure of the language is self; consistent, any person who spent a significant amount of time programming; in LLVM directly would understand how to do it without looking it up in a; manual. The reason this does not work for C is b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt:398,simpl,simplify,398,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt,4,"['learn', 'simpl']","['learn', 'learning', 'simplify']"
Usability,">GetEntry(i);; params[0] = msumf; params[1] = ptsumf;; params[2] = acolin; params[3] = acopl;; bg->Fill(mlp->Evaluate(0,params));; }; for (i = 0; i < signal->GetEntries(); i++) {; signal->GetEntry(i);; params[0] = msumf;; params[1] = ptsumf;; params[2] = acolin;; params[3] = acopl;; sig->Fill(mlp->Evaluate(0,params));; }; TCanvas *cv = new TCanvas(""NNout_cv"",""Neural net output"");; bg->SetFillStyle(3008);; bg->SetFillColor(kBlue);; sig->SetFillStyle(3003);; sig->SetFillColor(kRed);; bg->SetStats(0);; sig->SetStats(0);; bg->Draw();; sig->Draw(""same"");; TLegend *legend = new TLegend(.75,.80,.95,.95);; legend->AddEntry(bg,""Background(WW)"");; legend->AddEntry(sig,""Signal(Higgs)"");; legend->Draw();; ```. The neural net output is then used to display the final difference; between background and signal events. The figure ""The neural net; output"" shows this plot. ![The neural net output](pictures/image144.png). As it can be seen, this is a quite efficient technique. As mentioned; earlier, neural networks are also used for fitting function. For some; application with a cylindrical symmetry, a magnetic field simulation; gives as output the angular component of the potential vector `A`, as; well as the radial and `z` components of the `B` field. One wants to fit those distributions with a function in order to plug; them into the `Geant` simulation code. Polynomial fits could be tried,; but it seems difficult to reach the desired precision over the full; range. One could also use a `spline` interpolation between known; points. In all cases, the resulting field would not be `C`-infinite. An example of output (for Br) is shown. First the initial function can; be seen as the target. Then, the resulting (normalized) neural net; output. In order to ease the learning, the ""normalize output"" was used; here. The initial amplitude can be recovered by multiplying by the; original RMS and then shifting by the original mean. ![The original and the neural net for Br](pictures/image145.jpg); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:81272,learn,learning,81272,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['learn'],['learning']
Usability,">`; feedback, please revert and address said feedback before recommitting.; (Possibly after another round of review.); * If you are asked to revert by another contributor, please revert and discuss; the merits of the request offline (unless doing so would further destabilize; tip of tree). When should you revert someone else's change?. * In general, if the author themselves would revert the change per these; guidelines, we encourage other contributors to do so as a courtesy to the; author. This is one of the major cases where our norms differ from others;; we generally consider reverting a normal part of development. We don't; expect contributors to be always available, and the assurance that a; problematic patch will be reverted and we can return to it at our next; opportunity enables this. What are the expectations around a revert?. * Use your best judgment. If you're uncertain, please start an email on; the commit thread asking for assistance. We aren't trying to enumerate; every case, but rather give a set of guidelines.; * You should be sure that reverting the change improves the stability of tip; of tree. Sometimes reverting one change in a series can worsen things; instead of improving them. We expect reasonable judgment to ensure that; the proper patch or set of patches is being reverted.; * The commit message for the reverting commit should explain why patch; is being reverted.; * It is customary to respond to the original commit email mentioning the; revert. This serves as both a notice to the original author that their; patch was reverted, and helps others following llvm-commits track context.; * Ideally, you should have a publicly reproducible test case ready to share.; Where possible, we encourage sharing of test cases in commit threads, or; in PRs. We encourage the reverter to minimize the test case and to prune; dependencies where practical. This even applies when reverting your own; patch; documenting the reasons for others who might be following alo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:20867,guid,guidelines,20867,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['guid'],['guidelines']
Usability,"A.getChecker<FooAnalysis>();; return !PAC.preservedWhenStateless();; }. If an analysis depends on other analyses, those analyses also need to be; checked if they are invalidated:. .. code-block:: c++. bool FooAnalysisResult::invalidate(Function &F, const PreservedAnalyses &PA,; FunctionAnalysisManager::Invalidator &Inv) {; auto PAC = PA.getChecker<FooAnalysis>();; if (!PAC.preserved() && !PAC.preservedSet<AllAnalysesOn<Function>>()); return true;. // Check transitive dependencies.; return Inv.invalidate<BarAnalysis>(F, PA) ||; Inv.invalidate<BazAnalysis>(F, PA);; }. Combining invalidation and analysis manager proxies results in some; complexity. For example, when we invalidate all analyses in a module pass,; we have to make sure that we also invalidate function analyses accessible via; any existing inner proxies. The inner proxy's ``invalidate()`` first checks; if the proxy itself should be invalidated. If so, that means the proxy may; contain pointers to IR that is no longer valid, meaning that the inner proxy; needs to completely clear all relevant analysis results. Otherwise the proxy; simply forwards the invalidation to the inner analysis manager. Generally for outer proxies, analysis results from the outer analysis manager; should be immutable, so invalidation shouldn't be a concern. However, it is; possible for some inner analysis to depend on some outer analysis, and when; the outer analysis is invalidated, we need to make sure that dependent inner; analyses are also invalidated. This actually happens with alias analysis; results. Alias analysis is a function-level analysis, but there are; module-level implementations of specific types of alias analysis. Currently; ``GlobalsAA`` is the only module-level alias analysis and it generally is not; invalidated so this is not so much of a concern. See; ``OuterAnalysisManagerProxy::Result::registerOuterAnalysisInvalidation()``; for more details. Invoking ``opt``; ================. .. code-block:: shell. $ opt -passes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:17437,clear,clear,17437,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['clear'],['clear']
Usability,"ARWIN_LTO_LIBRARY=${LLVM_SHLIB_OUTPUT_INTDIR}/libLTO.dylib; -DDYLD_LIBRARY_PATH=${LLVM_LIBRARY_OUTPUT_INTDIR}); elseif(MSVC); add_dependencies(clang-bootstrap-deps llvm-lib); set(${CLANG_STAGE}_AR -DCMAKE_AR=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-lib); elseif(NOT WIN32); add_dependencies(clang-bootstrap-deps llvm-ar llvm-ranlib); if(NOT BOOTSTRAP_LLVM_ENABLE_LLD AND LLVM_BINUTILS_INCDIR); add_dependencies(clang-bootstrap-deps LLVMgold); endif(); set(${CLANG_STAGE}_AR -DCMAKE_AR=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-ar); set(${CLANG_STAGE}_RANLIB -DCMAKE_RANLIB=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-ranlib); endif(); endif(). if(CLANG_BOOTSTRAP_EXTRA_DEPS); add_dependencies(clang-bootstrap-deps ${CLANG_BOOTSTRAP_EXTRA_DEPS}); endif(). add_custom_target(${NEXT_CLANG_STAGE}-clear; DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-cleared; ); add_custom_command(; OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-cleared; DEPENDS clang-bootstrap-deps; COMMAND ${CMAKE_COMMAND} -E remove_directory ${BINARY_DIR}; COMMAND ${CMAKE_COMMAND} -E make_directory ${BINARY_DIR}; COMMAND ${CMAKE_COMMAND} -E remove_directory ${STAMP_DIR}; COMMAND ${CMAKE_COMMAND} -E make_directory ${STAMP_DIR}; COMMENT ""Clobberring ${NEXT_CLANG_STAGE} build and stamp directories""; ). if(CMAKE_VERBOSE_MAKEFILE); set(verbose -DCMAKE_VERBOSE_MAKEFILE=On); endif(). set(_BOOTSTRAP_DEFAULT_PASSTHROUGH; PACKAGE_VERSION; PACKAGE_VENDOR; LLVM_VERSION_MAJOR; LLVM_VERSION_MINOR; LLVM_VERSION_PATCH; CLANG_VERSION_MAJOR; CLANG_VERSION_MINOR; CLANG_VERSION_PATCHLEVEL; CLANG_VERSION_SUFFIX; CLANG_VENDOR; LLVM_VERSION_SUFFIX; LLVM_BINUTILS_INCDIR; CLANG_REPOSITORY_STRING; CMAKE_MAKE_PROGRAM; CMAKE_OSX_ARCHITECTURES; CMAKE_BUILD_TYPE; LLVM_ENABLE_PROJECTS; LLVM_ENABLE_RUNTIMES). # We don't need to depend on compiler-rt/libcxx if we're building instrumented; # because the next stage will use the same compiler used to build this stage.; if(NOT LLVM_BUILD_INSTRUMENTED); if(TARGET compiler-rt); add_dependencies(clang-boot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:23027,clear,clear,23027,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,3,['clear'],"['clear', 'cleared']"
Usability,"ATH=""${library_output_dir}\\\;%PATH%""; ROOTIGNOREPREFIX=1 ROOT_HIST=0 $<TARGET_FILE:root.exe> -l -q -b); else(); set(modules_idx_cmd COMMAND ${ld_library_path}=${library_output_dir}:$ENV{${ld_library_path}}; ROOTIGNOREPREFIX=1 ROOT_HIST=0 $<TARGET_FILE:root.exe> -l -q -b); endif(); add_custom_command(OUTPUT ${library_output_dir}/modules.idx; COMMAND ${CMAKE_COMMAND} -E remove -f modules.idx modules.timestamp; ${modules_idx_cmd}; WORKING_DIRECTORY ${library_output_dir}; DEPENDS $<TARGET_FILE:root.exe> Cling Hist Tree Gpad Graf HistPainter move_artifacts; ${modules_idx_deps}); add_custom_target(modules_idx ALL DEPENDS ${library_output_dir}/modules.idx); add_dependencies(modules_idx ${modules_idx_deps}); set_property(TARGET modules_idx PROPERTY modules_idx_file ${library_output_dir}/modules.idx); set_directory_properties(PROPERTIES ADDITIONAL_CLEAN_FILES ""${library_output_dir}/modules.timestamp""); endif(). #---hsimple.root---------(use the executable for clearer dependencies and proper return code)---; add_custom_target(hsimple ALL DEPENDS tutorials/hsimple.root); add_dependencies(hsimple onepcm); if(WIN32); set(hsimple_cmd COMMAND ${CMAKE_COMMAND} -E env PATH=""${CMAKE_RUNTIME_OUTPUT_DIRECTORY}\\\;%PATH%""; ROOTIGNOREPREFIX=1 ROOT_HIST=0 $<TARGET_FILE:root.exe> -l -q -b -n -x hsimple.C -e return); else(); set(hsimple_cmd COMMAND ${MODULES_ROOT_INCPATH} ${ld_library_path}=${CMAKE_LIBRARY_OUTPUT_DIRECTORY}:$ENV{${ld_library_path}}; ROOTIGNOREPREFIX=1 ROOT_HIST=0 $<TARGET_FILE:root.exe> -l -q -b -n -x hsimple.C -e return); endif(); add_custom_command(OUTPUT tutorials/hsimple.root; ${hsimple_cmd}; WORKING_DIRECTORY tutorials; DEPENDS $<TARGET_FILE:root.exe> Cling Hist Tree Gpad Graf HistPainter move_artifacts); install(FILES ${CMAKE_BINARY_DIR}/tutorials/hsimple.root DESTINATION ${CMAKE_INSTALL_TUTDIR} COMPONENT tests). if(runtime_cxxmodules); add_dependencies(hsimple modules_idx); endif(). #---copy special headers required for building on Windows---------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:22977,clear,clearer,22977,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,1,['clear'],['clearer']
Usability,"Among other things you can learn how; to detect Heartbleed_ in one second. Advanced features; =================; .. contents::; :local:; :depth: 1. Dictionaries; ------------; LibFuzzer supports user-supplied dictionaries with input language keywords; or other interesting byte sequences (e.g. multi-byte magic values).; Use ``-dict=DICTIONARY_FILE``. For some input languages using a dictionary; may significantly improve the search speed.; The dictionary syntax is similar to that used by AFL_ for its ``-x`` option::. # Lines starting with '#' and empty lines are ignored. # Adds ""blah"" (w/o quotes) to the dictionary.; kw1=""blah""; # Use \\ for backslash and \"" for quotes.; kw2=""\""ac\\dc\""""; # Use \xAB for hex values; kw3=""\xF7\xF8""; # the name of the keyword followed by '=' may be omitted:; ""foo\x0Abar"". Tracing CMP instructions; ------------------------. With an additional compiler flag ``-fsanitize-coverage=trace-cmp``; (on by default as part of ``-fsanitize=fuzzer``, see SanitizerCoverageTraceDataFlow_); libFuzzer will intercept CMP instructions and guide mutations based; on the arguments of intercepted CMP instructions. This may slow down; the fuzzing but is very likely to improve the results. Value Profile; -------------. With ``-fsanitize-coverage=trace-cmp`` (default with ``-fsanitize=fuzzer``); and extra run-time flag ``-use_value_profile=1`` the fuzzer will; collect value profiles for the parameters of compare instructions; and treat some new values as new coverage. The current implementation does roughly the following:. * The compiler instruments all CMP instructions with a callback that receives both CMP arguments.; * The callback computes `(caller_pc&4095) | (popcnt(Arg1 ^ Arg2) << 12)` and uses this value to set a bit in a bitset.; * Every new observed bit in the bitset is treated as new coverage. This feature has a potential to discover many interesting inputs,; but there are two downsides.; First, the extra instrumentation may bring up to 2x additional sl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:20215,guid,guide,20215,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['guid'],['guide']
Usability,"An AutoFlush is always done with an AutoSave.; If the interval specified for AutoSave is less than that for; AutoFlush, the AutoSave interval is used for both.; If the AutoFlush interval is less than the AutoSave interval,; the AutoSave interval is adjusted to the largest integer; multiple of the AutoFlush interval that is less than or equal; to the original value of the AutoSave interval. Update MakeProxy so that the resulting skeleton is useable with Proof.; Update MakeProxy, MakeClass and MakeSelector to support more cases of branches names (that includes characters illegal in a C++ symbol); Replace the ReadLeaves virtual function by a fReadLeaves pointer to member function,; this allows the customization of the ReadLeaves function at run-time depending on the; underlying user class layout in TBranchElement. This removes many if statements whose; 'answer' is known at initialization time. Add support for 'array' formula in TTree::Query.; Set the initial value of fCacheSize to zero to indicate clearly that the TreeCache is disabled.; In TChain::SetEntryList use only the treename to lookup the (sub)entryList (instead subdir/treename).; Add support for the branch creation syntax:; TString rootString;; t->Branch(""rootString"",""TString"",&rootString, 1600, 0);; which is 'natural' as it uses the legacy syntax (branch_name,class_name, user_data); but did not work because 'rootString' is an object rather than a pointer to an; object. (However the simplier form:; t->Branch(""rootString"",&rootString, 1600, 0);; works/worked fine). Add type information to the result of TTree::Print in the case of; TBranchElement:; *Br 17 :fH : TH1F* *; *Entries : 20 : Total Size= 19334 bytes File Size = 1671 *; *Baskets : 2 : Basket Size= 16000 bytes Compression= 11.29 *; *............................................................................*; *Br 18 :fTriggerBits : TBits *; *Entries : 20 : Total Size= 1398 bytes File Size = 400 *; *Baskets : 1 : Basket Size= 16000 bytes Compression= 2.23",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html:4261,clear,clearly,4261,tree/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html,1,['clear'],['clearly']
Usability,"BEGIN_HTML. <center><h1>Gviz3d - Objects Data Structure visualisation in 3D space</h1></center>; <p><hr><p>. The Gviz3d module provides an interface for inspecting objects collections.; TStructViewer represents a class, a struct or any other type as an; object in 3D space.; At the top of the scene we can see objects depending on a pointer root. Under it we see; pointers and collection elements. Collections must inherit from TCollection; or be STL collections. We can change the number of visible levels or objects on the scene with the GUI or; methods. The Size of objects in the geometry scene is proportional to memory taken by this object; or to the number of objects inside this object. An easy way to find some class in the viewer is to change the color of a type.; We can connect for example TF2 class with red color or connect all classes; inheriting from TF2 by adding plus to name. For example typename ""TF2+"" tells us; that all classes inheriting from TF2 will be red. Navigatiion in the viewer is very simple like in usual GLViewer. When you put mouse over; some object you can see some information about it (e.g. name, size, actual level).; When you double click this object, it becames top object on scene.; Undo and redo operations are supported. END_HTML; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gviz3d/doc/index.txt:1017,simpl,simple,1017,graf3d/gviz3d/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gviz3d/doc/index.txt,1,['simpl'],['simple']
Usability,"BOOTSTRAP=On \; -DCLANG_BOOTSTRAP_PASSTHROUGH=""CMAKE_INSTALL_PREFIX;CMAKE_VERBOSE_MAKEFILE"" \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. CMake options starting by ``BOOTSTRAP_`` will be passed only to the stage2 build.; This gives the opportunity to use Clang specific build flags.; For example, the following CMake call will enabled '-fno-addrsig' only during; the stage2 build for C and C++. .. code-block:: console. $ cmake [..] -DBOOTSTRAP_CMAKE_CXX_FLAGS='-fno-addrsig' -DBOOTSTRAP_CMAKE_C_FLAGS='-fno-addrsig' [..]. The clang build system refers to builds as stages. A stage1 build is a standard; build using the compiler installed on the host, and a stage2 build is built; using the stage1 compiler. This nomenclature holds up to more stages too. In; general a stage*n* build is built using the output from stage*n-1*. Apple Clang Builds (A More Complex Bootstrap); =============================================. Apple's Clang builds are a slightly more complicated example of the simple; bootstrapping scenario. Apple Clang is built using a 2-stage build. The stage1 compiler is a host-only compiler with some options set. The stage1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:3461,simpl,simple,3461,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['simpl'],['simple']
Usability,"BUILD_DOCS**:BOOL; Adds all *enabled* documentation targets (i.e. Doxgyen and Sphinx targets) as; dependencies of the default build targets. This results in all of the (enabled); documentation targets being as part of a normal build. If the ``install``; target is run then this also enables all built documentation targets to be; installed. Defaults to OFF. To enable a particular documentation target, see; see LLVM_ENABLE_SPHINX and LLVM_ENABLE_DOXYGEN. **LLVM_BUILD_EXAMPLES**:BOOL; Build LLVM examples. Defaults to OFF. Targets for building each example are; generated in any case. See documentation for *LLVM_BUILD_TOOLS* above for more; details. **LLVM_BUILD_INSTRUMENTED_COVERAGE**:BOOL; If enabled, `source-based code coverage; <https://clang.llvm.org/docs/SourceBasedCodeCoverage.html>`_ instrumentation; is enabled while building llvm. If CMake can locate the code coverage; scripts and the llvm-cov and llvm-profdata tools that pair to your compiler,; the build will also generate the `generate-coverage-report` target to generate; the code coverage report for LLVM, and the `clear-profile-data` utility target; to delete captured profile data. See documentation for; *LLVM_CODE_COVERAGE_TARGETS* and *LLVM_COVERAGE_SOURCE_DIRS* for more; information on configuring code coverage reports. **LLVM_CODE_COVERAGE_TARGETS**:STRING; If set to a semicolon separated list of targets, those targets will be used; to drive the code coverage reports. If unset, the target list will be; constructed using the LLVM build's CMake export list. **LLVM_COVERAGE_SOURCE_DIRS**:STRING; If set to a semicolon separated list of directories, the coverage reports; will limit code coverage summaries to just the listed directories. If unset,; coverage reports will include all sources identified by the tooling. **LLVM_INDIVIDUAL_TEST_COVERAGE**:BOOL; Enable individual test case coverage. When set to ON, code coverage data for; each test case will be generated and stored in a separate directory under the; co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:15112,clear,clear-profile-data,15112,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['clear'],['clear-profile-data']
Usability,"Binary_Interface_Standards_Manual.pdf>`_. LoongArch; ---------; * `LoongArch Reference Manual - Volume 1: Basic Architecture <https://loongson.github.io/LoongArch-Documentation/LoongArch-Vol1-EN.html>`_; * `LoongArch ELF ABI specification <https://loongson.github.io/LoongArch-Documentation/LoongArch-ELF-ABI-EN.html>`_. SPARC; -----. * `SPARC standards <http://sparc.org/standards>`_; * `SPARC V9 ABI <http://sparc.org/standards/64.psabi.1.35.ps.Z>`_; * `SPARC V8 ABI <http://sparc.org/standards/psABI3rd.pdf>`_. SystemZ; -------. * `z/Architecture Principles of Operation (registration required, free sign-up) <http://www-01.ibm.com/support/docview.wss?uid=isg2b9de5f05a9d57819852571c500428f9a>`_. VE; --. * `NEC SX-Aurora TSUBASA ISA Guide <https://www.hpc.nec/documents/guide/pdfs/Aurora_ISA_guide.pdf>`_; * `NEC SX-Aurora TSUBASA manuals and documentation <https://www.hpc.nec/documentation>`_. X86; ---. * `AMD processor manuals <http://developer.amd.com/resources/developer-guides-manuals/>`_; * `Intel 64 and IA-32 manuals <http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html>`_; * `Intel Itanium documentation <http://www.intel.com/design/itanium/documentation.htm?iid=ipp_srvr_proc_itanium2+techdocs>`_; * `X86 and X86-64 SysV psABI <https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI>`_; * `Calling conventions for different C++ compilers and operating systems <http://www.agner.org/optimize/calling_conventions.pdf>`_. XCore; -----. * `The XMOS XS1 Architecture (ISA) <https://www.xmos.ai/download/The-XMOS-XS1-Architecture%281.0%29.pdf>`_; * `The XMOS XS2 Architecture (ISA) <https://www.xmos.ai/download/xCORE-200:-The-XMOS-XS2-Architecture-%28ISA%29%281.1%29.pdf>`_; * `Tools Development Guide (includes ABI) <https://www.xmos.ai/download/Tools-Development-Guide%282.1%29.pdf>`_. Hexagon; -------. * `Hexagon Programmer's Reference Manuals and Hexagon ABI Specification (registration required, free sign-up) <https://developer.qualcomm.co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst:5872,guid,guides-manuals,5872,interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst,1,['guid'],['guides-manuals']
Usability,"Branch probability data in block `successors:` lists can be dropped if the; test doesn't depend on it. Example:; `successors: %bb.1(0x40000000), %bb.2(0x40000000)` can be replaced with; `successors: %bb.1, %bb.2`. - MIR code contains a whole IR module. This is necessary because there are; no equivalents in MIR for global variables, references to external functions,; function attributes, metadata, debug info. Instead some MIR data references; the IR constructs. You can often remove them if the test doesn't depend on; them. - Alias Analysis is performed on IR values. These are referenced by memory; operands in MIR. Example: `:: (load 8 from %ir.foobar, !alias.scope !9)`.; If the test doesn't depend on (good) alias analysis the references can be; dropped: `:: (load 8)`. - MIR blocks can reference IR blocks for debug printing, profile information; or debug locations. Example: `bb.42.myblock` in MIR references the IR block; `myblock`. It is usually possible to drop the `.myblock` reference and simply; use `bb.42`. - If there are no memory operands or blocks referencing the IR then the; IR function can be replaced by a parameterless dummy function like; `define @func() { ret void }`. - It is possible to drop the whole IR section of the MIR file if it only; contains dummy functions (see above). The .mir loader will create the; IR functions automatically in this case. .. _limitations:. Limitations; -----------. Currently the MIR format has several limitations in terms of which state it; can serialize:. - The target-specific state in the target-specific ``MachineFunctionInfo``; subclasses isn't serialized at the moment. - The target-specific ``MachineConstantPoolValue`` subclasses (in the ARM and; SystemZ backends) aren't serialized at the moment. - The ``MCSymbol`` machine operands don't support temporary or local symbols. - A lot of the state in ``MachineModuleInfo`` isn't serialized - only the CFI; instructions and the variable debug information from MMI is serialized righ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:4877,simpl,simply,4877,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['simpl'],['simply']
Usability,"C++ code; for computing derivatives of the function. It supports both forward-mode and; reverse-mode AD. 4. **Cling for live coding music and musical instruments:**. The artistic live coding community has been growing steadily since around the; year 2000. The Temporary Organisation for the Permanence of Live Art Programming; (TOPLAP) has been around since 2004, Algorave (algorithmic rave parties); recently celebrated its tenth birthday, and six editions of the International; Conference on Live Coding (ICLC) have been held. A great many live coding; systems have been developed during this time, many of them exhibiting exotic and; culturally specific features that professional software developers are mostly; unaware of. In this framework, Cling has been used as the basis for a C++ based; live coding synthesiser (`TinySpec-Cling; <https://github.com/nwoeanhinnogaehr/tinyspec-cling>`_). In another example,; Cling has been installed on a BeagleBoard to bring live coding to the Bela; interactive audio platform (`Using the Cling C++ Interpreter on the Bela; Platform; <https://gist.github.com/jarmitage/6e411ae8746c04d6ecbee1cbc1ebdcd4>`_). These; two examples show the potential mutual benefits for increased engagement between; the Cling community and the artistic live coding community. 5. **Clion:** The `CLion <https://www.jetbrains.com/clion/>`_ platform is a; Integrating Development Environment (`IDE; <https://en.wikipedia.org/wiki/Integrated_development_environment>`_) for C and; C++ by `JetBrains <https://www.jetbrains.com/>`_. It was developed with the aim; to enhance developer's productivity with a smart editor, code quality assurance,; automated refactorings and deep integration with the CMake build system. CLion; integrates Cling, which can be found by clicking on Tool. Cling enables; prototyping and learning C++ in CLion. You can find more information on `CLion's; building instructions; <https://www.jetbrains.com/help/clion/cling-integration.html#install-cling>`_. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/applications.rst:4060,learn,learning,4060,interpreter/cling/docs/chapters/applications.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/applications.rst,1,['learn'],['learning']
Usability,"CallArg::SetBinData(void *data, Long_t length)`. The methods could be replaced by equivalent methods with other signature:. * `Bool_t THttpServer::SubmitHttp(std::shared_ptr<THttpCallArg> arg, Bool_t can_run_immediately = kFALSE)`; * `Bool_t THttpServer::ExecuteHttp(std::shared_ptr<THttpCallArg> arg)`; * `Bool_t TRootSniffer::Produce(const std::string &path, const std::string &file, const std::string &options, std::string &res)`; * `const void *THttpCallArg::GetPostData() const`; * `Long_t THttpCallArg::GetPostDataLength() const`; * `std::string THttpCallArg::FillHttpHeader(const char *header = nullptr)`; * `void THttpCallArg::SetContent(std::string &&cont)`. ### Core Libraries; * The `TStringLong` class is deprecated. Please use `std::string` (or, if needeed, `TString`) instead. ## Core Libraries; - Prevent usage of non integer class id in `ClassDef(Inline)` macros with an error prompted at dictionary generation or compile time. ## I/O Libraries. * Added simpler way to retrieve object from `TDirectory` and `TFile`:; ~~~ {.cpp}; auto obj = directory->Get<MyClass>(""some object"");; ~~~. * Added support for read-only `TMemFile`s. ### TNetXNGFile; Added necessary changes to allow [XRootD local redirection](https://github.com/xrootd/xrootd/blob/8c9d0a9cc7f00cbb2db35be275c35126f3e091c0/docs/ReleaseNotes.txt#L14); - Uses standard VectorReadLimits and does not query a XRootD data server (which is unknown in local redirection), when it is redirected to a local file; - Adds a new constructor with a `const char *lurl` to `TNetXNGFile` and passes it to `TFile`, if set. This allows redirection to files that have a different name in the local file system and is important to allow derivation (for example to `TAlien` and `TJAlienFile`) while still keeping functionality via `TArchiveFile` when the file name in the local file system does not match `*.zip`. ### TBufferJSON; Add possibility to convert STL `std::map`, `std::multimap`, `std::unordered_map`,; `std::unordered_multimap` cla",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:5687,simpl,simpler,5687,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['simpl'],['simpler']
Usability,"Cint() call is made.; In CINT, all workspace objects will appear as correctly typed references to workspace objects in; a C++ namespace with the same name as the RooWorkspace object. Given e.g. a workspace w, with a Gaussian p.d.f gauss in terms of variables; x,m,s one can now do. RooWorkspace w(""w"",true) ; // workspace with CINT interface activated; // ... fill workspace with RooGaussian gauss(x,m,s) ...; RooPlot* frame = w::x.frame() ;; w::gauss.plotOn(frame) ;. to access the workspace contents. Each reference has the correct type, e.g. w::gauss is; a RooGaussian&. If a workspace is deleted from memory, the corresponding CINT namespace; is removed as well. Note that this feature is strictly available in interpreted C++ only; A new tutorial macro has been added to illustrate this functionality in more detail: rf509_wsinteractive.C.; writeToFile -- A new utility method RooWorkspace::writeToFile() has been added; to simplify the process of saving a workspace to file; Named sets and parameter snapshots -- It is now possible to define and retrieve; named RooArgSets of objects that live in the workspace through methods; defineSet() and set(). While named sets merely group objects logically, methods loadSnapshot and; saveSnapshot allow to make copies of the values, errors and 'constant' status of; sets of variable objects that live in the workspace. A newly added tutorial macro rf510_namedsets.C illustrates the functionality of both; of these features.; Improved printing of contents -- Many operator p.d.f. and function components now show; a more intuitive natural representation of their contents (these changes are mostly in the; respective p.d.f.s, but are most relevant in the context of a workspace). New object factory interface to workspace to facilitate script driven model definition; A object factory has been added to RooFit to simplify the process of creating p.d.f.; and function expressions consisting of multiple objects. The factory has two goals:; the first is t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:17263,simpl,simplify,17263,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['simpl'],['simplify']
Usability,"Cling is (also, but not only) REPL; -----------------------------------. A `read-eval-print-loop <https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop>`_; (**REPL**) is an interactive programming environment that takes user inputs,; executes them, and returns the result to the user. In order to enable; interactivity in C++, Cling provides several extensions to the C++ language:. 1. **Defining functions in the global scope:** Cling redefines expressions at a; global level. C++ provides limited support for this, Cling possesses the; necessary semantics to re-define code while the program is running,; minimizing the impedance mismatch between the **REPL** and the C++ codebase,; and allowing for a seamlessly interactive programing experience. 2. **Allows for implementation of commands** that provide information about the; current state of the environment. e.g., has an `Application Programming; Interface <https://en.wikipedia.org/wiki/API>`_ (**API**) to provide; information about the current state of the environment. 3. **Error recovery:** Cling has an efficient error recovery system which allows; it to handle the errors made by the user without restarting or having to redo; everything from the beginning. 4. **Tight feedback loop:** It provides feedback about the results of the; developer’s choices that is both accurate and fast. 5. **Facilitates debugging:** The programmer can inspect the printed result; before deciding what expression to provide for the next line of code.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/REPL.rst:1246,feedback,feedback,1246,interpreter/cling/docs/chapters/REPL.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/REPL.rst,2,['feedback'],['feedback']
Usability,"Cluster Sizes; =============. A cluster contains all the data of a given event range.; As clusters are usually compressed and tied to event boundaries, an exact size cannot be enforced.; Instead, RNTuple uses a *target size* for the compressed data as a guideline for when to flush a cluster. The default cluster target size is 100 MB of compressed data.; The default can be changed by the `RNTupleWriteOptions`.; The default should work well in the majority of cases.; In general, larger clusters provide room for more and larger pages and should improve compression ratio and speed.; However, clusters also need to be buffered during write and (partially) during read,; so larger clusters increase the memory footprint. A second option in `RNTupleWriteOptions` specifies the maximum uncompressed cluster size.; The default is 1 GiB.; This setting acts as an ""emergency break"" and should prevent very compressible clusters from growing too large. Given the two settings, writing works as follows:; when the current cluster is larger than the maximum uncompressed size, it will be flushed unconditionally.; When the current cluster size reaches the estimate for the compressed cluster size, it will be flushed, too.; The estimated compression ratio for the first cluster is 0.5 if compression is used, and 1 otherwise.; The following clusters use the average compression ratio of all so-far written clusters as an estimate.; See the notes below on a discussion of this approximation. Page Sizes; ==========. Pages contain consecutive elements of a certain column.; They are the unit of compression and of addressability on storage.; RNTuple puts a configurable maximum uncompressed size for pages.; This limit is by default set to 1 MiB.; When the limit is reached, a page will be flushed to disk. In addition, RNTuple maintains a memory budget for the combined allocated size of the pages that are currently filled.; By default, this limit is set to twice the compressed target cluster size when comp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/tuning.md:254,guid,guideline,254,tree/ntuple/v7/doc/tuning.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/tuning.md,1,['guid'],['guideline']
Usability,D; Multiple attribute-specifiers in one attribute-list; Unknown. 2280; C++20; Matching a usual deallocation function with placement new; Unknown. 2281; drafting; Consistency of aligned operator delete replacement; Not resolved. 2282; C++20; Consistency with mismatched aligned/non-over-aligned allocation/deallocation functions; Unknown. 2283; drafting; Missing complete type requirements; Not resolved. 2284; open; Sequencing of braced-init-list arguments; Not resolved. 2285; CD5; Issues with structured bindings; Unknown. 2286; NAD; Assignment evaluation order; Unknown. 2287; CD5; Pointer-interconvertibility in non-standard-layout unions; Unknown. 2288; NAD; Contradictory optionality in simple-declaration; Unknown. 2289; CD5; Uniqueness of structured binding names; Unknown. 2290; CD5; Unclear specification for overload resolution and deleted special member functions; Unknown. 2291; dup; Implicit conversion sequences in non-call contexts; Unknown. 2292; CD5; simple-template-id is ambiguous between class-name and type-name; Clang 9. 2293; CD5; Requirements for simple-template-id used as a class-name; Unknown. 2294; CD5; Dependent auto static data members; Unknown. 2295; CD5; Aggregates with deleted defaulted constructors; Unknown. 2296; open; Are default argument instantiation failures in the “immediate context”?; Not resolved. 2297; open; Unclear specification of atomic operations; Not resolved. 2298; open; Actions and expression evaluation; Not resolved. 2299; CD5; constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address comparison between different member subobjects; Unknown. 2303; CD5; Partial ordering and recursive variadic inheritance; Clang 12. 2304; NAD; Incomplete type vs overload resolution; Unknown. 2305; CD5; Explicit instantiation of constexpr or inline variable template; Unknown. 2306; NAD; Nested friend templates of class,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:156316,simpl,simple-template-id,156316,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['simpl'],['simple-template-id']
Usability,"DF.fitTo(data, BatchMode(""cuda"")); // can also use ""cuda""; ```. ### User-made PDFs; The easiest and most efficient way of accelerating your PDFs is to request their addition to the official RooFit by submitting a ticket [here](https://github.com/root-project/root/issues/new). The ROOT team will gladly assist you and take care of the details. While your code is integrated, you are able to significantly improve the speed of fitting (but not take full advantage of the RooBatchCompute library), at least by using the batch evaluation feature.; To make use of it, one should override `RooAbsReal::computeBatch()`; ``` {.cpp}; void RooMyPDF::computeBatch(RooBatchCompute::RooBatchComputeInterface*, double* output, size_t nEvents, RooBatchCompute::DataMap& dataMap) const; ```; This method must be implemented so that it fills the `output` array with the **normalized** probabilities computed for `nEvents` events, the data of which can be retrieved from `dataMap`. `dataMap` is a simple `std::map<RooRealVar*, std::span<const double>>`. Note that it is not necessary to evaluate any of the objects that the PDF relies to, because they have already been evaluated by the RooFitDriver, so that their updated results are always present in `dataMap`. The `RooBatchCompute::RooBatchComputeInterface` pointer should be ignored. ``` {.cpp}; void RooMyPDF::computeBatch(RooBatchCompute::RooBatchComputeInterface*, double* output, size_t nEvents, RooBatchCompute::DataMap& dataMap) const; {; // Retrieve `std::span`s for each parameter of the PDF; std::span<const double> span1 = dataMap.at(&*proxyVar1);; // or: auto span1 = dataMap.at(&*proxyVar1);; std::span<const double> span2 = dataMap.at(&*proxyVar2);. // let's assume c is a scalar parameter of the PDF. In this case the dataMap contains a std::span with only one value.; std::span<const double> scalar = dataMap.at(&*c);. // Perform computations in a for-loop; // Use VDT if possible to facilitate auto-vectorization; for (size_t i=0; i<nEvents; ++i)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/batchcompute.md:4475,simpl,simple,4475,roofit/doc/developers/batchcompute.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/batchcompute.md,1,['simpl'],['simple']
Usability,"Date: Sat, 18 Nov 2000 09:19:35 -0600 (CST); From: Vikram Adve <vadve@cs.uiuc.edu>; To: Chris Lattner <lattner@cs.uiuc.edu>; Subject: a few thoughts. I've been mulling over the virtual machine problem and I had some; thoughts about some things for us to think about discuss:. 1. We need to be clear on our goals for the VM. Do we want to emphasize; portability and safety like the Java VM? Or shall we focus on the; architecture interface first (i.e., consider the code generation and; processor issues), since the architecture interface question is also; important for portable Java-type VMs?. This is important because the audiences for these two goals are very; different. Architects and many compiler people care much more about; the second question. The Java compiler and OS community care much more; about the first one. Also, while the architecture interface question is important for; Java-type VMs, the design constraints are very different. 2. Design issues to consider (an initial list that we should continue; to modify). Note that I'm not trying to suggest actual solutions here,; but just various directions we can pursue:. a. A single-assignment VM, which we've both already been thinking about. b. A strongly-typed VM. One question is do we need the types to be; explicitly declared or should they be inferred by the dynamic compiler?. c. How do we get more high-level information into the VM while keeping; to a low-level VM design?. o Explicit array references as operands? An alternative is; to have just an array type, and let the index computations be; separate 3-operand instructions. o Explicit instructions to handle aliasing, e.g.s:; -- an instruction to say ""I speculate that these two values are not; aliased, but check at runtime"", like speculative execution in; EPIC?; -- or an instruction to check whether two values are aliased and; execute different code depending on the answer, somewhat like; predicated code in EPIC. o (This one is a difficult but powerful idea.); A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeas.txt:293,clear,clear,293,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeas.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeas.txt,1,['clear'],['clear']
Usability,"Date: Sun, 12 May 2002 17:12:53 -0500 (CDT); From: Chris Lattner <sabre@nondot.org>; To: ""Vikram S. Adve"" <vadve@cs.uiuc.edu>; Subject: LLVM change. There is a fairly fundemental change that I would like to make to the LLVM ; infrastructure, but I'd like to know if you see any drawbacks that I ; don't... Basically right now at the basic block level, each basic block contains an ; instruction list (returned by getInstList()) that is a ValueHolder of ; instructions. To iterate over instructions, we must actually iterate over ; the instlist, and access the instructions through the instlist. To add or remove an instruction from a basic block, we need to get an ; iterator to an instruction, which, given just an Instruction*, requires a ; linear search of the basic block the instruction is contained in... just ; to insert an instruction before another instruction, or to delete an ; instruction! This complicates algorithms that should be very simple (like ; simple constant propagation), because they aren't actually sparse anymore,; they have to traverse basic blocks to remove constant propogated ; instructions. Additionally, adding or removing instructions to a basic block ; _invalidates all iterators_ pointing into that block, which is really ; irritating. To fix these problems (and others), I would like to make the ordering of; the instructions be represented with a doubly linked list in the; instructions themselves, instead of an external data structure. This is ; how many other representations do it, and frankly I can't remember why I ; originally implemented it the way I did. Long term, all of the code that depends on the nasty features in the ; instruction list (which can be found by grep'ing for getInstList()) will ; be changed to do nice local transformations. In the short term, I'll ; change the representation, but preserve the interface (including ; getInstList()) so that all of the code doesn't have to change. Iteration over the instructions in a basic block rema",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-05-12-InstListChange.txt:950,simpl,simple,950,interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-05-12-InstListChange.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-05-12-InstListChange.txt,2,['simpl'],['simple']
Usability,"Date: Sun, 19 Nov 2000 16:23:57 -0600 (CST); From: Chris Lattner <sabre@nondot.org>; To: Vikram Adve <vadve@cs.uiuc.edu>; Subject: Re: a few thoughts. Okay... here are a few of my thoughts on this (it's good to know that we; think so alike!):. > 1. We need to be clear on our goals for the VM. Do we want to emphasize; > portability and safety like the Java VM? Or shall we focus on the; > architecture interface first (i.e., consider the code generation and; > processor issues), since the architecture interface question is also; > important for portable Java-type VMs?. I forsee the architecture looking kinda like this: (which is completely; subject to change). 1. The VM code is NOT guaranteed safe in a java sense. Doing so makes it; basically impossible to support C like languages. Besides that,; certifying a register based language as safe at run time would be a; pretty expensive operation to have to do. Additionally, we would like; to be able to statically eliminate many bounds checks in Java; programs... for example. 2. Instead, we can do the following (eventually): ; * Java bytecode is used as our ""safe"" representation (to avoid; reinventing something that we don't add much value to). When the; user chooses to execute Java bytecodes directly (ie, not; precompiled) the runtime compiler can do some very simple; transformations (JIT style) to convert it into valid input for our; VM. Performance is not wonderful, but it works right.; * The file is scheduled to be compiled (rigorously) at a later; time. This could be done by some background process or by a second; processor in the system during idle time or something...; * To keep things ""safe"" ie to enforce a sandbox on Java/foreign code,; we could sign the generated VM code with a host specific private; key. Then before the code is executed/loaded, we can check to see if; the trusted compiler generated the code. This would be much quicker; than having to validate consistency (especially if bounds checks have; been remo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt:263,clear,clear,263,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,1,['clear'],['clear']
Usability,"Date: Thu, 8 Feb 2001 08:42:04 -0600; From: Vikram S. Adve <vadve@cs.uiuc.edu>; To: Chris Lattner <sabre@nondot.org>; Subject: RE: Type notation debate... Chris,. > Okay before you comment, please look at:; >; > http://www.research.att.com/~bs/devXinterview.html. I read this argument. Even before that, I was already in agreement with you; and him that the C declarator syntax is difficult and confusing. But in fact, if you read the entire answer carefully, he came to the same; conclusion I do: that you have to go with familiar syntax over logical; syntax because familiarity is such a strong force:. ""However, familiarity is a strong force. To compare, in English, we; live; more or less happily with the absurd rules for ""to be"" (am, are, is, been,; was, were, ...) and all attempts to simplify are treated with contempt or; (preferably) humor. It be a curious world and it always beed."". > Basically, my argument for this type construction system is that it is; > VERY simple to use and understand (although it IS different than C, it is; > very simple and straightforward, which C is NOT). In fact, I would assert; > that most programmers TODAY do not understand pointers to member; > functions, and have to look up an example when they have to write them. Again, I don't disagree with this at all. But to some extent this; particular problem is inherently difficult. Your syntax for the above; example may be easier for you to read because this is the way you have been; thinking about it. Honestly, I don't find it much easier than the C syntax.; In either case, I would have to look up an example to write pointers to; member functions. But pointers to member functions are nowhere near as common as arrays. And; the old array syntax:; type [ int, int, ...]; is just much more familiar and clear to people than anything new you; introduce, no matter how logical it is. Introducing a new syntax that may; make function pointers easier but makes arrays much more difficult seems; very risky t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt:792,simpl,simplify,792,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt,3,['simpl'],"['simple', 'simplify']"
Usability,"Date: Tue, 18 Sep 2001 00:38:37 -0500 (CDT); From: Chris Lattner <sabre@nondot.org>; To: Vikram S. Adve <vadve@cs.uiuc.edu>; Subject: Idea for a simple, useful link time optimization. In C++ programs, exceptions suck, and here's why:. 1. In virtually all function calls, you must assume that the function; throws an exception, unless it is defined as 'nothrow'. This means; that every function call has to have code to invoke dtors on objects; locally if one is thrown by the function. Most functions don't throw; exceptions, so this code is dead [with all the bad effects of dead; code, including icache pollution].; 2. Declaring a function nothrow causes catch blocks to be added to every; call that isnot provably nothrow. This makes them very slow.; 3. Extra extraneous exception edges reduce the opportunity for code; motion.; 4. EH is typically implemented with large lookup tables. Ours is going to; be much smaller (than the ""standard"" way of doing it) to start with,; but eliminating it entirely would be nice. :); 5. It is physically impossible to correctly put (accurate, correct); exception specifications on generic, templated code. But it is trivial; to analyze instantiations of said code.; 6. Most large C++ programs throw few exceptions. Most well designed; programs only throw exceptions in specific planned portions of the; code. Given our _planned_ model of handling exceptions, all of this would be; pretty trivial to eliminate through some pretty simplistic interprocedural; analysis. The DCE factor alone could probably be pretty significant. The; extra code motion opportunities could also be exploited though... Additionally, this optimization can be implemented in a straight forward; conservative manner, allowing libraries to be optimized or individual; files even (if there are leaf functions visible in the translation unit; that are called). I think it's a reasonable optimization that hasn't really been addressed; (because assembly is way too low level for this), and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-09-18-OptimizeExceptions.txt:145,simpl,simple,145,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-09-18-OptimizeExceptions.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-09-18-OptimizeExceptions.txt,1,['simpl'],['simple']
Usability,"Date: Tue, 6 Feb 2001 20:27:37 -0600 (CST); From: Chris Lattner <sabre@nondot.org>; To: Vikram S. Adve <vadve@cs.uiuc.edu>; Subject: Type notation debate... This is the way that I am currently planning on implementing types:. Primitive Types: ; type ::= void|bool|sbyte|ubyte|short|ushort|int|uint|long|ulong. Method:; typelist ::= typelisth | /*empty*/; typelisth ::= type | typelisth ',' type; type ::= type (typelist). Arrays (without and with size):; type ::= '[' type ']' | '[' INT ',' type ']'. Pointer:; type ::= type '*'. Structure:; type ::= '{' typelist '}'. Packed:; type ::= '<' INT ',' type '>'. Simple examples:. [[ %4, int ]] - array of (array of 4 (int)); [ { int, int } ] - Array of structure; [ < %4, int > ] - Array of 128 bit SIMD packets; int (int, [[int, %4]]) - Method taking a 2d array and int, returning int. Okay before you comment, please look at:. http://www.research.att.com/~bs/devXinterview.html. Search for ""In another interview, you defined the C declarator syntax as; an experiment that failed. However, this syntactic construct has been; around for 27 years and perhaps more; why do you consider it problematic; (except for its cumbersome syntax)?"" and read that response for me. :). Now with this syntax, his example would be represented as:. [ %10, bool (int, int) * ] *. vs . bool (*(*)[10])(int, int). in C. Basically, my argument for this type construction system is that it is; VERY simple to use and understand (although it IS different than C, it is; very simple and straightforward, which C is NOT). In fact, I would assert; that most programmers TODAY do not understand pointers to member; functions, and have to look up an example when they have to write them. In my opinion, it is critically important to have clear and concise type; specifications, because types are going to be all over the programs. Let me know your thoughts on this. :). -Chris. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebate.txt:1424,simpl,simple,1424,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebate.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebate.txt,3,"['clear', 'simpl']","['clear', 'simple']"
Usability,"Date: Wed, 20 Jun 2001 12:32:22 -0500; From: Vikram Adve <vadve@cs.uiuc.edu>; To: Chris Lattner <lattner@cs.uiuc.edu>; Subject: .NET vs. our VM. One significant difference between .NET CLR and our VM is that the CLR; includes full information about classes and inheritance. In fact, I just; sat through the paper on adding templates to .NET CLR, and the speaker; indicated that the goal seems to be to do simple static compilation (very; little lowering or optimization). Also, the templates implementation in CLR; ""relies on dynamic class loading and JIT compilation"". This is an important difference because I think there are some significant; advantages to have a much lower level VM layer, and do significant static; analysis and optimization. I also talked to the lead guy for KAI's C++ compiler (Arch Robison) and he; said that SGI and other commercial compilers have included options to export; their *IR* next to the object code (i.e., .il files) and use them for; link-time code generation. In fact, he said that the .o file was nearly; empty and was entirely generated from the .il at link-time. But he agreed; that this limited the link-time interprocedural optimization to modules; compiled by the same compiler, whereas our approach allows us to link and; optimize modules from multiple different compilers. (Also, of course, they; don't do anything for runtime optimization). All issues to bring up in Related Work. --Vikram. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-20-.NET-Differences.txt:405,simpl,simple,405,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-20-.NET-Differences.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-06-20-.NET-Differences.txt,1,['simpl'],['simple']
Usability,"Date: Wed, 31 Jan 2001 12:04:33 -0600; From: Vikram S. Adve <vadve@cs.uiuc.edu>; To: Chris Lattner <lattner@cs.uiuc.edu>; Subject: another thought. I have a budding idea about making LLVM a little more ambitious: a; customizable runtime system that can be used to implement language-specific; virtual machines for many different languages. E.g., a C vm, a C++ vm, a; Java vm, a Lisp vm, .. The idea would be that LLVM would provide a standard set of runtime features; (some low-level like standard assembly instructions with code generation and; static and runtime optimization; some higher-level like type-safety and; perhaps a garbage collection library). Each language vm would select the; runtime features needed for that language, extending or customizing them as; needed. Most of the machine-dependent code-generation and optimization; features as well as low-level machine-independent optimizations (like PRE); could be provided by LLVM and should be sufficient for any language,; simplifying the language compiler. (This would also help interoperability; between languages.) Also, some or most of the higher-level; machine-independent features like type-safety and access safety should be; reusable by different languages, with minor extensions. The language; compiler could then focus on language-specific analyses and optimizations. The risk is that this sounds like a universal IR -- something that the; compiler community has tried and failed to develop for decades, and is; universally skeptical about. No matter what we say, we won't be able to; convince anyone that we have a universal IR that will work. We need to; think about whether LLVM is different or if has something novel that might; convince people. E.g., the idea of providing a package of separable; features that different languages select from. Also, using SSA with or; without type-safety as the intermediate representation. One interesting starting point would be to discuss how a JVM would be; implemented on top of LLV",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt:988,simpl,simplifying,988,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt,1,['simpl'],['simplifying']
Usability,"Declaring objects as ``const`` is an important tool of enforcing mutation free; algorithms (such as analyses, etc.). For this purpose above iterators come in; constant flavors as ``Value::const_use_iterator`` and; ``Value::const_op_iterator``. They automatically arise when calling; ``use/op_begin()`` on ``const Value*``\ s or ``const User*``\ s respectively.; Upon dereferencing, they return ``const Use*``\ s. Otherwise the above patterns; remain unchanged. .. _iterate_preds:. Iterating over predecessors & successors of blocks; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Iterating over the predecessors and successors of a block is quite easy with the; routines defined in ``""llvm/IR/CFG.h""``. Just use code like this to; iterate over all predecessors of BB:. .. code-block:: c++. #include ""llvm/IR/CFG.h""; BasicBlock *BB = ...;. for (BasicBlock *Pred : predecessors(BB)) {; // ...; }. Similarly, to iterate over successors use ``successors``. .. _simplechanges:. Making simple changes; ---------------------. There are some primitive transformation operations present in the LLVM; infrastructure that are worth knowing about. When performing transformations,; it's fairly common to manipulate the contents of basic blocks. This section; describes some of the common methods for doing so and gives example code. .. _schanges_creating:. Creating and inserting new ``Instruction``\ s; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. *Instantiating Instructions*. Creation of ``Instruction``\ s is straight-forward: simply call the constructor; for the kind of instruction to instantiate and provide the necessary parameters.; For example, an ``AllocaInst`` only *requires* a (const-ptr-to) ``Type``. Thus:. .. code-block:: c++. auto *ai = new AllocaInst(Type::Int32Ty);. will create an ``AllocaInst`` instance that represents the allocation of one; integer in the current stack frame, at run time. Each ``Instruction`` subclass; is likely to have varying default parameters which change th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:113194,simpl,simple,113194,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"Deploying the Virtual Analysis Facility; =======================================. Introduction; ------------. Thanks to CernVM and PROOF on Demand, it is possible to deploy a ready; to use Virtual Analysis Facility on your cloud (either public, private; or even your desktop computer). On the server side, ""configuring"" the Virtual Analysis Facility is; simply a matter of starting a certain number of CernVM virtual machines; that will become part of your PROOF cluster. CernVM uses; contextualization to specialize each virtual machine to be either a head; node or a worker node. The Virtual Analysis Facility comes with many preconfigured things:. - a HTCondor cluster capable of running PROOF on Demand. - certificate authentication. - your experiment's software (if available on CernVM-FS). Obtain the CernVM image and contextualization; ---------------------------------------------. ### Download the CernVM bare image. The Virtual Analysis Facility currently works with *CernVM Batch 2.7.1; 64-bit*. This means that you need to have this CernVM image available; either on your local hard disk (in case of a desktop deployment) or in; your cloud's image repository. > For convenience we provide the direct link for the working versions:; >; > - [CernVM 2.7.1 batch 64-bit for; > **KVM**](https://cernvm.cern.ch/releases/19/cernvm-batch-node-2.7.1-2-3-x86_64.hdd.gz); >; > - [CernVM 2.7.1 batch 64-bit for; > **Xen**](https://cernvm.cern.ch/releases/19/cernvm-batch-node-2.7.1-2-3-x86_64.ext3.gz); >; > Images are gzipped. In most cases you'll need to gunzip them before; > registering to your image repository. ### Create VM configuration profiles. CernVM images are base images supporting boot-time customization via; configuration profiles called ""contexts"". Context creation can be; performed through the [CernVM Online](https://cernvm-online.cern.ch/); website. The site is immediately accessible if you have a CERN account. Go to your [CernVM Online; Dashboard](https://cernvm-online.cern.c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md:354,simpl,simply,354,proof/doc/confman/DeployVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md,1,['simpl'],['simply']
Usability,"Description; Inputs; =================== =============== =============== =======================================; reserved ``s_trap 0x00`` Reserved by hardware.; ``debugtrap(arg)`` ``s_trap 0x01`` ``SGPR0-1``: Reserved for Finalizer HSA ``debugtrap``; ``queue_ptr`` intrinsic (not implemented).; ``VGPR0``:; ``arg``; ``llvm.trap`` ``s_trap 0x02`` ``SGPR0-1``: Causes wave to be halted with the PC at; ``queue_ptr`` the trap instruction. The associated; queue is signalled to put it into the; error state. When the queue is put in; the error state, the waves executing; dispatches on the queue will be; terminated.; ``llvm.debugtrap`` ``s_trap 0x03`` *none* - If debugger not enabled then behaves; as a no-operation. The trap handler; is entered and immediately returns to; continue execution of the wavefront.; - If the debugger is enabled, causes; the debug trap to be reported by the; debugger and the wavefront is put in; the halt state with the PC at the; instruction. The debugger must; increment the PC and resume the wave.; reserved ``s_trap 0x04`` Reserved.; reserved ``s_trap 0x05`` Reserved.; reserved ``s_trap 0x06`` Reserved.; reserved ``s_trap 0x07`` Reserved.; reserved ``s_trap 0x08`` Reserved.; reserved ``s_trap 0xfe`` Reserved.; reserved ``s_trap 0xff`` Reserved.; =================== =============== =============== =======================================. .. .. table:: AMDGPU Trap Handler for AMDHSA OS Code Object V3; :name: amdgpu-trap-handler-for-amdhsa-os-v3-table. =================== =============== =============== =======================================; Usage Code Sequence Trap Handler Description; Inputs; =================== =============== =============== =======================================; reserved ``s_trap 0x00`` Reserved by hardware.; debugger breakpoint ``s_trap 0x01`` *none* Reserved for debugger to use for; breakpoints. Causes wave to be halted; with the PC at the trap instruction.; The debugger is responsible to resume; the wave, including the instr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:381886,resume,resume,381886,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['resume'],['resume']
Usability,"E.SVGRenderer - no need for patched version; 4. When producing 3D graphical images in batch, use normal THREE.CanvasRenderer; 5. Use WebGL renderer in Chrome headless mode for 3D images generation; 6. Provide possibility to create SVG files for canvas or frame (#172); 7. Support text drawing with TH1 bar option; 8. Fix - when drawing text, reserve extra y range to show it correctly; 9. Migrate to Node.js 8, do not support older versions. ## Changes in 5.5.2; 1. Fix - draw TH2Poly bins outline when no content specified; 2. Fix - always set axis interactive handlers (#170); 3. Fix - take into account zaxis properties when drawing color palette (#171). ## Changes in 5.5.1; 1. Fix - adjust v7 part to new class naming convention, started with R; 2. Fix - show RCanvas title; 3. New - implement 'nocache' option for JSROOT scripts loading. When specified in URL with; JSRootCore.js script, tries to avoid scripts caching problem by adding stamp parameter to all URLs; 4. New - provide simple drawing for TObjString (#164). ## Changes in 5.5.0; 1. Introduce JSROOT.StoreJSON() function. It creates JSON code for the; TCanvas with all drawn objects inside. Allows to store current canvas state; 2. Support ""item=img:file.png"" parameter to insert images in existing layout (#151); 3. Support TTree drawing into TGraph (#153), thanks @cozzyd; 4. Let configure ""&toolbar=right"" in URL to change position of tool buttons; 5. Let configure ""&divsize=500x400"" in URL of size of main div element (default - full browser); 6. Implement ""optstat1001"" and ""optfit101"" draw options for histograms; 7. Remove ""autocol"" options - standard ""plc"" should be used instead; 8. Provide drawing of artificial ""$legend"" item - it creates TLegend for all primitives in pad; Can be used when several histograms or several graphs superimposed; 9. Let configure ""&toolbar=vert"" in URL to change orientation of tool buttons; 10. Improve markers and error bars drawing for TH1/TProfile. ## Changes in 5.4.3; 1. Fix - draw fun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:33404,simpl,simple,33404,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['simpl'],['simple']
Usability,"ECACHE_SIZE. The resource variable TTreeCache.Prefill sets the default TTreeCache prefilling; type. The prefill type may be: 0 for no prefilling and 1 to prefill all; the branches. It can be overridden by the environment variable ROOT_TTREECACHE_PREFILL. In particular the default can be set back to the same as in version 5 by; setting TTreeCache.Size (or ROOT_TTREECACHE_SIZE) and TTreeCache.Prefill; (or ROOT_TTREECACHE_PREFILL) both to zero. TTree methods which are expected to modify a cache, like AddBranchToCache, will; attempt to setup a cache of default size if one does not exist, irrespective of; whether the auto cache creation is enabled. Additionally several methods giving; control of the cache have changed return type from void to Int_t, to be able to; return a code to indicate if there was an error. Usually TTree::SetCacheSize will no longer reset the list of branches to be; cached (either set or previously learnt) nor restart the learning phase.; The learning phase is restarted when a new cache is created, e.g. after having; removed a cache with SetCacheSize(0). ### TSelectorDraw. The axis titles in case of a `x:y:z` plot with the option `COLZ` were not correct. ### TParallelCoordVar. Change the format used to print the variables limit for ||-Coord to `%g`. It was; `%6.4f` before. ## Histogram Libraries. ### TFormula. - New version of the TFormula class based on Cling. Formula expressions are now used to create functions which are passed to Cling to be Just In Time compiled.; The expression is therefore compiled using Clang/LLVVM which will give execution time as compiled code and in addition correctness of the result obtained.; - This class is not 100% backward compatible with the old TFormula class, which is still available in ROOT as =ROOT::v5::TFormula=.; Some of the TFormula member funtions available in version 5, such as =Analyze= and =AnalyzeFunction= are not available in the new TFormula class.; On the other hand formula expressions which were valid ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:14817,learn,learning,14817,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['learn'],['learning']
Usability,"E_BUILD_TYPE=RelWithDebInfo`` instead of; ``-DCMAKE_BUILD_TYPE=Release``. This will grant better coverage of; debug info pieces of clang, but will take longer to complete and will; result in a much larger build directory. It's recommended to build the ``all`` target with your instrumented Clang,; since more coverage is often better. b. You should now have a few ``*.profraw`` files in; ``path/to/stage2/profiles/``. You need to merge these using; ``llvm-profdata`` (even if you only have one! The profile merge transforms; profraw into actual profile data, as well). This can be done with; ``/path/to/stage1/llvm-profdata merge; -output=/path/to/output/profdata.prof path/to/stage2/profiles/*.profraw``. 4. Now, build your final, PGO-optimized Clang. To do this, you'll want to pass; the following additional arguments to CMake. - ``-DLLVM_PROFDATA_FILE=/path/to/output/profdata.prof`` - Use the PGO; profile from the previous step.; - ``-DCMAKE_C_COMPILER=/path/to/stage1/clang`` - Use the Clang we built in; step 1.; - ``-DCMAKE_CXX_COMPILER=/path/to/stage1/clang++`` - Same as above. From here, you can build whatever targets you need. .. note::; You may see warnings about a mismatched profile in the build output. These; are generally harmless. To silence them, you can add; ``-DCMAKE_C_FLAGS='-Wno-backend-plugin'; -DCMAKE_CXX_FLAGS='-Wno-backend-plugin'`` to your CMake invocation. Congrats! You now have a Clang built with profile-guided optimizations, and you; can delete all but the final build directory if you'd like. If this worked well for you and you plan on doing it often, there's a slight; optimization that can be made: LLVM and Clang have a tool called tblgen that's; built and run during the build process. While it's potentially nice to build; this for coverage as part of step 3, none of your other builds should benefit; from building it. You can pass the CMake option; ``-DLLVM_NATIVE_TOOL_DIR=/path/to/stage1/bin``; to steps 2 and onward to avoid these useless rebuilds.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst:6712,guid,guided,6712,interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWithPGO.rst,1,['guid'],['guided']
Usability,"E` and `F` will actually position only `A` and; `B `directly into these volumes, taking into account their combined; transformations `A/B` to `C` and `C` to `D/E/F`. This looks much nicer,; is it? In fact, it is and it is not. Of course, we managed to get rid of; the ""unnecessary"" volume `C` in our geometry, but we end-up with a more; flat structure for `D,E` and `F` (more daughters inside). This can get; much worse when extensively used, as in the case: assemblies of; assemblies. For deciding what to choose between using virtual containers or; assemblies for a specific case, one can use for both cases, after the; geometry was closed:. ~~~{.cpp}; gGeoManager->SetTopVolume(ptr_D);; gGeoManager->Test();; gGeoManager->RestoreMasterVolume();; ~~~. The `ptr_D` is a pointer to volume `D` containing the interesting; structure. The test will provide the timing for classifying 1 million; random points inside `D`. \anchor GP01be; #### Examples of Volume Positioning. Now let us make a simple volume representing a copper wire. We suppose; that a medium is already created (see TGeoMedium class on how to; create media). We will create a `TUBE` shape for our wire, having `Rmin=0cm`,; `Rmax=0.01cm` and a half-length `dZ=1cm`:. ~~~{.cpp}; TGeoTube *tube = new TGeoTube(""wire_tube"",0,0.01,1);; ~~~. One may omit the name for the shape `wire_tube,` if no retrieving by; name is further needed during geometry building. Different volumes; having different names and materials can share the same shape. Now let's make the volume for our wire:. ~~~{.cpp}; TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"",tube,ptrCOPPER); //(*); ~~~. (*) Do not bother to delete the media, shapes or volumes that you; have created since all will be automatically cleaned on exit by the; manager class. If we would have taken a look inside `TGeoManager::MakeTube()` method,; we would have been able to create our wire with a single line:. ~~~{.cpp}; TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"",ptrCOPPER,0,0.01,1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:33427,simpl,simple,33427,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"Emissive. For each of these you can select the component via the radio buttons.; Each component can have the red, green and blue values for the component; adjusted via the sliders. You can apply this adjustment to the shape; itself, or to all shapes sharing a common ‘family'. Shapes of the same; family have external objects with the same **`TObject`** name string.; You can also adjust the ‘Opacity' and ‘Shine' for the shapes materials; via the sliders. #### Geometry. Viewer Controls Pane ‘Geometry' tab. Review and modify the shapes X/Y/Z center and scaling factors via the; edit boxes. Selection and editing of shapes is not available via the API; at present. #### Outputting Viewer Contents. The current viewer rendering can be output to an external `EPS` or; `PDF`, using the options under the ‘File' menu on the top menu bar. The; file is named ‘`viewer.eps`' or ‘`viewer.pdf`' and written to the; current ROOT directory. ### The X3D Viewer. The X3D viewer is a fairly simple and limited viewer, capable of showing; basic lines and polygons. It lacks the quality, performance and more; advanced features of the GL Viewer, and additionally is not supported on; Windows. It is not actively developed and you are encouraged to use the; GL Viewer out of preference. The below table presents the main; interactions - these are repeated in the Help dialog of the viewer. Action KeyActionKey. Wireframe Mode wRotate about xx a. Hidden Line Mode eRotate about yy b. Hidden Surface Mode rRotate about zz c. Move object down uAuto-rotate about x1 2 3. Move object up iAuto-rotate about y4 5 6. Move object left lAuto-rotate about z7 8 9. Move object right hToggle controls styleo. Move object forward jToggle stereo displays. Move object backward kToggle blue stereo viewd. Adjust focus (stereo mode) [ ] { }Toggle double bufferf. Rotate object Left mouse button down + move. ### Common 3D Viewer Architecture. The 3D Viewer Architecture provides a common mechanism for viewer; clients to publish 3D o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:121103,simpl,simple,121103,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simple']
Usability,"Event.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // read the tree generated with tree4w. // note that we use ""new"" to create the TFile and TTree objects, because we; // want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");. // create a pointer to an event object for reading the branch values.; Event *event = new Event();; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_split"");; branch->SetAddress(&event);. Int_t nevent = t4->GetEntries();; Int_t nselected = 0;; Int_t nb = 0;; for (Int_t i=0; i<nevent; i++) {; //read branch ""fNtrack""only; bntrack->GetEntry(i);. // reject events with more than 587 tracks; if (event->GetNtrack() > 587)continue;. // read complete accepted event in memory; nb += t4->GetEntry(i);; nselected++;. // print the first accepted event; if (nselected == 1) t4->Show();; // clear tracks array; event->Clear();; }. if (gROOT->IsBatch()) return;; new TBrowser();; t4->StartViewer();; }; ```. Now, let's see how the tree looks like in the tree viewer. ![The tree viewer with tree4 example](pictures/03000103.png). You can see the two branches in the tree in the left panel: the event; branch is split and hence expands when clicked on. The other branch; event not split is not expandable and we can not browse the data; members. The **`TClonesArray`** of tracks `fTracks` is also split because we set; the split level to 2. The output on the command line is the result of; `tree4->Show()`. It shows the first entry with more than 587 tracks:. ``` {.cpp}; ======> EVENT:26; event_split =; fUniqueID = 0; fBits = 50331648; fType[20] = 116 121 112 101 49 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; fNtrack = 585; fNseg = 5834; fNvertex = 17; fFlag = 0; fTemperature = 20.044315; fEvtHdr.fEvtNum = 26; fEvtHdr.fRun = 200; fEvtHdr.fDate = 960312; fTracks = 585; fTracks.fUniqueI",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:65333,clear,clear,65333,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['clear'],['clear']
Usability,"Example project using cling as library <https://github.com/root-project/cling/tree/master/tools/demo>`_; - *Axel Naumann* 2016 GitHub; - This video showcases how to use Cling as a library, and shows how to set up a simple CMake configuration that uses Cling.; * - `Cling C++ interpreter testdrive <https://www.youtube.com/watch?v=1IGTHusaJ18>`_; - *Mika* 2015 Youtube; - In this tutorial, a developer tries Cling for the first time by uploading a few simple C++ user-cases onto Cling, involving also the loading of external files; * - `Building an Order Book in C++ <https://www.youtube.com/watch?v=fxN4xEZvrxI>`_; - *Dimitri Nesteruk* 2015 Youtube; - This demo shows how to build a simple order book using C++, CLion, Google Test and, of course, Cling. ; * - `Cling C++ interpreter testdrive <https://www.youtube.com/watch?v=1IGTHusaJ18>`_; - Dimitri Nesteruk 2015 Youtube; - This tutorial describes Cling’s general features. You will learn how to start Cling on Ubuntu, how to write a simple expression (N=5, N++) and how to define a Class for calculating body mass index. ; * - `Cling Interactive OpenGL Demo <https://www.youtube.com/watch?v=eoIuqLNvzFs>`_; - *Alexander Penev* 2012 Youtube; - This demo shows how to use Cling for interactive OpenGL. A rotating triangle with changing color, a static figure, and a figure with light effects are created.; ; . .. list-table:: Language Interoperability with Cling:; :widths: 25 25 50; :header-rows: 1. * - Link; - Info ; - Description; * - `Compiler Research - Calling C++ libraries from a D-written DSL: A cling/cppyy-based approach <https://www.youtube.com/watch?v=7teqrCNzrD8>`_; - *Alexandru Militaru* 2021 Compiler-Research Meeting; - This video presents D and C++ interoperability through SIL-Cling architecture. .. list-table:: Interactive CUDA C++ with Cling:; :widths: 25 25 50; :header-rows: 1. * - Link; - Info ; - Description; * - `Adding CUDA® Support to Cling: JIT Compile to GPUs <https://www.youtube.com/watch?v=XjjZRhiFDVs>`_; - *Si",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst:5302,learn,learn,5302,interpreter/cling/docs/chapters/references.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst,2,"['learn', 'simpl']","['learn', 'simple']"
Usability,"FP::get(*TheContext, APFloat(0.0));; }. AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);; Builder->CreateStore(InitVal, Alloca);. // Remember the old variable binding so that we can restore the binding when; // we unrecurse.; OldBindings.push_back(NamedValues[VarName]);. // Remember this binding.; NamedValues[VarName] = Alloca;; }. There are more comments here than code. The basic idea is that we emit; the initializer, create the alloca, then update the symbol table to; point to it. Once all the variables are installed in the symbol table,; we evaluate the body of the var/in expression:. .. code-block:: c++. // Codegen the body, now that all vars are in scope.; Value *BodyVal = Body->codegen();; if (!BodyVal); return nullptr;. Finally, before returning, we restore the previous variable bindings:. .. code-block:: c++. // Pop all our variables from scope.; for (unsigned i = 0, e = VarNames.size(); i != e; ++i); NamedValues[VarNames[i].first] = OldBindings[i];. // Return the body computation.; return BodyVal;; }. The end result of all of this is that we get properly scoped variable; definitions, and we even (trivially) allow mutation of them :). With this, we completed what we set out to do. Our nice iterative fib; example from the intro compiles and runs just fine. The mem2reg pass; optimizes all of our stack variables into SSA registers, inserting PHI; nodes where needed, and our front-end remains simple: no ""iterated; dominance frontier"" computation anywhere in sight. Full Code Listing; =================. Here is the complete code listing for our running example, enhanced with; mutable variables and var/in support. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../../examples/Kaleidoscope/Chapter7/toy.cpp; :language: c++. `Next: Compiling to Object Code <LangImpl08.html>`_. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:28956,simpl,simple,28956,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['simpl'],['simple']
Usability,"FT,\; Jonas Rembser, CERN/SFT,\; Enric Tejedor Saavedra, CERN/SFT,\; Aaradhya Saxena, GSOC,\; Oksana Shadura, UNL/CMS,\; Sanjiban Sengupta, GSOC,\; Federico Sossai, CERN/SFT,\; Harshal Shende, GSOC,\; Matevz Tadel, UCSD/CMS,\; Vassil Vassilev, Princeton/CMS,\; Wouter Verkerke, NIKHEF/ATLAS,\; Zef Wolffs, NIKHEF/ATLAS,\; Stefan Wunsch, CERN/SFT. ## Deprecation, Removal, Backward Incompatibilities. - The ""Virtual MonteCarlo"" facility VMC (`montecarlo/vmc`) has been removed from ROOT. The development of this package has moved to a [separate project](https://github.com/vmc-project/). ROOT's copy of VMC was deprecated since v6.18.; - `TTreeProcessorMT::SetMaxTasksPerFilePerWorker` has been removed. `TTreeProcessorMT::SetTasksPerWorkerHint` is a superior alternative.; - `TTree::GetEntry()` and `TTree::GetEvent()` no longer have 0 as the default value for the first parameter `entry`. We are not aware of correct uses of this function without providing an entry number. If you have one, please simply pass `0` from now on.; - `TBufferMerger` is now out of the `Experimental` namespace (`ROOT::Experimental::TBufferMerger` is deprecated, please use `ROOT::TBufferMerger` instead); - RooFit container classes marked as deprecated with this release: `RooHashTable`, `RooNameSet`, `RooSetPair`, and `RooList`. These classes are still available in this release, but will be removed in the next one. Please migrate to STL container classes, such as `std::unordered_map`, `std::set`, and `std::vector`.; - The `RooFit::FitOptions(const char*)` command to steer [RooAbsPdf::fitTo()](https://root.cern.ch/doc/v628/classRooAbsPdf.html) with an option string in now deprecated and will be removed in ROOT v6.28. Please migrate to the RooCmdArg-based fit configuration. The former character flags map to RooFit command arguments as follows:; - `'h'` : RooFit::Hesse(); - `'m'` : RooFit::Minos(); - `'o'` : RooFit::Optimize(1); - `'r'` : RooFit::Save(); - `'t'` : RooFit::Timer(); - `'v'` : RooFit::Verbose();",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:2303,simpl,simply,2303,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['simpl'],['simply']
Usability,"Focus()` - returns `kTRUE` if the flag `kWidgetWantFocus` is; set. ### TGWindow. **`TGWindow`** is a ROOT GUI window base class. It inherits from; **`TGObject`** and **`TGFrame`** derives from it. The application does; not use it directly. It creates and registers a new window within the; system. This window has common characteristics: existing parent,; location, size in height and width (it has a default minimum size 1, 1; under which it cannot shrink), border with particular view, state,; specific attributes. If there are no specified arguments their values; will be taken from the parent. It receives events from the window system; and can paint a representation of itself on the screen. ![](pictures/02000205.jpg). ### Frames. Most of the frame classes are mainly created for arranging widgets in a; window. The class **`TGFrame`** is a subclass of **`TGWindow`**; providing additional window characteristics and overriding some methods; of **`TGWindow`**. It is a base class for the simple widgets as buttons,; labels, etc. Its only purpose is to draw a frame around widgets that do; not have a frame of their own. The main groups of **`TGFrame`** member; functions are:. - Window's functions: `DoRedraw()`, `DeleteWindow()`, `Activate()`,; etc. - Geometry functions: `Move()`, `Resize()`, `SetSize()`, etc. - Graphics handlers: `ChangeBackground()`, `ChangeOptions()`, etc. - Mouse and keyboard functions: `HandleButton()`,; `HandleFocusChange()`, `HandleKey()`, `HandleMotion()`, etc. - Event handlers: `HandleEvent()`, `ProcessEvent()`, `GetSender()`,; `SendMessage()`,` ProcessMessage()`, `GetLastClick()`, etc. ![The GUI classes hierarchy](pictures/02000206.jpg). Ones of **`TGFrame`** member functions provide direct functionality;; others - will be overridden by **`TGFrame`** subclasses to ensure; particular widget's functionality. There are two constructors provided; in **`TGFrame`** class. One creates a frame using an externally created; window:. ``` {.cpp}; TGFrame(TGClient ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:24516,simpl,simple,24516,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability,"From: Chris Lattner <sabre@nondot.org>; To: ""Vikram S. Adve"" <vadve@cs.uiuc.edu>; Subject: Re: LLVM Feedback. I've included your feedback in the /home/vadve/lattner/llvm/docs directory; so that it will live in CVS eventually with the rest of LLVM. I've; significantly updated the documentation to reflect the changes you; suggested, as specified below:. > We should consider eliminating the type annotation in cases where it is; > essentially obvious from the instruction type:; > br bool <cond>, label <iftrue>, label <iffalse>; > I think your point was that making all types explicit improves clarity; > and readability. I agree to some extent, but it also comes at the; > cost of verbosity. And when the types are obvious from people's; > experience (e.g., in the br instruction), it doesn't seem to help as; > much. Very true. We should discuss this more, but my reasoning is more of a; consistency argument. There are VERY few instructions that can have all; of the types eliminated, and doing so when available unnecessarily makes; the language more difficult to handle. Especially when you see 'int; %this' and 'bool %that' all over the place, I think it would be; disorienting to see:. br %predicate, %iftrue, %iffalse. for branches. Even just typing that once gives me the creeps. ;) Like I; said, we should probably discuss this further in person... > On reflection, I really like your idea of having the two different; > switch types (even though they encode implementation techniques rather; > than semantics). It should simplify building the CFG and my guess is it; > could enable some significant optimizations, though we should think; > about which. Great. I added a note to the switch section commenting on how the VM; should just use the instruction type as a hint, and that the; implementation may choose altermate representations (such as predicated; branches). > In the lookup-indirect form of the switch, is there a reason not to; > make the val-type uint?. No. This was something",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt:129,feedback,feedback,129,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,1,['feedback'],['feedback']
Usability,"GUI fully cross-platform. Originally the GUI; classes were based on Hector Peraza's Xclass'95 widget library; <http://xclass.sourceforge.net/>. ## The ROOT GUI Classes. Features of the GUI classes in a nutshell:. - Originally based on the Xclass'95 widget library. - A rich and complete set of widgets. - Win'95 look and feel. - All machine dependent graphics calls abstracted via the; **`TVirtualX`** ""abstract"" class. - Completely scriptable via the C++ interpreter (fast prototyping). - Supports signal/slot event handling as pioneered by Trolltech's Qt. - Full class documentation is generated automatically (as for all ROOT; classes). - Code generation for variety of GUI's. ## Widgets and Frames. The ROOT GUI classes provide of set of components that allow an easy way; to develop cross-platform GUI applications with a Windows look and feel. The main widgets are:. - Simple widgets: labels, icons, push buttons, either with text or; pixmaps, check buttons, radio buttons, menu bars and popup menus,; scroll bars, list boxes, combo boxes, group frames, text entry; widgets, tab widgets, progress bars, sliders, tool tips. - Complex widgets: shutter, toolbar, status bar, list view, list tree. - Common dialogs: File Open/Save, File Properties, Font Selection,; Color Selection, About. - The widgets are shown in frames:. - frame, composite frame, main frame, transient frame, group frame. - Arranged by layout managers:. - horizontal layout, vertical layout, row layout, list layout, tile; layout, matrix layout. Using a combination of layout hints:. - left, right, center x, center y, top, bottom, expand x, expand y,; fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. - in response to actions widgets send messages and emit signals. - associated frames process these messages or the slot methods; connected to the signals are executed. ## TVirtualX. The GUI classes interface to the platform dependent low level graphics; system via the semi-abstract g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:1469,progress bar,progress bars,1469,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['progress bar'],['progress bars']
Usability,"Getting Started/Tutorials; =========================. For those new to the LLVM system. .. toctree::; :hidden:. CompilerWriterInfo; Frontend/PerformanceTips; GettingStarted; GettingStartedVS; ProgrammersManual; tutorial/index; MyFirstTypoFix. :doc:`GettingStarted`; Discusses how to get up and running quickly with the LLVM infrastructure.; Everything from unpacking and compilation of the distribution to execution; of some tools. :doc:`tutorial/index`; Tutorials about using LLVM. Includes a tutorial about making a custom; language with LLVM. :doc:`ProgrammersManual`; Introduction to the general layout of the LLVM sourcebase, important classes; and APIs, and some tips & tricks. :doc:`Frontend/PerformanceTips`; A collection of tips for frontend authors on how to generate IR; which LLVM is able to effectively optimize. :doc:`GettingStartedVS`; An addendum to the main Getting Started guide for those using Visual Studio; on Windows. :doc:`CompilerWriterInfo`; A list of helpful links for compiler writers. :doc:`MyFirstTypoFix`; This tutorial will guide you through the process of making a change to; LLVM, and contributing it back to the LLVM project.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedTutorials.rst:891,guid,guide,891,interpreter/llvm-project/llvm/docs/GettingStartedTutorials.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedTutorials.rst,2,['guid'],['guide']
Usability,"Git:. - ""The 'branch' I most care about is mainline, and losing the ability to say; 'fixed in r1234' (with some sort of monotonically increasing number) would; be a tragic loss."" [LattnerRevNum]_; - ""I like those results sorted by time and the chronology should be obvious, but; timestamps are incredibly cumbersome and make it difficult to verify that a; given checkout matches a given set of results."" [TrickRevNum]_; - ""There is still the major regression with unreadable version numbers.; Given the amount of Bugzilla traffic with 'Fixed in...', that's a; non-trivial issue."" [JSonnRevNum]_; - ""Sequential IDs are important for LNT and llvmlab bisection tool."" [MatthewsRevNum]_. However, Git can emulate this increasing revision number:; ``git rev-list --count <commit-hash>``. This identifier is unique only; within a single branch, but this means the tuple `(num, branch-name)` uniquely; identifies a commit. We can thus use this revision number to ensure that e.g. `clang -v` reports a; user-friendly revision number (e.g. `main-12345` or `4.0-5321`), addressing; the objections raised above with respect to this aspect of Git. What About Branches and Merges?; -------------------------------. In contrast to SVN, Git makes branching easy. Git's commit history is; represented as a DAG, a departure from SVN's linear history. However, we propose; to mandate making merge commits illegal in our canonical Git repository. Unfortunately, GitHub does not support server side hooks to enforce such a; policy. We must rely on the community to avoid pushing merge commits. GitHub offers a feature called `Status Checks`: a branch protected by; `status checks` requires commits to be explicitly allowed before the push can happen.; We could supply a pre-push hook on the client side that would run and check the; history, before allowing the commit being pushed [statuschecks]_.; However this solution would be somewhat fragile (how do you update a script; installed on every developer machine?) and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:5367,user-friendly,user-friendly,5367,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['user-friendly'],['user-friendly']
Usability,"Html`*** object, ***`gMinuit`***; objects, and the array of contours graphs (**`TGraph`**) created when; calling the `Draw` method of a histogram with the `""CONT`, `LIST""`; option. ### Access to the Collection Contents. The current content for a collection listed above can be accessed with; the corresponding `gROOT->GetListOf` method (for example; `gROOT->GetListOfCanvases`). In addition, `gROOT->GetListOfBrowsables`; returns a collection of all objects visible on the left side panel in; the browser. See the image of the Object Browser in the next figure. ![The ROOT Object Browser](pictures/03000094.png). ## Ownership by Other Objects. When an object creates another, the creating object is the owner of the; created one. For example:. ``` {.cpp}; myHisto->Fit(""gaus""); ```. The call to Fit copies the global **`TF1`** Gaussian function and; attaches the copy to the histogram. When the histogram is deleted, the; copy is deleted also. When a pad is deleted or cleared, all objects in the pad with the; `kCanDelete` bit set are deleted automatically. Currently the objects; created by the `DrawCopy` methods, have the `kCanDelete` bit set and; are therefore owned by the pad. ## Ownership by the User. The user owns all objects not described in one of the above cases.; **`TObject`** has two bits, `kCanDelete` and `kMustCleanup`, that; influence how an object is managed (in `TObject::fBits)`. These are in; an enumeration in `TObject.h.` To set these bits do:. ``` {.cpp}; MyObject->SetBit(kCanDelete); MyObject->SetBit(kMustCleanup); ```. The bits can be reset and tested with the `TObject::ResetBit` and; **`TObject::TestBit` methods.**. ### The kCanDelete Bit. The ***`gROOT`*** collections (see above) own their members and will; delete them regardless of the `kCanDelete` bit. In all other; collections, when the collection `Clear` method is called (i.e.; **`TList::Clear())`**, members with the `kCanDelete` bit set, are; deleted and removed from the collection. If the `kCanDelete` bi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ObjectOwnership.md:4943,clear,cleared,4943,documentation/users-guide/ObjectOwnership.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ObjectOwnership.md,1,['clear'],['cleared']
Usability,"I; might let you click on typedefs to expand them. This application would want to; pass significantly more information about types through to the GUI than a; simple flat string. The interface allows this to happen. .. _internals-diag-translation:. Adding Translations to Clang; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Not possible yet! Diagnostic strings should be written in UTF-8, the client can; translate to the relevant code page if needed. Each translation completely; replaces the format string for the diagnostic. .. _SourceLocation:; .. _SourceManager:. The ``SourceLocation`` and ``SourceManager`` classes; ----------------------------------------------------. Strangely enough, the ``SourceLocation`` class represents a location within the; source code of the program. Important design points include:. #. ``sizeof(SourceLocation)`` must be extremely small, as these are embedded; into many AST nodes and are passed around often. Currently it is 32 bits.; #. ``SourceLocation`` must be a simple value object that can be efficiently; copied.; #. We should be able to represent a source location for any byte of any input; file. This includes in the middle of tokens, in whitespace, in trigraphs,; etc.; #. A ``SourceLocation`` must encode the current ``#include`` stack that was; active when the location was processed. For example, if the location; corresponds to a token, it should contain the set of ``#include``\ s active; when the token was lexed. This allows us to print the ``#include`` stack; for a diagnostic.; #. ``SourceLocation`` must be able to describe macro expansions, capturing both; the ultimate instantiation point and the source of the original character; data. In practice, the ``SourceLocation`` works together with the ``SourceManager``; class to encode two pieces of information about a location: its spelling; location and its expansion location. For most tokens, these will be the; same. However, for a macro expansion (or tokens that came from a ``_Pragma``; directive) the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:23506,simpl,simple,23506,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"IRgen optimization opportunities. //===---------------------------------------------------------------------===//. The common pattern of; --; short x; // or char, etc; (x == 10); --; generates an zext/sext of x which can easily be avoided. //===---------------------------------------------------------------------===//. Bitfields accesses can be shifted to simplify masking and sign; extension. For example, if the bitfield width is 8 and it is; appropriately aligned then is is a lot shorter to just load the char; directly. //===---------------------------------------------------------------------===//. It may be worth avoiding creation of alloca's for formal arguments; for the common situation where the argument is never written to or has; its address taken. The idea would be to begin generating code by using; the argument directly and if its address is taken or it is stored to; then generate the alloca and patch up the existing code. In theory, the same optimization could be a win for block local; variables as long as the declaration dominates all statements in the; block. NOTE: The main case we care about this for is for -O0 -g compile time; performance, and in that scenario we will need to emit the alloca; anyway currently to emit proper debug info. So this is blocked by; being able to emit debug information which refers to an LLVM; temporary, not an alloca. //===---------------------------------------------------------------------===//. We should try and avoid generating basic blocks which only contain; jumps. At -O0, this penalizes us all the way from IRgen (malloc &; instruction overhead), all the way down through code generation and; assembly time. On 176.gcc:expr.ll, it looks like over 12% of basic blocks are just; direct branches!. //===---------------------------------------------------------------------===//; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/README.txt:358,simpl,simplify,358,interpreter/llvm-project/clang/lib/CodeGen/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/README.txt,1,['simpl'],['simplify']
Usability,"I`` to; ``rootcling``/``genreflex`` during build time).; When relocating the shared library, move the .pcm with it.; Once support for C++ modules is fully fleshed out, access to the header file; will no longer be needed. .. _`rootcling manual`: https://root.cern.ch/root/html/guides/users-guide/AddingaClass.html#the-linkdef.h-file; .. _`helper script`: https://github.com/wlav/cppyy/blob/master/test/make_dict_win32.py. Class loader; ^^^^^^^^^^^^. Explicitly loading dictionaries is fine if this is hidden under the hood of; a Python package and thus transparently done on ``import``.; Otherwise, the automatic class loader is more convenient, as it allows direct; use without having to manually find and load dictionaries (assuming these are; locatable by the dynamic loader). The class loader utilizes so-called rootmap files, which by convention should; live alongside the dictionary shared library (and C++ module file).; These are simple text files, which map C++ entities (such as classes) to the; dictionaries and other libraries that need to be loaded for their use. With ``genreflex``, the mapping file can be automatically created with; ``--rootmap-lib=MyClassDict``, where ""MyClassDict"" is the name of the shared; library (without the extension) build from the dictionary file.; With ``rootcling``, create the same mapping file with; ``-rmf MyClassDict.rootmap -rml MyClassDict``.; It is necessary to provide the final library name explicitly, since it is; only in the separate linking step where these names are fixed and those names; may not match the default choice. With the mapping file in place, the above example can be rerun without; explicit loading of the dictionary:. .. code-block:: python. >>> import cppyy; >>> from cppyy.gbl import MyClass; >>> MyClass(42).get_int(); 42; >>>. .. _cppyy-generator:. Bindings collection; -------------------. ``cppyy-generator`` is a clang-based utility program which takes a set of C++; header files and generates a JSON output file describ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:8669,simpl,simple,8669,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,1,['simpl'],['simple']
Usability,"If none is available, the; default implementation is created for the pass to use. All standard rules for; :ref:`interaction between passes <writing-an-llvm-pass-interaction>` still; apply. Although :ref:`Pass Registration <writing-an-llvm-pass-registration>` is; optional for normal passes, all analysis group implementations must be; registered, and must use the :ref:`INITIALIZE_AG_PASS; <writing-an-llvm-pass-RegisterAnalysisGroup>` template to join the; implementation pool. Also, a default implementation of the interface **must**; be registered with :ref:`RegisterAnalysisGroup; <writing-an-llvm-pass-RegisterAnalysisGroup>`. As a concrete example of an Analysis Group in action, consider the; `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`_; analysis group. The default implementation of the alias analysis interface; (the `basic-aa <https://llvm.org/doxygen/structBasicAliasAnalysis.html>`_ pass); just does a few simple checks that don't require significant analysis to; compute (such as: two different globals can never alias each other, etc).; Passes that use the `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`_ interface (for; example the `gvn <https://llvm.org/doxygen/classllvm_1_1GVN.html>`_ pass), do not; care which implementation of alias analysis is actually provided, they just use; the designated interface. From the user's perspective, commands work just like normal. Issuing the; command ``opt -gvn ...`` will cause the ``basic-aa`` class to be instantiated; and added to the pass sequence. Issuing the command ``opt -somefancyaa -gvn; ...`` will cause the ``gvn`` pass to use the ``somefancyaa`` alias analysis; (which doesn't actually exist, it's just a hypothetical example) instead. .. _writing-an-llvm-pass-RegisterAnalysisGroup:. Using ``RegisterAnalysisGroup``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``RegisterAnalysisGroup`` template is used to register the analysis group; itself, while the ``INITIALIZE_AG_PASS`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:37299,simpl,simple,37299,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simple']
Usability,"If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arcanist and forget to add the; ``Differential Revision`` line to your commit message then it is recommended; that you close the review manually. In the web UI, under ""Leap Into Action"" put; the git revision number in the Comment, set the Action to ""Close Revision"" and; click Submit. Note the review must have been Accepted first. Committing someone's change from Phabricator; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. On a clean Git repository on an up to date ``main`` branch run the; following (where ``<Revision>`` is the Phabricator review number):. ::. arc patch D<Revision>. This will create a new branch called ``arcpatch-D<Revision>`` based on the; current ``main`` and will create a commit corresponding to ``D<Revision>`` with a; commit message derived from information in the Phabricator review. Check you are happy with the commit message and amend it if necessa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:14546,guid,guide,14546,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['guid'],['guide']
Usability,"ImageN), /*ImageEnd*/; __start_omp_offloading_entries, /*EntriesBegin*/; __stop_omp_offloading_entries /*EntriesEnd*/; }; };; static const __tgt_bin_desc BinDesc = {; sizeof(Images) / sizeof(Images[0]), /*NumDeviceImages*/; Images, /*DeviceImages*/; __start_omp_offloading_entries, /*HostEntriesBegin*/; __stop_omp_offloading_entries /*HostEntriesEnd*/; };. Global Constructor and Destructor; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The global constructor (``.omp_offloading.descriptor_reg()``) registers the; device images with the runtime by calling the ``__tgt_register_lib()`` runtime; function. The constructor is explicitly defined in ``.text.startup`` section and; is run once when the program starts. Similarly, the global destructor; (``.omp_offloading.descriptor_unreg()``) calls ``__tgt_unregister_lib()`` for; the destructor and is also defined in ``.text.startup`` section and run when the; program exits. Offloading Example; ------------------. This section contains a simple example of generating offloading code using; OpenMP offloading. We will use a simple ``ZAXPY`` BLAS routine. .. code-block:: c++. #include <complex>. using complex = std::complex<double>;. void zaxpy(complex *X, complex *Y, complex D, std::size_t N) {; #pragma omp target teams distribute parallel for; for (std::size_t i = 0; i < N; ++i); Y[i] = D * X[i] + Y[i];; }. int main() {; const std::size_t N = 1024;; complex X[N], Y[N], D;; #pragma omp target data map(to:X[0 : N]) map(tofrom:Y[0 : N]); zaxpy(X, Y, D, N);; }. This code is compiled using the following Clang flags. .. code-block:: console. $ clang++ -fopenmp -fopenmp-targets=nvptx64 -O3 zaxpy.cpp -c. The output section in the object file can be seen using the ``readelf`` utility.; The ``.llvm.offloading`` section has the ``SHF_EXCLUDE`` flag so it will be; removed from the final executable or shared library by the linker. .. code-block:: text. $ llvm-readelf -WS zaxpy.o; Section Headers:; [Nr] Name Type Address Off Size ES Flg Lk Inf Al; [11] omp_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:21753,simpl,simple,21753,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst,1,['simpl'],['simple']
Usability,"Inlining; ========. There are several options that control which calls the analyzer will consider for; inlining. The major one is ``-analyzer-config ipa``:. * ``analyzer-config ipa=none`` - All inlining is disabled. This is the only mode; available in LLVM 3.1 and earlier and in Xcode 4.3 and earlier. * ``analyzer-config ipa=basic-inlining`` - Turns on inlining for C functions, C++; static member functions, and blocks -- essentially, the calls that behave; like simple C function calls. This is essentially the mode used in; Xcode 4.4. * ``analyzer-config ipa=inlining`` - Turns on inlining when we can confidently find; the function/method body corresponding to the call. (C functions, static; functions, devirtualized C++ methods, Objective-C class methods, Objective-C; instance methods when ExprEngine is confident about the dynamic type of the; instance). * ``analyzer-config ipa=dynamic`` - Inline instance methods for which the type is; determined at runtime and we are not 100% sure that our type info is; correct. For virtual calls, inline the most plausible definition. * ``analyzer-config ipa=dynamic-bifurcate`` - Same as -analyzer-config ipa=dynamic,; but the path is split. We inline on one branch and do not inline on the; other. This mode does not drop the coverage in cases when the parent class; has code that is only exercised when some of its methods are overridden. Currently, ``-analyzer-config ipa=dynamic-bifurcate`` is the default mode. While ``-analyzer-config ipa`` determines in general how aggressively the analyzer; will try to inline functions, several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:466,simpl,simple,466,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['simpl'],['simple']
Usability,"Inspect' menu title to 'Tools'; Added 'Event Recorder' menu entry. Here is a screenshot of TGRecorder (GUI interface of the recorder):. New Class: TGPack; New Container class for vertical and horizontal grouping of frames.; It enforces a predictable resizing behaviour on children.; For an example of how to use it, see tutorials/eve/pack.C. TRootBrowser. Make the default url for the HTML plugin of TRootBrowser configurable via rootrc. TGTab. Added a 'Close Tab' icon in TGTabElement, allowing to close a tab element, and emitting a CloseTab(Int_t id) signal. The icon is active only on the actually activated tab.; Implement CloseTab slot usage in TRootBrowser and in TGRootIDE. TGTextEditor. Allow to execute a macro without having to save it first. TGSplitFrame. Added a new signal method Docked(TGFrame*) to notify when a embedded frame has been docked.; Added a new signal method Undocked(TGFrame*) to notify when a embedded frame has been undocked.; Added a new getter method GetUndocked() returning a pointer on undocked frame, if any. TGToolTip. Added new constructor with global x, y position.; If neither fWindow nor fPad are set use global fX, fY that was passed from outside. TGSplitter. Added option to handle frame resizing externally. TGView. Added a protection against possible negative scroll values. TGTextView. Fix bottom line not being properly updated while scrolling.; Solve a problem with vertical slider (avoid negative value when scrolling). TGTextEdit. Fix blinking cursor on some platforms/compilers. TGTextEntry. Added optional parameter 'Bool_t emit' to TGTextEntry::SetText(const char* text, Bool_t emit = kTRUE);; Made the same extension in sub-class TGNumberEntryField. TGCompositeFrame. Added new method virtual TGFrameElement* FindFrameElement(TGFrame *f) const; and use it in several TGCompositeFrame methods to simplify the code. GUIHTML; TGHtml. Implemented HTML <select> with TGListBox/TGCombobox and emit InputSelected(const char *name, const char *val) when ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v522/index.html:1422,undo,undocked,1422,gui/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v522/index.html,1,['undo'],['undocked']
Usability,"Interactivity in C++ with Cling; -------------------------------. **Interactive programming** is a programming approach that allows developers to; change and modify the program as it runs. The final result is a program that; actively responds to a developers’ intuitions, allowing them to make changes in; their code, and to see the result of these changes without interrupting the; running program. Interactive programming gives programmers the freedom to; explore different scenarios while developing software, writing one expression; at a time, figuring out what to do next at each step, and enabling them to; quickly identify and fix bugs whenever they arise. As an example, the; High-Energy Physics community includes professionals with a variety of; backgrounds, including physicists, nuclear engineers, and software; engineers. Cling allows for interactive data analysis in `ROOT; <https://root.cern/>`_ by giving researchers a way to prototype their C++ code,; allowing them to tailor it to the particular scope of the analysis they want to; pursue on a particular set of data before being added to the main framework. **Interpreted language** is a way to achieve interactive programming. In; statically compiled language, all source code is converted into native machine; code and then executed by the processor before being run. An interpreted; language instead runs through source programs line by line, taking an; executable segment of source code, turning it into machine code, and then; executing it. With this approach, when a change is made by the programmer, the; interpreter will convey it without the need for the entire source code to be; manually compiled. Interpreted languages are flexible, and offer features like; dynamic typing and smaller program size. **Cling** is not an interpreter, it is a Just-In-Time (JIT) compiler that feels; like an interpreter, and allows C++, a language designed to be compiled, to be; interpreted. When using Cling, the programmer benefits from ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/interactivity.rst:260,intuit,intuitions,260,interpreter/cling/docs/chapters/interactivity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/interactivity.rst,1,['intuit'],['intuitions']
Usability,"It should also have a defined character as its unique access key. The; second parameter is the popup menu we would like to add. The third one; is an object of **`TGLayoutHints`** type that defines how the menu title; will be laid out in the menu bar. In our example the *`File`* and `Test`; menus will be laid out to the left of the menu bar with 4 pixels; distance in between, the `Help` menu - will be laid out to the right. The menu classes provide a very flexible menu system: you can enable,; disable, add or remove menu items dynamically. The method; `HideEntry(menuID)` hides the menu entry (the entry will not be shown in; the popup menu). To enable a hidden entry you should call; `EnableEntry(menuID)` method. By default all entries are enabled. The; method `DisableEntry(menuID)` helps you to disable a menu entry - it; will appear in sunken relieve. The `DeleteEntry(menuID)` method will; delete the specified entry from the menu. A few words about the menu design. A menu should be kept consistent and; simple. All related items need to be in a popup menu. The cascade menus; should be used judiciously. Try to limit them to one, maximum two; levels. There are some rules for naming the menu objects:. - Define unique names within a menu. - Use capitalized one-word names allowing the quick scan of the menu. - Define unique access key for any menu item. - Indicate by ellipsis (...) after the title with no space when a menu; item will pop-up a dialog box. The proper kind of graphical menus is a critical point to every; application success and depends of three main factors:. - number of presented items in the menu. - how often the menu is used. - how often the menu contents may change. ### Toolbar. ![](pictures/03000217.png). A toolbar (**`TGToolBar`**) is a composite frame that contains; **`TGPictureButton `**objects. It provides an easy and fast access to; most frequently used commands or options across multiple application; screens. Also, it invokes easily a sub applicatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:73432,simpl,simple,73432,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['simpl'],['simple']
Usability,"Itanium Name Demangler Library; ==============================. Introduction; ------------. This directory contains the generic itanium name demangler; library. The main purpose of the library is to demangle C++ symbols,; i.e. convert the string ""_Z1fv"" into ""f()"". You can also use the CRTP; base ManglingParser to perform some simple analysis on the mangled; name, or (in LLVM) use the opaque ItaniumPartialDemangler to query the; demangled AST. Why are there multiple copies of the this library in the source tree?; ---------------------------------------------------------------------. The canonical sources are in libcxxabi/src/demangle and some of the; files are copied to llvm/include/llvm/Demangle. The simple reason for; this comes from before the monorepo, and both [sub]projects need to; demangle symbols, but neither can depend on each other. * libcxxabi needs the demangler to implement __cxa_demangle, which is; part of the itanium ABI spec. * LLVM needs a copy for a bunch of places, and cannot rely on the; system's __cxa_demangle because it a) might not be available (i.e.,; on Windows), and b) may not be up-to-date on the latest language; features. The copy of the demangler in LLVM has some extra stuff that aren't; needed in libcxxabi (ie, the MSVC demangler, ItaniumPartialDemangler),; which depend on the shared generic components. Despite these; differences, we want to keep the ""core"" generic demangling library; identical between both copies to simplify development and testing. If you're working on the generic library, then do the work first in; libcxxabi, then run libcxxabi/src/demangle/cp-to-llvm.sh. This; script takes as an optional argument the path to llvm, and copies the; changes you made to libcxxabi over. Note that this script just; blindly overwrites all changes to the generic library in llvm, so be; careful. Because the core demangler needs to work in libcxxabi, everything; needs to be declared in an anonymous namespace (see; DEMANGLE_NAMESPACE_BEGIN), an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt:329,simpl,simple,329,interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt,2,['simpl'],['simple']
Usability,"Known Bits Analysis; ===================. The Known Bits Analysis pass makes information about the known values of bits; available to other passes to enable transformations like those in the examples; below. The information is lazily computed so you should only pay for what you; use. Examples; --------. A simple example is that transforming::. a + 1. into::. a | 1. is only valid when the addition doesn't carry. In other words it's only valid; if ``a & 1`` is zero. Another example is:. .. code-block:: none. %1:(s32) = G_CONSTANT i32 0xFF0; %2:(s32) = G_AND %0, %1; %3:(s32) = G_CONSTANT i32 0x0FF; %4:(s32) = G_AND %2, %3. We can use the constants and the definition of ``G_AND`` to determine the known; bits:. .. code-block:: none. ; %0 = 0x????????; %1:(s32) = G_CONSTANT i32 0xFF0 ; %1 = 0x00000FF0; %2:(s32) = G_AND %0, %1 ; %2 = 0x00000??0; %3:(s32) = G_CONSTANT i32 0x0FF ; %3 = 0x000000FF; %4:(s32) = G_AND %2, %3 ; %4 = 0x000000?0. and then use this to simplify the expression:. .. code-block:: none. ; %0 = 0x????????; %5:(s32) = G_CONSTANT i32 0x0F0 ; %5 = 0x00000FF0; %4:(s32) = G_AND %0, %5 ; %4 = 0x000000?0. Note that ``%4`` still has the same known bits as before the transformation.; Many transformations share this property. The main exception being when the; transform causes undefined bits to become defined to either zero, one, or; defined but unknown. Usage; -----. To use Known Bits Analysis in a pass, first include the header and register the; dependency with ``INITIALIZE_PASS_DEPENDENCY``. .. code-block:: c++. #include ""llvm/CodeGen/GlobalISel/GISelKnownBits.h"". ... INITIALIZE_PASS_BEGIN(...); INITIALIZE_PASS_DEPENDENCY(GISelKnownBitsAnalysis); INITIALIZE_PASS_END(...). and require the pass in ``getAnalysisUsage``. .. code-block:: c++. void MyPass::getAnalysisUsage(AnalysisUsage &AU) const {; AU.addRequired<GISelKnownBitsAnalysis>();; // Optional: If your pass preserves known bits analysis (many do) then; // indicate that it's preserved for re-use by another pa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/KnownBits.rst:307,simpl,simple,307,interpreter/llvm-project/llvm/docs/GlobalISel/KnownBits.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/KnownBits.rst,2,['simpl'],"['simple', 'simplify']"
Usability,"LE macros/slits.C; ```; [f21]: figures/TF1_DoubleSlit.png ""f21""; <a name=""f21""></a>. ![Output of slits.C with parameters 0.2 and 2.\label{f21}][f21]. The example first asks for user input, namely the ratio of slit width; over slit distance, and the number of slits. After entering this; information, you should see the graphical output as is shown in Figure [2.1](#f21). This is a more complicated example than the ones we have seen before, so; spend some time analysing it carefully, you should have understood it; before continuing. Let us go through it in detail:. Lines *7-18* define the necessary functions in `C++` code, split into; three separate functions, as suggested by the problem considered. The; full interference pattern is given by the product of a function; depending on the ratio of the width and distance of the slits, and a; second one depending on the number of slits. More important for us here; is the definition of the interface of these functions to make them; usable for the ROOT class `TF1`: the first argument is the pointer to; *x*, the second one points to the array of parameters. The main program starts at line 21 with the definition of a function; `slits()` of type `void`. After asking for user input, a ROOT function; is defined using the C-type function given in the beginning. We can now; use all methods of the `TF1` class to control the behaviour of our; function -- nice, isn't it ?. If you like, you can easily extend the example to also plot the; interference pattern of a single slit, using function `double single`,; or of a grid with narrow slits, function `double nslit0`, in `TF1`; instances. Here, we used a macro, some sort of lightweight program, that the; interpreter distributed with ROOT, Cling, is able to execute. This is a; rather extraordinary situation, since `C++` is not natively an interpreted; language! There is much more to say: chapter is indeed dedicated to; macros. ## Controlling ROOT ##. One more remark at this point: as every co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:6596,usab,usable,6596,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['usab'],['usable']
Usability,"LangRef.html#id311>`_:; ""the use of each incoming value is deemed to occur on the edge from the; corresponding predecessor block to the current block"". Now, an; edge to an exit block is considered outside of the loop because; if we take that edge, it leads us clearly out of the loop. However, an edge doesn't actually contain any IR, so in source code,; we have to choose a convention of whether the use happens in; the current block or in the respective predecessor. For LCSSA's purpose,; we consider the use happens in the latter (so as to consider the; use inside) [#point-of-use-phis]_. The major benefit of LCSSA is that it makes many other loop optimizations; simpler. First of all, a simple observation is that if one needs to see all; the outside users, they can just iterate over all the (loop closing); PHI nodes in the exit blocks (the alternative would be to; scan the def-use chain [#def-use-chain]_ of all instructions in the loop). Then, consider for example; :ref:`simple-loop-unswitch <passes-simple-loop-unswitch>` ing the loop above.; Because it is in LCSSA form, we know that any value defined inside of; the loop will be used either only inside the loop or in a loop closing; PHI node. In this case, the only loop closing PHI node is X4.; This means that we can just copy the loop and change the X4; accordingly, like so:. .. code-block:: C. c = ...;; if (c) {; for (...) {; if (true); X1 = ...; else; X2 = ...; X3 = phi(X1, X2);; }; } else {; for (...) {; if (false); X1' = ...; else; X2' = ...; X3' = phi(X1', X2');; }; }; X4 = phi(X3, X3'). Now, all uses of X4 will get the updated value (in general,; if a loop is in LCSSA form, in any loop transformation,; we only need to update the loop closing PHI nodes for the changes; to take effect). If we did not have Loop Closed SSA form, it means that X3 could; possibly be used outside the loop. So, we would have to introduce the; X4 (which is the new X3) and replace all uses of X3 with that.; However, we should note that bec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:13252,simpl,simple-loop-unswitch,13252,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,2,['simpl'],['simple-loop-unswitch']
Usability,"Low-level code; ==============. .. toctree::; :hidden:. C code and older C++ code sometimes makes use of low-level features such as; pointers to builtin types, some of which do not have any Python equivalent; (e.g. ``unsigned short*``).; Furthermore, such codes tend to be ambiguous: the information from header; file is not sufficient to determine the full purpose.; For example, an ``int*`` type may refer to the address of a single ``int``; (an out-parameter, say) or it may refer to an array of ``int``, the ownership; of which is not clear either.; cppyy provides a few low-level helpers and integration with the Python; `ctypes module`_ to cover these cases. Use of these low-level helpers will obviously lead to very ""C-like"" code and; it is recommended to :doc:`pythonize <pythonizations>` the code, perhaps; using the Cling JIT and embedded C++. Note: the low-level module is not loaded by default (since its use is, or; should be, uncommon).; It needs to be imported explicitly:. .. code-block:: python. >>> import cppyy.ll; >>>. `LowLevelView`; --------------. Python has an elaborate array interface (buffer) specification, but no; standard library array type that completely implements it; instead, the; canonical Python array type is the NumPy one.; cppyy introduces the basic ``LowLevelView`` array class to avoid having a; direct dependency on NumPy and to guarantee zero copy.; The ``LowLevelView`` type gives access to array details such as the size,; type, etc. and allows reading/writing of array elements, both for interactive; use and through the buffer interface to allow NumPy to interface with them.; For more complex operations, it's recommended to copy from the; ``LowLevelView`` inta a NumPy array, or to create a NumPy view (see below,; under :ref:`NumPy Casts <npcasts>`). `C/C++ casts`; -------------. C++ instances are auto-casted to the most derived available type, so do not; require explicit casts even when a function returns a pointer to a base; class or interface",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:539,clear,clear,539,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['clear'],['clear']
Usability,"Lowering``'s ``emitPrologue``, you have to emit `CFI; directives <https://sourceware.org/binutils/docs/as/CFI-directives.html>`_; to specify how to calculate the CFA (Canonical Frame Address) and how register; is restored from the address pointed by the CFA with an offset. The assembler; is instructed by CFI directives to build ``.eh_frame`` section, which is used; by th unwinder to unwind stack during exception handling. * ``getExceptionPointerRegister`` and ``getExceptionSelectorRegister``. ``TargetLowering`` must implement both functions. The *personality function*; passes the *exception structure* (a pointer) and *selector value* (an integer); to the landing pad through the registers specified by ``getExceptionPointerRegister``; and ``getExceptionSelectorRegister`` respectively. On most platforms, they; will be GPRs and will be the same as the ones specified in the calling convention. * ``EH_RETURN``. The ISD node represents the undocumented GCC extension ``__builtin_eh_return (offset, handler)``,; which adjusts the stack by offset and then jumps to the handler. ``__builtin_eh_return``; is used in GCC unwinder (`libgcc <https://gcc.gnu.org/onlinedocs/gccint/Libgcc.html>`_),; but not in LLVM unwinder (`libunwind <https://clang.llvm.org/docs/Toolchain.html#unwind-library>`_).; If you are on the top of ``libgcc`` and have particular requirement on your target,; you have to handle ``EH_RETURN`` in ``TargetLowering``. If you don't leverage the existing runtime (``libstdc++`` and ``libgcc``),; you have to take a look on `libc++ <https://libcxx.llvm.org/>`_ and; `libunwind <https://clang.llvm.org/docs/Toolchain.html#unwind-library>`_; to see what have to be done there. For ``libunwind``, you have to do the following. * ``__libunwind_config.h``. Define macros for your target. * ``include/libunwind.h``. Define enum for the target registers. * ``src/Registers.hpp``. Define ``Registers`` class for your target, implement setter and getter functions. * ``src/UnwindCursor.hpp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:36266,undo,undocumented,36266,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['undo'],['undocumented']
Usability,"M does not:. - histogramming. - data handling. - graphics. M is kept as a low-level package with optimal performance. The main usages of M are. - from a user's program (such as int main()...). - from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. - its numerical accuracy (equivalent to its Fortran version). - its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a; two-way strategy was imposed:. - a minimal required interface with minimum interaction with M objects; and with appropriate usage of the standard library (STL): the user's; implementation of the FCNBase class, initial parameter values and; uncertainties are provided by the to M user via std::vectors. - a rich interface which provides the user with more functionality; such as interaction with parameters. The core of the minimization functionality and related tools (the kernel; of M ) should be clearly separated from the user, who is interfacing via; defined user interfaces (the API). ## Internal and external parameters ##. Each of the parameters to the $\mbox{FCN}$ is defined by the user as; belonging to one of the following types:. - Freely variable: allowed to take on any value. - Variable with double sided limits: allowed to vary only between two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:4897,clear,clearly,4897,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['clear'],['clearly']
Usability,"M library. For example, ``llvm::DenseMap`` should; almost always be used instead of ``std::map`` or ``std::unordered_map``, and; ``llvm::SmallVector`` should usually be used instead of ``std::vector``. We explicitly avoid some standard facilities, like the I/O streams, and instead; use LLVM's streams library (raw_ostream_). More detailed information on these; subjects is available in the :doc:`ProgrammersManual`. For more information about LLVM's data structures and the tradeoffs they make,; please consult `that section of the programmer's manual; <https://llvm.org/docs/ProgrammersManual.html#picking-the-right-data-structure-for-a-task>`_. Python version and Source Code Formatting; -----------------------------------------. The current minimum version of Python required is documented in the :doc:`GettingStarted`; section. Python code in the LLVM repository should only use language features; available in this version of Python. The Python code within the LLVM repository should adhere to the formatting guidelines; outlined in `PEP 8 <https://peps.python.org/pep-0008/>`_. For consistency and to limit churn, code should be automatically formatted with; the `black <https://github.com/psf/black>`_ utility, which is PEP 8 compliant.; Use its default rules. For example, avoid specifying ``--line-length`` even; though it does not default to 80. The default rules can change between major; versions of black. In order to avoid unnecessary churn in the formatting rules,; we currently use black version 23.x in LLVM. When contributing a patch unrelated to formatting, you should format only the; Python code that the patch modifies. For this purpose, use the `darker; <https://pypi.org/project/darker/>`_ utility, which runs default black rules; over only the modified Python code. Doing so should ensure the patch will pass; the Python format checks in LLVM's pre-commit CI, which also uses darker. When; contributing a patch specifically for reformatting Python files, use black,; which c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:4929,guid,guidelines,4929,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['guid'],['guidelines']
Usability,"M when running into troubles. Problems can be:. - a bug in M. - an error in the $\mbox{FCN}$. - a highly difficult problem (usually strong correlations among; parameters). - floating–point precision. ## The output from minimization ##. ### The FunctionMinimum ###. The output of the minimizers is the FunctionMinimum. The FunctionMinimum; contains the result of the minimization in both internal parameter; representation and external parameter representation. ### User representable format: MnUserParameterState ###. On request, the result of the minimization is transformed into a user; representable format for parameters and errors, the; MnUserParameterState. ### Access values, errors, covariance ###. The result can be accessed via methods like; MnUserParameterState::value(unsigned int n) and; MnUserParameterState::error(unsigned int n), where $n$ is the index of; the parameter in the list of parameters defined by the user. ### Printout of the result ###. The FunctionMinimum can be printed on the output simply via std::cout.; It will print both the internal and external state, that is parameters,; errors and the covariance matrix (if available). It also tells the user; if M did converge or not by issuing an appropriate message. If a; covariance matrix is available, the global correlation coefficients are; printed as well. ### Global correlation coefficients ###. The global correlation coefficient for parameter $n$ is a number between; zero and one which gives the correlation between parameter $n$ and that; linear combination of all other parameters which is most strongly; correlated with $n$. # M application programming interface (API) #. [api:api]. ## FunctionMinimum ##. [api:fm] The FunctionMinimum is the output of the minimizers and; contains the minimization result. The state at the minimum is available; both in internal and external representations. For the external; representations the return methods. - FunctionMinimum::userState(),. - FunctionMinimum::userParamete",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:36406,simpl,simply,36406,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['simpl'],['simply']
Usability,"M, Alpha, and X86) can be; examined as models for your own ``analyzeBranch`` implementation. Since SPARC; does not implement a useful ``analyzeBranch``, the ARM target implementation is; shown below. ``analyzeBranch`` returns a Boolean value and takes four parameters:. * ``MachineBasicBlock &MBB`` --- The incoming block to be examined. * ``MachineBasicBlock *&TBB`` --- A destination block that is returned. For a; conditional branch that evaluates to true, ``TBB`` is the destination. * ``MachineBasicBlock *&FBB`` --- For a conditional branch that evaluates to; false, ``FBB`` is returned as the destination. * ``std::vector<MachineOperand> &Cond`` --- List of operands to evaluate a; condition for a conditional branch. In the simplest case, if a block ends without a branch, then it falls through; to the successor block. No destination blocks are specified for either ``TBB``; or ``FBB``, so both parameters return ``NULL``. The start of the; ``analyzeBranch`` (see code below for the ARM target) shows the function; parameters and the code for the simplest case. .. code-block:: c++. bool ARMInstrInfo::analyzeBranch(MachineBasicBlock &MBB,; MachineBasicBlock *&TBB,; MachineBasicBlock *&FBB,; std::vector<MachineOperand> &Cond) const; {; MachineBasicBlock::iterator I = MBB.end();; if (I == MBB.begin() || !isUnpredicatedTerminator(--I)); return false;. If a block ends with a single unconditional branch instruction, then; ``analyzeBranch`` (shown below) should return the destination of that branch in; the ``TBB`` parameter. .. code-block:: c++. if (LastOpc == ARM::B || LastOpc == ARM::tB) {; TBB = LastInst->getOperand(0).getMBB();; return false;; }. If a block ends with two unconditional branches, then the second branch is; never reached. In that situation, as shown below, remove the last branch; instruction and return the penultimate branch in the ``TBB`` parameter. .. code-block:: c++. if ((SecondLastOpc == ARM::B || SecondLastOpc == ARM::tB) &&; (LastOpc == ARM::B || LastOpc =",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:48701,simpl,simplest,48701,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['simpl'],['simplest']
Usability,"MPILER_RT_DEFAULT_TARGET_ONLY=ON``; * ``-DLLVM_CONFIG_PATH=/path/to/llvm-config``. The ``build-c-flags`` need to be sufficient to pass the C-make compiler check,; compile compiler-rt, and if you are running the tests, compile and link the; tests. When cross-compiling with clang we will need to pass sufficient; information to generate code for the Arm architecture we are targeting. We will; need to select the Arm target, select the Armv7-A architecture and choose; between using Arm or Thumb.; instructions. For example:. * ``--target=arm-linux-gnueabihf``; * ``-march=armv7a``; * ``-mthumb``. When using a GCC arm-linux-gnueabihf toolchain the following flags are; needed to pick up the includes and libraries:. * ``--gcc-toolchain=/path/to/dir/toolchain``; * ``--sysroot=/path/to/toolchain/arm-linux-gnueabihf/libc``. In this example we will be adding all of the command line options to both; ``CMAKE_C_FLAGS`` and ``CMAKE_ASM_FLAGS``. There are cmake flags to pass some of; these options individually which can be used to simplify the ``build-c-flags``:. * ``-DCMAKE_C_COMPILER_TARGET=""arm-linux-gnueabihf""``; * ``-DCMAKE_ASM_COMPILER_TARGET=""arm-linux-gnueabihf""``; * ``-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN=/path/to/dir/toolchain``; * ``-DCMAKE_SYSROOT=/path/to/dir/toolchain/arm-linux-gnueabihf/libc``. Once cmake has completed the builtins can be built with ``ninja builtins``. Testing compiler-rt builtins using qemu-arm; ===========================================; To test the builtins library we need to add a few more cmake flags to enable; testing and set up the compiler and flags for test case. We must also tell; cmake that we wish to run the tests on ``qemu-arm``. * ``-DCOMPILER_RT_EMULATOR=""qemu-arm -L /path/to/armhf/sysroot``; * ``-DCOMPILER_RT_INCLUDE_TESTS=ON``; * ``-DCOMPILER_RT_TEST_COMPILER=""/path/to/clang""``; * ``-DCOMPILER_RT_TEST_COMPILER_CFLAGS=""test-c-flags""``. The ``/path/to/armhf/sysroot`` should be the same as the one passed to; ``--sysroot`` in the ""build-c-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst:4298,simpl,simplify,4298,interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,1,['simpl'],['simplify']
Usability,"MakeSelector to support more cases of branches names (that includes characters illegal in a C++ symbol); Replace the ReadLeaves virtual function by a fReadLeaves pointer to member function,; this allows the customization of the ReadLeaves function at run-time depending on the; underlying user class layout in TBranchElement. This removes many if statements whose; 'answer' is known at initialization time. Add support for 'array' formula in TTree::Query.; Set the initial value of fCacheSize to zero to indicate clearly that the TreeCache is disabled.; In TChain::SetEntryList use only the treename to lookup the (sub)entryList (instead subdir/treename).; Add support for the branch creation syntax:; TString rootString;; t->Branch(""rootString"",""TString"",&rootString, 1600, 0);; which is 'natural' as it uses the legacy syntax (branch_name,class_name, user_data); but did not work because 'rootString' is an object rather than a pointer to an; object. (However the simplier form:; t->Branch(""rootString"",&rootString, 1600, 0);; works/worked fine). Add type information to the result of TTree::Print in the case of; TBranchElement:; *Br 17 :fH : TH1F* *; *Entries : 20 : Total Size= 19334 bytes File Size = 1671 *; *Baskets : 2 : Basket Size= 16000 bytes Compression= 11.29 *; *............................................................................*; *Br 18 :fTriggerBits : TBits *; *Entries : 20 : Total Size= 1398 bytes File Size = 400 *; *Baskets : 1 : Basket Size= 16000 bytes Compression= 2.23 *; *............................................................................*; *Br 19 :fIsValid : Bool_t *; *Entries : 20 : Total Size= 582 bytes File Size = 92 *; *Baskets : 1 : Basket Size= 16000 bytes Compression= 1.00 *. Add a new function TBranch::SetStatus It is much faster to call this function in case of a Tree with many branches; instead of calling TTree::SetBranchStatus.; Implement TTreeCache::Print that shows information like:; // ******TreeCache statistics for file: cms2.roo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html:4714,simpl,simplier,4714,tree/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html,1,['simpl'],['simplier']
Usability,"Meeting notes: Implementation idea: Exception Handling in C++/Java. The 5/18/01 meeting discussed ideas for implementing exceptions in LLVM.; We decided that the best solution requires a set of library calls provided by; the VM, as well as an extension to the LLVM function invocation syntax. The LLVM function invocation instruction previously looks like this (ignoring; types):. call func(arg1, arg2, arg3). The extension discussed today adds an optional ""with"" clause that ; associates a label with the call site. The new syntax looks like this:. call func(arg1, arg2, arg3) with funcCleanup. This funcHandler always stays tightly associated with the call site (being; encoded directly into the call opcode itself), and should be used whenever; there is cleanup work that needs to be done for the current function if ; an exception is thrown by func (or if we are in a try block). To support this, the VM/Runtime provide the following simple library ; functions (all syntax in this document is very abstract):. typedef struct { something } %frame;; The VM must export a ""frame type"", that is an opaque structure used to ; implement different types of stack walking that may be used by various; language runtime libraries. We imagine that it would be typical to ; represent a frame with a PC and frame pointer pair, although that is not ; required. %frame getStackCurrentFrame();; Get a frame object for the current function. Note that if the current; function was inlined into its caller, the ""current"" frame will belong to; the ""caller"". bool isFirstFrame(%frame f);; Returns true if the specified frame is the top level (first activated) frame; for this thread. For the main thread, this corresponds to the main() ; function, for a spawned thread, it corresponds to the thread function. %frame getNextFrame(%frame f);; Return the previous frame on the stack. This function is undefined if f; satisfies the predicate isFirstFrame(f). Label *getFrameLabel(%frame f);; If a label was associated with",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt:938,simpl,simple,938,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt,1,['simpl'],['simple']
Usability,"MnContours). # Introduction: M basic concepts #. [sec:intro]. ## The organization of M ##. The M package acts on a multiparameter *objective function* which is; called — for historical reasons — the $\mbox{FCN}$ function (see; [howto:fcn]). This function is usually a chisquared or a log–likelihood,; but it could also be a mathematical function. The $\mbox{FCN}$; function needs to be written in for which M defines the pure abstract; base class FCNBase as interface. The user must define and implement the; $\mbox{FCN}$ function in a derived class from FCNBase. Sometimes; this is done by an intermediate program such as HippoDraw@bib-HippoDraw,; in which case M is being used under the control of such an intermediate; program[^1]. The value of the $\mbox{FCN}$ function will in general; depend on one or more variable parameters whose meaning is defined by; the user (or by the intermediate program), but whose trial values are; determined by M . To take a simple example, suppose the problem is to fit a polynomial; through a set of data points. Then the user would write a; $\mbox{FCN}$ which calculates the $\chi^2$ between a polynomial and; the data; the variable parameters of $\mbox{FCN}$ would be the; coefficients of the polynomials. Using objects for minimization from M ,; the user would request M to minimize the $\mbox{FCN}$ with respect; to the parameters, that is, find those values of the coefficients which; give the lowest value of chisquare. The user must therefore supply, in addition to the function to be; analyzed, via a set or sequence of M applications the instructions which; analysis is wanted. The instructions are coded in in the calling program; (main.cpp), which allows looping, conditional execution, and all the; other possibilities of , but not interactivity, since it must be; compiled before execution. ## Design aspects of M in ##. What M is:. - platform independent. - written in an object-oriented way using standard. - independent of any external package. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:2582,simpl,simple,2582,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['simpl'],['simple']
Usability,"Module));; checkCudaErrors(cuCtxDestroy(context));. return 0;; }. You will need to link with the CUDA driver and specify the path to cuda.h. .. code-block:: text. # clang++ sample.cpp -o sample -O2 -g -I/usr/local/cuda-5.5/include -lcuda. We don't need to specify a path to ``libcuda.so`` since this is installed in a; system location by the driver, not the CUDA toolkit. If everything goes as planned, you should see the following output when; running the compiled program:. .. code-block:: text. Using CUDA Device [0]: GeForce GTX 680; Device Compute Capability: 3.0; Launching kernel; Results:; 0 + 0 = 0; 1 + 2 = 3; 2 + 4 = 6; 3 + 6 = 9; 4 + 8 = 12; 5 + 10 = 15; 6 + 12 = 18; 7 + 14 = 21; 8 + 16 = 24; 9 + 18 = 27; 10 + 20 = 30; 11 + 22 = 33; 12 + 24 = 36; 13 + 26 = 39; 14 + 28 = 42; 15 + 30 = 45. .. note::. You will likely see a different device identifier based on your hardware. Tutorial: Linking with Libdevice; ================================. In this tutorial, we show a simple example of linking LLVM IR with the; libdevice library. We will use the same kernel as the previous tutorial,; except that we will compute ``C = pow(A, B)`` instead of ``C = A + B``.; Libdevice provides an ``__nv_powf`` function that we will use. .. code-block:: llvm. target datalayout = ""e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64""; target triple = ""nvptx64-nvidia-cuda"". ; Intrinsic to read X component of thread ID; declare i32 @llvm.nvvm.read.ptx.sreg.tid.x() readnone nounwind; ; libdevice function; declare float @__nv_powf(float, float). define void @kernel(float addrspace(1)* %A,; float addrspace(1)* %B,; float addrspace(1)* %C) {; entry:; ; What is my ID?; %id = tail call i32 @llvm.nvvm.read.ptx.sreg.tid.x() readnone nounwind. ; Compute pointers into A, B, and C; %ptrA = getelementptr float, float addrspace(1)* %A, i32 %id; %ptrB = getelementptr float, float addrspace(1)* %B, i32 %id; %ptrC = getelementptr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:23493,simpl,simple,23493,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['simpl'],['simple']
Usability,"NSNumber numberWithLongLong:42LL]. // floating point literals.; NSNumber *piFloat = @3.141592654F; // equivalent to [NSNumber numberWithFloat:3.141592654F]; NSNumber *piDouble = @3.1415926535; // equivalent to [NSNumber numberWithDouble:3.1415926535]. // BOOL literals.; NSNumber *yesNumber = @YES; // equivalent to [NSNumber numberWithBool:YES]; NSNumber *noNumber = @NO; // equivalent to [NSNumber numberWithBool:NO]. #ifdef __cplusplus; NSNumber *trueNumber = @true; // equivalent to [NSNumber numberWithBool:(BOOL)true]; NSNumber *falseNumber = @false; // equivalent to [NSNumber numberWithBool:(BOOL)false]; #endif; }. Discussion; ----------. NSNumber literals only support literal scalar values after the ``'@'``.; Consequently, ``@INT_MAX`` works, but ``@INT_MIN`` does not, because; they are defined like this:. .. code-block:: objc. #define INT_MAX 2147483647 /* max value for an int */; #define INT_MIN (-2147483647-1) /* min value for an int */. The definition of ``INT_MIN`` is not a simple literal, but a; parenthesized expression. Parenthesized expressions are supported using; the `boxed expression <#objc_boxed_expressions>`_ syntax, which is; described in the next section. Because ``NSNumber`` does not currently support wrapping ``long double``; values, the use of a ``long double NSNumber`` literal (e.g.; ``@123.23L``) will be rejected by the compiler. Previously, the ``BOOL`` type was simply a typedef for ``signed char``,; and ``YES`` and ``NO`` were macros that expand to ``(BOOL)1`` and; ``(BOOL)0`` respectively. To support ``@YES`` and ``@NO`` expressions,; these macros are now defined using new language keywords in; ``<objc/objc.h>``:. .. code-block:: objc. #if __has_feature(objc_bool); #define YES __objc_yes; #define NO __objc_no; #else; #define YES ((BOOL)1); #define NO ((BOOL)0); #endif. The compiler implicitly converts ``__objc_yes`` and ``__objc_no`` to; ``(BOOL)1`` and ``(BOOL)0``. The keywords are used to disambiguate; ``BOOL`` and integer literals. Object",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:3071,simpl,simple,3071,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['simpl'],['simple']
Usability,"NSTANT i32 2, debug-location !14; DBG_VALUE %2(s32), $noreg, !9, !DIExpression(), debug-location !14; %3:_(s32) = G_ADD %0, %2, debug-location !DILocation(line: 4, column: 1, scope: !6); DBG_VALUE %3(s32), $noreg, !9, !DIExpression(), debug-location !DILocation(line: 4, column: 1, scope: !6); %4:_(s32) = G_SUB %3, %1, debug-location !DILocation(line: 5, column: 1, scope: !6); DBG_VALUE %4(s32), $noreg, !9, !DIExpression(), debug-location !DILocation(line: 5, column: 1, scope: !6). By default, ``mir-debugify`` inserts ``DBG_VALUE`` instructions **everywhere**; it is legal to do so. In particular, every (non-PHI) machine instruction that; defines a register must be followed by a ``DBG_VALUE`` use of that def. If; an instruction does not define a register, but can be followed by a debug inst,; MIRDebugify inserts a ``DBG_VALUE`` that references a constant. Insertion of; ``DBG_VALUE``'s can be disabled by setting ``-debugify-level=locations``. To run MIRDebugify once, simply insert ``mir-debugify`` into your ``llc``; invocation, like:. .. code-block:: bash. # Before some other pass.; $ llc -run-pass=mir-debugify,other-pass ... # After some other pass.; $ llc -run-pass=other-pass,mir-debugify ... To run MIRDebugify before each pass in a pipeline, use; ``-debugify-and-strip-all-safe``. This can be combined with ``-start-before``; and ``-start-after``. For example:. .. code-block:: bash. $ llc -debugify-and-strip-all-safe -run-pass=... <other llc args>; $ llc -debugify-and-strip-all-safe -O1 <other llc args>. If you want to check it after each pass in a pipeline, use; ``-debugify-check-and-strip-all-safe``. This can also be combined with; ``-start-before`` and ``-start-after``. For example:. .. code-block:: bash. $ llc -debugify-check-and-strip-all-safe -run-pass=... <other llc args>; $ llc -debugify-check-and-strip-all-safe -O1 <other llc args>. To check all debug info from a test, use ``mir-check-debugify``, like:. .. code-block:: bash. $ llc -run-pass=mir-debugify,other",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:17725,simpl,simply,17725,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['simpl'],['simply']
Usability,"NU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .x = ; t.c:5:36: warning: use of GNU old-style field designator extension; struct point origin = { x: 0.0, y: 0.0 };; ~~ ^; .y = . ""Fix-it"" hints are most useful for; working around common user errors and misconceptions. For example, C++ users; commonly forget the syntax for explicit specialization of class templates,; as in the error in the following example. Again, after describing the problem,; Clang provides the fix--add template<>--as part of the; diagnostic. $ clang t.cpp; t.cpp:9:3: error: template specialization requires 'template<>'; struct iterator_traits<file_iterator> {; ^; template<> . Template Type Diffing; Templates types can be long and difficult to read. More so when part of an; error message. Instead of just printing out the type name, Clang has enough; information to remove the common elements and highlight the differences. To; show the template structure more clearly, the templated type can also be; printed as an indented text tree. Default: template diff with type elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<[...], float>>' to 'vector<map<[...], double>>' for 1st argument;. -fno-elide-type: template diff without elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<int, float>>' to 'vector<map<int, double>>' for 1st argument;. -fdiagnostics-show-template-tree: template tree printing with elision. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; [...],; [float != double]>>. -fdiagnostics-show-template-tree -fno-elide-type: template tree printing with no elision. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; int,; [float != double]>>. Automatic Macro Expansion; Many errors happen in macros that are sometimes deeply nested. With; traditional compilers, you need to dig d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:7763,clear,clearly,7763,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['clear'],['clearly']
Usability,"Name"");. if (!areSameVariable(IncVar, CondVar) || !areSameVariable(IncVar, InitVar)); return;; llvm::outs() << ""Potential array-based loop discovered.\n"";; }. Clang associates a ``VarDecl`` with each variable to represent the variable's; declaration. Since the ""canonical"" form of each declaration is unique by; address, all we need to do is make sure neither ``ValueDecl`` (base class of; ``VarDecl``) is ``NULL`` and compare the canonical Decls. .. code-block:: c++. static bool areSameVariable(const ValueDecl *First, const ValueDecl *Second) {; return First && Second &&; First->getCanonicalDecl() == Second->getCanonicalDecl();; }. If execution reaches the end of ``LoopPrinter::run()``, we know that the; loop shell looks like. .. code-block:: c++. for (int i= 0; i < expr(); ++i) { ... }. For now, we will just print a message explaining that we found a loop.; The next section will deal with recursively traversing the AST to; discover all changes needed. As a side note, it's not as trivial to test if two expressions are the same,; though Clang has already done the hard work for us by providing a way to; canonicalize expressions:. .. code-block:: c++. static bool areSameExpr(ASTContext *Context, const Expr *First,; const Expr *Second) {; if (!First || !Second); return false;; llvm::FoldingSetNodeID FirstID, SecondID;; First->Profile(FirstID, *Context, true);; Second->Profile(SecondID, *Context, true);; return FirstID == SecondID;; }. This code relies on the comparison between two; ``llvm::FoldingSetNodeIDs``. As the documentation for; ``Stmt::Profile()`` indicates, the ``Profile()`` member function builds; a description of a node in the AST, based on its properties, along with; those of its children. ``FoldingSetNodeID`` then serves as a hash we can; use to compare expressions. We will need ``areSameExpr`` later. Before; you run the new code on the additional loops added to; test-files/simple.cpp, try to figure out which ones will be considered; potentially convertible.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:19649,simpl,simple,19649,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['simpl'],['simple']
Usability,"None. Semantics:; """""""""""""""""""". This intrinsic is lowered to refer to a private constant coroutine frame. The; resume and destroy handlers for this frame are empty functions that do nothing.; Note that in different translation units llvm.coro.noop may return different pointers. .. _coro.frame:. 'llvm.coro.frame' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.frame(). Overview:; """""""""""""""""". The '``llvm.coro.frame``' intrinsic returns an address of the coroutine frame of; the enclosing coroutine. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic is lowered to refer to the `coro.begin`_ instruction. This is; a frontend convenience intrinsic that makes it easier to refer to the; coroutine frame. .. _coro.id:. 'llvm.coro.id' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare token @llvm.coro.id(i32 <align>, ptr <promise>, ptr <coroaddr>,; ptr <fnaddrs>). Overview:; """""""""""""""""". The '``llvm.coro.id``' intrinsic returns a token identifying a; switched-resume coroutine. Arguments:; """""""""""""""""""". The first argument provides information on the alignment of the memory returned; by the allocation function and given to `coro.begin` by the first argument. If; this argument is 0, the memory is assumed to be aligned to 2 * sizeof(ptr).; This argument only accepts constants. The second argument, if not `null`, designates a particular alloca instruction; to be a `coroutine promise`_. The third argument is `null` coming out of the frontend. The CoroEarly pass sets; this argument to point to the function this coro.id belongs to. The fourth argument is `null` before coroutine is split, and later is replaced; to point to a private global constant array containing function pointers to; outlined resume and destroy parts of the coroutine. Semantics:; """""""""""""""""""". The purpose of this intrinsic is to tie together `coro.id`, `coro.alloc` and; `coro.begin` belonging to the same coroutine to prevent optimization passes from; duplicating an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:37087,resume,resume,37087,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"Note that the; definition of ""storage"" here refers to the outermost enclosing allocation of any; particular object (so for example, it's never correct to call this function; passing the addresses of fields in the same struct, elements of the same array,; etc.). Query for this feature with ``__has_builtin(__builtin_assume_separate_storage)``. ``__builtin_offsetof``; ----------------------. ``__builtin_offsetof`` is used to implement the ``offsetof`` macro, which; calculates the offset (in bytes) to a given member of the given type. **Syntax**:. .. code-block:: c++. __builtin_offsetof(type-name, member-designator). **Example of Use**:. .. code-block:: c++. struct S {; char c;; int i;; struct T {; float f[2];; } t;; };. const int offset_to_i = __builtin_offsetof(struct S, i);; const int ext1 = __builtin_offsetof(struct U { int i; }, i); // C extension; const int offset_to_subobject = __builtin_offsetof(struct S, t.f[1]);. **Description**:. This builtin is usable in an integer constant expression which returns a value; of type ``size_t``. The value returned is the offset in bytes to the subobject; designated by the member-designator from the beginning of an object of type; ``type-name``. Clang extends the required standard functionality in the; following way:. * In C language modes, the first argument may be the definition of a new type.; Any type declared this way is scoped to the nearest scope containing the call; to the builtin. Query for this feature with ``__has_builtin(__builtin_offsetof)``. ``__builtin_call_with_static_chain``; ------------------------------------. ``__builtin_call_with_static_chain`` is used to perform a static call while; setting updating the static chain register. **Syntax**:. .. code-block:: c++. T __builtin_call_with_static_chain(T expr, void* ptr). **Example of Use**:. .. code-block:: c++. auto v = __builtin_call_with_static_chain(foo(3), foo);. **Description**:. This builtin returns ``expr`` after checking that ``expr`` is a non-member; st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:101419,usab,usable,101419,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['usab'],['usable']
Usability,"OPERTY_class | 0x4000|; +--------------------------------------+-------+. Name Accelerator Tables; -----------------------. Introduction; ^^^^^^^^^^^^. The ""``.debug_pubnames``"" and ""``.debug_pubtypes``"" formats are not what a; debugger needs. The ""``pub``"" in the section name indicates that the entries; in the table are publicly visible names only. This means no static or hidden; functions show up in the ""``.debug_pubnames``"". No static variables or private; class variables are in the ""``.debug_pubtypes``"". Many compilers add different; things to these tables, so we can't rely upon the contents between gcc, icc, or; clang. The typical query given by users tends not to match up with the contents of; these tables. For example, the DWARF spec states that ""In the case of the name; of a function member or static data member of a C++ structure, class or union,; the name presented in the ""``.debug_pubnames``"" section is not the simple name; given by the ``DW_AT_name attribute`` of the referenced debugging information; entry, but rather the fully qualified name of the data or function member.""; So the only names in these tables for complex C++ entries is a fully; qualified name. Debugger users tend not to enter their search strings as; ""``a::b::c(int,const Foo&) const``"", but rather as ""``c``"", ""``b::c``"" , or; ""``a::b::c``"". So the name entered in the name table must be demangled in; order to chop it up appropriately and additional names must be manually entered; into the table to make it effective as a name lookup table for debuggers to; use. All debuggers currently ignore the ""``.debug_pubnames``"" table as a result of; its inconsistent and useless public-only name content making it a waste of; space in the object file. These tables, when they are written to disk, are not; sorted in any way, leaving every debugger to do its own parsing and sorting.; These tables also include an inlined copy of the string values in the table; itself making the tables much larger than they ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:57285,simpl,simple,57285,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['simpl'],['simple']
Usability,"OP_LLVM_entry_value, 1, ...)`` is lowered to; ``DW_OP_entry_value [reg], ...``, which pushes the value ``reg`` had upon; function entry onto the DWARF expression stack. The next ``(N - 1)`` operations will be part of the ``DW_OP_entry_value``; block argument. For example, ``!DIExpression(DW_OP_LLVM_entry_value, 1,; DW_OP_plus_uconst, 123, DW_OP_stack_value)`` specifies an expression where; the entry value of ``reg`` is pushed onto the stack, and is added with 123.; Due to framework limitations ``N`` must be 1, in other words,; ``DW_OP_entry_value`` always refers to the value/address operand of the; instruction. Because ``DW_OP_LLVM_entry_value`` is defined in terms of registers, it is; usually used in MIR, but it is also allowed in LLVM IR when targeting a; :ref:`swiftasync <swiftasync>` argument. The operation is introduced by:. - ``LiveDebugValues`` pass, which applies it to function parameters that; are unmodified throughout the function. Support is limited to simple; register location descriptions, or as indirect locations (e.g.,; parameters passed-by-value to a callee via a pointer to a temporary copy; made in the caller).; - ``AsmPrinter`` pass when a call site parameter value; (``DW_AT_call_site_parameter_value``) is represented as entry value of; the parameter.; - ``CoroSplit`` pass, which may move variables from allocas into a; coroutine frame. If the coroutine frame is a; :ref:`swiftasync <swiftasync>` argument, the variable is described with; an ``DW_OP_LLVM_entry_value`` operation. - ``DW_OP_LLVM_arg, N`` is used in debug intrinsics that refer to more than one; value, such as one that calculates the sum of two registers. This is always; used in combination with an ordered list of values, such that; ``DW_OP_LLVM_arg, N`` refers to the ``N``\ :sup:`th` element in that list. For; example, ``!DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus,; DW_OP_stack_value)`` used with the list ``(%reg1, %reg2)`` would evaluate to; ``%reg1 - reg2``. This lis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:264132,simpl,simple,264132,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability,"Object(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; </script>; ```. Here the default location `https://root.cern/js/latest/` is specified. One always can install JSROOT on private web server.; When JSROOT is used with THttpServer, the address looks like:. ```javascript; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; ```. Loading main module is enough to get public JSROOT functionality - reading files and drawing objects.; One also can load some special components directly like:. ```javascript; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; ```. After script loading one can configure different parameters in `gStyle` object.; It is instance of the `TStyle` object and behaves like `gStyle` variable in ROOT. For instance,; to change stat format using to display value in stats box:. ```javascript; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; ```. There is also `settings` object which contains all other JSROOT settings. For instance,; one can configure custom format for different axes:. ```javascript; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; ```. One also can use `build/jsroot.js` bundle to load all functionality at one and access it via `JSROOT` global handle:. ```javascript; <script src=""https://root.cern/js/latest/build/j",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:35412,simpl,simple,35412,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['simpl'],['simple']
Usability,"P02c; ### Initializing the Direction. In order to move inside geometry starting with the current point, the; modeller needs to know the current direction `(nx,ny,nz)`. This; direction is stored as `Double_t fCurrentDirection[3]` by the navigator; and it represents a direction in the global frame. It can be retrieved; with:. ~~~{.cpp}; Const Double_t *cdir = gGeoManager->GetCurrentDirection();; ~~~. The direction can be initialized in a similar manner as the current; point:. ~~~{.cpp}; gGeoManager->SetCurrentDirection(nx,ny,nz);; // or:; gGeoManager->SetCurrentDirection(Double_t *dir);; ~~~. \anchor GP02d; ### Initializing the State. Setting the initial point and direction is not enough for initializing; tracking. The modeller needs to find out where the initial point is; located in the geometrical hierarchy. Due to the containment based; architecture of the model, this is the deepest positioned object; containing the point. For illustrating this, imagine that we have a; simple structure with a top volume `A` and another one `B `positioned; inside. Since `A `is a top volume, its associated node `A_1` will define; `MARS` and our simple hierarchy of nodes (positioned volumes) will be:; `/A_1/B_1`. Suppose now that the initial point is contained by `B_1`.; This implies by default that the point is also contained by `A_1`, since; `B_1` have to be fully contained by this. After searching the point; location, the modeller will consider that the point is located inside; `B_1`, which will be considered as the representative object (node) for; the current state. This is stored as: `TGeoNode *TGeoNavigator::%fCurrentNode`; and can be asked from the manager class; only after the `'Where am I?'` was completed:. ~~~{.cpp}; TGeoNode *current = gGeoManager->GetCurrentNode();; ~~~. In order to find the location of the current point inside the hierarchy; of nodes, after setting this point it is mandatory to call the; `‘Where am I?'` method:. ~~~{.cpp}; gGeoManager->FindNode();; ~~~. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:65874,simpl,simple,65874,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"ParallelStartup: no; ```. ``` {.cpp}; Proof.StatsHist: no; Proof.StatsTrace: no; Proof.SlaveStatsTrace: no; ```. ``` {.cpp}; Proof.CondorHome: /opt/condor; Proof.CondorConfig: /opt/condor/etc/condor_config; ```. ``` {.cpp}; PEAC.GmUrl: http://somewhere:8080/clarens/; PEAC.LmUrl: http://elsewhere:8080/clarens/; ```. #### Server Authentication in TServerSocket. General setting: file with server access rules. ``` {.cpp}; SrvAuth.DaemonRc: /etc/root/system.daemonrc; ```. Check of host equivalence via `/etc/hosts`.`equiv` or `$HOME/.rhosts`. ``` {.cpp}; SrvAuth.CheckHostsEquivalence: 1; ```. Force file opening via **`TNetFile`** (**`TNetXNGFile`**) if a hostname is; specified in the Url. By default, for local files `TFile::Open()`; invokes directly **`TFile.`**. ``` {.cpp}; TFile.ForceRemote: yes; ```. Special cases for the **`TUrl`** parser, where the special cases are; parsed in a protocol + file part, like rfio:host:/path/file.root,; castor:/path/file.root or /alien/path/file.root. In case the file; namespace descriptor ends with - the namespace is not a part of the; filename. Extend in private .rootrc with a +Url.Special line. ``` {.cpp}; Url.Special: file: rfio: hpss: castor: dcache:; +Url.Special: /alien/- /castor/; ```. #### PROOF XRD Client Variables. Debug level (if \<=0 : none, 1 : low, 2 : medium, 3 : high). ``` {.cpp}; XProof.Debug: 0; ```. Socket read timeout [in secs: default 10 secs]. ``` {.cpp}; XProof.ReadTimeout: 10; ```. `XNet.PrintTAG` - Print a particular string the developers can choose to; quickly recognize the version at run time [default - 0]. Example of custom setting for the Rint application (root.exe). This; overrides the default specified above for a generic application. Color 5; is yellow. ``` {.cpp}; Rint.Canvas.HighLightColor: 5; ```. ## Documentation to Download. - The latest ROOT Users Guide. - <https://root.cern.ch/root/htmldoc/guides/users-guide/ROOTUsersGuide.html>. - ROOT Reference Guide. - <http://root.cern.ch/root/Reference.html>. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:15679,guid,guides,15679,documentation/users-guide/InstallandBuild.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md,2,['guid'],"['guide', 'guides']"
Usability,"ParenExpr();; }; }. Now that you see the definition of this function, it is more obvious why; we can assume the state of CurTok in the various functions. This uses; look-ahead to determine which sort of expression is being inspected, and; then parses it with a function call. Now that basic expressions are handled, we need to handle binary; expressions. They are a bit more complex. Binary Expression Parsing; =========================. Binary expressions are significantly harder to parse because they are; often ambiguous. For example, when given the string ""x+y\*z"", the parser; can choose to parse it as either ""(x+y)\*z"" or ""x+(y\*z)"". With common; definitions from mathematics, we expect the later parse, because ""\*""; (multiplication) has higher *precedence* than ""+"" (addition). There are many ways to handle this, but an elegant and efficient way is; to use `Operator-Precedence; Parsing <http://en.wikipedia.org/wiki/Operator-precedence_parser>`_.; This parsing technique uses the precedence of binary operators to guide; recursion. To start with, we need a table of precedences:. .. code-block:: c++. /// BinopPrecedence - This holds the precedence for each binary operator that is; /// defined.; static std::map<char, int> BinopPrecedence;. /// GetTokPrecedence - Get the precedence of the pending binary operator token.; static int GetTokPrecedence() {; if (!isascii(CurTok)); return -1;. // Make sure it's a declared binop.; int TokPrec = BinopPrecedence[CurTok];; if (TokPrec <= 0) return -1;; return TokPrec;; }. int main() {; // Install standard binary operators.; // 1 is lowest precedence.; BinopPrecedence['<'] = 10;; BinopPrecedence['+'] = 20;; BinopPrecedence['-'] = 20;; BinopPrecedence['*'] = 40; // highest.; ...; }. For the basic form of Kaleidoscope, we will only support 4 binary; operators (this can obviously be extended by you, our brave and intrepid; reader). The ``GetTokPrecedence`` function returns the precedence for; the current token, or -1 if the token is not a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:12692,guid,guide,12692,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['guid'],['guide']
Usability,"Probing /cvmfs/sft.cern.ch... OK. > You might need special configurations for some custom software; > repositories! Special cases are not covered in this guide. ### Firewall configuration. [PROOF on Demand](http://pod.gsi.de/) is very flexible in handling; various cases of network topologies. The best solution would be to allow; all TCP communications between the cluster machines. No other incoming communication is required from the outside. Configuration steps for the head node only; ------------------------------------------. ### Setup HTTPS+SSH (sshcertauth) authentication. > Latest recommended sshcertauth version is 0.8.5.; >; > [Download](https://github.com/dberzano/sshcertauth/archive/v0.8.5.zip); > and [read the; > instructions](http://newton.ph.unito.it/~berzano/w/doku.php?id=proof:sshcertauth). If you want your users to connect to the PROOF cluster using their Grid; user certificate and private key you might be interested in installing; sshcertauth. Please refer to the [installation; guide](http://newton.ph.unito.it/~berzano/w/doku.php?id=proof:sshcertauth); for further information. ### PROOF on Demand. > Latest recommended PROOF on Demand version is 3.12.; >; > **On CernVM-FS:** `/cvmfs/sft.cern.ch/lcg/external/PoD/3.12`; >; > **Source code:** [PoD download page](http://pod.gsi.de/download.html); > and [Installation; > instructions](http://pod.gsi.de/doc/3.12/Installation.html). [PROOF on Demand](http://pod.gsi.de/) is required on the head node and on the; user's client. In case your experiment provides a version of PoD on CernVM-FS you can use; that one. Experiment-independent versions are available from the PH-SFT; cvmfs repository. Only if you have specific reasons while you want to use a customly built; PoD version, download the source code and compile it using the; installation instructions. Please note that [CMake](http://www.cmake.org/) and; [Boost](http://www.boost.org/) are required to build PoD. - After you have built PoD, install it with:. make i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md:4516,guid,guide,4516,proof/doc/confman/ConfigProofPoD.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md,1,['guid'],['guide']
Usability,"Proof(10000,"""") ; // execute 10000 toys through PROOF-lite. gfs.summaryData()->Print() ;. Workspace and factory improvements. The workspace class RooWorkspace has been augmented with several; new features. The import() method now supports a new argument RenameAllVariablesExcept(const char* suffix, const char keepList) which; will rename all variables of the imported function by extended them with a supplied suffix,; except for a given list of variables, which are not renamed.; A new utility function importFromFile() has been added, which is similar to import, except that it take a string; specifier for the object to be imported rather than a reference. The string is expected to be of the form ; fileName:workspaceName:objectName and simplifies import of objects from other workspaces on file. The importFromFile; accepts all arguments accepted by the standard import() method.; Generic objects (inheriting from TObject) can now also be stored in the workspace under an alias name, rather; under their own name, which simplifies management of objects of types like TMatrixD that do not have a settable name. ws.import(matrix,""cov_matrix"") ;. New accessors have been added that return a RooArgSet of all elements of the workspace of a given type, e.g.; allVars(), allPdfs(). The Print() method now accepts option ""t"", which prints the contents tree-style instead of a flat list of components,; as illustrated below. *** Print() ***. p.d.f.s; -------; RooProdPdf::bkg[ ptBkgPdf * mllBkgPdf * effBkgPdf|pt ] = 0.267845; RooEfficiency::effBkgPdf[ cat=cut effFunc=effBkg ] = 0.76916; RooEfficiency::effSigPdf[ cat=cut effFunc=effSig ] = 0.899817; RooAddPdf::genmodel[ Nsig * sig + Nbkg * bkg ] = 0.502276; RooPolynomial::mllBkgPdf[ x=mll coefList=(mbkg_slope) ] = 0.775; RooGaussian::mllSigPdf[ x=mll mean=msig_mean sigma=msig_sigma ] = 1; RooExponential::ptBkgPdf[ x=pt c=pbkg_slope ] = 0.449329; RooExponential::ptSigPdf[ x=pt c=psig_slope ] = 0.818731; RooProdPdf::sig[ ptSigPdf * mllSigPdf * e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:2715,simpl,simplifies,2715,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,1,['simpl'],['simplifies']
Usability,"R (note that; this dump is generated with optimizations disabled for clarity):. .. code-block:: llvm. declare double @putchard(double). define double @printstar(double %n) {; entry:; ; initial value = 1.0 (inlined into phi); br label %loop. loop: ; preds = %loop, %entry; %i = phi double [ 1.000000e+00, %entry ], [ %nextvar, %loop ]; ; body; %calltmp = call double @putchard(double 4.200000e+01); ; increment; %nextvar = fadd double %i, 1.000000e+00. ; termination test; %cmptmp = fcmp ult double %i, %n; %booltmp = uitofp i1 %cmptmp to double; %loopcond = fcmp one double %booltmp, 0.000000e+00; br i1 %loopcond, label %loop, label %afterloop. afterloop: ; preds = %loop; ; loop always returns 0.0; ret double 0.000000e+00; }. This loop contains all the same constructs we saw before: a phi node,; several expressions, and some basic blocks. Let's see how this fits; together. Code Generation for the 'for' Loop; ----------------------------------. The first part of codegen is very simple: we just output the start; expression for the loop value:. .. code-block:: c++. Value *ForExprAST::codegen() {; // Emit the start code first, without 'variable' in scope.; Value *StartVal = Start->codegen();; if (!StartVal); return nullptr;. With this out of the way, the next step is to set up the LLVM basic; block for the start of the loop body. In the case above, the whole loop; body is one block, but remember that the body code itself could consist; of multiple blocks (e.g. if it contains an if/then/else or a for/in; expression). .. code-block:: c++. // Make the new basic block for the loop header, inserting after current; // block.; Function *TheFunction = Builder->GetInsertBlock()->getParent();; BasicBlock *PreheaderBB = Builder->GetInsertBlock();; BasicBlock *LoopBB =; BasicBlock::Create(*TheContext, ""loop"", TheFunction);. // Insert an explicit fall through from the current block to the LoopBB.; Builder->CreateBr(LoopBB);. This code is similar to what we saw for if/then/else. Because we ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:20443,simpl,simple,20443,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['simpl'],['simple']
Usability,"R9 Processor User's Manual <https://openpowerfoundation.org/?resource_lib=power9-processor-users-manual>`_. * `Power Instruction Set Architecture, Version 2.07B <https://openpowerfoundation.org/?resource_lib=ibm-power-isa-version-2-07-b>`_. * `POWER8 Processor User's Manual <https://openpowerfoundation.org/?resource_lib=power8-processor-users-manual>`_. * `Power Instruction Set Architecture, Versions 2.03 through 2.06 (Internet Archive) <https://web.archive.org/web/20121124005736/https://www.power.org/technology-introduction/standards-specifications>`_. * `IBM AIX 7.2 POWER Assembly Reference <https://www.ibm.com/support/knowledgecenter/en/ssw_aix_72/assembler/alangref_kickoff.html>`_. * `IBM AIX/5L for POWER Assembly Reference <http://publibn.boulder.ibm.com/doc_link/en_US/a_doc_lib/aixassem/alangref/alangreftfrm.htm>`_. Embedded PowerPC Processors manuals and docs; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * `Book E: Enhanced PowerPC Architecture <https://www.nxp.com/docs/en/user-guide/BOOK_EUM.pdf>`_. * `EREF: A Programmer's Reference Manual for Freescale Embedded Processors (EREFRM) <https://www.nxp.com/files-static/32bit/doc/ref_manual/EREF_RM.pdf>`_. * `Signal Processing Engine (SPE) Programming Environments Manual: A Supplement to the EREF <https://www.nxp.com/docs/en/reference-manual/SPEPEM.pdf>`_. * `Variable-Length Encoding (VLE) Programming Environments Manual: A Supplement to the EREF <https://www.nxp.com/docs/en/reference-manual/VLEPEM.pdf>`_. Other documents, collections, notes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * `PowerPC Compiler Writer's Guide <http://www.ibm.com/chips/techlib/techlib.nsf/techdocs/852569B20050FF7785256996007558C6>`_; * `Intro to PowerPC Architecture <http://www.ibm.com/developerworks/linux/library/l-powarch/>`_; * `Various IBM specifications and white papers <https://www.power.org/documentation/?document_company=105&document_category=all&publish_year=all&grid_order=DESC&grid_sort=title>`_; * `PowerPC ABI documents <http://pen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst:3237,guid,guide,3237,interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompilerWriterInfo.rst,1,['guid'],['guide']
Usability,"R; ========================================. .. contents::; :local:. Chapter 3 Introduction; ======================. Welcome to Chapter 3 of the ""`Implementing a language with; LLVM <index.html>`_"" tutorial. This chapter shows you how to transform; the `Abstract Syntax Tree <LangImpl02.html>`_, built in Chapter 2, into; LLVM IR. This will teach you a little bit about how LLVM does things, as; well as demonstrate how easy it is to use. It's much more work to build; a lexer and parser than it is to generate LLVM IR code. :). **Please note**: the code in this chapter and later require LLVM 3.7 or; later. LLVM 3.6 and before will not work with it. Also note that you; need to use a version of this tutorial that matches your LLVM release:; If you are using an official LLVM release, use the version of the; documentation included with your release or on the `llvm.org releases; page <https://llvm.org/releases/>`_. Code Generation Setup; =====================. In order to generate LLVM IR, we want some simple setup to get started.; First we define virtual code generation (codegen) methods in each AST; class:. .. code-block:: c++. /// ExprAST - Base class for all expression nodes.; class ExprAST {; public:; virtual ~ExprAST() = default;; virtual Value *codegen() = 0;; };. /// NumberExprAST - Expression class for numeric literals like ""1.0"".; class NumberExprAST : public ExprAST {; double Val;. public:; NumberExprAST(double Val) : Val(Val) {}; Value *codegen() override;; };; ... The codegen() method says to emit IR for that AST node along with all; the things it depends on, and they all return an LLVM Value object.; ""Value"" is the class used to represent a ""`Static Single Assignment; (SSA) <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_; register"" or ""SSA value"" in LLVM. The most distinct aspect of SSA values; is that their value is computed as the related instruction executes, and; it does not get a new value until (and if) the instruction re-executes.; In other",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:1089,simpl,simple,1089,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['simpl'],['simple']
Usability,"RNTuple Introduction; ====================. RNTuple (for n-tuple and nested tuple) is the experimental evolution of TTree columnar data storage. RNTuple introduces; new interfaces that aim to be more robust. In particular, the new interfaces are type-safe through the use of; templates, and the ownership is well-defined through the use of smart pointers. For instance. tree->Branch(""px"", &Category, ""px/F"");. becomes. auto px = model->MakeField<float>(""px"");; // px is std::shared_ptr<float>. The physical layout changes slightly from big endian to little endian so that it matches the in-memory layout on; most modern architectures. Combined with a clear separation of offset/index data and payload data for collections,; uncompressed RNTuple data can be directly mapped to memory without further copies. Goals; -----. RNTuple shall investigate improvements of the TTree I/O in the following ways. 1. More speed; * Improve mapping to vectorized and parallel hardware; * For types known at compile / JIT time: generate optimized code; * Optimized for simple types (float, int, and vectors of them); * Better memory control: work with a fixed budget of pre-defined I/O buffers; * Naturally thread-safe and asynchronous interfaces. 2. More robust interfaces; * Compile-time type safety by default; * Decomposition into layers: logical layer, primitives layer, storage layer; * Separation of data model and live data; * Self-contained I/O code to support creation of a standalone I/O library. Concepts; --------. At the **logical layer**, the user defines a data model using the RNTupleModel class.; The data model is a collection of serializable C++ types with associated names, similar to branches in a TTree.; The data model can contain (nested) collections, e.g., a type can be `std::vector<std::vector<float>>`. Each serializable type is represented by a **field**, concretely by a templated version of RField,; e.g. `RField<double>`. A field can generate or adopt an associated **value**, which re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md:651,clear,clear,651,tree/ntuple/v7/doc/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md,1,['clear'],['clear']
Usability,"ROOT. Since it is an extension module, the usage of `PyROOT` probably comes; naturally if you're used to Python. In general, `PyROOT` attempts to; allow working in both Python and ROOT style, and although it is; succeeding, it isn't perfect: there are edges. The following sections; explain in some detail what you can expect, and what you need to watch; out for. #### Access to ROOT Classes. Before a ROOT class can be used from Python, its dictionary needs to be; loaded into the current process. Starting with ROOT version 4.00/06,; this happens automatically for all classes that are declared to the; auto-loading mechanism through so-called `rootmap` files. Effectively,; this means that all classes in the ROOT distributions are directly; available for import. For example:. ``` {.cpp}; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); ```. Although it is not recommended, a simple way of working with `PyROOT` is; doing a global import:. ``` {.cpp}; from ROOT import *. c = TCanvas(); l = TLorentzVector(); ```. Keeping the ROOT namespace (""`import ROOT`""), or only importing from; ROOT those classes that you will actually use (see above), however, will; always be cleaner and clearer:. ``` {.cpp}; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); ```. Since it is foreseen that most people will use the simple approach; anyway, the request to copy all from module ROOT will not actually; result in copying all ROOT classes into the current namespace. Instead,; classes will still be bound (and possibly loaded) on an as-needed basis.; Note carefully how this is different from other Python (extension); modules, and what to expect if you use the normal inspection tools (such; as e.g. '`dir()`'). This feature prevents the inspection tools from; being swamped by an enormous amount of classes, but they can no longer; be used to explore unknown parts of the system (e.g. to f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:9984,simpl,simple,9984,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['simpl'],['simple']
Usability,"SVDUnfold class; TSVDUnfold implements the singular value decomposition based; unfolding method proposed in NIM A372, 469 (1996); [hep-ph/9509307]. The regularisation is implemented as; a discrete minimum curvature condition. This minimal implementation of; TSVDUnfold provides unfolding of one-dimensional histograms with; equal number of, not necessarily equidistant, bins in the measured and; unfolded distributions. In addition to the unfolding itself,; TSVDUnfold provides. Propagation of covariance matrices from the measured to the unfolded; spectrum via GetUnfoldCovMatrix; Evaluation of covariance matrix due to finite statistics in detector; response via GetAdetCovMatrix; Access to distribution of |d_i| useful for determining the proper; regularisation via GetD; Access to singular values via GetSV. A toy example for the use of TSVDUnfold is included in the math; tutorials (TSVDUnfoldExample.C). New TH2Poly class; TH2Poly is a 2D Histogram class, inheriting from TH2,; allowing to define polygonal bins of arbitary shape. Each bin, in a TH2Poly histogram, is a TH2PolyBin object.; TH2PolyBin is a very simple class containing the vertices, stored; as TGraphs and TMultiGraphs, and the content of the polygonal; bin. Bins are defined using one of the AddBin() methods. The bins definition; should be done before filling. TH2Poly implements a partitioning algorithm to speed up bins' filling.; The following very simple macro shows how to build and fill a TH2Poly:. {; TH2Poly *h2p = new TH2Poly();. Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 4.7, 3.5};. h2p->AddBin(3, x1, y1);; h2p->AddBin(3, x2, y2);; h2p->AddBin(3, x3, y3);. h2p->Fill( 3, 1, 3); // fill bin 1; h2p->Fill(-0.5, -0.5, 7); // fill bin 2; h2p->Fill(-0.7, -0.5, 1); // fill bin 2; h2p->Fill( 1, 3, 5); // fill bin 3; }. More examples can be found in $ROOTSYS/tutorials/hist/:. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:12685,simpl,simple,12685,hist/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html,2,['simpl'],['simple']
Usability,"S_TO_BUILD; Set this equal to the target you wish to build. You may wish to set this to; X86; however, you will find a full list of targets within the; llvm-project/llvm/lib/Target directory. * -DLLVM_OPTIMIZED_TABLEGEN; Set this to ON to generate a fully optimized tablegen during your build. This; will significantly improve your build time. This is only useful if you are; using the Debug build type. * -DLLVM_ENABLE_PROJECTS; Set this equal to the projects you wish to compile (e.g. clang, lld, etc.) If; compiling more than one project, separate the items with a semicolon. Should; you run into issues with the semicolon, try surrounding it with single quotes. * -DLLVM_ENABLE_RUNTIMES; Set this equal to the runtimes you wish to compile (e.g. libcxx, libcxxabi, etc.); If compiling more than one runtime, separate the items with a semicolon. Should; you run into issues with the semicolon, try surrounding it with single quotes. * -DCLANG_ENABLE_STATIC_ANALYZER; Set this option to OFF if you do not require the clang static analyzer. This; should improve your build time slightly. * -DLLVM_USE_SPLIT_DWARF; Consider setting this to ON if you require a debug build, as this will ease; memory pressure on the linker. This will make linking much faster, as the; binaries will not contain any of the debug information; however, this will; generate the debug information in the form of a DWARF object file (with the; extension .dwo). This only applies to host platforms using ELF, such as Linux. .. _links:. Links; =====. This document is just an **introduction** on how to use LLVM to do some simple; things... there are many more interesting and complicated things that you can do; that aren't documented here (but we'll gladly accept a patch if you want to; write something up!). For more information about LLVM, check out:. * `LLVM Homepage <https://llvm.org/>`_; * `LLVM Doxygen Tree <https://llvm.org/doxygen/>`_; * `Starting a Project that Uses LLVM <https://llvm.org/docs/Projects.html>`_; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:47204,simpl,simple,47204,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['simpl'],['simple']
Usability,"Selector to process tree friends. Example of TSelector implementation to process tree friends in PROOF.; See tutorials/proof/runProof.C, option ""eventproc"", for; an example of how to run this selector. \defgroup tutorial_ProofNtuple ProofNtuple; \ingroup tutorial_proof; \brief Selector to fill a simple ntuple. Example of TSelector implementation to do generic processing; (filling a simple ntuple, in this case).; See tutorials/proof/runProof.C, option ""ntuple"", for an; example of how to run this selector. \defgroup tutorial_ProofPythia ProofPythia; \ingroup tutorial_proof; \brief Selector to generate Monte Carlo events with Pythia8. Example of TSelector implementation to do a Monte Carlo; generation using Pythia8.; See tutorials/proof/runProof.C, option ""pythia8"", for an; example of how to run this selector. \defgroup tutorial_ProofSimple ProofSimple; \ingroup tutorial_proof; \brief Selector to fill a set of histograms. Example of TSelector implementation to do generic processing (filling a; set of histograms in this case).; See tutorials/proof/runProof.C, option ""simple"", for an; example of how to run this selector. \defgroup tutorial_ProofSimpleFile ProofSimpleFile; \ingroup tutorial_proof; \brief Selector to fill a set of histograms and merging via file. Example of TSelector implementation to do generic processing; (filling a set of histograms in this case) and merging via; a file, with part of the objects saved in a sub-directory.; See tutorials/proof/runProof.C, option ""simplefile"", for an; example of how to run this selector. \defgroup tutorial_ProofStdVec ProofStdVec; \ingroup tutorial_proof; \brief Selector for generic processing with stdlib collections. Example of TSelector implementation to do generic; processing with stdlib collections.; See tutorials/proof/runProof.C, option ""stdlib"", for an; example of how to run this selector. \defgroup tutorial_ProofTests ProofTests; \ingroup tutorial_proof; \brief Auxilliary selector used to test PROOF functionality; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/proof/index.md:2137,simpl,simple,2137,tutorials/proof/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/proof/index.md,2,['simpl'],"['simple', 'simplefile']"
Usability,"Setup a static PROOF cluster with PROOF on Demand; =================================================. Introduction; ------------. Using PROOF on Demand is our current recommended way of running a PROOF; cluster. The usage of PoD is in particular helpful for the following; reasons:. - **Sandboxing.** Each user get their own personal PROOF cluster,; separated from the others: a problem occurring on one personal; cluster does not affect the workflow of other users. - **Easier administration and self-servicing.** A user can restart their; personal PROOF cluster in case of troubles without waiting for a; system administrator's intervention. - **Efficient multiuser scheduling.** PROOF on Demand makes PROOF run on; top of an existing resource management system, moving the problem of; scheduling many concurrent users outside of PROOF. This guide particularly refers to the setup of a static PROOF cluster; running on physical hosts: the recommended setup is in practice the same; as the ready-to-go Virtual Analysis Facility. If you want to use PROOF; on the clouds there is no configuration to go through. Setup a resource management system; ----------------------------------. Although PROOF on Demand can run on a cluster of nodes without using a; resource management system (using `pod-ssh`), it is recommended to setup a; dedicated one to benefit from the scheduling in a multiuser environment, or a; dedicated queue on an existing one. As there's a variety of resource management systems, this guide does not cover; their setup. The RMS preconfigured for the Virtual Analysis Facility is; [HTCondor](http://research.cs.wisc.edu/htcondor/), which we recommend primarily; because it has dynamic addition of workers built in. Configuration steps for all nodes; ---------------------------------. ### Setup CernVM-FS. [CernVM-FS](http://cernvm.cern.ch/portal/filesystem) should be installed; on all machines as the preferred method for software distribution. > Configuration instructions for the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md:844,guid,guide,844,proof/doc/confman/ConfigProofPoD.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md,1,['guid'],['guide']
Usability,"Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You can even look at the code itself, since ROOT is a; free, open-source product. Use these documents in parallel to this; tutorial!. The ROOT Data Analysis Framework itself is written in and heavily relies; on the `C++` programming language: some knowledge about `C++` is required.; Jus take advantage from the immense available literatur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3484,guid,guide,3484,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['guid'],['guide']
Usability,"Suppose we want to position the; same box inside 2 different volumes and we want the Z size to match the; one of each container:. ~~~{.cpp}; TGeoVolume *container1 = gGeoManager->MakeBox(""C1"",imed,10,10,30);; TGeoVolume *container2 = gGeoManager->MakeBox(""C2"",imed,10,10,20);; TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"",jmed,3,3,-1);; container1->AddNode(pvol,1);; container2->AddNode(pvol,1);; ~~~. Note that the third parameter of `PVOL` is negative, which does not make; sense as half-length on Z. This is interpreted as: when positioned,; create a box replacing all invalid parameters with the corresponding; dimensions of the container. This is also internally handled by the; **`TGeoVolumeMulti`** class, which does not need to be instantiated by; users. \anchor GP01bi; #### Dividing Volumes. Volumes can be divided according a pattern. The simplest division can be; done along one axis that can be: `X,Y,Z,Phi,Rxy or Rxyz`. Let's take a; simple case: we would like to divide a box in N equal slices along X; coordinate, representing a new volume family. Supposing we already have; created the initial box, this can be done like:. ~~~{.cpp}; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N);; ~~~. Here `SLICEX` is the name of the new family representing all slices and; 1 is the slicing axis. The meaning of the axis index is the following:; for all volumes having shapes like `box`, `trd1`, `trd2`, `trap`,; `gtra `or` para - `1, 2, 3 mean X, Y, Z; for `tube`, `tubs`, `cone`,; `cons - `1 means `Rxy`, 2 means `phi` and 3 means Z; for `pcon` and; `pgon` - 2 means `phi` and 3 means Z; for spheres 1 means `R `and 2; means `phi.`. In fact, the division operation has the same effect as positioning; volumes in a given order inside the divided container - the advantage; being that the navigation in such a structure is much faster. When a; volume is divided, a volume family corresponding to the slices is; created. In case all slices can be represented by a single shape, only; one volume ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:44329,simpl,simple,44329,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"T:; call void %FP(); ret void; F:; call fastcc void %FP(); ret void; }; define void @test() {; %X = or i1 false, false; call void @bar(void()* @foo, i1 %X); ret void; }. In this example, ""test"" always passes ``@foo``/``false`` into ``bar``, which; ensures that it is dynamically called with the right calling conv (thus, the; code is perfectly well defined). If you run this through the inliner, you; get this (the explicit ""or"" is there so that the inliner doesn't dead code; eliminate a bunch of stuff):. .. code-block:: llvm. define fastcc void @foo() {; ret void; }; define void @test() {; %X = or i1 false, false; br i1 %X, label %T.i, label %F.i; T.i:; call void @foo(); br label %bar.exit; F.i:; call fastcc void @foo(); br label %bar.exit; bar.exit:; ret void; }. Here you can see that the inlining pass made an undefined call to ``@foo``; with the wrong calling convention. We really don't want to make the inliner; have to know about this sort of thing, so it needs to be valid code. In this; case, dead code elimination can trivially remove the undefined code. However,; if ``%X`` was an input argument to ``@test``, the inliner would produce this:. .. code-block:: llvm. define fastcc void @foo() {; ret void; }. define void @test(i1 %X) {; br i1 %X, label %T.i, label %F.i; T.i:; call void @foo(); br label %bar.exit; F.i:; call fastcc void @foo(); br label %bar.exit; bar.exit:; ret void; }. The interesting thing about this is that ``%X`` *must* be false for the; code to be well-defined, but no amount of dead code elimination will be able; to delete the broken call as unreachable. However, since; ``instcombine``/``simplifycfg`` turns the undefined call into unreachable, we; end up with a branch on a condition that goes to unreachable: a branch to; unreachable can never happen, so ""``-inline -instcombine -simplifycfg``"" is; able to produce:. .. code-block:: llvm. define fastcc void @foo() {; ret void; }; define void @test(i1 %X) {; F.i:; call fastcc void @foo(); ret void; }; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst:12284,simpl,simplifycfg,12284,interpreter/llvm-project/llvm/docs/FAQ.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst,2,['simpl'],['simplifycfg']
Usability,"T>('+', std::move(LHS),; std::move(RHS));. In order to do this, we'll start by defining some basic helper routines:. .. code-block:: c++. /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.; static int CurTok;; static int getNextToken() {; return CurTok = gettok();; }. This implements a simple token buffer around the lexer. This allows us; to look one token ahead at what the lexer is returning. Every function; in our parser will assume that CurTok is the current token that needs to; be parsed. .. code-block:: c++. /// LogError* - These are little helper functions for error handling.; std::unique_ptr<ExprAST> LogError(const char *Str) {; fprintf(stderr, ""Error: %s\n"", Str);; return nullptr;; }; std::unique_ptr<PrototypeAST> LogErrorP(const char *Str) {; LogError(Str);; return nullptr;; }. The ``LogError`` routines are simple helper routines that our parser will; use to handle errors. The error recovery in our parser will not be the; best and is not particular user-friendly, but it will be enough for our; tutorial. These routines make it easier to handle errors in routines; that have various return types: they always return null. With these basic helper functions, we can implement the first piece of; our grammar: numeric literals. Basic Expression Parsing; ========================. We start with numeric literals, because they are the simplest to; process. For each production in our grammar, we'll define a function; which parses that production. For numeric literals, we have:. .. code-block:: c++. /// numberexpr ::= number; static std::unique_ptr<ExprAST> ParseNumberExpr() {; auto Result = std::make_unique<NumberExprAST>(NumVal);; getNextToken(); // consume the number; return std::move(Result);; }. This routine is very simple: it expects to be called when the current; token is a ``tok_number`` token. It takes the curre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:6646,simpl,simple,6646,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['simpl'],['simple']
Usability,"The C API is, in general, a ""best effort"" for stability.; This means that we make every attempt to keep the C API stable, but that; stability will be limited by the abstractness of the interface and the; stability of the C++ API that it wraps. In practice, this means that things; like ""create debug info"" or ""create this type of instruction"" are likely to be; less stable than ""take this IR file and JIT it for my current machine"". * Release stability: We won't break the C API on the release branch with patches; that go on that branch, with the exception that we will fix an unintentional; C API break that will keep the release consistent with both the previous and; next release. * Testing: Patches to the C API are expected to come with tests just like any; other patch. * Including new things into the API: If an LLVM subcomponent has a C API already; included, then expanding that C API is acceptable. Adding C API for; subcomponents that don't currently have one needs to be discussed on the; `LLVM Discourse forums`_ for design and maintainability feedback prior to implementation. * Documentation: Any changes to the C API are required to be documented in the; release notes so that it's clear to external users who do not follow the; project how the C API is changing and evolving. .. _toolchain:. Updating Toolchain Requirements; -------------------------------. We intend to require newer toolchains as time goes by. This means LLVM's; codebase can use newer versions of C++ as they get standardized. Requiring newer; toolchains to build LLVM can be painful for those building LLVM; therefore, it; will only be done through the following process:. * It is a general goal to support LLVM and GCC versions from the last 3 years; at a minimum. This time-based guideline is not strict: we may support much; older compilers, or decide to support fewer versions. * An RFC is sent to the `LLVM Discourse forums`_. - Detail upsides of the version increase (e.g. which newer C++ language or; lib",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:33661,feedback,feedback,33661,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['feedback'],['feedback']
Usability,"There are a couple of special cases for easier typing:. * If the first pass is not a module pass, a pass manager of the first pass is; implicitly created. * For example, the following are equivalent. .. code-block:: shell. $ opt -passes='no-op-function,no-op-function' /tmp/a.ll -S; $ opt -passes='function(no-op-function,no-op-function)' /tmp/a.ll -S. * If there is an adaptor for a pass that lets it fit in the previous pass; manager, that is implicitly created. * For example, the following are equivalent. .. code-block:: shell. $ opt -passes='no-op-function,no-op-loop' /tmp/a.ll -S; $ opt -passes='no-op-function,loop(no-op-loop)' /tmp/a.ll -S. For a list of available passes and analyses, including the IR unit (module,; CGSCC, function, loop) they operate on, run. .. code-block:: shell. $ opt --print-passes. or take a look at ``PassRegistry.def``. To make sure an analysis named ``foo`` is available before a pass, add; ``require<foo>`` to the pass pipeline. This adds a pass that simply requests; that the analysis is run. This pass is also subject to proper nesting. For; example, to make sure some function analysis is already computed for all; functions before a module pass:. .. code-block:: shell. $ opt -passes='function(require<my-function-analysis>),my-module-pass' /tmp/a.ll -S. Status of the New and Legacy Pass Managers; ==========================================. LLVM currently contains two pass managers, the legacy PM and the new PM. The; optimization pipeline (aka the middle-end) uses the new PM, whereas the backend; target-dependent code generation uses the legacy PM. The legacy PM somewhat works with the optimization pipeline, but this is; deprecated and there are ongoing efforts to remove its usage. Some IR passes are considered part of the backend codegen pipeline even if; they are LLVM IR passes (whereas all MIR passes are codegen passes). This; includes anything added via ``TargetPassConfig`` hooks, e.g.; ``TargetPassConfig::addCodeGenPrepare()``. The ``Targ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:20275,simpl,simply,20275,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['simpl'],['simply']
Usability,"There are few key implications of the definitions given above which; are important for working successfully with this interface. * LoopInfo does not contain information about non-loop cycles. As a; result, it is not suitable for any algorithm which requires complete; cycle detection for correctness. * LoopInfo provides an interface for enumerating all top level loops; (e.g. those not contained in any other loop). From there, you may; walk the tree of sub-loops rooted in that top level loop. * Loops which become statically unreachable during optimization *must*; be removed from LoopInfo. If this can not be done for some reason,; then the optimization is *required* to preserve the static; reachability of the loop. .. _loop-terminology-loop-simplify:. Loop Simplify Form; ==================. The Loop Simplify Form is a canonical form that makes; several analyses and transformations simpler and more effective.; It is ensured by the LoopSimplify; (:ref:`-loop-simplify <passes-loop-simplify>`) pass and is automatically; added by the pass managers when scheduling a LoopPass.; This pass is implemented in; `LoopSimplify.h <https://llvm.org/doxygen/LoopSimplify_8h_source.html>`_.; When it is successful, the loop has:. * A preheader.; * A single backedge (which implies that there is a single latch).; * Dedicated exits. That is, no exit block for the loop; has a predecessor that is outside the loop. This implies; that all exit blocks are dominated by the loop header. .. _loop-terminology-lcssa:. Loop Closed SSA (LCSSA); =======================. A program is in Loop Closed SSA Form if it is in SSA form; and all values that are defined in a loop are used only inside; this loop. Programs written in LLVM IR are always in SSA form but not necessarily; in LCSSA. To achieve the latter, for each value that is live across the; loop boundary, single entry PHI nodes are inserted to each of the exit blocks; [#lcssa-construction]_ in order to ""close"" these values inside the loop.; In particul",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:10148,simpl,simplify,10148,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,2,['simpl'],['simplify']
Usability,"These pages contain the documentation for all ROOT classes, and the conceptual structure of the ROOT classes, its modules.; The documentation can be accessed by browsing the modules below,; by accessing a certain class directly using the Class Index,; or by simply searching the reference guide (see search field above).; The ROOT Tutorials show how to use many of ROOT's classes. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/index.html:258,simpl,simply,258,doc/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/index.html,2,"['guid', 'simpl']","['guide', 'simply']"
Usability,"These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class that contains a pointer to a; character and a length, and is quite related to the :ref:`ArrayRef; <dss_arrayref>` class (but specialized for arrays of characters). Because; StringRef carries a length with it, it safely handles strings with embedded nul; characters in it, getting the length does not require a strlen call, and it even; has very convenient APIs for slicing and dicing the character range that it; represents. StringRef is ideal for passing simple strings around that are known to be live,; either because they are C string literals, std::string, a C array, or a; SmallVector. Each of these cases has an efficient implicit conversion to; StringRef, which doesn't result in a dynamic strlen being executed. StringRef has a few major limitations which make more powerful string containers; useful:. #. You cannot directly convert a StringRef to a 'const char*' because there is; no way to add a trailing nul (unlike the .c_str() method on various stronger; classes). #. StringRef doesn't own or keep alive the underlying string bytes.; As such it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:71717,simpl,simple,71717,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"This allows ``ptrtoint`` and arithmetic to be; performed on these values so long as the original value is reconstituted before; the ``indirectbr`` instruction. Finally, some targets may provide defined semantics when using the value; as the operand to an inline assembly, but that is target specific. .. _dso_local_equivalent:. DSO Local Equivalent; --------------------. ``dso_local_equivalent @func``. A '``dso_local_equivalent``' constant represents a function which is; functionally equivalent to a given function, but is always defined in the; current linkage unit. The resulting pointer has the same type as the underlying; function. The resulting pointer is permitted, but not required, to be different; from a pointer to the function, and it may have different values in different; translation units. The target function may not have ``extern_weak`` linkage. ``dso_local_equivalent`` can be implemented as such:. - If the function has local linkage, hidden visibility, or is; ``dso_local``, ``dso_local_equivalent`` can be implemented as simply a pointer; to the function.; - ``dso_local_equivalent`` can be implemented with a stub that tail-calls the; function. Many targets support relocations that resolve at link time to either; a function or a stub for it, depending on if the function is defined within the; linkage unit; LLVM will use this when available. (This is commonly called a; ""PLT stub"".) On other targets, the stub may need to be emitted explicitly. This can be used wherever a ``dso_local`` instance of a function is needed without; needing to explicitly make the original function ``dso_local``. An instance where; this can be used is for static offset calculations between a function and some other; ``dso_local`` symbol. This is especially useful for the Relative VTables C++ ABI,; where dynamic relocations for function pointers in VTables can be replaced with; static relocations for offsets between the VTable and virtual functions which; may not be ``dso_local``. This",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:201688,simpl,simply,201688,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"This directory contains the ROOT::Math::GeneticMinimizer class; BEGIN_HTML; The GeneticMinimizer class is used to implement a genetic minimizer algorithm.; The algorithm is based on an algorithm implemented in the TMVA package; (TMVA::GeneticAlgorithm class).; <p>; The ROOT::Math:GeneticMinimizer class implements the; ROOT::Math::Minimizer interface, as a new plugin with name ""Genetic"".; The class can be used when fitting histograms or graph by selecting it; as default minimizer. This can be done via:; <pre>; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Genetic"");; </pre>; Via the MinimizerOptions, one can control the possible options for the; class. These are described in the TMVA user guide, Option Table 7.; A list of the default options can be obtained by doing:; <pre>; ROOT::Math::Minimizer * min =ROOT::Math::Factory::CreateMinimizer(""Genetic"");; min->Options().Print();; </pre>; The user can change a default option, like the population size to 500; and the steps to 60 by doing:; <pre>; ROOT::Math::MinimizerOptions::Default(""Genetic"").SetValue(""PopSize"",500);; ROOT::Math::MinimizerOptions::Default(""Genetic"").SetValue(""Steps"",60);; </pre>. END_HTML. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genetic/doc/index.txt:702,guid,guide,702,math/genetic/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genetic/doc/index.txt,1,['guid'],['guide']
Usability,"This directory contains three utilities for fuzzing Clang: clang-fuzzer,; clang-objc-fuzzer, and clang-proto-fuzzer. All use libFuzzer to generate inputs; to clang via coverage-guided mutation. The three utilities differ, however, in how they structure inputs to Clang.; clang-fuzzer makes no attempt to generate valid C++ programs and is therefore; primarily useful for stressing the surface layers of Clang (i.e. lexer, parser). clang-objc-fuzzer is similar but for Objective-C: it makes no attempt to; generate a valid Objective-C program. clang-proto-fuzzer uses a protobuf class to describe a subset of the C++; language and then uses libprotobuf-mutator to mutate instantiations of that; class, producing valid C++ programs in the process. As a result,; clang-proto-fuzzer is better at stressing deeper layers of Clang and LLVM. Some of the fuzzers have example corpuses inside the corpus_examples directory. ===================================; Building clang-fuzzer; ===================================; Within your LLVM build directory, run CMake with the following variable; definitions:; - CMAKE_C_COMPILER=clang; - CMAKE_CXX_COMPILER=clang++; - LLVM_USE_SANITIZE_COVERAGE=YES; - LLVM_USE_SANITIZER=Address. Then build the clang-fuzzer target. Example:; cd $LLVM_SOURCE_DIR; mkdir build && cd build; cmake .. -GNinja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ \; -DLLVM_USE_SANITIZE_COVERAGE=YES -DLLVM_USE_SANITIZER=Address; ninja clang-fuzzer. ======================; Running clang-fuzzer; ======================; bin/clang-fuzzer CORPUS_DIR. ===================================; Building clang-objc-fuzzer; ===================================; Within your LLVM build directory, run CMake with the following variable; definitions:; - CMAKE_C_COMPILER=clang; - CMAKE_CXX_COMPILER=clang++; - LLVM_USE_SANITIZE_COVERAGE=YES; - LLVM_USE_SANITIZER=Address. Then build the clang-objc-fuzzer target. Example:; cd $LLVM_SOURCE_DIR; mkdir build && cd build; cmake .. -GNinja -DCMAKE_C_C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt:177,guid,guided,177,interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt,1,['guid'],['guided']
Usability,"This is a simple N^2 alias analysis accuracy evaluator. Basically, for each; function in the program, it simply queries to see how the alias analysis; implementation answers alias queries between each pair of pointers in the; function. This is inspired and adapted from code by: Naveen Neelakantam, Francesco; Spadini, and Wojciech Stryjewski. ``basic-aa``: Basic Alias Analysis (stateless AA impl); ------------------------------------------------------. A basic alias analysis pass that implements identities (two different globals; cannot alias, etc), but does no stateful analysis. ``basiccg``: Basic CallGraph Construction; -----------------------------------------. Yet to be written. .. _passes-da:. ``da``: Dependence Analysis; ---------------------------. Dependence analysis framework, which is used to detect dependences in memory; accesses. ``domfrontier``: Dominance Frontier Construction; ------------------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominator frontiers. ``domtree``: Dominator Tree Construction; ----------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominators. ``dot-callgraph``: Print Call Graph to ""dot"" file; -------------------------------------------------. This pass, only available in ``opt``, prints the call graph into a ``.dot``; graph. This graph can then be processed with the ""dot"" tool to convert it to; postscript or some other suitable format. ``dot-cfg``: Print CFG of function to ""dot"" file; ------------------------------------------------. This pass, only available in ``opt``, prints the control flow graph into a; ``.dot`` graph. This graph can then be processed with the :program:`dot` tool; to convert it to postscript or some other suitable format.; Additionally the ``-cfg-func-name=<substring>`` option can be used to filter the; functions that are printed. All functions that contain the specified substring; wil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:2221,simpl,simple,2221,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"This is a simple example demonstrating how to use clang's facility for; providing AST consumers using a plugin. Build the plugin by running `make` in this directory. Once the plugin is built, you can run it using:; --; Linux:; $ clang -cc1 -load ../../Debug+Asserts/lib/libPrintFunctionNames.so -plugin print-fns some-input-file.c; $ clang -cc1 -load ../../Debug+Asserts/lib/libPrintFunctionNames.so -plugin print-fns -plugin-arg-print-fns help -plugin-arg-print-fns --example-argument some-input-file.c; $ clang -cc1 -load ../../Debug+Asserts/lib/libPrintFunctionNames.so -plugin print-fns -plugin-arg-print-fns -an-error some-input-file.c. Mac:; $ clang -cc1 -load ../../Debug+Asserts/lib/libPrintFunctionNames.dylib -plugin print-fns some-input-file.c; $ clang -cc1 -load ../../Debug+Asserts/lib/libPrintFunctionNames.dylib -plugin print-fns -plugin-arg-print-fns help -plugin-arg-print-fns --example-argument some-input-file.c; $ clang -cc1 -load ../../Debug+Asserts/lib/libPrintFunctionNames.dylib -plugin print-fns -plugin-arg-print-fns -an-error some-input-file.c; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/examples/PrintFunctionNames/README.txt:10,simpl,simple,10,interpreter/llvm-project/clang/examples/PrintFunctionNames/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/examples/PrintFunctionNames/README.txt,1,['simpl'],['simple']
Usability,"This means we have to support multiple live argument; allocations. Consider the evaluation of:. .. code-block:: c++. // Foo is non-trivial.; struct Foo { int a; Foo(); Foo(const &Foo); ~Foo(); };; Foo bar(Foo b);; int main() {; bar(bar(Foo()));; }. In this case, we want to be able to elide copies into ``bar``'s argument; slots. That means we need to have more than one set of argument frames; active at the same time. First, we need to allocate the frame for the; outer call so we can pass it in as the hidden struct return pointer to; the middle call. Then we do the same for the middle call, allocating a; frame and passing its address to ``Foo``'s default constructor. By; wrapping the evaluation of the inner ``bar`` with stack save and; restore, we can have multiple overlapping active call frames. Callee-cleanup Calling Conventions; ----------------------------------. Another wrinkle is the existence of callee-cleanup conventions. On; Windows, all methods and many other functions adjust the stack to clear; the memory used to pass their arguments. In some sense, this means that; the allocas are automatically cleared by the call. However, LLVM; instead models this as a write of undef to all of the inalloca values; passed to the call instead of a stack adjustment. Frontends should; still restore the stack pointer to avoid a stack leak. Exceptions; ----------. There is also the possibility of an exception. If argument evaluation; or copy construction throws an exception, the landing pad must do; cleanup, which includes adjusting the stack pointer to avoid a stack; leak. This means the cleanup of the stack memory cannot be tied to the; call itself. There needs to be a separate IR-level instruction that can; perform independent cleanup of arguments. Efficiency; ----------. Eventually, it should be possible to generate efficient code for this; construct. In particular, using inalloca should not require a base; pointer. If the backend can prove that all points in the CFG only ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InAlloca.rst:5059,clear,clear,5059,interpreter/llvm-project/llvm/docs/InAlloca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InAlloca.rst,1,['clear'],['clear']
Usability,"Tips.html>`_ recommends; this. Optimizations benefit from knowing about the target and data; layout. .. code-block:: c++. TheModule->setDataLayout(TargetMachine->createDataLayout());; TheModule->setTargetTriple(TargetTriple);. Emit Object Code; ================. We're ready to emit object code! Let's define where we want to write; our file to:. .. code-block:: c++. auto Filename = ""output.o"";; std::error_code EC;; raw_fd_ostream dest(Filename, EC, sys::fs::OF_None);. if (EC) {; errs() << ""Could not open file: "" << EC.message();; return 1;; }. Finally, we define a pass that emits object code, then we run that; pass:. .. code-block:: c++. legacy::PassManager pass;; auto FileType = CodeGenFileType::ObjectFile;. if (TargetMachine->addPassesToEmitFile(pass, dest, nullptr, FileType)) {; errs() << ""TargetMachine can't emit a file of this type"";; return 1;; }. pass.run(*TheModule);; dest.flush();. Putting It All Together; =======================. Does it work? Let's give it a try. We need to compile our code, but; note that the arguments to ``llvm-config`` are different to the previous chapters. ::. $ clang++ -g -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs all` -o toy. Let's run it, and define a simple ``average`` function. Press Ctrl-D; when you're done. ::. $ ./toy; ready> def average(x y) (x + y) * 0.5;; ^D; Wrote output.o. We have an object file! To test it, let's write a simple program and; link it with our output. Here's the source code:. .. code-block:: c++. #include <iostream>. extern ""C"" {; double average(double, double);; }. int main() {; std::cout << ""average of 3.0 and 4.0: "" << average(3.0, 4.0) << std::endl;; }. We link our program to output.o and check the result is what we; expected:. ::. $ clang++ main.cpp output.o -o main; $ ./main; average of 3.0 and 4.0: 3.5. Full Code Listing; =================. .. literalinclude:: ../../../examples/Kaleidoscope/Chapter8/toy.cpp; :language: c++. `Next: Adding Debug Information <LangImpl09.html>`_; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst:4846,simpl,simple,4846,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.rst,2,['simpl'],['simple']
Usability,"To-do; -----. * Keep the address of the constant pool in a register instead of forming its; address all of the time.; * We can fold small constant offsets into the %hi/%lo references to constant; pool addresses as well.; * When in V9 mode, register allocate %icc[0-3].; * Add support for isel'ing UMUL_LOHI instead of marking it as Expand.; * Emit the 'Branch on Integer Register with Prediction' instructions. It's; not clear how to write a pattern for this though:. float %t1(int %a, int* %p) {; %C = seteq int %a, 0; br bool %C, label %T, label %F; T:; store int 123, int* %p; br label %F; F:; ret float undef; }. codegens to this:. t1:; save -96, %o6, %o6; 1) subcc %i0, 0, %l0; 1) bne .LBBt1_2 ! F; nop; .LBBt1_1: ! T; or %g0, 123, %l0; st %l0, [%i1]; .LBBt1_2: ! F; restore %g0, %g0, %g0; retl; nop. 1) should be replaced with a brz in V9 mode. * Same as above, but emit conditional move on register zero (p192) in V9; mode. Testcase:. int %t1(int %a, int %b) {; %C = seteq int %a, 0; %D = select bool %C, int %a, int %b; ret int %D; }. * Emit MULX/[SU]DIVX instructions in V9 mode instead of fiddling; with the Y register, if they are faster. * Codegen bswap(load)/store(bswap) -> load/store ASI. * Implement frame pointer elimination, e.g. eliminate save/restore for; leaf fns.; * Fill delay slots. * Use %g0 directly to materialize 0. No instruction is required.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/README.txt:421,clear,clear,421,interpreter/llvm-project/llvm/lib/Target/Sparc/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/README.txt,1,['clear'],['clear']
Usability,"Type to be able to use; the preprocessor to synthesize the relevant cast operations. For example,; ``X(char, Char_S)``, where ``char`` is the type from the language's type system; and ``Char_S`` is the Clang builtin type which represents it. This mapping helps; to import execution results from the interpreter in a compiled program and vice; versa. The ``Value.h`` header file can be included at runtime and this is why it; has a very low token count and was developed with strict constraints in mind. This also enables the user to receive the computed 'type' back in their code; and then transform the type into something else (e.g., re-cast a double into; a float). Normally, the compiler can handle these conversions transparently,; but in interpreter mode, the compiler cannot see all the 'from' and 'to' types,; so it cannot implicitly do the conversions. So this logic enables providing; these conversions on request. On-request conversions can help improve the user experience, by allowing; conversion to a desired 'to' type, when the 'from' type is unknown or unclear. Significance of this Feature; ----------------------------. The 'Value' object enables wrapping a memory region that comes from the; JIT, and bringing it back to the compiled code (and vice versa).; This is a very useful functionality when:. - connecting an interpreter to the compiled code, or; - connecting an interpreter in another language. For example, this feature helps transport values across boundaries. A notable; example is the cppyy project code makes use of this feature to enable running C++; within Python. It enables transporting values/information between C++; and Python. Note: `cppyy <https://github.com/wlav/cppyy/>`_ is an automatic, run-time,; Python-to-C++ bindings generator, for calling C++ from Python and Python from C++.; It uses LLVM along with a C++ interpreter (e.g., Cling) to enable features like; run-time instantiation of C++ templates, cross-inheritance, callbacks,; auto-casting, transp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:10180,user experience,user experience,10180,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['user experience'],['user experience']
Usability,"Used Technology; ---------------. `LLVM <https://llvm.org/>`_ is a free, open-source compiler infrastructure under; the `Apache License 2.0 <https://www.apache.org/licenses/LICENSE-2.0>`_. It is; designed as a collection of tools including Front Ends parsers, Middle Ends; optimizers, and Back Ends to produce machine code out of those programs. `Clang <https://clang.llvm.org/>`_ is a front-end that uses a LLVM; license. Clang works by taking the source language (e.g. C++) and translating it; into an intermediate representation that is then received by the compiler back; end (i.e., the LLVM backend). Its library-based architecture makes it relatively; easy to adapt Clang and build new tools based on it. Cling inherits a number of; features from LLVM and Clang, such as: fast compiling and low memory use,; efficient C++ parsing, extremely clear and concise diagnostics, Just-In-Time; compilation, pluggable optimizers, and support for `GCC <https://gcc.gnu.org/>`_; extensions. Interpreters allow for exploration of software development at the rate of human; thought. Nevertheless, interpreter code can be slower than compiled code due to; the fact that translating code at run time adds to the overhead and therefore; causes the execution speed to be slower. This issue is overcome by exploiting; the *Just-In-Time* (`JIT; <https://en.wikipedia.org/wiki/Just-in-time_compilation>`_) compilation method,; which allows an efficient memory management (for example, by evaluating whether; a certain part of the source code is executed often, and then compile this part,; therefore reducing the overall execution time). With the JIT approach, the developer types the code in Cling's command; prompt. The input code is then lowered to Clang, where is compiled and; eventually transformed in order to attach specific behavior. Clang compiles then; the input into an AST representation, that is then lowered to LLVM IR, an; `intermediate language; <https://en.wikipedia.org/wiki/Common_Intermediate_L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/implementation.rst:847,clear,clear,847,interpreter/cling/docs/chapters/implementation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/implementation.rst,1,['clear'],['clear']
Usability,"UsesWith`` to rewrite the debug uses of that; operand. Consider the following example function:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %b = sext i16 %a to i32; %c = and i32 %b, 15; call void @llvm.dbg.value(metadata i32 %c, ...); %d = trunc i32 %c to i16; ret i16 %d; }. Now, here's what happens after the unnecessary truncation instruction ``%d`` is; replaced with a simplified instruction:. .. code-block:: llvm. define i16 @foo(i16 %a) {; call void @llvm.dbg.value(metadata i32 undef, ...); %simplified = and i16 %a, 15; ret i16 %simplified; }. Note that after deleting ``%d``, all uses of its operand ``%c`` become; trivially dead. The debug use which used to point to ``%c`` is now ``undef``,; and debug info is needlessly lost. To solve this problem, do:. .. code-block:: cpp. llvm::replaceAllDbgUsesWith(%c, theSimplifiedAndInstruction, ...). This results in better debug info because the debug use of ``%c`` is preserved:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %simplified = and i16 %a, 15; call void @llvm.dbg.value(metadata i16 %simplified, ...); ret i16 %simplified; }. You may have noticed that ``%simplified`` is narrower than ``%c``: this is not; a problem, because ``llvm::replaceAllDbgUsesWith`` takes care of inserting the; necessary conversion operations into the DIExpressions of updated debug uses. Deleting a MIR-level MachineInstr; ---------------------------------. TODO. Rules for updating ``DIAssignID`` Attachments; =============================================. ``DIAssignID`` metadata attachments are used by Assignment Tracking, which is; currently an experimental debug mode. See :doc:`AssignmentTracking` for how to update them and for more info on; Assignment Tracking. How to automatically convert tests into debug info tests; ========================================================. .. _IRDebugify:. Mutation testing for IR-level transformations; ---------------------------------------------. An IR test case for a transformation can, in many",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:8421,simpl,simplified,8421,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['simpl'],['simplified']
Usability,"VM_PROFILE_FILE`` for each invocation. The pattern strings ""%p"" or ""%Nm""; may help to avoid corruption due to concurrency. Note that ""%p"" is also a Lit; token and needs to be escaped as ""%%p"". .. code-block:: console. % clang++ -fprofile-instr-generate -fcoverage-mapping -mllvm -runtime-counter-relocation foo.cc -o foo. Creating coverage reports; =========================. Raw profiles have to be **indexed** before they can be used to generate; coverage reports. This is done using the ""merge"" tool in ``llvm-profdata``; (which can combine multiple raw profiles and index them at the same time):. .. code-block:: console. # Step 3(a): Index the raw profile.; % llvm-profdata merge -sparse foo.profraw -o foo.profdata. For an example of merging multiple profiles created by testing,; see the LLVM `coverage build script <https://github.com/llvm/llvm-zorg/blob/main/zorg/jenkins/jobs/jobs/llvm-coverage>`_. There are multiple different ways to render coverage reports. The simplest; option is to generate a line-oriented report:. .. code-block:: console. # Step 3(b): Create a line-oriented coverage report.; % llvm-cov show ./foo -instr-profile=foo.profdata. This report includes a summary view as well as dedicated sub-views for; templated functions and their instantiations. For our example program, we get; distinct views for ``foo<int>(...)`` and ``foo<float>(...)``. If; ``-show-line-counts-or-regions`` is enabled, ``llvm-cov`` displays sub-line; region counts (even in macro expansions):. .. code-block:: none. 1| 20|#define BAR(x) ((x) || (x)); ^20 ^2; 2| 2|template <typename T> void foo(T x) {; 3| 22| for (unsigned I = 0; I < 10; ++I) { BAR(I); }; ^22 ^20 ^20^20; 4| 2|}; ------------------; | void foo<int>(int):; | 2| 1|template <typename T> void foo(T x) {; | 3| 11| for (unsigned I = 0; I < 10; ++I) { BAR(I); }; | ^11 ^10 ^10^10; | 4| 1|}; ------------------; | void foo<float>(int):; | 2| 1|template <typename T> void foo(T x) {; | 3| 11| for (unsigned I = 0; I < 10; ++I) { BAR(I)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:6500,simpl,simplest,6500,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,1,['simpl'],['simplest']
Usability,"Validate and push \n to dump()"", shape=""box""];; callp [label="" call print() function "", shape=""box""];; type [label="" Print the Type \n ReplPrintTypeImpl()"", shape=""box""];; data [label="" Print the Data \n ReplPrintDataImpl() "", shape=""box""];; output [label="" Output Pretty Print \n to the user "", shape=""box"", fontcolor=white, fillcolor=""#3333ff"", style=filled];. parse -> capture [label=""Optional 'Value' Parameter""];; capture -> use [label=""Yes""];; use -> End;; capture -> dump [label=""No""];; dump -> callp;; callp -> type;; callp -> data;; type -> output;; data -> output;; }. **Note:** Following is a sample code snippet. Actual code may vary over time. .. code-block:: console. llvm::Error Interpreter::ParseAndExecute(llvm::StringRef Code, Value *V) {. auto PTU = Parse(Code);; if (!PTU); return PTU.takeError();; if (PTU->TheModule); if (llvm::Error Err = Execute(*PTU)); return Err;. if (LastValue.isValid()) {; if (!V) {; LastValue.dump();; LastValue.clear();; } else; *V = std::move(LastValue);; }; return llvm::Error::success();; }. The ``dump()`` function (in ``value.cpp``) calls the ``print()`` function. Printing the Data and Type are handled in their respective functions:; ``ReplPrintDataImpl()`` and ``ReplPrintTypeImpl()``. Annotation Token (annot_repl_input_end); ---------------------------------------. This feature uses a new token (``annot_repl_input_end``) to consider printing the; value of an expression if it doesn't end with a semicolon. When parsing an; Expression Statement, if the last semicolon is missing, then the code will; pretend that there one and set a marker there for later utilization, and; continue parsing. A semicolon is normally required in C++, but this feature expands the C++; syntax to handle cases where a missing semicolon is expected (i.e., when; handling an expression statement). It also makes sure that an error is not; generated for the missing semicolon in this specific case. This is accomplished by identifying the end position of the user i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:17601,clear,clear,17601,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['clear'],['clear']
Usability,"W_AT_location``; attribute that is encoded as a ``loclist`` or ``loclistsptr``, and the; specified location list expression E' matches a single location list; entry with operation expression E, the same as the ``exprloc`` case and; evaluate on the same stack. But this is not attractive as if the attribute is for a variable that; happens to end with a non-singleton stack, it will not simply put a; location description on the stack. Presumably the intent of using; ``DW_OP_call*`` on a variable or formal parameter debugger information; entry is to push just one location description on the stack. That; location description may have more than one single location description. The previous rule for ``exprloc`` also has the same problem, as normally; a variable or formal parameter location expression may leave multiple; entries on the stack and only return the top entry. GDB implements ``DW_OP_call*`` by always executing E on the same stack.; If the location list has multiple matching entries, it simply picks the; first one and ignores the rest. This seems fundamentally at odds with; the desire to support multiple places for variables. So, it feels like ``DW_OP_call*`` should both support pushing a location; description on the stack for a variable or formal parameter, and also; support being able to execute an operation expression on the same stack.; Being able to specify a different operation expression for different; program locations seems a desirable feature to retain. A solution to that is to have a distinct ``DW_AT_LLVM_proc`` attribute; for the ``DW_TAG_dwarf_procedure`` debugging information entry. Then the; ``DW_AT_location`` attribute expression is always executed separately; and pushes a location description (that may have multiple single; location descriptions), and the ``DW_AT_LLVM_proc`` attribute expression; is always executed on the same stack and can leave anything on the; stack. The ``DW_AT_LLVM_proc`` attribute could have the new classes; ``exprproc``, ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:77529,simpl,simply,77529,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['simpl'],['simply']
Usability,"Why interpreting C++ with Cling?; -----------------------------------. 1. **Learning C++:**; ; One use case of Cling is to aid the C++ learning process. Offering imediate; feedback the user can easily get familiar with the structures and spelling of; the language. 2. **Creating scripts:**; ; The power of an interpreter lays as well in the compactness and ease of; repeatedly running a small snippet of code - aka a script. This can be done in; Cling by inserting the bash-like style line:. .. code:: bash; ; #!/usr/bin/cling; ; 3. **Rapid Application Development (RAD):**. Cling can be used successfully for Rapid Application Development allowing for; prototyping and proofs of concept taking advantage of dynamicity and feedback; during the implementation process. 4. **Runtime-Generated Code**. Sometime it's convenient to create code as a reaction to input; (user/network/configuration). Runtime-generated code can interface with C++; libraries. 5. **Embedding Cling:**. The functionality of an application can be enriched by embedding Cling. To embed; Cling, the main program has to be provided. One of the things this main program; has to do is initialize the Cling interpreter. There are optional calls to pass; command line arguments to Cling. Afterwards, you can call the interpreter from; any anywhere within the application. For compilation and linkage the application needs the path to the Clang and LLVM; libraries and the invocation is order dependent since the linker cannot do; backward searches. .. code:: bash. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclangEdit -lclangLex -lclangDriver -lclangCodeGen ; -lclangBasic -lclangAST ; `llvm-config ; --libs bitwriter mcjit orcjit native option ; ipo profiledata instrumentation objcarcopts` ; -lz -pthread -ldl -ltinfo ; -o embedcling; . Embedding Cling requires the creation of the interpreter. Optionally compile",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/why_interpreting.rst:135,learn,learning,135,interpreter/cling/docs/chapters/why_interpreting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/why_interpreting.rst,3,"['feedback', 'learn']","['feedback', 'learning']"
Usability,"Write up design. Interface; ---------. The core routine of LibFormat is ``reformat()``:. .. code-block:: c++. tooling::Replacements reformat(const FormatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();. /// Returns a format style complying with Webkit's style guide:; /// https://webkit.org/code-style-guidelines/; FormatStyle getWebkitStyle();. /// Returns a format style complying with Microsoft's style guide:; /// https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference; FormatStyle getMicrosoftStyle();. These optio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:1369,guid,guide,1369,interpreter/llvm-project/clang/docs/LibFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst,1,['guid'],['guide']
Usability,"[tree]` indicates a; change to TTree, `[RF]` indicates a change to RooFit). If you are unsure about which scope tags to use, we are happy to; point you in the right direction! See also the [commit log](https://github.com/root-project/root/commits/master/) for; examples. The summary itself should not exceed 50 characters (excluding the scope tag), be meaningful (i.e., it; describes the change) and should be written in the; [present imperative mood](https://git.kernel.org/pub/scm/git/git.git/tree/Documentation/SubmittingPatches?id=HEAD#n239); (e.g. `Add this awesome feature` instead of `Adds this awesome feature` or `Added this awesome feature`). The commit message that follow the summary can be used to provide more context to the change.; It should describe the **why**, rather than the **what** and **how** (we can gather this from the commit summary and the; change diff, respectively).; The commit message should be wrapped at 72 characters. > [!TIP]; > We provide a commit message template to help with following the above guidelines. It can be found in the root of this; > repository as [`.git-commit-template`](https://github.com/root-project/root/blob/master/.git-commit-template),; > and can be set to automatically be used for every commit with the following command:; > ```sh; > $ git config commit.template .git-commit-template; > ```. ## Your Pull Request. > [!NOTE]; > For the mechanics on how to create pull requests, please visit; > [this page](https://root.cern/for_developers/creating_pr). The title of your PR follows the same principle as the commit summary. If your PR only involves one commit, you can; reuse this summary. For non-functional changes (e.g. to the documentation) or changes for which you want to; **temporarily** prevent Jenkins from being triggered (e.g., for a draft PR), use `[skip-CI]` as the first tag.; Note that for functional changes this tag needs to be removed and it has to pass the CI before merging to ensure; the change does not break anythi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md:3577,guid,guidelines,3577,CONTRIBUTING.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md,1,['guid'],['guidelines']
Usability,"\addtogroup tutorial_FOAM. @{. ### What is FOAM ?. FOAM is simplified version of multi-dimensional general; purpose Monte Carlo event generator (integrator) with hyper-cubical; ""foam of cells"". Certain features of full version of FOAM are omitted.; mFOAM is intended as an easy to use tool for MC; simulation/integration in few dimensions. It relies heavily on ROOT package,; borrowing persistency of classes from ROOT. mFOAM can be easily used from; the ROOT shell. For more difficult problems the full FOAM may be better. ### How to run application programs ?. The application program can be run in two modes: it can be simply; interpreted by CLING or compiled. The first method is simpler but; results in slower execution. The second method employs ACLiC -; The Automatic Compiler of Libraries, which automatizes the; process of compilation and linking. In $(ROOTSYS)/tutorials there are 3 demonstration programs:. #### foam_kanwa.C; is a simple example how to run FOAM in interactive; mode. To run this macro issue the following simple command from the; Linux shell:. ```; root foam_kanwa.C; ```. or from CLING:. ```; root [0] .x foam_kanwa.C; ```. Simulation will start and graphical canvas with plot; of the distribution function appear. In this example; we defined the distribution function simply as a global; function function Camel2. #### foam_demo.C; shows usage of FOAM in compiled mode, which is; the preferred method. The integrand function is defined; now as a Density method from class TFDISTR inheriting from; abstract class TFoamIntegrand. User can modify interface to; integrand function according to their needs but they should; always remember to define Density method which provides the; density distribution.; Enter CLING interpreter and type:. ```; root [0] gSystem->Load(""libFoam.so""); root [1] .x foam_demo.C+; ```. to load FOAM library, compile and execute macro foam_demo.C.; A shared object foam_demo_C.so is created in the current; directory. At the end of exploration ph",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/foam/index.md:59,simpl,simplified,59,tutorials/foam/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/foam/index.md,4,['simpl'],"['simple', 'simpler', 'simplified', 'simply']"
Usability,"\addtogroup tutorial_dataframe. @{. [RDataFrame](classROOT_1_1RDataFrame.html) offers a high level interface for the analysis of data stored in [TTree](classTTree.html)s, [CSV files](classROOT_1_1RDF_1_1RCsvDS.html) and [other data formats](classROOT_1_1RDF_1_1RDataSource.html). In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available on their machines transparently. In a nutshell:; ~~~{.cpp}; ROOT::EnableImplicitMT(); // Enable ROOT's implicit multi-threading; ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; auto histoA = d.Histo1D(""Branch_A""); // Book the filling of a histogram; auto histoB = d.Histo1D(""Branch_B""); // Book the filling of another histogram; // Data processing is triggered by the next line, which accesses a booked result for the first time; // All booked results are evaluated during the same parallel event loop.; histoA->Draw(); // <-- event loop runs here!; histoB->Draw(); // HistoB has already been filled, no event loop is run here; ~~~. Explore the examples below or go to [RDataFrame's user guide](classROOT_1_1RDataFrame.html). @}",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/index.md:1113,guid,guide,1113,tutorials/dataframe/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/index.md,1,['guid'],['guide']
Usability,\addtogroup tutorial_vecops. @{. Please note that you can find the exhaustive documentation [here in the reference guide](<https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html>). @}; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/vecops/index.md:115,guid,guide,115,tutorials/vecops/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/vecops/index.md,1,['guid'],['guide']
Usability,\defgroup Histpainter Histograms and graphs painting classes.; \ingroup HistPainting. The histograms and graphs plotting options are described in details in the THistPainter and TGraphPainter classes.; Some related tutorials:. - graph.C: Using and drawing a simple TGraph.; - graph2derrorsfit.C: TGraph2D with errors drawing.; - h1draw.C: Drawing Options for 1D Histograms.; - hbars.C: Demo of option bar with histograms.; - hsimple.C: Simple drawing of a 1D Histograms.; - hsum.C: Filling several histograms and some graphics options.; - surfaces.C: Drawing a TH2 as a 2-D surface. Some related HowTos:; - [How to Draw objects ?](https://root-forum.cern.ch/t/how-to-draw-objects/28249); - [How to change the position of the statistics box on histogram plot ?](https://root-forum.cern.ch/t/how-to-change-the-position-of-the-statistics-box-on-histogram-plot/28262); - [How to draw several TGraph in one common axis system ?](https://root-forum.cern.ch/t/how-to-draw-several-tgraph-in-one-common-axis-system/28261); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/doc/index.md:258,simpl,simple,258,hist/histpainter/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/doc/index.md,1,['simpl'],['simple']
Usability,"\defgroup Roofit RooFit; \brief RooFit main classes for building likelihood models, mainly PDFs.; \ingroup Roofitmain. For an introduction check the [user's guides](https://root.cern.ch/root-user-guides-and-manuals),; [courses](https://root.cern.ch/learn/courses) or [the RooFit chapter of the Manual](https://root.cern/manual/roofit/). For tutorials see \ref tutorial_roofit.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/doc/index.md:157,guid,guides,157,roofit/roofit/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/doc/index.md,3,"['guid', 'learn']","['guides', 'guides-and-manuals', 'learn']"
Usability,"\defgroup Roofitmain RooFit; \brief RooFit is a package for building likelihood models and fitting these to data. For an introduction check the \ref tutorial_roofit, [user's guides](https://root.cern.ch/root-user-guides-and-manuals),; [courses](https://root.cern.ch/learn/courses) or [the RooFit chapter of the Manual](https://root.cern/manual/roofit/). For developers, there is also the \ref roofit_dev_docs, which serves as a reference on how to extend %RooFit with custom classes or for contributing to %RooFit itself. \defgroup roofit_dev_docs RooFit Developer Documentation; \brief How-to guides on how to extend \ref Roofitmain with custom classes or to work on %RooFit itself.; \ingroup Roofitmain; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/index.md:174,guid,guides,174,roofit/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/index.md,4,"['guid', 'learn']","['guides', 'guides-and-manuals', 'learn']"
Usability,\defgroup Roostats RooStats; \brief RooStats is a toolkit for statistical tests built on top of RooFit.; \ingroup Roofitmain. RooStats is a package containing statistical tools built on top of RooFit.; See the RooStats [Twiki Page](https://twiki.cern.ch/twiki/bin/view/RooStats/WebHome) or the [courses](https://root.cern/learn/courses) for more information. For tutorials see \ref tutorial_roostats. ; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/doc/index.md:322,learn,learn,322,roofit/roostats/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/doc/index.md,1,['learn'],['learn']
Usability,"\defgroup Tutorials Tutorials; \brief A collection of C++ macros, Python scripts and notebooks helping to learn ROOT by example. You can execute the scripts in `$ROOTSYS/tutorials` (or sub-directories); by setting your current directory in the script directory or from any; user directory with write access. Several tutorials create new files. If you have write access to; the tutorials directory, the new files will be created in the tutorials; directory, otherwise they will be created in the user directory. You can start by executing the standard ROOT demos with a session like:. ```; root > .x demos.C; ```; or. ```; root > .x $ROOTSYS/tutorials/demos.C; ```. You can execute the standard ROOT graphics benchmark with. ```; root > .x benchmarks.C; ```. or. ```; root > .x $ROOTSYS/tutorials/benchmarks.C; ```. The `$ROOTSYS/tutorials` directory includes several sub-directories:. \defgroup tutorial_hist Histograms tutorials; \ingroup Tutorials; \brief Examples showing the ""histograms' classes"" usage. \defgroup tutorial_tree Tree tutorials; \ingroup Tutorials; \brief Example code which illustrates how to use ROOT trees and ntuples. \defgroup tutorial_dataframe Dataframe tutorials; \ingroup Tutorials; \brief These examples show various features of [RDataFrame](classROOT_1_1RDataFrame.html): ROOT's declarative analysis interface. \defgroup tutorial_v7 ROOT 7 tutorials; \ingroup Tutorials; \brief Various examples showing the ROOT 7 interface. \defgroup tutorial_FOAM FOAM tutorials; \ingroup Tutorials; \brief Examples showing how to use FOAM. \defgroup tutorial_cont Containers tutorials; \ingroup Tutorials; \brief Examples showing the ""containers' classes"" usage. \defgroup tutorial_eve Event display tutorials; \ingroup Tutorials; \brief Examples showing the ""Event display classes"" usage. \defgroup tutorial_eve7 Event display ROOT7 tutorials; \ingroup Tutorials; \brief Examples showing the ""Event display classes"" usage with ROOT7. \defgroup tutorial_geom Geometry tutorials; \ingro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/index.md:106,learn,learn,106,tutorials/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/index.md,1,['learn'],['learn']
Usability,\defgroup guihtml HTML visualizer; \ingroup gui; \brief A very simple HTML browser.; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/doc/index.md:63,simpl,simple,63,gui/guihtml/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/doc/index.md,1,['simpl'],['simple']
Usability,"\defgroup roofit_dev_docs_ad How to extend the use of Automatic Differentiation in RooFit; \ingroup roofit_dev_docs; \date October 2023; \brief Developer guide on how to add support for Automatic Differentiation via code generation. # How to extend the use of Automatic Differentiation in RooFit. ## What is RooFit?. [RooFit] is a statistical data analysis tool, widely used in scientific; research, especially in the high-energy physics (HEP) field. It is an; extension of the ROOT framework, a C++ based data analysis framework that; provides tools for data storage, analysis, and visualization. RooFit provides; a set of tools/classes to define and evaluate probability density functions; (PDFs), perform maximum likelihood fits, perform statistical tests, etc. ## Proof of Concept: Speeding up RooFit using Automatic Differentiation (AD). RooFit is used to reduce statistical models (functions) to find a set of; parameters that minimize the value of the function. This minimization happens; via one of several methods relying heavily on the computation of derivatives; of the function with respect to its free parameters. Currently, the; computation of Numerical Derivatives is the most time-consuming component of; RooFit [^1]. On the other hand, derivatives computed using the Automatic; Differentiation tool [Clad] have been shown to be far more efficient [^2]. \htmlonly; <div class=""pyrootbox"">; \endhtmlonly. Main Advantage of using AD with RooFit: efficient and more precise; derivatives. It computes derivatives with high precision, avoiding the errors; that may arise from approximating derivatives using finite differences. \htmlonly; </div>; \endhtmlonly. ### AD Support essentially requires Code Generation. As we'll discuss in upcoming sections, *AD support* can be added using *C++; Code generation*.; These two terms may be used interchangeably in this document, since the term; *Code Generation* better helps visualize the transformation that is enabling; AD support. ## Current S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:154,guid,guide,154,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['guid'],['guide']
Usability,"\defgroup roofit_dev_docs_batchcompute RooBatchCompute library guide; \ingroup roofit_dev_docs; \date September 2021; \author Emmanouil Michalainas; \brief Overview of the RooBatchCompute library. ## RooBatchCompute Library; _Contains optimized computation functions for PDFs that enable significantly faster fittings._; #### Note: This library is still at an experimental stage. Tests are being conducted continuously to ensure correctness of the results, but the interfaces and the instructions on how to use might change. ### Purpose; While fitting, a significant amount of time and processing power is spent on computing the probability function for every event and PDF involved in the fitting model. To speed up this process, roofit can use the computation functions provided in this library. The functions provided here process whole data arrays (batches) instead of a single event at a time, as in the legacy evaluate() function in roofit. In addition, the code is written in a manner that allows for compiler optimizations, notably auto-vectorization. This library is compiled multiple times for different [vector instruction set architectures](https://en.wikipedia.org/wiki/SIMD) and the optimal code is executed during runtime, as a result of an automatic hardware detection mechanism that this library contains. **As a result, fits can benefit by a speedup of 3x-16x.**. As of ROOT v6.26, RooBatchComputes also provides multithread and [CUDA](https://en.wikipedia.org/wiki/CUDA) instances of the computation functions, resulting in even greater improvements for fitting times. ### How to use; This library is an internal component of RooFit, so users are not supposed to actively interact with it. Instead, they can benefit from significantly faster times for fitting by calling `fitTo()` and providing a `BatchMode(""cpu"")` or a `BatchMode(""cuda"")` option.; ``` {.cpp}; // fit using the most efficient library that the computer's CPU can support; RooMyPDF.fitTo(data, BatchMode(""cpu""));. //",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/batchcompute.md:63,guid,guide,63,roofit/doc/developers/batchcompute.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/batchcompute.md,1,['guid'],['guide']
Usability,"\mainpage %ROOT Reference Documentation. ### Introduction; Welcome to %ROOT!. This is the Reference Guide of the ROOT software toolkit.; You can find in the [reference documentation page](https://root.cern/reference/) pointers; to Reference Guides for all %ROOT versions. ### Manuals. - The [Manual](https://root.cern/manual/) provides a more in depth explanation of; concepts and functionality available in the %ROOT system. It is closely linked to the; Reference Guide.; - A number of topical [User Guides and Manuals](https://root.cern/topical/) for various; components of the system. ### Tutorials and courses. - A rich set of %ROOT [tutorials and code examples](https://root.cern/doc/master/group__Tutorials.html) are offered to developers to exercise specific functionality.; - [ROOT Primer](https://root.cern/primer/).; - [ROOT Introductory Course](https://github.com/root-project/training/tree/master/BasicCourse). ### Provide your feedback; If you have suggestions about how to improve this documentation, you can let us know:. - With a [PR](https://github.com/root-project/root); - On the [ROOT Forum](https://root-forum.cern.ch); - On [our tracker](https://github.com/root-project/root/issues); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/doxygen/mainpage.md:940,feedback,feedback,940,documentation/doxygen/mainpage.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/doxygen/mainpage.md,1,['feedback'],['feedback']
Usability,"\theta_i^2$ instead of $\theta_i$. FUMILI will fail if; one tries minimize $\chi^2 = g^2(\vec\theta)$ where g is arbitrary; function. Approximate value is:. $$; {\frac{\partial^2\chi^2}{\partial\theta_i\partial\theta_k}}\approx Z_{ik}=; \sum^n_{j=1}{\frac{1}{\sigma^2_j}}{\frac{\partial f_j}{\theta_i}}; {\frac{\partial f_j}{\theta_k}}; $$. Then the equations for parameter increments are:. $$; \left(\frac{\partial\chi^2}{\partial\theta_i}\right)_; {\vec\theta={\vec\theta}^0} +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) =; 0, \qquad i=1\ldots m; $$. Remarkable feature of algorithm is the technique for step restriction.; For an initial value of parameter ${\vec\theta}^0$ a parallelepiped; $P_0$ is built with the center at ${\vec\theta}^0$ and axes parallel; to coordinate axes $\theta_i$. The lengths of parallelepiped sides; along i-th axis is $2b_i$, where $b_i$ is such a value that the; functions $f_j(\vec\theta)$ are quasi-linear all over the; parallelepiped. FUMILI takes into account simple linear inequalities in the form:. $$ \theta_i^{min}\le\theta_i\le\theta^{max}_i$$. They form parallelepiped $P$ ($P_0$ may be deformed by $P$). Very; similar step formulae are used in FUMILI for negative logarithm of; the likelihood function with the same idea - linearization of function; argument. ## Neural Networks. ### Introduction. Neural Networks are used in various fields for data analysis and; classification, both for research and commercial institutions. Some; randomly chosen examples are image analysis, financial movements'; predictions and analysis, or sales forecast and product shipping; optimization. In particles physics neural networks are mainly used for; classification tasks (signal over background discrimination). A vast; majority of commonly used neural networks are multilayer perceptrons.; This implementation of multilayer perceptrons is inspired from the; `MLPfit` package, which remains one of the fastest tools for neural; networks studies. ### The MLP. The multilaye",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:69501,simpl,simple,69501,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['simpl'],['simple']
Usability,"]. :program:`lldb-tblgen` [*options*] [*filename*]. :program:`llvm-tblgen` [*options*] [*filename*]. :program:`mlir-tblgen` [*options*] [*filename*]. DESCRIPTION; -----------. :program:`*-tblgen` is a family of programs that translates target; description (``.td``) files into C++ code and other output formats. Most; users of LLVM will not need to use this program. It is used only for; writing parts of the compiler, debugger, and LLVM target backends. The details of the input and output of the :program:`*-tblgen` programs is; beyond the scope of this short introduction; please see the :doc:`TableGen; Overview <../TableGen/index>` for an introduction and for references to; additional TableGen documents. The *filename* argument specifies the name of the Target Description (``.td``); file that TableGen processes. OPTIONS; -------. General Options; ~~~~~~~~~~~~~~~. .. option:: -help. Print a description of the command line options. .. option:: -help-list. Print a description of the command line options in a simple list format. .. option:: -D=macroname. Specify the name of a macro to be defined. The name is defined, but it; has no particular value. .. option:: -d=filename. Specify the name of the dependency filename. .. option:: -debug. Enable debug output. .. option:: -dump-json. Print a JSON representation of all records, suitable for further; automated processing. .. option:: -I directory. Specify where to find other target description files for inclusion. The; ``directory`` value should be a full or partial path to a directory that; contains target description files. .. option:: -null-backend. Parse the source files and build the records, but do not run any; backend. This is useful for timing the frontend. .. option:: -o filename. Specify the output file name. If ``filename`` is ``-``, then; :program:`*-tblgen` sends its output to standard output. .. option:: -print-records. Print all classes and records to standard output (default backend option). .. option:: -print-d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst:1174,simpl,simple,1174,interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,1,['simpl'],['simple']
Usability,"]; %hdl = call noalias ptr @llvm.coro.begin(token %id, ptr %phi); br label %loop; loop:; %n.val = phi i32 [ %n, %coro.begin ], [ %inc, %loop ]; %inc = add nsw i32 %n.val, 1; store i32 %n.val, ptr %promise; %0 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %0, label %suspend [i8 0, label %loop; i8 1, label %cleanup]; cleanup:; %mem = call ptr @llvm.coro.free(token %id, ptr %hdl); call void @free(ptr %mem); br label %suspend; suspend:; %unused = call i1 @llvm.coro.end(ptr %hdl, i1 false, token none); ret ptr %hdl; }. A coroutine consumer can rely on the `coro.promise`_ intrinsic to access the; coroutine promise. .. code-block:: llvm. define i32 @main() {; entry:; %hdl = call ptr @f(i32 4); %promise.addr = call ptr @llvm.coro.promise(ptr %hdl, i32 4, i1 false); %val0 = load i32, ptr %promise.addr; call void @print(i32 %val0); call void @llvm.coro.resume(ptr %hdl); %val1 = load i32, ptr %promise.addr; call void @print(i32 %val1); call void @llvm.coro.resume(ptr %hdl); %val2 = load i32, ptr %promise.addr; call void @print(i32 %val2); call void @llvm.coro.destroy(ptr %hdl); ret i32 0; }. After example in this section is compiled, result of the compilation will be:. .. code-block:: llvm. define i32 @main() {; entry:; tail call void @print(i32 4); tail call void @print(i32 5); tail call void @print(i32 6); ret i32 0; }. .. _final:; .. _final suspend:. Final Suspend; -------------. A coroutine author or a frontend may designate a particular suspend to be final,; by setting the second argument of the `coro.suspend`_ intrinsic to `true`.; Such a suspend point has two properties:. * it is possible to check whether a suspended coroutine is at the final suspend; point via `coro.done`_ intrinsic;. * a resumption of a coroutine stopped at the final suspend point leads to; undefined behavior. The only possible action for a coroutine at a final; suspend point is destroying it via `coro.destroy`_ intrinsic. From the user perspective, the final suspend point represents an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:24074,resume,resume,24074,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"^. A member of a struct or union may be declared to have ownership-qualified; type. If the type is qualified with ``__unsafe_unretained``, the semantics; of the containing aggregate are unchanged from the semantics of an unqualified type in a non-ARC mode. If the type is qualified with ``__autoreleasing``, the program is ill-formed. Otherwise, if the type is nontrivially ownership-qualified, additional rules apply. Both Objective-C and Objective-C++ support nontrivially ownership-qualified; fields. Due to formal differences between the standards, the formal; treatment is different; however, the basic language model is intended to; be the same for identical code. .. admonition:: Rationale. Permitting ``__strong`` and ``__weak`` references in aggregate types; allows programmers to take advantage of the normal language tools of; C and C++ while still automatically managing memory. While it is; usually simpler and more idiomatic to use Objective-C objects for; secondary data structures, doing so can introduce extra allocation; and message-send overhead, which can cause to unacceptable; performance. Using structs can resolve some of this tension. ``__autoreleasing`` is forbidden because it is treacherous to rely; on autoreleases as an ownership tool outside of a function-local; contexts. Earlier releases of Clang permitted ``__strong`` and ``__weak`` only; references in Objective-C++ classes, not in Objective-C. This; restriction was an undesirable short-term constraint arising from the; complexity of adding support for non-trivial struct types to C. In Objective-C++, nontrivially ownership-qualified types are treated; for nearly all purposes as if they were class types with non-trivial; default constructors, copy constructors, move constructors, copy assignment; operators, move assignment operators, and destructors. This includes the; determination of the triviality of special members of classes with a; non-static data member of such a type. In Objective-C, the definitio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:52219,simpl,simpler,52219,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['simpl'],['simpler']
Usability,"^^^^^^^^. After talking about namespaces in general, you may be wondering about anonymous; namespaces in particular. Anonymous namespaces are a great language feature; that tells the C++ compiler that the contents of the namespace are only visible; within the current translation unit, allowing more aggressive optimization and; eliminating the possibility of symbol name collisions. Anonymous namespaces are; to C++ as ""static"" is to C functions and global variables. While ""``static``""; is available in C++, anonymous namespaces are more general: they can make entire; classes private to a file. The problem with anonymous namespaces is that they naturally want to encourage; indentation of their body, and they reduce locality of reference: if you see a; random function definition in a C++ file, it is easy to see if it is marked; static, but seeing if it is in an anonymous namespace requires scanning a big; chunk of the file. Because of this, we have a simple guideline: make anonymous namespaces as small; as possible, and only use them for class declarations. For example:. .. code-block:: c++. namespace {; class StringSort {; ...; public:; StringSort(...); bool operator<(const char *RHS) const;; };; } // namespace. static void runHelper() {; ...; }. bool StringSort::operator<(const char *RHS) const {; ...; }. Avoid putting declarations other than classes into anonymous namespaces:. .. code-block:: c++. namespace {. // ... many declarations ... void runHelper() {; ...; }. // ... many declarations ... } // namespace. When you are looking at ""``runHelper``"" in the middle of a large C++ file,; you have no immediate way to tell if this function is local to the file. In; contrast, when the function is marked static, you don't need to cross-reference; faraway places in the file to tell that the function is local. Don't Use Braces on Simple Single-Statement Bodies of if/else/loop Statements; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When writin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:60582,simpl,simple,60582,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,2,"['guid', 'simpl']","['guideline', 'simple']"
Usability,"^^^^^^^^. There is only type of public symbol, an ``S_PUB32`` which describes a mangled; name, a flag indicating what kind of symbol it is (e.g. function, variable), and; the symbol's address. The :ref:`dbi_section_map_substream` of the; :doc:`DBI Stream <DbiStream>` can be consulted to determine what module this address; corresponds to, and from there that module's :doc:`module debug stream <ModiStream>`; can be consulted to locate full information for the symbol with the given address. .. _global_symbols:. Global Symbols; --------------. While there is one :ref:`public symbol <public_symbols>` for every symbol in the; program with `external` linkage, there is one global symbol for every symbol in the; program with linkage (including internal linkage). As a result, global symbols do; not describe a mangled name *or* an address, since symbols with internal linkage; need not have any mangling at all, and also may not have an address. Thus, all; global symbols simply refer directly to the full symbol record via a module/offset; combination. Similarly to :ref:`public symbols <public_symbols>`, all global symbols are contained; in a single :doc:`Globals Stream <GlobalStream>`, which contains a hash table mapping; fully qualified name to the corresponding record in the globals stream (which as; mentioned, then contains information allowing one to locate the full record in the; corresponding module symbol stream). Note that a consequence and limitation of this design is that program-wide lookup; by anything other than an exact textually matching fully-qualified name of whatever; the compiler decided to emit is impractical. This differs from DWARF, where even; though we don't necessarily have O(1) lookup by basename within a given scope (including; O(1) scope, we at least have O(n) access within a given scope). .. important::; Program-wide lookup of names by anything other than an exact textually matching fully; qualified name is not possible. S_GDATA32; ^^^^^^^^^^. S_GTHR",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst:3763,simpl,simply,3763,interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst,1,['simpl'],['simply']
Usability,"^^^^^^^^^^^^. The Select phase is the bulk of the target-specific code for instruction; selection. This phase takes a legal SelectionDAG as input, pattern matches the; instructions supported by the target to this DAG, and produces a new DAG of; target code. For example, consider the following LLVM fragment:. .. code-block:: llvm. %t1 = fadd float %W, %X; %t2 = fmul float %t1, %Y; %t3 = fadd float %t2, %Z. This LLVM code corresponds to a SelectionDAG that looks basically like this:. .. code-block:: text. (fadd:f32 (fmul:f32 (fadd:f32 W, X), Y), Z). If a target supports floating point multiply-and-add (FMA) operations, one of; the adds can be merged with the multiply. On the PowerPC, for example, the; output of the instruction selector might look like this DAG:. ::. (FMADDS (FADDS W, X), Y, Z). The ``FMADDS`` instruction is a ternary instruction that multiplies its first; two operands and adds the third (as single-precision floating-point numbers).; The ``FADDS`` instruction is a simple binary single-precision add instruction.; To perform this pattern match, the PowerPC backend includes the following; instruction definitions:. .. code-block:: text; :emphasize-lines: 4-5,9. def FMADDS : AForm_1<59, 29,; (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRC, F4RC:$FRB),; ""fmadds $FRT, $FRA, $FRC, $FRB"",; [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),; F4RC:$FRB))]>;; def FADDS : AForm_2<59, 21,; (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRB),; ""fadds $FRT, $FRA, $FRB"",; [(set F4RC:$FRT, (fadd F4RC:$FRA, F4RC:$FRB))]>;. The highlighted portion of the instruction definitions indicates the pattern; used to match the instructions. The DAG operators (like ``fmul``/``fadd``); are defined in the ``include/llvm/Target/TargetSelectionDAG.td`` file.; ""``F4RC``"" is the register class of the input and result values. The TableGen DAG instruction selector generator reads the instruction patterns; in the ``.td`` file and automatically builds parts of the pattern matching code; for your target. It has the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:47597,simpl,simple,47597,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Iterating over the predecessors and successors of a block is quite easy with the; routines defined in ``""llvm/IR/CFG.h""``. Just use code like this to; iterate over all predecessors of BB:. .. code-block:: c++. #include ""llvm/IR/CFG.h""; BasicBlock *BB = ...;. for (BasicBlock *Pred : predecessors(BB)) {; // ...; }. Similarly, to iterate over successors use ``successors``. .. _simplechanges:. Making simple changes; ---------------------. There are some primitive transformation operations present in the LLVM; infrastructure that are worth knowing about. When performing transformations,; it's fairly common to manipulate the contents of basic blocks. This section; describes some of the common methods for doing so and gives example code. .. _schanges_creating:. Creating and inserting new ``Instruction``\ s; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. *Instantiating Instructions*. Creation of ``Instruction``\ s is straight-forward: simply call the constructor; for the kind of instruction to instantiate and provide the necessary parameters.; For example, an ``AllocaInst`` only *requires* a (const-ptr-to) ``Type``. Thus:. .. code-block:: c++. auto *ai = new AllocaInst(Type::Int32Ty);. will create an ``AllocaInst`` instance that represents the allocation of one; integer in the current stack frame, at run time. Each ``Instruction`` subclass; is likely to have varying default parameters which change the semantics of the; instruction, so refer to the `doxygen documentation for the subclass of; Instruction <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_ that; you're interested in instantiating. *Naming values*. It is very useful to name the values of instructions when you're able to, as; this facilitates the debugging of your transformations. If you end up looking; at generated LLVM machine code, you definitely want to have logical names; associated with the results of instructions! By supplying a value for the; ``Name`` (default) param",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:113735,simpl,simply,113735,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simply']
Usability,"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This section mostly applies to Linux and older BSDs. On macOS, you should; have a sufficiently modern Xcode, or you will likely need to upgrade until you; do. Windows does not have a ""system compiler"", so you must install either Visual; Studio 2019 (or later), or a recent version of mingw64. FreeBSD 10.0 and newer; have a modern Clang as the system compiler. However, some Linux distributions and some other or older BSDs sometimes have; extremely old versions of GCC. These steps attempt to help you upgrade you; compiler even on such a system. However, if at all possible, we encourage you; to use a recent version of a distribution with a modern system compiler that; meets these requirements. Note that it is tempting to install a prior; version of Clang and libc++ to be the host compiler, however libc++ was not; well tested or set up to build on Linux until relatively recently. As; a consequence, this guide suggests just using libstdc++ and a modern GCC as the; initial host in a bootstrap, and then using Clang (and potentially libc++). The first step is to get a recent GCC toolchain installed. The most common; distribution on which users have struggled with the version requirements is; Ubuntu Precise, 12.04 LTS. For this distribution, one easy option is to install; the `toolchain testing PPA`_ and use it to install a modern GCC. There is; a really nice discussions of this on the `ask ubuntu stack exchange`_ and a; `github gist`_ with updated commands. However, not all users can use PPAs and; there are many other distributions, so it may be necessary (or just useful, if; you're here you *are* doing compiler development after all) to build and install; GCC from source. It is also quite easy to do these days. .. _toolchain testing PPA:; https://launchpad.net/~ubuntu-toolchain-r/+archive/test; .. _ask ubuntu stack exchange:; https://askubuntu.com/questions/466651/how-do-i-use-the-latest-gcc-on-ubuntu/581497#58149; .. _github gist:; https://g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:15837,guid,guide,15837,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['guid'],['guide']
Usability,"_5; ...; ```. Returns have a simple mitigation technique on x86-64 (or other ABIs which have; what is called a ""red zone"" region beyond the end of the stack). This region is; guaranteed to be preserved across interrupts and context switches, making the; return address used in returning to the current code remain on the stack and; valid to read. We can emit code in the caller to verify that a return edge was; not mispredicted:; ```; callq other_function; return_addr:; testq -8(%rsp), return_addr # Validate return address.; cmovneq %r8, %rax # Update predicate state.; ```. For an ABI without a ""red zone"" (and thus unable to read the return address; from the stack), we can compute the expected return address prior to the call; into a register preserved across the call and use that similarly to the above. Indirect calls (and returns in the absence of a red zone ABI) pose the most; significant challenge to propagate. The simplest technique would be to define a; new ABI such that the intended call target is passed into the called function; and checked in the entry. Unfortunately, new ABIs are quite expensive to deploy; in C and C++. While the target function could be passed in TLS, we would still; require complex logic to handle a mixture of functions compiled with and; without this extra logic (essentially, making the ABI backwards compatible).; Currently, we suggest using retpolines here and will continue to investigate; ways of mitigating this. ##### Optimizations, Alternatives, and Tradeoffs. Merely accumulating predicate state involves significant cost. There are; several key optimizations we employ to minimize this and various alternatives; that present different tradeoffs in the generated code. First, we work to reduce the number of instructions used to track the state:; * Rather than inserting a `cmovCC` instruction along every conditional edge in; the original program, we track each set of condition flags we need to capture; prior to entering each basic block and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:20008,simpl,simplest,20008,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['simpl'],['simplest']
Usability,"_DIR} ${CMAKE_BINARY_DIR}/profiles/; COMMENT ""Merging profdata""; DEPENDS generate-profraw); if (CLANG_PGO_TRAINING_DATA_SOURCE_DIR); llvm_ExternalProject_Add(generate-profraw-external ${CLANG_PGO_TRAINING_DATA_SOURCE_DIR}; USE_TOOLCHAIN EXLUDE_FROM_ALL NO_INSTALL DEPENDS generate-profraw); add_dependencies(generate-profdata generate-profraw-external); endif(); endif(); endif(). find_program(DTRACE dtrace); # TODO: Look into supporting this for the driver build. It will require changing; # the perf-helper.py file to understand to call `llvm` as `llvm clang`.; if(APPLE AND DTRACE AND NOT LLVM_TOOL_LLVM_DRIVER_BUILD); configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/order-files.lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/order-files/lit.site.cfg; ). add_lit_testsuite(generate-dtrace-logs ""Generating clang dtrace data""; ${CMAKE_CURRENT_BINARY_DIR}/order-files/; EXCLUDE_FROM_CHECK_ALL; ARGS -j 1; DEPENDS clang clear-dtrace-logs; ). add_custom_target(clear-dtrace-logs; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py clean ${CMAKE_CURRENT_BINARY_DIR} dtrace; COMMENT ""Clearing old dtrace data""). if(NOT CLANG_ORDER_FILE); message(FATAL_ERROR ""Output clang order file is not set""); endif(). add_custom_target(generate-order-file; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py gen-order-file --binary $<TARGET_FILE:clang> --output ${CLANG_ORDER_FILE} ${CMAKE_CURRENT_BINARY_DIR}; COMMENT ""Generating order file""; DEPENDS generate-dtrace-logs); endif(). if(CLANG_BOLT_INSTRUMENT AND NOT LLVM_BUILD_INSTRUMENTED); configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/bolt.lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/bolt-fdata/lit.site.cfg; ). add_lit_testsuite(generate-bolt-fdata ""Generating BOLT profile for Clang""; ${CMAKE_CURRENT_BINARY_DIR}/bolt-fdata/; EXCLUDE_FROM_CHECK_ALL; DEPENDS clang-instrumented clear-bolt-fdata; ). add_custom_target(clear-bolt-fdata; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt:2375,clear,clear-dtrace-logs,2375,interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,1,['clear'],['clear-dtrace-logs']
Usability,"_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according to very simple laws, and an additional Gaussian smearing. This; set of variables mimics a measurement of an electrical resistance while; varying pressure and temperature. Imagine your task now consists in finding the relations among the; variables -- of course without knowing the code used to generate them.; You will see that the possibilities of the `NTuple` class enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:2527,simpl,simple,2527,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['simpl'],['simple']
Usability,"_postdec__``; ``operator--()`` ``__predec__``; ``unary operator*`` ``__deref__``; ``operator->`` ``__follow__``; ``operator&&`` ``__dand__``; ``operator||`` ``__dor__``; ``operator,`` ``__comma__``; =================== ===================. Here is an example of operator usage, using STL iterators directly (note that; this is not necessary in practice as STL and STL-like containers work; transparently in Python for-loops):. .. code-block:: python. >>> v = cppyy.gbl.std.vector[int](range(3)); >>> i = v.begin(); >>> while (i != v.end()):; ... print(i.__deref__()); ... _ = i.__preinc__(); ...; 0; 1; 2; >>>. Overridden ``operator new`` and ``operator delete``, as well as their array; equivalents, are not accessible but will be called as appropriate. `Templates`; -----------. Templated classes are instantiated using square brackets.; (For backwards compatibility reasons, parentheses work as well.); The instantiation of a templated class yields a class, which can then; be used to create instances. Templated classes need not pre-exist in the bound code, just their; declaration needs to be available.; This is true for e.g. all of STL:. .. code-block:: python. >>> cppyy.gbl.std.vector # template metatype; <cppyy.Template 'std::vector' object at 0x7fffed2674d0>; >>> cppyy.gbl.std.vector(int) # instantiates template -> class; <class cppyy.gbl.std.vector<int> at 0x1532190>; cppyy.gbl.std.vector[int]() # instantiates class -> object; <cppyy.gbl.std.vector<int> object at 0x2341ec0>; >>>. The template arguments may be actual types or their names as a string,; whichever is more convenient.; Thus, the following are equivalent:. .. code-block:: python. >>> from cppyy.gbl.std import vector; >>> type1 = vector[Concrete]; >>> type2 = vector['Concrete']; >>> type1 == type2; True; >>>. `Typedefs`; ----------. Typedefs are simple python references to the actual classes to which; they refer. .. code-block:: python. >>> from cppyy.gbl import Concrete_t; >>> Concrete is Concrete_t; True; >>>. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst:12145,simpl,simple,12145,bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,1,['simpl'],['simple']
Usability,"` from the menu line of the window. It will pop up a file; selector box to allow you to choose the format, file name and target; directory to store the image. There is one very noticeable feature here:; you can store a plot as a root macro! In this macro, you find the C++; representation of all methods and classes involved in generating the; plot. This is a valuable source of information for your own macros,; which you will hopefully write after having worked through this; tutorial. Using ROOT's interactive capabilities is useful for a first exploration; of possibilities. Other ROOT classes you will encounter in this tutorial; have such graphical interfaces. We will not comment further on this,; just be aware of the existence of ROOT's interactive features and use; them if you find them convenient. Some trial-and-error is certainly necessary; to find your way through the huge number of menus and parameter; settings. ## ROOT Beginners' FAQ ##. At this point of the guide, some basic questions could have already come; to your mind. We will try to clarify some of them with further; explanations in the following. ### ROOT type declarations for basic data types ###. In the official ROOT documentation, you find special data types; replacing the normal ones, e.g. `Double_t`, `Float_t` or `Int_t`; replacing the standard `double`, `float` or `int` types. Using the ROOT; types makes it easier to port code between platforms (64/32 bit) or; operating systems (windows/Linux), as these types are mapped to suitable; ones in the ROOT header files. If you want adaptive code of this type,; use the ROOT type declarations. However, usually you do not need such; adaptive code, and you can safely use the standard C type declarations; for your private code, as we did and will do throughout this guide. If; you intend to become a ROOT developer, however, you better stick to the; official coding rules!. ### Configure ROOT at start-up ###. The behaviour of a ROOT session can be tailored with t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:16942,guid,guide,16942,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['guid'],['guide']
Usability,"` nor allow it to be; declared. Instead it should provide its own interface to discovering; information about files and directories. Those interfaces may be implemented in; terms of ``stat`` but that is strictly an implementation detail. The interface; provided by the Support Library must be implemented on all platforms (even; those without ``stat``). No Exposed Data; ---------------. Any data defined by system libraries (i.e. not defined by ``lib/Support``) must; not be exposed through the ``lib/Support`` interface, even if the header file; for that function is not exposed. As with functions, this prevents inadvertent; use of data that might not exist on all platforms. Minimize Soft Errors; --------------------. Operating system interfaces will generally provide error results for every; little thing that could go wrong. In almost all cases, you can divide these; error results into two groups: normal/good/soft and abnormal/bad/hard. That is,; some of the errors are simply information like ""file not found"", ""insufficient; privileges"", etc. while other errors are much harder like ""out of space"", ""bad; disk sector"", or ""system call interrupted"". We'll call the first group ""*soft*""; errors and the second group ""*hard*"" errors. ``lib/Support`` must always attempt to minimize soft errors. This is a design; requirement because the minimization of soft errors can affect the granularity; and the nature of the interface. In general, if you find that you're wanting to; throw soft errors, you must review the granularity of the interface because it; is likely you're trying to implement something that is too low level. The rule; of thumb is to provide interface functions that **can't** fail, except when; faced with hard errors. For a trivial example, suppose we wanted to add an ""``OpenFileForWriting``""; function. For many operating systems, if the file doesn't exist, attempting to; open the file will produce an error. However, ``lib/Support`` should not simply; throw that error i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:7510,simpl,simply,7510,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['simpl'],['simply']
Usability,"` operand to the convergent call. The semantics of the; ``loop`` intrinsic ensures that the convergent call is performed convergently; only by those threads that convergently exited the loop in a given iteration. .. code-block:: llvm. define void @example() convergent {; %entry = call token @llvm.experimental.convergence.entry(); br label %for. for:; %inner = call token @llvm.experimental.convergence.loop() [""convergencectrl""(token %entry)]; %for.cond = i1 ...; br i1 %for.cond, label %B, label %E. B:; ...; %condition = i1 ...; br i1 %condition, label %C, label %D. C:; call void @convergent_op() [""convergencectrl""(token %inner)]; br label %E. D:; ...; br label %for. E:; ...; ret void; }. The LLVM IR version of the same program shows a cycle consisting of the basic; blocks ``%for``, ``%B`` and ``%D``, while ``%C`` is an exit reached by the; divergent branch at the end of the exiting block ``%B``. But the use of; convergence control tokens makes it clear that block ``%C`` must be executed; convergently only by those threads that convergently take the exit edge from %B; to ``%C``. In other words, the convergent execution of ``%C`` is governed by the; call to the :ref:`llvm.experimental.convergence.loop; <llvm.experimental.convergence.loop>` intrinsic inside the cycle. The cycle is; effectively extended to include all uses of this token that lie outside the; cycle. .. _dynamic_instances_and_convergence_tokens:. Dynamic Instances and Convergence Tokens; ========================================. Every execution of an LLVM IR instruction occurs in a :ref:`dynamic instance; <convergence-dynamic-instances>` of the instruction. Dynamic instances are the; formal objects by which we talk about communicating threads in convergent; operations. Dynamic instances are defined for *all* operations in an LLVM; program, whether convergent or not. Convergence control is primarily about the; dynamic instances of convergent operations since they affect execution of the; program through int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:18111,clear,clear,18111,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['clear'],['clear']
Usability,"`**` ::Draw` ); for the first time, it creates a **`THistPainter`** object and saves a; pointer to painter as a data member of the histogram. The; **`THistPainter`** class specializes in the drawing of histograms. It; allows logarithmic axes (x, y, z) when the CONT drawing option is; using. The **`THistPainter`** class is separated from the histogram so; that one can have histograms without the graphics overhead, for; example in a batch program. The choice to give each histogram has its; own painter rather than a central singleton painter, allows two; histograms to be drawn in two threads without overwriting the; painter's values. When a displayed histogram is filled again, you do; not have to call the `Draw` method again. The image is refreshed the; next time the pad is updated. A pad is updated after one of these; three actions:. - A carriage control on the ROOT command line. - A click inside the pad. - A call to **`TPad`**`::Update()`. By default, the **`TH1`**`::Draw` clears the pad before drawing the; new image of the histogram. You can use the `""SAME""` option to leave; the previous display intact and superimpose the new histogram. The; same histogram can be drawn with different graphics options in; different pads. When a displayed histogram is deleted, its image is; automatically removed from the pad. To create a copy of the histogram; when drawing it, you can use **`TH1`**`::DrawClone()`. This will clone; the histogram and allow you to change and delete the original one; without affecting the clone. You can use **`TH1`**`::DrawNormalized()`; to draw a normalized copy of a histogram. ``` {.cpp}; TH1 *TH1::DrawNormalized(Option_t *option,Double_t norm) const; ```. A clone of this histogram is normalized to norm and drawn with option.; A pointer to the normalized histogram is returned. The contents of the; histogram copy are scaled such that the new sum of weights (excluding; under and overflow) is equal to `norm` . Note that the returned normalized histogram is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:13927,clear,clears,13927,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['clear'],['clears']
Usability,"`BranchFolding.cpp`` and; ``IfConversion.cpp`` in the ``lib/CodeGen`` directory) call ``analyzeBranch``; to improve the control flow graph that represents the instructions. Several implementations of ``analyzeBranch`` (for ARM, Alpha, and X86) can be; examined as models for your own ``analyzeBranch`` implementation. Since SPARC; does not implement a useful ``analyzeBranch``, the ARM target implementation is; shown below. ``analyzeBranch`` returns a Boolean value and takes four parameters:. * ``MachineBasicBlock &MBB`` --- The incoming block to be examined. * ``MachineBasicBlock *&TBB`` --- A destination block that is returned. For a; conditional branch that evaluates to true, ``TBB`` is the destination. * ``MachineBasicBlock *&FBB`` --- For a conditional branch that evaluates to; false, ``FBB`` is returned as the destination. * ``std::vector<MachineOperand> &Cond`` --- List of operands to evaluate a; condition for a conditional branch. In the simplest case, if a block ends without a branch, then it falls through; to the successor block. No destination blocks are specified for either ``TBB``; or ``FBB``, so both parameters return ``NULL``. The start of the; ``analyzeBranch`` (see code below for the ARM target) shows the function; parameters and the code for the simplest case. .. code-block:: c++. bool ARMInstrInfo::analyzeBranch(MachineBasicBlock &MBB,; MachineBasicBlock *&TBB,; MachineBasicBlock *&FBB,; std::vector<MachineOperand> &Cond) const; {; MachineBasicBlock::iterator I = MBB.end();; if (I == MBB.begin() || !isUnpredicatedTerminator(--I)); return false;. If a block ends with a single unconditional branch instruction, then; ``analyzeBranch`` (shown below) should return the destination of that branch in; the ``TBB`` parameter. .. code-block:: c++. if (LastOpc == ARM::B || LastOpc == ARM::tB) {; TBB = LastInst->getOperand(0).getMBB();; return false;; }. If a block ends with two unconditional branches, then the second branch is; never reached. In that situation, a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:48377,simpl,simplest,48377,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['simpl'],['simplest']
Usability,"`LLVMConfig.cmake`` file sets various useful variables. Notable variables; include. ``LLVM_CMAKE_DIR``; The path to the LLVM CMake directory (i.e. the directory containing; LLVMConfig.cmake). ``LLVM_DEFINITIONS``; A list of preprocessor defines that should be used when building against LLVM. ``LLVM_ENABLE_ASSERTIONS``; This is set to ON if LLVM was built with assertions, otherwise OFF. ``LLVM_ENABLE_EH``; This is set to ON if LLVM was built with exception handling (EH) enabled,; otherwise OFF. ``LLVM_ENABLE_RTTI``; This is set to ON if LLVM was built with run time type information (RTTI),; otherwise OFF. ``LLVM_INCLUDE_DIRS``; A list of include paths to directories containing LLVM header files. ``LLVM_PACKAGE_VERSION``; The LLVM version. This string can be used with CMake conditionals, e.g., ``if; (${LLVM_PACKAGE_VERSION} VERSION_LESS ""3.5"")``. ``LLVM_TOOLS_BINARY_DIR``; The path to the directory containing the LLVM tools (e.g. ``llvm-as``). Notice that in the above example we link ``simple-tool`` against several LLVM; libraries. The list of libraries is determined by using the; ``llvm_map_components_to_libnames()`` CMake function. For a list of available; components look at the output of running ``llvm-config --components``. Note that for LLVM < 3.5 ``llvm_map_components_to_libraries()`` was; used instead of ``llvm_map_components_to_libnames()``. This is now deprecated; and will be removed in a future version of LLVM. .. _cmake-out-of-source-pass:. Developing LLVM passes out of source; ------------------------------------. It is possible to develop LLVM passes out of LLVM's source tree (i.e. against an; installed or built LLVM). An example of a project layout is provided below. .. code-block:: none. <project dir>/; |; CMakeLists.txt; <pass name>/; |; CMakeLists.txt; Pass.cpp; ... Contents of ``<project dir>/CMakeLists.txt``:. .. code-block:: cmake. find_package(LLVM REQUIRED CONFIG). separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS}); add_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:44455,simpl,simple-tool,44455,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['simpl'],['simple-tool']
Usability,"`TableGen; Backend Developer's Guide <./BackGuide>` for a guide to writing a new; backend. Here are a few of the things backends can do. * Generate the register file information for a particular target machine. * Generate the instruction definitions for a target. * Generate the patterns that the code generator uses to match instructions; to intermediate representation (IR) nodes. * Generate semantic attribute identifiers for Clang. * Generate abstract syntax tree (AST) declaration node definitions for Clang. * Generate AST statement node definitions for Clang. Concepts; --------. TableGen source files contain two primary items: *abstract records* and; *concrete records*. In this and other TableGen documents, abstract records; are called *classes.* (These classes are different from C++ classes and do; not map onto them.) In addition, concrete records are usually just called; records, although sometimes the term *record* refers to both classes and; concrete records. The distinction should be clear in context. Classes and concrete records have a unique *name*, either chosen by; the programmer or generated by TableGen. Associated with that name; is a list of *fields* with values and an optional list of *parent classes*; (sometimes called base or super classes). The fields are the primary data that; backends will process. Note that TableGen assigns no meanings to fields; the; meanings are entirely up to the backends and the programs that incorporate; the output of those backends. .. note::. The term ""parent class"" can refer to a class that is a parent of another; class, and also to a class from which a concrete record inherits. This; nonstandard use of the term arises because TableGen treats classes and; concrete records similarly. A backend processes some subset of the concrete records built by the; TableGen parser and emits the output files. These files are usually C++; ``.inc`` files that are included by the programs that require the data in; those records. However, a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:2464,clear,clear,2464,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['clear'],['clear']
Usability,"`__; This list gets emailed every time a bug is opened and closed. It is; higher volume than the LLVM-dev list. .. __: http://lists.llvm.org/pipermail/llvm-bugs/. `LLVM Announcements`__; If you just want project wide announcements such as releases, developers meetings, or blog posts, then you should check out the Announcement category on LLVM Discourse. .. __: https://discourse.llvm.org/c/announce/46. .. _online-sync-ups:. Online Sync-Ups; ---------------. A number of regular calls are organized on specific topics. It should be; expected that the range of topics will change over time. At the time of; writing, the following sync-ups are organized.; The :doc:`CodeOfConduct` applies to all online sync-ups. If you'd like to organize a new sync-up, please add the info in the table; below. Please also create a calendar event for it and invite calendar@llvm.org; to the event, so that it'll show up on the :ref:`llvm-community-calendar`.; Please see :ref:`llvm-community-calendar-host-guidance` for more guidance on; what to add to your calendar invite. .. list-table:: LLVM regular sync-up calls; :widths: 25 25 25 25; :header-rows: 1. * - Topic; - Frequency; - Calendar link; - Minutes/docs link; * - Loop Optimization Working Group; - Every 2 weeks on Wednesday; - `ics <./_static/LoopOptWG_invite.ics>`__; - `Minutes/docs <https://docs.google.com/document/d/1sdzoyB11s0ccTZ3fobqctDpgJmRoFcz0sviKxqczs4g/edit>`__; * - RISC-V; - Every 2 weeks on Thursday; - `ics <https://calendar.google.com/calendar/ical/lowrisc.org_0n5pkesfjcnp0bh5hps1p0bd80%40group.calendar.google.com/public/basic.ics>`__; `gcal <https://calendar.google.com/calendar/b/1?cid=bG93cmlzYy5vcmdfMG41cGtlc2ZqY25wMGJoNWhwczFwMGJkODBAZ3JvdXAuY2FsZW5kYXIuZ29vZ2xlLmNvbQ>`__; - `Minutes/docs <https://docs.google.com/document/d/1G3ocHm2zE6AYTS2N3_3w2UxFnSEyKkcF57siLWe-NVs>`__; * - Scalable Vectors and Arm SVE; - Monthly, every 3rd Tuesday; - `ics <https://calendar.google.com/calendar/ical/bjms39pe6k6bo5egtsp7don414%40group.cal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:4324,guid,guidance,4324,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,2,['guid'],['guidance']
Usability,"``%X`` has a zero bit, then the output of the; '``and``' operation will always be a zero for that bit, no matter what; the corresponding bit from the '``undef``' is. As such, it is unsafe to; optimize or assume that the result of the '``and``' is '``undef``'.; However, it is safe to assume that all bits of the '``undef``' could be; 0, and optimize the '``and``' to 0. Likewise, it is safe to assume that; all the bits of the '``undef``' operand to the '``or``' could be set,; allowing the '``or``' to be folded to -1. .. code-block:: llvm. %A = select undef, %X, %Y; %B = select undef, 42, %Y; %C = select %X, %Y, undef; Safe:; %A = %X (or %Y); %B = 42 (or %Y); %C = %Y (if %Y is provably not poison; unsafe otherwise); Unsafe:; %A = undef; %B = undef; %C = undef. This set of examples shows that undefined '``select``' (and conditional; branch) conditions can go *either way*, but they have to come from one; of the two operands. In the ``%A`` example, if ``%X`` and ``%Y`` were; both known to have a clear low bit, then ``%A`` would have to have a; cleared low bit. However, in the ``%C`` example, the optimizer is; allowed to assume that the '``undef``' operand could be the same as; ``%Y`` if ``%Y`` is provably not '``poison``', allowing the whole '``select``'; to be eliminated. This is because '``poison``' is stronger than '``undef``'. .. code-block:: llvm. %A = xor undef, undef. %B = undef; %C = xor %B, %B. %D = undef; %E = icmp slt %D, 4; %F = icmp gte %D, 4. Safe:; %A = undef; %B = undef; %C = undef; %D = undef; %E = undef; %F = undef. This example points out that two '``undef``' operands are not; necessarily the same. This can be surprising to people (and also matches; C semantics) where they assume that ""``X^X``"" is always zero, even if; ``X`` is undefined. This isn't true for a number of reasons, but the; short answer is that an '``undef``' ""variable"" can arbitrarily change; its value over its ""live range"". This is true because the variable; doesn't actually *have a live r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:193150,clear,clear,193150,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['clear'],"['clear', 'cleared']"
Usability,"``. Subdirectory; names known to LLVM include:. * spec95. * speccpu2000. * speccpu2006. * povray31. Others are added from time to time, and can be determined from; ``configure``. Running Different Tests; =======================. In addition to the regular ""whole program"" tests, the ``test-suite``; module also provides a mechanism for compiling the programs in different; ways. If the variable TEST is defined on the ``gmake`` command line, the; test system will include a Makefile named; ``TEST.<value of TEST variable>.Makefile``. This Makefile can modify; build rules to yield different results. For example, the LLVM nightly tester uses ``TEST.nightly.Makefile`` to; create the nightly test reports. To run the nightly tests, run; ``gmake TEST=nightly``. There are several TEST Makefiles available in the tree. Some of them are; designed for internal LLVM research and will not work outside of the; LLVM research group. They may still be valuable, however, as a guide to; writing your own TEST Makefile for any optimization or analysis passes; that you develop with LLVM. Generating Test Output; ======================. There are a number of ways to run the tests and generate output. The; most simple one is simply running ``gmake`` with no arguments. This will; compile and run all programs in the tree using a number of different; methods and compare results. Any failures are reported in the output,; but are likely drowned in the other output. Passes are not reported; explicitly. Somewhat better is running ``gmake TEST=sometest test``, which runs the; specified test and usually adds per-program summaries to the output; (depending on which sometest you use). For example, the ``nightly`` test; explicitly outputs TEST-PASS or TEST-FAIL for every test after each; program. Though these lines are still drowned in the output, it's easy; to grep the output logs in the Output directories. Even better are the ``report`` and ``report.format`` targets (where; ``format`` is one of ``html``, `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:3538,guid,guide,3538,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,1,['guid'],['guide']
Usability,"``; interface. All of these :ref:`chain <aliasanalysis-chaining>` to other; alias analysis implementations. The ``-basic-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^. The ``-basic-aa`` pass is an aggressive local analysis that *knows* many; important facts:. * Distinct globals, stack allocations, and heap allocations can never alias.; * Globals, stack allocations, and heap allocations never alias the null pointer.; * Different fields of a structure do not alias.; * Indexes into arrays with statically differing subscripts cannot alias.; * Many common standard C library functions `never access memory or only read; memory`_.; * Pointers that obviously point to constant globals ""``pointToConstantMemory``"".; * Function calls can not modify or references stack allocations if they never; escape from the function that allocates them (a common case for automatic; arrays). The ``-globalsmodref-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This pass implements a simple context-sensitive mod/ref and alias analysis for; internal global variables that don't ""have their address taken"". If a global; does not have its address taken, the pass knows that no pointers alias the; global. This pass also keeps track of functions that it knows never access; memory or never read memory. This allows certain optimizations (e.g. GVN) to; eliminate call instructions entirely. The real power of this pass is that it provides context-sensitive mod/ref; information for call instructions. This allows the optimizer to know that calls; to a function do not clobber or read the value of the global, allowing loads and; stores to be eliminated. .. note::. This pass is somewhat limited in its scope (only support non-address taken; globals), but is very quick analysis. The ``-steens-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^. The ``-steens-aa`` pass implements a variation on the well-known ""Steensgaard's; algorithm"" for interprocedural alias analysis. Steensgaard's algorithm is a; unification-based, flow-insensitive, context-insen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:24587,simpl,simple,24587,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['simpl'],['simple']
Usability,"``ADD %EAX, %EBX``, in X86 is actually equivalent to ``%EAX = %EAX +; %EBX``. In order to produce correct code, LLVM must convert three address instructions; that represent two address instructions into true two address instructions. LLVM; provides the pass ``TwoAddressInstructionPass`` for this specific purpose. It; must be run before register allocation takes place. After its execution, the; resulting code may no longer be in SSA form. This happens, for instance, in; situations where an instruction such as ``%a = ADD %b %c`` is converted to two; instructions such as:. ::. %a = MOVE %b; %a = ADD %a %c. Notice that, internally, the second instruction is represented as ``ADD; %a[def/use] %c``. I.e., the register operand ``%a`` is both used and defined by; the instruction. The SSA deconstruction phase; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. An important transformation that happens during register allocation is called; the *SSA Deconstruction Phase*. The SSA form simplifies many analyses that are; performed on the control flow graph of programs. However, traditional; instruction sets do not implement PHI instructions. Thus, in order to generate; executable code, compilers must replace PHI instructions with other instructions; that preserve their semantics. There are many ways in which PHI instructions can safely be removed from the; target code. The most traditional PHI deconstruction algorithm replaces PHI; instructions with copy instructions. That is the strategy adopted by LLVM. The; SSA deconstruction algorithm is implemented in; ``lib/CodeGen/PHIElimination.cpp``. In order to invoke this pass, the identifier; ``PHIEliminationID`` must be marked as required in the code of the register; allocator. Instruction folding; ^^^^^^^^^^^^^^^^^^^. *Instruction folding* is an optimization performed during register allocation; that removes unnecessary copy instructions. For instance, a sequence of; instructions such as:. ::. %EBX = LOAD %mem_address; %EAX = COPY %EBX. can be safely subs",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:67820,simpl,simplifies,67820,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simplifies']
Usability,"``mu`` before calling ``withdrawImpl``.; Because the caller is assumed to have locked ``mu``, it is safe to modify; ``balance`` within the body of the method. The ``depositImpl()`` method does not have ``REQUIRES``, so the; analysis issues a warning. Thread safety analysis is not inter-procedural, so; caller requirements must be explicitly declared.; There is also a warning in ``transferFrom()``, because although the method; locks ``this->mu``, it does not lock ``b.mu``. The analysis understands; that these are two separate mutexes, in two different objects. Finally, there is a warning in the ``withdraw()`` method, because it fails to; unlock ``mu``. Every lock must have a corresponding unlock, and the analysis; will detect both double locks, and double unlocks. A function is allowed to; acquire a lock without releasing it, (or vice versa), but it must be annotated; as such (using ``ACQUIRE``/``RELEASE``). Running The Analysis; --------------------. To run the analysis, simply compile with the ``-Wthread-safety`` flag, e.g. .. code-block:: bash. clang -c -Wthread-safety example.cpp. Note that this example assumes the presence of a suitably annotated; :ref:`mutexheader` that declares which methods perform locking,; unlocking, and so on. Basic Concepts: Capabilities; ============================. Thread safety analysis provides a way of protecting *resources* with; *capabilities*. A resource is either a data member, or a function/method; that provides access to some underlying resource. The analysis ensures that; the calling thread cannot access the *resource* (i.e. call the function, or; read/write the data) unless it has the *capability* to do so. Capabilities are associated with named C++ objects which declare specific; methods to acquire and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:3180,simpl,simply,3180,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['simpl'],['simply']
Usability,"`dot-post-dom``: Print postdominance tree of function to ""dot"" file; --------------------------------------------------------------------. This pass, only available in ``opt``, prints the post dominator tree into a; ``.dot`` graph. This graph can then be processed with the :program:`dot` tool; to convert it to postscript or some other suitable format. ``dot-post-dom-only``: Print postdominance tree of function to ""dot"" file (with no function bodies); ---------------------------------------------------------------------------------------------------. This pass, only available in ``opt``, prints the post dominator tree into a; ``.dot`` graph, omitting the function bodies. This graph can then be processed; with the :program:`dot` tool to convert it to postscript or some other suitable; format. ``globals-aa``: Simple mod/ref analysis for globals; ---------------------------------------------------. This simple pass provides alias and mod/ref information for global values that; do not have their address taken, and keeps track of whether functions read or; write memory (are ""pure""). For this simple (but very common) case, we can; provide pretty accurate and useful information. ``instcount``: Counts the various types of ``Instruction``\ s; -------------------------------------------------------------. This pass collects the count of all instructions and reports them. ``iv-users``: Induction Variable Users; --------------------------------------. Bookkeeping for ""interesting"" users of expressions computed from induction; variables. ``lazy-value-info``: Lazy Value Information Analysis; ----------------------------------------------------. Interface for lazy computation of value constraint information. ``lint``: Statically lint-checks LLVM IR; ----------------------------------------. This pass statically checks for common and easily-identified constructs which; produce undefined or likely unintended behavior in LLVM IR. It is not a guarantee of correctness, in two ways. Firs",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:5525,simpl,simple,5525,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"`llc``, then pipe the output of ``llc`` into ``FileCheck``. This; means that FileCheck will be verifying its standard input (the llc output); against the filename argument specified (the original ``.ll`` file specified by; ""``%s``""). To see how this works, let's look at the rest of the ``.ll`` file; (after the RUN line):. .. code-block:: llvm. define void @sub1(i32* %p, i32 %v) {; entry:; ; CHECK: sub1:; ; CHECK: subl; %0 = tail call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %p, i32 %v); ret void; }. define void @inc4(i64* %p) {; entry:; ; CHECK: inc4:; ; CHECK: incq; %0 = tail call i64 @llvm.atomic.load.add.i64.p0i64(i64* %p, i64 1); ret void; }. Here you can see some ""``CHECK:``"" lines specified in comments. Now you can; see how the file is piped into ``llvm-as``, then ``llc``, and the machine code; output is what we are verifying. FileCheck checks the machine code output to; verify that it matches what the ""``CHECK:``"" lines specify. The syntax of the ""``CHECK:``"" lines is very simple: they are fixed strings that; must occur in order. FileCheck defaults to ignoring horizontal whitespace; differences (e.g. a space is allowed to match a tab) but otherwise, the contents; of the ""``CHECK:``"" line is required to match some thing in the test file exactly. One nice thing about FileCheck (compared to grep) is that it allows merging; test cases together into logical groups. For example, because the test above; is checking for the ""``sub1:``"" and ""``inc4:``"" labels, it will not match; unless there is a ""``subl``"" in between those labels. If it existed somewhere; else in the file, that would not count: ""``grep subl``"" matches if ""``subl``""; exists anywhere in the file. The FileCheck -check-prefix option; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The FileCheck `-check-prefix` option allows multiple test; configurations to be driven from one `.ll` file. This is useful in many; circumstances, for example, testing different architectural variants with; :program:`llc`. Here's a simple e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:9137,simpl,simple,9137,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['simpl'],['simple']
Usability,"`remarkEmitter``; or even ``remarker``. The following is a list of longer class names and the associated shorter; variable name. ========================= =============; Class name Variable name; ========================= =============; BasicBlock block; ConstantExpr expr; ExecutionEngine engine; MachineOperand operand; OptimizationRemarkEmitter remarker; PreservedAnalyses analyses; PreservedAnalysesChecker checker; TargetLowering lowering; TargetMachine machine; ========================= =============. Transition Options; ==================. There are three main options for transitioning:. 1. Keep the current coding standard; 2. Laissez faire; 3. Big bang. Keep the current coding standard; --------------------------------. Proponents of keeping the current coding standard (i.e. not transitioning at; all) question whether the cost of transition outweighs the benefit; [EmersonConcern]_ [ReamesConcern]_ [BradburyConcern]_.; The costs are that ``git blame`` will become less usable; and that merging the; changes will be costly for downstream maintainers. See `Big bang`_ for potential; mitigations. Laissez faire; -------------. The coding standard could allow both ``CamelCase`` and ``camelBack`` styles for; variable names [LattnerTransition]_. A code review to implement this is at https://reviews.llvm.org/D57896. Advantages; **********. * Very easy to implement initially. Disadvantages; *************. * Leads to inconsistency [BradburyConcern]_ [AminiInconsistent]_.; * Inconsistency means it will be hard to know at a guess what name a variable; will have [DasInconsistent]_ [CarruthInconsistent]_.; * Some large-scale renaming may happen anyway, leading to its disadvantages; without any mitigations. Big bang; --------. With this approach, variables will be renamed by an automated script in a series; of large commits. The principle advantage of this approach is that it minimises the cost of; inconsistency [BradburyTransition]_ [RobinsonTransition]_. It goes against a policy",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:7785,usab,usable,7785,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['usab'],['usable']
Usability,"`vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. .. option:: -fsanitize-cfi-icall-experimental-normalize-integers. Normalize integers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. This option is currently experimental. .. option:: -fstrict-vtable-pointers. Enable optimizations based on the stric",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:79257,simpl,simple,79257,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['simpl'],['simple']
Usability,"a coroutine function, which; // would return a coroutine type 'Task'. In practice, we typically say ""`Coros` contains 3 coroutines"" in the above; example, though this is not strictly correct. More technically, this should; say ""`Coros` contains 3 coroutine instances"" or ""Coros contains 3 coroutine; objects."". In this document, we follow the common practice of using `coroutine` to refer; to an individual `coroutine instance`, since the terms `coroutine instance` and; `coroutine object` aren't sufficiently defined in this case. coroutine frame; ---------------. The C++ Standard uses `coroutine state` to describe the allocated storage. In; the compiler, we use `coroutine frame` to describe the generated data structure; that contains the necessary information. The structure of coroutine frames; =================================. The structure of coroutine frames is defined as:. .. code-block:: c++. struct {; void (*__r)(); // function pointer to the `resume` function; void (*__d)(); // function pointer to the `destroy` function; promise_type; // the corresponding `promise_type`; ... // Any other needed information; }. In the debugger, the function's name is obtainable from the address of the; function. And the name of `resume` function is equal to the name of the; coroutine function. So the name of the coroutine is obtainable once the; address of the coroutine is known. Print promise_type; ==================. Every coroutine has a `promise_type`, which defines the behavior; for the corresponding coroutine. In other words, if two coroutines have the; same `promise_type`, they should behave in the same way.; To print a `promise_type` in a debugger when stopped at a breakpoint inside a; coroutine, printing the `promise_type` can be done by:. .. parsed-literal::. print __promise. It is also possible to print the `promise_type` of a coroutine from the address; of the coroutine frame. For example, if the address of a coroutine frame is; 0x416eb0, and the type of the `promise_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:2869,resume,resume,2869,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['resume'],['resume']
Usability,"a is owned by the enclosing object. No inlining.; ------------. Thread safety analysis is strictly intra-procedural, just like ordinary type; checking. It relies only on the declared attributes of a function, and will; not attempt to inline any method calls. As a result, code such as the; following will not work:. .. code-block:: c++. template<class T>; class AutoCleanup {; T* object;; void (T::*mp)();. public:; AutoCleanup(T* obj, void (T::*imp)()) : object(obj), mp(imp) { }; ~AutoCleanup() { (object->*mp)(); }; };. Mutex mu;; void foo() {; mu.Lock();; AutoCleanup<Mutex>(&mu, &Mutex::Unlock);; // ...; } // Warning, mu is not unlocked. In this case, the destructor of ``Autocleanup`` calls ``mu.Unlock()``, so; the warning is bogus. However,; thread safety analysis cannot see the unlock, because it does not attempt to; inline the destructor. Moreover, there is no way to annotate the destructor,; because the destructor is calling a function that is not statically known.; This pattern is simply not supported. No alias analysis.; ------------------. The analysis currently does not track pointer aliases. Thus, there can be; false positives if two pointers both point to the same mutex. .. code-block:: c++. class MutexUnlocker {; Mutex* mu;. public:; MutexUnlocker(Mutex* m) RELEASE(m) : mu(m) { mu->Unlock(); }; ~MutexUnlocker() ACQUIRE(mu) { mu->Lock(); }; };. Mutex mutex;; void test() REQUIRES(mutex) {; {; MutexUnlocker munl(&mutex); // unlocks mutex; doSomeIO();; } // Warning: locks munl.mu; }. The MutexUnlocker class is intended to be the dual of the MutexLocker class,; defined in :ref:`mutexheader`. However, it doesn't work because the analysis; doesn't know that munl.mu == mutex. The SCOPED_CAPABILITY attribute handles; aliasing for MutexLocker, but does so only for that particular pattern. ACQUIRED_BEFORE(...) and ACQUIRED_AFTER(...) are currently unimplemented.; -------------------------------------------------------------------------. To be fixed in a future update. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:23699,simpl,simply,23699,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['simpl'],['simply']
Usability,"a local notebook server customised with all the ROOT features. New tutorials and code examples have been provided. The simplest example showing the integration of ROOT with the notebook technology can be found [here](https://root.cern.ch/notebooks/HowTos/HowTo_ROOT-Notebooks.html) and many more snippets [here](https://root.cern.ch/code-examples#notebooks). Support for capturing large outputs (stderr/stdout) coming from C++ libraries has been added. ## JavaScript ROOT. - support registered in THttpServer commands with arguments.; - provide workaround for websites using require.js and older jquery-ui; - support custom requests to remote objects, demonstrated in httptextlog.C tutorial; - rewrite draw.htm (page for individual object drawing) to support all custom features as main gui does; - See also the [JSRoot 3.9 examples page](https://root.cern.ch/js/3.9/) and the [JSRoot 3.9 release notes](https://github.com/linev/jsroot/releases/tag/3.9). ## Class Reference Guide. The ROOT [reference guide](https://root.cern.ch/doc/master/index.html) is moving; to the Doxygen system. Doxygen is the de-facto standard for code documentation. It offers; many nice features we are now exploring and trying to get the best of them. Having; [MathJax rendered math formula](https://root.cern.ch/doc/master/classTSpectrum2.html#a482a7f144b9cc1b0405d0ac0d8cc9bbb); is one of them. The documentation can be structured in a more logical way; [using groups](https://root.cern.ch/doc/master/modules.html). Still there is a lot; to do but big progresses have been done. We developed also a Doxygen filter allowing; to execute macros given as examples in the documentation and show the; [resulting picture directly in the documentation](https://root.cern.ch/doc/master/classTHistPainter.html#HP16). ## Tutorials. [The tutorials](https://root.cern.ch/doc/master/group__Tutorials.html) in; `$ROOTSYS/tutorials` are also presented on the web thanks to Doxygen. They; are now part of the reference guide allowing nice",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:23577,guid,guide,23577,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['guid'],['guide']
Usability,"a multi-line command:. ``` {.cpp}; root [] {; root [] ? TLine l;; root [] ? for (int i = 0; i < 5; i++) {; root [] ? l.SetX1(i);; root [] ? l.SetY1(i+1);; root [] ? l.Print();; root [] ? }; root [] ? }; TLine X1=0.000000 Y1=1.000000 X2=0.000000 Y2=0.000000; TLine X1=1.000000 Y1=2.000000 X2=0.000000 Y2=0.000000; TLine X1=2.000000 Y1=3.000000 X2=0.000000 Y2=0.000000; TLine X1=3.000000 Y1=4.000000 X2=0.000000 Y2=0.000000; TLine X1=4.000000 Y1=5.000000 X2=0.000000 Y2=0.000000; root [] .q; ```. Here we note:. - A multi-line command starts with a { and ends with a }.; - Inside continuation, every line has to be correctly terminated with a ; (like in ""real''; C++).; - All objects are created in *global* scope.; - There is no way to back up; you are better off writing a script.; - Use `.q` to exit root. ## Feeding Sources Files To ROOT: C++ Scripts. ROOT script files (often called ""Macros"") contain pure C++ code. They can contain a simple; sequence of statements like in the multi command line example given; above, but also arbitrarily complex class and function definitions. The most frequent interaction with the ROOT prompt uses `.x` to ""run"" a file:. ```; root [] .x myScript.C; ```. This loads myScript.C into the interpreter and calls the function `myScript()`.; You can pass arguments using `.x myScript.C(12, ""A String"")`. Alternatively you can load the script and then run a function explicitly:. ```; root [] .L myScript.C; root [] myScript(); ```. The above is equivalent to `.x myScript.C`. In a named script, the objects created on the stack are deleted when; the function exits. In a common scenario you; create a histogram in a named script on the stack. You draw the; histogram, but when the function exits the canvas is empty and the; histogram has disappeared. To avoid the histogram from disappearing you can; create it on the heap (by using new). This will leave the histogram; object intact, but the pointer in the named script scope will be; ""gone"". Since histograms (and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:7619,simpl,simple,7619,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['simpl'],['simple']
Usability,"a protocol). .. admonition:: Rationale. There are a fair number of existing methods with ``init``-like selectors; which nonetheless don't follow the ``init`` conventions. Typically these; are either accidental naming collisions or helper methods called during; initialization. Because of the peculiar retain/release behavior of; ``init`` methods, it's very important not to treat these methods as; ``init`` methods if they aren't meant to be. It was felt that implicitly; defining these methods out of the family based on the exact relationship; between the return type and the declaring class would be much too subtle; and fragile. Therefore we identify a small number of legitimate-seeming; return types and call everything else an error. This serves the secondary; purpose of encouraging programmers not to accidentally give methods names; in the ``init`` family. Note that a method with an ``init``-family selector which returns a; non-Objective-C type (e.g. ``void``) is perfectly well-formed; it simply; isn't in the ``init`` family. A program is ill-formed if a method's declarations, implementations, and; overrides do not all have the same method family. .. _arc.family.attribute:. Explicit method family control; ------------------------------. A method may be annotated with the ``objc_method_family`` attribute to; precisely control which method family it belongs to. If a method in an; ``@implementation`` does not have this attribute, but there is a method; declared in the corresponding ``@interface`` that does, then the attribute is; copied to the declaration in the ``@implementation``. The attribute is; available outside of ARC, and may be tested for with the preprocessor query; ``__has_attribute(objc_method_family)``. The attribute is spelled; ``__attribute__((objc_method_family(`` *family* ``)))``. If *family* is; ``none``, the method has no family, even if it would otherwise be considered to; have one based on its selector and type. Otherwise, *family* must be one of; ``a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:69858,simpl,simply,69858,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['simpl'],['simply']
Usability,"a reference to the underlying type (same; example: Instruction&) instead of a pointer to the underlying object. This; makes it much easier to write nested loops that iterator over things, changing; this:. for (Function::iterator BI = Func->begin(); BI != Func->end(); ++BI); for (BasicBlock::iterator II = (*BI)->begin(); II != (*BI)->end(); ++II); (*II)->dump();. into:. for (Function::iterator BI = Func->begin(); BI != Func->end(); ++BI); for (BasicBlock::iterator II = BI->begin(); II != BI->end(); ++II); II->dump();. which is much more natural and what users expect. * Simplification of #include's: Before, it was necessary for a .cpp file to; include every .h file that it used. Now things are batched a little bit more; to make it easier to use. Specifically, the include graph now includes these; edges:; Module.h -> Function.h, GlobalVariable.h; Function.h -> BasicBlock.h, Argument.h; BasicBlock.h -> Instruction.h. Which means that #including Function.h is usually sufficient for getting the; lower level #includes. * Printing out a Value* has now changed: Printing a Value* will soon print out; the address of the value instead of the contents of the Value. To print out; the contents, you must convert it to a reference with (for example); 'cout << *I' instead of 'cout << I;'. This conversion is not yet complete,; but will be eventually. In the mean time, both forms print out the contents. * References are used much more throughout the code base. In general, if a; pointer is known to never be null, it is passed in as a reference instead of a; pointer. For example, the instruction visitor class uses references instead; of pointers, and that Pass subclasses now all receive references to Values; instead of pointers, because they may never be null. * The Function class now has helper functions for accessing the Arguments list.; Instead of having to go through getArgumentList for simple things like; iterator over the arguments, now the a*() methods can be used to access them. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-06-25-MegaPatchInfo.txt:3218,simpl,simple,3218,interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-06-25-MegaPatchInfo.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2002-06-25-MegaPatchInfo.txt,1,['simpl'],['simple']
Usability,"able through the ``getType()`` method. In addition, all LLVM; values can be named. The ""name"" of the ``Value`` is a symbolic string printed; in the LLVM code:. .. code-block:: llvm. %foo = add i32 1, 2. .. _nameWarning:. The name of this instruction is ""foo"". **NOTE** that the name of any value may; be missing (an empty string), so names should **ONLY** be used for debugging; (making the source code easier to read, debugging printouts), they should not be; used to keep track of values or map between them. For this purpose, use a; ``std::map`` of pointers to the ``Value`` itself instead. One important aspect of LLVM is that there is no distinction between an SSA; variable and the operation that produces it. Because of this, any reference to; the value produced by an instruction (or the value available as an incoming; argument, for example) is represented as a direct pointer to the instance of the; class that represents this value. Although this may take some getting used to,; it simplifies the representation and makes it easier to manipulate. .. _m_Value:. Important Public Members of the ``Value`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * | ``Value::use_iterator`` - Typedef for iterator over the use-list; | ``Value::const_use_iterator`` - Typedef for const_iterator over the; use-list; | ``unsigned use_size()`` - Returns the number of users of the value.; | ``bool use_empty()`` - Returns true if there are no users.; | ``use_iterator use_begin()`` - Get an iterator to the start of the; use-list.; | ``use_iterator use_end()`` - Get an iterator to the end of the use-list.; | ``User *use_back()`` - Returns the last element in the list. These methods are the interface to access the def-use information in LLVM.; As with all other iterators in LLVM, the naming conventions follow the; conventions defined by the STL_. * ``Type *getType() const``; This method returns the Type of the Value. * | ``bool hasName() const``; | ``std::string getName() const``; | ``void",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:143064,simpl,simplifies,143064,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simplifies']
Usability,"above,; except that the bisection script does not need to include the; `git submodule update` step. The same example, finding which commit introduces a regression where clang-3.9; crashes but not clang-3.8 passes, will look like::. git bisect start releases/3.9.x releases/3.8.x; git bisect run ./bisect_script.sh. With the `bisect_script.sh` script being::. #!/bin/sh; cd $BUILD_DIR. ninja clang || exit 125 # an exit code of 125 asks ""git bisect""; # to ""skip"" the current commit. ./bin/clang some_crash_test.cpp. Also, since the monorepo handles commits update across multiple projects, you're; less like to encounter a build failure where a commit change an API in LLVM and; another later one ""fixes"" the build in clang. Moving Local Branches to the Monorepo; =====================================. Suppose you have been developing against the existing LLVM git; mirrors. You have one or more git branches that you want to migrate; to the ""final monorepo"". The simplest way to migrate such branches is with the; ``migrate-downstream-fork.py`` tool at; https://github.com/jyknight/llvm-git-migration. Basic migration; ---------------. Basic instructions for ``migrate-downstream-fork.py`` are in the; Python script and are expanded on below to a more general recipe::. # Make a repository which will become your final local mirror of the; # monorepo.; mkdir my-monorepo; git -C my-monorepo init. # Add a remote to the monorepo.; git -C my-monorepo remote add upstream/monorepo https://github.com/llvm/llvm-project.git. # Add remotes for each git mirror you use, from upstream as well as; # your local mirror. All projects are listed here but you need only; # import those for which you have local branches.; my_projects=( clang; clang-tools-extra; compiler-rt; debuginfo-tests; libcxx; libcxxabi; libunwind; lld; lldb; llvm; openmp; polly ); for p in ${my_projects[@]}; do; git -C my-monorepo remote add upstream/split/${p} https://github.com/llvm-mirror/${p}.git; git -C my-monorepo remote add loc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:20266,simpl,simplest,20266,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['simpl'],['simplest']
Usability,"absolutely; required; for example for certain code that cannot tolerate any instrumentation; and resulting side-effects. This attribute overrides ``no_sanitize(""memory"")``. Ignorelist; ----------. MemorySanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to relax MemorySanitizer; checks for certain source files and functions. All ""Use of uninitialized value""; warnings will be suppressed and all values loaded from memory will be; considered fully initialized. Report symbolization; ====================. MemorySanitizer uses an external symbolizer to print files and line numbers in; reports. Make sure that ``llvm-symbolizer`` binary is in ``PATH``,; or set environment variable ``MSAN_SYMBOLIZER_PATH`` to point to it. .. _msan-origins:. Origin Tracking; ===============. MemorySanitizer can track origins of uninitialized values, similar to; Valgrind's --track-origins option. This feature is enabled by; ``-fsanitize-memory-track-origins=2`` (or simply; ``-fsanitize-memory-track-origins``) Clang option. With the code from; the example above,. .. code-block:: console. % cat umr2.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; volatile int b = a[argc];; if (b); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fsanitize-memory-track-origins=2 -fno-omit-frame-pointer -g -O2 umr2.cc; % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f7893912f0b in main umr2.cc:7; #1 0x7f789249b76c in __libc_start_main libc-start.c:226. Uninitialized value was stored to memory at; #0 0x7f78938b5c25 in __msan_chain_origin msan.cc:484; #1 0x7f7893912ecd in main umr2.cc:6. Uninitialized value was created by a heap allocation; #0 0x7f7893901cbd in operator new[](unsigned long) msan_new_delete.cc:44; #1 0x7f7893912e06 in main umr2.cc:4. By default, MemorySanitizer collects both allocation points and all; intermediate stores the uninitialized value went through. Origin; track",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:3995,simpl,simply,3995,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst,1,['simpl'],['simply']
Usability,"ace; that allows users to input these options without ever invoking the; action. Selection Requirements; ^^^^^^^^^^^^^^^^^^^^^^. The refactoring rule requirements that require some form of source selection; are listed below:. - ``SourceRangeSelectionRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range will contain the cursor's location in; that case). .. FIXME: Future selection requirements. .. FIXME: Maybe mention custom selection requirements?. Other Requirements; ^^^^^^^^^^^^^^^^^^. There are several other requirements types that can be used when creating; a refactoring rule:. - The ``RefactoringOptionsRequirement`` requirement is an abstract class that; should be subclassed by requirements working with options. The more; concrete ``OptionRequirement`` requirement is a simple implementation of the; aforementioned class that returns the value of the specified option when; it's evaluated. The next section talks more about refactoring options and; how they can be used when creating a rule. Refactoring Options; -------------------. Refactoring options are values that affect a refactoring operation and are; specified either using command-line options or another client-specific; mechanism. Options should be created using a class that derives either from; the ``OptionalRequiredOption`` or ``RequiredRefactoringOption``. The following; example shows how one can created a required string option that corresponds to; the ``-new-name`` command-line option in clang-refactor:. .. code-block:: c++. class NewNameOption : public RequiredRefactoringOption<std::string> {; public:; StringRef getName() const override { return ""new-name""; }; StringRef getDescription() const override {; return ""The new name to change the symbol to"";; }; };. The option that's shown in the example above can then be used t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:9541,simpl,simple,9541,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['simpl'],['simple']
Usability,"ack(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; ```. The parameters to the template instantiation can either be an actual; type or value (as is used here, ""int""), or a string representation of; the parameters (e.g. ""'double'""), or a mixture of both (e.g. ""'TCanvas,; 0'"" or ""'double', 0"" ). The ""std::vector\<int\>"" class is one of the; classes builtin by default into the Cling extension dlls. You will get a; non-functional class (instances of which can still be passed around to; C++) if the corresponding dictionary doesn't exist. #### Access to ROOT Globals. Most globals and global functions can be imported directly from the; ROOT.py module, but some common ones (most notably **`gMinuit`**,; although that variable now exists at startup from release 5.08 onward); do not exist yet at program startup, as they exist in modules that are; loaded later (e.g. through the auto-loading mechanism). An example; session should make this clear:. ``` {.cpp}; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; ```. It is also possible to create globals interactively, either by executing; a Cling macro, or by a call to `gROOT.ProcessLine()`. These globals are; made available in the same way: either use them directly after creation; in 'from ROOT import \*' more, or get them from the ROOT namespace after; an 'import ROOT'. As of 5.08, the behaviour of ROOT globals is the same as python globals,; which is sometimes counterintuitive: since the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:13181,clear,clear,13181,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['clear'],['clear']
Usability,"ackSafetyAnalysis; SupportLibrary; TableGen/index; TableGenFundamentals; Vectorizers; WritingAnLLVMPass; WritingAnLLVMNewPMPass; WritingAnLLVMBackend; yaml2obj. Clang; -----. :doc:`HowToBuildOnARM`; Notes on building and testing LLVM/Clang on ARM. :doc:`HowToBuildWithPGO`; Notes on building LLVM/Clang with PGO. :doc:`HowToCrossCompileLLVM`; Notes on cross-building and testing LLVM/Clang. `How to build the C, C++, ObjC, and ObjC++ front end`__; Instructions for building the clang front-end from source. .. __: https://clang.llvm.org/get_started.html. :doc:`CoverageMappingFormat`; This describes the format and encoding used for LLVM’s code coverage mapping. :doc:`CFIVerify`; A description of the verification tool for Control Flow Integrity. LLVM Builds and Distributions; -----------------------------. :doc:`BuildingADistribution`; A best-practices guide for using LLVM's CMake build system to package and; distribute LLVM-based tools. :doc:`CMake`; An addendum to the main Getting Started guide for those using the `CMake; build system <http://www.cmake.org>`_. :doc:`Docker`; A reference for using Dockerfiles provided with LLVM. :doc:`Support Library <SupportLibrary>`; This document describes the LLVM Support Library (``lib/Support``) and; how to keep LLVM source code portable. :doc:`AdvancedBuilds`; This document describes more advanced build configurations. Optimizations; -------------. :doc:`WritingAnLLVMPass`; Information on how to write LLVM transformations and analyses. :doc:`WritingAnLLVMNewPMPass`; Information on how to write LLVM transformations under the new pass; manager. :doc:`Passes`; A list of optimizations and analyses implemented in LLVM. :doc:`StackSafetyAnalysis`; This document describes the design of the stack safety analysis of local; variables. :doc:`MergeFunctions`; Describes functions merging optimization. :doc:`AliasAnalysis`; Information on how to write a new alias analysis implementation or how to; use existing analyses. :doc:`MemorySSA`; Informat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst:2223,guid,guide,2223,interpreter/llvm-project/llvm/docs/UserGuides.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst,1,['guid'],['guide']
Usability,"act with LLVM IR. Design of MemorySSA; ===================. ``MemorySSA`` is an analysis that can be built for any arbitrary function. When; it's built, it does a pass over the function's IR in order to build up its; mapping of ``MemoryAccess``\ es. You can then query ``MemorySSA`` for things; like the dominance relation between ``MemoryAccess``\ es, and get the; ``MemoryAccess`` for any given ``Instruction`` . When ``MemorySSA`` is done building, it also hands you a ``MemorySSAWalker``; that you can use (see below). The walker; ----------. A structure that helps ``MemorySSA`` do its job is the ``MemorySSAWalker``, or; the walker, for short. The goal of the walker is to provide answers to clobber; queries beyond what's represented directly by ``MemoryAccess``\ es. For example,; given:. .. code-block:: llvm. define void @foo() {; %a = alloca i8; %b = alloca i8. ; 1 = MemoryDef(liveOnEntry); store i8 0, ptr %a; ; 2 = MemoryDef(1); store i8 0, ptr %b; }. The store to ``%a`` is clearly not a clobber for the store to ``%b``. It would; be the walker's goal to figure this out, and return ``liveOnEntry`` when queried; for the clobber of ``MemoryAccess`` ``2``. By default, ``MemorySSA`` provides a walker that can optimize ``MemoryDef``\ s; and ``MemoryUse``\ s by consulting whatever alias analysis stack you happen to; be using. Walkers were built to be flexible, though, so it's entirely reasonable; (and expected) to create more specialized walkers (e.g. one that specifically; queries ``GlobalsAA``, one that always stops at ``MemoryPhi`` nodes, etc). Default walker APIs; ^^^^^^^^^^^^^^^^^^^. There are two main APIs used to retrieve the clobbering access using the walker:. - ``MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA);`` return the; clobbering memory access for ``MA``, caching all intermediate results; computed along the way as part of each access queried. - ``MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA, const MemoryLocation &Loc);``; returns the a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:9204,clear,clearly,9204,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['clear'],['clearly']
Usability,"activated thanks to the options `PFC`; (Palette Fill Color), `PLC` (Palette Line Color) and `AMC` (Palette Marker Color).; When one of these options is given to `TH1::Draw` the histogram get its color; from the current color palette defined by `gStyle->SetPalette(…)`. The color; is determined according to the number of objects having palette coloring in; the current pad.; - The line width and line style can be change on 2d histograms painted with; option `ARR`.; - When the angle of a TGraphPolar was not in radian, the error bars were misplaced.; The problem was reported [here](https://sft.its.cern.ch/jira/browse/ROOT-8476).; - In `TASimage::DrawLineInternal` the case of a line with 0 pixel along X and 0; pixel along Y was not treated properly. An horizontal line was drawn instead.; - In `TGraphPainter::PaintGrapHist`: Decouple the `P` option (histogram drawn with; a simple polymarker) from the `L` option (Histogram drawn as a simple polyline). This; improved (in some cases some extra markers were drawn) and simplified the code.; - Candle plot improvements:; * Rearragement of TCandle-code - split into calculate and paint; * Implementation for a ""raw-data candle"" inside TCandle - to be used from TTreeViewer in the future; * Implementation of 1D histograms along each candle (left, right and violin) - to be used for violin-charts; * Implementation of a zero indicator line for TCandle - to be used for violin-charts; * Reimplementation if THistPainter draw option VIOLIN; * Implementations of presets and individual options for VIOLIN-charts; * Implementation of VIOLIN-charts in THStack - can be combined with CANDLE; * Update of the docs (THistPainter and THStack); * New tutorials; - In various places in TGraph the underlying histogram was deleted when the graph; range should be recomputed. This has the side effect that some graph parameters; (like the axis titles) were also deleted. This now fixed. It was reported; [here](https://sft.its.cern.ch/jira/browse/ROOT-8092).; - ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:10191,simpl,simplified,10191,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['simpl'],['simplified']
Usability,"acuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ~~~. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ~~~{.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ~~~. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the geometry. ~~~{.cpp}; root[] gGeoManager->SetTopVolume(top);; ~~~. This should be enough, but it is not since always after defining some; geometry hierarchy, TGeo needs to build some optimization; structures and perform some checks. Note the messages posted after the; statement is executed. We will describe the corresponding operations; later. ~~~{.cpp}; root[] gGeoManager->CloseGeometry();; ~~~. Now we are really done with geometry building stage, but we would like; to see our simple world:. ~~~{.cpp}; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; ~~~. \anchor GP00b; ### Example 2: A Geometrical Hierarchy Look and Feel. Before going further, let us get a look and feel of interacting with the; modeller. For this, we will use one of the examples illustrating the; geometry package. To get an idea on the geometry structure created in; this example, just look at rootgeom.C. You will; notice that this is a bit more complex that just creating the ""world""; since several other volumes are created and put together in a hierarchy.; The purpose here is just to learn how to interact with a geometry that; is already built, but just few hints on the building steps in this; example might be useful. The geometry here represents the word %ROOT that; is replicated in some symmetric manner. You might for instance ask some; questions after having a first look:. **Q:** ""OK",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:6844,simpl,simple,6844,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"ad as an enumeration. For example, say some configuration option; started as an enumeration. Then it got more complex so it is now a; mapping. But it is necessary to support the old configuration files.; In that case, add a function ``enumInput`` like for; ``ScalarEnumerationTraits::enumeration``. Examples:. .. code-block:: c++. struct FooBarEnum {; int Foo;; int Bar;; bool operator==(const FooBarEnum &R) const {; return Foo == R.Foo && Bar == R.Bar;; }; };. template <> struct MappingTraits<FooBarEnum> {; static void enumInput(IO &io, FooBarEnum &Val) {; io.enumCase(Val, ""OnlyFoo"", FooBarEnum({1, 0}));; io.enumCase(Val, ""OnlyBar"", FooBarEnum({0, 1}));; }; static void mapping(IO &io, FooBarEnum &Val) {; io.mapOptional(""Foo"", Val.Foo);; io.mapOptional(""Bar"", Val.Bar);; }; };. No Normalization; ----------------. The ``mapping()`` method is responsible, if needed, for normalizing and; denormalizing. In a simple case where the native data structure requires no; normalization, the mapping method just uses mapOptional() or mapRequired() to; bind the struct's fields to YAML key names. For example:. .. code-block:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. template <>; struct MappingTraits<Person> {; static void mapping(IO &io, Person &info) {; io.mapRequired(""name"", info.name);; io.mapOptional(""hat-size"", info.hatSize);; }; };. Normalization; ----------------. When [de]normalization is required, the mapping() method needs a way to access; normalized values as fields. To help with this, there is; a template MappingNormalization<> which you can then use to automatically; do the normalization and denormalization. The template is used to create; a local variable in your mapping() method which contains the normalized keys. Suppose you have native data type; Polar which specifies a position in polar coordinates (distance, angle):. .. code-block:: c++. struct Polar {; float distance;; float angle;; };. but you've decided the normalized YAML for should be in x,y ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:16633,simpl,simple,16633,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['simpl'],['simple']
Usability,"ad. ### The TGraph::Fit Method. The signature for fitting a TGraph is exactly the same as for the **`TH1`**. Only some options apply only for fitting histograms,; these are the options ""`L`"", ""`WL`"" and ""`I`"".; These options apply instead only for `TGraph::Fit`, the rest of options (appart from ""`L`"", ""`WL`"" and ""`I`"" are the same). * `TGraph` specific *options*. 	- ""`EX0`"" When fitting a `TGraphErrors` or a `TgraphAsymErrors` the errors on the coordinates are not used in the fit. 	- ""`ROB`"" in case of linear fitting use the Robust fitting. Compute the LTS regression coefficients (robust (resistant) regression),; using the default fraction of good points.; 	- ""`ROB=0.x`"" as above, but compute the LTS regression coefficients, using 0.x as a fraction of good points. ## The `TF1` function class. Here we will show how to create the **`TF1`** class that is used for fitting histograms and graphs. ### Fit with a Predefined Function. To fit a histogram with a predefined function, simply pass the name of; the function in the first parameter of `TH1::Fit`. For example,; this line fits histogram object `hist` with a Gaussian. ``` {.cpp}; root[] hist.Fit(""gaus"");; ```. The initial parameter values (and eventual limits) for pre-defined functions are set; automatically. For overriding the default limits values use the fit option `B`. The list of pre-defined functions that can be used with the `Fit` method is the following:. - ""`gaus`"" Gaussian function with 3 parameters:; `f(x) = p0*exp(-0.5*((x-p1)/p2)^2)`. - ""`expo`""An Exponential with 2 parameters: `f(x) = exp(p0+p1*x)`. - ""`pol`*`N`*"" A polynomial of degree *N*, where N is a number between 0 and 9:; `f(x) = p0 + p1*x + p2*x2 +...`. - ""`chebyshev`*`N`*"" A Chebyshev polynomial of degree *N*, where N is a number between 0 and 9:; `f(x) = p0 + p1*x + p2*(2*x2-1) +...`. - ""`landau`"" Landau function with mean and sigma. This function has; been adapted from the `CERNLIB` routine `G110 denlan` (see `TMath::Landau`). - ""`gausn`"" Normal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:4437,simpl,simply,4437,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['simpl'],['simply']
Usability,"adata i32 %c, ...); %d = trunc i32 %c to i16; ret i16 %d; }. Now, here's what happens after the unnecessary truncation instruction ``%d`` is; replaced with a simplified instruction:. .. code-block:: llvm. define i16 @foo(i16 %a) {; call void @llvm.dbg.value(metadata i32 undef, ...); %simplified = and i16 %a, 15; ret i16 %simplified; }. Note that after deleting ``%d``, all uses of its operand ``%c`` become; trivially dead. The debug use which used to point to ``%c`` is now ``undef``,; and debug info is needlessly lost. To solve this problem, do:. .. code-block:: cpp. llvm::replaceAllDbgUsesWith(%c, theSimplifiedAndInstruction, ...). This results in better debug info because the debug use of ``%c`` is preserved:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %simplified = and i16 %a, 15; call void @llvm.dbg.value(metadata i16 %simplified, ...); ret i16 %simplified; }. You may have noticed that ``%simplified`` is narrower than ``%c``: this is not; a problem, because ``llvm::replaceAllDbgUsesWith`` takes care of inserting the; necessary conversion operations into the DIExpressions of updated debug uses. Deleting a MIR-level MachineInstr; ---------------------------------. TODO. Rules for updating ``DIAssignID`` Attachments; =============================================. ``DIAssignID`` metadata attachments are used by Assignment Tracking, which is; currently an experimental debug mode. See :doc:`AssignmentTracking` for how to update them and for more info on; Assignment Tracking. How to automatically convert tests into debug info tests; ========================================================. .. _IRDebugify:. Mutation testing for IR-level transformations; ---------------------------------------------. An IR test case for a transformation can, in many cases, be automatically; mutated to test debug info handling within that transformation. This is a; simple way to test for proper debug info handling. The ``debugify`` utility pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:8561,simpl,simplified,8561,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['simpl'],['simplified']
Usability,"add an explicit prefix for Clang to look in for a GCC toolchain with; the ``--gcc-toolchain=/opt/my/gcc/prefix`` flag, passing it to both compile and; link commands when using your just-built-Clang to bootstrap. .. _Getting Started with LLVM:. Getting Started with LLVM; =========================. The remainder of this guide is meant to get you up and running with LLVM and to; give you some basic information about the LLVM environment. The later sections of this guide describe the `general layout`_ of the LLVM; source tree, a `simple example`_ using the LLVM tool chain, and `links`_ to find; more information about LLVM or to get help via e-mail. Terminology and Notation; ------------------------. Throughout this manual, the following names are used to denote paths specific to; the local system and working environment. *These are not environment variables; you need to set but just strings used in the rest of this document below*. In; any of the examples below, simply replace each of these names with the; appropriate pathname on your local system. All these paths are absolute:. ``SRC_ROOT``. This is the top level directory of the LLVM source tree. ``OBJ_ROOT``. This is the top level directory of the LLVM object tree (i.e. the tree where; object files and compiled programs will be placed. It can be the same as; SRC_ROOT). Unpacking the LLVM Archives; ---------------------------. If you have the LLVM distribution, you will need to unpack it before you can; begin to compile it. LLVM is distributed as a number of different; subprojects. Each one has its own download which is a TAR archive that is; compressed with the gzip program. The files are as follows, with *x.y* marking the version number:. ``llvm-x.y.tar.gz``. Source release for the LLVM libraries and tools. ``cfe-x.y.tar.gz``. Source release for the Clang frontend. .. _checkout:. Checkout LLVM from Git; ----------------------. You can also checkout the source code for LLVM from Git. .. note::. Passing ``--config core",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:20871,simpl,simply,20871,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['simpl'],['simply']
Usability,"add i32 %w, %w ; undef; %z = add i32 %x, %x ; even number because all uses of %x observe; ; the same value; %x2 = freeze i32 %w; %cmp = icmp eq i32 %x, %x2 ; can be true or false. ; example with vectors; %v = <2 x i32> <i32 undef, i32 poison>; %a = extractelement <2 x i32> %v, i32 0 ; undef; %b = extractelement <2 x i32> %v, i32 1 ; poison; %add = add i32 %a, %a ; undef. %v.fr = freeze <2 x i32> %v ; element-wise freeze; %d = extractelement <2 x i32> %v.fr, i32 0 ; not undef; %add.f = add i32 %d, %d ; even number. ; branching on frozen value; %poison = add nsw i1 %k, undef ; poison; %c = freeze i1 %poison; br i1 %c, label %foo, label %bar ; non-deterministic branch to %foo or %bar. .. _i_call:. '``call``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = [tail | musttail | notail ] call [fast-math flags] [cconv] [ret attrs] [addrspace(<num>)]; <ty>|<fnty> <fnptrval>(<function args>) [fn attrs] [ operand bundles ]. Overview:; """""""""""""""""". The '``call``' instruction represents a simple function call. Arguments:; """""""""""""""""""". This instruction requires several arguments:. #. The optional ``tail`` and ``musttail`` markers indicate that the optimizers; should perform tail call optimization. The ``tail`` marker is a hint that; `can be ignored <CodeGenerator.html#tail-call-optimization>`_. The; ``musttail`` marker means that the call must be tail call optimized in order; for the program to be correct. This is true even in the presence of; attributes like ""disable-tail-calls"". The ``musttail`` marker provides these; guarantees:. #. The call will not cause unbounded stack growth if it is part of a; recursive cycle in the call graph.; #. Arguments with the :ref:`inalloca <attr_inalloca>` or; :ref:`preallocated <attr_preallocated>` attribute are forwarded in place.; #. If the musttail call appears in a function with the ``""thunk""`` attribute; and the caller and callee both have varargs, then any unprototyped; arguments in register or memory are forwarded to the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:472458,simpl,simple,472458,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability,"add two lines to transfer the newly defined function to; the JIT and open a new module. In HandleExtern, we just need to add one line to; add the prototype to FunctionProtos. .. warning::; Duplication of symbols in separate modules is not allowed since LLVM-9. That means you can not redefine function in your Kaleidoscope as its shown below. Just skip this part. The reason is that the newer OrcV2 JIT APIs are trying to stay very close to the static and dynamic linker rules, including rejecting duplicate symbols. Requiring symbol names to be unique allows us to support concurrent compilation for symbols using the (unique) symbol names as keys for tracking. With these changes made, let's try our REPL again (I removed the dump of the; anonymous functions this time, you should get the idea by now :) :. ::. ready> def foo(x) x + 1;; ready> foo(2);; Evaluated to 3.000000. ready> def foo(x) x + 2;; ready> foo(2);; Evaluated to 4.000000. It works!. Even with this simple code, we get some surprisingly powerful capabilities -; check this out:. ::. ready> extern sin(x);; Read extern:; declare double @sin(double). ready> extern cos(x);; Read extern:; declare double @cos(double). ready> sin(1.0);; Read top-level expression:; define double @2() {; entry:; ret double 0x3FEAED548F090CEE; }. Evaluated to 0.841471. ready> def foo(x) sin(x)*sin(x) + cos(x)*cos(x);; Read function definition:; define double @foo(double %x) {; entry:; %calltmp = call double @sin(double %x); %multmp = fmul double %calltmp, %calltmp; %calltmp2 = call double @cos(double %x); %multmp4 = fmul double %calltmp2, %calltmp2; %addtmp = fadd double %multmp, %multmp4; ret double %addtmp; }. ready> foo(4.0);; Read top-level expression:; define double @3() {; entry:; %calltmp = call double @foo(double 4.000000e+00); ret double %calltmp; }. Evaluated to 1.000000. Whoa, how does the JIT know about sin and cos? The answer is surprisingly; simple: The KaleidoscopeJIT has a straightforward symbol resolution rule that; it use",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:21695,simpl,simple,21695,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['simpl'],['simple']
Usability,"address of outgoing stack arguments. An ``inalloca`` argument must; be a pointer to stack memory produced by an ``alloca`` instruction.; The alloca, or argument allocation, must also be tagged with the; inalloca keyword. Only the last argument may have the ``inalloca``; attribute, and that argument is guaranteed to be passed in memory. An argument allocation may be used by a call at most once because; the call may deallocate it. The ``inalloca`` attribute cannot be; used in conjunction with other attributes that affect argument; storage, like ``inreg``, ``nest``, ``sret``, or ``byval``. The; ``inalloca`` attribute also disables LLVM's implicit lowering of; large aggregate return values, which means that frontend authors; must lower them with ``sret`` pointers. When the call site is reached, the argument allocation must have; been the most recent stack allocation that is still live, or the; behavior is undefined. It is possible to allocate additional stack; space after an argument allocation and before its call site, but it; must be cleared off with :ref:`llvm.stackrestore; <int_stackrestore>`. The inalloca attribute requires a type argument, which must be the; same as the pointee type of the argument. See :doc:`InAlloca` for more information on how to use this; attribute. ``sret(<ty>)``; This indicates that the pointer parameter specifies the address of a; structure that is the return value of the function in the source; program. This pointer must be guaranteed by the caller to be valid:; loads and stores to the structure may be assumed by the callee not; to trap and to be properly aligned. This is not a valid attribute; for return values. The sret type argument specifies the in memory type, which must be; the same as the pointee type of the argument. .. _attr_elementtype:. ``elementtype(<ty>)``. The ``elementtype`` argument attribute can be used to specify a pointer; element type in a way that is compatible with `opaque pointers; <OpaquePointers.html>`__. The ``elem",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:55639,clear,cleared,55639,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['clear'],['cleared']
Usability,"ady know how to compile the code in question for the host architecture,; and that you know how to choose additional include and library paths. However, this document is *not* a ""how to"" and won't help you setting your; build system or Makefiles, nor choosing the right CMake options, etc.; Also, it does not cover all the possible options, nor does it contain; specific examples for specific architectures. For a concrete example, the; `instructions for cross-compiling LLVM itself; <https://llvm.org/docs/HowToCrossCompileLLVM.html>`_ may be of interest. After reading this document, you should be familiar with the main issues; related to cross-compilation, and what main compiler options Clang provides; for performing cross-compilation. Cross compilation issues; ========================. In GCC world, every host/target combination has its own set of binaries,; headers, libraries, etc. So, it's usually simple to download a package; with all files in, unzip to a directory and point the build system to; that compiler, that will know about its location and find all it needs to; when compiling your code. On the other hand, Clang/LLVM is natively a cross-compiler, meaning that; one set of programs can compile to all targets by setting the ``-target``; option. That makes it a lot easier for programmers wishing to compile to; different platforms and architectures, and for compiler developers that; only have to maintain one build system, and for OS distributions, that; need only one set of main packages. But, as is true to any cross-compiler, and given the complexity of; different architectures, OS's and options, it's not always easy finding; the headers, libraries or binutils to generate target specific code.; So you'll need special options to help Clang understand what target; you're compiling to, where your tools are, etc. Another problem is that compilers come with standard libraries only (like; ``compiler-rt``, ``libcxx``, ``libgcc``, ``libm``, etc), so you'll have to; find an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:1251,simpl,simple,1251,interpreter/llvm-project/clang/docs/CrossCompilation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst,1,['simpl'],['simple']
Usability,"afe points; the collector could move the objects and invalidate the; derived pointer. This is bad enough in the first place, but safe points can; crop up unpredictably. Consider:. %array = load { i32, [0 x %obj] }** %array_addr; %nth_el = getelementptr { i32, [0 x %obj] }* %array, i32 0, i32 %n; %old = load %obj** %nth_el; %z = div i64 %x, %y; store %obj* %new, %obj** %nth_el. If the i64 division is lowered to a libcall, then a safe point will (must); appear for the call site. If a collection occurs, %array and %nth_el no longer; point into the correct object. The fix for this is to copy address calculations so that dependent pointers; are never live across safe point boundaries. But the loads cannot be copied; like this if there was an intervening store, so may be hard to get right. Only a concurrent mutator can trigger a collection at the libcall safe point.; So single-threaded programs do not have this requirement, even with a copying; collector. Still, LLVM optimizations would probably undo a front-end's careful; work. //===---------------------------------------------------------------------===//. The ocaml frametable structure supports liveness information. It would be good; to support it. //===---------------------------------------------------------------------===//. The FIXME in ComputeCommonTailLength in BranchFolding.cpp needs to be; revisited. The check is there to work around a misuse of directives in inline; assembly. //===---------------------------------------------------------------------===//. It would be good to detect collector/target compatibility instead of silently; doing the wrong thing. //===---------------------------------------------------------------------===//. It would be really nice to be able to write patterns in .td files for copies,; which would eliminate a bunch of explicit predicates on them (e.g. no side; effects). Once this is in place, it would be even better to have tblgen; synthesize the various copy insertion/inspection meth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt:3802,undo,undo,3802,interpreter/llvm-project/llvm/lib/CodeGen/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt,1,['undo'],['undo']
Usability,"age collection run, the checker sees if the marked symbol is; being collected and issues the 'SYMBOL DEAD' warning if it does.; This way you know where exactly, up to the line of code, the symbol dies. It is unlikely that you call this function after the symbol is already dead,; because the very reference to it as the function argument prevents it from; dying. However, if the argument is not a symbol but a concrete value,; no warning would be issued. Example usage::. do {; int x = generate_some_integer();; clang_analyzer_warnOnDeadSymbol(x);; } while(0); // expected-warning{{SYMBOL DEAD}}. - ``void clang_analyzer_explain(a single argument of any type);``. This function explains the value of its argument in a human-readable manner; in the warning message. You can make as many overrides of its prototype; in the test code as necessary to explain various integral, pointer,; or even record-type values. To simplify usage in C code (where overloading; the function declaration is not allowed), you may append an arbitrary suffix; to the function name, without affecting functionality. Example usage::. void clang_analyzer_explain(int);; void clang_analyzer_explain(void *);. // Useful in C code; void clang_analyzer_explain_int(int);. void foo(int param, void *ptr) {; clang_analyzer_explain(param); // expected-warning{{argument 'param'}}; clang_analyzer_explain_int(param); // expected-warning{{argument 'param'}}; if (!ptr); clang_analyzer_explain(ptr); // expected-warning{{memory address '0'}}; }. - ``void clang_analyzer_dump( /* a single argument of any type */);``. Similar to clang_analyzer_explain, but produces a raw dump of the value,; same as SVal::dump(). Example usage::. void clang_analyzer_dump(int);; void foo(int x) {; clang_analyzer_dump(x); // expected-warning{{reg_$0<x>}}; }. - ``size_t clang_analyzer_getExtent(void *);``. This function returns the value that represents the extent of a memory region; pointed to by the argument. This value is often difficult to obtain ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:6701,simpl,simplify,6701,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,1,['simpl'],['simplify']
Usability,"ains>` laid out elsewhere in this document. .. _arc.misc.special_methods.dealloc:. ``dealloc``; ^^^^^^^^^^^. A program is ill-formed if it contains a message send or ``@selector``; expression for the selector ``dealloc``. .. admonition:: Rationale. There are no legitimate reasons to call ``dealloc`` directly. A class may provide a method definition for an instance method named; ``dealloc``. This method will be called after the final ``release`` of the; object but before it is deallocated or any of its instance variables are; destroyed. The superclass's implementation of ``dealloc`` will be called; automatically when the method returns. .. admonition:: Rationale. Even though ARC destroys instance variables automatically, there are still; legitimate reasons to write a ``dealloc`` method, such as freeing; non-retainable resources. Failing to call ``[super dealloc]`` in such a; method is nearly always a bug. Sometimes, the object is simply trying to; prevent itself from being destroyed, but ``dealloc`` is really far too late; for the object to be raising such objections. Somewhat more legitimately, an; object may have been pool-allocated and should not be deallocated with; ``free``; for now, this can only be supported with a ``dealloc``; implementation outside of ARC. Such an implementation must be very careful; to do all the other work that ``NSObject``'s ``dealloc`` would, which is; outside the scope of this document to describe. The instance variables for an ARC-compiled class will be destroyed at some; point after control enters the ``dealloc`` method for the root class of the; class. The ordering of the destruction of instance variables is unspecified,; both within a single class and between subclasses and superclasses. .. admonition:: Rationale. The traditional, non-ARC pattern for destroying instance variables is to; destroy them immediately before calling ``[super dealloc]``. Unfortunately,; message sends from the superclass are quite capable of reaching methods",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:88213,simpl,simply,88213,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['simpl'],['simply']
Usability,"airly simple and there is little code reuse opportunity anyway. .. _implementation-details:. Implementation Details; ======================. The current implementation of DDG differs slightly from the dependence; graph described in [1]_ in the following ways:. 1. The graph nodes in the paper represent three main program components, namely *assignment statements*, *for loop headers* and *while loop headers*. In this implementation, DDG nodes naturally represent LLVM IR instructions. An assignment statement in this implementation typically involves a node representing the ``store`` instruction along with a number of individual nodes computing the right-hand-side of the assignment that connect to the ``store`` node via a def-use edge. The loop header instructions are not represented as special nodes in this implementation because they have limited uses and can be easily identified, for example, through ``LoopAnalysis``.; 2. The paper describes five types of dependency edges between nodes namely *loop dependency*, *flow-*, *anti-*, *output-*, and *input-* dependencies. In this implementation *memory* edges represent the *flow-*, *anti-*, *output-*, and *input-* dependencies. However, *loop dependencies* are not made explicit, because they mainly represent association between a loop structure and the program elements inside the loop and this association is fairly obvious in LLVM IR itself.; 3. The paper describes two types of pi-blocks; *recurrences* whose bodies are SCCs and *IN* nodes whose bodies are not part of any SCC. In this implementation, pi-blocks are only created for *recurrences*. *IN* nodes remain as simple DDG nodes in the graph. References; ----------; .. [1] ""D. J. Kuck, R. H. Kuhn, D. A. Padua, B. Leasure, and M. Wolfe (1981). DEPENDENCE GRAPHS AND COMPILER OPTIMIZATIONS.""; .. [2] ""J. FERRANTE (IBM), K. J. OTTENSTEIN (Michigan Technological University) and JOE D. WARREN (Rice University), 1987. The Program Dependence Graph and Its Use in Optimization.""; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:6346,simpl,simple,6346,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,1,['simpl'],['simple']
Usability,"aive mathematical formulas for complex; multiplication and enables application of Smith's algorithm for complex; division. See SMITH, R. L. Algorithm 116: Complex division. Commun.; ACM 5, 8 (1962). The default is ``-fno-cx-fortran-rules``. .. _floating-point-environment:. Accessing the floating point environment; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; Many targets allow floating point operations to be configured to control things; such as how inexact results should be rounded and how exceptional conditions; should be handled. This configuration is called the floating point environment.; C and C++ restrict access to the floating point environment by default, and the; compiler is allowed to assume that all operations are performed in the default; environment. When code is compiled in this default mode, operations that depend; on the environment (such as floating-point arithmetic and `FLT_ROUNDS`) may have; undefined behavior if the dynamic environment is not the default environment; for; example, `FLT_ROUNDS` may or may not simply return its default value for the target; instead of reading the dynamic environment, and floating-point operations may be; optimized as if the dynamic environment were the default. Similarly, it is undefined; behavior to change the floating point environment in this default mode, for example; by calling the `fesetround` function.; C provides two pragmas to allow code to dynamically modify the floating point environment:. - ``#pragma STDC FENV_ACCESS ON`` allows dynamic changes to the entire floating; point environment. - ``#pragma STDC FENV_ROUND FE_DYNAMIC`` allows dynamic changes to just the floating; point rounding mode. This may be more optimizable than ``FENV_ACCESS ON`` because; the compiler can still ignore the possibility of floating-point exceptions by default. Both of these can be used either at the start of a block scope, in which case; they cover all code in that scope (unless they're turned off in a child scope),; or at the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:69727,simpl,simply,69727,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['simpl'],['simply']
Usability,"al, i32 %sel, 1; resume { ptr, i32 } %lpad.val29. The `CoroSpit` pass replaces `coro.end` with ``True`` in the resume functions,; thus leading to immediate unwind to the caller, whereas in start function it; is replaced with ``False``, thus allowing to proceed to the rest of the cleanup; code that is only needed during initial invocation of the coroutine. For Windows Exception handling model, a frontend should attach a funclet bundle; referring to an enclosing cleanuppad as follows:. .. code-block:: llvm. ehcleanup:; %tok = cleanuppad within none []; %unused = call i1 @llvm.coro.end(ptr null, i1 true, token none) [ ""funclet""(token %tok) ]; cleanupret from %tok unwind label %RestOfTheCleanup. The `CoroSplit` pass, if the funclet bundle is present, will insert; ``cleanupret from %tok unwind to caller`` before; the `coro.end`_ intrinsic and will remove the rest of the block. In the unwind path (when the argument is `true`), `coro.end` will mark the coroutine; as done, making it undefined behavior to resume the coroutine again and causing ; `llvm.coro.done` to return `true`. This is not necessary in the normal path because; the coroutine will already be marked as done by the final suspend. The following table summarizes the handling of `coro.end`_ intrinsic. +--------------------------+------------------------+---------------------------------+; | | In Start Function | In Resume/Destroy Functions |; +--------------------------+------------------------+---------------------------------+; |unwind=false | nothing |``ret void`` |; +------------+-------------+------------------------+---------------------------------+; | | WinEH | mark coroutine as done || ``cleanupret unwind to caller``|; | | | || mark coroutine done |; |unwind=true +-------------+------------------------+---------------------------------+; | | Landingpad | mark coroutine as done | mark coroutine done |; +------------+-------------+------------------------+---------------------------------+. .. _coro.end.re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:46170,resume,resume,46170,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"al:. Chapter 1 Introduction; ======================. **Warning: This tutorial is currently being updated to account for ORC API; changes. Only Chapters 1 and 2 are up-to-date.**. **Example code from Chapters 3 to 5 will compile and run, but has not been; updated**. Welcome to Chapter 1 of the ""Building an ORC-based JIT in LLVM"" tutorial. This; tutorial runs through the implementation of a JIT compiler using LLVM's; On-Request-Compilation (ORC) APIs. It begins with a simplified version of the; KaleidoscopeJIT class used in the; `Implementing a language with LLVM <LangImpl01.html>`_ tutorials and then; introduces new features like concurrent compilation, optimization, lazy; compilation and remote execution. The goal of this tutorial is to introduce you to LLVM's ORC JIT APIs, show how; these APIs interact with other parts of LLVM, and to teach you how to recombine; them to build a custom JIT that is suited to your use-case. The structure of the tutorial is:. - Chapter #1: Investigate the simple KaleidoscopeJIT class. This will; introduce some of the basic concepts of the ORC JIT APIs, including the; idea of an ORC *Layer*. - `Chapter #2 <BuildingAJIT2.html>`_: Extend the basic KaleidoscopeJIT by adding; a new layer that will optimize IR and generated code. - `Chapter #3 <BuildingAJIT3.html>`_: Further extend the JIT by adding a; Compile-On-Demand layer to lazily compile IR. - `Chapter #4 <BuildingAJIT4.html>`_: Improve the laziness of our JIT by; replacing the Compile-On-Demand layer with a custom layer that uses the ORC; Compile Callbacks API directly to defer IR-generation until functions are; called. - `Chapter #5 <BuildingAJIT5.html>`_: Add process isolation by JITing code into; a remote process with reduced privileges using the JIT Remote APIs. To provide input for our JIT we will use a lightly modified version of the; Kaleidoscope REPL from `Chapter 7 <LangImpl07.html>`_ of the ""Implementing a; language in LLVM tutorial"". Finally, a word on API generations: ORC ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:1185,simpl,simple,1185,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['simpl'],['simple']
Usability,"alf by refactoring the code reading and writing the TBasket data;; A single transient buffer holding the compressed data is now managed by TTree (and could be made thread local); rather than having one per TBranch. Updated TBranchElement::Unroll to no longer split a base class; that can not be split (i.e. respect the information returned; by TStreamerElement::CannotSplit (and thus TClass::CanSplit). This disabling is currently _not_ done automatically for backward compatibility reasons and because; ; Without TClass::SetCanSplit there was no way to; force the splitting (short of setting the split level lower); Some classes still requires a custom streamer solely to; read older data files (for example for file written before; the advent of StreamerInfo) and are such not necessary to; be used when writting (and schema evolution rules can not; yet be used in this case). Allowed removing branches when cloning a TNtuple. Added an option value (""cachedbranches"") to the Print() function of TTreeCache to be able to print the list of cached branches. Made the ownership of the TBranch by fBranch clearer (and thus allow the 'reuse' of TTree object without memory leak). Introduced GetLeaf(branchname,leafname) used in TTreeFormula to avoid ambiguity in the syntax introduced by too many slashes. Improved performance of TTree::GetEntry. With this changes the 'overhead'; compare to protobuf goes from 48% to 24%. (This does not include the; cost of the file opening which can be comparatively large for small; files. For the example used in the comparison the cost TFile::Open is 8% of the cost; of 100000 calls to TTree::GetEntry). Prevented the use of non-existent memory when reading in an object that is part of an STL collection and which used; to contains an embedded object (and this data member has been removed). Now properly recognize a TClonesArray data member even if the requested type was a typedef (to TClonesArray) that is in a namespace (for example edm::Event::ContaierType). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v532/index.html:3436,clear,clearer,3436,tree/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v532/index.html,1,['clear'],['clearer']
Usability,"align 16; %1 = getelementptr [8 x i64]* %input, i64 0, i64 2; store i64 1, i64* %1, align 16; %2 = getelementptr [8 x i64]* %input, i64 0, i64 4; store i64 1, i64* %2, align 16; %3 = getelementptr [8 x i64]* %input, i64 0, i64 6; store i64 1, i64* %3, align 16. Which gets codegen'd into:. 	pxor	%xmm0, %xmm0; 	movaps	%xmm0, -16(%rbp); 	movaps	%xmm0, -32(%rbp); 	movaps	%xmm0, -48(%rbp); 	movaps	%xmm0, -64(%rbp); 	movq	$1, -64(%rbp); 	movq	$1, -48(%rbp); 	movq	$1, -32(%rbp); 	movq	$1, -16(%rbp). It would be better to have 4 movq's of 0 instead of the movaps's. //===---------------------------------------------------------------------===//. http://llvm.org/PR717:. The following code should compile into ""ret int undef"". Instead, LLVM; produces ""ret int 0"":. int f() {; int x = 4;; int y;; if (x == 3) y = 0;; return y;; }. //===---------------------------------------------------------------------===//. The loop unroller should partially unroll loops (instead of peeling them); when code growth isn't too bad and when an unroll count allows simplification; of some code within the loop. One trivial example is:. #include <stdio.h>; int main() {; int nRet = 17;; int nLoop;; for ( nLoop = 0; nLoop < 1000; nLoop++ ) {; if ( nLoop & 1 ); nRet += 2;; else; nRet -= 1;; }; return nRet;; }. Unrolling by 2 would eliminate the '&1' in both copies, leading to a net; reduction in code size. The resultant code would then also be suitable for; exit value computation. //===---------------------------------------------------------------------===//. We miss a bunch of rotate opportunities on various targets, including ppc, x86,; etc. On X86, we miss a bunch of 'rotate by variable' cases because the rotate; matching code in dag combine doesn't look through truncates aggressively ; enough. Here are some testcases reduces from GCC PR17886:. unsigned long long f5(unsigned long long x, unsigned long long y) {; return (x << 8) | ((y >> 48) & 0xffull);; }; unsigned long long f6(unsigned long long x, u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:16022,simpl,simplification,16022,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplification']
Usability,"all analysis paths.; There are more debug checkers available. To see all available debug checkers:. $ clang -cc1 -analyzer-checker-help | grep ""debug"". Debug Prints and Tricks; To view ""half-baked"" ExplodedGraph while debugging, jump to a frame; that has clang::ento::ExprEngine object and execute:. (gdb) p ViewGraph(0). To see the ProgramState while debugging use the following command. (gdb) p State->dump(). To see clang::Expr while debugging use the following command. If you; pass in a SourceManager object, it will also dump the corresponding line in the; source code. (gdb) p E->dump(). To dump AST of a method that the current ExplodedNode belongs; to:. (gdb) p C.getPredecessor()->getCodeDecl().getBody()->dump(). Making Your Checker Better. User facing documentation is important for adoption! Make sure the checker list is updated; at the homepage of the analyzer. Also ensure the description is clear to; non-analyzer-developers in Checkers.td.; Warning and note messages should be clear and easy to understand, even if a bit long. Messages should start with a capital letter (unlike Clang warnings!) and should not; end with ..; Articles are usually omitted, eg. Dereference of a null pointer ->; Dereference of null pointer.; Introduce BugReporterVisitors to emit additional notes that explain the warning; to the user better. There are some existing visitors that might be useful for your check,; e.g. trackNullOrUndefValue. For example, SimpleStreamChecker should highlight; the event of opening the file when reporting a file descriptor leak. If the check tracks anything in the program state, it needs to implement the; checkDeadSymbolscallback to clean the state up.; The check should conservatively assume that the program is correct when a tracked symbol; is passed to a function that is unknown to the analyzer.; checkPointerEscape callback could help you handle that case.; Use safe and convenient APIs!. Always use CheckerContext::generateErrorNode and; CheckerContext::genera",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:23153,clear,clear,23153,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['clear'],['clear']
Usability,"all projects. .. _build_single_project:. Building a single sub-project; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Even though there is a single source tree, you are not required to build; all sub-projects together. It is trivial to configure builds for a single; sub-project. For example::. mkdir build && cd build; # Configure only LLVM (default); cmake path/to/monorepo; # Configure LLVM and lld; cmake path/to/monorepo -DLLVM_ENABLE_PROJECTS=lld; # Configure LLVM and clang; cmake path/to/monorepo -DLLVM_ENABLE_PROJECTS=clang. .. _git-svn-mirror:. Outstanding Questions; ---------------------. Read-only sub-project mirrors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. With the Monorepo, it is undecided whether the existing single-subproject; mirrors (e.g. https://git.llvm.org/git/compiler-rt.git) will continue to; be maintained. Read/write SVN bridge; ^^^^^^^^^^^^^^^^^^^^^. GitHub supports a read/write SVN bridge for its repositories. However,; there have been issues with this bridge working correctly in the past,; so it's not clear if this is something that will be supported going forward. Monorepo Drawbacks; ------------------. * Using the monolithic repository may add overhead for those contributing to a; standalone sub-project, particularly on runtimes like libcxx and compiler-rt; that don't rely on LLVM; currently, a fresh clone of libcxx is only 15MB (vs.; 1GB for the monorepo), and the commit rate of LLVM may cause more frequent; `git push` collisions when upstreaming. Affected contributors may be able to; use the SVN bridge or the single-subproject Git mirrors. However, it's; undecided if these projects will continue to be maintained.; * Using the monolithic repository may add overhead for those *integrating* a; standalone sub-project, even if they aren't contributing to it, due to the; same disk space concern as the point above. The availability of the; sub-project Git mirrors would addresses this.; * Preservation of the existing read/write SVN-based workflows relies on the; GitHub SV",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:10960,clear,clear,10960,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['clear'],['clear']
Usability,"alloc). One example of this is in; SingleSource/Benchmarks/Misc/dt.c. //===---------------------------------------------------------------------===//. Interesting missed case because of control flow flattening (should be 2 loads):; http://gcc.gnu.org/bugzilla/show_bug.cgi?id=26629; With: llvm-gcc t2.c -S -o - -O0 -emit-llvm | llvm-as | ; opt -mem2reg -gvn -instcombine | llvm-dis; we miss it because we need 1) CRIT EDGE 2) MULTIPLE DIFFERENT; VALS PRODUCED BY ONE BLOCK OVER DIFFERENT PATHS. //===---------------------------------------------------------------------===//. http://gcc.gnu.org/bugzilla/show_bug.cgi?id=19633; We could eliminate the branch condition here, loading from null is undefined:. struct S { int w, x, y, z; };; struct T { int r; struct S s; };; void bar (struct S, int);; void foo (int a, struct T b); {; struct S *c = 0;; if (a); c = &b.s;; bar (*c, a);; }. //===---------------------------------------------------------------------===//. simplifylibcalls should do several optimizations for strspn/strcspn:. strcspn(x, ""a"") -> inlined loop for up to 3 letters (similarly for strspn):. size_t __strcspn_c3 (__const char *__s, int __reject1, int __reject2,; int __reject3) {; register size_t __result = 0;; while (__s[__result] != '\0' && __s[__result] != __reject1 &&; __s[__result] != __reject2 && __s[__result] != __reject3); ++__result;; return __result;; }. This should turn into a switch on the character. See PR3253 for some notes on; codegen. 456.hmmer apparently uses strcspn and strspn a lot. 471.omnetpp uses strspn. //===---------------------------------------------------------------------===//. simplifylibcalls should turn these snprintf idioms into memcpy (GCC PR47917). char buf1[6], buf2[6], buf3[4], buf4[4];; int i;. int foo (void) {; int ret = snprintf (buf1, sizeof buf1, ""abcde"");; ret += snprintf (buf2, sizeof buf2, ""abcdef"") * 16;; ret += snprintf (buf3, sizeof buf3, ""%s"", i++ < 6 ? ""abc"" : ""def"") * 256;; ret += snprintf (buf4, sizeof buf4, ""%s"",",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:36779,simpl,simplifylibcalls,36779,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplifylibcalls']
Usability,"ally in the main file. .. productionlist::; IncludeDirective: ""include"" `TokString`. Portions of the main file and included files can be conditionalized using; preprocessor directives. .. productionlist::; PreprocessorDirective: ""#define"" | ""#ifdef"" | ""#ifndef"". Types; =====. The TableGen language is statically typed, using a simple but complete type; system. Types are used to check for errors, to perform implicit conversions,; and to help interface designers constrain the allowed input. Every value is; required to have an associated type. TableGen supports a mixture of low-level types (e.g., ``bit``) and; high-level types (e.g., ``dag``). This flexibility allows you to describe a; wide range of records conveniently and compactly. .. productionlist::; Type: ""bit"" | ""int"" | ""string"" | ""dag""; :| ""bits"" ""<"" `TokInteger` "">""; :| ""list"" ""<"" `Type` "">""; :| `ClassID`; ClassID: `TokIdentifier`. ``bit``; A ``bit`` is a boolean value that can be 0 or 1. ``int``; The ``int`` type represents a simple 64-bit integer value, such as 5 or; -42. ``string``; The ``string`` type represents an ordered sequence of characters of arbitrary; length. ``bits<``\ *n*\ ``>``; The ``bits`` type is a fixed-sized integer of arbitrary length *n* that; is treated as separate bits. These bits can be accessed individually.; A field of this type is useful for representing an instruction operation; code, register number, or address mode/register/displacement. The bits of; the field can be set individually or as subfields. For example, in an; instruction address, the addressing mode, base register number, and; displacement can be set separately. ``list<``\ *type*\ ``>``; This type represents a list whose elements are of the *type* specified in; angle brackets. The element type is arbitrary; it can even be another; list type. List elements are indexed from 0. ``dag``; This type represents a nestable directed acyclic graph (DAG) of nodes.; Each node has an *operator* and zero or more *arguments* (or *opera",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:10897,simpl,simple,10897,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,"ally supports a fully fine grained mapping mechanism that allows; you to map almost any diagnostic to the output level that you want. The only; diagnostics that cannot be mapped are ``NOTE``\ s, which always follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example of this class of error are failure; to ``#include`` a file. The Format String; ^^^^^^^^^^^^^^^^^. The format string for the diagnostic is very simple, but it has some power. It; takes the form of a string in English with markers that indicate where and how; arguments to the diagnostic are inserted and formatted. For example, here are; some simple format strings:. .. code-block:: c++. ""binary integer literals are an extension""; ""format string contains '\\0' within the string body""; ""more '%%' conversions than data arguments""; ""invalid operands to binary expression (%0 and %1)""; ""overloaded '%0' must be a %select{unary|binary|unary or binary}2 operator""; "" (has %1 parameter%s1)"". These examples show some important points of format strings. You can use any; plain ASCII character in the diagnostic string except ""``%``"" without a; problem, but these are C strings, so you have to use and be aware of all the C; escape sequences (as in the second example). If you want to produce a ""``%``""; in the output, use the ""``%%``"" escape sequence, like the third diagnostic.; Finally, Clang uses the ""``%...[digit]``"" sequences to specif",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:6269,simpl,simple,6269,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"also change for each sub-pad. ## Changes in 5.0.2; 1. Fix - read branch entries as arrays; 2. Fix - command submission to THttpServer; 3. Fix - let refill statbox also for empty histogram; 4. Fix - problem with online TTree::Draw and ROOT6. ## Changes in 5.0.1; 1. Support older ROOT files, created before 2010; 2. Support TBranchObject - appears in old files; 3. Correctly set TBasket buffer position for the entry; 4. Fix - problem with empty STL containers; 5. Fix - empty baskets at the end of branch store; 6. Fix - problem with zooming in THStack. ## Changes in 5.0.0; 1. Reading TTree data; - all kinds of branches, including split STL containers; - branches with several elementary leaves; - branches from different ROOT files; - JSROOT.TSelector class to access TTree data; - simple access to branch data with ""dump"" draw option; 2. TTree::Draw support; - simple 1D/2D/3D histograms; - simple cut conditions; - configurable histogram like ""px:py>>hist(50,-5,5,50,-5,5)""; - strings support; - iterate over arrays indexes, let use another branch as index values; - support ""Entry$"" and ""Entries$"" variables in expressions; - bits histogram like ""event.fTracks.fBits>>bits(16)""; - special handling of TBits; - arbitrary math function from JavaScript Math class, some TMath:: function from ROOT; - if branch is object, one could use methods ""TMath::Abs(lep1_p4.X()+lep1_p4.Y())""; - interactive player to configure and execute draw expression; 3. Full support of Float16_t and Double32_t types in I/O; 4. Drawing of RooPlot objects, I/O support for RooFit classes; 5. Many improvements in object inspector; - support of large lists; only first part is shown; - support of large arrays; values group in decades; - allow to call draw function for sub-elements in inspector; 6. Canvas or selected sub-pad can be enlarged when double-clicked outside frame (#116); Complete drawing will be expanded to the visible space.; Not available for flex, tabs and collapsible layouts.; 7. Support reading of lo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:46947,simpl,simple,46947,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,2,['simpl'],['simple']
Usability,"alue() << ""\n"";. Note that ``enumerate`` has ``zip_equal`` semantics and provides elements; through a 'reference wrapper' proxy, which makes them modifiable when accessed; through structured bindings or the ``value()`` member function. When two or more; ranges are passed, ``enumerate`` requires them to have equal lengths (checked; with an ``assert``). .. _debugging:. Debugging; =========. A handful of `GDB pretty printers; <https://sourceware.org/gdb/onlinedocs/gdb/Pretty-Printing.html>`__ are; provided for some of the core LLVM libraries. To use them, execute the; following (or add it to your ``~/.gdbinit``)::. source /path/to/llvm/src/utils/gdb-scripts/prettyprinters.py. It also might be handy to enable the `print pretty; <http://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_57.html>`__ option to; avoid data structures being printed as a big block of text. .. _common:. Helpful Hints for Common Operations; ===================================. This section describes how to perform some very simple transformations of LLVM; code. This is meant to give examples of common idioms used, showing the; practical side of LLVM transformations. Because this is a ""how-to"" section, you should also read about the main classes; that you will be working with. The :ref:`Core LLVM Class Hierarchy Reference; <coreclasses>` contains details and descriptions of the main classes that you; should know about. .. _inspection:. Basic Inspection and Traversal Routines; ---------------------------------------. The LLVM compiler infrastructure have many different data structures that may be; traversed. Following the example of the C++ standard template library, the; techniques used to traverse these various data structures are all basically the; same. For an enumerable sequence of values, the ``XXXbegin()`` function (or; method) returns an iterator to the start of the sequence, the ``XXXend()``; function returns an iterator pointing to one past the last valid element of the; sequence, and there ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:103638,simpl,simple,103638,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simple']
Usability,"alyzer. Obtaining the Static Analyzer; This page describes how to download and install the analyzer. Once; the analyzer is installed, follow the instructions on using scan-build to; get started analyzing your code.; Packaged Builds (Mac OS X); Semi-regular pre-built binaries of the analyzer are available on Mac; OS X. These are built to run on OS X 10.7 and later.; Builds are released frequently. Often the differences between build; numbers being a few bug fixes or minor feature improvements. When using; the analyzer, we recommend that you check back here occasionally for new; builds, especially if the build you are using is more than a couple; weeks old.; The latest build is:; . Packaged builds for other platforms may eventually be provided, but; we need volunteers who are willing to help provide such regular builds.; If you wish to help contribute regular builds of the analyzer on other; platforms, please email the Clang; Developers' mailing list.; Using Packaged Builds; To use a package build, simply unpack it anywhere. If the build; archive has the name checker-XXX.tar.bz2 then the; archive will expand to a directory called checker-XXX.; You do not need to place this directory or the contents of this; directory in any special place. Uninstalling the analyzer is as simple; as deleting this directory.; Most of the files in the checker-XXX directory will; be supporting files for the analyzer that you can simply ignore. Most; users will only care about two files, which are located at the top of; the checker-XXX directory:. scan-build: scan-build is the high-level command line utility for running the analyzer; scan-view: scan-view a companion command line; utility to scan-build, scan-view is used to view; analysis results generated by scan-build. There is an option; that one can pass to scan-build to cause scan-view to; run as soon as it the analysis of a build completes. Running scan-build; For specific details on using scan-build, please see; scan-build's documentat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/installation.html:1037,simpl,simply,1037,interpreter/llvm-project/clang/www/analyzer/installation.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/installation.html,1,['simpl'],['simply']
Usability,"ameter(1,1);; f1->Draw();; ```. in Python becomes:. ``` {.python}; import ROOT; f1 = ROOT.TF1(""f2"",""[0]*sin([1]*x)/x"",0.,10.); f1.SetParameter(0,1);; f1.SetParameter(1,1);; f1.Draw();; ```. A slightly more advanced example hands over data defined in the macro to the ROOT; class `TGraphErrors`. Note that a Python array can be used to pass data between; Python and ROOT. The first line in the Python script allows it to be executed; directly from the operating system, without the need to start the script from; python or the highly recommended powerful interactive shell ipython. The last line; in the python script is there to allow you to have a look at the graphical output; in the ROOT canvas before it disappears upon termination of the script. Here is the C++ version:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/TGraphFit.C; ```. In Python it looks like this:. ``` {.python}; @ROOT_INCLUDE_FILE macros/TGraphFit.py; ```. Comparing the C++ and Python versions in these two examples, it now should be; clear how easy it is to convert any ROOT Macro in C++ to a Python version. As another example, let us revisit macro3 from Chapter 4. A straight-forward; Python version relying on the ROOT class `TMath`:. ``` {.python}; @ROOT_INCLUDE_FILE macros/macro3.py; ```. ### More Python- less C++ ###. You may have noticed already that there are some Python modules providing; functionality similar to ROOT classes, which fit more seamlessly into your; Python code. A more “pythonic” version of the above macro3 would use a replacement of the; ROOT class TMath for the provisioning of data to TGraphPolar. With the math; package, the part of the code becomes. ``` {.cpp}; import math; from array import array; from ROOT import TCanvas , TGraphPolar; ...; ipt=range(0,npoints); r=array('d',map(lambda x: x*(rmax-rmin)/(npoints-1.)+rmin,ipt)); theta=array('d',map(math.sin,r)); e=array('d',npoints*[0.]); ... ```. #### Customised Binning ####; This example combines comfortable handling of arrays in Python to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md:1859,clear,clear,1859,documentation/primer/root_in_python.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/root_in_python.md,1,['clear'],['clear']
Usability,"ample is a set of; values defining the inputs and the corresponding output that the; network should ideally provide. In ROOT this is a **`TTree`** entry.; The first thing to be decided is the network layout. This layout is; described in a string where the layers are separated by semicolons.; The input/output layers are defined by giving the expression for each; neuron, separated by comas. Hidden layers are just described by the; number of neurons. In addition, input and output layer formulas can be preceded by '@'; (e.g. ""@out"") if one wants to normalize the corresponding value. Also,; if the string ends with '`!`', output neurons are set up for; classification, i.e. with a sigmoid (1 neuron) or softmax (more; neurons) activation function. Many questions on the good usage of neural network, including rules of; dumb to determine the best network topology are addressed at; <ftp://ftp.sas.com/pub/neural/FAQ.html>. ``` {.cpp}; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; ```. Expressions are evaluated as for `TTree::Draw()`. Input and outputs; are taken from the **`TTree`** associated with the network. This; **`TTree`** can be given as argument of the constructor or defined; later with `TMultiLayerPerceptron::SetData()`. Events can also be; weighted. The weight expression can be given in the constructor or set; later with the method `SetWeight()` of the class; **`TMultiLayerPerceptron`**. Two datasets must be defined before; learning the network: a training dataset that is used when minimizing; the error, and a test dataset that will avoid bias. Those two datasets; can be built aside and then given to the network, or can be built from; a standard expression. By default, half of the events are put in both; datasets. ``` {.cpp}; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:75082,simpl,simple,75082,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['simpl'],['simple']
Usability,"ample, guarantees that there will be no critical; edges in the CFG when your pass has been run. Some analyses chain to other analyses to do their job. For example, an; `AliasAnalysis <AliasAnalysis>` implementation is required to :ref:`chain; <aliasanalysis-chaining>` to other alias analysis passes. In cases where; analyses chain, the ``addRequiredTransitive`` method should be used instead of; the ``addRequired`` method. This informs the ``PassManager`` that the; transitively required pass should be alive as long as the requiring pass is. The ``AnalysisUsage::addPreserved<>`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. One of the jobs of the ``PassManager`` is to optimize how and when analyses are; run. In particular, it attempts to avoid recomputing data unless it needs to.; For this reason, passes are allowed to declare that they preserve (i.e., they; don't invalidate) an existing analysis if it's available. For example, a; simple constant folding pass would not modify the CFG, so it can't possibly; affect the results of dominator analysis. By default, all passes are assumed; to invalidate all others. The ``AnalysisUsage`` class provides several methods which are useful in; certain circumstances that are related to ``addPreserved``. In particular, the; ``setPreservesAll`` method can be called to indicate that the pass does not; modify the LLVM program at all (which is true for analyses), and the; ``setPreservesCFG`` method can be used by transformations that change; instructions in the program but do not modify the CFG or terminator; instructions. ``addPreserved`` is particularly useful for transformations like; ``BreakCriticalEdges``. This pass knows how to update a small set of loop and; dominator related analyses if they exist, so it can preserve them, despite the; fact that it hacks on the CFG. Example implementations of ``getAnalysisUsage``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. // This example modifies the program, bu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:31533,simpl,simple,31533,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['simpl'],['simple']
Usability,"ample: BOOST_PP_STRINGIZE. .. END_FORMAT_STYLE_OPTIONS. Adding additional style options; ===============================. Each additional style option adds costs to the clang-format project. Some of; these costs affect the clang-format development itself, as we need to make; sure that any given combination of options work and that new features don't; break any of the existing options in any way. There are also costs for end users; as options become less discoverable and people have to think about and make a; decision on options they don't really care about. The goal of the clang-format project is more on the side of supporting a; limited set of styles really well as opposed to supporting every single style; used by a codebase somewhere in the wild. Of course, we do want to support all; major projects and thus have established the following bar for adding style; options. Each new style option must .. * be used in a project of significant size (have dozens of contributors); * have a publicly accessible style guide; * have a person willing to contribute and maintain patches. Examples; ========. A style similar to the `Linux Kernel style; <https://www.kernel.org/doc/html/latest/process/coding-style.html>`_:. .. code-block:: yaml. BasedOnStyle: LLVM; IndentWidth: 8; UseTab: Always; BreakBeforeBraces: Linux; AllowShortIfStatementsOnASingleLine: false; IndentCaseLabels: false. The result is (imagine that tabs are used for indentation here):. .. code-block:: c++. void test(); {; switch (x) {; case 0:; case 1:; do_something();; break;; case 2:; do_something_else();; break;; default:; break;; }; if (condition); do_something_completely_different();. if (x == y) {; q();; } else if (x > y) {; w();; } else {; r();; }; }. A style similar to the default Visual Studio formatting style:. .. code-block:: yaml. UseTab: Never; IndentWidth: 4; BreakBeforeBraces: Allman; AllowShortIfStatementsOnASingleLine: false; IndentCaseLabels: false; ColumnLimit: 0. The result is:. .. code-block:: c+",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:134664,guid,guide,134664,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['guid'],['guide']
Usability,"ampling, Fourier transforms, etc. �The following concrete implementation; of the TestStatSampler interface are currently available. ToyMCSamplerUses a Toy Monte Carlo approach to build the; sampling distribution. �The pdf's generate method to generate is used to; generate toy data, and then the test statistic is evaluated at the; requested parameter point. ; DebuggingSampler Simply returns a uniform distribution; between 0,1. �Useful for debugging. NeymanConstruction and FeldmanCousins; A flexible framework for the Neyman Construction was added in this; release. The NeymanConstruction is a concrete implementation of the; IntervalCalculator interface, but it needs several; additional components�to be specified before use. The design; factorizes the choice of the parameter points to be tested,�the choice of; the test statistic, and the generation of sampling distribution into; separate parts (described above). �Finally, the NeymanConstruction class; is simply in charge of using these parts (strategies) and constructing; the confidence belt and confidence intervals. �The ConfidenceBelt class; is still under development, but the current version works fine for; producing ConfidenceIntervals. �We are also working to make this class; work with parallelization approaches, which is not yet complete.; The FeldmanCousins class is a separate concrete implementation of the; IntervalCalculator interface. �It uses the NeymanConstruction internally,; and�enforces�specific choices of the test statistic and ordering; principle to realize the Unified intervals described by Feldman and; Cousins in their paper�Phys.Rev.D57:3873-3889,1998. In an extension to the technique discussed in Feldman and Cousins paper,; the FeldmanCousins class also performs a ""profile construction"" if their are nuisance parameters.; In this case, the parameters of interest are scanned in a regular grid. For each point in the grid; the calculator finds the best fit value of the nuisance parameters (given the dat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:28183,simpl,simply,28183,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['simpl'],['simply']
Usability,"an add a ``-mno-evex512`` in the command line with AVX512 options if; they want to run the binary on both legacy AVX512 and new AVX10/256 capable; processors. The option has the same constraints as ``-mavx10.N``, i.e.,; cannot call to 512-bit X86 specific intrinsics and pass or return 512-bit vector; types in function call. Users should avoid using AVX512 features in function target attributes when; developing code for AVX10. If they have to do so, they need to add an explicit; ``evex512`` or ``no-evex512`` together with AVX512 features for 512-bit or; non-512-bit functions respectively to avoid unexpected code generation. Both; command line option and target attribute of EVEX512 feature can only be used; with AVX512. They don't affect vector size of AVX10. User should not mix the use AVX10 and AVX512 options together at any time,; because the option combinations are conflicting sometimes. For example, a; combination of ``-mavx512f -mavx10.1-256`` doesn't show a clear intention to; compiler, since instructions in AVX512F and AVX10.1/256 intersect but do not; overlap. In this case, compiler will emit warning for it, but the behavior; is determined. It will generate the same code as option ``-mavx10.1-512``.; A similar case is ``-mavx512f -mavx10.2-256``, which equals to; ``-mavx10.1-512 -mavx10.2-256``, because ``avx10.2-256`` implies ``avx10.1-256``; and ``-mavx512f -mavx10.1-256`` equals to ``-mavx10.1-512``. There are some new macros introduced with AVX10 support. ``-mavx10.1-256`` will; enable ``__AVX10_1__`` and ``__EVEX256__``, while ``-mavx10.1-512`` enables; ``__AVX10_1__``, ``__EVEX256__``, ``__EVEX512__`` and ``__AVX10_1_512__``.; Besides, both ``-mavx10.1-256`` and ``-mavx10.1-512`` will enable all AVX512; feature specific macros. A AVX512 feature will enable both ``__EVEX256__``,; ``__EVEX512__`` and its own macro. So ``__EVEX512__`` can be used to guard code; that can run on both legacy AVX512 and AVX10/512 capable processors but cannot; run on AVX10/256,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:160199,clear,clear,160199,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['clear'],['clear']
Usability,"an be added or customized by overriding InstrInfo's hook; ``createMIROperandComment()``. Debug-Info constructs; ---------------------. Most of the debugging information in a MIR file is to be found in the metadata; of the embedded module. Within a machine function, that metadata is referred to; by various constructs to describe source locations and variable locations. Source locations; ^^^^^^^^^^^^^^^^. Every MIR instruction may optionally have a trailing reference to a; ``DILocation`` metadata node, after all operands and symbols, but before; memory operands:. .. code-block:: text. $rbp = MOV64rr $rdi, debug-location !12. The source location attachment is synonymous with the ``!dbg`` metadata; attachment in LLVM-IR. The absence of a source location attachment will be; represented by an empty ``DebugLoc`` object in the machine instruction. Fixed variable locations; ^^^^^^^^^^^^^^^^^^^^^^^^. There are several ways of specifying variable locations. The simplest is; describing a variable that is permanently located on the stack. In the stack; or fixedStack attribute of the machine function, the variable, scope, and; any qualifying location modifier are provided:. .. code-block:: text. - { id: 0, name: offset.addr, offset: -24, size: 8, alignment: 8, stack-id: default,; 4 debug-info-variable: '!1', debug-info-expression: '!DIExpression()',; debug-info-location: '!2' }. Where:. - ``debug-info-variable`` identifies a DILocalVariable metadata node,. - ``debug-info-expression`` adds qualifiers to the variable location,. - ``debug-info-location`` identifies a DILocation metadata node. These metadata attributes correspond to the operands of a ``llvm.dbg.declare``; IR intrinsic, see the :ref:`source level debugging<format_common_intrinsics>`; documentation. Varying variable locations; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Variables that are not always on the stack or change location are specified; with the ``DBG_VALUE`` meta machine instruction. It is synonymous with the; ``llvm.dbg.valu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:24602,simpl,simplest,24602,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['simpl'],['simplest']
Usability,"an be nested).; * The ``Lexer`` keeps track of an :ref:`MultipleIncludeOpt; <MultipleIncludeOpt>` object, which is used to detect whether the buffer uses; the standard ""``#ifndef XX`` / ``#define XX``"" idiom to prevent multiple; inclusion. If a buffer does, subsequent includes can be ignored if the; ""``XX``"" macro is defined. .. _TokenLexer:. The ``TokenLexer`` class; ------------------------. The ``TokenLexer`` class is a token provider that returns tokens from a list of; tokens that came from somewhere else. It typically used for two things: 1); returning tokens from a macro definition as it is being expanded 2) returning; tokens from an arbitrary buffer of tokens. The later use is used by; ``_Pragma`` and will most likely be used to handle unbounded look-ahead for the; C++ parser. .. _MultipleIncludeOpt:. The ``MultipleIncludeOpt`` class; --------------------------------. The ``MultipleIncludeOpt`` class implements a really simple little state; machine that is used to detect the standard ""``#ifndef XX`` / ``#define XX``""; idiom that people typically use to prevent multiple inclusion of headers. If a; buffer uses this idiom and is subsequently ``#include``'d, the preprocessor can; simply check to see whether the guarding condition is defined or not. If so,; the preprocessor can completely ignore the include of the header. .. _Parser:. The Parser Library; ==================. This library contains a recursive-descent parser that polls tokens from the; preprocessor and notifies a client of the parsing progress. Historically, the parser used to talk to an abstract ``Action`` interface that; had virtual methods for parse events, for example ``ActOnBinOp()``. When Clang; grew C++ support, the parser stopped supporting general ``Action`` clients --; it now always talks to the :ref:`Sema library <Sema>`. However, the Parser; still accesses AST objects only through opaque types like ``ExprResult`` and; ``StmtResult``. Only :ref:`Sema <Sema>` looks at the AST node contents o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:56369,simpl,simple,56369,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"an exact; field label and data type match.). If, however, all methods fail and there is only one C++ exception (the other; exceptions originating from argument conversion, never succeeding to call; into C++), this C++ exception will be preferentially reported and will have; the original C++ type. `Return values`; ---------------. Most return types are readily amenable to automatic memory management: builtin; returns, by-value returns, (const-)reference returns to internal data, smart; pointers, etc.; The important exception is pointer returns.; ; A function that returns a pointer to an object over which Python should claim; ownership, should have its ``__creates__`` flag set through its; :doc:`pythonization <pythonizations>`.; Well-written APIs will have clear clues in their naming convention about the; ownership rules.; For example, functions called ``New...``, ``Clone...``, etc. can be expected; to return freshly allocated objects.; A basic name-matching in the pythonization then makes it simple to mark all; these functions as creators. The return values are :ref:`auto-casted <sec-auto-casting-label>`. `\*args and \*\*kwds`; ---------------------. C++ default arguments work as expected.; Keywords, however, are a Python language feature that does not exist in C++.; Many C++ function declarations do have formal arguments, but these are not; part of the C++ interface (the argument names are repeated in the definition,; making the names in the declaration irrelevant: they do not even need to be; provided).; Thus, although ``cppyy`` will map keyword argument names to formal argument; names from the C++ declaration, use of this feature is not recommended unless; you have a guarantee that the names in C++ the interface are maintained.; Example:. .. code-block:: python. >>> from cppyy.gbl import Concrete; >>> c = Concrete() # uses default argument; >>> c.m_int; 42; >>> c = Concrete(13) # uses provided argument; >>> c.m_int; 13; >>> args = (27,); >>> c = Concrete(*args) # a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst:13006,simpl,simple,13006,bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,1,['simpl'],['simple']
Usability,"an now just use; `getSCEV() <https://llvm.org/doxygen/classllvm_1_1ScalarEvolution.html#a30bd18ac905eacf3601bc6a553a9ff49>`_.; and which of these two llvm::Instructions you pass to it disambiguates; the context / scope / relative loop. .. rubric:: Footnotes. .. [#lcssa-construction] To insert these loop-closing PHI nodes, one has to; (re-)compute dominance frontiers (if the loop has multiple exits). .. [#point-of-use-phis] Considering the point of use of a PHI entry value; to be in the respective predecessor is a convention across the whole LLVM.; The reason is mostly practical; for example it preserves the dominance; property of SSA. It is also just an overapproximation of the actual; number of uses; the incoming block could branch to another block in which; case the value is not actually used but there are no side-effects (it might; increase its live range which is not relevant in LCSSA though).; Furthermore, we can gain some intuition if we consider liveness:; A PHI is *usually* inserted in the current block because the value can't; be used from this point and onwards (i.e. the current block is a dominance; frontier). It doesn't make sense to consider that the value is used in; the current block (because of the PHI) since the value stops being live; before the PHI. In some sense the PHI definition just ""replaces"" the original; value definition and doesn't actually use it. It should be stressed that; this analogy is only used as an example and does not pose any strict; requirements. For example, the value might dominate the current block; but we can still insert a PHI (as we do with LCSSA PHI nodes) *and*; use the original value afterwards (in which case the two live ranges overlap,; although in LCSSA (the whole point is that) we never do that). .. [#def-use-chain] A property of SSA is that there exists a def-use chain; for each definition, which is a list of all the uses of this definition.; LLVM implements this property by keeping a list of all the uses of a Valu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:17382,intuit,intuition,17382,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['intuit'],['intuition']
Usability,"and calculator classes.; Offsetting is a feature of calculation in a fitting context; it enhances numerical precision by subtracting the initial likelihood value from the value that the minimizer sees, thus setting it to zero for the minimizer.; Since this does not impact the derivative terms, it does not affect the fitting result, except for added numerical precision. ## Calculators; `RooFit::TestStatistics` provides two abstract base classes for likelihood calculation: `LikelihoodWrapper` and `LikelihoodGradientWrapper`.; These are used by the `RooAbsMinimizerFcn` implementation `MinuitFcnGrad` which expects them to, respectively, provide likelihood and likelihood gradient values for use by `Minuit2` in fitting the pdf to the dataset. The `Wrapper`s can be implemented for different kinds of algorithms, or with different kinds of optimization ""back-ends"" in mind.; One implementation of each is ready for use in `RooFit` currently:. 1. `LikelihoodSerial` is more or less simply a rewrite of the existing serial calculation of a `RooNLLVar`.; 2. `LikelihoodGradientJob` calculates the partial derivatives or the gradient in parallel on multiple CPUs/cores, based on `RooFit::MultiProcess`, which is a fork-based multi-processing task execution framework with dynamic load balancing. Other possible implementations could use the GPU or external tools like TensorFlow. The coupling of all these classes to `RooMinimizer` is made via the `MinuitFcnGrad` class, which owns the `Wrappers` that calculate the likelihood components. Note: a second `LikelihoodWrapper` class called `LikelihoodJob` is also available.; This class emulates the existing `NumCPU(>1)` functionality of the `RooAbsTestStatistic` tree, which is implemented based on `RooRealMPFE`.; This class is not yet thoroughly tested and should not be considered production ready. ### Usage example: `MultiProcess` enabled parallel gradient calculator. The main selling point of using `RooFit::TestStatistics` from a performance poi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md:7123,simpl,simply,7123,roofit/doc/developers/test_statistics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md,1,['simpl'],['simply']
Usability,"and non-core components. :doc:`SphinxQuickstartTemplate`; A template + tutorial for writing new Sphinx documentation. It is meant; to be read in source form. :doc:`HowToSubmitABug`; Instructions for properly submitting information about any bugs you run into; in the LLVM system. :doc:`BugLifeCycle`; Describes how bugs are reported, triaged and closed. :doc:`CodingStandards`; Details the LLVM coding standards and provides useful information on writing; efficient C++ code. :doc:`GitHub`; Describes how to use the llvm-project repository and code reviews on GitHub. :doc:`GitBisecting`; Describes how to use ``git bisect`` on LLVM's repository. :doc:`GitRepositoryPolicy`; Collection of policies around the git repositories. .. _development-process:. Development Process; -------------------. Information about LLVM's development process. .. toctree::; :hidden:. Projects; HowToReleaseLLVM; Packaging; ReleaseProcess; HowToAddABuilder; ReleaseNotes. :doc:`Projects`; How-to guide and templates for new projects that *use* the LLVM; infrastructure. The templates (directory organization, Makefiles, and test; tree) allow the project code to be located outside (or inside) the ``llvm/``; tree, while using LLVM header files and libraries. :doc:`HowToReleaseLLVM`; This is a guide to preparing LLVM releases. Most developers can ignore it. :doc:`ReleaseProcess`; This is a guide to validate a new release, during the release process. Most developers can ignore it. :doc:`HowToAddABuilder`; Instructions for adding new builder to LLVM buildbot master. :doc:`Packaging`; Advice on packaging LLVM into a distribution. :doc:`Release notes for the current release <ReleaseNotes>`; This describes new features, known bugs, and other limitations. .. _lists-forums:. Forums & Mailing Lists; ----------------------. If you can't find what you need in these docs, try consulting the; Discourse forums. There are also commit mailing lists for all commits to the LLVM Project.; The :doc:`CodeOfConduct` applies to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:1601,guid,guide,1601,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['guid'],['guide']
Usability,"and one test sample has; been rewritten completely. The new code is more performant and; has a clearer structure. This fixes several bugs which have been; reported by the TMVA users. On Minimization: . Variables, targets and spectators are now checked if they are; constant. (The execution of TMVA is stopped for variables and; targets, a warning is given for spectators.). On Regression:; ; The analysis type is no longer defined by calling a dedicated; TestAllMethods-member-function of the Factory, but with the; option ""AnalysisType"" in the Factory. The default value is; ""Auto"" where TMVA tries to determine the most suitable analysis; type from the targets and classes the user has defined. Other; values are ""regression"", ""classification"" and ""multiclass"" for; the forthcoming multiclass classification.; Missing regression evaluation plots for training sample were; added. On Cut method:. Removed obsolete option ""FVerySmart"" from Cuts method. On MLP method:; ; Display of convergence information in the progress bar for MLP during training. Creation of animated gifs for MLP convergence monitoring (please; contact authors if you want to do this). On Datasets: . Checks are performed if events are unvoluntarily cut by using a; non-filled array entry (e.g. ""arr[4]"" is used, when the array; has not always at least 5 entries). A warning is given in that; case.; Bug fixes. Spectators and Targets could not be used with by-hand assignment of events.; Corrected types (training/testing) for assigning single events.; Changed message from FATAL to WARNING when the user requests more events for ; training or testing than available.; Fixed bug which caused TMVA to crash if the number of input variables exceeded ; the allowed maximum for generating scatter plots.; Prevent TMVA from crashing when running with an empty TTree or TChain.; A variable expression like ""Alt$(arr[3],0)"" can now be used; to give a default value for a variable if for some events the; array don't contain enough eleme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html:2490,progress bar,progress bar,2490,tmva/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html,1,['progress bar'],['progress bar']
Usability,"and parameter; attributes, an assume operand bundle my also encode a ``separate_storage``; operand bundle. This has the form:. .. code-block:: llvm. separate_storage(<val1>, <val2>)``. This indicates that no pointer :ref:`based <pointeraliasing>` on one of its; arguments can alias any pointer based on the other. Even if the assumed property can be encoded as a boolean value, like; ``nonnull``, using operand bundles to express the property can still have; benefits:. * Attributes that can be expressed via operand bundles are directly the; property that the optimizer uses and cares about. Encoding attributes as; operand bundles removes the need for an instruction sequence that represents; the property (e.g., `icmp ne ptr %p, null` for `nonnull`) and for the; optimizer to deduce the property from that instruction sequence.; * Expressing the property using operand bundles makes it easy to identify the; use of the value as a use in an :ref:`llvm.assume <int_assume>`. This then; simplifies and improves heuristics, e.g., for use ""use-sensitive""; optimizations. .. _ob_preallocated:. Preallocated Operand Bundles; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Preallocated operand bundles are characterized by the ``""preallocated""``; operand bundle tag. These operand bundles allow separation of the allocation; of the call argument memory from the call site. This is necessary to pass; non-trivially copyable objects by value in a way that is compatible with MSVC; on some targets. There can be at most one ``""preallocated""`` operand bundle; attached to a call site and it must have exactly one bundle operand, which is; a token generated by ``@llvm.call.preallocated.setup``. A call with this; operand bundle should not adjust the stack before entering the function, as; that will have been done by one of the ``@llvm.call.preallocated.*`` intrinsics. .. code-block:: llvm. %foo = type { i64, i32 }. ... %t = call token @llvm.call.preallocated.setup(i32 1); %a = call ptr @llvm.call.preallocated.arg(token %",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:126355,simpl,simplifies,126355,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simplifies']
Usability,"and they fall into hierarchies. In addition, the ROOT has; fully cross-platform GUI classes and provides all standard components; for an application environment with common ‘look and feel'. The; object-oriented, event-driven programming model supports the modern; signals/slots communication mechanism. It handles user interface actions; and allows total independence of interacting objects and classes. This; mechanism uses the ROOT dictionary information and the Cling the C++; Interpreter to connect signals to slots methods. Therefore, all necessary elements for an object-oriented editor design; are in place. The editor complexity can be reduced by splitting it into; discrete units of so-called *`object`* *`editors`*. Any object editor; provides an object specific GUI. The main purpose of the ROOT graphics; editor is the organization of the object editors' appearance and the; task sequence between them. ### Object Editors. Every object editor follows a simple naming convention: to have as a; name the object class name concatenated with ‘*`Editor`*' (e.g. for; **`TGraph`** objects the object editor is **`TGraphEditor`**). Thanks to; the signals/slots communication mechanism and to the method; `DistancetoPrimitive()` that computes a ‘‘distance'' to an object from; the mouse position, it was possible to implement a signal method of the; canvas that says which is the selected object and to which pad it; belongs. Having this information the graphics editor loads the; corresponding object editor and the user interface is ready for use.; This way after a click on ‘axis'—the axis editor is active; a click on a; ‘pad' activates the pad editor, etc. The algorithm in use is simple and is based on the object-oriented; relationship and communication. When the user activates the editor,; according to the selected object **`<obj>`** in the canvas it looks for; a class name **`<obj>Editor`**. For that reason, the correct naming is; very important. If a class with this name is found, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:102212,simpl,simple,102212,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,2,['simpl'],['simple']
Usability,"and: register, immediate, basic block, external; symbol, global address, constant pool index, or jump table index. For an; instruction with a memory address operand, the ``printMemOperand`` method; should be implemented to generate the proper output. Similarly,; ``printCCOperand`` should be used to print a conditional operand. ``doFinalization`` should be overridden in ``XXXAsmPrinter``, and it should be; called to shut down the assembly printer. During ``doFinalization``, global; variables and constants are printed to output. Subtarget Support; =================. Subtarget support is used to inform the code generation process of instruction; set variations for a given chip set. For example, the LLVM SPARC; implementation provided covers three major versions of the SPARC microprocessor; architecture: Version 8 (V8, which is a 32-bit architecture), Version 9 (V9, a; 64-bit architecture), and the UltraSPARC architecture. V8 has 16; double-precision floating-point registers that are also usable as either 32; single-precision or 8 quad-precision registers. V8 is also purely big-endian.; V9 has 32 double-precision floating-point registers that are also usable as 16; quad-precision registers, but cannot be used as single-precision registers.; The UltraSPARC architecture combines V9 with UltraSPARC Visual Instruction Set; extensions. If subtarget support is needed, you should implement a target-specific; ``XXXSubtarget`` class for your architecture. This class should process the; command-line options ``-mcpu=`` and ``-mattr=``. TableGen uses definitions in the ``Target.td`` and ``Sparc.td`` files to; generate code in ``SparcGenSubtarget.inc``. In ``Target.td``, shown below, the; ``SubtargetFeature`` interface is defined. The first 4 string parameters of; the ``SubtargetFeature`` interface are a feature name, a XXXSubtarget field set; by the feature, the value of the XXXSubtarget field, and a description of the; feature. (The fifth parameter is a list of features whose pres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:71689,usab,usable,71689,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['usab'],['usable']
Usability,"and; `LLDB development <https://lldb.llvm.org/resources/build.html>`_. 11. Install psutil and obtain LLVM source code:. .. code-block:: bat. pip install psutil; git clone https://github.com/llvm/llvm-project.git llvm. Instead of ``git clone`` you may download a compressed source distribution; from the `releases page <https://github.com/llvm/llvm-project/releases>`_.; Select the last link: ``Source code (zip)`` and unpack the downloaded file using; Windows Explorer built-in zip support or any other unzip tool. 12. Finally, configure LLVM using CMake:. .. code-block:: bat. cmake -S llvm\llvm -B build -DLLVM_ENABLE_PROJECTS=clang -DLLVM_TARGETS_TO_BUILD=X86 -Thost=x64; exit. ``LLVM_ENABLE_PROJECTS`` specifies any additional LLVM projects you want to; build while ``LLVM_TARGETS_TO_BUILD`` selects the compiler targets. If; ``LLVM_TARGETS_TO_BUILD`` is omitted by default all targets are built; slowing compilation and using more disk space.; See the :doc:`LLVM CMake guide <CMake>` for detailed information about; how to configure the LLVM build. The ``cmake`` command line tool is bundled with Visual Studio but its GUI is; not. You may install `CMake <http://www.cmake.org/>`_ to use its GUI to change; CMake variables or modify the above command line. * Once CMake is installed then the simplest way is to just start the; CMake GUI, select the directory where you have LLVM extracted to, and; the default options should all be fine. One option you may really; want to change, regardless of anything else, might be the; ``CMAKE_INSTALL_PREFIX`` setting to select a directory to INSTALL to; once compiling is complete, although installation is not mandatory for; using LLVM. Another important option is ``LLVM_TARGETS_TO_BUILD``,; which controls the LLVM target architectures that are included on the; build.; * CMake generates project files for all build types. To select a specific; build type, use the Configuration manager from the VS IDE or the; ``/property:Configuration`` command line ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:5381,guid,guide,5381,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,1,['guid'],['guide']
Usability,"andled before submission but understand that it isn't; possible to test all of this for every submission. Our build bots and nightly; testing infrastructure normally finds these problems. A good rule of thumb is; to check the nightly testers for regressions the day after your change. Build; bots will directly email you if a group of commits that included yours caused a; failure. You are expected to check the build bot messages to see if they are; your fault and, if so, fix the breakage. Commits that violate these quality standards (e.g. are very broken) may be; reverted. This is necessary when the change blocks other developers from making; progress. The developer is welcome to re-commit the change after the problem has; been fixed. .. _commit messages:. Commit messages; ---------------. Although we don't enforce the format of commit messages, we prefer that; you follow these guidelines to help review, search in logs, email formatting; and so on. These guidelines are very similar to rules used by other open source; projects. Most importantly, the contents of the message should be carefully written to; convey the rationale of the change (without delving too much in detail). It; also should avoid being vague or overly specific. For example, ""bits were not; set right"" will leave the reviewer wondering about which bits, and why they; weren't right, while ""Correctly set overflow bits in TargetInfo"" conveys almost; all there is to the change. Below are some guidelines about the format of the message itself:. * Separate the commit message into title and body separated by a blank line. * If you're not the original author, ensure the 'Author' property of the commit is; set to the original author and the 'Committer' property is set to yourself.; You can use a command similar to; ``git commit --amend --author=""John Doe <jdoe@llvm.org>""`` to correct the; author property if it is incorrect. See `Attribution of Changes`_ for more; information including the method we used for attr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:15010,guid,guidelines,15010,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['guid'],['guidelines']
Usability,"andlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new errors can be produced:; Error(UserDefinedError &E);. // Original error can be inspected, then re-wrapped and returned (or a new; // error can be produced):; Error(std::unique_ptr<UserDefinedError> E);. Any error returned from a handler will be returned from the ``handleErrors``; function so that it can be handled itself, or propagated up the stack. .. _err_exitonerr:. Using ExitOnError to simplify tool code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Library code should never call ``exit`` for a recoverable error, however in tool; code (especially command line tools) this can be a reasonable approach. Calling; ``exit`` upon encountering an error dramatically simplifies control flow as the; error no longer needs to be propagated up the stack. This allows code to be; written in straight-line style, as long as each fallible call is wrapped in a; check and call to exit. The ``ExitOnError`` class supports this pattern by; providing call operators that inspect ``Error`` values, stripping the error away; in the success case and logging to ``stderr`` then exiting in the failure case. To use this class, declare a global ``ExitOnError`` variable in your program:. .. code-block:: c++. ExitOnError ExitOnErr;. Calls to fallible functions can then be wrapped with a call to ``ExitOnErr``,; turning them into non-failing calls:. .. code-block:: c++. Error mayFail();; Expected<int> mayFail2();. void foo() {; ExitOnErr(mayFail());; int X = ExitOnErr(mayFail2());; }. On failure, the error's log message will be written to ``stderr``, optionally; preceded by a string ""banner"" that can be set by calling the setBanner method. A; mapping can also be supplied from ``Error`` val",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:30618,simpl,simplifies,30618,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simplifies']
Usability,"ang++ -g -fsanitize-coverage=trace-pc-guard trace-pc-guard-example.cc -c; clang++ trace-pc-guard-cb.cc trace-pc-guard-example.o -fsanitize=address; ASAN_OPTIONS=strip_path_prefix=`pwd`/ ./a.out. .. code-block:: console. INIT: 0x71bcd0 0x71bce0; guard: 0x71bcd4 2 PC 0x4ecd5b in main trace-pc-guard-example.cc:2; guard: 0x71bcd8 3 PC 0x4ecd9e in main trace-pc-guard-example.cc:3:7. .. code-block:: console. ASAN_OPTIONS=strip_path_prefix=`pwd`/ ./a.out with-foo. .. code-block:: console. INIT: 0x71bcd0 0x71bce0; guard: 0x71bcd4 2 PC 0x4ecd5b in main trace-pc-guard-example.cc:3; guard: 0x71bcdc 4 PC 0x4ecdc7 in main trace-pc-guard-example.cc:4:17; guard: 0x71bcd0 1 PC 0x4ecd20 in foo() trace-pc-guard-example.cc:2:14. Inline 8bit-counters; ====================. **Experimental, may change or disappear in future**. With ``-fsanitize-coverage=inline-8bit-counters`` the compiler will insert; inline counter increments on every edge.; This is similar to ``-fsanitize-coverage=trace-pc-guard`` but instead of a; callback the instrumentation simply increments a counter. Users need to implement a single function to capture the counters at startup. .. code-block:: c++. extern ""C""; void __sanitizer_cov_8bit_counters_init(char *start, char *end) {; // [start,end) is the array of 8-bit counters created for the current DSO.; // Capture this array in order to read/modify the counters.; }. Inline bool-flag; ================. **Experimental, may change or disappear in future**. With ``-fsanitize-coverage=inline-bool-flag`` the compiler will insert; setting an inline boolean to true on every edge.; This is similar to ``-fsanitize-coverage=inline-8bit-counter`` but instead of; an increment of a counter, it just sets a boolean to true. Users need to implement a single function to capture the flags at startup. .. code-block:: c++. extern ""C""; void __sanitizer_cov_bool_flag_init(bool *start, bool *end) {; // [start,end) is the array of boolean flags created for the current DSO.; // Capture this arr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:4485,simpl,simply,4485,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,1,['simpl'],['simply']
Usability,"anteed to succeed when the; /// callback executes. Pass in NULL to remove any callback.; typedef void (*dfsan_write_callback_t)(int fd, const void *buf, size_t count);; void dfsan_set_write_callback(dfsan_write_callback_t labeled_write_callback);. /// Callbacks to be invoked on calls to `memcmp` or `strncmp`.; void dfsan_weak_hook_memcmp(void *caller_pc, const void *s1, const void *s2,; size_t n, dfsan_label s1_label,; dfsan_label s2_label, dfsan_label n_label);; void dfsan_weak_hook_strncmp(void *caller_pc, const char *s1, const char *s2,; size_t n, dfsan_label s1_label,; dfsan_label s2_label, dfsan_label n_label);. Taint label representation; --------------------------. We use an 8-bit unsigned integer for the representation of a; label. The label identifier 0 is special, and means that the data item; is unlabelled. This is optimizing for low CPU and code size overhead; of the instrumentation. When a label union operation is requested at a; join point (any arithmetic or logical operation with two or more; operands, such as addition), we can simply OR the two labels in O(1). Users are responsible for managing the 8 integer labels (i.e., keeping; track of what labels they have used so far, picking one that is yet; unused, etc). Origin tracking trace representation; ------------------------------------. An origin tracking trace is a list of chains. Each chain has a stack trace; where the DFSan runtime records a label propagation, and a pointer to its; previous chain. The very first chain does not point to any chain. Every four 4-bytes aligned application bytes share a 4-byte origin trace ID. A; 4-byte origin trace ID contains a 4-bit depth and a 28-bit hash ID of a chain. A chain ID is calculated as a hash from a chain structure. A chain structure; contains a stack ID and the previous chain ID. The chain head has a zero; previous chain ID. A stack ID is a hash from a stack trace. The 4-bit depth; limits the maximal length of a path. The environment variable ``origin_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:5926,simpl,simply,5926,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,1,['simpl'],['simply']
Usability,"anual.html#Statistic>`_ to your pass, which will; tally counts of things you care about. Following this, you can set up a test and a report that collects these; and formats them for easy viewing. This consists of two files, a; ""``test-suite/TEST.XXX.Makefile``"" fragment (where XXX is the name of; your test) and a ""``test-suite/TEST.XXX.report``"" file that indicates; how to format the output into a table. There are many example reports of; various levels of sophistication included with the test suite, and the; framework is very general. If you are interested in testing an optimization pass, check out the; ""libcalls"" test as an example. It can be run like this:. .. code-block:: bash. % cd llvm/projects/test-suite/MultiSource/Benchmarks # or some other level; % make TEST=libcalls report. This will do a bunch of stuff, then eventually print a table like this:. ::. Name | total | #exit |; ...; FreeBench/analyzer/analyzer | 51 | 6 |; FreeBench/fourinarow/fourinarow | 1 | 1 |; FreeBench/neural/neural | 19 | 9 |; FreeBench/pifft/pifft | 5 | 3 |; MallocBench/cfrac/cfrac | 1 | * |; MallocBench/espresso/espresso | 52 | 12 |; MallocBench/gs/gs | 4 | * |; Prolangs-C/TimberWolfMC/timberwolfmc | 302 | * |; Prolangs-C/agrep/agrep | 33 | 12 |; Prolangs-C/allroots/allroots | * | * |; Prolangs-C/assembler/assembler | 47 | * |; Prolangs-C/bison/mybison | 74 | * |; ... This basically is grepping the -stats output and displaying it in a; table. You can also use the ""TEST=libcalls report.html"" target to get; the table in HTML form, similarly for report.csv and report.tex. The source for this is in ``test-suite/TEST.libcalls.*``. The format is; pretty simple: the Makefile indicates how to run the test (in this case,; ""``opt -simplify-libcalls -stats``""), and the report contains one line; for each column of the output. The first value is the header for the; column and the second is the regex to grep the output of the command; for. There are lots of example reports that can do fancy stuff.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:7232,simpl,simple,7232,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,2,['simpl'],"['simple', 'simplify-libcalls']"
Usability,"anup]. In this case, the coroutine frame would include a suspend index that will; indicate at which suspend point the coroutine needs to resume. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32, i32 }. The resume function will use an index to jump to an appropriate basic block and will look; as follows:. .. code-block:: llvm. define internal fastcc void @f.Resume(ptr %FramePtr) {; entry.Resume:; %index.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 2; %index = load i8, ptr %index.addr, align 1; %switch = icmp eq i8 %index, 0; %n.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 3; %n = load i32, ptr %n.addr, align 4. br i1 %switch, label %loop.resume, label %loop. loop.resume:; %sub = sub nsw i32 0, %n; call void @print(i32 %sub); br label %suspend; loop:; %inc = add nsw i32 %n, 1; store i32 %inc, ptr %n.addr, align 4; tail call void @print(i32 %inc); br label %suspend. suspend:; %storemerge = phi i8 [ 0, %loop ], [ 1, %loop.resume ]; store i8 %storemerge, ptr %index.addr, align 1; ret void; }. If different cleanup code needs to get executed for different suspend points,; a similar switch will be in the `f.destroy` function. .. note ::. Using suspend index in a coroutine state and having a switch in `f.resume` and; `f.destroy` is one of the possible implementation strategies. We explored; another option where a distinct `f.resume1`, `f.resume2`, etc. are created for; every suspend point, and instead of storing an index, the resume and destroy; function pointers are updated at every suspend. Early testing showed that the; current approach is easier on the optimizer than the latter so it is a; lowering strategy implemented at the moment. Distinct Save and Suspend; -------------------------. In the previous example, setting a resume index (or some other state change that; needs to happen to prepare a coroutine for resumption) happens at the same time as; a suspension of a coroutine. However, in certain cases, it is necessary to co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:19764,resume,resume,19764,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"any cases it makes sense to build a special fuzzing-friendly build; with certain fuzzing-unfriendly features disabled. We propose to use a common build macro; for all such cases for consistency: ``FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION``. .. code-block:: c++. void MyInitPRNG() {; #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION; // In fuzzing mode the behavior of the code should be deterministic.; srand(0);; #else; srand(time(0));; #endif; }. AFL compatibility; -----------------; LibFuzzer can be used together with AFL_ on the same test corpus.; Both fuzzers expect the test corpus to reside in a directory, one file per input.; You can run both fuzzers on the same corpus, one after another:. .. code-block:: console. ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@; ./llvm-fuzz testcase_dir findings_dir # Will write new tests to testcase_dir. Periodically restart both fuzzers so that they can use each other's findings.; Currently, there is no simple way to run both fuzzing engines in parallel while sharing the same corpus dir. You may also use AFL on your target function ``LLVMFuzzerTestOneInput``:; see an example `here <https://github.com/llvm/llvm-project/tree/main/compiler-rt/lib/fuzzer/afl>`__. How good is my fuzzer?; ----------------------. Once you implement your target function ``LLVMFuzzerTestOneInput`` and fuzz it to death,; you will want to know whether the function or the corpus can be improved further.; One easy to use metric is, of course, code coverage. We recommend to use; `Clang Coverage <https://clang.llvm.org/docs/SourceBasedCodeCoverage.html>`_,; to visualize and study your code coverage; (`example <https://github.com/google/fuzzer-test-suite/blob/master/tutorial/libFuzzerTutorial.md#visualizing-coverage>`_). User-supplied mutators; ----------------------. LibFuzzer allows to use custom (user-supplied) mutators, see; `Structure-Aware Fuzzing <https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md>`_; for more de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:22757,simpl,simple,22757,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['simpl'],['simple']
Usability,"ap<[...], double>>' for 1st argument;. -fno-elide-type: template diff without elision. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<int, float>>' to 'vector<map<int, double>>' for 1st argument;. -fdiagnostics-show-template-tree: template tree printing with elision. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; [...],; [float != double]>>. -fdiagnostics-show-template-tree -fno-elide-type: template tree printing with no elision. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; int,; [float != double]>>. Automatic Macro Expansion; Many errors happen in macros that are sometimes deeply nested. With; traditional compilers, you need to dig deep into the definition of the macro to; understand how you got into trouble. The following simple example shows how; Clang helps you out by automatically printing instantiation information and; nested range information for diagnostics as they are instantiated through macros; and also shows how some of the other pieces work in a bigger example. $ clang -fsyntax-only t.c; t.c:80:3: error: invalid operands to binary expression ('typeof(P)' (aka 'struct mystruct') and 'typeof(F)' (aka 'float')); X = MYMAX(P, F);; ^~~~~~~~~~~; t.c:76:94: note: expanded from:; #define MYMAX(A,B) __extension__ ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a < __b ? __b : __a; }); ~~~ ^ ~~~. Here's another real world warning that occurs in the ""window"" Unix package (which; implements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implem",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:8873,simpl,simple,8873,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['simpl'],['simple']
Usability,"applied; earlier in the pipeline. Async Lowering; --------------. In async-continuation lowering, signaled by the use of `llvm.coro.id.async`,; handling of control-flow must be handled explicitly by the frontend. In this lowering, a coroutine is assumed to take the current `async context` as; one of its arguments (the argument position is determined by; `llvm.coro.id.async`). It is used to marshal arguments and return values of the; coroutine. Therefore an async coroutine returns `void`. .. code-block:: llvm. define swiftcc void @async_coroutine(ptr %async.ctxt, ptr, ptr) {; }. Values live across a suspend point need to be stored in the coroutine frame to; be available in the continuation function. This frame is stored as a tail to the; `async context`. Every suspend point takes an `context projection function` argument which; describes how-to obtain the continuations `async context` and every suspend; point has an associated `resume function` denoted by the; `llvm.coro.async.resume` intrinsic. The coroutine is resumed by calling this; `resume function` passing the `async context` as the one of its arguments; argument. The `resume function` can restore its (the caller's) `async context`; by applying a `context projection function` that is provided by the frontend as; a parameter to the `llvm.coro.suspend.async` intrinsic. .. code-block:: c. // For example:; struct async_context {; struct async_context *caller_context;; ...; }. char *context_projection_function(struct async_context *callee_ctxt) {; return callee_ctxt->caller_context;; }. .. code-block:: llvm. %resume_func_ptr = call ptr @llvm.coro.async.resume(); call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function. The frontend should provide a `async function pointer` struct associated with; each async coroutine by `llvm.coro.id.async`'s argument. The initial size and; alignment of the `async context` must be provided as arguments to the; `llvm.coro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:8605,resume,resume,8605,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"apsed time is less than a second. ### Examples of Using the Generators. The method `Rndm()` is used for generating a pseudo-random number; distributed between 0 and 1 as shown in the following example:. ``` {.cpp}; // use default seed; // (same random numbers will be generated each time); TRandom3 r; // generate a number in interval ]0,1] (0 is excluded); r.Rndm();; double x[100];; r.RndmArray(100,x); // generate an array of random numbers in ]0,1]; TRandom3 rdm(111); // construct with a user-defined seed; // use 0: a unique seed will be automatically generated using TUUID; TRandom1 r1(0);; TRandom2 r2(0);; TRandom3 r3(0);; // seed generated using machine clock (different every second); TRandom r0(0);; ```. ### Random Number Distributions. The **`TRandom`** base class provides functions, which can be used by; all the other derived classes for generating random variates according; to predefined distributions. In the simplest cases, like in the case of; the exponential distribution, the non-uniform random number is obtained; by applying appropriate transformations. In the more complicated cases,; random variates are obtained using acceptance-rejection methods, which; require several random numbers. ``` {.cpp}; TRandom3 r;; // generate a gaussian distributed number with:; // mu=0, sigma=1 (default values); double x1 = r.Gaus();; double x2 = r.Gaus(10,3); // use mu = 10, sigma = 3;; ```. The following table shows the various distributions that can be; generated using methods of the **`TRandom`** classes. More information; is available in the reference documentation for **`TRandom`**. In; addition, random numbers distributed according to a user defined; function, in a limited interval, or to a user defined histogram, can be; generated in a very efficient way using **`TF1::`**GetRandom() or; **`TH1::`**GetRandom(). +-------------------------------------------+--------------------------------+; | Distributions | Description |; +-------------------------------------------+-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:15109,simpl,simplest,15109,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['simpl'],['simplest']
Usability,"apture, you don't; subclass a parser. This means that you don't have to write **any**; boilerplate code. #. Globally accessible: Libraries can specify command line arguments that are; automatically enabled in any tool that links to the library. This is; possible because the application doesn't have to keep a list of arguments to; pass to the parser. This also makes supporting `dynamically loaded options`_; trivial. #. Cleaner: CommandLine supports enum and other types directly, meaning that; there is less error and more security built into the library. You don't have; to worry about whether your integral command line argument accidentally got; assigned a value that is not valid for your enum type. #. Powerful: The CommandLine library supports many different types of arguments,; from simple `boolean flags`_ to `scalars arguments`_ (`strings`_,; `integers`_, `enums`_, `doubles`_), to `lists of arguments`_. This is; possible because CommandLine is... #. Extensible: It is very simple to add a new argument type to CommandLine.; Simply specify the parser that you want to use with the command line option; when you declare it. `Custom parsers`_ are no problem. #. Labor Saving: The CommandLine library cuts down on the amount of grunt work; that you, the user, have to do. For example, it automatically provides a; ``-help`` option that shows the available command line options for your tool.; Additionally, it does most of the basic correctness checking for you. #. Capable: The CommandLine library can handle lots of different forms of; options often found in real programs. For example, `positional`_ arguments,; ``ls`` style `grouping`_ options (to allow processing '``ls -lad``'; naturally), ``ld`` style `prefix`_ options (to parse '``-lmalloc; -L/usr/lib``'), and interpreter style options. This document will hopefully let you jump in and start using CommandLine in your; utility quickly and painlessly. Additionally it should be a simple reference; manual to figure out how stuff wo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:2618,simpl,simple,2618,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,"arameters after the lambda, indent the block two spaces from the indent of the; ``[]``:. .. code-block:: c++. dyn_switch(V->stripPointerCasts(),; [] (PHINode *PN) {; // process phis...; },; [] (SelectInst *SI) {; // process selects...; },; [] (LoadInst *LI) {; // process loads...; },; [] (AllocaInst *AI) {; // process allocas...; });. Braced Initializer Lists; """""""""""""""""""""""""""""""""""""""""""""""". Starting from C++11, there are significantly more uses of braced lists to; perform initialization. For example, they can be used to construct aggregate; temporaries in expressions. They now have a natural way of ending up nested; within each other and within function calls in order to build up aggregates; (such as option structs) from local variables. The historically common formatting of braced initialization of aggregate; variables does not mix cleanly with deep nesting, general expression contexts,; function arguments, and lambdas. We suggest new code use a simple rule for; formatting braced initialization lists: act as-if the braces were parentheses; in a function call. The formatting rules exactly match those already well; understood for formatting nested function calls. Examples:. .. code-block:: c++. foo({a, b, c}, {1, 2, 3});. llvm::Constant *Mask[] = {; llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 0),; llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 1),; llvm::ConstantInt::get(llvm::Type::getInt32Ty(getLLVMContext()), 2)};. This formatting scheme also makes it particularly easy to get predictable,; consistent, and automatic formatting with tools like `Clang Format`_. .. _Clang Format: https://clang.llvm.org/docs/ClangFormat.html. Language and Compiler Issues; ----------------------------. Treat Compiler Warnings Like Errors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Compiler warnings are often useful and help improve the code. Those that are; not useful, can be often suppressed with a small code change. For example, an; assignment in the ``if``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:20688,simpl,simple,20688,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['simpl'],['simple']
Usability,"arate sub ranges of the same histogram. To use a Gaussian, or; any other ROOT built in function, on a sub range you need to define a; new **`TF1`**. Each is 'derived' from the canned function `gaus`. ![Fitting a histogram with several Gaussian; functions](pictures/03000062.png). First, four **`TF1`** objects are created - one for each sub-range:. ``` {.cpp}; g1 = new TF1(""m1"",""gaus"",85,95);; g2 = new TF1(""m2"",""gaus"",98,108);; g3 = new TF1(""m3"",""gaus"",110,121);; // The total is the sum of the three, each has 3 parameters; total = new TF1(""mstotal"",""gaus(0)+gaus(3)+gaus(6)"",85,125);; ```. Next, we fill a histogram with bins defined in the array x. ``` {.cpp}; // Create a histogram and set it's contents; h = new TH1F(""g1"",""Example of several fits in subranges"",; np,85,134);; h->SetMaximum(7);; for (int i=0; i<np; i++) {; h->SetBinContent(i+1,x[i]);; }; // Define the parameter array for the total function; Double_t par[9];; ```. When fitting simple functions, such as a Gaussian, the initial values; of the parameters are automatically computed by ROOT. In the more; complicated case of the sum of 3 Gaussian functions, the initial; values of parameters must be set. In this particular case, the initial; values are taken from the result of the individual fits. The use of; the ""+"" sign is explained below:. ``` {.cpp}; // Fit each function and add it to the list of functions; h->Fit(g1,""R"");; h->Fit(g2,""R+"");; h->Fit(g3,""R+"");. // Get the parameters from the fit; g1->GetParameters(&par[0]);; g2->GetParameters(&par[3]);; g3->GetParameters(&par[6]);. // Use the parameters on the sum; total->SetParameters(par);; h->Fit(total,""R+"");; ```. ### Adding Functions to the List. The example `$ROOTSYS/tutorials/fit/multifit.C` also illustrates how; to fit several functions on the same histogram. By default a Fit; command deletes the previously fitted function in the histogram; object. You can specify the option ""+"" in the second parameter to add; the newly fitted function to the existing l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:13459,simpl,simple,13459,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['simpl'],['simple']
Usability,"ared with the 'diff' method.; (`#66744 <https://github.com/llvm/llvm-project/issues/66744>`_). - Fix crash caused by a spaceship operator returning a comparision category by; reference. Fixes:; (`#64162 <https://github.com/llvm/llvm-project/issues/64162>`_); - Fix a crash when calling a consteval function in an expression used as; the size of an array.; (`#65520 <https://github.com/llvm/llvm-project/issues/65520>`_). - Clang no longer tries to capture non-odr-used variables that appear; in the enclosing expression of a lambda expression with a noexcept specifier.; (`#67492 <https://github.com/llvm/llvm-project/issues/67492>`_). - Fix crash when fold expression was used in the initialization of default; argument. Fixes:; (`#67395 <https://github.com/llvm/llvm-project/issues/67395>`_). - Fixed a bug causing destructors of constant-evaluated structured bindings; initialized by array elements to be called in the wrong evaluation context. - Fix crash where ill-formed code was being treated as a deduction guide and; we now produce a diagnostic. Fixes:; (`#65522 <https://github.com/llvm/llvm-project/issues/65522>`_). - Fixed a bug where clang incorrectly considered implicitly generated deduction; guides from a non-templated constructor and a templated constructor as ambiguous,; rather than prefer the non-templated constructor as specified in; [standard.group]p3. - Fixed a crash caused by incorrect handling of dependence on variable templates; with non-type template parameters of reference type. Fixes:; (`#65153 <https://github.com/llvm/llvm-project/issues/65153>`_). - Clang now properly compares constraints on an out of line class template; declaration definition. Fixes:; (`#61763 <https://github.com/llvm/llvm-project/issues/61763>`_). - Fix a bug where implicit deduction guides are not correctly generated for nested template; classes. Fixes:; (`#46200 <https://github.com/llvm/llvm-project/issues/46200>`_); (`#57812 <https://github.com/llvm/llvm-project/issues/57812>`_). - ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:51228,guid,guide,51228,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['guid'],['guide']
Usability,"argument is; assumed to be ``this``, and the analysis will not check the body of the; function. This pattern is intended for use by classes which hide locking; details behind an abstract interface. For example:. .. code-block:: c++. template <class T>; class CAPABILITY(""mutex"") Container {; private:; Mutex mu;; T* data;. public:; // Hide mu from public interface.; void Lock() ACQUIRE() { mu.Lock(); }; void Unlock() RELEASE() { mu.Unlock(); }. T& getElem(int i) { return data[i]; }; };. void test() {; Container<int> c;; c.Lock();; int i = c.getElem(0);; c.Unlock();; }. EXCLUDES(...); -------------. *Previously*: ``LOCKS_EXCLUDED``. ``EXCLUDES`` is an attribute on functions or methods, which declares that; the caller must *not* hold the given capabilities. This annotation is; used to prevent deadlock. Many mutex implementations are not re-entrant, so; deadlock can occur if the function acquires the mutex a second time. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void clear() EXCLUDES(mu) {; mu.Lock();; a = 0;; mu.Unlock();; }. void reset() {; mu.Lock();; clear(); // Warning! Caller cannot hold 'mu'.; mu.Unlock();; }. Unlike ``REQUIRES``, ``EXCLUDES`` is optional. The analysis will not issue a; warning if the attribute is missing, which can lead to false negatives in some; cases. This issue is discussed further in :ref:`negative`. NO_THREAD_SAFETY_ANALYSIS; -------------------------. ``NO_THREAD_SAFETY_ANALYSIS`` is an attribute on functions or methods, which; turns off thread safety checking for that method. It provides an escape hatch; for functions which are either (1) deliberately thread-unsafe, or (2) are; thread-safe, but too complicated for the analysis to understand. Reasons for; (2) will be described in the :ref:`limitations`, below. .. code-block:: c++. class Counter {; Mutex mu;; int a GUARDED_BY(mu);. void unsafeIncrement() NO_THREAD_SAFETY_ANALYSIS { a++; }; };. Unlike the other attributes, NO_THREAD_SAFETY_ANALYSIS is not part of the; interface o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:10493,clear,clear,10493,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['clear'],['clear']
Usability,"arser<int> specialization** uses the C ``strtol`` function to parse the; string input. As such, it will accept a decimal number (with an optional '+'; or '-' prefix) which must start with a non-zero digit. It accepts octal; numbers, which are identified with a '``0``' prefix digit, and hexadecimal; numbers with a prefix of '``0x``' or '``0X``'. .. _doubles:; .. _float:; .. _double:. * The **parser<double>** and **parser<float> specializations** use the standard; C ``strtod`` function to convert floating point strings into floating point; values. As such, a broad range of string formats is supported, including; exponential notation (ex: ``1.7e15``) and properly supports locales. .. _Extension Guide:; .. _extending the library:. Extension Guide; ===============. Although the CommandLine library has a lot of functionality built into it; already (as discussed previously), one of its true strengths lie in its; extensibility. This section discusses how the CommandLine library works under; the covers and illustrates how to do some simple, common, extensions. .. _Custom parsers:; .. _custom parser:; .. _Writing a Custom Parser:. Writing a custom parser; -----------------------. One of the simplest and most common extensions is the use of a custom parser.; As `discussed previously`_, parsers are the portion of the CommandLine library; that turns string input from the user into a particular parsed data type,; validating the input in the process. There are two ways to use a new parser:. #. Specialize the `cl::parser`_ template for your custom data type. This approach has the advantage that users of your custom data type will; automatically use your custom parser whenever they define an option with a; value type of your data type. The disadvantage of this approach is that it; doesn't work if your fundamental data type is something that is already; supported. #. Write an independent class, using it explicitly from options that need it. This approach works well in situations wher",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:61698,simpl,simple,61698,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,"art of the RNTupleUtils library,; which depends on the RNTuple library. The RNTuple classes are organized in layers:; the storage layer, the primitives layer, the logical layer and the event iteration layer.; Most classes in the storage layer and the primitives layer are in the `ROOT::Internal` namespace (non-public interfaces),; with the notable exception of the descriptor classes (`RNTupleDescriptor`, `RFieldDescriptor`, etc.).; Most classes in the upper layers provide public interfaces. | Layer | Description | Example of classes |; |------------|---------------------------------------------------------------------|-------------------------------------------------------------|; | Storage | Read and write pages (physical: file, object store; virtual: e.g. buffered) | RPage{Source,Sink}, RNTupleDescriptor, RClusterPool |; | Primitives | Storage-backed columns of simple types | RColumn, RColumnElement, RPage |; | Logical | Mapping of C++ types onto columns | RField, RNTupleModel, REntry |; | Iteration | Reading and writing events / properties | RNTuple{Reader,Writer}, RNTupleView, RNTupleDS (RDataFrame) |; | Tooling | Higher-level, RNTuple related utility classes | RNTupleMerger, RNTupleImporter, RNTupleInspector |. The RNTuple classes are, unless explicitly stated otherwise, conditionally thread safe. The read and write APIs provide templated, compile-time type-safe APIs,; APIs where the type at hand is passed as string and which are runtime type-safe,; and type-unsafe APIs using void pointers. On I/O errors and invalid input, RNTuple classes throw an `RException`. Walkthrough: Reading Data; -------------------------. ```c++; auto file = std::make_unique<TFile>(""data.root"");; auto ntuple = std::unique_ptr<RNTuple>(file->Get<RNTuple>(""ntpl""));. // Option 1: entire row; // The reader creates a page source; the page source creates a model from the on-disk information; auto reader = RNTupleReader::Open(ntuple);; // Populate the objects that are used in the model's defau",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:1584,simpl,simple,1584,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['simpl'],['simple']
Usability,"aryOp()); BinopPrecedence[P.getOperatorName()] = P.getBinaryPrecedence();. // Create a new basic block to start insertion into.; BasicBlock *BB = BasicBlock::Create(*TheContext, ""entry"", TheFunction);; ... Basically, before codegening a function, if it is a user-defined; operator, we register it in the precedence table. This allows the binary; operator parsing logic we already have in place to handle it. Since we; are working on a fully-general operator precedence parser, this is all; we need to do to ""extend the grammar"". Now we have useful user-defined binary operators. This builds a lot on; the previous framework we built for other operators. Adding unary; operators is a bit more challenging, because we don't have any framework; for it yet - let's see what it takes. User-defined Unary Operators; ============================. Since we don't currently support unary operators in the Kaleidoscope; language, we'll need to add everything to support them. Above, we added; simple support for the 'unary' keyword to the lexer. In addition to; that, we need an AST node:. .. code-block:: c++. /// UnaryExprAST - Expression class for a unary operator.; class UnaryExprAST : public ExprAST {; char Opcode;; std::unique_ptr<ExprAST> Operand;. public:; UnaryExprAST(char Opcode, std::unique_ptr<ExprAST> Operand); : Opcode(Opcode), Operand(std::move(Operand)) {}. Value *codegen() override;; };. This AST node is very simple and obvious by now. It directly mirrors the; binary operator AST node, except that it only has one child. With this,; we need to add the parsing logic. Parsing a unary operator is pretty; simple: we'll add a new function to do it:. .. code-block:: c++. /// unary; /// ::= primary; /// ::= '!' unary; static std::unique_ptr<ExprAST> ParseUnary() {; // If the current token is not an operator, it must be a primary expr.; if (!isascii(CurTok) || CurTok == '(' || CurTok == ','); return ParsePrimary();. // If this is a unary operator, read it.; int Opc = CurTok;; getNextTo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:10525,simpl,simple,10525,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['simpl'],['simple']
Usability,"as a pointer to such a Boolean node. Since the shape; components may also be composites, they will also contain binary Boolean; nodes branching out other two shapes in the hierarchy. Any such branch; ends-up when the final leaves are no longer composite shapes, but basic; primitives. The figure shows the composite shapes structure. ![The composite shapes structure](pictures/080001CA.png). Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do; this only for understanding how to create them in a proper way, since; the user interface for this purpose is in fact very simple. We will; ignore for the time being the positioning of components. The definition; of a composite shape takes an expression where the identifiers are shape; names. The expression is parsed and decomposed in 2 sub-expressions and; the top-level Boolean operator. 1. Union: `A+B+C`. Just to illustrate the Boolean expression parsing and the composite; shape structure, let's take a simple example. We will describe the union; of A, B and C. Both union operators are at the same level. Since:. `A+B+C = (A+B)+C = A+(B+C)`. The first` (+)` is taken as separator, hence the expression split in:; `A` and `(B+C)`. A Boolean node of type **`TGeoUnion`**`(""A"",""B+C"")` is; created. This tries to replace the 2 expressions by actual pointers to; corresponding shapes. The first expression (A) contains no operators; therefore is interpreted as representing a shape. The shape named ""A"" is; searched into the list of shapes handled by the manager class and stored; as the ""left"" shape in the Boolean union node. Since the second; expression is not yet fully decomposed, the ""right"" shape in the; combination is created as a new composite shape. This will split at its; turn B+C into B and C and create a **`TGeoUnion`**`(""B"",""C"")`. The B and; C identifiers will be looked for and replaced by the pointers to the; actual shapes into the new node. Fin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:44788,simpl,simple,44788,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"as a single dataset (syntax:; ""dataset1|dataset2|..."");  - 'keep; separated':; the datasets are processed one after the other; the user is notified in; the selector of the change of dataset so they have the opportunity to; separate the results. A new packetizer, TPacketizerMulti, has been; developed for this case: it basically contains a list of standard; packetizers (one for each dataset) and loops over them (syntax:; ""dataset1,dataset2,..."" or dataset1 dataset2 ..."").; In; both cases, entry-list can be applied using the syntax; ""dataset<<entrylist"", e.g.; ""dataset1<<el1|dataset2<<el2|"".; The datasets to be processed can also be specified on one or multiple lines in a text file.; Add; support for automatic download of a package when available on the; master but not locally. The downloaded packages are store under <sandbox>/packages/downloaded; and automatically checked for updates against the master repository. If; a local version of the same package is created (using the; UploadPackage) the entry in downloaded is; cleared, so that the behaviour is unchanged.; Add; the possibility to remap the server for the files in a dataset. This; allows, for example, to reuse the dataset information for the same; files stored in a different cluster.; Add a local cache for; TDataSetManagerFile. This is mainly used to improve the speed of; TDataSetManager::ShowDataSets, which is run very often by users and may; be very slow if the number of dataset is large. The cache is also used; to cache frequently received dataset objects.Add the possibility to audit the activity on the nodes via syslog. .; New packetizer TPacketizerFile generating packets which contain a single; file path to be used in processing single files. Used, for example, in; tasks generating files. The files are specified into a TMap - named; 'PROOF_FilesToProcess' - containing the list of files to be generated; per host (the key is the host name, the value the TList of TObjString; (or TFileInfo) with the files names ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:1252,clear,cleared,1252,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,1,['clear'],['cleared']
Usability,"as queries between each pair of pointers in the; function. This is inspired and adapted from code by: Naveen Neelakantam, Francesco; Spadini, and Wojciech Stryjewski. ``basic-aa``: Basic Alias Analysis (stateless AA impl); ------------------------------------------------------. A basic alias analysis pass that implements identities (two different globals; cannot alias, etc), but does no stateful analysis. ``basiccg``: Basic CallGraph Construction; -----------------------------------------. Yet to be written. .. _passes-da:. ``da``: Dependence Analysis; ---------------------------. Dependence analysis framework, which is used to detect dependences in memory; accesses. ``domfrontier``: Dominance Frontier Construction; ------------------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominator frontiers. ``domtree``: Dominator Tree Construction; ----------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominators. ``dot-callgraph``: Print Call Graph to ""dot"" file; -------------------------------------------------. This pass, only available in ``opt``, prints the call graph into a ``.dot``; graph. This graph can then be processed with the ""dot"" tool to convert it to; postscript or some other suitable format. ``dot-cfg``: Print CFG of function to ""dot"" file; ------------------------------------------------. This pass, only available in ``opt``, prints the control flow graph into a; ``.dot`` graph. This graph can then be processed with the :program:`dot` tool; to convert it to postscript or some other suitable format.; Additionally the ``-cfg-func-name=<substring>`` option can be used to filter the; functions that are printed. All functions that contain the specified substring; will be printed. ``dot-cfg-only``: Print CFG of function to ""dot"" file (with no function bodies); -------------------------------------------------------------------------------. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:2402,simpl,simple,2402,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simple']
Usability,"ased frequently. Often the differences between build; numbers being a few bug fixes or minor feature improvements. When using; the analyzer, we recommend that you check back here occasionally for new; builds, especially if the build you are using is more than a couple; weeks old.; The latest build is:; . Packaged builds for other platforms may eventually be provided, but; we need volunteers who are willing to help provide such regular builds.; If you wish to help contribute regular builds of the analyzer on other; platforms, please email the Clang; Developers' mailing list.; Using Packaged Builds; To use a package build, simply unpack it anywhere. If the build; archive has the name checker-XXX.tar.bz2 then the; archive will expand to a directory called checker-XXX.; You do not need to place this directory or the contents of this; directory in any special place. Uninstalling the analyzer is as simple; as deleting this directory.; Most of the files in the checker-XXX directory will; be supporting files for the analyzer that you can simply ignore. Most; users will only care about two files, which are located at the top of; the checker-XXX directory:. scan-build: scan-build is the high-level command line utility for running the analyzer; scan-view: scan-view a companion command line; utility to scan-build, scan-view is used to view; analysis results generated by scan-build. There is an option; that one can pass to scan-build to cause scan-view to; run as soon as it the analysis of a build completes. Running scan-build; For specific details on using scan-build, please see; scan-build's documentation.; To run scan-build, either add the; checker-XXX directory to your path or specify a complete; path for scan-build when running it. It is also possible to use; a symbolic link to scan-build, such one located in a directory; in your path. When scan-build runs it will automatically; determine where to find its accompanying files.; Other Platforms (Building the Analyzer from Sour",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/installation.html:1454,simpl,simply,1454,interpreter/llvm-project/clang/www/analyzer/installation.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/installation.html,1,['simpl'],['simply']
Usability,"at is executing; the focused thread of execution for languages that are implemented using a SIMD; or SIMT execution model. The ``DW_ASPACE_AMDGPU_private_wave`` address space allows location expressions; to specify the unswizzled private address space corresponding to the wavefront; that is executing the focused thread of execution. The wavefront view of private; memory is the per wavefront unswizzled backing memory layout defined in; :ref:`amdgpu-address-spaces`, such that address 0 corresponds to the first; location for the backing memory of the wavefront (namely the address is not; offset by ``wavefront-scratch-base``). The following formula can be used to; convert from a ``DW_ASPACE_AMDGPU_private_lane`` address to a; ``DW_ASPACE_AMDGPU_private_wave`` address:. ::. private-address-wavefront =; ((private-address-lane / 4) * wavefront-size * 4) +; (wavefront-lane-id * 4) + (private-address-lane % 4). If the ``DW_ASPACE_AMDGPU_private_lane`` address is dword aligned, and the start; of the dwords for each lane starting with lane 0 is required, then this; simplifies to:. ::. private-address-wavefront =; private-address-lane * wavefront-size. A compiler can use the ``DW_ASPACE_AMDGPU_private_wave`` address space to read a; complete spilled vector register back into a complete vector register in the; CFI. The frame pointer can be a private lane address which is dword aligned,; which can be shifted to multiply by the wavefront size, and then used to form a; private wavefront address that gives a location for a contiguous set of dwords,; one per lane, where the vector register dwords are spilled. The compiler knows; the wavefront size since it generates the code. Note that the type of the; address may have to be converted as the size of a; ``DW_ASPACE_AMDGPU_private_lane`` address may be smaller than the size of a; ``DW_ASPACE_AMDGPU_private_wave`` address. .. _amdgpu-dwarf-lane-identifier:. Lane identifier; ---------------. DWARF lane identifies specify a target architec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:96878,simpl,simplifies,96878,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['simpl'],['simplifies']
Usability,"at least add CivetWeb version and operating system.; Please see also the guidelines for [Contributions](https://github.com/civetweb/civetweb/blob/master/docs/Contribution.md) and the [Security Policy](https://github.com/civetweb/civetweb/blob/master/SECURITY.md). Note: We do not take any liability or warranty for any linked contents. Visit these pages and try the community support suggestions at your own risk.; Any link provided in this project (including source and documentation) is provided in the hope that this information will be helpful.; However, we cannot accept any responsibility for any content on an external page. Contributions; -------------. Contributions are welcome provided all contributions carry the MIT license. DO NOT APPLY fixes copied from Mongoose to this project to prevent GPL tainting.; Since 2013, CivetWeb and Mongoose are developed independently.; By now the code base differs, so patches cannot be safely transferred in either direction. Some guidelines can be found in [docs/Contribution.md](https://github.com/civetweb/civetweb/blob/master/docs/Contribution.md). Authors; -------. CivetWeb has been forked from the last MIT version of Mongoose in 2013.; Since then, CivetWeb has seen many improvements from various authors; (Copyright (c) 2013-2021 the CivetWeb developers, MIT license). A list of authors can be found in [CREDITS.md](https://github.com/civetweb/civetweb/blob/master/CREDITS.md). CivetWeb is based on the Mongoose project. The original author of Mongoose was; Sergey Lyubka (Copyright (c) 2004-2013 Sergey Lyubka, MIT license).; However, on August 16, 2013, the [license of Mongoose has been changed](https://groups.google.com/forum/#!topic/mongoose-users/aafbOnHonkI); after writing and distributing the original code this project is based on.; The license change and CivetWeb used to be mentioned on the Mongoose; [Wikipedia](https://en.wikipedia.org/wiki/Mongoose_(web_server)); page as well, but it's getting deleted (and added again) there",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:9773,guid,guidelines,9773,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['guid'],['guidelines']
Usability,"at makes it easier to refer to the; coroutine frame. .. _coro.id:. 'llvm.coro.id' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare token @llvm.coro.id(i32 <align>, ptr <promise>, ptr <coroaddr>,; ptr <fnaddrs>). Overview:; """""""""""""""""". The '``llvm.coro.id``' intrinsic returns a token identifying a; switched-resume coroutine. Arguments:; """""""""""""""""""". The first argument provides information on the alignment of the memory returned; by the allocation function and given to `coro.begin` by the first argument. If; this argument is 0, the memory is assumed to be aligned to 2 * sizeof(ptr).; This argument only accepts constants. The second argument, if not `null`, designates a particular alloca instruction; to be a `coroutine promise`_. The third argument is `null` coming out of the frontend. The CoroEarly pass sets; this argument to point to the function this coro.id belongs to. The fourth argument is `null` before coroutine is split, and later is replaced; to point to a private global constant array containing function pointers to; outlined resume and destroy parts of the coroutine. Semantics:; """""""""""""""""""". The purpose of this intrinsic is to tie together `coro.id`, `coro.alloc` and; `coro.begin` belonging to the same coroutine to prevent optimization passes from; duplicating any of these instructions unless entire body of the coroutine is; duplicated. A frontend should emit exactly one `coro.id` intrinsic per coroutine. A frontend should emit function attribute `presplitcoroutine` for the coroutine. .. _coro.id.async:. 'llvm.coro.id.async' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare token @llvm.coro.id.async(i32 <context size>, i32 <align>,; ptr <context arg>,; ptr <async function pointer>). Overview:; """""""""""""""""". The '``llvm.coro.id.async``' intrinsic returns a token identifying an async coroutine. Arguments:; """""""""""""""""""". The first argument provides the initial size of the `async context` as required; from the frontend. Lowering will add to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:37827,resume,resume,37827,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"at the argument means; without requiring it to use a specific presentation (consider this MVC for; Clang :). It is really easy to add format specifiers to the Clang diagnostics system, but; they should be discussed before they are added. If you are creating a lot of; repetitive diagnostics and/or have an idea for a useful formatter, please bring; it up on the cfe-dev mailing list. Here are the different diagnostic argument formats currently supported by; Clang:. **""s"" format**. Example:; ``""requires %0 parameter%s0""``; Class:; Integers; Description:; This is a simple formatter for integers that is useful when producing English; diagnostics. When the integer is 1, it prints as nothing. When the integer; is not 1, it prints as ""``s``"". This allows some simple grammatical forms to; be to be handled correctly, and eliminates the need to use gross things like; ``""requires %1 parameter(s)""``. Note, this only handles adding a simple; ""``s``"" character, it will not handle situations where pluralization is more; complicated such as turning ``fancy`` into ``fancies`` or ``mouse`` into; ``mice``. You can use the ""plural"" format specifier to handle such situations. **""select"" format**. Example:; ``""must be a %select{unary|binary|unary or binary}0 operator""``; Class:; Integers; Description:; This format specifier is used to merge multiple related diagnostics together; into one common one, without requiring the difference to be specified as an; English string argument. Instead of specifying the string, the diagnostic; gets an integer argument and the format string selects the numbered option.; In this case, the ""``%0``"" value must be an integer in the range [0..2]. If; it is 0, it prints ""unary"", if it is 1 it prints ""binary"" if it is 2, it; prints ""unary or binary"". This allows other language translations to; substitute reasonable words (or entire phrases) based on the semantics of the; diagnostic instead of having to do things textually. The selected string; does undergo formatt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:10798,simpl,simple,10798,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"at the function type must match the signature of the callee and the; types of the 'call parameters' arguments. The '#call args' operand is the number of arguments to the actual; call. It must exactly match the number of arguments passed in the; 'call parameters' variable length section. The 'flags' operand is used to specify extra information about the; statepoint. This is currently only used to mark certain statepoints; as GC transitions. This operand is a 64-bit integer with the following; layout, where bit 0 is the least significant bit:. +-------+---------------------------------------------------+; | Bit # | Usage |; +=======+===================================================+; | 0 | Set if the statepoint is a GC transition, cleared |; | | otherwise. |; +-------+---------------------------------------------------+; | 1-63 | Reserved for future use; must be cleared. |; +-------+---------------------------------------------------+. The 'call parameters' arguments are simply the arguments which need to; be passed to the call target. They will be lowered according to the; specified calling convention and otherwise handled like a normal call; instruction. The number of arguments must exactly match what is; specified in '# call args'. The types must match the signature of; 'target'. The 'call parameter' attributes must be followed by two 'i64 0' constants.; These were originally the length prefixes for 'gc transition parameter' and; 'deopt parameter' arguments, but the role of these parameter sets have been; entirely replaced with the corresponding operand bundles. In a future; revision, these now redundant arguments will be removed. Semantics:; """""""""""""""""""". A statepoint is assumed to read and write all memory. As a result,; memory operations can not be reordered past a statepoint. It is; illegal to mark a statepoint as being either 'readonly' or 'readnone'. Note that legal IR can not perform any memory operation on a 'gc; pointer' argument of the statepoint in a loc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:502545,simpl,simply,502545,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"at you use this technique for building SSA form,; unless there is an extremely good reason not to. Using this technique; is:. - Proven and well tested: clang uses this technique; for local mutable variables. As such, the most common clients of LLVM; are using this to handle a bulk of their variables. You can be sure; that bugs are found fast and fixed early.; - Extremely Fast: mem2reg has a number of special cases that make it; fast in common cases as well as fully general. For example, it has; fast-paths for variables that are only used in a single block,; variables that only have one assignment point, good heuristics to; avoid insertion of unneeded phi nodes, etc.; - Needed for debug info generation: `Debug information in; LLVM <../../SourceLevelDebugging.html>`_ relies on having the address of; the variable exposed so that debug info can be attached to it. This; technique dovetails very naturally with this style of debug info. If nothing else, this makes it much easier to get your front-end up and; running, and is very simple to implement. Let's extend Kaleidoscope with; mutable variables now!. Mutable Variables in Kaleidoscope; =================================. Now that we know the sort of problem we want to tackle, let's see what; this looks like in the context of our little Kaleidoscope language.; We're going to add two features:. #. The ability to mutate variables with the '=' operator.; #. The ability to define new variables. While the first item is really what this is about, we only have; variables for incoming arguments as well as for induction variables, and; redefining those only goes so far :). Also, the ability to define new; variables is a useful thing regardless of whether you will be mutating; them. Here's a motivating example that shows how we could use these:. ::. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. # Recursive fib, we could do this before.; def fib(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:10120,simpl,simple,10120,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['simpl'],['simple']
Usability,"at; :ref:`DenseMap <dss_densemap>` has. .. _dss_sparseset:. llvm/ADT/SparseSet.h; ^^^^^^^^^^^^^^^^^^^^. SparseSet holds a small number of objects identified by unsigned keys of; moderate size. It uses a lot of memory, but provides operations that are almost; as fast as a vector. Typical keys are physical registers, virtual registers, or; numbered basic blocks. SparseSet is useful for algorithms that need very fast clear/find/insert/erase; and fast iteration over small sets. It is not intended for building composite; data structures. .. _dss_sparsemultiset:. llvm/ADT/SparseMultiSet.h; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SparseMultiSet adds multiset behavior to SparseSet, while retaining SparseSet's; desirable attributes. Like SparseSet, it typically uses a lot of memory, but; provides operations that are almost as fast as a vector. Typical keys are; physical registers, virtual registers, or numbered basic blocks. SparseMultiSet is useful for algorithms that need very fast; clear/find/insert/erase of the entire collection, and iteration over sets of; elements sharing a key. It is often a more efficient choice than using composite; data structures (e.g. vector-of-vectors, map-of-vectors). It is not intended for; building composite data structures. .. _dss_FoldingSet:. llvm/ADT/FoldingSet.h; ^^^^^^^^^^^^^^^^^^^^^. FoldingSet is an aggregate class that is really good at uniquing; expensive-to-create or polymorphic objects. It is a combination of a chained; hash table with intrusive links (uniqued objects are required to inherit from; FoldingSetNode) that uses :ref:`SmallVector <dss_smallvector>` as part of its ID; process. Consider a case where you want to implement a ""getOrCreateFoo"" method for a; complex object (for example, a node in the code generator). The client has a; description of **what** it wants to generate (it knows the opcode and all the; operands), but we don't want to 'new' a node, then try inserting it into a set; only to find out it already exists, at which po",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:81393,clear,clear,81393,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['clear'],['clear']
Usability,"at; =========. LibFormat is a library that implements automatic source code formatting based; on Clang. This documents describes the LibFormat interface and design as well; as some basic style discussions. If you just want to use `clang-format` as a tool or integrated into an editor,; checkout :doc:`ClangFormat`. Design; ------. FIXME: Write up design. Interface; ---------. The core routine of LibFormat is ``reformat()``:. .. code-block:: c++. tooling::Replacements reformat(const FormatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();. /// Returns a f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:1081,guid,guides,1081,interpreter/llvm-project/clang/docs/LibFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst,1,['guid'],['guides']
Usability,"ata types"");; tree->Branch(""floatVal"", &floatVal, ""floatVal/f""); // Float16_t value with default settings; tree->Branch(""floatArray"", floatArray, ""floatArray[7]/f[0,100]""); // Float16_t array with range from 0 to 100; tree->Branch(""doubleVal"", &doubleVal, ""doubleVal/d[0,1000,20]""); // Double32_t value with range from 0 to 1000 and 20 bits; tree->Branch(""doubleArray"", doubleArray, ""doubleArray[5]/d[0,0,18]""); // Double32_t array without range and 18 bits; ~~~. ### Bulk I/O; - The new `TBulkBranchRead` class (inside the `ROOT::Experimental::Internal` namespace) provides; a mechanism for reading, in a single library call, many events' worth of simple data (primitive types,; arrays of primitives, split structures) stored in a `TTree`. This allows for extremely fast delivery; of event data to the process. This is meant as an internal interface that allows the ROOT team to; implement faster high-level interface.; - The `TTreeReaderFast ` class (inside the `ROOT::Experimental::Internal` namespace) provides a simple; mechanism for reading ntuples with the bulk IO interface. ## Histogram Libraries. ### TH1; - Add a search range to the `TH1::FindFirstBinAbove(..)` and `TH1::FindLastBinAvove(..)` functions. ### TH2Poly; - Add implementation of `SetBinError` and fix a bug in `GetBinError` in case of weighted events. ### TF1; - The implementation of `TF1::GetX` has been improved. In case of the presence of multiple roots, the function will return the root with the lower x value. In case of no-roots a NaN will be returned instead of returning a random incorrect value. ### TKDE; - Add support for I/O. ## Math Libraries; - Add `TComplex` value printer for printing the value of object at the root prompt and in python; - Add to the documentation of `TLorentzVector` a link to `ROOT::Math::LorentzVector`, which is a superior tool.; - Add new implementation of `TStatistic::Merge` able to deal silently with empty TStatistic objects. This implementation is useful when filling TStatistics w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:11381,simpl,simple,11381,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['simpl'],['simple']
Usability,"ated to finer grained read and write locks in a few hotspots that occur during file opening/closing or task initialization in RDataFrame. This can lead to O(100x) improvements for some typical RDataFrame scenarios with 256 threads due to massively reduced lock contention. ## TTree Libraries. - `TTree` now supports the inclusion of leaves of types `long` and `unsigned long` (and therefore also `std::size_t` on most systems) also for branches in ""leaflist mode"". The corresponding leaflist letters are 'G' and 'g'.; - when looping over a `TTree` with a friend with a larger number of entries, `TTreeReader` now ends the event loop when the entries in the _main_ `TTree` are exhausted, consistently with other interfaces. See [#6518](https://github.com/root-project/root/issues/6518) for more details.; - `TTreeProcessorMT::SetMaxTasksPerFilePerWorker` is now deprecated in favor of the more flexible and newly introduced `TTreeProcessorMT::SetTasksPerWorkerHint`. See the relevant entries in our reference guide for more information.; - The name of the sub-branches of a split collection no longer have 2 consecutive dots if the top level branche name has a trailing dot. The name of the collection's index leaf also no longer include the dot. For example for ""t."" the names where ""t._"" and ""t..fValue"" and are now ""t_"" and ""t.fValue"". . ## RDataFrame. ### New features. - Introduce `ROOT::RDF::RunGraphs`, which allows to compute the results of multiple `RDataFrame`s (or better, multiple independent computation graphs) concurrently while sharing the same thread pool. The computation may be more efficient than running the `RDataFrame`s sequentially if an analysis consists of several computation graphs that individually do not fully utilize the available resources. See e.g. [this tutorial](https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html) for an example usage.; - `RDataFrame` now supports reading friend `TTree`s with a `TTreeIndex`, aka ""indexed friends"". More details at [RO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:5356,guid,guide,5356,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['guid'],['guide']
Usability,"athText interface](https://root.cern.ch/doc/master/classTMathText.html); is invoked. It provides the plain TeX syntax and allow to access character's; set like Russian and Japanese. ## Interpretation and Compilation. As you observed, up to now we heavily exploited the capabilities of ROOT; for interpreting our code, more than compiling and then executing. This; is sufficient for a wide range of applications, but you might have; already asked yourself ""how can this code be compiled ?"". There are two; answers. ### Compile a Macro with ACLiC. ACLiC will create for you a compiled dynamic library for your macro,; without any effort from your side, except the insertion of the; appropriate header files in lines *5--11*. In this example, they are; already included. To generate an object library from the macro code, from inside the; interpreter type (please note the ""+""):. ``` {.cpp}; root [1] .L macro1.C+; ```. Once this operation is accomplished, the macro symbols will be available; in memory and you will be able to execute it simply by calling from; inside the interpreter:. ``` {.cpp}; root [2] macro1(); ```. ### Compile a Macro with the Compiler. A plethora of excellent compilers are available, both free and; commercial. We will refer to the `GCC` compiler in the following. In; this case, you have to include the appropriate headers in the code and; then exploit the *root-config* tool for the automatic settings of all; the compiler flags. *root-config* is a script that comes with ROOT; it; prints all flags and libraries needed to compile code and link it with; the ROOT libraries. In order to make the code executable stand-alone, an; entry point for the operating system is needed, in C++ this is the; procedure `int main();`. The easiest way to turn a ROOT macro code into; a stand-alone application is to add the following ""dressing code"" at the; end of the macro file. This defines the procedure main, the only purpose; of which is to call your macro:. ``` {.cpp}; int main() ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:9811,simpl,simply,9811,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['simpl'],['simply']
Usability,"atically when objects are; added. At creation time one specifies the default array size (default =; 16) and lower bound (default = 0). Resizing involves a re-allocation and; a copy of the old array to the new. This can be costly if done too; often. If possible, set initial size close to expected final size. Index; validity is always checked (if you are 100% sure and maximum performance; is needed you can use `UnCheckedAt()` instead of `At()` or; `operator[]`). If the stored objects are sort able the array can be; sorted using `Sort()`. Once sorted, efficient searching is possible via; the `BinarySearch()` method. The figure shows the internal data; structure of a **`TObjArray`**:. ![The internal data structure of a TObjArray](pictures/020001A7.jpg). Iterating can be done using a **`TIter`** iterator or via a simple for; loop:. ``` {.cpp}; for (int i = 0; i <= fArr.GetLast(); i++); if ((track = (TTrack*)fArr[i])) // or fArr.At(i); track->Draw();; ```. Main features of **`TObjArray`** are simple, well-known array semantics.; **Overhead per element**: none, except possible over sizing of `fCont`. ## TClonesArray An Array of Identical Objects. A **`TClonesArray`** is an array of identical (clone) objects. The; memory for the objects stored in the array is allocated only once in the; lifetime of the clones array. All objects must be of the same class. For; the rest this class has the same properties as a **`TObjArray`**. ![The internal data structure of a TClonesArray](pictures/020001A8.jpg). The figure above shows the internal data structure of a; **`TClonesArray`**. The class is specially designed for repetitive data; analysis tasks, where in a loop many times the same objects, are created; and deleted. The only supported way to add objects to a; **`TClonesArray`** is via the `new` with placement method. The different; `Add()` methods of **`TObjArray`** and its base classes are not; supported. ### The Idea Behind TClonesArray. To reduce the very large number of new and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:15966,simpl,simple,15966,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['simpl'],['simple']
Usability,"ating the; memory for the `async context` but can use the `async function pointer` struct; to obtain the required size. .. code-block:: c. struct async_function_pointer {; uint32_t relative_function_pointer_to_async_impl;; uint32_t context_size;; }. Lowering will split an async coroutine into a ramp function and one resume; function per suspend point. How control-flow is passed between caller, suspension point, and back to; resume function is left up to the frontend. The suspend point takes a function and its arguments. The function is intended; to model the transfer to the callee function. It will be tail called by; lowering and therefore must have the same signature and calling convention as; the async coroutine. .. code-block:: llvm. call {ptr, ptr, ptr} (ptr, ptr, ...) @llvm.coro.suspend.async(; ptr %resume_func_ptr,; ptr %context_projection_function,; ptr %suspend_function,; ptr %arg1, ptr %arg2, i8 %arg3). Coroutines by Example; =====================. The examples below are all of switched-resume coroutines. Coroutine Representation; ------------------------. Let's look at an example of an LLVM coroutine with the behavior sketched; by the following pseudo-code. .. code-block:: c++. void *f(int n) {; for(;;) {; print(n++);; <suspend> // returns a coroutine handle on first suspend; }; }. This coroutine calls some function `print` with value `n` as an argument and; suspends execution. Every time this coroutine resumes, it calls `print` again with an argument one bigger than the last time. This coroutine never completes by itself and must be destroyed explicitly. If we use this coroutine with; a `main` shown in the previous section. It will call `print` with values 4, 5; and 6 after which the coroutine will be destroyed. The LLVM IR for this coroutine looks like this:. .. code-block:: llvm. define ptr @f(i32 %n) presplitcoroutine {; entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %size = call i32 @llvm.coro.size.i32(); %alloc = call pt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:10760,resume,resume,10760,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ation code:. .. code-block:: llvm. cleanup:; %mem = call ptr @llvm.coro.free(token %id, ptr %hdl); %need.dyn.free = icmp ne ptr %mem, null; br i1 %need.dyn.free, label %dyn.free, label %if.end; dyn.free:; call void @CustomFree(ptr %mem); br label %if.end; if.end:; ... With allocations and deallocations represented as described as above, after; coroutine heap allocation elision optimization, the resulting main will be:. .. code-block:: llvm. define i32 @main() {; entry:; call void @print(i32 4); call void @print(i32 5); call void @print(i32 6); ret i32 0; }. Multiple Suspend Points; -----------------------. Let's consider the coroutine that has more than one suspend point:. .. code-block:: c++. void *f(int n) {; for(;;) {; print(n++);; <suspend>; print(-n);; <suspend>; }; }. Matching LLVM code would look like (with the rest of the code remaining the same; as the code in the previous section):. .. code-block:: llvm. loop:; %n.addr = phi i32 [ %n, %entry ], [ %inc, %loop.resume ]; call void @print(i32 %n.addr) #4; %2 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %2, label %suspend [i8 0, label %loop.resume; i8 1, label %cleanup]; loop.resume:; %inc = add nsw i32 %n.addr, 1; %sub = xor i32 %n.addr, -1; call void @print(i32 %sub); %3 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %3, label %suspend [i8 0, label %loop; i8 1, label %cleanup]. In this case, the coroutine frame would include a suspend index that will; indicate at which suspend point the coroutine needs to resume. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32, i32 }. The resume function will use an index to jump to an appropriate basic block and will look; as follows:. .. code-block:: llvm. define internal fastcc void @f.Resume(ptr %FramePtr) {; entry.Resume:; %index.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 2; %index = load i8, ptr %index.addr, align 1; %switch = icmp eq i8 %index, 0; %n.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:18386,resume,resume,18386,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ation with additional labels to define where control; flow goes after the call. The output values of a '``callbr``' instruction are available only to; the '``fallthrough``' block, not to any '``indirect``' blocks(s). The only use of this today is to implement the ""goto"" feature of gcc inline; assembly where additional labels can be provided as locations for the inline; assembly to jump to. Example:; """""""""""""""". .. code-block:: llvm. ; ""asm goto"" without output constraints.; callbr void asm """", ""r,!i""(i32 %x); to label %fallthrough [label %indirect]. ; ""asm goto"" with output constraints.; <result> = callbr i32 asm """", ""=r,r,!i""(i32 %x); to label %fallthrough [label %indirect]. .. _i_resume:. '``resume``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. resume <type> <value>. Overview:; """""""""""""""""". The '``resume``' instruction is a terminator instruction that has no; successors. Arguments:; """""""""""""""""""". The '``resume``' instruction requires one argument, which must have the; same type as the result of any '``landingpad``' instruction in the same; function. Semantics:; """""""""""""""""""". The '``resume``' instruction resumes propagation of an existing; (in-flight) exception whose unwinding was interrupted with a; :ref:`landingpad <i_landingpad>` instruction. Example:; """""""""""""""". .. code-block:: llvm. resume { ptr, i32 } %exn. .. _i_catchswitch:. '``catchswitch``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind to caller; <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind label <default>. Overview:; """""""""""""""""". The '``catchswitch``' instruction is used by `LLVM's exception handling system; <ExceptionHandling.html#overview>`_ to describe the set of possible catch handlers; that may be executed by the :ref:`EH personality routine <personalityfn>`. Arguments:; """""""""""""""""""". The ``parent`` argument is the token of the funclet t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:369937,resume,resume,369937,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['resume'],['resume']
Usability,"ations are required to be instantiated separately (this; includes default arguments and exception specifications), and such; instantiations update the existing declaration. These cases tend to be fragile; mutable AST state should be avoided where; possible. As a consequence of this design principle, we typically do not provide setters; for AST state. (Some are provided for short-term modifications intended to be; used immediately after an AST node is created and before it's ""published"" as; part of the complete AST, or where language semantics require after-the-fact; updates.). Faithfulness; ^^^^^^^^^^^^. The AST intends to provide a representation of the program that is faithful to; the original source. We intend for it to be possible to write refactoring tools; using only information stored in, or easily reconstructible from, the Clang AST.; This means that the AST representation should either not desugar source-level; constructs to simpler forms, or -- where made necessary by language semantics; or a clear engineering tradeoff -- should desugar minimally and wrap the result; in a construct representing the original source form. For example, ``CXXForRangeStmt`` directly represents the syntactic form of a; range-based for statement, but also holds a semantic representation of the; range declaration and iterator declarations. It does not contain a; fully-desugared ``ForStmt``, however. Some AST nodes (for example, ``ParenExpr``) represent only syntax, and others; (for example, ``ImplicitCastExpr``) represent only semantics, but most nodes; will represent a combination of syntax and associated semantics. Inheritance; is typically used when representing different (but related) syntaxes for nodes; with the same or similar semantics. .. _Type:. The ``Type`` class and its subclasses; -------------------------------------. The ``Type`` class (and its subclasses) are an important part of the AST.; Types are accessed through the ``ASTContext`` class, which implicitly creates",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:60232,simpl,simpler,60232,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,"['clear', 'simpl']","['clear', 'simpler']"
Usability,ations; Unknown. 2047; CD4; Coordinating “throws anything” specifications; Unknown. 2048; open; C-style casts that cast away constness vs static_cast; Not resolved. 2049; drafting; List initializer in non-type template default argument; Clang 18. 2050; NAD; Consolidate specification of linkage; Unknown. 2051; CD5; Simplifying alias rules; Unknown. 2052; CD4; Template argument deduction vs overloaded operators; Unknown. 2053; C++20; auto in non-generic lambdas; Unknown. 2054; DR; Missing description of class SFINAE; Unknown. 2055; drafting; Explicitly-specified non-deduced parameter packs; Not resolved. 2056; drafting; Member function calls in partially-initialized class objects; Not resolved. 2057; drafting; Template template arguments with default arguments; Not resolved. 2058; CD6; More errors from internal-linkage namespaces; Unknown. 2059; CD5; Linkage and deduced return types; Unknown. 2060; NAD; Deduced return type for explicit specialization; Unknown. 2061; CD4; Inline namespace after simplifications; Yes. 2062; CD6; Class template redeclaration requirements; Unknown. 2063; CD4; Type/nontype hiding in class scope; Unknown. 2064; CD4; Conflicting specifications for dependent decltype-specifiers; Unknown. 2065; CD6; Current instantiation of a partial specialization; Unknown. 2066; CD4; Does type-dependent imply value-dependent?; Unknown. 2067; open; Generated variadic templates requiring empty pack; Not resolved. 2068; CD4; When can/must a defaulted virtual destructor be defined?; Unknown. 2069; CD4; Do destructors have names?; Unknown. 2070; CD6; using-declaration with dependent nested-name-specifier; Unknown. 2071; CD4; typedef with no declarator; Unknown. 2072; C++23; Default argument instantiation for member functions of templates; Unknown. 2073; drafting; Allocating memory for exception objects; Not resolved. 2074; drafting; Type-dependence of local class of function template; Not resolved. 2075; CD4; Passing short initializer lists to array reference para,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:140101,simpl,simplifications,140101,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['simpl'],['simplifications']
Usability,"atrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; ~~~. Note, constructing of, say, TMatrixDDiag does *not* involve any; copying of any elements of the source matrix. #### 5. It's possible (and encouraged) to use ""nested"" functions; For example, creating of a Hilbert matrix can be done as follows:. ~~~ {.cpp}; void foo(const TMatrixD &m); {; TMatrixD m1(TMatrixD::kZero,m);; struct MakeHilbert : public TElementPosActionD {; void Operation(Double_t &element); { element = 1./(fI+fJ-1); }; };; m1.Apply(MakeHilbert());; }; ~~~. of course, using a special method THilbertMatrixD() is; still more optimal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix element:. ~~~ {.cpp}; void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }; ~~~. Validation code `$ROOTSYS/test/vmatrix.cxx` and `vvector.cxx` contain; a few more examples of that kind. #### 6. Lazy matrices:. instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:. ~~~ {.cpp}; TMatrixD haar = THaarMatrixD(5);; ~~~. THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md:17900,simpl,simple,17900,math/matrix/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md,1,['simpl'],['simple']
Usability,"ave been able to create our wire with a single line:. ~~~{.cpp}; TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"",ptrCOPPER,0,0.01,1); //(*); ~~~. (*) The same applies for all primitive shapes, for which there can; be found corresponding `MakeSHAPE()` methods. Their usage is much more; convenient unless a shape has to be shared between more volumes. Let us make now an aluminum wire having the same shape, supposing that; we have created the copper wire with the line above:. ~~~{.cpp}; TGeoVolume *wire_al = new TGeoVolume(""WIRE_AL"",wire_co>GetShape(),; ptrAL);; ~~~. We would like now to position our wire in the middle of a gas chamber.; We need first to define the gas chamber:. ~~~{.cpp}; TGeoVolume *chamber = gGeoManager->MakeTube(""CHAMBER"",ptrGAS,; 0,1,1);; ~~~. Now we can put the wire inside:. ~~~{.cpp}; chamber->AddNode(wire_co,1);; ~~~. If we inspect now the chamber volume in a browser, we will notice that; it has one daughter. Of course, the gas has some container also, but let; us keeps it like that for the sake of simplicity. Since we did not; supply the third argument, the wire will be positioned with an identity; transformation inside the chamber. \anchor GP01bf; #### Overlapping Volumes. Positioning volumes that does not overlap their neighbors nor extrude; their container is sometimes quite strong constraint. Having a limited; set of geometric shapes might force sometimes overlaps. Since; overlapping is contradictory to containment, a point belonging to an; overlapping region will naturally belong to all overlapping partners.; The answer provided by the modeller to ""Where am I?"" is no longer; deterministic if there is no priority assigned. There are two ways out provided by the modeller in such cases and we; will illustrate them by examples. - Suppose we have 2 crossing tubes that we have to describe. Such a; structure cannot be decomposed in a containment schema. This is a; typical example of simple structure that can be handled by using; composite sh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:35342,simpl,simplicity,35342,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simplicity']
Usability,"ave; it evaluate its conditional, then return the 'then' or 'else' value; based on how the condition was resolved. This is very similar to the C; ""?:"" expression. The semantics of the if/then/else expression is that it evaluates the; condition to a boolean equality value: 0.0 is considered to be false and; everything else is considered to be true. If the condition is true, the; first subexpression is evaluated and returned, if the condition is; false, the second subexpression is evaluated and returned. Since; Kaleidoscope allows side-effects, this behavior is important to nail; down. Now that we know what we ""want"", let's break this down into its; constituent pieces. Lexer Extensions for If/Then/Else; ---------------------------------. The lexer extensions are straightforward. First we add new enum values; for the relevant tokens:. .. code-block:: c++. // control; tok_if = -6,; tok_then = -7,; tok_else = -8,. Once we have that, we recognize the new keywords in the lexer. This is; pretty simple stuff:. .. code-block:: c++. ...; if (IdentifierStr == ""def""); return tok_def;; if (IdentifierStr == ""extern""); return tok_extern;; if (IdentifierStr == ""if""); return tok_if;; if (IdentifierStr == ""then""); return tok_then;; if (IdentifierStr == ""else""); return tok_else;; return tok_identifier;. AST Extensions for If/Then/Else; -------------------------------. To represent the new expression we add a new AST node for it:. .. code-block:: c++. /// IfExprAST - Expression class for if/then/else.; class IfExprAST : public ExprAST {; std::unique_ptr<ExprAST> Cond, Then, Else;. public:; IfExprAST(std::unique_ptr<ExprAST> Cond, std::unique_ptr<ExprAST> Then,; std::unique_ptr<ExprAST> Else); : Cond(std::move(Cond)), Then(std::move(Then)), Else(std::move(Else)) {}. Value *codegen() override;; };. The AST node just has pointers to the various subexpressions. Parser Extensions for If/Then/Else; ----------------------------------. Now that we have the relevant tokens coming from the lexer a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:2616,simpl,simple,2616,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['simpl'],['simple']
Usability,"aversed using the; ``CFGBlock::*iterator`` interface. A ``CFG`` object owns the instances of ``CFGBlock`` within the control-flow; graph it represents. Each ``CFGBlock`` within a CFG is also uniquely numbered; (accessible via ``CFGBlock::getBlockID()``). Currently the number is based on; the ordering the blocks were created, but no assumptions should be made on how; ``CFGBlocks`` are numbered other than their numbers are unique and that they; are numbered from 0..N-1 (where N is the number of basic blocks in the CFG). Entry and Exit Blocks; ^^^^^^^^^^^^^^^^^^^^^. Each instance of ``CFG`` contains two special blocks: an *entry* block; (accessible via ``CFG::getEntry()``), which has no incoming edges, and an; *exit* block (accessible via ``CFG::getExit()``), which has no outgoing edges.; Neither block contains any statements, and they serve the role of providing a; clear entrance and exit for a body of code such as a function body. The; presence of these empty blocks greatly simplifies the implementation of many; analyses built on top of CFGs. .. _ConditionalControlFlow:. Conditional Control-Flow; ^^^^^^^^^^^^^^^^^^^^^^^^. Conditional control-flow (such as those induced by if-statements and loops) is; represented as edges between ``CFGBlocks``. Because different C language; constructs can induce control-flow, each ``CFGBlock`` also records an extra; ``Stmt*`` that represents the *terminator* of the block. A terminator is; simply the statement that caused the control-flow, and is used to identify the; nature of the conditional control-flow between blocks. For example, in the; case of an if-statement, the terminator refers to the ``IfStmt`` object in the; AST that represented the given branch. To illustrate, consider the following code example:. .. code-block:: c++. int foo(int x) {; x = x + 1;; if (x > 2); x++;; else {; x += 2;; x *= 2;; }. return x;; }. After invoking the parser+semantic analyzer on this code fragment, the AST of; the body of ``foo`` is referenced by ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:113934,simpl,simplifies,113934,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simplifies']
Usability,"aw();; ```. Of course, this version shows the same results as the initial one. Try; playing with the parameters and plot the function again. The class `TF1`; has a large number of very useful methods, including integration and; differentiation. To make full use of this and other ROOT classes, visit; the documentation on the Internet under; <https://root.cern/doc/master/>. Formulae in ROOT; are evaluated using the class `TFormula`, so also look up the relevant; class documentation for examples, implemented functions and syntax. You should definitely download this guide to your own system to have it; at you disposal whenever you need it. To extend a little bit on the above example, consider a more complex; function you would like to define. You can also do this using standard; `C` or `C++` code. Consider the example below, which calculates and displays the; interference pattern produced by light falling on a multiple slit.; Please do not type in the example below at the ROOT command line, there; is a much simpler way: Make sure you have the file `slits.C` on disk,; and type `root slits.C` in the shell. This will start root and make it; read the ""macro"" `slits.C`, i.e. all the lines in the file will be; executed one after the other. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/slits.C; ```; [f21]: figures/TF1_DoubleSlit.png ""f21""; <a name=""f21""></a>. ![Output of slits.C with parameters 0.2 and 2.\label{f21}][f21]. The example first asks for user input, namely the ratio of slit width; over slit distance, and the number of slits. After entering this; information, you should see the graphical output as is shown in Figure [2.1](#f21). This is a more complicated example than the ones we have seen before, so; spend some time analysing it carefully, you should have understood it; before continuing. Let us go through it in detail:. Lines *7-18* define the necessary functions in `C++` code, split into; three separate functions, as suggested by the problem considered. The; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:5338,simpl,simpler,5338,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['simpl'],['simpler']
Usability,"awtText`, `TTF::SetTextSize` was called with a rounded; value (to pixel). This cause some misplacements of character in TLatex; formulae. ### TPDF and TPostScript. - Parenthesis can be used in PDF and PS file names.; - In PDF files, italic greek characters were not correct for non null; text angle. ### TImageDump; - Fix a `TBox` clipping issue. ### TSVG; - Some markers did not show in Google-Chrome. ### New class TTeXDump: Graphics interface to TeX. This class allow to generate `PGF/TikZ` vector graphics output; which can be included in TeX and LaTeX documents. `PGF` is a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friedly syntax layer called `TikZ`. To generate a such file it is enough to do:. ```; gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");; ```. Then, the generated file (<tt>hpx.tex</tt>) can be included in a; LaTeX document (`simple.tex`) in the following way:. ```; \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}; ```. Note the two directive needed at the top of the LaTeX file:. ```; \usepackage{tikz}; \usetikzlibrary{patterns}; ```. Then including the picture in the document is done with the; `\input` directive. The command `pdflatex simple.tex` will generate the corresponding pdf; file `simple.pdf`. ### X11 fonts. - A coverity fix in `Rotated.cxx` had a side effect on rotated text; drawn with X11 fonts. ### TCanvas and TPad. - `TPad::SaveAs` produces named macros in .C files.; - Change the way the string input is done in the Pad toolbar for text; and Pave Label. It doesn't use anymore the `TGX11` function `RequestString`.; Now the text appears directly as it will show and it is poss",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md:1209,simpl,simple,1209,graf2d/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md,1,['simpl'],['simple']
Usability,"ay after a click on ‘axis'—the axis editor is active; a click on a; ‘pad' activates the pad editor, etc. The algorithm in use is simple and is based on the object-oriented; relationship and communication. When the user activates the editor,; according to the selected object **`<obj>`** in the canvas it looks for; a class name **`<obj>Editor`**. For that reason, the correct naming is; very important. If a class with this name is found, the editor verifies; that this class derives from the base editor class **`TGedFrame`**. If; all checks are satisfied, the editor makes an instance of the object; editor. Then, it scans all object base classes searching the; corresponding object editors. When it finds one, it makes an instance of; the base class editor too. Once the object editor is in place, it sets the user interface elements; according to the object's status. After that, it is ready to interact; with the object following the user actions. The graphics editor gives an intuitive way to edit objects in a canvas; with immediate feedback. Complexity of some object editors is reduced by; hiding GUI elements and revealing them only on users' requests. An object in the canvas is selected by clicking on it with the left; mouse button. Its name is displayed on the top of the editor frame in; red color. If the editor frame needs more space than the canvas window,; a vertical scroll bar appears for easy navigation. ![Histogram, pad and axis editors](pictures/03000222.png). ### Editor Design Elements. The next rules describe the path to follow when creating your own object; editor that will be recognized and loaded by the graphics editor in; ROOT, i.e. it will be included as a part of it. (a) Derive the code of your object editor from the base editor class; **`TGedFrame`**. (b) Keep the correct naming convention: the name of the object editor; should be the object class name concatenated with the word `‘Editor'`. (c) Provide a default constructor. (d) Use the signals/slots commun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:103790,intuit,intuitive,103790,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,2,"['feedback', 'intuit']","['feedback', 'intuitive']"
Usability,"ay after a click on ‘axis'—the axis editor is active; a click on a; ‘pad' activates the pad editor, etc. The algorithm in use is simple and is based on the object-oriented; relationship and communication. When the user activates the editor,; according to the selected object **`<obj>`** in the canvas it looks for; a class name **`<obj>Editor`**. For that reason, the correct naming is; very important. If a class with this name is found, the editor verifies; that this class derives from the base editor class **`TGedFrame`**. If; all checks are satisfied, the editor makes an instance of the object; editor. Then, it scans all object base classes searching the; corresponding object editors. When it finds one, it makes an instance of; the base class editor too. Once the object editor is in place, it sets the user interface elements; according to the object's status. After that, it is ready to interact; with the object following the user actions. The graphics editor gives an intuitive way to edit objects in a canvas; with immediate feedback. Complexity of some object editors is reduced by; hiding GUI elements and revealing them only on users' requests. An object in the canvas is selected by clicking on it with the left; mouse button. Its name is displayed on the top of the editor frame in; red color. If the editor frame needs more space than the canvas window,; a vertical scroll bar appears for easy navigation. \image html ged.png width=800px. **Histogram, pad and axis editors**. ### Editor Design Elements. The next rules describe the path to follow when creating your own object; editor that will be recognized and loaded by the graphics editor in; ROOT, i.e. it will be included as a part of it. (a) Derive the code of your object editor from the base editor class; **`TGedFrame`**. (b) Keep the correct naming convention: the name of the object editor; should be the object class name concatenated with the word `‘Editor'`. (c) Provide a default constructor. (d) Use the signals/s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/doc/index.md:2820,intuit,intuitive,2820,gui/ged/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/doc/index.md,2,"['feedback', 'intuit']","['feedback', 'intuitive']"
Usability,"ayer concept by using a new layer,; IRTransformLayer, to add IR optimization support to KaleidoscopeJIT. Optimizing Modules using the IRTransformLayer; =============================================. In `Chapter 4 <LangImpl04.html>`_ of the ""Implementing a language with LLVM""; tutorial series the llvm *FunctionPassManager* is introduced as a means for; optimizing LLVM IR. Interested readers may read that chapter for details, but; in short: to optimize a Module we create an llvm::FunctionPassManager; instance, configure it with a set of optimizations, then run the PassManager on; a Module to mutate it into a (hopefully) more optimized but semantically; equivalent form. In the original tutorial series the FunctionPassManager was; created outside the KaleidoscopeJIT and modules were optimized before being; added to it. In this Chapter we will make optimization a phase of our JIT; instead. For now this will provide us a motivation to learn more about ORC; layers, but in the long term making optimization part of our JIT will yield an; important benefit: When we begin lazily compiling code (i.e. deferring; compilation of each function until the first time it's run) having; optimization managed by our JIT will allow us to optimize lazily too, rather; than having to do all our optimization up-front. To add optimization support to our JIT we will take the KaleidoscopeJIT from; Chapter 1 and compose an ORC *IRTransformLayer* on top. We will look at how the; IRTransformLayer works in more detail below, but the interface is simple: the; constructor for this layer takes a reference to the execution session and the; layer below (as all layers do) plus an *IR optimization function* that it will; apply to each Module that is added via addModule:. .. code-block:: c++. class KaleidoscopeJIT {; private:; ExecutionSession ES;; RTDyldObjectLinkingLayer ObjectLayer;; IRCompileLayer CompileLayer;; IRTransformLayer TransformLayer;. DataLayout DL;; MangleAndInterner Mangle;; ThreadSafeContex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:2111,learn,learn,2111,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['learn'],['learn']
Usability,"ays follow the; severity of the previously emitted diagnostic and ``ERROR``\ s, which can only; be mapped to ``Fatal`` (it is not possible to turn an error into a warning, for; example). Diagnostic mappings are used in many ways. For example, if the user specifies; ``-pedantic``, ``EXTENSION`` maps to ``Warning``, if they specify; ``-pedantic-errors``, it turns into ``Error``. This is used to implement; options like ``-Wunused_macros``, ``-Wundef`` etc. Mapping to ``Fatal`` should only be used for diagnostics that are considered so; severe that error recovery won't be able to recover sensibly from them (thus; spewing a ton of bogus errors). One example of this class of error are failure; to ``#include`` a file. The Format String; ^^^^^^^^^^^^^^^^^. The format string for the diagnostic is very simple, but it has some power. It; takes the form of a string in English with markers that indicate where and how; arguments to the diagnostic are inserted and formatted. For example, here are; some simple format strings:. .. code-block:: c++. ""binary integer literals are an extension""; ""format string contains '\\0' within the string body""; ""more '%%' conversions than data arguments""; ""invalid operands to binary expression (%0 and %1)""; ""overloaded '%0' must be a %select{unary|binary|unary or binary}2 operator""; "" (has %1 parameter%s1)"". These examples show some important points of format strings. You can use any; plain ASCII character in the diagnostic string except ""``%``"" without a; problem, but these are C strings, so you have to use and be aware of all the C; escape sequences (as in the second example). If you want to produce a ""``%``""; in the output, use the ""``%%``"" escape sequence, like the third diagnostic.; Finally, Clang uses the ""``%...[digit]``"" sequences to specify where and how; arguments to the diagnostic are formatted. Arguments to the diagnostic are numbered according to how they are specified by; the C++ code that :ref:`produces them <internals-producing-diag",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:6468,simpl,simple,6468,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"ays is of variable length, and in particular; that the second array is jagged. **Example:** Suppose a hypothetical PDB file with a 4KiB block size, and 4; streams of lengths {1000 bytes, 8000 bytes, 16000 bytes, 9000 bytes}. Stream 0: ceil(1000 / 4096) = 1 block. Stream 1: ceil(8000 / 4096) = 2 blocks. Stream 2: ceil(16000 / 4096) = 4 blocks. Stream 3: ceil(9000 / 4096) = 3 blocks. In total, 10 blocks are used. Let's see what the stream directory might look; like:. .. code-block:: c++. struct StreamDirectory {; ulittle32_t NumStreams = 4;; ulittle32_t StreamSizes[] = {1000, 8000, 16000, 9000};; ulittle32_t StreamBlocks[][] = {; {4},; {5, 6},; {11, 9, 7, 8},; {10, 15, 12}; };; };. In total, this occupies ``15 * 4 = 60`` bytes, so; ``SuperBlock->NumDirectoryBytes`` would equal ``60``, and; ``SuperBlock->BlockMapAddr`` would be an array of one ``ulittle32_t``, since; ``60 <= SuperBlock->BlockSize``. Note also that the streams are discontiguous, and that part of stream 3 is in the; middle of part of stream 2. You cannot assume anything about the layout of the; blocks!. Alignment and Block Boundaries; ==============================; As may be clear by now, it is possible for a single field (whether it be a high; level record, a long string field, or even a single ``uint16``) to begin and; end in separate blocks. For example, if the block size is 4096 bytes, and a; ``uint16`` field begins at the last byte of the current block, then it would; need to end on the first byte of the next block. Since blocks are not; necessarily contiguously laid out in the file, this means that both the consumer; and the producer of an MSF file must be prepared to split data apart; accordingly. In the aforementioned example, the high byte of the ``uint16``; would be written to the last byte of block N, and the low byte would be written; to the first byte of block N+1, which could be tens of thousands of bytes later; (or even earlier!) in the file, depending on what the stream directory says.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst:6874,clear,clear,6874,interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst,1,['clear'],['clear']
Usability,"b browser.; Dedicated for the case when ROOT should be running as server application, providing different RWebWindow instances for connection. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ## Jupyter lab. - Let use created notebooks with viewers like https://nbviewer.jupyter.org/; - Fix problem with using of local JSROOT version. ## Tutorials. - The tutorial games.C was not working properly. - Improve tutorial ErrorIntegral.C. - Schrödinger's Hydrogen Atom example. - Tutorial demonstrating how the changing of the range can zoom into the histogram. - Tutorial demonstrating how a Histogram can be read from a ROOT File. - histMax.C: a tutorial demoing how the hist->GetMaximumBin() can be used. ## Class Reference Guide. - Images for ROOT7 tutorials can be generated, in json format, using the directive using; `\macro_image (json)` in the macro header. - Clarify THStack drawing options. - Add missing documentation to TH1 functions. - Restructure the math reference guide. - Make the web gui documentation visible in the reference guide. - Make clear THtml is legacy code. Add deprecated flag on PROOF and TGeoTrack. - Improve many classes documentation: TContext, TTreePlayer, THistPainter, TGraph, TSelector,; integrator, GUI, TH1, TH2, TH3, TColor classes ... - Make the TFile layout doc visible in Reference Guide. - Update the external links of the reference guide main page. - Reformat TMVA mathcore Unuran Roostats documentation . ## Build, Configuration and Testing Infrastructure. - For users building from source the `latest-stable` branch and passing `-Droottest=ON` to the CMake command line, the corresponding revision of roottest pointed to by `latest-stable` will be downloaded as required. ## PyROOT. - The `ROOT` Python module is now properly serializable so that it is automatically available in the Python environment if a function or ROOT object needs to be serialized. See issue [#6764](https://github.com/root-project/root/issues/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:38913,guid,guide,38913,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['guid'],['guide']
Usability,"ba type declarations are done lazily, with the ``numba_ext`` module only; initially registering hooks on proxy base classes, to keep overheads in; Numba's type-resolution to a minimum.; On use in a JITed trace, each C++ type or function call is refined to the; actual, concrete types and type-specific overloads, with templates; instantiated as-needed.; Where possible, lowering is kept generic to reduce the number of callbacks; in Numba's compilation chain. Examples; --------. The following, non-exhaustive, set of examples gives an idea of the; current level of support.; More examples can be found in the `test suite`_. C++ free (global) functions can be called and overloads will be selected, or; a template will be instantiated, based on the provided types.; Exact type matches are fully supported, there is some support for typedefs; add implicit conversions for builtin types, there is no support for; conversions of custom types or default arguments. - **Basic usage**: To use ``cppyy`` in Numba JITed code, simply import; ``cppyy.numba_ext``, after which further use is transparent and the same; as when otherwise using ``cppyy`` in Python.; Example:. .. code-block:: python. >>> import numba; >>> import cppyy; >>> import cppyy.numba_ext # enables numba to work with cppyy; >>> import math; >>> @numba.jit(nopython=True); ... def cpp_sqrt(x):; ... return cppyy.gbl.sqrt(x) # direct use, no extra setup required; >>> print(""Sqrt of 4: "", cpp_sqrt(4.0)); Sqrt of 4: 2.0; >>> print(""Sqrt of Pi: "", cpp_sqrt(math.pi)); Sqrt of Pi: 1.7724538509055159. - **Overload selection**: C++ overloads provide different implementations; for different argument types (not to be confused with Numba overloads,; which provide different implementations for the same argument types).; Unfortunately, mapping of Python types to C++ types is often not exact,; so a ""best match"" is chosen, similarly to what ``cppyy`` normally does.; However, the latter, being dynamic, is more flexible.; For example, best-match",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst:3578,simpl,simply,3578,bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,1,['simpl'],['simply']
Usability,"back control. To enforce these semantics, stackmap and patchpoint intrinsics are; considered to potentially read and write all memory. This may limit; optimization more than some clients desire. This limitation may be; avoided by marking the call site as ""readonly"". In the future we may; also allow meta-data to be added to the intrinsic call to express; aliasing, thereby allowing optimizations to hoist certain loads above; stack maps. Direct Stack Map Entries; ^^^^^^^^^^^^^^^^^^^^^^^^. As shown in :ref:`stackmap-section`, a Direct stack map location; records the address of frame index. This address is itself the value; that the runtime requested. This differs from Indirect locations,; which refer to a stack locations from which the requested values must; be loaded. Direct locations can communicate the address if an alloca,; while Indirect locations handle register spills. For example:. .. code-block:: none. entry:; %a = alloca i64...; llvm.experimental.stackmap(i64 <ID>, i32 <shadowBytes>, ptr %a). The runtime can determine this alloca's relative location on the; stack immediately after compilation, or at any time thereafter. This; differs from Register and Indirect locations, because the runtime can; only read the values in those locations when execution reaches the; instruction address of the stack map. This functionality requires LLVM to treat entry-block allocas; specially when they are directly consumed by an intrinsics. (This is; the same requirement imposed by the llvm.gcroot intrinsic.) LLVM; transformations must not substitute the alloca with any intervening; value. This can be verified by the runtime simply by checking that the; stack map's location is a Direct location type. Supported Architectures; =======================. Support for StackMap generation and the related intrinsics requires; some code for each backend. Today, only a subset of LLVM's backends; are supported. The currently supported architectures are X86_64,; PowerPC, AArch64 and SystemZ.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:20374,simpl,simply,20374,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['simpl'],['simply']
Usability,"basic block to start insertion into.; BasicBlock *BB = BasicBlock::Create(*TheContext, ""entry"", TheFunction);; Builder->SetInsertPoint(BB);. // Record the function arguments in the NamedValues map.; NamedValues.clear();; for (auto &Arg : TheFunction->args()); NamedValues[std::string(Arg.getName())] = &Arg;. Now we get to the point where the ``Builder`` is set up. The first line; creates a new `basic block <http://en.wikipedia.org/wiki/Basic_block>`_; (named ""entry""), which is inserted into ``TheFunction``. The second line; then tells the builder that new instructions should be inserted into the; end of the new basic block. Basic blocks in LLVM are an important part; of functions that define the `Control Flow; Graph <http://en.wikipedia.org/wiki/Control_flow_graph>`_. Since we; don't have any control flow, our functions will only contain one block; at this point. We'll fix this in `Chapter 5 <LangImpl05.html>`_ :). Next we add the function arguments to the NamedValues map (after first clearing; it out) so that they're accessible to ``VariableExprAST`` nodes. .. code-block:: c++. if (Value *RetVal = Body->codegen()) {; // Finish off the function.; Builder->CreateRet(RetVal);. // Validate the generated code, checking for consistency.; verifyFunction(*TheFunction);. return TheFunction;; }. Once the insertion point has been set up and the NamedValues map populated,; we call the ``codegen()`` method for the root expression of the function. If no; error happens, this emits code to compute the expression into the entry block; and returns the value that was computed. Assuming no error, we then create an; LLVM `ret instruction <../../LangRef.html#ret-instruction>`_, which completes the function.; Once the function is built, we call ``verifyFunction``, which is; provided by LLVM. This function does a variety of consistency checks on; the generated code, to determine if our compiler is doing everything; right. Using this is important: it can catch a lot of bugs. Once the; funct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:15329,clear,clearing,15329,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['clear'],['clearing']
Usability,"be coroutine promise>; <SUSPEND> // injected suspend point, so that the coroutine starts suspended; for (int i = 0; i < n; ++i) {; current_value = i; <SUSPEND>; // corresponds to ""yield i""; }; <SUSPEND final=true> // injected final suspend point; }. and python iterator `__next__` would look like:. .. code-block:: c++. int __next__(void* hdl) {; coro.resume(hdl);; if (coro.done(hdl)) throw StopIteration();; return *(int*)coro.promise(hdl, 4, false);; }. Intrinsics; ==========. Coroutine Manipulation Intrinsics; ---------------------------------. Intrinsics described in this section are used to manipulate an existing; coroutine. They can be used in any function which happen to have a pointer; to a `coroutine frame`_ or a pointer to a `coroutine promise`_. .. _coro.destroy:. 'llvm.coro.destroy' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.coro.destroy(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.destroy``' intrinsic destroys a suspended; switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a coroutine handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.destroy` intrinsic is replaced with a direct call to; the coroutine destroy function. Otherwise it is replaced with an indirect call; based on the function pointer for the destroy function stored in the coroutine; frame. Destroying a coroutine that is not suspended leads to undefined behavior. .. _coro.resume:. 'llvm.coro.resume' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare void @llvm.coro.resume(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.resume``' intrinsic resumes a suspended switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.resume` intrinsic is replaced with a direct call to the; coroutine resume function. Otherwise it is replaced with an indirect call based; on the function pointer for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:27259,resume,resume,27259,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"be running as server application, providing different RWebWindow instances for connection. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ## Jupyter lab. - Let use created notebooks with viewers like https://nbviewer.jupyter.org/; - Fix problem with using of local JSROOT version. ## Tutorials. - The tutorial games.C was not working properly. - Improve tutorial ErrorIntegral.C. - Schrödinger's Hydrogen Atom example. - Tutorial demonstrating how the changing of the range can zoom into the histogram. - Tutorial demonstrating how a Histogram can be read from a ROOT File. - histMax.C: a tutorial demoing how the hist->GetMaximumBin() can be used. ## Class Reference Guide. - Images for ROOT7 tutorials can be generated, in json format, using the directive using; `\macro_image (json)` in the macro header. - Clarify THStack drawing options. - Add missing documentation to TH1 functions. - Restructure the math reference guide. - Make the web gui documentation visible in the reference guide. - Make clear THtml is legacy code. Add deprecated flag on PROOF and TGeoTrack. - Improve many classes documentation: TContext, TTreePlayer, THistPainter, TGraph, TSelector,; integrator, GUI, TH1, TH2, TH3, TColor classes ... - Make the TFile layout doc visible in Reference Guide. - Update the external links of the reference guide main page. - Reformat TMVA mathcore Unuran Roostats documentation . ## Build, Configuration and Testing Infrastructure. - For users building from source the `latest-stable` branch and passing `-Droottest=ON` to the CMake command line, the corresponding revision of roottest pointed to by `latest-stable` will be downloaded as required. ## PyROOT. - The `ROOT` Python module is now properly serializable so that it is automatically available in the Python environment if a function or ROOT object needs to be serialized. See issue [#6764](https://github.com/root-project/root/issues/6764) for a concrete usecase.; - Improve overload res",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:38978,guid,guide,38978,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['guid'],['guide']
Usability,"bed below:. :Methods:. Identified by 'Selector' and 'MethodKind'; the MethodKind is either; ""Instance"" or ""Class"". ::. Classes:; - Name: UIViewController; Methods:; - Selector: ""presentViewController:animated:""; MethodKind: Instance; …. :Properties:. Identified by 'Name' and 'PropertyKind'; the PropertyKind is also either; ""Instance"" or ""Class"". ::. Classes:; - Name: UIView; Properties:; - Name: subviews; PropertyKind: Instance; …. Each declaration supports the following annotations (if relevant to that; declaration kind), all of which are optional:. :SwiftName:. Equivalent to ``NS_SWIFT_NAME``. For a method, must include the full Swift name; with all arguments. Use ""_"" to omit an argument label. ::. - Selector: ""presentViewController:animated:""; MethodKind: Instance; SwiftName: ""present(_:animated:)"". - Class: NSBundle; SwiftName: Bundle. :Availability, AvailabilityMsg:. A value of ""nonswift"" is equivalent to ``NS_SWIFT_UNAVAILABLE``. A value of; ""available"" can be used in the ""SwiftVersions"" section to undo the effect of; ""nonswift"". ::. - Selector: ""dealloc""; MethodKind: Instance; Availability: nonswift; AvailabilityMsg: ""prefer 'deinit'"". :SwiftPrivate:. Equivalent to NS_REFINED_FOR_SWIFT. ::. - Name: CGColorEqualToColor; SwiftPrivate: true. :Nullability:. Used for properties and globals. There are four options, identified by their; initials:. - ``Nonnull`` or ``N`` (corresponding to ``_Nonnull``); - ``Optional`` or ``O`` (corresponding to ``_Nullable``); - ``Unspecified`` or ``U`` (corresponding to ``_Null_unspecified``); - ``Scalar`` or ``S`` (deprecated). Note that 'Nullability' is overridden by 'Type', even in a ""SwiftVersions""; section. .. note::. 'Nullability' can also be used to describe the argument types of methods; and functions, but this usage is deprecated in favor of 'Parameters' (see; below). ::. - Name: dataSource; Nullability: O. :NullabilityOfRet:. Used for methods and functions. Describes the nullability of the return type. Note that 'Nullabili",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/APINotes.rst:4991,undo,undo,4991,interpreter/llvm-project/clang/docs/APINotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/APINotes.rst,1,['undo'],['undo']
Usability,"bel %if.end; dyn.free:; call void @CustomFree(ptr %mem); br label %if.end; if.end:; ... With allocations and deallocations represented as described as above, after; coroutine heap allocation elision optimization, the resulting main will be:. .. code-block:: llvm. define i32 @main() {; entry:; call void @print(i32 4); call void @print(i32 5); call void @print(i32 6); ret i32 0; }. Multiple Suspend Points; -----------------------. Let's consider the coroutine that has more than one suspend point:. .. code-block:: c++. void *f(int n) {; for(;;) {; print(n++);; <suspend>; print(-n);; <suspend>; }; }. Matching LLVM code would look like (with the rest of the code remaining the same; as the code in the previous section):. .. code-block:: llvm. loop:; %n.addr = phi i32 [ %n, %entry ], [ %inc, %loop.resume ]; call void @print(i32 %n.addr) #4; %2 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %2, label %suspend [i8 0, label %loop.resume; i8 1, label %cleanup]; loop.resume:; %inc = add nsw i32 %n.addr, 1; %sub = xor i32 %n.addr, -1; call void @print(i32 %sub); %3 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %3, label %suspend [i8 0, label %loop; i8 1, label %cleanup]. In this case, the coroutine frame would include a suspend index that will; indicate at which suspend point the coroutine needs to resume. .. code-block:: llvm. %f.frame = type { ptr, ptr, i32, i32 }. The resume function will use an index to jump to an appropriate basic block and will look; as follows:. .. code-block:: llvm. define internal fastcc void @f.Resume(ptr %FramePtr) {; entry.Resume:; %index.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 2; %index = load i8, ptr %index.addr, align 1; %switch = icmp eq i8 %index, 0; %n.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 3; %n = load i32, ptr %n.addr, align 4. br i1 %switch, label %loop.resume, label %loop. loop.resume:; %sub = sub nsw i32 0, %n; call void @print(i32 %sub); br label %suspend; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:18569,resume,resume,18569,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"ber of iterations in the review process. For example, when; suggesting a change, if you want the author to make a similar set of changes at; other places in the code, please explain the requested set of changes so that; the author can make all of the changes at once. If a patch will require; multiple steps prior to approval (e.g., splitting, refactoring, posting data; from specific performance tests), please explain as many of these up front as; possible. This allows the patch author and reviewers to make the most efficient; use of their time. LGTM - How a Patch Is Accepted; ------------------------------. A patch is approved to be committed when a reviewer accepts it, and this is; almost always associated with a message containing the text ""LGTM"" (which; stands for Looks Good To Me). Only approval from a single reviewer is required. When providing an unqualified LGTM (approval to commit), it is the; responsibility of the reviewer to have reviewed all of the discussion and; feedback from all reviewers ensuring that all feedback has been addressed and; that all other reviewers will almost surely be satisfied with the patch being; approved. If unsure, the reviewer should provide a qualified approval, (e.g.,; ""LGTM, but please wait for @someone, @someone_else""). You may also do this if; you are fairly certain that a particular community member will wish to review,; even if that person hasn't done so yet. Note that, if a reviewer has requested a particular community member to review,; and after a week that community member has yet to respond, feel free to ping; the patch (which literally means submitting a comment on the patch with the; word, ""Ping.""), or alternatively, ask the original reviewer for further; suggestions. If it is likely that others will want to review a recently-posted patch,; especially if there might be objections, but no one else has done so yet, it is; also polite to provide a qualified approval (e.g., ""LGTM, but please wait for a; couple of days in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:6841,feedback,feedback,6841,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,2,['feedback'],['feedback']
Usability,"ber. Given; struct B {};; struct D : B {; int I;; D(int i) : I(i) {}; };; struct E : B {; E() : B() {}; };; cxxConstructorDecl(hasAnyConstructorInitializer(isBaseInitializer())); will match E(), but not match D(int). Matcher<CXXCtorInitializer>isMemberInitializer; Matches a constructor initializer if it is initializing a member, as; opposed to a base. Given; struct B {};; struct D : B {; int I;; D(int i) : I(i) {}; };; struct E : B {; E() : B() {}; };; cxxConstructorDecl(hasAnyConstructorInitializer(isMemberInitializer())); will match D(int), but not match E(). Matcher<CXXCtorInitializer>isWritten; Matches a constructor initializer if it is explicitly written in; code (as opposed to implicitly added by the compiler). Given; struct Foo {; Foo() { }; Foo(int) : foo_(""A"") { }; string foo_;; };; cxxConstructorDecl(hasAnyConstructorInitializer(isWritten())); will match Foo(int), but not Foo(). Matcher<CXXDeductionGuideDecl>isExplicit; Matches constructor, conversion function, and deduction guide declarations; that have an explicit specifier if this explicit specifier is resolved to; true. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.; cxxConversionDecl(isExplicit()) will match #4, but not #3.; cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. Matcher<CXXDependentScopeMemberExpr>hasMemberNamestd::string N; Matches template-dependent, but known, member names. In template declarations, dependent members are not resolved and so can; not be matched to particular named declarations. This matcher allows to match on the known name of members. Given; template <typename T>; struct S {; void mem();; };; template <typename T>; void x() {; S<T> s;; s.mem();",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:63950,guid,guide,63950,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['guid'],['guide']
Usability,"bers, which are identified with a '``0``' prefix digit, and hexadecimal; numbers with a prefix of '``0x``' or '``0X``'. .. _doubles:; .. _float:; .. _double:. * The **parser<double>** and **parser<float> specializations** use the standard; C ``strtod`` function to convert floating point strings into floating point; values. As such, a broad range of string formats is supported, including; exponential notation (ex: ``1.7e15``) and properly supports locales. .. _Extension Guide:; .. _extending the library:. Extension Guide; ===============. Although the CommandLine library has a lot of functionality built into it; already (as discussed previously), one of its true strengths lie in its; extensibility. This section discusses how the CommandLine library works under; the covers and illustrates how to do some simple, common, extensions. .. _Custom parsers:; .. _custom parser:; .. _Writing a Custom Parser:. Writing a custom parser; -----------------------. One of the simplest and most common extensions is the use of a custom parser.; As `discussed previously`_, parsers are the portion of the CommandLine library; that turns string input from the user into a particular parsed data type,; validating the input in the process. There are two ways to use a new parser:. #. Specialize the `cl::parser`_ template for your custom data type. This approach has the advantage that users of your custom data type will; automatically use your custom parser whenever they define an option with a; value type of your data type. The disadvantage of this approach is that it; doesn't work if your fundamental data type is something that is already; supported. #. Write an independent class, using it explicitly from options that need it. This approach works well in situations where you would line to parse an; option using special syntax for a not-very-special data-type. The drawback; of this approach is that users of your parser have to be aware that they are; using your parser instead of the builtin on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:61858,simpl,simplest,61858,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simplest']
Usability,"bers. * Move from MathMore to MathCore the class `ROOT::Math::Random`. Make it a new interface class for random number generation. Add interfaces for standard; ROOT random engines, GSL random engines and random engines provided by the C++ standard library (`std::random`).; * Add a new randomengine, `MIXMAX` based on matrix-recursive random number generator from Kostas and George Savvidy. See this [paper](http://dx.doi.org/10.1016/j.cpc.2015.06.003). ## R Interface. Apply several improvements in the interface to R, allowing to use R functions within ROOT.; See more at the [ROOT-R User Guide](http://oproject.org/tiki-index.php?page=ROOT%20R%20Users%20Guide). . ## TMVA. Add new TMVA plug-in based on R and Python (using Scikit-Learn) ; * See the [RMVA Web page](http://oproject.org/tiki-index.php?page=RMVA) for a detailed description of the new TMVA method based on R; * See the [PyMVA Web page](http://oproject.org/tiki-index.php?page=PyMVA) for detailed description of the machine learning methods added in TMVA and based on the Python Scikit-Learn package. ## RooFit Libraries; . ## 2D Graphics Libraries. ### THistPainter. Improve the algorithm to compute the lower limit of an axis in log scale when its; real lower limit is 0. The problem was reported in ROOT-7414. Using the `COL` option with histograms having some negative bins; the empty bins; (containing 0) are drawn. In some cases one wants to not draw empty bins; (containing 0) of histograms having a negative minimum. The option `1`, used with; the option `COL`, allows to do that. Implement the Log option for `CANDLE` plots as requested; [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=20225&p=87006#p87006). ### TTeXDump. From Dmitry Kalinkin (via github): Fix file corruption in `TTeXDump::DrawPolyMarker`; The current implementation of `TTeXDump` uses `TVirtualPS::PrintFast` based methods; to output TeX markup with automatic line-wraps. Yet these methods are optimized for; PostScript format where there are a lot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:14383,learn,learning,14383,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['learn'],['learning']
Usability,"bility R, ThreadSafeModule TSM) override;. private:; IRLayer &BaseLayer;; TransformFunction Transform;; };. // From IRTransformLayer.cpp:. IRTransformLayer::IRTransformLayer(ExecutionSession &ES,; IRLayer &BaseLayer,; TransformFunction Transform); : IRLayer(ES), BaseLayer(BaseLayer), Transform(std::move(Transform)) {}. void IRTransformLayer::emit(MaterializationResponsibility R,; ThreadSafeModule TSM) {; assert(TSM.getModule() && ""Module must not be null"");. if (auto TransformedTSM = Transform(std::move(TSM), R)); BaseLayer.emit(std::move(R), std::move(*TransformedTSM));; else {; R.failMaterialization();; getExecutionSession().reportError(TransformedTSM.takeError());; }; }. This is the whole definition of IRTransformLayer, from; ``llvm/include/llvm/ExecutionEngine/Orc/IRTransformLayer.h`` and; ``llvm/lib/ExecutionEngine/Orc/IRTransformLayer.cpp``. This class is concerned; with two very simple jobs: (1) Running every IR Module that is emitted via this; layer through the transform function object, and (2) implementing the ORC; ``IRLayer`` interface (which itself conforms to the general ORC Layer concept,; more on that below). Most of the class is straightforward: a typedef for the; transform function, a constructor to initialize the members, a setter for the; transform function value, and a default no-op transform. The most important; method is ``emit`` as this is half of our IRLayer interface. The emit method; applies our transform to each module that it is called on and, if the transform; succeeds, passes the transformed module to the base layer. If the transform; fails, our emit function calls; ``MaterializationResponsibility::failMaterialization`` (this JIT clients who; may be waiting on other threads know that the code they were waiting for has; failed to compile) and logs the error with the execution session before bailing; out. The other half of the IRLayer interface we inherit unmodified from the IRLayer; class:. .. code-block:: c++. Error IRLayer::add(JITDyli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:7948,simpl,simple,7948,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['simpl'],['simple']
Usability,"bindings are generated/built/packaged using 3 environments:. - One compatible with the header files being bound. This is used to; generate the generic C++ binding code (and some ancillary files) using; a modified C++ compiler. The needed options must be compatible with the; normal build environment of the header files.; - One to compile the generated, generic C++ binding code using a standard; C++ compiler. The resulting library code is ""universal"" in that it is; compatible with both Python2 and Python3.; - One to package the library and ancillary files into standard Python2/3; wheel format. The packaging is done using native Python tooling. +----------------------+---------------------------------------------------------------------------------------------+; |Arguments and options | Description |; +======================+=============================================================================================+; |pkg | The name of the package to generate. This can be either |; | | of the form ""simplename"" (e.g. ""Akonadi""), or of the |; | | form ""namespace.simplename"" (e.g. ""KF5.Akonadi""). |; +----------------------+---------------------------------------------------------------------------------------------+; |pkg_version | The version of the package. |; +----------------------+---------------------------------------------------------------------------------------------+; |author | The name of the library author. |; +----------------------+---------------------------------------------------------------------------------------------+; |author_email | The email address of the library author. |; +----------------------+---------------------------------------------------------------------------------------------+; |URL url | The home page for the library. Default is |; | | ""https://pypi.python.org/pypi/<pkg>"". |; +----------------------+---------------------------------------------------------------------------------------------+; |LICENSE license | The license, defa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst:5806,simpl,simplename,5806,bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,1,['simpl'],['simplename']
Usability,"bing how to move from debug info using; intrinsics such as dbg.value to using the non-instruction DPValue object. :doc:`InstrProfileFormat`; This document explains two binary formats of instrumentation-based profiles. Code Generation; ---------------. :doc:`WritingAnLLVMBackend`; Information on how to write LLVM backends for machine targets. :doc:`CodeGenerator`; The design and implementation of the LLVM code generator. Useful if you are; working on retargetting LLVM to a new architecture, designing a new codegen; pass, or enhancing existing components. :doc:`TableGen <TableGen/index>`; Describes the TableGen tool, which is used heavily by the LLVM code; generator. ==========; GlobalISel; ==========. :doc:`MIRPatterns <GlobalISel/MIRPatterns>`; Describes the design of MIR Patterns and how to use them. ===; JIT; ===. :doc:`MCJITDesignAndImplementation`; Describes the inner workings of MCJIT execution engine. :doc:`ORCv2`; Describes the design and implementation of the ORC APIs, including some; usage examples, and a guide for users transitioning from ORCv1 to ORCv2. :doc:`JITLink`; Describes the design and APIs for the JITLink library, ORC's new JIT; linker. :doc:`DebuggingJITedCode`; How to debug JITed code with GDB. Additional Topics; -----------------. :doc:`CommandLine`; Provides information on using the command line parsing library. :doc:`ExtendingLLVM`; Look here to see how to add instructions and intrinsics to LLVM. :doc:`AddingConstrainedIntrinsics`; Gives the steps necessary when adding a new constrained math intrinsic; to LLVM. :doc:`HowToBuildWindowsItaniumPrograms`; Notes on assembling a Windows Itanium environment. :doc:`HowToCrossCompileBuiltinsOnArm`; Notes on cross-building and testing the compiler-rt builtins for Arm. :doc:`BigEndianNEON`; LLVM's support for generating NEON instructions on big endian ARM targets is; somewhat nonintuitive. This document explains the implementation and rationale. :doc:`AArch64SME`; LLVM's support for AArch64 SME ACLE an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst:5437,guid,guide,5437,interpreter/llvm-project/llvm/docs/UserGuides.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst,1,['guid'],['guide']
Usability,"bject {; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Float_t fCharge; //Charge of this track; Float_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion. // method definitions ...; ClassDef(Track,1) //A track segment; };; ```. ### Writing the Tree. We create a simple tree with two branches both holding `Event` objects.; One is split and the other is not. We also create a pointer to an; `Event` object (`event`). ``` {.cpp}; void tree4w() {; // check to see if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; // create a ROOT Tree; TTree t4(""t4"",""A Tree with Events"");; // create a pointer to an Event object; Event *event = new Event();; // create two branches, split one; t4.Branch(""event_branch"", ""Event"", &event,16000,2);; t4.Branch(""event_not_split"", ""Event"", &event,16000,0);. // a local variable for the event type; char etype[20];. // fill the tree; for (Int_t ev = 0; ev <100; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(et",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:62083,simpl,simple,62083,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['simpl'],['simple']
Usability,"bject. To use an attribute group, an; object references the attribute group's ID (e.g. ``#37``). An object may refer; to more than one attribute group. In that situation, the attributes from the; different groups are merged. Here is an example of attribute groups for a function that should always be; inlined, has a stack alignment of 4, and which shouldn't use SSE instructions:. .. code-block:: llvm. ; Target-independent attributes:; attributes #0 = { alwaysinline alignstack=4 }. ; Target-dependent attributes:; attributes #1 = { ""no-sse"" }. ; Function @f has attributes: alwaysinline, alignstack=4, and ""no-sse"".; define void @f() #0 #1 { ... }. .. _fnattrs:. Function Attributes; -------------------. Function attributes are set to communicate additional information about; a function. Function attributes are considered to be part of the; function, not of the function type, so functions with different function; attributes can have the same function type. Function attributes are simple keywords that follow the type specified.; If multiple attributes are needed, they are space separated. For; example:. .. code-block:: llvm. define void @f() noinline { ... }; define void @f() alwaysinline { ... }; define void @f() alwaysinline optsize { ... }; define void @f() optsize { ... }. ``alignstack(<n>)``; This attribute indicates that, when emitting the prologue and; epilogue, the backend should forcibly align the stack pointer.; Specify the desired alignment, which must be a power of two, in; parentheses.; ``""alloc-family""=""FAMILY""``; This indicates which ""family"" an allocator function is part of. To avoid; collisions, the family name should match the mangled name of the primary; allocator function, that is ""malloc"" for malloc/calloc/realloc/free,; ""_Znwm"" for ``::operator::new`` and ``::operator::delete``, and; ""_ZnwmSt11align_val_t"" for aligned ``::operator::new`` and; ``::operator::delete``. Matching malloc/realloc/free calls within a family; can be optimized, but mismatched o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:77142,simpl,simple,77142,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability,"ble and easily accommodate new uses; as we grow the clang and LLVM infrastructure. As one example, the driver; can easily support the introduction of tools which have an integrated; assembler; something we hope to add to LLVM in the future. Similarly, most of the driver functionality is kept in a library which; can be used to build other tools which want to implement or accept a gcc; like interface. Low Overhead; ------------. The driver should have as little overhead as possible. In practice, we; found that the gcc driver by itself incurred a small but meaningful; overhead when compiling many small files. The driver doesn't do much; work compared to a compilation, but we have tried to keep it as; efficient as possible by following a few simple principles:. - Avoid memory allocation and string copying when possible.; - Don't parse arguments more than once.; - Provide a few simple interfaces for efficiently searching arguments. Simple; ------. Finally, the driver was designed to be ""as simple as possible"", given; the other goals. Notably, trying to be completely compatible with the; gcc driver adds a significant amount of complexity. However, the design; of the driver attempts to mitigate this complexity by dividing the; process into a number of independent stages instead of a single; monolithic task. Internal Design and Implementation; ==================================. .. contents::; :local:; :depth: 1. Internals Introduction; ----------------------. In order to satisfy the stated goals, the driver was designed to; completely subsume the functionality of the gcc executable; that is, the; driver should not need to delegate to gcc to perform subtasks. On; Darwin, this implies that the Clang driver also subsumes the gcc; driver-driver, which is used to implement support for building universal; images (binaries and object files). This also implies that the driver; should be able to call the language specific compilers (e.g. cc1); directly, which means that it must hav",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:2226,simpl,simple,2226,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['simpl'],['simple']
Usability,"ble()`` - Removes a global variable from the list and deletes it.; | ``global_begin()``, ``global_end()``, ``global_size()``, ``global_empty()``. These are forwarding methods that make it easy to access the contents of a; ``Module`` object's GlobalVariable_ list. ----------------. * ``SymbolTable *getSymbolTable()``. Return a reference to the SymbolTable_ for this ``Module``. ----------------. * ``Function *getFunction(StringRef Name) const``. Look up the specified function in the ``Module`` SymbolTable_. If it does not; exist, return ``null``. * ``FunctionCallee getOrInsertFunction(const std::string &Name,; const FunctionType *T)``. Look up the specified function in the ``Module`` SymbolTable_. If; it does not exist, add an external declaration for the function and; return it. Note that the function signature already present may not; match the requested signature. Thus, in order to enable the common; usage of passing the result directly to EmitCall, the return type is; a struct of ``{FunctionType *T, Constant *FunctionPtr}``, rather; than simply the ``Function*`` with potentially an unexpected; signature. * ``std::string getTypeName(const Type *Ty)``. If there is at least one entry in the SymbolTable_ for the specified Type_,; return it. Otherwise return the empty string. * ``bool addTypeName(const std::string &Name, const Type *Ty)``. Insert an entry in the SymbolTable_ mapping ``Name`` to ``Ty``. If there is; already an entry for this name, true is returned and the SymbolTable_ is not; modified. .. _Value:. The ``Value`` class; -------------------. ``#include ""llvm/IR/Value.h""``. header source: `Value.h <https://llvm.org/doxygen/Value_8h_source.html>`_. doxygen info: `Value Class <https://llvm.org/doxygen/classllvm_1_1Value.html>`_. The ``Value`` class is the most important class in the LLVM Source base. It; represents a typed value that may be used (among other things) as an operand to; an instruction. There are many different types of ``Value``\ s, such as; Con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:140312,simpl,simply,140312,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simply']
Usability,"blic statements about a resolution and will; only publish :ref:`transparency reports<Transparency Reports>`. If a public; statement is necessary and requested by the committee, it will be given by the; LLVM Foundation Board of Directors. Report Acknowledgement; ======================. When a report is received, the committee will reply to the reporter to confirm; receipt within 24 hours of the incident being reported. . This acknowledgement will contain:. * Acknowledgement of the incident report; * Next steps of the committee for responding to the incident; * Reminder of confidentiality policy regarding the report and parties involved. All incident reports should be assessed if they require immediate response and; acted on accordingly. .. _Incident Response Assessment:. Incident Response Assessment; ============================. The committee will assess the incident and determine an appropriate response.; The assessment will be documented and retained in records. Here are some; guidelines for the process:. * Review report documentation to determine the content and context of the; incident. * Request additional information if needed from the reporter. * Determine if it occurred within the scope of the CoC.; * Determine if it violated the CoC and specifically which part.; * Consult documentation of past incidents for patterns of behavior (if; available and applicable).; * Follow up with the reportee to get their view or any other additional; information.; * Determine appropriate resolutions to the incident when all information has; been gathered.; * Notify the reporter of the resolution and request feedback. This may or may; not be used to reevaluate the resolution. The committee will aim to have a resolution agreed upon within two weeks of; receipt of the incident report. In the event that a resolution cannot be; determined within that time, the CoC committee will respond to the reporter(s); with an updated and projected timeline for resolution. . .. _Following Up W",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:5040,guid,guidelines,5040,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['guid'],['guidelines']
Usability,"block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, the Visual Studio project generators in CMake do; not support `CMAKE_EXPORT_COMPILE_COMMANDS; <https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html>`_.; However, the Ninja generator does support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate it. Next, assuming you already have Visual Studio installed on your machine, you; need to have the appropriate environment variables configured so that CMake; will locate the MSVC compiler for the Ninja generator. The `documentation; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#path_and_environment>`_; describes the necessary environment variable settings, but the simplest thing; is to use a `developer command-prompt window; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_prompt_shortcuts>`_; or call a `developer command file; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_file_locations>`_; to set the environment variables appropriately. Now you can run CMake with the Ninja generator to export a compilation; database:. .. code-block:: console. C:\> mkdir build-ninja; C:\> cd build-ninja; C:\build-ninja> cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. It is best to keep your Visual Studio IDE build folder separate from the; Ninja build folder. This prevents the two build systems from negatively; interacting with each other. Once the ``compile_commands.json`` file has been created by Ninja, you can; use that compilation database with Clang Tooling. One caveat is that becaus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:2990,simpl,simplest,2990,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,1,['simpl'],['simplest']
Usability,"body of an ``if``, ``else``, or for/while loop statement, we; prefer to omit the braces to avoid unnecessary line noise. However, braces; should be used in cases where the omission of braces harm the readability and; maintainability of the code. We consider that readability is harmed when omitting the brace in the presence; of a single statement that is accompanied by a comment (assuming the comment; can't be hoisted above the ``if`` or loop statement, see below). Similarly, braces should be used when a single-statement body is complex enough; that it becomes difficult to see where the block containing the following; statement began. An ``if``/``else`` chain or a loop is considered a single; statement for this rule, and this rule applies recursively. This list is not exhaustive. For example, readability is also harmed if an; ``if``/``else`` chain does not use braced bodies for either all or none of its; members, or has complex conditionals, deep nesting, etc. The examples below; intend to provide some guidelines. Maintainability is harmed if the body of an ``if`` ends with a (directly or; indirectly) nested ``if`` statement with no ``else``. Braces on the outer ``if``; would help to avoid running into a ""dangling else"" situation. .. code-block:: c++. // Omit the braces since the body is simple and clearly associated with the; // `if`.; if (isa<FunctionDecl>(D)); handleFunctionDecl(D);; else if (isa<VarDecl>(D)); handleVarDecl(D);. // Here we document the condition itself and not the body.; if (isa<VarDecl>(D)) {; // It is necessary that we explain the situation with this surprisingly long; // comment, so it would be unclear without the braces whether the following; // statement is in the scope of the `if`.; // Because the condition is documented, we can't really hoist this; // comment that applies to the body above the `if`.; handleOtherDecl(D);; }. // Use braces on the outer `if` to avoid a potential dangling `else`; // situation.; if (isa<VarDecl>(D)) {; if (should",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:62645,guid,guidelines,62645,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['guid'],['guidelines']
Usability,"body of code that uses acronyms; extensively to the detriment of its readability. Further, it is natural and; generally encouraged that new code be written in the style of the surrounding; code. Therefore it is likely that much newly written code will also use; acronyms despite what the coding standard says, much as it is today. As well as changing the case of variable names, they could also be expanded to; their non-acronym form e.g. ``Triple T`` → ``Triple triple``. There is support for expanding many acronyms [CarruthAcronym]_ [PicusAcronym]_; but there is a preference that expanding acronyms be deferred; [ParzyszekAcronym]_ [CarruthAcronym]_. The consensus within the community seems to be that at least some acronyms are; valuable [ParzyszekAcronym]_ [LattnerAcronym]_. The most commonly cited acronym; is ``TLI`` however that is used to refer to both ``TargetLowering`` and; ``TargetLibraryInfo`` [GreeneDistinguish]_. The following is a list of acronyms considered sufficiently useful that the; benefit of using them outweighs the cost of learning them. Acronyms that are; either not on the list or are used to refer to a different type should be; expanded. ============================ =============; Class name Variable name; ============================ =============; DeterministicFiniteAutomaton dfa; DominatorTree dt; LoopInfo li; MachineFunction mf; MachineInstr mi; MachineRegisterInfo mri; ScalarEvolution se; TargetInstrInfo tii; TargetLibraryInfo tli; TargetRegisterInfo tri; ============================ =============. In some cases renaming acronyms to the full type name will result in overly; verbose code. Unlike most classes, a variable's scope is limited and therefore; some of its purpose can implied from that scope, meaning that fewer words are; necessary to give it a clear name. For example, in an optimization pass the reader; can assume that a variable's purpose relates to optimization and therefore an; ``OptimizationRemarkEmitter`` variable could be given t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:5844,learn,learning,5844,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['learn'],['learning']
Usability,"bot-worker description::. Windows 7 x64; Core i7 (2.66GHz), 16GB of RAM. g++.exe (TDM-1 mingw32) 4.4.0; GNU Binutils 2.19.1; cmake version 2.8.4; Microsoft(R) 32-bit C/C++ Optimizing Compiler Version 16.00.40219.01 for 80x86. See `here <http://docs.buildbot.net/current/manual/installation/worker.html>`_; for which files to edit. #. Send a patch which adds your build worker and your builder to; `zorg <https://github.com/llvm/llvm-zorg>`_. Use the typical LLVM; `workflow <https://llvm.org/docs/Contributing.html#how-to-submit-a-patch>`_. * workers are added to ``buildbot/osuosl/master/config/workers.py``; * builders are added to ``buildbot/osuosl/master/config/builders.py``. Please make sure your builder name and its builddir are unique through the; file. All new builders should default to using the ""'collapseRequests': False""; configuration. This causes the builder to build each commit individually; and not merge build requests. To maximize quality of feedback to developers,; we *strongly prefer* builders to be configured not to collapse requests.; This flag should be removed only after all reasonable efforts have been; exhausted to improve build times such that the builder can keep up with; commit flow. It is possible to allow email addresses to unconditionally receive; notifications on build failure; for this you'll need to add an; ``InformativeMailNotifier`` to ``buildbot/osuosl/master/config/status.py``.; This is particularly useful for the staging buildmaster which is silent; otherwise. #. Send the buildbot-worker access name and the access password directly to; `Galina Kistanova <mailto:gkistanova@gmail.com>`_, and wait until she; lets you know that your changes are applied and buildmaster is; reconfigured. #. Make sure you can start the buildbot-worker and successfully connect; to the silent buildmaster. Then set up your buildbot-worker to start; automatically at the start up time. See the buildbot documentation; for help. You may want to restart your computer t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:5709,feedback,feedback,5709,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['feedback'],['feedback']
Usability,"bstituted into; Not resolved. 2771; open; Transformation for unqualified-ids in address operator; Not resolved. 2772; DR; Missing Annex C entry for linkage effects of linkage-specification; Unknown. 2773; open; Naming anonymous union members as class members; Not resolved. 2774; open; Value-dependence of requires-expressions; Not resolved. 2775; tentatively ready; Unclear argument type for copy of exception object; Unknown. 2776; open; Substitution failure and implementation limits; Not resolved. 2777; open; Type of id-expression denoting a template parameter object; Not resolved. 2778; open; Trivial destructor does not imply constant destruction; Not resolved. 2779; open; Restrictions on the ordinary literal encoding; Not resolved. 2780; DR; reinterpret_cast to reference to function types; Unknown. 2781; open; Unclear recursion in the one-definition rule; Not resolved. 2782; open; Treatment of closure types in the one-definition rule; Not resolved. 2783; DR; Handling of deduction guides in global-module-fragment; Unknown. 2784; open; Unclear definition of member-designator for offsetof; Not resolved. 2785; DR; Type-dependence of requires-expression; Unknown. 2786; open; Comparing pointers to complete objects; Not resolved. 2787; open; Kind of explicit object copy/move assignment function; Not resolved. 2788; open; Correspondence and redeclarations; Not resolved. 2789; DR; Overload resolution with implicit and explicit object member functions; Clang 18. 2790; open; Aggregate initialization and user-defined conversion sequence; Not resolved. 2791; DR; Unclear phrasing about ""returning to the caller""; Unknown. 2792; DR; Clean up specification of noexcept operator; Unknown. 2793; DR; Block-scope declaration conflicting with parameter name; Unknown. 2794; open; Uniqueness of lambdas in alias templates; Not resolved. 2795; DR; Overlapping empty subobjects with different cv-qualification; Unknown. 2796; DR; Function pointer conversions for relational operators; Unknown. 27",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:192950,guid,guides,192950,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['guid'],['guides']
Usability,"buf_t *sbuf, sized_t nelems) {; // Materialize RHS values:; int *tmp_ptr = (int *)malloc(sizeof(int) * nelems);; int tmp_count = nelems;; // Inserted check:; // - checks to ensure that `lower <= tmp_ptr <= upper`; // - if (upper(tmp_ptr) - tmp_ptr < tmp_count) trap();; sbuf->buf = tmp_ptr;; sbuf->count = tmp_count;; }. Whether the compiler can optimize such run-time checks depends on how the upper; bound of the pointer is derived. If the source pointer has ``__sized_by``,; ``__counted_by``, or a variant of such, the compiler assumes that the upper; bound calculation doesn't overflow, e.g., ``ptr + size`` (where the type of; ``ptr`` is ``void *__sized_by(size)``), because when the ``__sized_by`` pointer; is initialized, ``-fbounds-safety`` inserts run-time checks to ensure that ``ptr; + size`` doesn't overflow and that ``size >= 0``. Assuming the upper bound calculation doesn't overflow, the compiler can simplify; the trap condition ``upper(tmp_ptr) - tmp_ptr < tmp_count`` to ``size <; tmp_count`` so if both ``size`` and ``tmp_count`` values are known at compile; time such that ``0 <= tmp_count <= size``, the optimizer can remove the check. ``ptr + size`` may still overflow if the ``__sized_by`` pointer is created from; code that doesn't enable ``-fbounds-safety``, which is undefined behavior. In the previous code example with the transformed ``alloc_buf()``, the upper; bound of ``tmp_ptr`` is derived from ``void *__sized_by_or_null(size)``, which; is the return type of ``malloc()``. Hence, the pointer arithmetic doesn't; overflow or ``tmp_ptr`` is null. Therefore, if ``nelems`` was given as a; compile-time constant, the compiler could remove the checks. Cast rules; ----------. ``-fbounds-safety`` does not enforce overall type safety and bounds invariants; can still be violated by incorrect casts in some cases. That said,; ``-fbounds-safety`` prevents type conversions that change bounds attributes in a; way to violate the bounds invariant of the destination's pointer ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:38134,simpl,simplify,38134,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['simpl'],['simplify']
Usability,"build and; test LLVM have been ported to a plethora of platforms. What API do I use to store a value to one of the virtual registers in LLVM IR's SSA representation?; ---------------------------------------------------------------------------------------------------. In short: you can't. It's actually kind of a silly question once you grok; what's going on. Basically, in code like:. .. code-block:: llvm. %result = add i32 %foo, %bar. , ``%result`` is just a name given to the ``Value`` of the ``add``; instruction. In other words, ``%result`` *is* the add instruction. The; ""assignment"" doesn't explicitly ""store"" anything to any ""virtual register"";; the ""``=``"" is more like the mathematical sense of equality. Longer explanation: In order to generate a textual representation of the; IR, some kind of name has to be given to each instruction so that other; instructions can textually reference it. However, the isomorphic in-memory; representation that you manipulate from C++ has no such restriction since; instructions can simply keep pointers to any other ``Value``'s that they; reference. In fact, the names of dummy numbered temporaries like ``%1`` are; not explicitly represented in the in-memory representation at all (see; ``Value::getName()``). Source Languages; ================. What source languages are supported?; ------------------------------------. LLVM currently has full support for C and C++ source languages through; `Clang <https://clang.llvm.org/>`_. Many other language frontends have; been written using LLVM, and an incomplete list is available at; `projects with LLVM <https://llvm.org/ProjectsWithLLVM/>`_. I'd like to write a self-hosting LLVM compiler. How should I interface with the LLVM middle-end optimizers and back-end code generators?; ----------------------------------------------------------------------------------------------------------------------------------------; Your compiler front-end will communicate with LLVM by creating a module in the; LLVM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst:2437,simpl,simply,2437,interpreter/llvm-project/llvm/docs/FAQ.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst,1,['simpl'],['simply']
Usability,"bvector``. Prior to the existence of the Legalize passes, we required that every target; `selector`_ supported and handled every operator and type even if they are not; natively supported. The introduction of the Legalize phases allows all of the; canonicalization patterns to be shared across targets, and makes it very easy to; optimize the canonicalized code because it is still in the form of a DAG. .. _optimizations:; .. _Optimize SelectionDAG:; .. _selector:. SelectionDAG Optimization Phase: the DAG Combiner; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The SelectionDAG optimization phase is run multiple times for code generation,; immediately after the DAG is built and once after each legalization. The first; run of the pass allows the initial code to be cleaned up (e.g. performing; optimizations that depend on knowing that the operators have restricted type; inputs). Subsequent runs of the pass clean up the messy code generated by the; Legalize passes, which allows Legalize to be very simple (it can focus on making; code legal instead of focusing on generating *good* and legal code). One important class of optimizations performed is optimizing inserted sign and; zero extension instructions. We currently use ad-hoc techniques, but could move; to more rigorous techniques in the future. Here are some good papers on the; subject:. ""`Widening integer arithmetic <http://www.eecs.harvard.edu/~nr/pubs/widen-abstract.html>`_"" :raw-html:`<br>`; Kevin Redwine and Norman Ramsey :raw-html:`<br>`; International Conference on Compiler Construction (CC) 2004. ""`Effective sign extension elimination <http://portal.acm.org/citation.cfm?doid=512529.512552>`_"" :raw-html:`<br>`; Motohiro Kawahito, Hideaki Komatsu, and Toshio Nakatani :raw-html:`<br>`; Proceedings of the ACM SIGPLAN 2002 Conference on Programming Language Design; and Implementation. .. _Select instructions from DAG:. SelectionDAG Select Phase; ^^^^^^^^^^^^^^^^^^^^^^^^^. The Select phase is the bulk of the target",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:45670,simpl,simple,45670,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"bvious data dependency (e.g., when comparing strings, ignore the fact; that the output of the comparison might be implicit data-dependent on the; content of the strings). This applies only to functions with ``custom`` category; in ABI list. Its default value is true.; * ``origin_history_size`` -- The limit of origin chain length. Non-positive values; mean unlimited. Its default value is 16.; * ``origin_history_per_stack_limit`` -- The limit of origin node's references count.; Non-positive values mean unlimited. Its default value is 20000.; * ``store_context_size`` -- The depth limit of origin tracking stack traces. Its; default value is 20.; * ``zero_in_malloc`` -- Whether to zero shadow space of new allocated memory. Its; default value is true.; * ``zero_in_free`` --- Whether to zero shadow space of deallocated memory. Its; default value is true. Example; =======. DataFlowSanitizer supports up to 8 labels, to achieve low CPU and code; size overhead. Base labels are simply 8-bit unsigned integers that are; powers of 2 (i.e. 1, 2, 4, 8, ..., 128), and union labels are created; by ORing base labels. The following program demonstrates label propagation by checking that; the correct labels are propagated. .. code-block:: c++. #include <sanitizer/dfsan_interface.h>; #include <assert.h>. int main(void) {; int i = 100;; int j = 200;; int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:10767,simpl,simply,10767,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,1,['simpl'],['simply']
Usability,"by -loop-reduce and -indvars. //===---------------------------------------------------------------------===//. u32 to float conversion improvement:. float uint32_2_float( unsigned u ) {; float fl = (int) (u & 0xffff);; float fh = (int) (u >> 16);; fh *= 0x1.0p16f;; return fh + fl;; }. 00000000 subl $0x04,%esp; 00000003 movl 0x08(%esp,1),%eax; 00000007 movl %eax,%ecx; 00000009 shrl $0x10,%ecx; 0000000c cvtsi2ss %ecx,%xmm0; 00000010 andl $0x0000ffff,%eax; 00000015 cvtsi2ss %eax,%xmm1; 00000019 mulss 0x00000078,%xmm0; 00000021 addss %xmm1,%xmm0; 00000025 movss %xmm0,(%esp,1); 0000002a flds (%esp,1); 0000002d addl $0x04,%esp; 00000030 ret. //===---------------------------------------------------------------------===//. When using fastcc abi, align stack slot of argument of type double on 8 byte; boundary to improve performance. //===---------------------------------------------------------------------===//. GCC's ix86_expand_int_movcc function (in i386.c) has a ton of interesting; simplifications for integer ""x cmp y ? a : b"". //===---------------------------------------------------------------------===//. Consider the expansion of:. define i32 @test3(i32 %X) {; %tmp1 = urem i32 %X, 255; ret i32 %tmp1; }. Currently it compiles to:. ...; movl $2155905153, %ecx; movl 8(%esp), %esi; movl %esi, %eax; mull %ecx; ... This could be ""reassociated"" into:. movl $2155905153, %eax; movl 8(%esp), %ecx; mull %ecx. to avoid the copy. In fact, the existing two-address stuff would do this; except that mul isn't a commutative 2-addr instruction. I guess this has; to be done at isel time based on the #uses to mul?. //===---------------------------------------------------------------------===//. Make sure the instruction which starts a loop does not cross a cacheline; boundary. This requires knowning the exact length of each machine instruction.; That is somewhat complicated, but doable. Example 256.bzip2:. In the new trace, the hot loop has an instruction which crosses a cacheline; boundar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:9750,simpl,simplifications,9750,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['simpl'],['simplifications']
Usability,"by passing -configuration; Debug to xcodebuild.; Analyze your project using the Simulator as your base SDK. It is; possible to analyze your code when targeting the device, but this is much; easier to do when using Xcode's Build and Analyze feature.; Check that your code signing SDK is set to the simulator SDK as well, and make sure this option is set to Don't Code Sign. Note that you can most of this without actually modifying your project. For; example, if your application targets iPhoneOS 2.2, you could run; scan-build in the following manner from the command line:. $ scan-build xcodebuild -configuration Debug -sdk iphonesimulator2.2. Alternatively, if your application targets iPhoneOS 3.0:. $ scan-build xcodebuild -configuration Debug -sdk iphonesimulator3.0. Gotcha: using the right compiler; Recall that scan-build analyzes your project by using a compiler to; compile the project and clang to analyze your project. The script uses; simple heuristics to determine which compiler should be used (it defaults to; clang on Darwin and gcc on other platforms). When analyzing; iPhone projects, scan-build may pick the wrong compiler than the one; Xcode would use to build your project. For example, this could be because; multiple versions of a compiler may be installed on your system, especially if; you are developing for the iPhone.; When compiling your application to run on the simulator, it is important that scan-build; finds the correct version of gcc/clang. Otherwise, you may see strange build; errors that only happen when you run scan-build. scan-build provides the --use-cc and --use-c++; options to hardwire which compiler scan-build should use for building your code.; Note that although you are chiefly interested in analyzing your project, keep in; mind that running the analyzer is intimately tied to the build, and not being; able to compile your code means it won't get fully analyzed (if at all).; If you aren't certain which compiler Xcode uses to build your project,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:9892,simpl,simple,9892,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,1,['simpl'],['simple']
Usability,"by passing; ``-ftrigraphs``. Non-comprehensive list of changes in this release; -------------------------------------------------. * Clang now has a ``__builtin_vectorelements()`` function that determines the number of elements in a vector.; For fixed-sized vectors, e.g., defined via ``__attribute__((vector_size(N)))`` or ARM NEON's vector types; (e.g., ``uint16x8_t``), this returns the constant number of elements at compile-time.; For scalable vectors, e.g., SVE or RISC-V V, the number of elements is not known at compile-time and is; determined at runtime.; * The ``__datasizeof`` keyword has been added. It is similar to ``sizeof``; except that it returns the size of a type ignoring tail padding.; * ``__builtin_classify_type()`` now classifies ``_BitInt`` values as the return value ``18``; and vector types as return value ``19``, to match GCC 14's behavior.; * The default value of `_MSC_VER` was raised from 1920 to 1933.; * Since MSVC 19.33 added undocumented attribute ``[[msvc::constexpr]]``, this release adds the attribute as well. * Added ``#pragma clang fp reciprocal``. * The version of Unicode used by Clang (primarily to parse identifiers) has been updated to 15.1. * Clang now defines macro ``__LLVM_INSTR_PROFILE_GENERATE`` when compiling with; PGO instrumentation profile generation, and ``__LLVM_INSTR_PROFILE_USE`` when; compiling with PGO profile use. New Compiler Flags; ------------------. * ``-fverify-intermediate-code`` and its complement ``-fno-verify-intermediate-code``.; Enables or disables verification of the generated LLVM IR.; Users can pass this to turn on extra verification to catch certain types of; compiler bugs at the cost of extra compile time.; Since enabling the verifier adds a non-trivial cost of a few percent impact on; build times, it's disabled by default, unless your LLVM distribution itself is; compiled with runtime checks enabled.; * ``-fkeep-system-includes`` modifies the behavior of the ``-E`` option,; preserving ``#include`` directiv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:14839,undo,undocumented,14839,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['undo'],['undocumented']
Usability,"by; essentially interposing on a project's build process. This means that to run the; analyzer using scan-build, you will use scan-build to analyze; the source files compiled by gcc/clang during a project build.; This means that any files that are not compiled will also not be analyzed.; Basic Usage; Basic usage of scan-build is designed to be simple: just place the; word ""scan-build"" in front of your build command:. $ scan-build make; $ scan-build xcodebuild. In the first case scan-build analyzes the code of a project built; with make and in the second case scan-build analyzes a project; built using xcodebuild.; Here is the general format for invoking scan-build:. $ scan-build [scan-build options] <command> [command options]. Operationally, scan-build literally runs <command> with all of the; subsequent options passed to it. For example, one can pass -j4 to; make get a parallel build over 4 cores:. $ scan-build make -j4. In almost all cases, scan-build makes no effort to interpret the; options after the build command; it simply passes them through. In general,; scan-build should support parallel builds, but not distributed; builds.; It is also possible to use scan-build to analyze specific; files:. $ scan-build gcc -c t1.c t2.c. This example causes the files t1.c and t2.c to be analyzed. For Windows Users; Windows users must have Perl installed to use scan-build.; scan-build.bat script allows you to launch scan-build in the same; way as it described in the Basic Usage section above. To invoke scan-build from; an arbitrary location, add the path to the folder containing scan-build.bat to; your PATH environment variable.; If you have unexpected compilation/make problems when running scan-build; with MinGW/MSYS the following information may be helpful:. If getting unexpected ""fatal error: no input files"" while; building with MSYS make from the Windows cmd, try one of these solutions:. Use MinGW mingw32-make instead of MSYS make and; exclude the path to MSYS from PATH ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:2684,simpl,simply,2684,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,1,['simpl'],['simply']
Usability,"c blocks in the CFG). Entry and Exit Blocks; ^^^^^^^^^^^^^^^^^^^^^. Each instance of ``CFG`` contains two special blocks: an *entry* block; (accessible via ``CFG::getEntry()``), which has no incoming edges, and an; *exit* block (accessible via ``CFG::getExit()``), which has no outgoing edges.; Neither block contains any statements, and they serve the role of providing a; clear entrance and exit for a body of code such as a function body. The; presence of these empty blocks greatly simplifies the implementation of many; analyses built on top of CFGs. .. _ConditionalControlFlow:. Conditional Control-Flow; ^^^^^^^^^^^^^^^^^^^^^^^^. Conditional control-flow (such as those induced by if-statements and loops) is; represented as edges between ``CFGBlocks``. Because different C language; constructs can induce control-flow, each ``CFGBlock`` also records an extra; ``Stmt*`` that represents the *terminator* of the block. A terminator is; simply the statement that caused the control-flow, and is used to identify the; nature of the conditional control-flow between blocks. For example, in the; case of an if-statement, the terminator refers to the ``IfStmt`` object in the; AST that represented the given branch. To illustrate, consider the following code example:. .. code-block:: c++. int foo(int x) {; x = x + 1;; if (x > 2); x++;; else {; x += 2;; x *= 2;; }. return x;; }. After invoking the parser+semantic analyzer on this code fragment, the AST of; the body of ``foo`` is referenced by a single ``Stmt*``. We can then construct; an instance of ``CFG`` representing the control-flow graph of this function; body by single call to a static class method:. .. code-block:: c++. Stmt *FooBody = ...; std::unique_ptr<CFG> FooCFG = CFG::buildCFG(FooBody);. Along with providing an interface to iterate over its ``CFGBlocks``, the; ``CFG`` class also provides methods that are useful for debugging and; visualizing CFGs. For example, the method ``CFG::dump()`` dumps a; pretty-printed version of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:114390,simpl,simply,114390,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simply']
Usability,"c destroys a suspended; switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a coroutine handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.destroy` intrinsic is replaced with a direct call to; the coroutine destroy function. Otherwise it is replaced with an indirect call; based on the function pointer for the destroy function stored in the coroutine; frame. Destroying a coroutine that is not suspended leads to undefined behavior. .. _coro.resume:. 'llvm.coro.resume' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare void @llvm.coro.resume(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.resume``' intrinsic resumes a suspended switched-resume coroutine. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". When possible, the `coro.resume` intrinsic is replaced with a direct call to the; coroutine resume function. Otherwise it is replaced with an indirect call based; on the function pointer for the resume function stored in the coroutine frame.; Resuming a coroutine that is not suspended leads to undefined behavior. .. _coro.done:. 'llvm.coro.done' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare i1 @llvm.coro.done(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.done``' intrinsic checks whether a suspended; switched-resume coroutine is at the final suspend point or not. Arguments:; """""""""""""""""""". The argument is a handle to a suspended coroutine. Semantics:; """""""""""""""""""". Using this intrinsic on a coroutine that does not have a `final suspend`_ point; or on a coroutine that is not suspended leads to undefined behavior. .. _coro.promise:. 'llvm.coro.promise' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ::. declare ptr @llvm.coro.promise(ptr <ptr>, i32 <alignment>, i1 <from>). Overview:; """""""""""""""""". The '``llvm.coro.promise``' intrinsic obtains a pointer to a; `coroutine promise`_ given a switched-resume coroutine handle and vice versa. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:28247,resume,resume,28247,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"called; with constants like in the ""``sin(1.0)``"" above. In the future we'll see how tweaking this symbol resolution rule can be used to; enable all sorts of useful features, from security (restricting the set of; symbols available to JIT'd code), to dynamic code generation based on symbol; names, and even lazy compilation. One immediate benefit of the symbol resolution rule is that we can now extend; the language by writing arbitrary C++ code to implement operations. For example,; if we add:. .. code-block:: c++. #ifdef _WIN32; #define DLLEXPORT __declspec(dllexport); #else; #define DLLEXPORT; #endif. /// putchard - putchar that takes a double and returns 0.; extern ""C"" DLLEXPORT double putchard(double X) {; fputc((char)X, stderr);; return 0;; }. Note, that for Windows we need to actually export the functions because; the dynamic symbol loader will use ``GetProcAddress`` to find the symbols. Now we can produce simple output to the console by using things like:; ""``extern putchard(x); putchard(120);``"", which prints a lowercase 'x'; on the console (120 is the ASCII code for 'x'). Similar code could be; used to implement file I/O, console input, and many other capabilities; in Kaleidoscope. This completes the JIT and optimizer chapter of the Kaleidoscope; tutorial. At this point, we can compile a non-Turing-complete; programming language, optimize and JIT compile it in a user-driven way.; Next up we'll look into `extending the language with control flow; constructs <LangImpl05.html>`_, tackling some interesting LLVM IR issues; along the way. Full Code Listing; =================. Here is the complete code listing for our running example, enhanced with; the LLVM JIT and optimizer. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. If you are compiling this on Linux, make sure to add the ""-rdynamic""; option as well. This makes sure that the e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:24315,simpl,simple,24315,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['simpl'],['simple']
Usability,"can modify the; entities described in an earlier precompiled header. For example, later; precompiled headers can add entries into the various name-lookup tables for; the translation unit or namespaces, or add new categories to an Objective-C; class. Each of these updates is captured in an ""update record"" that is; stored in the chained precompiled header file and will be loaded along with; the original entity. .. _pchinternals-modules:. Modules; -------. Modules generalize the chained precompiled header model yet further, from a; linear chain of precompiled headers to an arbitrary directed acyclic graph; (DAG) of AST files. All of the same techniques used to make chained; precompiled headers work --- ID number, name lookup, update records --- are; shared with modules. However, the DAG nature of modules introduce a number of; additional complications to the model:. Numbering of IDs; The simple, linear numbering scheme used in chained precompiled headers falls; apart with the module DAG, because different modules may end up with; different numbering schemes for entities they imported from common shared; modules. To account for this, each module file provides information about; which modules it depends on and which ID numbers it assigned to the entities; in those modules, as well as which ID numbers it took for its own new; entities. The AST reader then maps these ""local"" ID numbers into a ""global""; ID number space for the current translation unit, providing a 1-1 mapping; between entities (in whatever AST file they inhabit) and global ID numbers.; If that translation unit is then serialized into an AST file, this mapping; will be stored for use when the AST file is imported. Declaration merging; It is possible for a given entity (from the language's perspective) to be; declared multiple times in different places. For example, two different; headers can have the declaration of ``printf`` or could forward-declare; ``struct stat``. If each of those headers is included in a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:27554,simpl,simple,27554,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['simpl'],['simple']
Usability,"can only be specified for unique-suspend; returned-continuation coroutines where it must be a token value produced by; '``llvm.coro.end.results``' intrinsic. Only none token is allowed for coro.end calls in unwind sections. Semantics:; """"""""""""""""""""; The purpose of this intrinsic is to allow frontends to mark the cleanup and; other code that is only relevant during the initial invocation of the coroutine; and should not be present in resume and destroy parts. In returned-continuation lowering, ``llvm.coro.end`` fully destroys the; coroutine frame. If the second argument is `false`, it also returns from; the coroutine with a null continuation pointer, and the next instruction; will be unreachable. If the second argument is `true`, it falls through; so that the following logic can resume unwinding. In a yield-once; coroutine, reaching a non-unwind ``llvm.coro.end`` without having first; reached a ``llvm.coro.suspend.retcon`` has undefined behavior. The remainder of this section describes the behavior under switched-resume; lowering. This intrinsic is lowered when a coroutine is split into; the start, resume and destroy parts. In the start part, it is a no-op,; in resume and destroy parts, it is replaced with `ret void` instruction and; the rest of the block containing `coro.end` instruction is discarded.; In landing pads it is replaced with an appropriate instruction to unwind to; caller. The handling of coro.end differs depending on whether the target is; using landingpad or WinEH exception model. For landingpad based exception model, it is expected that frontend uses the; `coro.end`_ intrinsic as follows:. .. code-block:: llvm. ehcleanup:; %InResumePart = call i1 @llvm.coro.end(ptr null, i1 true, token none); br i1 %InResumePart, label %eh.resume, label %cleanup.cont. cleanup.cont:; ; rest of the cleanup. eh.resume:; %exn = load ptr, ptr %exn.slot, align 8; %sel = load i32, ptr %ehselector.slot, align 4; %lpad.val = insertvalue { ptr, i32 } undef, ptr %exn, 0; %lpad.va",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:44146,resume,resume,44146,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"case, you should install ```openssl-devel```, re-compile Python and ```configure```; will automatically link against the required libraries and produce a binary with SSL; support. #### Ubuntu/Debian; On Debian, Ubuntu, Linux Mint, CrunchBang, or any other distro based on Debian; which supports APT package manager, you can install all the required packages by:; ```sh; sudo apt-get update; sudo apt-get install git g++ debhelper devscripts gnupg python; ```; You are not required to do this manually since CPT can do this for you automatically. ###### Setting up:; Make sure GnuPG is properly set up with your correct fingerprint. These; credentials are needed to sign the Debian package and create Debian changelogs.; On a build machine (Electric Commander), make sure the fingerprint is of the; user who is supposed to sign the official uploads. You might also want to; configure GnuPG to not ask for the passphrase while signing the Debian package. The [Ubuntu Packaging Guide] contains a quick guide on creating a GPG key on an; Ubuntu system. To test if you have successfully set up your GnuPG key, use the following command:; ```sh; gpg --fingerprint; ```; Again, all these checks are performed by default when you launch CPT with ```-c``` option.; [Ubuntu Packaging Guide]:http://packaging.ubuntu.com/html/getting-set-up.html#create-your-gpg-key. #### Windows; CPT is meant to be executed on cmd.exe prompt. Make sure you have set the; environment properly before continuing.; Below is a list of required packages for Windows (Win32-x86):. [MSYS Git] for Windows. [Python] for Windows. Microsoft Visual Studio 11 (2012), with Microsoft Visual C++ 2012. [MSYS Git]:http://msysgit.github.io/; [Python]:https://www.python.org/. ###### Setting Up:; Unlike other UNIX-like platforms, Windows requires you to follow some rules.; Do not ignore this section unless you want CPT to fail mid-way with wierd; errors. You should require these instructions only once. * While installing the packages make ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md:3197,guid,guide,3197,interpreter/cling/tools/packaging/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md,1,['guid'],['guide']
Usability,"cause they can all be seen together. Each option acts as a switch and; can be either ""on"" or ""off"". It is never changed in contents. Checkboxes; differ from radio buttons in that they permit selection of more than one; alternative. Each box can be switched on or off independently. These; buttons can be used alone or grouped in sets. It is good practice to; provide default settings for check boxes whenever it is possible. ![](pictures/03000213.png). This can be done by:. ``` {.cpp}; SetState(EButtonState state); ```. The parameter state can be one of `kButtonUp`, `kButtonDown`,; `kButtonEngaged`, `kButtonDisabled`. Check boxes can be used to affect other controls. The contents of a list; can, for example, be filtered by setting a check box. In any case, use a; check box only when both states of a choice are clearly opposite and; unambiguous. If opposite states are not clear, it is better to use two; radio buttons. Choice description, i.e. check box label, must be clear, meaningful,; fully spelled out, and displayed in mixed-type text. Whenever the use of; a given button is inappropriate, for whatever reason, that button should; be disabled:. ``` {.cpp}; button->SetState(kButtonDisabled);; ```. Never make a button appear and disappear. In general, option buttons should not offer more than eight choices. If; the number of choices exceeds this maximum, it is better to use a; multiple selection list box. The method `IsToggleButton()` gives the information whether a radio; button or a check button is selected. An option button can be set or; unset via its method `PSetState(EButtonState state).`. The method `HandleKey(event)` is called when the defined hotkey is hit; for any button. It sets the selected option button or clicks the; selected text button and invokes its defined action. ### Text Entries. A **`TGTextEntry`** is a one-line text input widget. It contains text; that is entered or modified through the keyboard. This text may be; displayed in different way accordin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:63297,clear,clear,63297,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['clear'],['clear']
Usability,"causing destructors of constant-evaluated structured bindings; initialized by array elements to be called in the wrong evaluation context. - Fix crash where ill-formed code was being treated as a deduction guide and; we now produce a diagnostic. Fixes:; (`#65522 <https://github.com/llvm/llvm-project/issues/65522>`_). - Fixed a bug where clang incorrectly considered implicitly generated deduction; guides from a non-templated constructor and a templated constructor as ambiguous,; rather than prefer the non-templated constructor as specified in; [standard.group]p3. - Fixed a crash caused by incorrect handling of dependence on variable templates; with non-type template parameters of reference type. Fixes:; (`#65153 <https://github.com/llvm/llvm-project/issues/65153>`_). - Clang now properly compares constraints on an out of line class template; declaration definition. Fixes:; (`#61763 <https://github.com/llvm/llvm-project/issues/61763>`_). - Fix a bug where implicit deduction guides are not correctly generated for nested template; classes. Fixes:; (`#46200 <https://github.com/llvm/llvm-project/issues/46200>`_); (`#57812 <https://github.com/llvm/llvm-project/issues/57812>`_). - Diagnose use of a variable-length array in a coroutine. The design of; coroutines is such that it is not possible to support VLA use. Fixes:; (`#65858 <https://github.com/llvm/llvm-project/issues/65858>`_). - Fix bug where we were overriding zero-initialization of class members when; default initializing a base class in a constant expression context. Fixes:; (`#69890 <https://github.com/llvm/llvm-project/issues/69890>`_). - Fix crash when template class static member imported to other translation unit.; Fixes:; (`#68769 <https://github.com/llvm/llvm-project/issues/68769>`_). - Clang now rejects incomplete types for ``__builtin_dump_struct``. Fixes:; (`#63506 <https://github.com/llvm/llvm-project/issues/63506>`_). - Fixed a crash for C++98/03 while checking an ill-formed ``_Static_assert`` expressi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:52009,guid,guides,52009,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['guid'],['guides']
Usability,"ce Code Transformation takes the source code (that needs to be; differentiated) as the input and generates an output code that represents the; derivative of the input. This output code can be used instead of the input; code for more efficient compilation. For more technical details, please see the following paper:. > [Automatic Differentiation of Binned Likelihoods with RooFit and Clad](https://arxiv.org/abs/2304.02650). ## Overview on RooFit implementation details to access source code transformation AD. In RooFit jargon, what is meant by a ""RooFit class"" is a class inheriting from; RooAbsArg that represents a mathematical function, a PDF, or any other; transformation of inputs that are also represented by RooAbsArg objects.; Almost all final classes deriving from RooAbsArg have RooAbsReal as an; intermediate base class, which is the base class for all RooAbsArg that; represent real-valued nodes in the computation graph.; As such RooFit objects are so prevalent in practice, the names RooAbsArg and; RooAbsReal are used interchangeably in this guide. Users take these classes to build a computational graph that represents the; PDF (also called ""model"") that they want to use for fitting the data.; The user then passes his final PDF and a RooAbsData object to the; RooAbsPdf::fitTo() method, which implicitly creates a negative-log likelihood; (NLL) that RooFit minimizes for parameter estimation.; The NLL object, internally created by RooAbsPdf::createNLL(), is a RooAbsArg; itself.; In technical terms, it's another larger computation graph that encompasses the; computation graph representing the PDF. To enable source code transformation AD for RooFit NLLs with Clad, RooFit has a; routine that can traverse a computation graph made of RooAbsArg objects and; transform it to much simpler C++ code that mathematically represents the same; computation, but without any overhead that is hard to digest by the AD tool. On a high level, this *code generation* is implemented as follow",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:3468,guid,guide,3468,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['guid'],['guide']
Usability,"ce and the; stability of the C++ API that it wraps. In practice, this means that things; like ""create debug info"" or ""create this type of instruction"" are likely to be; less stable than ""take this IR file and JIT it for my current machine"". * Release stability: We won't break the C API on the release branch with patches; that go on that branch, with the exception that we will fix an unintentional; C API break that will keep the release consistent with both the previous and; next release. * Testing: Patches to the C API are expected to come with tests just like any; other patch. * Including new things into the API: If an LLVM subcomponent has a C API already; included, then expanding that C API is acceptable. Adding C API for; subcomponents that don't currently have one needs to be discussed on the; `LLVM Discourse forums`_ for design and maintainability feedback prior to implementation. * Documentation: Any changes to the C API are required to be documented in the; release notes so that it's clear to external users who do not follow the; project how the C API is changing and evolving. .. _toolchain:. Updating Toolchain Requirements; -------------------------------. We intend to require newer toolchains as time goes by. This means LLVM's; codebase can use newer versions of C++ as they get standardized. Requiring newer; toolchains to build LLVM can be painful for those building LLVM; therefore, it; will only be done through the following process:. * It is a general goal to support LLVM and GCC versions from the last 3 years; at a minimum. This time-based guideline is not strict: we may support much; older compilers, or decide to support fewer versions. * An RFC is sent to the `LLVM Discourse forums`_. - Detail upsides of the version increase (e.g. which newer C++ language or; library features LLVM should use; avoid miscompiles in particular compiler; versions, etc).; - Detail downsides on important platforms (e.g. Ubuntu LTS status). * Once the RFC reaches consensus, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:33802,clear,clear,33802,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['clear'],['clear']
Usability,"ced that ``%simplified`` is narrower than ``%c``: this is not; a problem, because ``llvm::replaceAllDbgUsesWith`` takes care of inserting the; necessary conversion operations into the DIExpressions of updated debug uses. Deleting a MIR-level MachineInstr; ---------------------------------. TODO. Rules for updating ``DIAssignID`` Attachments; =============================================. ``DIAssignID`` metadata attachments are used by Assignment Tracking, which is; currently an experimental debug mode. See :doc:`AssignmentTracking` for how to update them and for more info on; Assignment Tracking. How to automatically convert tests into debug info tests; ========================================================. .. _IRDebugify:. Mutation testing for IR-level transformations; ---------------------------------------------. An IR test case for a transformation can, in many cases, be automatically; mutated to test debug info handling within that transformation. This is a; simple way to test for proper debug info handling. The ``debugify`` utility pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``debugify`` testing utility is just a pair of passes: ``debugify`` and; ``check-debugify``. The first applies synthetic debug information to every instruction of the; module, and the second checks that this DI is still available after an; optimization has occurred, reporting any errors/warnings while doing so. The instructions are assigned sequentially increasing line locations, and are; immediately used by debug value intrinsics everywhere possible. For example, here is a module before:. .. code-block:: llvm. define void @f(i32* %x) {; entry:; %x.addr = alloca i32*, align 8; store i32* %x, i32** %x.addr, align 8; %0 = load i32*, i32** %x.addr, align 8; store i32 10, i32* %0, align 4; ret void; }. and after running ``opt -debugify``:. .. code-block:: llvm. define void @f(i32* %x) !dbg !6 {; entry:; %x.addr = alloca i32*, align 8, !dbg !12; call void @llvm.dbg.value(metadata i32** %x.addr,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:9530,simpl,simple,9530,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['simpl'],['simple']
Usability,"cement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversion. The second use case is the; computation of the global transformation of a given object in the; geometry. Since the geometry is built as 'volumes-inside-volumes', the; global transformation represents the pile-up of all local; transformations in the corresponding branch. Once a given object in the; hierarchy becomes the current one, the conversion from master to local; coordinates or the other way around can be done from the manager class. A general homogenous transformation is defined as a 4x4 matrix embedding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous; matrix, composition being performed as simple matrix multiplication. Rotation:. \f[; \left|\begin{array}{cccc}; r_{11} & r_{12} & r_{13} & 0 \\; r_{21} & r_{22} & r_{23} & 0 \\; r_{31} & r_{32} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \f]. Translation:. \f[; \left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; t_x & t_y & t_z & 1; \end{array}; \right|; \f]. Scale:. \f[; \left|\begin{array}{cccc}; s_x & 0 & 0 & 0 \\; 0 & s_y & 0 & 0 \\; 0 & 0 & s_z & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \f]. Inverse rotation:. \f[; \left|\begin{array}{cccc}; r_{11} & r_{21} & r_{31} & 0 \\; r_{12} & r_{22} & r_{32} & 0 \\; r_{13} & r_{23} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \f]. Inverse translation:. \f[; \left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; -t_x & -t_y & -t_z & 1; \end{array}; \right|; \f]. Inverse scale:. \f[; \left|\begin{array}{cccc}; \frac{1}{s_x} & 0 & 0 & 0 \\; 0 & \frac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:52756,simpl,simple,52756,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"cement of a volume with respect to its container; reference frame. This frame will be called 'master' and the frame of the; positioned volume - 'local'. If `T` is a transformation used for; positioning volume daughters, then: `MASTER = T * LOCAL`. Therefore `T `is used to perform a local to master conversion, while; `T-1` for a master to local conversion. The second use case is the; computation of the global transformation of a given object in the; geometry. Since the geometry is built as 'volumes-inside-volumes', the; global transformation represents the pile-up of all local; transformations in the corresponding branch. Once a given object in the; hierarchy becomes the current one, the conversion from master to local; coordinates or the other way around can be done from the manager class. A general homogenous transformation is defined as a 4x4 matrix embedding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous; matrix, composition being performed as simple matrix multiplication. Rotation:; $\left|\begin{array}{cccc}; r_{11} & r_{12} & r_{13} & 0 \\; r_{21} & r_{22} & r_{23} & 0 \\; r_{31} & r_{32} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|$; Translation:; $\left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; t_x & t_y & t_z & 1; \end{array}; \right|$; Scale:; $\left|\begin{array}{cccc}; s_x & 0 & 0 & 0 \\; 0 & s_y & 0 & 0 \\; 0 & 0 & s_z & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|$. Inverse rotation:; $\left|\begin{array}{cccc}; r_{11} & r_{21} & r_{31} & 0 \\; r_{12} & r_{22} & r_{32} & 0 \\; r_{13} & r_{23} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|$; Inverse translation:; $\left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; -t_x & -t_y & -t_z & 1; \end{array}; \right|$; Inverse scale:; $\left|\begin{array}{cccc}; \frac{1}{s_x} & 0 & 0 & 0 \\; 0 & \frac{1}{s_y} & 0 & 0 \\; 0 & 0 & \frac{1}{s_z} &",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:92429,simpl,simple,92429,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['simpl'],['simple']
Usability,"cheme:. ``<base>-<arch>.opt.<format>``. Note that this is incompatible with passing the; :option:`-foptimization-record-file` option. .. option:: -foptimization-record-file. Control the file to which optimization reports are written. This implies; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`. On Darwin platforms, this is incompatible with passing multiple; ``-arch <arch>`` options. .. option:: -foptimization-record-passes. Only include passes which match a specified regular expression. When optimization reports are being output (see; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`), this; option controls the passes that will be included in the final report. If this option is not used, all the passes are included in the optimization; record. .. _opt_fdiagnostics-show-hotness:. .. option:: -f[no-]diagnostics-show-hotness. Enable profile hotness information in diagnostic line. This option controls whether Clang prints the profile hotness associated; with diagnostics in the presence of profile-guided optimization information.; This is currently supported with optimization remarks (see; :ref:`Options to Emit Optimization Reports <rpass>`). The hotness information; allows users to focus on the hot optimization remarks that are likely to be; more relevant for run-time performance. For example, in this output, the block containing the callsite of `foo` was; executed 3000 times according to the profile data:. ::. s.c:7:10: remark: foo inlined into bar (hotness: 3000) [-Rpass-analysis=inline]; sum += foo(x, x - 2);; ^. This option is implied when; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>` is used.; Otherwise, it defaults to off. .. option:: -fdiagnostics-hotness-threshold. Prevent optimization remarks from being output if they do not have at least; this hotness value. This option, which defaults to zero, controls the minimum hotness an; optimization remark would need in order to be output by Clang. This is; current",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:13985,guid,guided,13985,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['guid'],['guided']
Usability,"cher<Decl>classTemplateSpecializationDeclMatcher<ClassTemplateSpecializationDecl>...; Matches C++ class template specializations. Given; template<typename T> class A {};; template<> class A<double> {};; A<int> a;; classTemplateSpecializationDecl(); matches the specializations A<int> and A<double>. Matcher<Decl>conceptDeclMatcher<ConceptDecl>...; Matches concept declarations. Example matches integral; template<typename T>; concept integral = std::is_integral_v<T>;. Matcher<Decl>cxxConstructorDeclMatcher<CXXConstructorDecl>...; Matches C++ constructor declarations. Example matches Foo::Foo() and Foo::Foo(int); class Foo {; public:; Foo();; Foo(int);; int DoSomething();; };. Matcher<Decl>cxxConversionDeclMatcher<CXXConversionDecl>...; Matches conversion operator declarations. Example matches the operator.; class X { operator int() const; };. Matcher<Decl>cxxDeductionGuideDeclMatcher<CXXDeductionGuideDecl>...; Matches user-defined and implicitly generated deduction guide. Example matches the deduction guide.; template<typename T>; class X { X(int) };; X(int) -> X<int>;. Matcher<Decl>cxxDestructorDeclMatcher<CXXDestructorDecl>...; Matches explicit C++ destructor declarations. Example matches Foo::~Foo(); class Foo {; public:; virtual ~Foo();; };. Matcher<Decl>cxxMethodDeclMatcher<CXXMethodDecl>...; Matches method declarations. Example matches y; class X { void y(); };. Matcher<Decl>cxxRecordDeclMatcher<CXXRecordDecl>...; Matches C++ class declarations. Example matches X, Z; class X;; template<class T> class Z {};. Matcher<Decl>declMatcher<Decl>...; Matches declarations. Examples matches X, C, and the friend declaration inside C;; void X();; class C {; friend X;; };. Matcher<Decl>declaratorDeclMatcher<DeclaratorDecl>...; Matches declarator declarations (field, variable, function; and non-type template parameter declarations). Given; class X { int y; };; declaratorDecl(); matches int y. Matcher<Decl>decompositionDeclMatcher<DecompositionDecl>...; Matches decomposition-decla",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:11615,guid,guide,11615,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['guid'],['guide']
Usability,"cility environment; --------------------------------------------------. The Virtual Analysis Facility client is a wrapper around commands sent; to the remote host by means of PROOF on Demand's `pod-remote`. The VAF; client takes care of setting up passwordless SSH from your client node; to the VAF master. ### Getting the credentials. > You can skip this paragraph if the remote server wasn't configured for; > HTTPS+SSH authentication. In our example we will assume that the remote server's name is; `cloud-gw-213.to.infn.it`: substitute it with your remote endpoint. First, check that you have your Grid certificate and private key; installed both in your browser and in the home directory of your; client. Point your browser to `https://cloud-gw-213.to.infn.it/auth/`: you'll; probably be asked for a certificate to choose for authentication. Pick; one and you'll be presented with the following web page:. ![Web authentication with sshcertauth](img/sshcertauth-web.png). The webpage clearly explains you what to do next. ### Customizing user's configuration. Before entering the VAF environment, you should customize the user's; configuration. How to do so depends on your experiment, but usually you; should essentially specify the version of the experiment's software you; need. For instance, in the CMS use case, only one file is needed:; `~/.vaf/common.before`, which contains something like:. ``` {.bash}; # Version of CMSSW (as reported by ""scram list""); export VafCmsswVersion='CMSSW_5_3_9_sherpa2beta2'; ```. ### Entering the VAF environment. Open a terminal on your client machine (can be either your local; computer or a remote user interface) and type:. vaf-enter <username>@cloud-gw-213.to.infn.it. You'll substitute `<username>` with the username that either your system; administrator or the web authentication (if you used it) provided you. You'll be presented with a neat shell which looks like the following:. Entering VAF environment: dberzano@cloud-gw-213.to.infn.it; Remember",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:9124,clear,clearly,9124,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['clear'],['clearly']
Usability,"cipate in the project using GitHub. Branches; ========. It is possible to create branches that starts with `users/<username>/`, however this is; intended to be able to support ""stacked"" pull-request. Do not create any branches in the; llvm/llvm-project repository otherwise, please use a fork (see below). User branches that; aren't associated with a pull-request **will be deleted**. Pull Requests; =============; The LLVM project is using GitHub Pull Requests for Code Reviews. This document; describes the typical workflow of creating a Pull Request and getting it reviewed; and accepted. This is meant as an overview of the GitHub workflow, for complete; documentation refer to `GitHub's documentation <https://docs.github.com/pull-requests>`_. GitHub Tools; ------------; You can interact with GitHub in several ways: via git command line tools,; the web browser, `GitHub Desktop <https://desktop.github.com/>`_, or the; `GitHub CLI <https://cli.github.com>`_. This guide will cover the git command line; tools and the GitHub CLI. The GitHub CLI (`gh`) will be most like the `arc` workflow and; recommended. Creating Pull Requests; ----------------------; Keep in mind that when creating a pull request, it should generally only contain one; self-contained commit initially.; This makes it easier for reviewers to understand the introduced changes and; provide feedback. It also helps maintain a clear and organized commit history; for the project. If you have multiple changes you want to introduce, it's; recommended to create separate pull requests for each change. Create a local branch per commit you want to submit and then push that branch; to your `fork <https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks>`_; of the llvm-project and; `create a pull request from the fork <https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork>`_.; As GitH",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:1474,guid,guide,1474,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['guid'],['guide']
Usability,"ck.C.`. ``` {.cpp}; {; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide (1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs->Draw(""nostack"");; }; ```. ## TH2Poly. `TH2Poly` is a 2D Histogram class allowing to define polygonal bins of; arbitrary shape. Each bin in the `TH2Poly` histogram is a `TH2PolyBin` object.; `TH2PolyBin` is a very simple class containing the vertices and; contents of the polygonal bin as well as several related functions. Bins are defined using one of the `AddBin()` methods. The bin; definition should be done before filling. The following very simple macro shows how to build and fill a; `TH2Poly`:. ``` {.cpp}; {; TH2Poly *h2p = new TH2Poly();; Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 4.7, 3.5};; h2p->AddBin(3, x1, y1);; h2p->AddBin(3, x2, y2);; h2p->AddBin(3, x3, y3);; h2p->Fill( 3, 1, 3); // fill bin 1; h2p->Fill(-0.5, -0.5, 7); // fill bin 2; h2p->Fill(-0.7, -0.5, 1); // fill bin 2; h2p->Fill( 1, 3, 5); // fill bin 3; }; ```. More examples can bin found in `$ROOTSYS/tutorials/hist/th2poly*.C`. ![A TH2Poly histogram example](pictures/th2poly1.png). ## Profile Histograms. Profile histograms are in many cases an elegant replacement of; two-dimensional histograms. The relationship of two quantities X and Y; can be visualized by a two-dimensional histogram or a scatter-plot;; its representation is not particularly satisfactory, except for sparse; data. If Y is an unknown [but single-valued] function of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:60652,simpl,simple,60652,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['simpl'],['simple']
Usability,"ckstartTemplate.md`. You; should copy it, open the new file in your text editor, write your docs, and; then send the new document to llvm-commits for review. Focus on *content*. It is easy to fix the Markdown syntax; later if necessary, although Markdown tries to imitate common; plain-text conventions so it should be quite natural. A basic knowledge of; Markdown syntax is useful when writing the document, so the last; ~half of this document (starting with [Example Section](#example-section)) gives examples; which should cover 99% of use cases. Let me say that again: focus on *content*. But if you really need to verify; Sphinx's output, see `docs/README.txt` for information. Once you have finished with the content, please send the `.md` file to; llvm-commits for review. ## Guidelines. Try to answer the following questions in your first section:. 1. Why would I want to read this document?. 2. What should I know to be able to follow along with this document?. 3. What will I have learned by the end of this document?. Common names for the first section are `Introduction`, `Overview`, or; `Background`. If possible, make your document a ""how to"". Give it a name `HowTo*.md`; like the other ""how to"" documents. This format is usually the easiest; for another person to understand and also the most useful. You generally should not be writing documentation other than a ""how to""; unless there is already a ""how to"" about your topic. The reason for this; is that without a ""how to"" document to read first, it is difficult for a; person to understand a more advanced document. Focus on content (yes, I had to say it again). The rest of this document shows example Markdown markup constructs; that are meant to be read by you in your text editor after you have copied; this file into a new file for the documentation you are about to write. ## Example Section. Your text can be *emphasized*, **bold**, or `monospace`. Use blank lines to separate paragraphs. Headings (like `Example Section` just",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MarkdownQuickstartTemplate.md:1445,learn,learned,1445,interpreter/llvm-project/llvm/docs/MarkdownQuickstartTemplate.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MarkdownQuickstartTemplate.md,1,['learn'],['learned']
Usability,"class is the parent of the **`TCanvas`**; class. In ROOT, most objects derive from a base class **`TObject`**.; This class has a virtual method `Draw()` such as all objects are; supposed to be able to be ""drawn"". If several canvases are defined,; there is only one active at a time. One draws an object in the active; canvas by using the statement:. ``` {.cpp}; object.Draw(); ```. This instructs the object ""`object`"" to draw itself. If no canvas is; opened, a default one (named ""`c1`"") is created. In the next example,; the first statement defines a function and the second one draws it. A; default canvas is created since there was no opened one. You should; see the picture as shown in the next figure. ``` {.cpp}; root[] TF1 f1(""func1"",""sin(x)/x"",0,10); root[] f1.Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; ```. ![A canvas with drawing](pictures/0300000A.png). The following components comprise the canvas window:. - Menu bar - contains main menus for global operations with files,; print, clear canvas, inspect, etc. - Tool bar - has buttons for global and drawing operations; such as; arrow, ellipse, latex, pad, etc. - Canvas - an area to draw objects. - Status bar - displays descriptive messages about the selected; object. - Editor frame - responds dynamically and presents the user; interface according to the selected object in the canvas. ### Main Menus and Toolbar. At the top of the canvas window are File, Edit, View, Options,; Inspect, Classes and Help menus. #### File Menu. - *New Canvas*: creates a new canvas window in the current ROOT; session. - *Open...*: popup a dialog to open a file. - *Close Canvas*: close the canvas window. - *Save*: save the drawing of the current canvas in a format; selectable from the submenu. The current canvas name is used as a; file name for various formats such as PostScript, GIF, JPEG, C; macro file, root file. - *Save As...*: popup a dialog for saving the current canvas drawing; in a new filename. - *Print*: ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:7069,clear,clear,7069,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['clear'],['clear']
Usability,"class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression; Unknown. 1011; C++11; Standard conversions that cannot be inverted; Unknown. 1012; C++11; Undeprecating static; Unknown. 1013; CD3; Uninitialized std::nullptr_t objects; Unknown. 1014; NAD; Overload resolution between const T& and T&&; Unknown. 1015; C++11; Template arguments and argument-dependent lookup; Unknown. 1016; C++11; Overloadable declarations, function templates, and references; Unknown. 1017; C++11; Member access transformation in unevaluated operands; Unknown. 1018; C++11; Ambiguity between simple-declaration and attribute-declaration; Unknown. 1019; dup; Dependent simple-template-ids in base-specifiers and mem-initializers; Unknown. 1020; C++11; Implicitly-defined copy constructors and explicit base class constructors; Unknown. 1021; CD4; Definitions of namespace members; Unknown. 1022; C++11; Can an enumeration variable have values outside the values of the enumeration?; Unknown. 1023; dup; thread_local objects as non-type template arguments; Unknown. 1024; CD3; Limits on multicharacter literals; Unknown. 1025; C++11; Use of a reference as a non-type template argument; Unknown. 1026; NAD; Cv-qualified non-class rvalues; Unknown. 1027; review; Type consistency and reallocation of scalar types; Not resolved. 1028; CD6; Dependent names in non-defining declarations; Unknown. 1029; C++11; Type of a destructor call; Unknown. 1030; C++11; Evaluation order in initializer-lists used in aggregate initialization; Unknown. 1031; C++11; Optional elements in attributes; Unknown. 1032; C++11; Empty pack expansions; Unknown. 1033; C++11; Restrictions on alignment attributes; Unknown.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:67210,simpl,simple-template-ids,67210,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['simpl'],['simple-template-ids']
Usability,"cleanuppad``. New instructions are also used to mark the points where control is transferred; out of a catch/cleanup handler (which will correspond to exits from the; generated funclet). A catch handler which reaches its end by normal execution; executes a ``catchret`` instruction, which is a terminator indicating where in; the function control is returned to. A cleanup handler which reaches its end; by normal execution executes a ``cleanupret`` instruction, which is a terminator; indicating where the active exception will unwind to next. Each of these new EH pad instructions has a way to identify which action should; be considered after this action. The ``catchswitch`` instruction is a terminator; and has an unwind destination operand analogous to the unwind destination of an; invoke. The ``cleanuppad`` instruction is not; a terminator, so the unwind destination is stored on the ``cleanupret``; instruction instead. Successfully executing a catch handler should resume; normal control flow, so neither ``catchpad`` nor ``catchret`` instructions can; unwind. All of these ""unwind edges"" may refer to a basic block that contains an; EH pad instruction, or they may unwind to the caller. Unwinding to the caller; has roughly the same semantics as the ``resume`` instruction in the landingpad; model. When inlining through an invoke, instructions that unwind to the caller; are hooked up to unwind to the unwind destination of the call site. Putting things together, here is a hypothetical lowering of some C++ that uses; all of the new IR instructions:. .. code-block:: c. struct Cleanup {; Cleanup();; ~Cleanup();; int m;; };; void may_throw();; int f() noexcept {; try {; Cleanup obj;; may_throw();; } catch (int e) {; may_throw();; return e;; }; return 0;; }. .. code-block:: text. define i32 @f() nounwind personality ptr @__CxxFrameHandler3 {; entry:; %obj = alloca %struct.Cleanup, align 4; %e = alloca i32, align 4; %call = invoke ptr @""??0Cleanup@@QEAA@XZ""(ptr nonnull %obj); to la",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:27083,resume,resume,27083,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['resume'],['resume']
Usability,"codes can be found at; :doc:`GenericOpcode`. The ``MachineIRBuilder`` class wraps the ``MachineInstrBuilder`` and provides; a convenient way to create these generic instructions. .. _gmir-gvregs:. Generic Virtual Registers; -------------------------. .. note::. This section expands on :ref:`mir-registers` from the MIR Language; Reference. Generic virtual registers are like virtual registers but they are not assigned a; Register Class constraint. Instead, generic virtual registers have less strict; constraints starting with a :ref:`gmir-llt` and then further constrained to a; :ref:`gmir-regbank`. Eventually they will be constrained to a register class; at which point they become normal virtual registers. Generic virtual registers can be used with all the virtual register API's; provided by ``MachineRegisterInfo``. In particular, the def-use chain API's can; be used without needing to distinguish them from non-generic virtual registers. For simplicity, most generic instructions only accept virtual registers (both; generic and non-generic). There are some exceptions to this but in general:. * instead of immediates, they use a generic virtual register defined by an; instruction that materializes the immediate value (see; :ref:`irtranslator-constants`). Typically this is a G_CONSTANT or a; G_FCONSTANT. One example of an exception to this rule is G_SEXT_INREG where; having an immediate is mandatory.; * instead of physical register, they use a generic virtual register that is; either defined by a ``COPY`` from the physical register or used by a ``COPY``; that defines the physical register. .. admonition:: Historical Note. We started with an alternative representation, where MRI tracks a size for; each generic virtual register, and instructions have lists of types.; That had two flaws: the type and size are redundant, and there was no generic; way of getting a given operand's type (as there was no 1:1 mapping between; instruction types and operands).; We considered putting t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst:2087,simpl,simplicity,2087,interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,1,['simpl'],['simplicity']
Usability,"color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int zlight; // z position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int shadow; // determines whether shadow will be drawn (no shadow, shadow),; // for rainbowed display modes with shading according to light; int shading; // determines whether the picture will shaded, smoothed (no shading,; // shading), for rainbowed display modes only; int bezier; // determines Bezier interpolation (applies only for simple display; // modes group for grid, x_lines, y_lines display modes); int border_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the rasters are shown; int raster_long; // decides whether the rasters are drawn as long lines; int raster_color; // color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description; char *raster_description_z; // z axis description; int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_color; // color of channel marks; int chanline_en_dis; // decides whether the channel lines (grid) are shown.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:79327,simpl,simple,79327,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['simpl'],['simple']
Usability,com/civetweb/civetweb/issues/812)). Trouble tickets should be filed on GitHub; [https://github.com/civetweb/civetweb/issues](https://github.com/civetweb/civetweb/issues). New releases are announced at Google Groups; [https://groups.google.com/d/forum/civetweb](https://groups.google.com/d/forum/civetweb). Formerly some support question and discussion threads have been at [Google groups](https://groups.google.com/d/forum/civetweb).; Recent questions and discussions use [GitHub issues](https://github.com/civetweb/civetweb/issues). Source releases can be found on GitHub; [https://github.com/civetweb/civetweb/releases](https://github.com/civetweb/civetweb/releases). A very brief overview can be found on GitHub Pages; [http://civetweb.github.io/civetweb/](http://civetweb.github.io/civetweb/). Getting The Source; ------------------; Download the source code by running the following code in your command prompt:. $ git clone https://github.com/civetweb/civetweb.git; or simply grab a copy of the source code as a ZIP or TGZ file. Quick start documentation; --------------------------. - [docs/Installing.md](https://github.com/civetweb/civetweb/blob/master/docs/Installing.md) - Install Guide (for end users using pre-built binaries); - [docs/UserManual.md](https://github.com/civetweb/civetweb/blob/master/docs/UserManual.md) - End User Guide; - [docs/Building.md](https://github.com/civetweb/civetweb/blob/master/docs/Building.md) - Building the Server (quick start guide); - [docs/Embedding.md](https://github.com/civetweb/civetweb/blob/master/docs/Embedding.md) - Embedding (how to add HTTP support to an existing application); - [docs/OpenSSL.md](https://github.com/civetweb/civetweb/blob/master/docs/OpenSSL.md) - Adding HTTPS (SSL/TLS) support using OpenSSL.; - [API documentation](https://github.com/civetweb/civetweb/tree/master/docs/api) - Additional documentation on the civetweb application programming interface ([civetweb.h](https://github.com/civetweb/civetweb/blob/master/include/,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:3808,simpl,simply,3808,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['simpl'],['simply']
Usability,"com/llvm/llvm-project/issues/47355>`_; - Fixed a bug where Template Instantiation failed to handle Lambda Expressions; with certain types of Attributes.; (`#76521 <https://github.com/llvm/llvm-project/issues/76521>`_). Miscellaneous Bug Fixes; ^^^^^^^^^^^^^^^^^^^^^^^. Miscellaneous Clang Crashes Fixed; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; - Fixed a crash when parsing top-level ObjC blocks that aren't properly; terminated. Clang should now also recover better when an @end is missing; between blocks.; `Issue 64065 <https://github.com/llvm/llvm-project/issues/64065>`_; - Fixed a crash when check array access on zero-length element.; `Issue 64564 <https://github.com/llvm/llvm-project/issues/64564>`_; - Fixed a crash when an ObjC ivar has an invalid type. See; (`#68001 <https://github.com/llvm/llvm-project/pull/68001>`_); - Fixed a crash in C when redefined struct is another nested redefinition.; `Issue 41302 <https://github.com/llvm/llvm-project/issues/41302>`_; - Fixed a crash when ``-ast-dump=json`` was used for code using class; template deduction guides.; - Fixed a crash when a lambda marked as ``static`` referenced a captured; variable in an expression.; `Issue 74608 <https://github.com/llvm/llvm-project/issues/74608>`_; - Fixed a crash with modules and a ``constexpr`` destructor.; `Issue 68702 <https://github.com/llvm/llvm-project/issues/68702>`_. OpenACC Specific Changes; ------------------------; - OpenACC Implementation effort is beginning with semantic analysis and parsing; of OpenACC pragmas. The ``-fopenacc`` flag was added to enable these new,; albeit incomplete changes. The ``_OPENACC`` macro is currently defined to; ``1``, as support is too incomplete to update to a standards-required value.; - Added ``-fexperimental-openacc-macro-override``, a command line option to; permit overriding the ``_OPENACC`` macro to be any digit-only value specified; by the user, which permits testing the compiler against existing OpenACC; workloads in order to evaluate implemen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:58164,guid,guides,58164,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['guid'],['guides']
Usability,"completion of a send of ``release`` that is not; preceded by a send of ``retain`` to the same object. The behavior of ``autorelease`` must be equivalent to sending ``release`` when; one of the autorelease pools currently in scope is popped. It may not throw an; exception. When the semantics call for performing one of these operations on a retainable; object pointer, if that pointer is ``null`` then the effect is a no-op. All of the semantics described in this document are subject to additional; :ref:`optimization rules <arc.optimization>` which permit the removal or; optimization of operations based on local knowledge of data flow. The; semantics describe the high-level behaviors that the compiler implements, not; an exact sequence of operations that a program will be compiled into. .. _arc.objects.operands:. Retainable object pointers as operands and arguments; ----------------------------------------------------. In general, ARC does not perform retain or release operations when simply using; a retainable object pointer as an operand within an expression. This includes:. * loading a retainable pointer from an object with non-weak :ref:`ownership; <arc.ownership>`,; * passing a retainable pointer as an argument to a function or method, and; * receiving a retainable pointer as the result of a function or method call. .. admonition:: Rationale. While this might seem uncontroversial, it is actually unsafe when multiple; expressions are evaluated in ""parallel"", as with binary operators and calls,; because (for example) one expression might load from an object while another; writes to it. However, C and C++ already call this undefined behavior; because the evaluations are unsequenced, and ARC simply exploits that here to; avoid needing to retain arguments across a large number of calls. The remainder of this section describes exceptions to these rules, how those; exceptions are detected, and what those exceptions imply semantically. .. _arc.objects.operands.consumed:. Co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:15556,simpl,simply,15556,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['simpl'],['simply']
Usability,"consistency; ^^^^^^^^^^^^^^^^^^^^^^^. The C++ language defines that same declarations in different translation units should have; the same definition, as known as ODR (One Definition Rule). Prior to modules, the translation; units don't dependent on each other and the compiler itself can't perform a strong; ODR violation check. With the introduction of modules, now the compiler have; the chance to perform ODR violations with language semantics across translation units. However, in the practice, we found the existing ODR checking mechanism is not stable; enough. Many people suffers from the false positive ODR violation diagnostics, AKA,; the compiler are complaining two identical declarations have different definitions; incorrectly. Also the true positive ODR violations are rarely reported.; Also we learned that MSVC don't perform ODR check for declarations in the global module; fragment. So in order to get better user experience, save the time checking ODR and keep consistent; behavior with MSVC, we disabled the ODR check for the declarations in the global module; fragment by default. Users who want more strict check can still use the; ``-Xclang -fno-skip-odr-check-in-gmf`` flag to get the ODR check enabled. It is also; encouraged to report issues if users find false positive ODR violations or false negative ODR; violations with the flag enabled. ABI Impacts; -----------. The declarations in a module unit which are not in the global module fragment have new linkage names. For example,. .. code-block:: c++. export module M;; namespace NS {; export int foo();; }. The linkage name of ``NS::foo()`` would be ``_ZN2NSW1M3fooEv``.; This couldn't be demangled by previous versions of the debugger or demangler.; As of LLVM 15.x, users can utilize ``llvm-cxxfilt`` to demangle this:. .. code-block:: console. $ llvm-cxxfilt _ZN2NSW1M3fooEv. The result would be ``NS::foo@M()``, which reads as ``NS::foo()`` in module ``M``. The ABI implies that we can't declare something in a modul",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:17866,user experience,user experience,17866,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['user experience'],['user experience']
Usability,"constraint in the constraint list must have the same number of alternative; sets. With this syntax, the same alternative in *all* of the items in the; constraint list will be chosen together. Putting those together, you might have a two operand constraint string like; ``""rm|r,ri|rm""``. This indicates that if operand 0 is ``r`` or ``m``, then; operand 1 may be one of ``r`` or ``i``. If operand 0 is ``r``, then operand 1; may be one of ``r`` or ``m``. But, operand 0 and 1 cannot both be of type m. However, the use of either of the alternatives features is *NOT* recommended, as; LLVM is not able to make an intelligent choice about which one to use. (At the; point it currently needs to choose, not enough information is available to do so; in a smart way.) Thus, it simply tries to make a choice that's most likely to; compile, not one that will be optimal performance. (e.g., given ""``rm``"", it'll; always choose to use memory, not registers). And, if given multiple registers,; or multiple register classes, it will simply choose the first one. (In fact, it; doesn't currently even ensure explicitly specified physical registers are; unique, so specifying multiple physical registers as alternatives, like; ``{r11}{r12},{r11}{r12}``, will assign r11 to both operands, not at all what was; intended.). Supported Constraint Code List; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""". The constraint codes are, in general, expected to behave the same way they do in; GCC. LLVM's support is often implemented on an 'as-needed' basis, to support C; inline asm code which was supported by GCC. A mismatch in behavior between LLVM; and GCC likely indicates a bug in LLVM. Some constraint codes are typically supported by all targets:. - ``r``: A register in the target's general purpose register class.; - ``m``: A memory address operand. It is target-specific what addressing modes; are supported, typical examples are register, or register + register offset,; or register + immediate offset (of some target-specific",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:220095,simpl,simply,220095,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"cope of this document: it is worth to mention; that I/O can be performed out of the box for the almost complete set; of ROOT classes. We can explore this functionality with histograms and two simple macros. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_to_file.C; ```. Not bad, eh ? Especially for a language that does not foresees; persistency natively like C++. The *RECREATE* option forces ROOT to; create a new file even if a file with the same name exists on disk. Now, you may use the Cling command line to access information in the file; and draw the previously written histogram:. ``` {.cpp}; > root my_rootfile.root; root [0]; Attaching file my_rootfile.root as _file0...; root [1] _file0->ls(); TFile** my_rootfile.root; TFile* my_rootfile.root; KEY: TH1F	my_histogram;1 My Title; root [2] my_histogram->Draw(); ```; \newpage; Alternatively, you can use a simple macro to carry out the job:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:1514,simpl,simple,1514,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['simpl'],['simple']
Usability,"cppyy-backend; =============. C/C++ wrapper around Cling, the LLVM-based interactive C++ interpreter, for; use by cppyy, providing stable C and C++ Reflection APIs. The compilation of cppyy-backend is very fast, but it will pull in; cppyy-cling, which takes a long time to install if there is no matching wheel; for your platform, forcing a build from source. By default, all cores will be; used, but it is also recommended to add the verbose flag to see progress:. $ python -m pip install --verbose cppyy-backend. For further details, see cppyy's installation instructions:; https://cppyy.readthedocs.io/en/latest/installation.html. Cling documentation is here:; https://root.cern.ch/cling. ----. Find the cppyy documentation here:; http://cppyy.readthedocs.io. Change log:; https://cppyy.readthedocs.io/en/latest/changelog.html. Bug reports/feedback:; https://bitbucket.org/wlav/cppyy/issues?status=new&status=open; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/README.rst:843,feedback,feedback,843,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/README.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/README.rst,1,['feedback'],['feedback']
Usability,"cppyy-cling; ===========. A repackaging of Cling, the LLVM-based interactive C++ interpreter, as a; library for use as the backend to cppyy. This version of Cling is patched for; improved performance and better use with Python. Wheels are available for the major platforms, but if you have to build from; source, building of LLVM will take a long time. By default, all cores will be; used, but it is also recommended to add the verbose flag to see progress:. $ python -m pip install --verbose cppyy-cling. For further details, see cppyy's installation instructions:; https://cppyy.readthedocs.io/en/latest/installation.html. Cling documentation is here:; https://root.cern.ch/cling. ----. Full cppyy documentation is here:; http://cppyy.readthedocs.io/. Change log:; https://cppyy.readthedocs.io/en/latest/changelog.html. Bug reports/feedback:; https://bitbucket.org/wlav/cppyy/issues?status=new&status=open; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/README.rst:834,feedback,feedback,834,bindings/pyroot/cppyy/cppyy-backend/cling/README.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/cling/README.rst,1,['feedback'],['feedback']
Usability,"cppyy.bind_object(s, 'MyStruct'); >>> print(sobj); <cppyy.gbl.MyStruct object at 0x7ff25e28eb20>; >>> print(sobj.fInt); 42; >>>. Instead of the type name as a string, ``bind_object`` can also take the; actual class (here: ``cppyy.gbl.MyStruct``). * **Typed nullptr**: A Python side proxy can pass through a pointer to; pointer function argument, but if the C++ side allocates memory and; stores it in the pointer, the result is a memory leak.; In that case, use ``bind_object`` to bind ``cppyy.nullptr`` instead, to; get a typed nullptr to pass to the function.; Example (continuing from the example above):. .. code-block:: python. >>> cppyy.cppdef(""""""; ... void create_mystruct(MyStruct** ptr) { *ptr = new MyStruct{42}; }; ... """"""); ...; >>> s = cppyy.bind_object(cppyy.nullptr, 'MyStruct'); >>> print(s); <cppyy.gbl.MyStruct object at 0x0>; >>> cppyy.gbl.create_mystruct(s); >>> print(s); <cppyy.gbl.MyStruct object at 0x7fc7d85b91c0>; >>> print(s.fInt); 42; >>>. * **C-style cast**: This is the simplest option for builtin types.; The syntax is ""template-style"", example:. .. code-block:: python. >>> cppyy.cppdef(""""""; ... void* get_data(int sz) {; ... int* iptr = (int*)malloc(sizeof(int)*sz);; ... for (int i=0; i<sz; ++i) iptr[i] = i;; ... return iptr;; ... }""""""); ...; >>> NDATA = 4; >>> d = cppyy.gbl.get_data(NDATA); >>> print(d); <cppyy.LowLevelView object at 0x1068cba30>; >>> d = cppyy.ll.cast['int*'](d); >>> d.reshape((NDATA,)); >>> print(list(d)); [0, 1, 2, 3]; >>>. * **C++-style casts**: Similar to the C-style cast, there are; ``ll.static_cast`` and ``ll.reinterpret_cast``.; There should never be a reason for a ``dynamic_cast``, since that only; applies to objects, for which auto-casting will work.; The syntax is ""template-style"", just like for the C-style cast above. .. _npcasts:. `NumPy casts`; -------------. The ``cppyy.LowLevelView`` type returned for pointers to basic types,; including for ``void*``, is a simple and light-weight view on memory, given a; pointer, type,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:3660,simpl,simplest,3660,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['simpl'],['simplest']
Usability,"ct::Paint()`**. #### Physical IDs. TVirtualViewer3D provides for two methods of object addition:. ``` {.cpp}; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID,; const TBuffer3D & buffer,; Bool_t *addChildren = 0); ```. If you use the first (simple) case a viewer using logical/physical pairs; will generate sequential IDs for each physical object internally. Scene; rebuilds will require destruction and recreation of all physical; objects. For the second you can specify an identifier from the client; side, which must be unique and stable - i.e. the IDs of a published; object is consistent, regardless of changes in termination of contained; child geometry branches. In this case the viewer can safely cache the; physical objects across scene rebuilds, discarding those no longer of; interest. #### Child Objects. In many geometries there is a rigid containment hierarchy, and so if the; viewer is not interested in a certain object due to limits/size then it; will also not be interest in any of the contained branch of siblings.; Both `TBuffer3D::AddObject()` methods have an `addChildren` return; parameter. The viewer will complete this (if passed) indicating if; children of the object just sent are worth sending. #### Recycling TBuffer3D. Once add `TBuffer3D::AddObject()` has been called, the contents are; copied to the viewer's internal data structures. You are free to destroy; this **`TBuffer3D`**, or recycle it for the next object if suitable. #### Examples. For an example of a simple geometry, working in master reference frame; examine the code under `$ROOTSYS/g3d`. For a more complex example, which; works in both master and local frames, and uses logical`/`physical; division of shape geometry and placement, examine the code under; `$ROOTSYS/geom` - in particular **`TGeoShape`** hierarchy, and the; painter object **`TGeoPainter`** (under geopainter) where the; negotiation with the viewer is performed.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:139086,simpl,simple,139086,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simple']
Usability,"ction and any load of the; pointer. The ``-gvn``, ``-memcpyopt``, and ``-dse`` passes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These passes use AliasAnalysis information to reason about loads and stores. .. _the clients:. Clients for debugging and evaluation of implementations; -------------------------------------------------------. These passes are useful for evaluating the various alias analysis; implementations. You can use them with commands like:. .. code-block:: bash. % opt -ds-aa -aa-eval foo.bc -disable-output -stats. The ``-print-alias-sets`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-print-alias-sets`` pass is exposed as part of the ``opt`` tool to print; out the Alias Sets formed by the `AliasSetTracker`_ class. This is useful if; you're using the ``AliasSetTracker`` class. To use it, use something like:. .. code-block:: bash. % opt -ds-aa -print-alias-sets -disable-output. The ``-aa-eval`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-aa-eval`` pass simply iterates through all pairs of pointers in a; function and asks an alias analysis whether or not the pointers alias. This; gives an indication of the precision of the alias analysis. Statistics are; printed indicating the percent of no/may/must aliases found (a more precise; algorithm will have a lower number of may aliases). Memory Dependence Analysis; ==========================. .. note::. We are currently in the process of migrating things from; ``MemoryDependenceAnalysis`` to :doc:`MemorySSA`. Please try to use; that instead. If you're just looking to be a client of alias analysis information, consider; using the Memory Dependence Analysis interface instead. MemDep is a lazy,; caching layer on top of alias analysis that is able to answer the question of; what preceding memory operations a given instruction depends on, either at an; intra- or inter-block level. Because of its laziness and caching policy, using; MemDep can be a significant performance win over accessing alias analysis; directly.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:29603,simpl,simply,29603,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['simpl'],['simply']
Usability,"ction given in the beginning. We can now; use all methods of the `TF1` class to control the behaviour of our; function -- nice, isn't it ?. If you like, you can easily extend the example to also plot the; interference pattern of a single slit, using function `double single`,; or of a grid with narrow slits, function `double nslit0`, in `TF1`; instances. Here, we used a macro, some sort of lightweight program, that the; interpreter distributed with ROOT, Cling, is able to execute. This is a; rather extraordinary situation, since `C++` is not natively an interpreted; language! There is much more to say: chapter is indeed dedicated to; macros. ## Controlling ROOT ##. One more remark at this point: as every command you type into ROOT is; usually interpreted by Cling, an ""escape character"" is needed to pass; commands to ROOT directly. This character is the dot at the beginning of; a line:. ``` {.cpp}; root [1] .<command>; ```. This is a selection of the most common commands. - **quit root**, simply type `.q` or `.quit` or `.exit`. - obtain the full **list of commands**, use `.?` or `.help`. - **access the shell** of the operating system, type `.!<OS_command>`;; try, e.g. `.!ls` or `.!pwd`. - **execute a macro**, enter `.x <file_name>`; in the above example,; you might have used `.x slits.C` at the ROOT prompt. - **load a macro**, type `.L <file_name>`; in the above example, you; might instead have used the command `.L slits.C` followed by the; function call `slits();`. Note that after loading a macro all; functions and procedures defined therein are available at the ROOT; prompt. - **compile a macro**, type `.L <file_name>+`; ROOT is able to manage; for you the `C++` compiler behind the scenes and to produce machine; code starting from your macro. One could decide to compile a macro; in order to obtain better performance or to get nearer to the; production environment. ## Plotting Measurements ##. To display measurements in ROOT, including errors, there exists a; powerfu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:7897,simpl,simply,7897,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['simpl'],['simply']
Usability,"ction is currently implemented in the `ELF_x86_64.cpp`; file, and tied to the x86-64 relocation parsing code. The bulk of the code is; generic and should be split into an ELFLinkGraphBuilder base class along the; same lines as the existing generic MachOLinkGraphBuilder. * Implement support for arm32. * Implement support for other new architectures. JITLink Availability and Feature Status; ---------------------------------------. The following table describes the status of the JITlink backends for various; format / architecture combinations (as of July 2023). Support levels:. * None: No backend. JITLink will return an ""architecture not supported"" error.; Represented by empty cells in the table below.; * Skeleton: A backend exists, but does not support commonly used relocations.; Even simple programs are likely to trigger an ""unsupported relocation"" error.; Backends in this state may be easy to improve by implementing new relocations.; Consider getting involved!; * Basic: The backend supports simple programs, isn't ready for general use yet.; * Usable: The backend is useable for general use for at least one code and; relocation model.; * Good: The backend supports almost all relocations. Advanced features like; native thread local storage may not be available yet.; * Complete: The backend supports all relocations and object format features. .. list-table:: Availability and Status; :widths: 10 30 30 30; :header-rows: 1; :stub-columns: 1. * - Architecture; - ELF; - COFF; - MachO; * - arm32; - Skeleton; -; -; * - arm64; - Usable; -; - Good; * - LoongArch; - Good; -; -; * - PowerPC 64; - Usable; -; -; * - RISC-V; - Good; -; -; * - x86-32; - Basic; -; -; * - x86-64; - Good; - Usable; - Good. .. [1] See ``llvm/examples/OrcV2Examples/LLJITWithObjectLinkingLayerPlugin`` for; a full worked example. .. [2] If not for *hidden* scoped symbols we could eliminate the; ``JITLinkDylib*`` argument to ``JITLinkMemoryManager::allocate`` and; treat every object as a separate simulated dyl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:45881,simpl,simple,45881,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['simpl'],['simple']
Usability,"ction:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %b = sext i16 %a to i32; %c = and i32 %b, 15; call void @llvm.dbg.value(metadata i32 %c, ...); %d = trunc i32 %c to i16; ret i16 %d; }. Now, here's what happens after the unnecessary truncation instruction ``%d`` is; replaced with a simplified instruction:. .. code-block:: llvm. define i16 @foo(i16 %a) {; call void @llvm.dbg.value(metadata i32 undef, ...); %simplified = and i16 %a, 15; ret i16 %simplified; }. Note that after deleting ``%d``, all uses of its operand ``%c`` become; trivially dead. The debug use which used to point to ``%c`` is now ``undef``,; and debug info is needlessly lost. To solve this problem, do:. .. code-block:: cpp. llvm::replaceAllDbgUsesWith(%c, theSimplifiedAndInstruction, ...). This results in better debug info because the debug use of ``%c`` is preserved:. .. code-block:: llvm. define i16 @foo(i16 %a) {; %simplified = and i16 %a, 15; call void @llvm.dbg.value(metadata i16 %simplified, ...); ret i16 %simplified; }. You may have noticed that ``%simplified`` is narrower than ``%c``: this is not; a problem, because ``llvm::replaceAllDbgUsesWith`` takes care of inserting the; necessary conversion operations into the DIExpressions of updated debug uses. Deleting a MIR-level MachineInstr; ---------------------------------. TODO. Rules for updating ``DIAssignID`` Attachments; =============================================. ``DIAssignID`` metadata attachments are used by Assignment Tracking, which is; currently an experimental debug mode. See :doc:`AssignmentTracking` for how to update them and for more info on; Assignment Tracking. How to automatically convert tests into debug info tests; ========================================================. .. _IRDebugify:. Mutation testing for IR-level transformations; ---------------------------------------------. An IR test case for a transformation can, in many cases, be automatically; mutated to test debug info handling within that transformation.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:8517,simpl,simplified,8517,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['simpl'],['simplified']
Usability,"ctionality of both; of these features.; Improved printing of contents -- Many operator p.d.f. and function components now show; a more intuitive natural representation of their contents (these changes are mostly in the; respective p.d.f.s, but are most relevant in the context of a workspace). New object factory interface to workspace to facilitate script driven model definition; A object factory has been added to RooFit to simplify the process of creating p.d.f.; and function expressions consisting of multiple objects. The factory has two goals:; the first is to provide a back-end for higher level factories and tools to process; the creation of objects. The second is to provide a simple end-user language to; populate a RooWorkspace with function and p.d.f. objects. For the latter purpose the object creation language is executed through the factory() method; of a workspace object. RooWorkspace w(""w"") ;; RooAbsArg* arg = w.factory(""expression_goes_here"") ;. Basic Syntax; The rules at its simplest level are as follows. Expressions with square brackets create variables (discrete and continuous). ""m[-10,10]"" - Creates a RooRealVar named 'm' with range [-10,10]; ""m[5,-10,10]"" - Idem, but with initial value 5; ""m[5]"" - Creates a constant RooRealVar with name 'm' and value 5. ""tagCat[Lep,Kao,NT1,NT2]"" -- Creates a RooCategory with name tagCat and labeled states Lep,Kao,NT1,NT2; ""b0flav[B0=1,B0bar=-1]"" -- Creates a RooCategory with name b0flav and states B0 and B0bar with explicit index assignments. Expressions with parentheses create RooAbsArg function objects of any type. ""RooGaussian::g(x,m,s)"" -- Create a RooGaussian named g with variables x,m,s; This expression maps 1-1 to a createArg() call. ""Gaussian::g(x,m,s)"" -- Idem. The 'Roo' prefix on any class may be omitted. ""Gaussian(x,m,s)"" -- Create a RooGaussian with an automatically assigned name with variables x,m,s. Expressions with curly brackets creates RooArgSets or RooArgLists ""{x,y,z}"". Compound expressions; The rea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:18768,simpl,simplest,18768,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['simpl'],['simplest']
Usability,"ctions for the three indices through ""P"" in the assignment statement. The; function argument ``P`` will be the second operand of each of these GEP; instructions. The third operand indexes through that pointer. The fourth; operand will be the field offset into the ``struct munger_struct`` type, for; either the ``f1`` or ``f2`` field. So, in LLVM assembly the ``munge`` function; looks like:. .. code-block:: llvm. define void @munge(ptr %P) {; entry:; %tmp = getelementptr %struct.munger_struct, ptr %P, i32 1, i32 0; %tmp1 = load i32, ptr %tmp; %tmp2 = getelementptr %struct.munger_struct, ptr %P, i32 2, i32 1; %tmp3 = load i32, ptr %tmp2; %tmp4 = add i32 %tmp3, %tmp1; %tmp5 = getelementptr %struct.munger_struct, ptr %P, i32 0, i32 0; store i32 %tmp4, ptr %tmp5; ret void; }. In each case the second operand is the pointer through which the GEP instruction; starts. The same is true whether the second operand is an argument, allocated; memory, or a global variable. To make this clear, let's consider a more obtuse example:. .. code-block:: text. @MyVar = external global i32; ...; %idx1 = getelementptr i32, ptr @MyVar, i64 0; %idx2 = getelementptr i32, ptr @MyVar, i64 1; %idx3 = getelementptr i32, ptr @MyVar, i64 2. These GEP instructions are simply making address computations from the base; address of ``MyVar``. They compute, as follows (using C syntax):. .. code-block:: c++. idx1 = (char*) &MyVar + 0; idx2 = (char*) &MyVar + 4; idx3 = (char*) &MyVar + 8. Since the type ``i32`` is known to be four bytes long, the indices 0, 1 and 2; translate into memory offsets of 0, 4, and 8, respectively. No memory is; accessed to make these computations because the address of ``@MyVar`` is passed; directly to the GEP instructions. The obtuse part of this example is in the cases of ``%idx2`` and ``%idx3``. They; result in the computation of addresses that point to memory past the end of the; ``@MyVar`` global, which is only one ``i32`` long, not three ``i32``\s long.; While this is legal i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:3706,clear,clear,3706,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['clear'],['clear']
Usability,"ctions named ``.text``. .. code-block:: gas. 	.section	.text,""ax"",@progbits,unique,1; nop. 	.section	.text,""ax"",@progbits,unique,2; nop. The unique number is not present in the resulting object at all. It is just used; in the assembler to differentiate the sections. The 'o' flag is mapped to SHF_LINK_ORDER. If it is present, a symbol; must be given that identifies the section to be placed is the; .sh_link. .. code-block:: gas. .section .foo,""a"",@progbits; .Ltmp:; .section .bar,""ao"",@progbits,.Ltmp. which is equivalent to just. .. code-block:: gas. .section .foo,""a"",@progbits; .section .bar,""ao"",@progbits,.foo. ``.linker-options`` Section (linker options); ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In order to support passing linker options from the frontend to the linker, a; special section of type ``SHT_LLVM_LINKER_OPTIONS`` (usually named; ``.linker-options`` though the name is not significant as it is identified by; the type). The contents of this section is a simple pair-wise encoding of; directives for consideration by the linker. The strings are encoded as standard; null-terminated UTF-8 strings. They are emitted inline to avoid having the; linker traverse the object file for retrieving the value. The linker is; permitted to not honour the option and instead provide a warning/error to the; user that the requested option was not honoured. The section has type ``SHT_LLVM_LINKER_OPTIONS`` and has the ``SHF_EXCLUDE``; flag to ensure that the section is treated as opaque by linkers which do not; support the feature and will not be emitted into the final linked binary. This would be equivalent to the follow raw assembly:. .. code-block:: gas. .section "".linker-options"",""e"",@llvm_linker_options; .asciz ""option 1""; .asciz ""value 1""; .asciz ""option 2""; .asciz ""value 2"". The following directives are specified:. - lib. The parameter identifies a library to be linked against. The library will; be looked up in the default and any specified library search paths; (specifi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Extensions.rst:6272,simpl,simple,6272,interpreter/llvm-project/llvm/docs/Extensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Extensions.rst,1,['simpl'],['simple']
Usability,"ctions that are registered as global constructors in; ``llvm.global_ctors`` and which contain a call to ``__cxa_atexit`` to register; their destructor functions. ``loweratomic``: Lower atomic intrinsics to non-atomic form; -----------------------------------------------------------. This pass lowers atomic intrinsics to non-atomic form for use in a known; non-preemptible environment. The pass does not verify that the environment is non-preemptible (in general; this would require knowledge of the entire call graph of the program including; any libraries which may not be available in bitcode form); it simply lowers; every atomic intrinsic. ``lowerinvoke``: Lower invokes to calls, for unwindless code generators; -----------------------------------------------------------------------. This transformation is designed for use by code generators which do not yet; support stack unwinding. This pass converts ``invoke`` instructions to; ``call`` instructions, so that any exception-handling ``landingpad`` blocks; become dead code (which can be removed by running the ``-simplifycfg`` pass; afterwards). ``lowerswitch``: Lower ``SwitchInst``\ s to branches; ----------------------------------------------------. Rewrites switch instructions with a sequence of branches, which allows targets; to get away with not implementing the switch instruction until it is; convenient. .. _passes-mem2reg:. ``mem2reg``: Promote Memory to Register; ---------------------------------------. This file promotes memory references to be register references. It promotes; alloca instructions which only have loads and stores as uses. An ``alloca`` is; transformed by using dominator frontiers to place phi nodes, then traversing; the function in depth-first order to rewrite loads and stores as appropriate.; This is just the standard SSA construction algorithm to construct ""pruned"" SSA; form. ``memcpyopt``: MemCpy Optimization; ----------------------------------. This pass performs various transformations rela",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:30065,simpl,simplifycfg,30065,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['simpl'],['simplifycfg']
Usability,"cts that come from, e.g., a library adopting the feature and providing; benefits to its users.; A specific need to reside within the Clang tree: There are some extensions; that would be better expressed as a separate tool, and should remain as; separate tools even if they end up being hosted as part of the LLVM umbrella; project.; A specification: The specification must be sufficient to understand the; design of the feature as well as interpret the meaning of specific examples.; The specification should be detailed enough that another compiler vendor; could implement the feature.; Representation within the appropriate governing organization: For; extensions to a language governed by a standards committee (C, C++, OpenCL),; the extension itself must have an active proposal and proponent within that; committee and have a reasonable chance of acceptance. Clang should drive the; standard, not diverge from it. This criterion does not apply to all; extensions, since some extensions fall outside of the realm of the standards; bodies.; A long-term support plan: increasingly large or complex extensions to; Clang need matching commitments to supporting them over time, including; improving their implementation and specification as Clang evolves. The; capacity of the contributor to make that commitment is as important as the; commitment itself.; A high-quality implementation: The implementation must fit well into; Clang's architecture, follow LLVM's coding conventions, and meet Clang's; quality standards, including diagnostics and complete AST; representations. This is particularly important for language extensions,; because users will learn how those extensions work through the behavior of the; compiler.; A test suite: Extensive testing is crucial to ensure that the language; extension is not broken by ongoing maintenance in Clang. The test suite; should be complete enough that another compiler vendor could conceivably; validate their implementation of the feature against it. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:4373,learn,learn,4373,interpreter/llvm-project/clang/www/get_involved.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html,1,['learn'],['learn']
Usability,"cts, it also leads to dramatically cleaner source code. #. No subclasses required: To use CommandLine, you instantiate variables that; correspond to the arguments that you would like to capture, you don't; subclass a parser. This means that you don't have to write **any**; boilerplate code. #. Globally accessible: Libraries can specify command line arguments that are; automatically enabled in any tool that links to the library. This is; possible because the application doesn't have to keep a list of arguments to; pass to the parser. This also makes supporting `dynamically loaded options`_; trivial. #. Cleaner: CommandLine supports enum and other types directly, meaning that; there is less error and more security built into the library. You don't have; to worry about whether your integral command line argument accidentally got; assigned a value that is not valid for your enum type. #. Powerful: The CommandLine library supports many different types of arguments,; from simple `boolean flags`_ to `scalars arguments`_ (`strings`_,; `integers`_, `enums`_, `doubles`_), to `lists of arguments`_. This is; possible because CommandLine is... #. Extensible: It is very simple to add a new argument type to CommandLine.; Simply specify the parser that you want to use with the command line option; when you declare it. `Custom parsers`_ are no problem. #. Labor Saving: The CommandLine library cuts down on the amount of grunt work; that you, the user, have to do. For example, it automatically provides a; ``-help`` option that shows the available command line options for your tool.; Additionally, it does most of the basic correctness checking for you. #. Capable: The CommandLine library can handle lots of different forms of; options often found in real programs. For example, `positional`_ arguments,; ``ls`` style `grouping`_ options (to allow processing '``ls -lad``'; naturally), ``ld`` style `prefix`_ options (to parse '``-lmalloc; -L/usr/lib``'), and interpreter style options. This ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:2424,simpl,simple,2424,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['simpl'],['simple']
Usability,"d %0() [""kcfi""(i32 1234)]. Clang emits KCFI operand bundles and the necessary metadata with; ``-fsanitize=kcfi``. .. _convergencectrl:. Convergence Control Operand Bundles; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A ""convergencectrl"" operand bundle is only valid on a ``convergent`` operation.; When present, the operand bundle must contain exactly one value of token type.; See the :doc:`ConvergentOperations` document for details. .. _moduleasm:. Module-Level Inline Assembly; ----------------------------. Modules may contain ""module-level inline asm"" blocks, which corresponds; to the GCC ""file scope inline asm"" blocks. These blocks are internally; concatenated by LLVM and treated as a single unit, but may be separated; in the ``.ll`` file if desired. The syntax is very simple:. .. code-block:: llvm. module asm ""inline asm code goes here""; module asm ""more can go here"". The strings can contain any character by escaping non-printable; characters. The escape sequence used is simply ""\\xx"" where ""xx"" is the; two digit hex code for the number. Note that the assembly string *must* be parseable by LLVM's integrated assembler; (unless it is disabled), even when emitting a ``.s`` file. .. _langref_datalayout:. Data Layout; -----------. A module may specify a target specific data layout string that specifies; how data is to be laid out in memory. The syntax for the data layout is; simply:. .. code-block:: llvm. target datalayout = ""layout specification"". The *layout specification* consists of a list of specifications; separated by the minus sign character ('-'). Each specification starts; with a letter and may include other information after the letter to; define some aspect of the data layout. The specifications accepted are; as follows:. ``E``; Specifies that the target lays out data in big-endian form. That is,; the bits with the most significance have the lowest address; location.; ``e``; Specifies that the target lays out data in little-endian form. That; is, the bits with the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:130685,simpl,simply,130685,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"d '::' and any; of the STL container names was inadvertently omitted (in case of classes; that are part of the TTree but had only a base and no member or in some; cases where it had only object data members.; Prevent storing a 2nd time an object non derived from TObject in the case; where the object is both the top level object of branch and has; some of it sub-object containing a pointer back to the object. (This was; actually activated in v5.18).; ; void TBranch::DeleteBaskets(Option_t* option); new function which loops on all branch baskets. If the file where branch buffers reside is writable, free the disk space associated to the baskets of the branch, then call Reset(). If the option contains ""all"", delete also the baskets for the subbranches. The branch is reset.; NOTE that this function must be used with extreme care. Deleting branch baskets; fragments the file and may introduce inefficiencies when adding new entries; in the Tree or later on when reading the Tree. Protect TTree::GetCurrentFile in case the current directory is gROOT.; This case may happen when a TChain calls TChain::Process and no files have been; connected to the chain yet, but a TFile has been opened meanwhile.; Remove the calls to MapObject introduce in revision 21384 when; are unnecessary hence restoring lost performance in case where; the TTree contains many simple type (double, int, etc.); In TBranchElement::Streamer when writing, call ForceWriteInfo; not only for the TStreamerInfo directly concerning this branch; but also (in the case of the top level branch of a split TClonesArray; or a split STL container) call ForceWriteInfo for the class of; the value. This omission meant that slow CloneTree was (fataly) missing in; some cases the copy of the TStreamerInfo for class that are part; part of the TTree but had only a base and no member or in; some cases where it had only object data members.; Fix the return value of the lookup in TChainIndex; when the value searched for does not exist. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v520/index.html:9220,simpl,simple,9220,tree/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v520/index.html,1,['simpl'],['simple']
Usability,"d 'hide' any item from the user (but keep access with normal http requests). With such properties one could specify which item is drawn when web page is loaded, or configure monitoring. See tutorials/http/httpcontrol.C macro for more details. ##### Method Calls; Implement exe.json requests to be able to execute any method of registered objects. This request is used to provide remote TTree::Draw() functionality. ##### Misc; Correctly set 'Cache-Control' headers when replying to http requests.; Better support of STL containers when converting objects into json with TBufferJSON class. ## JavaScript ROOT. - Several files can now be loaded simultaneously; - Use d3.time.scale to display time scales; - Implemented drag and drop to superimpose histograms or graphs; - Allow selection of drawing option via context menu; - Better support of touch devices; - Provide simple layout, making it default; - Allow to open ROOT files in online session (via url parameter); - One could monitor simultaneously objects from server and root files; - Implement 'autocol' draw option - when superimposing histograms,; their line colors will be automatically assigned; - Implement 'nostat' draw option - disabled stat drawing; - Using '_same_' identifier in item name, one can easily draw or superimpose; similar items from different files. Could be used in URL like:; `...&files=[file1.root,file2.root]&items=[file1.root/hpx, file2.root/_same_]`; `...&files=[file1.root,file2.root]&item=file1.root/hpx+file2.root/_same_`; Main limitation - file names should have similar length.; - When 'autozoom' specified in draw options, histogram zoomed into; non-empty content. Same command available via context menu.; - Item of 'Text' kind can be created. It is displayed as; lain text in the browser. If property 'mathjax' specified,; MathJax.js library will be loaded and used for rendering.; See tutorials/http/httpcontrol.C macro for example.; - When using foreignObject, provide workaround for absolute positioning; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:10636,simpl,simple,10636,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['simpl'],['simple']
Usability,"d **`TVectorF`**.; Copy constructors exist to transform these into their double precision; equivalent, thereby allowing easy access to decomposition and eigenvalue; classes, only available in double precision. The choice was made not to provide the less frequently used complex; matrix classes. If necessary, users can always reformulate the; calculation in 2 parts, a real one and an imaginary part. Although, a; linear equation involving complex numbers will take about a factor of 8; more computations, the alternative of introducing a set of complex; classes in this non-template library would create a major maintenance; challenge. Another choice was to fill in both the upper-right corner and the; bottom-left corner of a symmetric matrix. Although most algorithms use; only the upper-right corner, implementation of the different matrix; views was more straightforward this way. When stored only the; upper-right part is written to file. For a detailed description of the interface, the user should look at the; root reference guide at: <http://root.cern.ch/root/Reference.html>. ## Overview of Matrix Classes. The figure below shows an overview of the classes available in the; linear algebra library,` libMatrix.so`. At the center is the base class; **`TMatrixDBase`** from which three different matrix classes,; **`TMatrixD`**, **`TMatrixDSym`** and **`TMatrixDFSparse`** derive. The; user can define customized matrix operations through the classes; **`TElementActionD`** and **`TElementsPosActionD`**. ![Overview of matrix classes](pictures/0300012D.png). Reference to different views of the matrix can be created through the; classes on the right-hand side, see ""Matrix Views"". These references; provide a natural connection to vectors. Matrix decompositions (used in equation solving and matrix inversion); are available through the classes on the left-hand side (see ""Matrix; Decompositions""). They inherit from the **`TDecompBase`** class. The; Eigen Analysis is performed through the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:1392,guid,guide,1392,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['guid'],['guide']
Usability,"d Clang, you will need to give *it* access to modern C++; standard library in order to use it as your new host in part of a bootstrap.; There are two easy ways to do this, either build (and install) libc++ along; with Clang and then use it with the ``-stdlib=libc++`` compile and link flag,; or install Clang into the same prefix (``$HOME/toolchains`` above) as GCC.; Clang will look within its own prefix for libstdc++ and use it if found. You; can also add an explicit prefix for Clang to look in for a GCC toolchain with; the ``--gcc-toolchain=/opt/my/gcc/prefix`` flag, passing it to both compile and; link commands when using your just-built-Clang to bootstrap. .. _Getting Started with LLVM:. Getting Started with LLVM; =========================. The remainder of this guide is meant to get you up and running with LLVM and to; give you some basic information about the LLVM environment. The later sections of this guide describe the `general layout`_ of the LLVM; source tree, a `simple example`_ using the LLVM tool chain, and `links`_ to find; more information about LLVM or to get help via e-mail. Terminology and Notation; ------------------------. Throughout this manual, the following names are used to denote paths specific to; the local system and working environment. *These are not environment variables; you need to set but just strings used in the rest of this document below*. In; any of the examples below, simply replace each of these names with the; appropriate pathname on your local system. All these paths are absolute:. ``SRC_ROOT``. This is the top level directory of the LLVM source tree. ``OBJ_ROOT``. This is the top level directory of the LLVM object tree (i.e. the tree where; object files and compiled programs will be placed. It can be the same as; SRC_ROOT). Unpacking the LLVM Archives; ---------------------------. If you have the LLVM distribution, you will need to unpack it before you can; begin to compile it. LLVM is distributed as a number of different; su",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:20364,guid,guide,20364,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,2,"['guid', 'simpl']","['guide', 'simple']"
Usability,"d Fortran version,; with almost equivalent numerical accuracy and computational performances.; Furthermore, it contains new functionality, like the possibility to set single side parameter limits or; the FUMILI algorithm, which is an optimized method for least square and log likelihood minimizations.; The package has been originally developed by M. Winkler and F. James.; More information on the new C++ version can be found on the; MINUIT Web Site. Minuit2, originally developed in the SEAL project, is now distributed within %ROOT.; The API has been then changed in this new version to follow the %ROOT coding convention (function names starting with capital letters) and the classes have been moved inside the namespace ROOT::Minuit2.; In addition, the %ROOT distribution contains classes needed to integrate Minuit2 in the %ROOT framework. A new class has been introduced, ROOT::Minuit2::Minuit2Minimizer, which implements the interface; ROOT::Math::Minimizer. Within %ROOT, it can be instantiates also using the %ROOT plug-in manager. This class provides a convenient entry point for using Minuit2. An example of using this interface is; the %ROOT tutorial tutorials/fit/NumericalMinimization.C or; the Minuit2 test program testMinimize.cxx. A standalone version of Minuit2 (independent of %ROOT) can be downloaded from here. It does not contain the %ROOT interface and it is therefore totally independent of external packages and can be simply build using the configure script and then make. Example tests are provided in the directory test/MnSim and test/MnTutorial and they can be built with the make check command. The Minuit2 User Guide provides all the information needed for using directly (without add-on packages like %ROOT) Minuit2. References. F. James, Fortran MINUIT Reference Manual (html);; F. James and M. Winkler, C++ MINUIT User's Guide (html and; pdf);; F. James, Minuit Tutorial on Function Minimization (pdf);; F. James, The Interpretation of Errors in Minuit (pdf);. */; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.html:1712,simpl,simply,1712,math/minuit2/doc/Minuit2.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.html,1,['simpl'],['simply']
Usability,"d axis on their own. This may be useful for example in the case; one wants to draw two axis for the same plot, one on the left and one on; the right. For historical reasons, there are two classes representing axis.; **`TAxis`** \* `axis` is the axis object, which will be returned when; calling the `TH1::GetAxis()` method. ``` {.cpp}; TAxis *axis = histo->GetXaxis(); ```. Of course, you may do the same for `Y` and `Z`-axis. The graphical; representation of an axis is done with the **`TGaxis`** class. The; histogram classes and **`TGraph`** generate instances of this class.; This is internal and the user should not have to see it. ### Axis Title. The axis title is set, as with all named objects, by. ``` {.cpp}; axis->SetTitle(""Whatever title you want"");; ```. When the axis is embedded into a histogram or a graph, one has to first; extract the axis object:. ``` {.cpp}; h->GetXaxis()->SetTitle(""Whatever title you want""); ```. ### Axis Options and Characteristics. The axis options are most simply set with the styles. The available; style options controlling specific axis options are the following:. ``` {.cpp}; TAxis *axis = histo->GetXaxis();; axis->SetAxisColor(Color_t color = 1);; axis->SetLabelColor(Color_t color = 1);; axis->SetLabelFont(Style_t font = 62);; axis->SetLabelOffset(Float_t offset = 0.005);; axis->SetLabelSize(Float_t size = 0.04);; axis->SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE);; axis->SetNoExponent(Bool_t noExponent = kTRUE);; axis->SetTickLength(Float_t length = 0.03);; axis->SetTitleOffset(Float_t offset = 1);; axis->SetTitleSize(Float_t size = 0.02);; ```. The getters corresponding to the described setters are also available.; The general options, not specific to axis, as for instance; `SetTitleTextColor()` are valid and do have an effect on axis; characteristics. ### Setting the Number of Divisions. Use `TAxis::SetNdivisions(ndiv,optim)` to set the number of divisions; for an axis. The `ndiv` and `optim` are as follows:. - `ndiv = N1 + 10",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:50574,simpl,simply,50574,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['simpl'],['simply']
Usability,"d be treated as ``__null_terminated``.; The same applies to other annotations.; In system headers, the default pointer attribute for ABI-visible pointers is set; to ``__unsafe_indexable`` by default. The ``__ptrcheck_abi_assume_*ATTR*()`` macros are defined as pragmas in the; toolchain header (See `Portability with toolchains that do not support the; extension`_ for more details about the toolchain header):. .. code-block:: C. #define __ptrcheck_abi_assume_single() \; _Pragma(""clang abi_ptr_attr set(single)""). #define __ptrcheck_abi_assume_indexable() \; _Pragma(""clang abi_ptr_attr set(indexable)""). #define __ptrcheck_abi_assume_bidi_indexable() \; _Pragma(""clang abi_ptr_attr set(bidi_indexable)""). #define __ptrcheck_abi_assume_unsafe_indexable() \; _Pragma(""clang abi_ptr_attr set(unsafe_indexable)""). ABI implications of default bounds annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Although simply modifying types of a local variable doesn't normally impact the; ABI, taking the address of such a modified type could create a pointer type that; has an ABI mismatch. Looking at the following example, ``int *local`` is; implicitly ``int *__bidi_indexable`` and thus the type of ``&local`` is a; pointer to ``int *__bidi_indexable``. On the other hand, in ``void foo(int; **)``, the parameter type is a pointer to ``int *__single`` (i.e., ``void; foo(int *__single *__single)``) (or a pointer to ``int *__unsafe_indexable`` if; it's from a system header). The compiler reports an error for casts between; pointers whose elements have incompatible pointer attributes. This way,; ``-fbounds-safety`` prevents pointers that are implicitly ``__bidi_indexable``; from silently escaping thereby breaking the ABI. .. code-block:: c. void foo(int **);. void bar(void) {; int *local = 0;; // error: passing 'int *__bidi_indexable*__bidi_indexable' to parameter of; // incompatible nested pointer type 'int *__single*__single'; foo(&local);; }. A local variable may still be exposed to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:23469,simpl,simply,23469,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['simpl'],['simply']
Usability,"d loop containing S2 will be vectorized. Loop Distribution is currently not enabled by default in the optimizer because; it can hurt performance in some cases. For example, instruction-level; parallelism could be reduced by sequentializing the execution of the; statements S1 and S2 above. If Loop Distribution is turned on globally with; ``-mllvm -enable-loop-distribution``, specifying ``distribute(disable)`` can; be used the disable it on a per-loop basis. Additional Information; ----------------------. For convenience multiple loop hints can be specified on a single line. .. code-block:: c++. #pragma clang loop vectorize_width(4) interleave_count(8); for(...) {; ...; }. If an optimization cannot be applied any hints that apply to it will be ignored.; For example, the hint ``vectorize_width(4)`` is ignored if the loop is not; proven safe to vectorize. To identify and diagnose optimization issues use; `-Rpass`, `-Rpass-missed`, and `-Rpass-analysis` command line options. See the; user guide for details. Extensions to specify floating-point flags; ====================================================. The ``#pragma clang fp`` pragma allows floating-point options to be specified; for a section of the source code. This pragma can only appear at file scope or; at the start of a compound statement (excluding comments). When using within a; compound statement, the pragma is active within the scope of the compound; statement. Currently, the following settings can be controlled with this pragma:. ``#pragma clang fp reassociate`` allows control over the reassociation; of floating point expressions. When enabled, this pragma allows the expression; ``x + (y + z)`` to be reassociated as ``(x + y) + z``.; Reassociation can also occur across multiple statements.; This pragma can be used to disable reassociation when it is otherwise; enabled for the translation unit with the ``-fassociative-math`` flag.; The pragma can take two values: ``on`` and ``off``. .. code-block:: c++. float f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:169529,guid,guide,169529,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['guid'],['guide']
Usability,"d many; different ways of classifying them: flow-sensitive vs. flow-insensitive,; context-sensitive vs. context-insensitive, field-sensitive; vs. field-insensitive, unification-based vs. subset-based, etc. Traditionally,; alias analyses respond to a query with a `Must, May, or No`_ alias response,; indicating that two pointers always point to the same object, might point to the; same object, or are known to never point to the same object. The LLVM `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__ class is the; primary interface used by clients and implementations of alias analyses in the; LLVM system. This class is the common interface between clients of alias; analysis information and the implementations providing it, and is designed to; support a wide range of implementations and clients (but currently all clients; are assumed to be flow-insensitive). In addition to simple alias analysis; information, this class exposes Mod/Ref information from those implementations; which can provide it, allowing for powerful analyses and transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:1291,simpl,simple,1291,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['simpl'],['simple']
Usability,"d object are:. - **directory:** The working directory of the compilation. All paths; specified in the **command** or **file** fields must be either; absolute or relative to this directory.; - **file:** The main translation unit source processed by this; compilation step. This is used by tools as the key into the; compilation database. There can be multiple command objects for the; same file, for example if the same source file is compiled with; different configurations.; - **arguments:** The compile command argv as list of strings.; This should run the compilation step for the translation unit ``file``.; ``arguments[0]`` should be the executable name, such as ``clang++``.; Arguments should not be escaped, but ready to pass to ``execvp()``.; - **command:** The compile command as a single shell-escaped string.; Arguments may be shell quoted and escaped following platform conventions,; with '``""``' and '``\``' being the only special characters. Shell expansion; is not supported. Either **arguments** or **command** is required. **arguments** is preferred,; as shell (un)escaping is a possible source of errors.; - **output:** The name of the output created by this compilation step.; This field is optional. It can be used to distinguish different processing; modes of the same input file. Build System Integration; ========================. The convention is to name the file compile\_commands.json and put it at; the top of the build directory. Clang tools are pointed to the top of; the build directory to detect the file and use the compilation database; to parse C++ code in the source tree. Alternatives; ============; For simple projects, Clang tools also recognize a ``compile_flags.txt`` file.; This should contain one argument per line. The same flags will be used to; compile any file. Example:. ::. -xc++; -I; libwidget/include/. Here ``-I libwidget/include`` is two arguments, and so becomes two lines.; Paths are relative to the directory containing ``compile_flags.txt``.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst:4728,simpl,simple,4728,interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,1,['simpl'],['simple']
Usability,"d or older Ubuntus:. # service autofs restart. - Prepare a `/etc/cvmfs/default.local` file (create it if it does not; exists) with the following configuration bits:. ``` {.bash}; CVMFS_HTTP_PROXY=http://your-proxy-server.domain.ch:3128,DIRECT; CVMFS_REPOSITORIES=your-experiment.cern.ch,sft.cern.ch; CVMFS_QUOTA_LIMIT=50000; ```. You need to properly specify your closest HTTP caching proxy:; separate many of them via commas. The last fallback value, `DIRECT`,; tells cvmfs to connect directly without using any proxy at all. Among the list of repositories (comma-separated), always specify; `sft.cern.ch` and the one containing the software to your experiment; (e.g., `cms.cern.ch`). The quota limit is, in Megabytes, the amount of local disk space to; use as cache. - Check the configuration and repositories with:. # cvmfs_config chksetup; OK; # cvmfs_config probe; Probing /cvmfs/cms.cern.ch... OK; Probing /cvmfs/sft.cern.ch... OK. > You might need special configurations for some custom software; > repositories! Special cases are not covered in this guide. ### Firewall configuration. [PROOF on Demand](http://pod.gsi.de/) is very flexible in handling; various cases of network topologies. The best solution would be to allow; all TCP communications between the cluster machines. No other incoming communication is required from the outside. Configuration steps for the head node only; ------------------------------------------. ### Setup HTTPS+SSH (sshcertauth) authentication. > Latest recommended sshcertauth version is 0.8.5.; >; > [Download](https://github.com/dberzano/sshcertauth/archive/v0.8.5.zip); > and [read the; > instructions](http://newton.ph.unito.it/~berzano/w/doku.php?id=proof:sshcertauth). If you want your users to connect to the PROOF cluster using their Grid; user certificate and private key you might be interested in installing; sshcertauth. Please refer to the [installation; guide](http://newton.ph.unito.it/~berzano/w/doku.php?id=proof:sshcertauth); for further i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md:3662,guid,guide,3662,proof/doc/confman/ConfigProofPoD.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md,1,['guid'],['guide']
Usability,"d possible local settings; (daemon, dataset manager).; Add possibility to control the automatic re-loading of; the <proof.conf> file via the keyword; 'reload:1'/'reload:0'; in the xpd.resource directive.; Move the validation of <proof.conf> at the; moment of use; this allows to specify a file path and to dynamically; create/modify/destroy the file; used by PoD.; Improve displaying speed of large log files. Fixes. Fix two severe; bugs in the way TTreeCache; was used in PROOF: one bug was de facto disactivating the cache; the; other was causing a std::bad_alloc exception to be thrown on workers; when opening a remote file after a local one.    ; Fix several problems in TChain::Draw including. drawing into an existing histogram, i.e.; chain->Draw(""var>>myhist"");. treatment of histogram merging in case of small; statistics, i.e. when; the autobinning is not or only partially active;. usage of existing canvases when different histogram; names are specified;. Fix a problem causing a duplication of the final feedback; object. Fix problem with determining the subdir name in; TFileMerger::MergeRecursive on Windows; Make sure that the default sandbox is under $HOME/.proof; Fix a problem with dataset validation in multi-level; master setups; Fix a problem with ordinal numbers in multi-master setups; Fix a problem with defining the internal paths for; executables when configuring with '--prefix'; Fix backward-incompatibility issue giving the error; message  ""unknown action code: 5112""; Fix a few problems with file retrieval from the cache; Fix a problem with iteration of a std::list occasionally; causing seg-violations in TXSocket; Fix a few problems preventing correct usage of entry; lists in PROOF; Fix a problem with the permissions of the credentials; files created under <sandbox>/.creds; Fix a potential problem while determining the log paths; in log retrieval. Do not use vnsprintf in the XrdProofd plug-in, potential; source of deadlocks.; Fix a problem overwriting the local",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:9247,feedback,feedback,9247,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['feedback'],['feedback']
Usability,"d set of training variables in that zone. The division; into categories in presence of distinct sub-populations reduces; the correlations between the training variables, improves the; modelling, and hence increases the classification and regression; performance. Presently, the Category method works for; classification only, but regression will follow soon. Please; contact us if urgently needed. An example scripts and data files illustrating how the new; Category method is configured and used. Please check the macros; test/TMVAClassificationCategory.C and; test/TMVAClassificationCategoryApplication.C or the; corresponding executables.; Regression functionality for gradient boosted trees using a Huber loss function. Comments. On Input Data: . New TMVA event vector building. The code for splitting the input; data into training and test samples for all classes and the; mixing of those samples to one training and one test sample has; been rewritten completely. The new code is more performant and; has a clearer structure. This fixes several bugs which have been; reported by the TMVA users. On Minimization: . Variables, targets and spectators are now checked if they are; constant. (The execution of TMVA is stopped for variables and; targets, a warning is given for spectators.). On Regression:; ; The analysis type is no longer defined by calling a dedicated; TestAllMethods-member-function of the Factory, but with the; option ""AnalysisType"" in the Factory. The default value is; ""Auto"" where TMVA tries to determine the most suitable analysis; type from the targets and classes the user has defined. Other; values are ""regression"", ""classification"" and ""multiclass"" for; the forthcoming multiclass classification.; Missing regression evaluation plots for training sample were; added. On Cut method:. Removed obsolete option ""FVerySmart"" from Cuts method. On MLP method:; ; Display of convergence information in the progress bar for MLP during training. Creation of animated gifs for ML",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html:1573,clear,clearer,1573,tmva/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html,1,['clear'],['clearer']
Usability,"d that this; limitation cannot be eliminated with the usage of any parallel analysis; toolkit. ### Optimisation Regarding N-tuples ###. ROOT automatically applies compression algorithms on n-tuples to reduce; the memory consumption. A value that is in most cases the same will; consume only small space on your disk (but it has to be decompressed on; reading). Nevertheless, you should think about the design of your; n-tuples and your analyses as soon as the processing time exceeds some; minutes. - Try to keep your n-tuples simple and use appropriate variable types.; If your measurement has only a limited precision, it is needless to; store it with double precision. - Experimental conditions that do not change with every single; measurement should be stored in a separate tree. Although the; compression can handle redundant values, the processing time; increase with every variable that has to be filled. - The function `SetCacheSize(long)` specifies the size of the cache; for reading a `TTree` object from a file. The default value is 30MB.; A manual increase may help in certain situations. Please note that; the caching mechanism can cover only one `TTree` object per `TFile`; object. - You can select the branches to be covered by the caching algorithm; with `AddBranchToCache` and deactivate unneeded branches with; `SetBranchStatus`. This mechanism can result in a significant; speed-up for simple operations on trees with many branches. - You can measure the performance easily with `TTreePerfStats`. The; ROOT documentation on this class also includes an introductory; example. For example, `TTreePerfStats` can show you that it is; beneficial to store meta data and payload data separately, i.e.; write the meta data tree in a bulk to a file at the end of your job; instead of writing both trees interleaved. [^6]: The usage of `fOutput` is not really needed for this simple example, but it allows re-usage of the exact code in parallel processing with `PROOF` (see next section).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:14543,simpl,simple,14543,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,2,['simpl'],['simple']
Usability,"d the operands to the; operation. The various operation node types are described at the top of the; ``include/llvm/CodeGen/ISDOpcodes.h`` file. Although most operations define a single value, each node in the graph may; define multiple values. For example, a combined div/rem operation will define; both the dividend and the remainder. Many other situations require multiple; values as well. Each node also has some number of operands, which are edges to; the node defining the used value. Because nodes may define multiple values,; edges are represented by instances of the ``SDValue`` class, which is a; ``<SDNode, unsigned>`` pair, indicating the node and result value being used,; respectively. Each value produced by an ``SDNode`` has an associated ``MVT``; (Machine Value Type) indicating what the type of the value is. SelectionDAGs contain two different kinds of values: those that represent data; flow and those that represent control flow dependencies. Data values are simple; edges with an integer or floating point value type. Control edges are; represented as ""chain"" edges which are of type ``MVT::Other``. These edges; provide an ordering between nodes that have side effects (such as loads, stores,; calls, returns, etc). All nodes that have side effects should take a token; chain as input and produce a new one as output. By convention, token chain; inputs are always operand #0, and chain results are always the last value; produced by an operation. However, after instruction selection, the; machine nodes have their chain after the instruction's operands, and; may be followed by glue nodes. A SelectionDAG has designated ""Entry"" and ""Root"" nodes. The Entry node is; always a marker node with an Opcode of ``ISD::EntryToken``. The Root node is; the final side-effecting node in the token chain. For example, in a single basic; block function it would be the return node. One important concept for SelectionDAGs is the notion of a ""legal"" vs.; ""illegal"" DAG. A legal DAG for a tar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:35385,simpl,simple,35385,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simple']
Usability,"d to; generate a Data Layout and the optimization phases will operate; accordingly and introduce target specificity into the IR with respect to; these default specifications. .. _langref_triple:. Target Triple; -------------. A module may specify a target triple string that describes the target; host. The syntax for the target triple is simply:. .. code-block:: llvm. target triple = ""x86_64-apple-macosx10.7.0"". The *target triple* string consists of a series of identifiers delimited; by the minus sign character ('-'). The canonical forms are:. ::. ARCHITECTURE-VENDOR-OPERATING_SYSTEM; ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT. This information is passed along to the backend so that it generates; code for the proper architecture. It's possible to override this on the; command line with the ``-mtriple`` command line option. .. _objectlifetime:. Object Lifetime; ----------------------. A memory object, or simply object, is a region of a memory space that is; reserved by a memory allocation such as :ref:`alloca <i_alloca>`, heap; allocation calls, and global variable definitions.; Once it is allocated, the bytes stored in the region can only be read or written; through a pointer that is :ref:`based on <pointeraliasing>` the allocation; value.; If a pointer that is not based on the object tries to read or write to the; object, it is undefined behavior. A lifetime of a memory object is a property that decides its accessibility.; Unless stated otherwise, a memory object is alive since its allocation, and; dead after its deallocation.; It is undefined behavior to access a memory object that isn't alive, but; operations that don't dereference it such as; :ref:`getelementptr <i_getelementptr>`, :ref:`ptrtoint <i_ptrtoint>` and; :ref:`icmp <i_icmp>` return a valid result.; This explains code motion of these instructions across operations that; impact the object's lifetime.; A stack object's lifetime can be explicitly specified using; :ref:`llvm.lifetime.start <int_lifest",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:140159,simpl,simply,140159,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simply']
Usability,"d to; top of stack, and the new space is available immediately below the linkage and; parameter areas. The cost of shifting the linkage and parameter areas is minor; since only the link value needs to be copied. The link value can be easily; fetched by adding the original frame size to the base pointer. Note that; allocations in the dynamic space need to observe 16 byte alignment. The *locals area* is where the llvm compiler reserves space for local variables. The *saved registers area* is where the llvm compiler spills callee saved; registers on entry to the callee. Prolog/Epilog; ^^^^^^^^^^^^^. The llvm prolog and epilog are the same as described in the PowerPC ABI, with; the following exceptions. Callee saved registers are spilled after the frame is; created. This allows the llvm epilog/prolog support to be common with other; targets. The base pointer callee saved register r31 is saved in the TOC slot of; linkage area. This simplifies allocation of space for the base pointer and; makes it convenient to locate programmatically and during debugging. Dynamic Allocation; ^^^^^^^^^^^^^^^^^^. .. note::. TODO - More to come. The NVPTX backend; -----------------. The NVPTX code generator under lib/Target/NVPTX is an open-source version of; the NVIDIA NVPTX code generator for LLVM. It is contributed by NVIDIA and is; a port of the code generator used in the CUDA compiler (nvcc). It targets the; PTX 3.0/3.1 ISA and can target any compute capability greater than or equal to; 2.0 (Fermi). This target is of production quality and should be completely compatible with; the official NVIDIA toolchain. Code Generator Options:. :raw-html:`<table border=""1"" cellspacing=""0"">`; :raw-html:`<tr>`; :raw-html:`<th>Option</th>`; :raw-html:`<th>Description</th>`; :raw-html:`</tr>`; :raw-html:`<tr>`; :raw-html:`<td>sm_20</td>`; :raw-html:`<td align=""left"">Set shader model/compute capability to 2.0</td>`; :raw-html:`</tr>`; :raw-html:`<tr>`; :raw-html:`<td>sm_21</td>`; :raw-html:`<td align=""le",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:100794,simpl,simplifies,100794,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['simpl'],['simplifies']
Usability,"d upon. Short titles; also look better in `git log`. * When the changes are restricted to a specific part of the code (e.g. a; back-end or optimization pass), it is customary to add a tag to the; beginning of the line in square brackets. For example, ""[SCEV] ...""; or ""[OpenMP] ..."". This helps email filters and searches for post-commit; reviews. * The body, if it exists, should be separated from the title by an empty line. * The body should be concise, but explanatory, including a complete; reasoning. Unless it is required to understand the change, examples,; code snippets and gory details should be left to bug comments, web; review or the mailing list. * Text formatting and spelling should follow the same rules as documentation; and in-code comments, ex. capitalization, full stop, etc. * If the commit is a bug fix on top of another recently committed patch, or a; revert or reapply of a patch, include the git commit hash of the prior; related commit. This could be as simple as ""Revert commit NNNN because it; caused PR#"". * If the patch has been reviewed, add a link to its review page, as shown; `here <https://www.llvm.org/docs/Phabricator.html#committing-a-change>`__.; If the patch fixes a bug in GitHub Issues, we encourage adding a reference to; the issue being closed, as described; `here <https://llvm.org/docs/BugLifeCycle.html#resolving-closing-bugs>`__. * It is also acceptable to add other metadata to the commit message to automate; processes, including for downstream consumers. This metadata can include; links to resources that are not available to the entire community. However,; such links and/or metadata should not be used in place of making the commit; message self-explanatory. Note that such non-public links should not be; included in the submitted code. For minor violations of these recommendations, the community normally favors; reminding the contributor of this policy over reverting. Minor corrections and; omissions can be handled by sending a reply to t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:17404,simpl,simple,17404,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['simpl'],['simple']
Usability,"d users of the project. For more information about; the Apache 2.0 License, please see the `Apache License FAQ; <http://www.apache.org/foundation/license-faq.html>`_, maintained by the; Apache Project. .. _patent license:. Patents; -------. Section 3 of the Apache 2.0 license is a patent grant under which; contributors of code to the project contribute the rights to use any of; their patents that would otherwise be infringed by that code contribution; (protecting uses of that code). Further, the patent grant is revoked; from anyone who files a patent lawsuit about code in LLVM - this protects the; community by providing a ""patent commons"" for the code base and reducing the; odds of patent lawsuits in general. The license specifically scopes which patents are included with code; contributions. To help explain this, the `Apache License FAQ; <http://www.apache.org/foundation/license-faq.html>`_ explains this scope using; some questions and answers, which we reproduce here for your convenience (for; reference, the ""ASF"" is the Apache Software Foundation, the guidance still; holds though)::. Q1: If I own a patent and contribute to a Work, and, at the time my; contribution is included in that Work, none of my patent's claims are subject; to Apache's Grant of Patent License, is there a way any of those claims would; later become subject to the Grant of Patent License solely due to subsequent; contributions by other parties who are not licensees of that patent. A1: No. Q2: If at any time after my contribution, I am able to license other patent; claims that would have been subject to Apache's Grant of Patent License if; they were licensable by me at the time of my contribution, do those other; claims become subject to the Grant of Patent License?. A2: Yes. Q3: If I own or control a licensable patent and contribute code to a specific; Apache product, which of my patent claims are subject to Apache's Grant of; Patent License?. A3: The only patent claims that are licensed to th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:59147,guid,guidance,59147,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['guid'],['guidance']
Usability,"d(std::coroutine_handle<PromiseType> handle) noexcept {; handle.promise().count++;; }; };. static task coro_task(int v) {; int a = v;; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; co_await await_counter{};; a++;; std::cout << a << ""\n"";; a++;; std::cout << a << ""\n"";; }. int main() {; task t = coro_task(43);; t.resume();; t.resume();; t.resume();; return 0;; }. In debug mode (`O0` + `g`), the printing result would be:. .. parsed-literal::. {__resume_fn = 0x4019e0 <coro_task(int)>, __destroy_fn = 0x402000 <coro_task(int)>, __promise = {count = 1}, v = 43, a = 45, __coro_index = 1 '\001', struct_std__suspend_always_0 = {__int_8 = 0 '\000'},; class_await_counter_1 = {__int_8 = 0 '\000'}, class_await_counter_2 = {__int_8 = 0 '\000'}, struct_std__suspend_always_3 = {__int_8 = 0 '\000'}}. In the above, the values of `v` and `a` are clearly expressed, as are the; temporary values for `await_counter` (`class_await_counter_1` and; `class_await_counter_2`) and `std::suspend_always` (; `struct_std__suspend_always_0` and `struct_std__suspend_always_3`). The index; of the current suspension point of the coroutine is emitted as `__coro_index`.; In the above example, the `__coro_index` value of `1` means the coroutine; stopped at the second suspend point (Note that `__coro_index` is zero indexed); which is the first `co_await await_counter{};` in `coro_task`. Note that the; first initial suspend point is the compiler generated; `co_await promise_type::initial_suspend()`. However, when optimizations are enabled, the printed result changes drastically:. .. parsed-literal::. {__resume_fn = 0x401280 <coro_task(int)>, __destroy_fn = 0x401390 <coro_task(int)>, __promise = {count = 1}, __int_32_0 = 43, __coro_index = 1 '\001'}. Unused values are optimized out, as well as the name of the local variable `a`.; The only information remained is the value of a 32 bit integer. In this simple; case, it seems to be pretty ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:7659,clear,clearly,7659,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['clear'],['clearly']
Usability,"d.; - `TTree::Branch()` now complains for wrong leaf list strings, e.g. ""value/F[4]"" (which should really be spelled as ""value[4]/F"").; - Allow reading of older version of TTreePerfStats (ROOT-8520); - In `TTree::OptimizeBaskets()` do not call GetBasket(0) to avoid disc reads; - It is now possible to define the precision of the default histogram created; by `TTree::Draw`. Three new parameters are available in `$ROOTSYS/etcsystem.rootrc`; ```{.cpp}; Hist.Precision.1D: float; Hist.Precision.2D: float; Hist.Precision.3D: float; ```; the default values are `float`. They can be set to `double`.; - Fix ROOT-8742: TTree::SetBranchAddress could not be invoked safely even when dealing with the same tree obtained from the same file opened in different threads.; - TTree::Branch() now complains if a ""name[size]/F"" branch specification is passed wrongly (e.g. as ""name/F[size]""). ### TDataFrame; - Creation of the TDataFrame class. The TDataFrame allows to interact with data; stored in columnar format in a functional and intuitive way in order to perform; data analysis. Parallelism is accessible simply by activating implicit; multi-threading with the ROOT::EnableImplicitMT() function.; In a nutshell, the functionality provided is:; - Create and fill histograms with one single method invocation; - Express filtering of entries with strings, lambdas or functions; - Easy creation of efficiencies of cut-flows; - Possibility to run on ranges of entries; - Creating columns not present in the original dataset; - Chain multiple actions to be executed on the same event loop; - Creation of events on-the-fly (e.g. via Pythia or user-define generator functors), with no need for an input TTree; - Snapshot on a rootfile the dataset after cuts and after augmentation with columns created by the user; - Run analyses expressed as chains of actions in parallel in a transparent way for the user; See [the online documentation](https://root.cern.ch/doc/master/classROOT_1_1Experimental_1_1TDF_1_1TDataFram",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:6234,intuit,intuitive,6234,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['intuit'],['intuitive']
Usability,"dOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // ... but the node had been created.; auto *ToYDef = getFirstDecl<CXXRecordDecl>(; cxxRecordDecl(hasName(""Y""), isDefinition()), ToUnit);; ToYDef->dump();; // An error is set for ""ToYDef"" in the shared state.; Optional<ASTImportError> OptErr =; ImporterState->getImportDeclErrorIfAny(ToYDef);; assert(OptErr);. return 1;; }. If we take a look at the AST, then we can see that the Decl with the definition is created, but the field is missing. .. code-block:: bash. |-CXXRecordDecl 0xf66678 <line:9:7, col:13> col:13 class Y; `-CXXRecordDecl 0xf66730 prev 0xf66678 <:10:7, col:13> col:13 class Y definition; |-DefinitionData pass_in_registers empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init; | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; `-CXXRecordDecl 0xf66828 <col:7, col:13> col:13 implicit class Y. We do not remove the erroneous nodes because by the time when we recognize the error it is too late to remove the node, there may be additional references to that already in the AST.; This is aligned with the overall `design principle of the Clang AST <InternalsManual.html#immutability>`_: Clang AST nodes (types, declarations, statements, expressions, and so on) are generally designed to be **immutable once created**.; Thus, clients of the ASTImporter library should always check if there is any associated error for the node which they inspect in the destination context.; We recommend skipp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:19363,simpl,simple,19363,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,4,['simpl'],['simple']
Usability,"d_size_t`` is defined before that header is included, and also vend ``wchar_t`` only when the macro ``__need_wchar_t`` is defined. Such headers are often included many times in a single translation unit, and will have no include guards. There is no sane way to map this header to a submodule. One can either eliminate the header (e.g., by splitting it into separate headers, one per actual API) or simply ``exclude`` it in the module map. To detect and help address some of these problems, the ``clang-tools-extra`` repository contains a ``modularize`` tool that parses a set of given headers and attempts to detect these problems and produce a report. See the tool's in-source documentation for information on how to check your system or library headers. Future Directions; =================; Modules support is under active development, and there are many opportunities remaining to improve it. Here are a few ideas:. **Detect unused module imports**; Unlike with ``#include`` directives, it should be fairly simple to track whether a directly-imported module has ever been used. By doing so, Clang can emit ``unused import`` or ``unused #include`` diagnostics, including Fix-Its to remove the useless imports/includes. **Fix-Its for missing imports**; It's fairly common for one to make use of some API while writing code, only to get a compiler error about ""unknown type"" or ""no function named"" because the corresponding header has not been included. Clang can detect such cases and auto-import the required module, but should provide a Fix-It to add the import. **Improve modularize**; The modularize tool is both extremely important (for deployment) and extremely crude. It needs better UI, better detection of problems (especially for C++), and perhaps an assistant mode to help write module maps for you. Where To Learn More About Modules; =================================; The Clang source code provides additional information about modules:. ``clang/lib/Headers/module.modulemap``; Module ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:56266,simpl,simple,56266,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['simpl'],['simple']
Usability,"dar:. LLVM community calendar; -----------------------. We aim to maintain a public calendar view of all events happening in the LLVM; community such as :ref:`online-sync-ups` and :ref:`office-hours`. The calendar; can be found at; https://calendar.google.com/calendar/u/0/embed?src=calendar@llvm.org and can; also be seen inline below:. .. raw:: html. <iframe src=""https://calendar.google.com/calendar/embed?height=600&wkst=1&bgcolor=%23ffffff&ctz=UTC&showCalendars=0&showDate=1&showNav=1&src=Y2FsZW5kYXJAbGx2bS5vcmc&color=%23039BE5"" style=""border:solid 1px #777"" width=""800"" height=""600"" frameborder=""0"" scrolling=""no""></iframe>. .. _llvm-community-calendar-host-guidance:. Guidance on what to put into LLVM community calendar invites; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. To add your event, create a calendar event for it and invite calendar@llvm.org; on it. Your event should then show up on the community calendar. Please put the following pieces of information in your calendar invite:. * Write a single paragraph describing what the event is about. Include things; such as who the event is for and what sort of topics are discussed.; * State explicitly that the :doc:`CodeOfConduct` applies to this event.; * Make it clear who:. * the organizer is. * the person to contact is in case of any code-of-conduct issues. Typically,; this would be the organizer. * If you have meeting minutes for your event, add a pointer to where those live.; A good place for meeting minutes could be as a post on LLVM Discourse. An example invite looks as follows. .. code-block:: none. This event is a meetup for all developers of LLDB. Meeting agendas are posted; on discourse before the event. Attendees are required to adhere to the LLVM Code of Conduct; (https://llvm.org/docs/CodeOfConduct.html). For any Code of Conduct reports,; please contact the organizers, and also email conduct@llvm.org. Agenda/Meeting Minutes: Link to minutes. Organizer(s): First Surname (name@email.com). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:20164,clear,clear,20164,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['clear'],['clear']
Usability,"dd or change the project's .clang-tidy to reflect the agreed rules.; (This is in a separate commit to enable the merging process described in; `Minimising cost of downstream merges`_).; Also update the project list on the policy page.; 2. Apply ``clang-tidy`` to the project's files, with only the; ``readability-identifier-naming`` rules enabled. ``clang-tidy`` will also; reformat the affected lines according to the rules in ``.clang-format``.; It is anticipated that this will be a good dog-fooding opportunity for; clang-tidy, and bugs should be fixed in the process, likely including:. * `readability-identifier-naming incorrectly fixes lambda capture; <https://bugs.llvm.org/show_bug.cgi?id=41119>`_.; * `readability-identifier-naming incorrectly fixes variables which; become keywords <https://bugs.llvm.org/show_bug.cgi?id=41120>`_.; * `readability-identifier-naming misses fixing member variables in; destructor <https://bugs.llvm.org/show_bug.cgi?id=41122>`_. #. Gather feedback and refine the process as appropriate. #. Apply the process to the following projects, with a suitable delay between; each (at least 4 weeks after the first change, at least 2 weeks subsequently); to allow gathering further feedback.; This list should exclude projects that must adhere to an externally defined; standard e.g. libcxx.; The list is roughly in chronological order of renaming.; Some items may not make sense to rename individually - it is expected that; this list will change following experimentation:. * TableGen; * llvm/tools; * clang-tools-extra; * clang; * ARM backend; * AArch64 backend; * AMDGPU backend; * ARC backend; * AVR backend; * BPF backend; * Hexagon backend; * Lanai backend; * MIPS backend; * NVPTX backend; * PowerPC backend; * RISC-V backend; * Sparc backend; * SystemZ backend; * WebAssembly backend; * X86 backend; * XCore backend; * libLTO; * Debug Information; * Remainder of llvm; * compiler-rt; * libunwind; * openmp; * parallel-libs; * polly; * lldb. #. Remove the old v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:12139,feedback,feedback,12139,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['feedback'],['feedback']
Usability,"de for ""a+b"", and; then continue parsing:. .. code-block:: c++. ... if body omitted ...; }. // Merge LHS/RHS.; LHS = std::make_unique<BinaryExprAST>(BinOp, std::move(LHS),; std::move(RHS));; } // loop around to the top of the while loop.; }. In our example above, this will turn ""a+b+"" into ""(a+b)"" and execute the; next iteration of the loop, with ""+"" as the current token. The code; above will eat, remember, and parse ""(c+d)"" as the primary expression,; which makes the current pair equal to [+, (c+d)]. It will then evaluate; the 'if' conditional above with ""\*"" as the binop to the right of the; primary. In this case, the precedence of ""\*"" is higher than the; precedence of ""+"" so the if condition will be entered. The critical question left here is ""how can the if condition parse the; right hand side in full""? In particular, to build the AST correctly for; our example, it needs to get all of ""(c+d)\*e\*f"" as the RHS expression; variable. The code to do this is surprisingly simple (code from the; above two blocks duplicated for context):. .. code-block:: c++. // If BinOp binds less tightly with RHS than the operator after RHS, let; // the pending operator take RHS as its LHS.; int NextPrec = GetTokPrecedence();; if (TokPrec < NextPrec) {; RHS = ParseBinOpRHS(TokPrec+1, std::move(RHS));; if (!RHS); return nullptr;; }; // Merge LHS/RHS.; LHS = std::make_unique<BinaryExprAST>(BinOp, std::move(LHS),; std::move(RHS));; } // loop around to the top of the while loop.; }. At this point, we know that the binary operator to the RHS of our; primary has higher precedence than the binop we are currently parsing.; As such, we know that any sequence of pairs whose operators are all; higher precedence than ""+"" should be parsed together and returned as; ""RHS"". To do this, we recursively invoke the ``ParseBinOpRHS`` function; specifying ""TokPrec+1"" as the minimum precedence required for it to; continue. In our example above, this will cause it to return the AST; node for ""(c+d)\*e\*f"" a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:18899,simpl,simple,18899,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['simpl'],['simple']
Usability,"de set can; be a subset of another loop with a different loop header. The loop; hierarchy in a function forms a forest: Each top-level loop is the; root of the tree of the loops nested inside it. .. image:: ./loop-nested.svg; :width: 350 px. * It is not possible that two loops share only a few of their nodes.; Two loops are either disjoint or one is nested inside the other. In; the example below the left and right subsets both violate the; maximality condition. Only the merge of both sets is considered a loop. .. image:: ./loop-nonmaximal.svg; :width: 250 px. * It is also possible that two logical loops share a header, but are; considered a single loop by LLVM:. .. code-block:: C. for (int i = 0; i < 128; ++i); for (int j = 0; j < 128; ++j); body(i,j);. which might be represented in LLVM-IR as follows. Note that there is; only a single header and hence just a single loop. .. image:: ./loop-merge.svg; :width: 400 px. The :ref:`LoopSimplify <loop-terminology-loop-simplify>` pass will; detect the loop and ensure separate headers for the outer and inner loop. .. image:: ./loop-separate.svg; :width: 400 px. * A cycle in the CFG does not imply there is a loop. The example below; shows such a CFG, where there is no header node that dominates all; other nodes in the cycle. This is called **irreducible control-flow**. .. image:: ./loop-irreducible.svg; :width: 150 px. The term reducible results from the ability to collapse the CFG into a; single node by successively replacing one of three base structures with; a single node: A sequential execution of basic blocks, acyclic conditional; branches (or switches), and a basic block looping on itself.; `Wikipedia <https://en.wikipedia.org/wiki/Control-flow_graph#Reducibility>`_; has a more formal definition, which basically says that every cycle has; a dominating header. * Irreducible control-flow can occur at any level of the loop nesting.; That is, a loop that itself does not contain any loops can still have; cyclic control flow ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst:4215,simpl,simplify,4215,interpreter/llvm-project/llvm/docs/LoopTerminology.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LoopTerminology.rst,1,['simpl'],['simplify']
Usability,"de unsupported context menu entries, status line update. ## Changes in 3.4; 1. Support usage of minimized versions of .js and .css files.; Minimized scripts used by default on web servers.; 2. Implement JSROOT.extend instead of jQuery.extend, reduce; usage of jquery.js in core JSROOT classes; 3. Implement main graphics without jquery at all,; such mode used in `nobrowser` mode.; 4. Provide optional latex drawing with MathJax SVG.; TMathText always drawn with MathJax,; other classes require `mathjax` option in URL; 5. Improve drawing of different text classes, correctly handle; their alignment and scaling, special handling for IE; 6. Fix error with time axes - time offset was not correctly interpreted. ## Changes in 3.3; 1. Use d3.time.scale for display of time scales; 2. Within JSRootCore.js script URL one could specify JSROOT; functionality to be loaded: '2d', '3d', 'io', 'load', 'onload'.; Old method with JSROOT.AssertPrerequisites will also work.; 3. With THttpServer JSROOT now provides simple control functionality.; One could publish commands and execute them from the browser; 4. One could open several ROOT files simultaneously; 5. Add 'simple' layout - drawing uses full space on the right side; 6. Allow to open ROOT files in online session (via url parameter); 7. One could monitor simultaneously objects from server and root files; 8. Implement 'autocol' draw option - when superimposing histograms,; their line colors will be automatically assigned; 9. Implement 'nostat' draw option - disabled stat drawing; 10. Using '_same_' identifier in item name, one can easily draw or superimpose; similar items from different files. Could be used in URL like:; `...&files=[file1.root,file2.root]&items=[file1.root/hpx, file2.root/_same_]`; `...&files=[file1.root,file2.root]&item=file1.root/hpx+file2.root/_same_`; Main limitation - file names should have similar length.; 11. When 'autozoom' specified in draw options, histogram zoomed into; non-empty content. Same command availab",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:67215,simpl,simple,67215,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['simpl'],['simple']
Usability,"de-block:: bash. Kaleidoscope-Ch9 < fib.ks | & clang -x ir -. which gives an a.out/a.exe in the current working directory. Compile Unit; ============. The top level container for a section of code in DWARF is a compile unit.; This contains the type and function data for an individual translation unit; (read: one file of source code). So the first thing we need to do is; construct one for our fib.ks file. DWARF Emission Setup; ====================. Similar to the ``IRBuilder`` class we have a; `DIBuilder <https://llvm.org/doxygen/classllvm_1_1DIBuilder.html>`_ class; that helps in constructing debug metadata for an LLVM IR file. It; corresponds 1:1 similarly to ``IRBuilder`` and LLVM IR, but with nicer names.; Using it does require that you be more familiar with DWARF terminology than; you needed to be with ``IRBuilder`` and ``Instruction`` names, but if you; read through the general documentation on the; `Metadata Format <https://llvm.org/docs/SourceLevelDebugging.html>`_ it; should be a little more clear. We'll be using this class to construct all; of our IR level descriptions. Construction for it takes a module so we; need to construct it shortly after we construct our module. We've left it; as a global static variable to make it a bit easier to use. Next we're going to create a small container to cache some of our frequent; data. The first will be our compile unit, but we'll also write a bit of; code for our one type since we won't have to worry about multiple typed; expressions:. .. code-block:: c++. static std::unique_ptr<DIBuilder> DBuilder;. struct DebugInfo {; DICompileUnit *TheCU;; DIType *DblTy;. DIType *getDoubleTy();; } KSDbgInfo;. DIType *DebugInfo::getDoubleTy() {; if (DblTy); return DblTy;. DblTy = DBuilder->createBasicType(""double"", 64, dwarf::DW_ATE_float);; return DblTy;; }. And then later on in ``main`` when we're constructing our module:. .. code-block:: c++. DBuilder = std::make_unique<DIBuilder>(*TheModule);. KSDbgInfo.TheCU = DBuilder->createC",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:6434,clear,clear,6434,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,1,['clear'],['clear']
Usability,"de-block:: llvm. %f.frame = type { ptr, ptr, i32 }. After resume and destroy parts are outlined, function `f` will contain only the; code responsible for creation and initialization of the coroutine frame and; execution of the coroutine until a suspend point is reached:. .. code-block:: llvm. define ptr @f(i32 %n) {; entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %alloc = call noalias ptr @malloc(i32 24); %frame = call noalias ptr @llvm.coro.begin(token %id, ptr %alloc); %1 = getelementptr %f.frame, ptr %frame, i32 0, i32 0; store ptr @f.resume, ptr %1; %2 = getelementptr %f.frame, ptr %frame, i32 0, i32 1; store ptr @f.destroy, ptr %2. %inc = add nsw i32 %n, 1; %inc.spill.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i32 0, i32 2; store i32 %inc, ptr %inc.spill.addr; call void @print(i32 %n). ret ptr %frame; }. Outlined resume part of the coroutine will reside in function `f.resume`:. .. code-block:: llvm. define internal fastcc void @f.resume(ptr %frame.ptr.resume) {; entry:; %inc.spill.addr = getelementptr %f.frame, ptr %frame.ptr.resume, i64 0, i32 2; %inc.spill = load i32, ptr %inc.spill.addr, align 4; %inc = add i32 %inc.spill, 1; store i32 %inc, ptr %inc.spill.addr, align 4; tail call void @print(i32 %inc); ret void; }. Whereas function `f.destroy` will contain the cleanup code for the coroutine:. .. code-block:: llvm. define internal fastcc void @f.destroy(ptr %frame.ptr.destroy) {; entry:; tail call void @free(ptr %frame.ptr.destroy); ret void; }. Avoiding Heap Allocations; -------------------------. A particular coroutine usage pattern, which is illustrated by the `main`; function in the overview section, where a coroutine is created, manipulated and; destroyed by the same calling function, is common for coroutines implementing; RAII idiom and is suitable for allocation elision optimization which avoid; dynamic allocation by storing the coroutine frame as a static `alloca` in its; caller. In the entry block, we will c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:15612,resume,resume,15612,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"de](https://root.cern.ch/doc/master/classRooCategory.html). ### Type-safe proxies for RooFit objects; RooFit's proxy classes have been modernised. The class `RooTemplateProxy` allows for access to other RooFit objects; similarly to a smart pointer. In older versions of RooFit, the objects held by *e.g.* `RooRealProxy` had to be; accessed like this:; RooAbsArg* absArg = realProxy.absArg();; RooAbsPdf* pdf = dynamic_cast<RooAbsPdf*>(absArg);; assert(pdf); // This *should* work, but the proxy doesn't have a way to check; pdf->fitTo(...);; That is, a `RooRealProxy` stores a pointer to a RooAbsArg, and this pointer has to be cast. There was no type; safety, *i.e.*, any object deriving from RooAbsArg could be stored in that proxy, and the user had to take care; of ensuring that types are correct.; Now, if one uses; RooTemplateProxy<RooAbsPdf> pdfProxy;; instead of; RooRealProxy realProxy;; in RooFit classes, the above code can be simplified to; pdfProxy->fitTo(...);. Check the [doxygen reference guide](https://root.cern.ch/doc/master/classRooTemplateProxy.html) for `RooTemplateProxy` for; more information on how to modernise old code. ### HistFactory. #### Switch default statistical MC errors to Poisson; When defining HistFactory samples with statistical errors from C++, e.g.; Sample background1( ""background1"", ""background1"", InputFile );; background1.ActivateStatError();; statistical MC errors now have Poisson instead of Gaussian constraints. This better reflects the uncertainty of the MC simulations.; This can be reverted as follows:; // C++:; Channel chan(""channel1"");; chan.SetStatErrorConfig( 0.05, ""Gauss"" );; // Within <Channel ... > XML:; <StatErrorConfig RelErrorThreshold=""0.05"" ConstraintType=""Gauss"" />. #### Less verbose HistFactory; HistFactory was very verbose, writing to the terminal with lots of `cout`. Now, many HistFactory messages are going; into RooFit's message stream number 2. The verbosity can therefore be adjusted using; RooMsgService::instance().getS",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:5014,guid,guide,5014,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['guid'],['guide']
Usability,"des in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:77788,simpl,simple,77788,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['simpl'],['simple']
Usability,"deserialization of older readers. ## Locators and Envelope Links. A locator is a generalized way to specify a certain byte range on the storage medium.; For disk-based storage, the locator is just byte offset and byte size.; For other storage systems, the locator contains enough information to retrieve the referenced block,; e.g. in object stores, the locator can specify a certain object ID.; The locator has the following format. ```; 0 1 2 3; 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | Size |T|; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | |; + Offset +; | |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; ```. _Size_: If `T` is zero, the number of bytes to read, i.e. the compressed size of the referenced block.; Otherwise, the 16 least-significant bits, i.e. bits 0:15, specify the size of the locator itself (see below). _T(ype)_: Zero for a simple on-disk or in-file locator, 1 otherwise.; Can be interpreted as the sign bit of the size, i.e. negative sizes indicate non-standard locators.; In this case, the locator should be interpreted like a frame, i.e. size indicates the _size of the locator itself_. _Offset_:; For on-disk / in-file locators, the 64bit byte offset of the referenced byte range counted from the start of the file. For non-standard locators, i.e. `T` == 1, the locator format is as follows. ```; 0 1 2 3; 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | Size | Reserved | Type |T|; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | LOCATOR PAYLOAD |; | ... |; ```. In this case, the last 8 bits of the size should be interpreted as a locator type.; To determine the locator type, the absolute value of the 8bit integer should be taken.; The type can take one of the following values. | Type | Meaning | Payload format |; |------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:10042,simpl,simple,10042,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['simpl'],['simple']
Usability,"detection for a sampled allocation is; transient. To keep memory overhead fixed while still detecting bugs, deallocated; slots are randomly reused to guard future allocations. Usage; =====. GWP-ASan already ships by default in the; `Scudo Hardened Allocator <https://llvm.org/docs/ScudoHardenedAllocator.html>`_,; so building with ``-fsanitize=scudo`` is the quickest and easiest way to try out; GWP-ASan. Options; -------. GWP-ASan's configuration is managed by the supporting allocator. We provide a; generic configuration management library that is used by Scudo. It allows; several aspects of GWP-ASan to be configured through the following methods:. - When the GWP-ASan library is compiled, by setting; ``-DGWP_ASAN_DEFAULT_OPTIONS`` to the options string you want set by default.; If you're building GWP-ASan as part of a compiler-rt/LLVM build, add it during; cmake configure time (e.g. ``cmake ... -DGWP_ASAN_DEFAULT_OPTIONS=""...""``). If; you're building GWP-ASan outside of compiler-rt, simply ensure that you; specify ``-DGWP_ASAN_DEFAULT_OPTIONS=""...""`` when building; ``optional/options_parser.cpp``). - By defining a ``__gwp_asan_default_options`` function in one's program that; returns the options string to be parsed. Said function must have the following; prototype: ``extern ""C"" const char* __gwp_asan_default_options(void)``, with a; default visibility. This will override the compile time define;. - Depending on allocator support (Scudo has support for this mechanism): Through; an environment variable, containing the options string to be parsed. In Scudo,; this is through `SCUDO_OPTIONS=GWP_ASAN_${OPTION_NAME}=${VALUE}` (e.g.; `SCUDO_OPTIONS=GWP_ASAN_SampleRate=100`). Options defined this way will; override any definition made through ``__gwp_asan_default_options``. The options string follows a syntax similar to ASan, where distinct options; can be assigned in the same string, separated by colons. For example, using the environment variable:. .. code:: console. GWP_ASAN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:5587,simpl,simply,5587,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['simpl'],['simply']
Usability,"dex = load i8, ptr %index.addr, align 1; %switch = icmp eq i8 %index, 0; %n.addr = getelementptr inbounds %f.Frame, ptr %FramePtr, i64 0, i32 3; %n = load i32, ptr %n.addr, align 4. br i1 %switch, label %loop.resume, label %loop. loop.resume:; %sub = sub nsw i32 0, %n; call void @print(i32 %sub); br label %suspend; loop:; %inc = add nsw i32 %n, 1; store i32 %inc, ptr %n.addr, align 4; tail call void @print(i32 %inc); br label %suspend. suspend:; %storemerge = phi i8 [ 0, %loop ], [ 1, %loop.resume ]; store i8 %storemerge, ptr %index.addr, align 1; ret void; }. If different cleanup code needs to get executed for different suspend points,; a similar switch will be in the `f.destroy` function. .. note ::. Using suspend index in a coroutine state and having a switch in `f.resume` and; `f.destroy` is one of the possible implementation strategies. We explored; another option where a distinct `f.resume1`, `f.resume2`, etc. are created for; every suspend point, and instead of storing an index, the resume and destroy; function pointers are updated at every suspend. Early testing showed that the; current approach is easier on the optimizer than the latter so it is a; lowering strategy implemented at the moment. Distinct Save and Suspend; -------------------------. In the previous example, setting a resume index (or some other state change that; needs to happen to prepare a coroutine for resumption) happens at the same time as; a suspension of a coroutine. However, in certain cases, it is necessary to control; when coroutine is prepared for resumption and when it is suspended. In the following example, a coroutine represents some activity that is driven; by completions of asynchronous operations `async_op1` and `async_op2` which get; a coroutine handle as a parameter and resume the coroutine once async; operation is finished. .. code-block:: text. void g() {; for (;;); if (cond()) {; async_op1(<coroutine-handle>); // will resume once async_op1 completes; <suspend>; do_one();; }",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:20273,resume,resume,20273,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"diately preceding; the `coro.suspend` intrinsic. The second argument indicates whether this suspension point is `final`_.; The second argument only accepts constants. If more than one suspend point is; designated as final, the resume and destroy branches should lead to the same; basic blocks. Example (normal suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. %0 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %0, label %suspend [i8 0, label %resume; i8 1, label %cleanup]. Example (final suspend point):; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""". .. code-block:: llvm. while.end:; %s.final = call i8 @llvm.coro.suspend(token none, i1 true); switch i8 %s.final, label %suspend [i8 0, label %trap; i8 1, label %cleanup]; trap:; call void @llvm.trap(); unreachable. Semantics:; """""""""""""""""""". If a coroutine that was suspended at the suspend point marked by this intrinsic; is resumed via `coro.resume`_ the control will transfer to the basic block; of the 0-case. If it is resumed via `coro.destroy`_, it will proceed to the; basic block indicated by the 1-case. To suspend, coroutine proceed to the; default label. If suspend intrinsic is marked as final, it can consider the `true` branch; unreachable and can perform optimizations that can take advantage of that fact. .. _coro.save:. 'llvm.coro.save' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare token @llvm.coro.save(ptr <handle>). Overview:; """""""""""""""""". The '``llvm.coro.save``' marks the point where a coroutine need to update its; state to prepare for resumption to be considered suspended (and thus eligible; for resumption). It is illegal to merge two '``llvm.coro.save``' calls unless their; '``llvm.coro.suspend``' users are also merged. So '``llvm.coro.save``' is currently; tagged with the `no_merge` function attribute. Arguments:; """""""""""""""""""". The first argument points to a coroutine handle of the enclosing coroutine. Semantics:; """""""""""""""""""". Whatever coroutine state changes are required to e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:51344,resume,resumed,51344,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resumed']
Usability,"ding in ``\`` are concatenated until a RUN line that doesn't end in; ``\`` is found. This concatenated set of RUN lines then constitutes one; execution. :program:`lit` will substitute variables and arrange for the pipeline; to be executed. If any process in the pipeline fails, the entire line (and; test case) fails too. Below is an example of legal RUN lines in a ``.ll`` file:. .. code-block:: llvm. ; RUN: llvm-as < %s | llvm-dis > %t1; ; RUN: llvm-dis < %s.bc-13 > %t2; ; RUN: diff %t1 %t2. As with a Unix shell, the RUN lines permit pipelines and I/O; redirection to be used. There are some quoting rules that you must pay attention to when writing; your RUN lines. In general nothing needs to be quoted. :program:`lit` won't; strip off any quote characters so they will get passed to the invoked program.; To avoid this use curly braces to tell :program:`lit` that it should treat; everything enclosed as one value. In general, you should strive to keep your RUN lines as simple as possible,; using them only to run tools that generate textual output you can then examine.; The recommended way to examine output to figure out if the test passes is using; the :doc:`FileCheck tool <CommandGuide/FileCheck>`. *[The usage of grep in RUN; lines is deprecated - please do not send or commit patches that use it.]*. Put related tests into a single file rather than having a separate file per; test. Check if there are files already covering your feature and consider; adding your code there instead of creating a new file. Generating assertions in regression tests; -----------------------------------------. Some regression test cases are very large and complex to write/update by hand.; In that case to reduce the human work we can use the scripts available in; llvm/utils/ to generate the assertions. For example to generate assertions in an :program:`llc`-based test, after; adding one or more RUN lines use:. .. code-block:: bash. % llvm/utils/update_llc_test_checks.py --llc-binary build/bin/ll",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:10603,simpl,simple,10603,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['simpl'],['simple']
Usability,"dir LINKDEF LinkDef.h)` *if* the header is usually included as; `#include ""Header1.h""`, or to `ROOT_GENERATE_DICTIONARY(Dict subdir/Header1.h LINKDEF LinkDef.h)` *if* the header is usually; included as `#include ""subdir/Header1.h""`. I.e. the general rule is: pass to `ROOT_GENERATE_DICTIONARY` (or; `ROOT_STANDARD_LIBRARY_PACKAGE`) the spelling as `#include`ed. As an important side-effect, `ROOT_GENERATE_DICTIONARY` and thus `ROOT_STANDARD_LIBRARY_PACKAGE` now *require* the header to; be found at configuration time. We have seen too many cases where the header location was mis-stated, and as a consequence,; CMake did not generate the proper dependencies. If the header should not be taken into account for dependencies and / or if; the header will not be found (e.g. the standard library's `vector`) please pass the header through the `NODEPHEADERS` option; to `ROOT_GENERATE_DICTIONARY` or `ROOT_STANDARD_LIBRARY_PACKAGE`. We believe that this simplification / regularization of behavior, and the additional checks are worth the possible changes; on the user side. ## PyROOT. If the fix or new feature is a pythonization related to a C++ class, the change is added to the respective section above. ### Current PyROOT. - Fix compatibility with Python3.7 (ROOT-9922, ROOT-9871, ROOT-9809); - Fix lookup for templated methods (ROOT-9789); - Fix lookup for templated free functions (ROOT-9836). ### Experimental PyROOT. - All pythonisations from current PyROOT already migrated (`TTree` and subclasses, `TDirectory` and subclasses,; `TCollection` and subclasses, `TObject`, `TClass`, `TString`, `TObjString`, `TIter`, `TStyle`, `TH1`, `TFX`, `TMinuit`, `TVector3`,; `TVectorT`, `TArray`, `TCollection`, `TSeqCollection`, `TClonesArray`, `TComplex`, `TGraph`, `RooDataHist`) - ROOT-9510; - Cppyy updated to cppyy 1.4.7, cppyy-backend 1.8.1 (clingwrapper), CPyCppyy 1.7.1; * Includes fixed template support, fixed overload resolution, Windows fixes and other; - Merged Cppyy's patch to support using",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:25782,simpl,simplification,25782,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['simpl'],['simplification']
Usability,"dium) . Floating-point support.; Currently, the analyzer treats all floating-point values as unknown.; This project would involve adding a new SVal kind; for constant floats, generalizing the constraint manager to handle floats,; and auditing existing code to make sure it doesn't; make incorrect assumptions (most notably, that X == X; is always true, since it does not hold for NaN).; (Difficulty: Medium). Improved loop execution modeling.; The analyzer simply unrolls each loop N times before; dropping the path, for a fixed constant N.; However, that results in lost coverage in cases where the loop always; executes more than N times.; A Google Summer Of Code; project; was completed to make the loop bound parameterizable,; but the widening; problem still remains open. (Difficulty: Hard). Basic function summarization support; The analyzer performs inter-procedural analysis using; either inlining or ""conservative evaluation"" (invalidating all data; passed to the function).; Often, a very simple summary; (e.g. ""this function is pure"") would be; enough to be a large improvement over conservative evaluation.; Such summaries could be obtained either syntactically,; or using a dataflow framework.; (Difficulty: Hard). Implement a dataflow flamework.; The analyzer core; implements a symbolic execution; engine, which performs checks; (use-after-free, uninitialized value read, etc.); over a single program path.; However, many useful properties; (dead code, check-after-use, etc.) require; reasoning over all possible in a program.; Such reasoning requires a; dataflow analysis framework.; Clang already implements; a few dataflow analyses (most notably, liveness),; but they implemented in an ad-hoc fashion.; A proper framework would enable us writing many more useful checkers.; (Difficulty: Hard) . Track type information through casts more precisely.; The DynamicTypePropagation; checker is in charge of inferring a region's; dynamic type based on what operations the code is performing",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:7506,simpl,simple,7506,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,1,['simpl'],['simple']
Usability,"dominator tree alongside any transformations, but other analysis results may be invalid.; PreservedAnalyses PA;; PA.preserve<DominatorAnalysis>();; return PA;. // We haven't made any control flow changes, any analyses that only care about the control flow are still valid.; PreservedAnalyses PA;; PA.preserveSet<CFGAnalyses>();; return PA;. The pass manager will call the analysis manager's ``invalidate()`` method; with the pass's returned ``PreservedAnalyses``. This can be also done; manually within the pass:. .. code-block:: c++. FooModulePass::run(Module& M, ModuleAnalysisManager& AM) {; auto &FAM = AM.getResult<FunctionAnalysisManagerModuleProxy>(M).getManager();. // Invalidate all analysis results for function F1.; FAM.invalidate(F1, PreservedAnalyses::none());. // Invalidate all analysis results across the entire module.; AM.invalidate(M, PreservedAnalyses::none());. // Clear the entry in the analysis manager for function F2 if we've completely removed it from the module.; FAM.clear(F2);. ...; }. One thing to note when accessing inner level IR analyses is cached results for; deleted IR. If a function is deleted in a module pass, its address is still used; as the key for cached analyses. Take care in the pass to either clear the; results for that function or not use inner analyses at all. ``AM.invalidate(M, PreservedAnalyses::none());`` will invalidate the inner; analysis manager proxy which will clear all cached analyses, conservatively; assuming that there are invalid addresses used as keys for cached analyses.; However, if you'd like to be more selective about which analyses are; cached/invalidated, you can mark the analysis manager proxy as preserved,; essentially saying that all deleted entries have been taken care of manually.; This should only be done with measurable compile time gains as it can be tricky; to make sure all the right analyses are invalidated. Implementing Analysis Invalidation; ==================================. By default, an analysis is in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:14001,clear,clear,14001,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['clear'],['clear']
Usability,"don't currently merge them together. For; example, it is useful to merge memcpy(a,b,strlen(b)) -> strcpy. This can only; be done safely if ""b"" isn't modified between the strlen and memcpy of course. //===---------------------------------------------------------------------===//. We compile this program: (from GCC PR11680); http://gcc.gnu.org/bugzilla/attachment.cgi?id=4487. Into code that runs the same speed in fast/slow modes, but both modes run 2x; slower than when compile with GCC (either 4.0 or 4.2):. $ llvm-g++ perf.cpp -O3 -fno-exceptions; $ time ./a.out fast; 1.821u 0.003s 0:01.82 100.0%	0+0k 0+0io 0pf+0w. $ g++ perf.cpp -O3 -fno-exceptions; $ time ./a.out fast; 0.821u 0.001s 0:00.82 100.0%	0+0k 0+0io 0pf+0w. It looks like we are making the same inlining decisions, so this may be raw; codegen badness or something else (haven't investigated). //===---------------------------------------------------------------------===//. Divisibility by constant can be simplified (according to GCC PR12849) from; being a mulhi to being a mul lo (cheaper). Testcase:. void bar(unsigned n) {; if (n % 3 == 0); true();; }. This is equivalent to the following, where 2863311531 is the multiplicative; inverse of 3, and 1431655766 is ((2^32)-1)/3+1:; void bar(unsigned n) {; if (n * 2863311531U < 1431655766U); true();; }. The same transformation can work with an even modulo with the addition of a; rotate: rotate the result of the multiply to the right by the number of bits; which need to be zero for the condition to be true, and shrink the compare RHS; by the same amount. Unless the target supports rotates, though, that; transformation probably isn't worthwhile. The transformation can also easily be made to work with non-zero equality; comparisons: just transform, for example, ""n % 3 == 1"" to ""(n-1) % 3 == 0"". //===---------------------------------------------------------------------===//. Better mod/ref analysis for scanf would allow us to eliminate the vtable and a; bunch of other stuf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:19527,simpl,simplified,19527,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['simpl'],['simplified']
Usability,"drag it to the; desired position. ``` {.cpp}; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; ```. ### Progress Bars. A progress bar is a widget that shows that an operation is in progress; and how much time is left. It is a long rectangular bar, initially; empty, that fills with a color as a process is being performed. The; filled-in area indicates the percentage of the process that has been; completed. You should use this widget for waits exceeding `one minute`.; For a very time consuming operation it is better to break the operation; into subtasks and provide a progress bar for each of them. ![](pictures/0200021E.jpg). A progress bar may be oriented horizontally or vertically. The; horizontally oriented progress bar fills with a color from left to; right; the vertically oriented - from bottom to top. A percent complete; message provides an indication of the completed part of the process. It; is a good practice to include some descriptive text of the process to; keep users informed and entertained while they are waiting for process; completion. The picture below shows the progress bars you can create using the; classes **`TGProgressBar`**, **`TGHProgressBar`**, and; **`TGHProgressBar`**. ``` {.cpp}; // vertical frame with three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; fHProg2->SetBarColor(""lightblue"");; fHProg2->ShowPosition(kTRUE,kFALSE,""%.0f events"");; fHProg3 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg3->SetFillType(TGProgressBar::kBlockFill);. vframe->Add",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:88351,progress bar,progress bar,88351,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['progress bar'],['progress bar']
Usability,"dress space to be user accessible may need to adjust the exact sequence used; above. Additionally, the low addresses will need to be marked unreadable by the; OS to fully harden the load. ###### RIP-relative addressing is even easier to break. There is a common addressing mode idiom that is substantially harder to check:; addressing relative to the instruction pointer. We cannot change the value of; the instruction pointer register and so we have the harder problem of forcing; `%base + scale * %index + offset` to be an invalid address, by *only* changing; `%index`. The only advantage we have is that the attacker also cannot modify; `%base`. If we use the fast instruction sequence above, but only apply it to; the index, we will always access `%rip + (scale * -1) + offset`. If the; attacker can find a load which with this address happens to point to secret; data, then they can reach it. However, the loader and base libraries can also; simply refuse to map the heap, data segments, or stack within 2gb of any of the; text in the program, much like it can reserve the low 2gb of address space. ###### The flag registers again make everything hard. Unfortunately, the technique of using `orq`-instructions has a serious flaw on; x86. The very thing that makes it easy to accumulate state, the flag registers; containing predicates, causes serious problems here because they may be alive; and used by the loading instruction or subsequent instructions. On x86, the; `orq` instruction **sets** the flags and will override anything already there.; This makes inserting them into the instruction stream very hazardous.; Unfortunately, unlike when hardening the loaded value, we have no fallback here; and so we must have a fully general approach available. The first thing we must do when generating these sequences is try to analyze; the surrounding code to prove that the flags are not in fact alive or being; used. Typically, it has been set by some other instruction which just happens; to s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:31010,simpl,simply,31010,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['simpl'],['simply']
Usability,"ds the precedence for each binary operator that is; /// defined.; static std::map<char, int> BinopPrecedence;. /// GetTokPrecedence - Get the precedence of the pending binary operator token.; static int GetTokPrecedence() {; if (!isascii(CurTok)); return -1;. // Make sure it's a declared binop.; int TokPrec = BinopPrecedence[CurTok];; if (TokPrec <= 0) return -1;; return TokPrec;; }. int main() {; // Install standard binary operators.; // 1 is lowest precedence.; BinopPrecedence['<'] = 10;; BinopPrecedence['+'] = 20;; BinopPrecedence['-'] = 20;; BinopPrecedence['*'] = 40; // highest.; ...; }. For the basic form of Kaleidoscope, we will only support 4 binary; operators (this can obviously be extended by you, our brave and intrepid; reader). The ``GetTokPrecedence`` function returns the precedence for; the current token, or -1 if the token is not a binary operator. Having a; map makes it easy to add new operators and makes it clear that the; algorithm doesn't depend on the specific operators involved, but it; would be easy enough to eliminate the map and do the comparisons in the; ``GetTokPrecedence`` function. (Or just use a fixed-size array). With the helper above defined, we can now start parsing binary; expressions. The basic idea of operator precedence parsing is to break; down an expression with potentially ambiguous binary operators into; pieces. Consider, for example, the expression ""a+b+(c+d)\*e\*f+g"".; Operator precedence parsing considers this as a stream of primary; expressions separated by binary operators. As such, it will first parse; the leading primary expression ""a"", then it will see the pairs [+, b]; [+, (c+d)] [\*, e] [\*, f] and [+, g]. Note that because parentheses are; primary expressions, the binary expression parser doesn't need to worry; about nested subexpressions like (c+d) at all. To start, an expression is a primary expression potentially followed by; a sequence of [binop,primaryexpr] pairs:. .. code-block:: c++. /// expression; /// ::= pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:13747,clear,clear,13747,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['clear'],['clear']
Usability,"duction guide declarations; that have an explicit specifier if this explicit specifier is resolved to; true. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.; cxxConversionDecl(isExplicit()) will match #4, but not #3.; cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. Matcher<CXXConstructorDecl>isInheritingConstructor. Matcher<CXXConstructorDecl>isMoveConstructor; Matches constructor declarations that are move constructors. Given; struct S {; S(); // #1; S(const S &); // #2; S(S &&); // #3; };; cxxConstructorDecl(isMoveConstructor()) will match #3, but not #1 or #2. Matcher<CXXConversionDecl>isExplicit; Matches constructor, conversion function, and deduction guide declarations; that have an explicit specifier if this explicit specifier is resolved to; true. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.; cxxConversionDecl(isExplicit()) will match #4, but not #3.; cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. Matcher<CXXCtorInitializer>isBaseInitializer; Matches a constructor initializer if it is initializing a base, as; opposed to a member. Given; struct B {};; struct D : B {; int I;; D(int i) : I(i) {}; };; struct E : B {; E() : B() {}; };; cxxConstructorDecl(hasAnyConstructorInitializer(isBaseInitializer())); will match E(), but not match D(int). Matcher<CXXCtorInitializer>isMemberInitializer; Matches a constr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:62228,guid,guide,62228,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['guid'],['guide']
Usability,"e **curl** program since only curl correctly implements such authentication method. The command will look like:. ```bash; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; ```. ### Objects data access in JSON format. Request `root.json` implemented with [TBufferJSON](https://root.cern/doc/master/classTBufferJSON.html) class. TBufferJSON generates such object representation, which could be directly used in [JSROOT](https://root.cern/js/) for drawing. `root.json` request returns either complete object or just object member like:. ```bash; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; ```. The result will be: `""title""`. For the `root.json` request one could specify the 'compact' parameter, which allow to reduce the number of spaces and new lines without data lost. This parameter can have values from '0' (no compression) till '3' (no spaces and new lines at all).; In addition, one can use simple compression algorithm for big arrays. If compact='10', zero values in the begin and at the end; of the array will be excluded. If compact='20', similar values or large zero gaps in-between will be compressed. Such array; compression support in JSROOT from version 4.8.2. Usage of `root.json` request is about as efficient as binary `root.bin` request. Comparison of different request methods with TH2 histogram from hsimple.C shown in the table:. | Request | Size |; | :---------------------- | :--------- |; | root.bin | 7672 bytes |; | root.bin.gz | 1582 bytes |; | root.json | 8570 bytes |; | root.json?compact=3 | 6004 bytes |; | root.json?compact=23 | 5216 bytes |; | root.json.gz?compact=23 | 1855 bytes |. One should remember that JSON representation always includes names of the data fields which are not present in the binary representation. Even then the size difference is negligible. `root.json` used in JSROOT to request objects from THttpServer. ### Generating images out of objects. For ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:17218,simpl,simple,17218,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['simpl'],['simple']
Usability,"e *G* was used we; also have alias to *F*. 4. Set *F* linkage to private. Make it strong :-). No global aliases, replaceDirectCallers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; If global aliases are not supported. We call ``replaceDirectCallers``. Just; go through all calls of *G* and replace it with calls of *F*. If you look into; the method you will see that it scans all uses of *G* too, and if use is callee; (if user is call instruction and *G* is used as what to be called), we replace; it with use of *F*. If “F” could not be overridden, fix it!; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". We call ``writeThunkOrAlias(Function *F, Function *G)``. Here we try to replace; *G* with alias to *F* first. The next conditions are essential:. * target should support global aliases,; * the address itself of *G* should be not significant, not named and not; referenced anywhere,; * function should come with external, local or weak linkage. Otherwise we write thunk: some wrapper that has *G's* interface and calls *F*,; so *G* could be replaced with this wrapper. *writeAlias*. As follows from *llvm* reference:. “Aliases act as *second name* for the aliasee value”. So we just want to create; a second name for *F* and use it instead of *G*:. 1. create global alias itself (*GA*),. 2. adjust alignment of *F* so it must be maximum of current and *G's* alignment;. 3. replace uses of *G*:. 3.1. first mark all callers of *G* as to-be-analyzed-again, using; ``removeUsers`` method (see chapter above),. 3.2. call ``G->replaceAllUsesWith(GA)``. 4. Get rid of *G*. *writeThunk*. As it written in method comments:. “Replace G with a simple tail call to bitcast(F). Also replace direct uses of G; with bitcast(F). Deletes G.”. In general it does the same as usual when we want to replace callee, except the; first point:. 1. We generate tail call wrapper around *F*, but with interface that allows use; it instead of *G*. 2. “As-usual”: ``removeUsers`` and ``replaceAllUsesWith`` then. 3. Get rid of *G*. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:30967,simpl,simple,30967,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['simpl'],['simple']
Usability,"e `RooFitLegacy/RooCatTypeLegacy.h`.; - The `RooAbsString` that was only an alias for `RooStringVar` got removed.; - The `RooDataWeightedAverage` is now deprecated and will be removed in 6.32. It was only supposed to be an implementation detail of RooFits plotting that is now not necessary anymore.; - The `RooSpan` class was removed and its place in the implementation details of RooFit is now taken by `std::span`.; - The `RooAbsArg::isCloneOf()` and `RooAbsArg::getCloningAncestors()` member functions were removed because they didn't work (always returned `false` and an empty list respectively); - `ROOT::Math::KelvinFunctions` had an incompatible license and needed to be removed without deprecation.; - The use of `ROOT_GIT_BRANCH` and `ROOT_GIT_COMMIT` have been deprecated in favor of parsing `etc/gitinfo.txt`. This later file is now generated as part of the build of ROOT; `RGitCommit.h` (defining `ROOT_GIT_BRANCH` and `ROOT_GIT_COMMIT`) is not updated anymore. This simplifies ROOT's build and release procedure. ## Core Libraries. - Increase thread-safety in parts of core libraries (TCling, TClingMethodInfo, TClingTypeInfo, TFunction) to allow for parallel workflows using RDataFrame in multiple C++ `std::thread`s. ## I/O Libraries. - Improve parsing of input argument to `TChain::Add`. Now it supports the case of globbing files while also using the `?#` token to specify the tree name. ## RDataFrame; - instead of returning nothing, `ROOT::RDF::RunGraphs` now returns the number of separate computation graphs that have been run. - Introduce [`ProgressBar`](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#progressbar) feature that can be added to any RDataFrame program. - The `RDatasetSpec` class and its users now employ the concept of 'sample' rather than the original naming 'group' for groups of files with associated metadata. - `df106_HiggsToFourLeptons` tutorials (both python and C++) now showcase the `ProgressBar`. They now use `FromSpec` to define multiple ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:4417,simpl,simplifies,4417,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['simpl'],['simplifies']
Usability,"e a token value produced by; '``llvm.coro.end.results``' intrinsic. Only none token is allowed for coro.end calls in unwind sections. Semantics:; """"""""""""""""""""; The purpose of this intrinsic is to allow frontends to mark the cleanup and; other code that is only relevant during the initial invocation of the coroutine; and should not be present in resume and destroy parts. In returned-continuation lowering, ``llvm.coro.end`` fully destroys the; coroutine frame. If the second argument is `false`, it also returns from; the coroutine with a null continuation pointer, and the next instruction; will be unreachable. If the second argument is `true`, it falls through; so that the following logic can resume unwinding. In a yield-once; coroutine, reaching a non-unwind ``llvm.coro.end`` without having first; reached a ``llvm.coro.suspend.retcon`` has undefined behavior. The remainder of this section describes the behavior under switched-resume; lowering. This intrinsic is lowered when a coroutine is split into; the start, resume and destroy parts. In the start part, it is a no-op,; in resume and destroy parts, it is replaced with `ret void` instruction and; the rest of the block containing `coro.end` instruction is discarded.; In landing pads it is replaced with an appropriate instruction to unwind to; caller. The handling of coro.end differs depending on whether the target is; using landingpad or WinEH exception model. For landingpad based exception model, it is expected that frontend uses the; `coro.end`_ intrinsic as follows:. .. code-block:: llvm. ehcleanup:; %InResumePart = call i1 @llvm.coro.end(ptr null, i1 true, token none); br i1 %InResumePart, label %eh.resume, label %cleanup.cont. cleanup.cont:; ; rest of the cleanup. eh.resume:; %exn = load ptr, ptr %exn.slot, align 8; %sel = load i32, ptr %ehselector.slot, align 4; %lpad.val = insertvalue { ptr, i32 } undef, ptr %exn, 0; %lpad.val29 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1; resume { ptr, i32 } %lpad.val29. The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:44233,resume,resume,44233,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"e a virtual method one is involved; (instead of having C++ hide it for you behind ""syntactic sugar""). > And the old array syntax:; > type [ int, int, ...]; > is just much more familiar and clear to people than anything new you; > introduce, no matter how logical it is. . Erm... excuse me but how is this the ""old array syntax""? If you are; arguing for consistency with C, you should be asking for 'type int []',; which is significantly different than the above (beside the above; introduces a new operator and duplicates information; needlessly). Basically what I am suggesting is exactly the above without; the fluff. So instead of:. type [ int, int, ...]. you use:. type [ int ]. > Introducing a new syntax that may; > make function pointers easier but makes arrays much more difficult seems; > very risky to me. This is not about function pointers. This is about consistency in the; type system, and consistency with the rest of the language. The point; above does not make arrays any more difficult to use, and makes the; structure of types much more obvious than the ""c way"". > > In my opinion, it is critically important to have clear and concise type; > > specifications, because types are going to be all over the programs.; > ; > I absolutely agree. But the question is, what is more clear and concise?; > The syntax programmers are used to out of years of experience or a new; > syntax that they have never seen that has a more logical structure. I think; > the answer is the former. Sometimes, you have to give up a better idea; > because you can't overcome sociological barriers to it. Qwerty keyboards; > and Windows are two classic examples of bad technology that are difficult to; > root out. Very true, but you seem to be advocating a completely different Type; system than C has, in addition to it not offering the advantages of clear; structure that the system I recommended does... so you seem to not have a; problem with changing this, just with what I change it to. :). -Chris. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt:3521,clear,clear,3521,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt,3,['clear'],['clear']
Usability,"e above, the analyzer has detected that the body of; the loop is never entered for the case where length <= 0. In this; particular example, you may know that the loop will always be entered because; the input parameter length will be greater than zero in all calls to this; function. You can teach the analyzer facts about your code as well as document; it by using assertions. By adding assert(length > 0) in the beginning; of the function, you tell the analyzer that your code is never expecting a zero; or a negative value, so it won't need to test the correctness of those paths. int foo(int length) {; int x = 0;; assert(length > 0);; for (int i = 0; i < length; i++); x += 1;; return length/x;; }. Q: How can I suppress a specific analyzer warning?; When you encounter an analyzer bug/false positive, check if it's one of the; issues discussed above or if the analyzer; annotations can; resolve the issue by helping the static analyzer understand the code better.; Second, please report it to help us improve; user experience.; Sometimes there's really no ""good"" way to eliminate the issue. In such cases; you can ""silence"" it directly by annotating the problematic line of code with; the help of Clang attribute 'suppress':. int foo() {; int *x = nullptr;; ...; [[clang::suppress]] {; // all warnings in this scope are suppressed; int y = *x;; }. // null pointer dereference warning suppressed on the next line; [[clang::suppress]]; return *x; }. int bar(bool coin_flip) {; // suppress all memory leak warnings about this allocation; [[clang::suppress]]; int *result = (int *)malloc(sizeof(int));. if (coin_flip); return 0; // including this leak path. return *result; // as well as this leak path; }. You can also consider using __clang_analyzer__ macro; described below.; Q: How can I selectively exclude code the analyzer examines?; When the static analyzer is using clang to parse source files, it implicitly; defines the preprocessor macro __clang_analyzer__. One can use this; macro to se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html:8352,user experience,user experience,8352,interpreter/llvm-project/clang/www/analyzer/faq.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html,1,['user experience'],['user experience']
Usability,"e and Building; --------------------------. Finally, if you're using your platform compiler, run:. .. code-block:: bash. $ cmake -G Ninja <source-dir> -DCMAKE_BUILD_TYPE=<type> <options above>. If you're using Clang as the cross-compiler, run:. .. code-block:: bash. $ CC='clang' CXX='clang++' cmake -G Ninja <source-dir> -DCMAKE_BUILD_TYPE=<type> <options above>. If you have ``clang``/``clang++`` on the path, it should just work, and special; Ninja files will be created in the build directory. I strongly suggest; you to run ``cmake`` on a separate build directory, *not* inside the; source tree. To build, simply type:. .. code-block:: bash. $ ninja. It should automatically find out how many cores you have, what are; the rules that needs building and will build the whole thing. You can't run ``ninja check-all`` on this tree because the created; binaries are targeted to ARM, not x86_64. Installing and Using; --------------------. After the LLVM/Clang has built successfully, you should install it; via:. .. code-block:: bash. $ ninja install. which will create a sysroot on the install-dir. You can then tar; that directory into a binary with the full triple name (for easy; identification), like:. .. code-block:: bash. $ ln -sf <install-dir> arm-linux-gnueabihf-clang; $ tar zchf arm-linux-gnueabihf-clang.tar.gz arm-linux-gnueabihf-clang. If you copy that tarball to your target board, you'll be able to use; it for running the test-suite, for example. Follow the guidelines at; https://llvm.org/docs/lnt/quickstart.html, unpack the tarball in the; test directory, and use options:. .. code-block:: bash. $ ./sandbox/bin/python sandbox/bin/lnt runtest nt \; --sandbox sandbox \; --test-suite `pwd`/test-suite \; --cc `pwd`/arm-linux-gnueabihf-clang/bin/clang \; --cxx `pwd`/arm-linux-gnueabihf-clang/bin/clang++. Remember to add the ``-jN`` options to ``lnt`` to the number of CPUs; on your board. Also, the path to your clang has to be absolute, so; you'll need the `pwd` trick above.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst:7599,guid,guidelines,7599,interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,1,['guid'],['guidelines']
Usability,"e any continuous; function. 2- Trained with `output=1` for the signal and 0 for the background,; the approximated function of inputs `X` is the probability of signal,; knowing `X`. ### Learning Methods. The aim of all learning methods is to minimize the total error on a; set of weighted examples. The error is defined as the sum in quadrate,; divided by two, of the error on each individual output neuron. In all; methods implemented in this library, one needs to compute the first; derivative of that error with respect to the weights. Exploiting the; well-known properties of the derivative, one can express this; derivative as the product of the local partial derivative by the; weighted sum of the outputs derivatives (for a neuron) or as the; product of the input value with the local partial derivative of the; output neuron (for a synapse). This computation is called; ""back-propagation of the errors"". Six learning methods are; implemented. #### Stochastic Minimization. This is the most trivial learning method. The Robbins-Monro stochastic; approximation is applied to multilayer perceptrons. The weights are; updated after each example according to the formula:. $$; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); $$. with:. $$; \Delta w_{ij}(t) = - \eta \left(; \frac{\partial e_p}{\partial w_{ij}} + \delta \right) +; \epsilon \Delta w_{ij}(t-1); $$. The parameters for this method are `Eta`, `EtaDecay`, `Delta` and; `Epsilon`. #### Steepest Descent With Fixed Step Size (Batch Learning). It is the same as the stochastic minimization, but the weights are; updated after considering all the examples, with the total derivative; `dEdw`. The parameters for this method are `Eta`, `EtaDecay`, `Delta`; and `Epsilon`. #### Steepest Descent Algorithm. Weights are set to the minimum along the line defined by the gradient.; The only parameter for this method is `Tau`. Lower `Tau` = higher; precision = slower search. A value `Tau=3` seems reasonable. #### Conjugate Gradients With the Polak-R",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:72204,learn,learning,72204,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['learn'],['learning']
Usability,"e been solved. Step #3: Write Access Move; --------------------------. 9. Collect developers' GitHub account information, and add them to the project.; 10. Switch the SVN repository to read-only and allow pushes to the GitHub repository.; 11. Update the documentation.; 12. Mirror Git to SVN. Step #4 : Post Move; -------------------. 13. Archive the SVN repository.; 14. Update links on the LLVM website pointing to viewvc/klaus/phab etc. to; point to GitHub instead. GitHub Repository Description; =============================. Monorepo; ----------------. The LLVM git repository hosted at https://github.com/llvm/llvm-project contains all; sub-projects in a single source tree. It is often referred to as a monorepo and; mimics an export of the current SVN repository, with each sub-project having its; own top-level directory. Not all sub-projects are used for building toolchains.; For example, www/ and test-suite/ are not part of the monorepo. Putting all sub-projects in a single checkout makes cross-project refactoring; naturally simple:. * New sub-projects can be trivially split out for better reuse and/or layering; (e.g., to allow libSupport and/or LIT to be used by runtimes without adding a; dependency on LLVM).; * Changing an API in LLVM and upgrading the sub-projects will always be done in; a single commit, designing away a common source of temporary build breakage.; * Moving code across sub-project (during refactoring for instance) in a single; commit enables accurate `git blame` when tracking code change history.; * Tooling based on `git grep` works natively across sub-projects, allowing to; easier find refactoring opportunities across projects (for example reusing a; datastructure initially in LLDB by moving it into libSupport).; * Having all the sources present encourages maintaining the other sub-projects; when changing API. Finally, the monorepo maintains the property of the existing SVN repository that; the sub-projects move synchronously, and a single revisi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:8910,simpl,simple,8910,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['simpl'],['simple']
Usability,"e call will; be preceded by a runtime type check, which validates that the call target is; prefixed with a :ref:`type identifier<md_kcfi_type>` that matches the operand; bundle attribute. For example:. .. code-block:: llvm. call void %0() [""kcfi""(i32 1234)]. Clang emits KCFI operand bundles and the necessary metadata with; ``-fsanitize=kcfi``. .. _convergencectrl:. Convergence Control Operand Bundles; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A ""convergencectrl"" operand bundle is only valid on a ``convergent`` operation.; When present, the operand bundle must contain exactly one value of token type.; See the :doc:`ConvergentOperations` document for details. .. _moduleasm:. Module-Level Inline Assembly; ----------------------------. Modules may contain ""module-level inline asm"" blocks, which corresponds; to the GCC ""file scope inline asm"" blocks. These blocks are internally; concatenated by LLVM and treated as a single unit, but may be separated; in the ``.ll`` file if desired. The syntax is very simple:. .. code-block:: llvm. module asm ""inline asm code goes here""; module asm ""more can go here"". The strings can contain any character by escaping non-printable; characters. The escape sequence used is simply ""\\xx"" where ""xx"" is the; two digit hex code for the number. Note that the assembly string *must* be parseable by LLVM's integrated assembler; (unless it is disabled), even when emitting a ``.s`` file. .. _langref_datalayout:. Data Layout; -----------. A module may specify a target specific data layout string that specifies; how data is to be laid out in memory. The syntax for the data layout is; simply:. .. code-block:: llvm. target datalayout = ""layout specification"". The *layout specification* consists of a list of specifications; separated by the minus sign character ('-'). Each specification starts; with a letter and may include other information after the letter to; define some aspect of the data layout. The specifications accepted are; as follows:. ``E``; Specifi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:130478,simpl,simple,130478,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['simpl'],['simple']
Usability,"e came to the same; > conclusion I do: that you have to go with familiar syntax over logical; > syntax because familiarity is such a strong force:; > ""However, familiarity is a strong force. To compare, in English, we; live; > more or less happily with the absurd rules for ""to be"" (am, are, is, been,; > was, were, ...) and all attempts to simplify are treated with contempt or; > (preferably) humor. It be a curious world and it always beed."". Although you have to remember that his situation was considerably; different than ours. He was in a position where he was designing a high; level language that had to be COMPATIBLE with C. Our language is such; that a new person would have to learn the new, different, syntax; anyways. Making them learn about the type system does not seem like much; of a stretch from learning the opcodes and how SSA form works, and how; everything ties together... > > Basically, my argument for this type construction system is that it is; > > VERY simple to use and understand (although it IS different than C, it is; > > very simple and straightforward, which C is NOT). In fact, I would assert; > > that most programmers TODAY do not understand pointers to member; > > functions, and have to look up an example when they have to write them. > Again, I don't disagree with this at all. But to some extent this; > particular problem is inherently difficult. Your syntax for the above; > example may be easier for you to read because this is the way you have been; > thinking about it. Honestly, I don't find it much easier than the C syntax.; > In either case, I would have to look up an example to write pointers to; > member functions. I would argue that because the lexical structure of the language is self; consistent, any person who spent a significant amount of time programming; in LLVM directly would understand how to do it without looking it up in a; manual. The reason this does not work for C is because you rarely have to; declare these pointers, and th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt:1039,simpl,simple,1039,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt,2,['simpl'],['simple']
Usability,"e diagnostic is expected to occur a minimum number of times, this can; be specified by appending a ``+`` to the number. For example:. .. code-block:: c++. void f(); // expected-note 0+ {{previous declaration is here}}; void g(); // expected-note 1+ {{previous declaration is here}}. In the first example, the diagnostic becomes optional, i.e. it will be; swallowed if it occurs, but will not generate an error if it does not occur. In; the second example, the diagnostic must occur at least once. As a short-hand,; ""one or more"" can be specified simply by ``+``. For example:. .. code-block:: c++. void g(); // expected-note + {{previous declaration is here}}. A range can also be specified by ``<n>-<m>``. For example:. .. code-block:: c++. void f(); // expected-note 0-1 {{previous declaration is here}}. In this example, the diagnostic may appear only once, if at all. .. _DiagnosticMatching:. Matching Modes; ~~~~~~~~~~~~~~. The default matching mode is simple string, which looks for the expected text; that appears between the first `{{` and `}}` pair of the comment. The string is; interpreted just as-is, with one exception: the sequence `\n` is converted to a; single newline character. This mode matches the emitted diagnostic when the; text appears as a substring at any position of the emitted message. To enable matching against desired strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:160881,simpl,simple,160881,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['simpl'],['simple']
Usability,"e equivalent of:. .. code-block:: c++. static task coro_task(int v) {; store v to __int_32_0 in the frame; co_await await_counter{};; a = load __int_32_0; std::cout << a+1 << ""\n"";; std::cout << a+2 << ""\n"";; std::cout << a+3 << ""\n"";; co_await await_counter{};; a = load __int_32_0; std::cout << a+4 << ""\n"";; std::cout << a+5 << ""\n"";; }. It should now be obvious why the value of `__int_32_0` remains unchanged; throughout the function. It is important to recognize that `__int_32_0`; does not directly correspond to `a`, but is instead a variable generated; to assist the compiler in code generation. The variables in an optimized; coroutine frame should not be thought of as directly representing the; variables in the C++ source. Get the suspended points; ========================. An important requirement for debugging coroutines is to understand suspended; points, which are where the coroutine is currently suspended and awaiting. For simple cases like the above, inspecting the value of the `__coro_index`; variable in the coroutine frame works well. However, it is not quite so simple in really complex situations. In these; cases, it is necessary to use the coroutine libraries to insert the; line-number. For example:. .. code-block:: c++. // For all the promise_type we want:; class promise_type {; ...; + unsigned line_number = 0xffffffff;; };. #include <source_location>. // For all the awaiter types we need:; class awaiter {; ...; template <typename Promise>; void await_suspend(std::coroutine_handle<Promise> handle,; std::source_location sl = std::source_location::current()) {; ...; handle.promise().line_number = sl.line();; }; };. In this case, we use `std::source_location` to store the line number of the; await inside the `promise_type`. Since we can locate the coroutine function; from the address of the coroutine, we can identify suspended points this way; as well. The downside here is that this comes at the price of additional runtime cost.; This is consistent with th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:10660,simpl,simple,10660,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['simpl'],['simple']
Usability,"e final executable file when the program is linked. 2. It is also used by *llvm-cov* - the mapping information is extracted from an; object file and is used to associate the execution counts (the values of the; profile instrumentation counters), and the source ranges in a file.; After that, the tool is able to generate various code coverage reports; for the program. The coverage mapping format aims to be a ""universal format"" that would be; suitable for usage by any frontend, and not just by Clang. It also aims to; provide the frontend the possibility of generating the minimal coverage mapping; data in order to reduce the size of the IR and object files - for example,; instead of emitting mapping information for each statement in a function, the; frontend is allowed to group the statements with the same execution count into; regions of code, and emit the mapping information only for those regions. Advanced Concepts; =================. The remainder of this guide is meant to give you insight into the way the; coverage mapping format works. The coverage mapping format operates on a per-function level as the; profile instrumentation counters are associated with a specific function.; For each function that requires code coverage, the frontend has to create; coverage mapping data that can map between the source code ranges and; the profile instrumentation counters for that function. Mapping Region; --------------. The function's coverage mapping data contains an array of mapping regions.; A mapping region stores the `source code range`_ that is covered by this region,; the `file id <coverage file id_>`_, the `coverage mapping counter`_ and; the region's kind.; There are several kinds of mapping regions:. * Code regions associate portions of source code and `coverage mapping; counters`_. They make up the majority of the mapping regions. They are used; by the code coverage tool to compute the execution counts for lines,; highlight the regions of code that were never execute",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst:2885,guid,guide,2885,interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst,1,['guid'],['guide']
Usability,"e final side-effecting node in the token chain. For example, in a single basic; block function it would be the return node. One important concept for SelectionDAGs is the notion of a ""legal"" vs.; ""illegal"" DAG. A legal DAG for a target is one that only uses supported; operations and supported types. On a 32-bit PowerPC, for example, a DAG with a; value of type i1, i8, i16, or i64 would be illegal, as would a DAG that uses a; SREM or UREM operation. The `legalize types`_ and `legalize operations`_ phases; are responsible for turning an illegal DAG into a legal DAG. .. _SelectionDAG-Process:. SelectionDAG Instruction Selection Process; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SelectionDAG-based instruction selection consists of the following steps:. #. `Build initial DAG`_ --- This stage performs a simple translation from the; input LLVM code to an illegal SelectionDAG. #. `Optimize SelectionDAG`_ --- This stage performs simple optimizations on the; SelectionDAG to simplify it, and recognize meta instructions (like rotates; and ``div``/``rem`` pairs) for targets that support these meta operations.; This makes the resultant code more efficient and the `select instructions; from DAG`_ phase (below) simpler. #. `Legalize SelectionDAG Types`_ --- This stage transforms SelectionDAG nodes; to eliminate any types that are unsupported on the target. #. `Optimize SelectionDAG`_ --- The SelectionDAG optimizer is run to clean up; redundancies exposed by type legalization. #. `Legalize SelectionDAG Ops`_ --- This stage transforms SelectionDAG nodes to; eliminate any operations that are unsupported on the target. #. `Optimize SelectionDAG`_ --- The SelectionDAG optimizer is run to eliminate; inefficiencies introduced by operation legalization. #. `Select instructions from DAG`_ --- Finally, the target instruction selector; matches the DAG operations to target instructions. This process translates; the target-independent input DAG into another DAG of target instructions. #. `Sele",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:37110,simpl,simple,37110,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,2,['simpl'],"['simple', 'simplify']"
Usability,"e first argument is a token returned by a call to '``llvm.coro.id``'; identifying the coroutine. Semantics:; """""""""""""""""""". A frontend should emit at most one `coro.alloc` intrinsic per coroutine.; The intrinsic is used to suppress dynamic allocation of the coroutine frame; when possible. Example:; """""""""""""""". .. code-block:: llvm. entry:; %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null); %dyn.alloc.required = call i1 @llvm.coro.alloc(token %id); br i1 %dyn.alloc.required, label %coro.alloc, label %coro.begin. coro.alloc:; %frame.size = call i32 @llvm.coro.size(); %alloc = call ptr @MyAlloc(i32 %frame.size); br label %coro.begin. coro.begin:; %phi = phi ptr [ null, %entry ], [ %alloc, %coro.alloc ]; %frame = call ptr @llvm.coro.begin(token %id, ptr %phi). .. _coro.noop:. 'llvm.coro.noop' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.noop(). Overview:; """""""""""""""""". The '``llvm.coro.noop``' intrinsic returns an address of the coroutine frame of; a coroutine that does nothing when resumed or destroyed. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic is lowered to refer to a private constant coroutine frame. The; resume and destroy handlers for this frame are empty functions that do nothing.; Note that in different translation units llvm.coro.noop may return different pointers. .. _coro.frame:. 'llvm.coro.frame' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare ptr @llvm.coro.frame(). Overview:; """""""""""""""""". The '``llvm.coro.frame``' intrinsic returns an address of the coroutine frame of; the enclosing coroutine. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic is lowered to refer to the `coro.begin`_ instruction. This is; a frontend convenience intrinsic that makes it easier to refer to the; coroutine frame. .. _coro.id:. 'llvm.coro.id' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ::. declare token @llvm.coro.id(i32 <align>, ptr <promise>, ptr <coroaddr>,; ptr <f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:36021,resume,resumed,36021,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resumed']
Usability,"e function is split into three functions, representing three; different ways that control can enter the coroutine:. 1. the ramp function that is initially invoked, which takes arbitrary; arguments and returns a pointer to the coroutine object;. 2. a coroutine resume function that is invoked when the coroutine is resumed,; which takes a pointer to the coroutine object and returns `void`;. 3. a coroutine destroy function that is invoked when the coroutine is; destroyed, which takes a pointer to the coroutine object and returns; `void`. Because the resume and destroy functions are shared across all suspend; points, suspend points must store the index of the active suspend in; the coroutine object, and the resume/destroy functions must switch over; that index to get back to the correct point. Hence the name of this; lowering. Pointers to the resume and destroy functions are stored in the coroutine; object at known offsets which are fixed for all coroutines. A completed; coroutine is represented with a null resume function. There is a somewhat complex protocol of intrinsics for allocating and; deallocating the coroutine object. It is complex in order to allow the; allocation to be elided due to inlining. This protocol is discussed; in further detail below. The frontend may generate code to call the coroutine function directly;; this will become a call to the ramp function and will return a pointer; to the coroutine object. The frontend should always resume or destroy; the coroutine using the corresponding intrinsics. Returned-Continuation Lowering; ------------------------------. In returned-continuation lowering, signaled by the use of; `llvm.coro.id.retcon` or `llvm.coro.id.retcon.once`, some aspects of; the ABI must be handled more explicitly by the frontend. In this lowering, every suspend point takes a list of ""yielded values""; which are returned back to the caller along with a function pointer,; called the continuation function. The coroutine is resumed by simply; c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:4749,resume,resume,4749,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['resume'],['resume']
Usability,"e function the; loop is in, and that includes some function analyses the loop analyses depend; on. This discounts future concurrency over separate loops in a function, but; that's a tradeoff due to how tightly a loop and its function are coupled. To; make sure the function analyses that loop passes use are valid, they are; manually updated in the loop passes to ensure that invalidation is not; necessary. There is a set of common function analyses that loop passes and; analyses have access to which is passed into loop passes as a; ``LoopStandardAnalysisResults`` parameter. Other mutable function analyses are; not accessible from loop passes. As with any caching mechanism, we need some way to tell analysis managers; when results are no longer valid. Much of the analysis manager complexity; comes from trying to invalidate as few analysis results as possible to keep; compile times as low as possible. There are two ways to deal with potentially invalid analysis results. One is; to simply force clear the results. This should generally only be used when; the IR that the result is keyed on becomes invalid. For example, a function; is deleted, or a CGSCC has become invalid due to call graph changes. The typical way to invalidate analysis results is for a pass to declare what; types of analyses it preserves and what types it does not. When transforming; IR, a pass either has the option to update analyses alongside the IR; transformation, or tell the analysis manager that analyses are no longer; valid and should be invalidated. If a pass wants to keep some specific; analysis up to date, such as when updating it would be faster than; invalidating and recalculating it, the analysis itself may have methods to; update it for specific transformations, or there may be helper updaters like; ``DomTreeUpdater`` for a ``DominatorTree``. Otherwise to mark some analysis; as no longer valid, the pass can return a ``PreservedAnalyses`` with the; proper analyses invalidated. .. code-block:: c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:11745,simpl,simply,11745,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,2,"['clear', 'simpl']","['clear', 'simply']"
Usability,"e functionally related controls. ![](pictures/02000207.jpg). It is a composite frame with a border and a title. The title explains; the purpose of the group and should be a noun or noun phrase. Here is an; example taken from `guitest.C`:. ``` {.cpp}; groupFrame = new TGGroupFrame(tf,""Options"",kVerticalFrame);; groupFrame->SetTitlePos(TGGroupFrame::kLeft);; ```. The second line sets the title position on the left. You can change it; to be centered or right aligned if you use **`TGGroupFrame::kCenter`** or; `TGGroupFrame::kRight` as a parameter. ![](pictures/02000208.jpg). Be conservative in the use of borders because of the potential for; clutter. Do not place them around single entry fields, single combo; boxes, list boxes and groups of command buttons. The design of these; widgets provides them with a border. The picture above provides kind of; borders to avoid. ## Layout Management. The layout process is an integral part of any GUI. When you create a; simple message window, laying out its few buttons and text widgets is; quite simple. However, this process becomes increasingly difficult if; you have to implement large GUI's with many widgets that should behave; properly when the GUI is resized or uses a different font type or size.; Layout management is the process of determining the size and position of; every widget in a container. A layout manager is an object that performs layout management for the; widgets within a container. You already know that when adding a; component (child widget) to a container (parent widget) you can provide; alignment hints (or rely on the default ones). These hints are used by; the layout manager to correctly position the widgets in the container.; The **`TGLayoutManager`** is an abstract class providing the basic; layout functionality. ![The layout classes hierarchy](pictures/02000209.jpg). The base ""container"" class is **`TGCmpositeFrame`**. You can easily; change the layout manager using the; `SetLayoutManager(TGLayoutManager *l)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:33674,simpl,simple,33674,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,2,['simpl'],['simple']
Usability,"e have to define so many volumes to make an R?"". **A:** Well, in real life some objects have much more complex shapes; that an ""R"". The modeller cannot just know all of them; the idea; is to make a complex object by using elementary building blocks that; have known shapes (called ""primitive shapes""). Gluing these; together in the appropriate way is the user responsibility. **Q:** ""I am getting the global picture but not making much out of it... There; are also a lot of calls to TGeoVolume::AddNode() that I do not understand."". **A:** A volume is positioned inside another one by using this; method. The relative geometrical transformation as well as a copy number; must be specified. When positioned, a volume becomes a ""node"" of; its container and a new object of the class TGeoNode is; automatically created. This method is therefore the key element for the; creation of a hierarchical link between two volumes. As it will be; described further on in this document, there are few other methods; performing similar actions, but let us keep things simple for the time; being. In addition, notice that there are some visualization-related; calls in the example followed by a final TGeoVolume::Draw() call for; the top volume. These are explained in details in the section; ""Visualization Settings and Attributes"". At this point, you will; probably like to see how this geometry looks like. You just need to run; the example and you will get the following picture that you can rotate; using the mouse; or you can zoom / move it around (see what the Help; menu of the GL window displays). ~~~{.cpp}; % root rootgeom.C; ~~~. \image html geometry001.png width=600px. Now let us browse the hierarchy that was just created. Start a browser; and double-click on the item simple1 representing the; `gGeoManager` object. Note that right click opens the context menu; of the manager class where several global methods are available. ~~~{.cpp}; root[] new TBrowser;; ~~~. \image html geometry002.jpg width=",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:10725,simpl,simple,10725,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['simpl'],['simple']
Usability,"e image, such as the triple and architecture. All of these structures are combined to form a single binary blob, the order; does not matter because of the use of absolute offsets. This makes it easier to; extend in the future. As mentioned previously, multiple offloading images are; bundled together by simply concatenating them in this format. Because we have; the magic bytes and size of each image, we can extract them as-needed. Usage; =====. This tool can be used with the following arguments. Generally information is; passed as a key-value pair to the ``image=`` argument. The ``file`` and; ``triple``, arguments are considered mandatory to make a valid image.; The ``arch`` argument is suggested. .. code-block:: console. OVERVIEW: A utility for bundling several object files into a single binary.; The output binary can then be embedded into the host section table; to create a fatbinary containing offloading code. USAGE: clang-offload-packager [options]. OPTIONS:. Generic Options:. --help - Display available options (--help-hidden for more); --help-list - Display list of available options (--help-list-hidden for more); --version - Display the version of this program. clang-offload-packager options:. --image=<<key>=<value>,...> - List of key and value arguments. Required; keywords are 'file' and 'triple'.; -o <file> - Write output to <file>. Example; =======. This tool simply takes many input files from the ``image`` option and creates a; single output file with all the images combined. .. code-block:: console. clang-offload-packager -o out.bin --image=file=input.o,triple=nvptx64,arch=sm_70. The inverse operation can be performed instead by passing the packaged binary as; input. In this mode the matching images will either be placed in the output; specified by the ``file`` option. If no ``file`` argument is provided a name; will be generated for each matching image. .. code-block:: console. clang-offload-packager in.bin --image=file=output.o,triple=nvptx64,arch=sm_70; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst:8510,simpl,simply,8510,interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadPackager.rst,1,['simpl'],['simply']
Usability,"e instruction after *inst; if (it != inst->getParent()->end()) errs() << *it << ""\n"";; }. .. _iterate_complex:. Finding call sites: a slightly more complex example; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Say that you're writing a FunctionPass and would like to count all the locations; in the entire module (that is, across every ``Function``) where a certain; function (i.e., some ``Function *``) is already in scope. As you'll learn; later, you may want to use an ``InstVisitor`` to accomplish this in a much more; straight-forward manner, but this example will allow us to explore how you'd do; it if you didn't have ``InstVisitor`` around. In pseudo-code, this is what we; want to do:. .. code-block:: none. initialize callCounter to zero; for each Function f in the Module; for each BasicBlock b in f; for each Instruction i in b; if (i a Call and calls the given function); increment callCounter. And the actual code is (remember, because we're writing a ``FunctionPass``, our; ``FunctionPass``-derived class simply has to override the ``runOnFunction``; method):. .. code-block:: c++. Function* targetFunc = ...;. class OurFunctionPass : public FunctionPass {; public:; OurFunctionPass(): callCounter(0) { }. virtual runOnFunction(Function& F) {; for (BasicBlock &B : F) {; for (Instruction &I: B) {; if (auto *CB = dyn_cast<CallBase>(&I)) {; // We know we've encountered some kind of call instruction (call,; // invoke, or callbr), so we need to determine if it's a call to; // the function pointed to by m_func or not.; if (CB->getCalledFunction() == targetFunc); ++callCounter;; }; }; }; }. private:; unsigned callCounter;; };. .. _iterate_chains:. Iterating over def-use & use-def chains; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Frequently, we might have an instance of the ``Value`` class (`doxygen; <https://llvm.org/doxygen/classllvm_1_1Value.html>`__) and we want to determine; which ``User``\ s use the ``Value``. The list of all ``User``\ s of a particular; ``Value`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:110223,simpl,simply,110223,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simply']
Usability,"e it into a (hopefully) more optimized but semantically; equivalent form. In the original tutorial series the FunctionPassManager was; created outside the KaleidoscopeJIT and modules were optimized before being; added to it. In this Chapter we will make optimization a phase of our JIT; instead. For now this will provide us a motivation to learn more about ORC; layers, but in the long term making optimization part of our JIT will yield an; important benefit: When we begin lazily compiling code (i.e. deferring; compilation of each function until the first time it's run) having; optimization managed by our JIT will allow us to optimize lazily too, rather; than having to do all our optimization up-front. To add optimization support to our JIT we will take the KaleidoscopeJIT from; Chapter 1 and compose an ORC *IRTransformLayer* on top. We will look at how the; IRTransformLayer works in more detail below, but the interface is simple: the; constructor for this layer takes a reference to the execution session and the; layer below (as all layers do) plus an *IR optimization function* that it will; apply to each Module that is added via addModule:. .. code-block:: c++. class KaleidoscopeJIT {; private:; ExecutionSession ES;; RTDyldObjectLinkingLayer ObjectLayer;; IRCompileLayer CompileLayer;; IRTransformLayer TransformLayer;. DataLayout DL;; MangleAndInterner Mangle;; ThreadSafeContext Ctx;. public:. KaleidoscopeJIT(JITTargetMachineBuilder JTMB, DataLayout DL); : ObjectLayer(ES,; []() { return std::make_unique<SectionMemoryManager>(); }),; CompileLayer(ES, ObjectLayer, ConcurrentIRCompiler(std::move(JTMB))),; TransformLayer(ES, CompileLayer, optimizeModule),; DL(std::move(DL)), Mangle(ES, this->DL),; Ctx(std::make_unique<LLVMContext>()) {; ES.getMainJITDylib().addGenerator(; cantFail(DynamicLibrarySearchGenerator::GetForCurrentProcess(DL.getGlobalPrefix())));; }. Our extended KaleidoscopeJIT class starts out the same as it did in Chapter 1,; but after the CompileLayer we int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:2705,simpl,simple,2705,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['simpl'],['simple']
Usability,"e left with the original AST. .. code-block:: bash. ERROR: NameConflict; TranslationUnitDecl 0xe54a48 <<invalid sloc>> <invalid sloc>; |-ClassTemplateDecl 0xe91020 <to.cc:3:7, line:4:17> col:14 X; | |-TemplateTypeParmDecl 0xe90ed0 <line:3:17, col:26> col:26 typename depth 0 index 0 T; | |-CXXRecordDecl 0xe90f90 <line:4:7, col:17> col:14 struct X definition; | | |-DefinitionData empty aggregate standard_layout trivially_copyable pod trivial literal has_constexpr_non_copy_move_ctor can_const_default_init; | | | |-DefaultConstructor exists trivial constexpr needs_implicit defaulted_is_constexpr; | | | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveConstructor exists simple trivial needs_implicit; | | | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | | | |-MoveAssignment exists simple trivial needs_implicit; | | | `-Destructor simple irrelevant trivial needs_implicit; | | `-CXXRecordDecl 0xe91270 <col:7, col:14> col:14 implicit struct X; | `-ClassTemplateSpecialization 0xe91340 'X'; `-ClassTemplateSpecializationDecl 0xe91340 <line:6:7, line:7:30> col:14 struct X definition; |-DefinitionData pass_in_registers aggregate standard_layout trivially_copyable pod trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-TemplateArgument type 'int'; |-CXXRecordDecl 0xe91558 <col:7, col:14> col:14 implicit struct X; `-FieldDecl 0xe91600 <col:23, col:27> col:27 i 'int'. Error propagation; """""""""""""""""""""""""""""""""". If there is a dependent node we have to import before we could import a given node then the import error associated to the depend",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:14015,simpl,simple,14015,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,8,['simpl'],['simple']
Usability,"e mechanism that; allows one file to include the content of another file (see `Include; Files`_). This allows large files to be broken up into smaller ones, and; also provides a simple library mechanism where multiple source files can; include the same library file. TableGen supports a simple preprocessor that can be used to conditionalize; portions of ``.td`` files. See `Preprocessing Facilities`_ for more; information. Lexical Analysis; ================. The lexical and syntax notation used here is intended to imitate; `Python's`_ notation. In particular, for lexical definitions, the productions; operate at the character level and there is no implied whitespace between; elements. The syntax definitions operate at the token level, so there is; implied whitespace between tokens. .. _`Python's`: http://docs.python.org/py3k/reference/introduction.html#notation. TableGen supports BCPL-style comments (``// ...``) and nestable C-style; comments (``/* ... */``).; TableGen also provides simple `Preprocessing Facilities`_. Formfeed characters may be used freely in files to produce page breaks when; the file is printed for review. The following are the basic punctuation tokens::. - + [ ] { } ( ) < > : ; . ... = ? #. Literals; --------. Numeric literals take one of the following forms:. .. productionlist::; TokInteger: `DecimalInteger` | `HexInteger` | `BinInteger`; DecimalInteger: [""+"" | ""-""] (""0""...""9"")+; HexInteger: ""0x"" (""0""...""9"" | ""a""...""f"" | ""A""...""F"")+; BinInteger: ""0b"" (""0"" | ""1"")+. Observe that the :token:`DecimalInteger` token includes the optional ``+``; or ``-`` sign, unlike most languages where the sign would be treated as a; unary operator. TableGen has two kinds of string literals:. .. productionlist::; TokString: '""' (non-'""' characters and escapes) '""'; TokCode: ""[{"" (shortest text not containing ""}]"") ""}]"". A :token:`TokCode` is nothing more than a multi-line string literal; delimited by ``[{`` and ``}]``. It can break across lines and the; line breaks are ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:6972,simpl,simple,6972,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['simpl'],['simple']
Usability,"e must not impose an undue; burden on maintaining other components (core or peripheral). Warnings; --------. There are multiple types of issues that might trigger a request for deprecation,; including (but not limited to):. * Changes in a component consistently break other areas of the project.; * Components go broken for long periods of time (weeks or more).; * Clearly superior alternatives are in use and maintenance is painful.; * Builds and tests are harder / take longer, increasing the cost of; maintenance, overtaking the perceived benefits. If the maintenance cost is higher than it is acceptable by the majority of; developers, it means that either the sub-community is too small (and the extra; cost should be paid locally), or not active enough (and the problems won't be; fixed any time soon). In either case, removal of such problematic component is; justified. Steps for removal; -----------------. However clear the needs for removal are, we should take an incremental approach; to deprecating code, especially when there's still a sub-community that cares; about it. In that sense, code will never be removed outright without a series; of steps are taken. A minimum set of steps should be:; #. A proposal for removal / deactivation should be made to the Discourse forums ; (under the appropriate category), with a clear; statement of the maintenance costs imposed and the alternatives, if; applicable.; #. There must be enough consensus on the list that removal is warranted, and no; pending proposals to fix the situation from a sub-community.; #. An announcement for removal must be made on the same lists, with ample time; for downstream users to take action on their local infrastructure. The time; will depend on what is being removed. #. If a script or documents are to be removed, they can always be pulled; from previous revision, and can be removed within days.; #. if a whole target is removed, we need to first announce publicly, and; potentially mark as deprecated in o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:9132,clear,clear,9132,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['clear'],['clear']
Usability,"e of the edges/blocks may still be left; uninstrumented (pruned) if such instrumentation is considered redundant.; Use ``no-prune`` (e.g. ``-fsanitize-coverage=bb,no-prune,trace-pc-guard``); to disable pruning. This could be useful for better coverage visualization. Edge coverage; -------------. Consider this code:. .. code-block:: c++. void foo(int *a) {; if (a); *a = 0;; }. It contains 3 basic blocks, let's name them A, B, C:. .. code-block:: none. A; |\; | \; | B; | /; |/; C. If blocks A, B, and C are all covered we know for certain that the edges A=>B; and B=>C were executed, but we still don't know if the edge A=>C was executed.; Such edges of control flow graph are called; `critical <https://en.wikipedia.org/wiki/Control_flow_graph#Special_edges>`_.; The edge-level coverage simply splits all critical edges by introducing new; dummy blocks and then instruments those blocks:. .. code-block:: none. A; |\; | \; D B; | /; |/; C. Tracing data flow; =================. Support for data-flow-guided fuzzing.; With ``-fsanitize-coverage=trace-cmp`` the compiler will insert extra instrumentation; around comparison instructions and switch statements.; Similarly, with ``-fsanitize-coverage=trace-div`` the compiler will instrument; integer division instructions (to capture the right argument of division); and with ``-fsanitize-coverage=trace-gep`` --; the `LLVM GEP instructions <https://llvm.org/docs/GetElementPtr.html>`_; (to capture array indices).; Similarly, with ``-fsanitize-coverage=trace-loads`` and ``-fsanitize-coverage=trace-stores``; the compiler will instrument loads and stores, respectively. Currently, these flags do not work by themselves - they require one; of ``-fsanitize-coverage={trace-pc,inline-8bit-counters,inline-bool}``; flags to work. Unless ``no-prune`` option is provided, some of the comparison instructions; will not be instrumented. .. code-block:: c++. // Called before a comparison instruction.; // Arg1 and Arg2 are arguments of the comparison.; voi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:8796,guid,guided,8796,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,1,['guid'],['guided']
Usability,"e original author who is responsible to revert; the patch promptly. Developers often disagree, and erring on the side of the; developer asking for more review prevents any lingering disagreement over; code in the tree. This does not indicate any fault from the patch author,; this is inherent to our post-commit review practices.; Reverting a patch ensures that design discussions can happen without blocking; other development; it's entirely possible the patch will end up being reapplied; essentially as-is once concerns have been resolved. Before being recommitted, the patch generally should undergo further review.; The community member who identified the problem is expected to engage; actively in the review. In cases where the problem is identified by a buildbot,; a community member with access to hardware similar to that on the buildbot is; expected to engage in the review. Please note: The bar for post-commit feedback is not higher than for pre-commit; feedback. Don't delay unnecessarily in providing feedback. However, if you see; something after code has been committed about which you would have commented; pre-commit (had you noticed it earlier), please feel free to provide that; feedback at any time. That having been said, if a substantial period of time has passed since the; original change was committed, it may be better to create a new patch to; address the issues than comment on the original commit. The original patch; author, for example, might no longer be an active contributor to the project. What Tools Are Used for Code Review?; ------------------------------------. Pre-commit code reviews are conducted on GitHub with Pull Requests. See; :ref:`GitHub <github-reviews>` documentation. When Is an RFC Required?; ------------------------. Some changes are too significant for just a code review. Changes that should; change the LLVM Language Reference (e.g., adding new target-independent; intrinsics), adding language extensions in Clang, and so on, require an RFC;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:3241,feedback,feedback,3241,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,1,['feedback'],['feedback']
Usability,"e ownership responsibility is split between a ""resource owner""; who provides the underlying machine resource, and a ""configuration owner"" who; maintains the build configuration. Generally, operational responsibility lies; with the ""config owner"". We do expect ""resource owners"" - who are generally; the contact listed in a workers attributes - to proxy requests to the relevant; ""config owner"" in a timely manner. Most issues with a buildbot should be addressed directly with a bot owner; via email. Please CC `Galina Kistanova <mailto:gkistanova@gmail.com>`_. Steps To Add Builder To LLVM Buildbot; =====================================; Volunteers can provide their build machines to work as build workers to; public LLVM Buildbot. Here are the steps you can follow to do so:. #. Check the existing build configurations to make sure the one you are; interested in is not covered yet or gets built on your computer much; faster than on the existing one. We prefer faster builds so developers; will get feedback sooner after changes get committed. #. The computer you will be registering with the LLVM buildbot; infrastructure should have all dependencies installed and be able to; build your configuration successfully. Please check what degree; of parallelism (-j param) would give the fastest build. You can build; multiple configurations on one computer. #. Install buildbot-worker (currently we are using buildbot version 2.8.4).; This specific version can be installed using ``pip``, with a command such; as ``pip3 install buildbot-worker==2.8.4``. #. Create a designated user account, your buildbot-worker will be running under,; and set appropriate permissions. #. Choose the buildbot-worker root directory (all builds will be placed under; it), buildbot-worker access name and password the build master will be using; to authenticate your buildbot-worker. #. Create a buildbot-worker in context of that buildbot-worker account. Point it; to the **lab.llvm.org** port **9994** (see `Buildbot d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:2665,feedback,feedback,2665,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['feedback'],['feedback']
Usability,"e possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The greater the API surface, the greater the difficulty of keeping it stable.; Where possible the additional API surface should be kept small by defining it; in relation to existing APIs. An example of this is keeping a simple; relationship between flag names and command line options where possible.; Since the command line options are part of a stable API they are unlikely; to change, and therefore the flag names get the same stability. Low compile-time overhead; -------------------------. If the process of selecting multilib directories must be done on every; invocation of the Clang driver then it must have a negligible impact on; overall compile time.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:13055,simpl,simple,13055,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['simpl'],['simple']
Usability,"e previous values). All combinations are available. ``` {.cpp}; network.Train(1000,""text,graph,update=10""); // full output every; // 10 epochs; network.Train(100,""text,+""); // 100 more epochs; //starts with existing weights; ```. The weights can be saved to a file (`DumpWeights`) and then reloaded; (`LoadWeights`) to a new compatible network. The output can also be; evaluated (`Evaluate`) for a given output neuron and an array of; double input parameters or the network can be exported (`Export`) as a; standalone code. Up to now, this is only as a C++ or PYTHON class, but; other languages could be implemented. ### Examples. An example of how to use **`TMultiLayerPerceptron`** is the macro; `mlpHiggs.C` in \$ROOTSYS/tutorials. Using some standard simulated; information that could have been obtained at `LEP`, a neural network; is build, which can make the difference between `WW` events and events; containing a Higgs boson. Starting with a **`TFile`** containing two; **`TTree`**s: one for the signal, the other for the background, a; simple script is used:. ``` {.cpp}; void mlpHiggs(Int_t ntrain=100) {; if (!gROOT->GetClass(""TMultiLayerPerceptron"")); gSystem->Load(""libMLP"");; // prepare inputs - the 2 trees are merged into one, and a; // ""type"" branch, equal to 1 for the signal and 0 for the; // background is added; TFile input(""mlpHiggs.root"");; TTree *signal = (TTree *)input.Get(""sig_filtered"");; TTree *background = (TTree *)input.Get(""bg_filtered"");; TTree *simu = new TTree(""MonteCarlo"",; ""Filtered Monte Carlo Events"");; ...; ```. Since the input is a **`TTree`** and we are starting from two; different **`TTree`**s (with different names), they are first merged; into one, and a ""`type`"" branch is added, that says whether there is; a signal or a background event. Those irrelevant details are skipped; here. ``` {.cpp}; ...; TMultiLayerPerceptron *mlp = new TMultiLayerPerceptron(; ""msumf,ptsumf, acolin, acopl:8:type"",""ptsumf"",simu,; ""Entry$%2"",""Entry$/2"");; mlp->Train(ntra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:77957,simpl,simple,77957,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['simpl'],['simple']
Usability,"e regardless of the output device. .. option:: -help. Print a summary of command line options. .. option:: -o <filename>. Specify the output filename. .. option:: -S. Write output in LLVM intermediate language (instead of bitcode). .. option:: -{passname}. :program:`opt` provides the ability to run any of LLVM's optimization or; analysis passes in any order. The :option:`-help` option lists all the passes; available. The order in which the options occur on the command line are the; order in which they are executed (within pass constraints). .. option:: -strip-debug. This option causes opt to strip debug information from the module before; applying other optimizations. It is essentially the same as `-strip`; but it ensures that stripping of debug information is done first. .. option:: -verify-each. This option causes opt to add a verify pass after every pass otherwise; specified on the command line (including `-verify`). This is useful; for cases where it is suspected that a pass is creating an invalid module but; it is not clear which pass is doing it. .. option:: -stats. Print statistics. .. option:: -time-passes. Record the amount of time needed for each pass and print it to standard; error. .. option:: -debug. If this is a debug build, this option will enable debug printouts from passes; which use the ``LLVM_DEBUG()`` macro. See the `LLVM Programmer's Manual; <../ProgrammersManual.html>`_, section ``#DEBUG`` for more information. .. option:: -load=<plugin>. Load the dynamic object ``plugin``. This object should register new; optimization or analysis passes. Once loaded, the object will add new command; line options to enable various optimizations or analyses. To see the new; complete list of optimizations, use the :option:`-help` and :option:`-load`; options together. For example:. .. code-block:: sh. opt -load=plugin.so -help. .. option:: -print-passes. Print all available passes and exit. EXIT STATUS; -----------. If :program:`opt` succeeds, it will exit with 0.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/opt.rst:2228,clear,clear,2228,interpreter/llvm-project/llvm/docs/CommandGuide/opt.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/opt.rst,1,['clear'],['clear']
Usability,"e split cases.; Improve the performance of TProcessUUID::AddUUID by reintroducing the THashList.; This significanly improve the performance of reading file with very large number of ; directories (A file with 100,000 directories was traversed in more than 8 minutes; and is now traversed in 15s) without noticeable affecting small files. TFolder. Several enhancement and clarification to TFolder::FindFullPathName. TStyle. Add the fill color attribute (SetLegendFillColor() and the font; attribute (SetLegendFont(). A new TStyle called ""Modern"" has been implemented. It can be set with:. gROOT->SetStyle(""Modern"");; ; It has very little decoration. It was made looking at the default styles; usually used by the experiments.; ; A new parameter Canvas.Style in etc/system.rootrc allows; to define the default style. If it is not specified, the Modern; style is used. To use the old default style one can set it to Classic or add. gROOT->SetStyle(""Classic"");; ; to your scripts. We seek feedback on improving the Modern style.; Please leave comments in the forum.; ; The following table shows the two plots hpx->Draw() and hpxpy->Draw(""colz""); in the ""Classic"" and ""Modern"" styles.; . Classic Style; Modern Style. An other example:; ; Classic style:. Modern style:. ACLiC. ACLiC now passes the macro __ACLIC__ to both the rootcint and compiler phases. TWinNTSystem. Fix 64-bit compatibility issues (__asm keyword is not allowed).; Try (as much as possible) to avoid the disturbing ""There is no disk in the drive. Please insert a disk into drive \Device\..."" popup message box when calling AccessPathName() on removable disk drives with no media installed. This should fix the problem reported on the forum.; Prevent short timers (e.g. 10ms) to keep looping in the DispatchOneEvent() infinite loop.; Better stdout/stderr redirection (it was impossible to restore stdout using freopen on Windows 7, leaving the console as a zombie...); Make sure the stdout/stderr redirection works also in the case there",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html:2863,feedback,feedback,2863,core/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v530/index.html,1,['feedback'],['feedback']
Usability,"e statistics; gathered, use the '``-stats``' option:. .. code-block:: none. $ opt -stats -mypassname < program.bc > /dev/null; ... statistics output ... Note that in order to use the '``-stats``' option, LLVM must be; compiled with assertions enabled. When running ``opt`` on a C file from the SPEC benchmark suite, it gives a; report that looks like this:. .. code-block:: none. 7646 bitcodewriter - Number of normal instructions; 725 bitcodewriter - Number of oversized instructions; 129996 bitcodewriter - Number of bitcode bytes written; 2817 raise - Number of insts DCEd or constprop'd; 3213 raise - Number of cast-of-self removed; 5046 raise - Number of expression trees converted; 75 raise - Number of other getelementptr's formed; 138 raise - Number of load/store peepholes; 42 deadtypeelim - Number of unused typenames removed from symtab; 392 funcresolve - Number of varargs functions resolved; 27 globaldce - Number of global variables removed; 2 adce - Number of basic blocks removed; 134 cee - Number of branches revectored; 49 cee - Number of setcc instruction eliminated; 532 gcse - Number of loads removed; 2919 gcse - Number of instructions removed; 86 indvars - Number of canonical indvars added; 87 indvars - Number of aux indvars removed; 25 instcombine - Number of dead inst eliminate; 434 instcombine - Number of insts combined; 248 licm - Number of load insts hoisted; 1298 licm - Number of insts hoisted to a loop pre-header; 3 licm - Number of insts hoisted to multiple loop preds (bad, no loop pre-header); 75 mem2reg - Number of alloca's promoted; 1444 cfgsimplify - Number of blocks simplified. Obviously, with so many optimizations, having a unified framework for this stuff; is very nice. Making your pass fit well into the framework makes it more; maintainable and useful. .. _DebugCounters:. Adding debug counters to aid in debugging your code; ---------------------------------------------------. Sometimes, when writing new passes, or trying to track down bugs, it; i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:49465,simpl,simplified,49465,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['simpl'],['simplified']
Usability,"e systems is that a ; compiler may fall in anywhere in a ""continuum of compilation"" to do its ; job. On one side, scripting languages statically compile nothing and ; dynamically compile (or equivalently, interpret) everything. On the far ; other side, traditional static compilers process everything statically and ; nothing dynamically. These approaches have typically been seen as a ; tradeoff between performance and portability. On a deeper level, however, ; there are two reasons that optimal system performance may be obtained by a; system somewhere in between these two extremes: Dynamic application ; behavior and social constraints. From a technical perspective, pure static compilation cannot ever give ; optimal performance in all cases, because applications have varying dynamic; behavior that the static compiler cannot take into consideration. Even ; compilers that support profile guided optimization generate poor code in ; the real world, because using such optimization tunes that application ; to one particular usage pattern, whereas real programs (as opposed to ; benchmarks) often have several different usage patterns. On a social level, static compilation is a very shortsighted solution to ; the performance problem. Instruction set architectures (ISAs) continuously ; evolve, and each implementation of an ISA (a processor) must choose a set ; of tradeoffs that make sense in the market context that it is designed for. ; With every new processor introduced, the vendor faces two fundamental ; problems: First, there is a lag time between when a processor is introduced ; to when compilers generate quality code for the architecture. Secondly, ; even when compilers catch up to the new architecture there is often a large ; body of legacy code that was compiled for previous generations and will ; not or can not be upgraded. Thus a large percentage of code running on a ; processor may be compiled quite sub-optimally for the current ; characteristics of the dynamic execu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-04-16-DynamicCompilation.txt:1400,guid,guided,1400,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-04-16-DynamicCompilation.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-04-16-DynamicCompilation.txt,1,['guid'],['guided']
Usability,"e that kills variable locations is called a ""kill; dbg.value"" or ""kill location"", and for legacy reasons the term ""undef; dbg.value"" may be used in existing code. The ``DbgVariableIntrinsic`` methods; ``isKillLocation`` and ``setKillLocation`` should be used where possible rather; than inspecting location operands directly to check or set whether a dbg.value; is a kill location. In general, if any dbg.value has its operand optimized out and cannot be; recovered, then a kill dbg.value is necessary to terminate earlier variable; locations. Additional kill dbg.values may be necessary when the debugger can; observe re-ordering of assignments. How variable location metadata is transformed during CodeGen; ============================================================. LLVM preserves debug information throughout mid-level and backend passes,; ultimately producing a mapping between source-level information and; instruction ranges. This; is relatively straightforwards for line number information, as mapping; instructions to line numbers is a simple association. For variable locations; however the story is more complex. As each ``llvm.dbg.value`` intrinsic; represents a source-level assignment of a value to a source variable, the; variable location intrinsics effectively embed a small imperative program; within the LLVM IR. By the end of CodeGen, this becomes a mapping from each; variable to their machine locations over ranges of instructions.; From IR to object emission, the major transformations which affect variable; location fidelity are:. 1. Instruction Selection; 2. Register allocation; 3. Block layout. each of which are discussed below. In addition, instruction scheduling can; significantly change the ordering of the program, and occurs in a number of; different passes. Some variable locations are not transformed during CodeGen. Stack locations; specified by ``llvm.dbg.declare`` are valid and unchanging for the entire; duration of the function, and are recorded in a simp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:24225,simpl,simple,24225,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['simpl'],['simple']
Usability,"e to inlining creating nested exception; handling scopes. Restrictions; ------------. The unwinder delegates the decision of whether to stop in a call frame to that; call frame's language-specific personality function. Not all unwinders guarantee; that they will stop to perform cleanups. For example, the GNU C++ unwinder; doesn't do so unless the exception is actually caught somewhere further up the; stack. In order for inlining to behave correctly, landing pads must be prepared to; handle selector results that they did not originally advertise. Suppose that a; function catches exceptions of type ``A``, and it's inlined into a function that; catches exceptions of type ``B``. The inliner will update the ``landingpad``; instruction for the inlined landing pad to include the fact that ``B`` is also; caught. If that landing pad assumes that it will only be entered to catch an; ``A``, it's in for a rude awakening. Consequently, landing pads must test for; the selector results they understand and then resume exception propagation with; the `resume instruction <LangRef.html#i_resume>`_ if none of the conditions; match. Exception Handling Intrinsics; =============================. In addition to the ``landingpad`` and ``resume`` instructions, LLVM uses several; intrinsic functions (name prefixed with ``llvm.eh``) to provide exception; handling information at various points in generated code. .. _llvm.eh.typeid.for:. ``llvm.eh.typeid.for``; ----------------------. .. code-block:: llvm. i32 @llvm.eh.typeid.for(i8* %type_info). This intrinsic returns the type info index in the exception table of the current; function. This value can be used to compare against the result of; ``landingpad`` instruction. The single argument is a reference to a type info. Uses of this intrinsic are generated by the C++ front-end. .. _llvm.eh.exceptionpointer:. ``llvm.eh.exceptionpointer``; ----------------------------. .. code-block:: text. i8 addrspace(N)* @llvm.eh.padparam.pNi8(token %catchpad). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:14959,resume,resume,14959,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,2,['resume'],['resume']
Usability,"e values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));. .. _WhitespaceSensitiveMacros:. **WhitespaceSensitiveMacros** (``List of Strings``) :versionbadge:`clang-format 11` :ref:`¶ <WhitespaceSensitiveMacros>`; A vector of macros which are whitespace-sensitive and should not; be touched. These are expected to be macros of the form:. .. code-block:: c++. STRINGIZE(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']. For example: BOOST_PP_STRINGIZE. .. END_FORMAT_STYLE_OPTIONS. Adding additional style options; ===============================. Each additional style option adds costs to the clang-format project. Some of; these costs affect the clang-format development itself, as we need to make; sure that any given combination of options work and that new features don't; break any of the existing options in any way. There are also costs for end users; as o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:133074,clear,clear,133074,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['clear'],['clear']
Usability,"e with an unreachable unwind destination to a call instruction. #. Use profile metadata to indicate statically known cold paths, even if; dynamic profiling information is not available. This can make a large; difference in code placement and thus the performance of tight loops. #. When generating code for loops, try to avoid terminating the header block of; the loop earlier than necessary. If the terminator of the loop header; block is a loop exiting conditional branch, the effectiveness of LICM will; be limited for loads not in the header. (This is due to the fact that LLVM; may not know such a load is safe to speculatively execute and thus can't; lift an otherwise loop invariant load unless it can prove the exiting; condition is not taken.) It can be profitable, in some cases, to emit such; instructions into the header even if they are not used along a rarely; executed path that exits the loop. This guidance specifically does not; apply if the condition which terminates the loop header is itself invariant,; or can be easily discharged by inspecting the loop index variables. #. In hot loops, consider duplicating instructions from small basic blocks; which end in highly predictable terminators into their successor blocks.; If a hot successor block contains instructions which can be vectorized; with the duplicated ones, this can provide a noticeable throughput; improvement. Note that this is not always profitable and does involve a; potentially large increase in code size. #. When checking a value against a constant, emit the check using a consistent; comparison type. The GVN pass *will* optimize redundant equalities even if; the type of comparison is inverted, but GVN only runs late in the pipeline.; As a result, you may miss the opportunity to run other important; optimizations. #. Avoid using arithmetic intrinsics unless you are *required* by your source; language specification to emit a particular code sequence. The optimizer; is quite good at reasoning about gene",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst:7863,guid,guidance,7863,interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,1,['guid'],['guidance']
