quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Testability,"﻿. PCMSOLVER. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Test Suite and Sample Inputs; PCMSOLVER. PCMSOLVER¶. Input File; Description. pcmsolver/dft; pcm updated totalenergy to new BraggSlater radii values. pcmsolver/uhf-tdscf; UHF PCM TDSCF. pcmsolver/dipole; dipole moment for HF and B3LYP in presence of perturbation updated B3LYP values due to new BraggSlater radii. pcmsolver/ghost; ghost atoms for the pcmsolver addon. pcmsolver/tdscf; PCM TDSCF Ref. values from lsdaton test case: opa_hf_H2O_noneq_pcmsolver.out. pcmsolver/alpha; PCM dipole polarizabilities. Ref. values from lsdaton test case: static_alpha_hf_H2O_eq_pcmsolver.out. pcmsolver/ccsd-pte; coupled-cluster with PCM. pcmsolver/opt-fd; PCM-SCF STO-3G geometry optimization by finite differences, with Z-matrix input. pcmsolver/scf; pcm. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Test Suite and Sample Inputs; PCMSOLVER. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_pcmsolver.html:514,test,test,514,psi4manual/1.6.x/autodoc_testsuite_pcmsolver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_pcmsolver.html,2,['test'],['test']
Testability,"﻿. PCMSOLVER. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Test Suite and Sample Inputs; PCMSOLVER. PCMSOLVER¶. Input File; Description. pcmsolver/tdscf; PCM TDSCF Ref. values from lsdaton test case: opa_hf_H2O_noneq_pcmsolver.out. pcmsolver/alpha; PCM dipole polarizabilities. Ref. values from lsdaton test case: static_alpha_hf_H2O_eq_pcmsolver.out. pcmsolver/ghost; ghost atoms for the pcmsolver addon. pcmsolver/scf; pcm. pcmsolver/dipole; dipole moment for HF and B3LYP in presence of perturbation updated B3LYP values due to new BraggSlater radii. pcmsolver/ccsd-pte; coupled-cluster with PCM. pcmsolver/uhf-tdscf; UHF PCM TDSCF. pcmsolver/opt-fd; PCM-SCF STO-3G geometry optimization by finite differences, with Z-matrix input. pcmsolver/dft; pcm updated totalenergy to new BraggSlater radii values. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Test Suite and Sample Inputs; PCMSOLVER. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_pcmsolver.html:224,test,test,224,psi4manual/1.7.x/autodoc_testsuite_pcmsolver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_pcmsolver.html,2,['test'],['test']
Testability,"﻿. PCMSOLVER. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Test Suite and Sample Inputs; PCMSOLVER. PCMSOLVER¶. Input File; Description. pcmsolver/uhf-tdscf; UHF PCM TDSCF. pcmsolver/ghost; ghost atoms for the pcmsolver addon. pcmsolver/scf; pcm. pcmsolver/dipole; dipole moment for HF and B3LYP in presence of perturbation updated B3LYP values due to new BraggSlater radii. pcmsolver/tdscf; PCM TDSCF Ref. values from lsdaton test case: opa_hf_H2O_noneq_pcmsolver.out. pcmsolver/ccsd-pte; coupled-cluster with PCM. pcmsolver/dft; pcm updated totalenergy to new BraggSlater radii values. pcmsolver/opt-fd; PCM-SCF STO-3G geometry optimization by finite differences, with Z-matrix input. pcmsolver/alpha; PCM dipole polarizabilities. Ref. values from lsdaton test case: static_alpha_hf_H2O_eq_pcmsolver.out. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Test Suite and Sample Inputs; PCMSOLVER. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_pcmsolver.html:464,test,test,464,psi4manual/1.8.x/autodoc_testsuite_pcmsolver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_pcmsolver.html,2,['test'],['test']
Testability,"﻿. PCMSOLVER. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Test Suite and Sample Inputs; PCMSOLVER. PCMSOLVER¶. Input File; Description. pcmsolver/dipole; dipole moment for HF and B3LYP in presence of perturbation updated B3LYP values due to new BraggSlater radii. pcmsolver/scf; pcm. pcmsolver/ghost; ghost atoms for the pcmsolver addon. pcmsolver/alpha; PCM dipole polarizabilities. Ref. values from lsdaton test case: static_alpha_hf_H2O_eq_pcmsolver.out. pcmsolver/opt-fd; PCM-SCF STO-3G geometry optimization by finite differences, with Z-matrix input. pcmsolver/tdscf; PCM TDSCF Ref. values from lsdaton test case: opa_hf_H2O_noneq_pcmsolver.out. pcmsolver/uhf-tdscf; UHF PCM TDSCF. pcmsolver/dft; pcm updated totalenergy to new BraggSlater radii values. pcmsolver/ccsd-pte; coupled-cluster with PCM. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Test Suite and Sample Inputs; PCMSOLVER. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_pcmsolver.html:447,test,test,447,psi4manual/1.9.x/autodoc_testsuite_pcmsolver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_pcmsolver.html,2,['test'],['test']
Testability,"﻿. PYTHON. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Test Suite and Sample Inputs; PYTHON. PYTHON¶. Input File; Description. python/mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. python/cc54; CCSD dipole with user-specified basis set. python/cc-amps; API access to CCSD amplitudes. python/mints13; test fragment decomposition + to/from_dict. python/mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. python/curve; PsiAPI scanning a potential energy curve. python/3-index-transforms; examine JK packing forms. python/databases; PsiAPI energy example. python/mints14; Check for correctness of ESP values. The ESP values are calculated using one or four threads The one thread values are checked against the four thread values. The one thread values are also checked against the reference values (1 thread values computed, when generating this test). Caution: The reference values are not obtained using an actual physical reference, but rather generated by Psi4 at one point in time. python/pubchem; PsiAPI pubchem access. python/energy; PsiAPI energy example. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Test Suite and Sample Inputs; PYTHON. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_python.html:189,test,test,189,psi4manual/master/autodoc_testsuite_python.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_python.html,4,['test'],['test']
Testability,"﻿. PYTHON. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Test Suite and Sample Inputs. PYTHON¶. Input File; Description. python/memdfjk; compare MemJK and DiskJK. python/3-index-transforms; examine JK packing forms. python/mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. python/mints13; test fragment decomposition + to/from_dict. python/curve; PsiAPI scanning a potential energy curve. python/pubchem; PsiAPI pubchem access. python/energy; PsiAPI energy example. python/cc54; CCSD dipole with user-specified basis set. python/mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. python/vibanalysis; compare analytic, findif by G, findif by E vibrational analyses for several mols. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Test Suite and Sample Inputs. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_python-1.html:269,test,test,269,psi4manual/1.2.1/autodoc_testsuite_python-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_python-1.html,6,['test'],['test']
Testability,"﻿. PYTHON. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Test Suite and Sample Inputs. PYTHON¶. Input File; Description. python/3-index-transforms; examine JK packing forms. python/mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. python/mints13; test fragment decomposition + to/from_dict. python/curve; PsiAPI scanning a potential energy curve. python/pubchem; PsiAPI pubchem access. python/energy; PsiAPI energy example. python/cc54; CCSD dipole with user-specified basis set. python/mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. python/cc_amps; API access to CCSD amplitudes. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Test Suite and Sample Inputs. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_python-1.html:227,test,test,227,psi4manual/1.3.2/autodoc_testsuite_python-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_python-1.html,6,['test'],['test']
Testability,"﻿. PYTHON. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Test Suite and Sample Inputs; PYTHON. PYTHON¶. Input File; Description. python/pubchem; PsiAPI pubchem access. python/mints14; Check for correctness of ESP values. The ESP values are calculated using one or four threads The one thread values are checked against the four thread values. The one thread values are also checked against the reference values (1 thread values computed, when generating this test). Caution: The reference values are not obtained using an actual physical reference, but rather generated by Psi4 at one point in time. python/energy; PsiAPI energy example. python/cc54; CCSD dipole with user-specified basis set. python/cc-amps; API access to CCSD amplitudes. python/mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. python/3-index-transforms; examine JK packing forms. python/mints13; test fragment decomposition + to/from_dict. python/mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. python/databases; PsiAPI energy example. python/curve; PsiAPI scanning a potential energy curve. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Test Suite and Sample Inputs; PYTHON. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_python-1.html:493,test,test,493,psi4manual/1.4.0/autodoc_testsuite_python-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_python-1.html,8,['test'],['test']
Testability,"﻿. PYTHON. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Test Suite and Sample Inputs; PYTHON. PYTHON¶. Input File; Description. python/energy; PsiAPI energy example. python/databases; PsiAPI energy example. python/cc54; CCSD dipole with user-specified basis set. python/cc-amps; API access to CCSD amplitudes. python/mints13; test fragment decomposition + to/from_dict. python/mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. python/pubchem; PsiAPI pubchem access. python/curve; PsiAPI scanning a potential energy curve. python/mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. python/3-index-transforms; examine JK packing forms. python/mints14; Check for correctness of ESP values. The ESP values are calculated using one or four threads The one thread values are checked against the four thread values. The one thread values are also checked against the reference values (1 thread values computed, when generating this test). Caution: The reference values are not obtained using an actual physical reference, but rather generated by Psi4 at one point in time. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Test Suite and Sample Inputs; PYTHON. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_python-1.html:361,test,test,361,psi4manual/1.5.0/autodoc_testsuite_python-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_python-1.html,8,['test'],['test']
Testability,"﻿. PYTHON. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Test Suite and Sample Inputs; PYTHON. PYTHON¶. Input File; Description. python/cc54; CCSD dipole with user-specified basis set. python/mints13; test fragment decomposition + to/from_dict. python/curve; PsiAPI scanning a potential energy curve. python/databases; PsiAPI energy example. python/mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. python/pubchem; PsiAPI pubchem access. python/energy; PsiAPI energy example. python/3-index-transforms; examine JK packing forms. python/mints14; Check for correctness of ESP values. The ESP values are calculated using one or four threads The one thread values are checked against the four thread values. The one thread values are also checked against the reference values (1 thread values computed, when generating this test). Caution: The reference values are not obtained using an actual physical reference, but rather generated by Psi4 at one point in time. python/cc-amps; API access to CCSD amplitudes. python/mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Test Suite and Sample Inputs; PYTHON. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_python.html:235,test,test,235,psi4manual/1.6.x/autodoc_testsuite_python.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_python.html,4,['test'],['test']
Testability,"﻿. PYTHON. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Test Suite and Sample Inputs; PYTHON. PYTHON¶. Input File; Description. python/mints14; Check for correctness of ESP values. The ESP values are calculated using one or four threads The one thread values are checked against the four thread values. The one thread values are also checked against the reference values (1 thread values computed, when generating this test). Caution: The reference values are not obtained using an actual physical reference, but rather generated by Psi4 at one point in time. python/mints13; test fragment decomposition + to/from_dict. python/pubchem; PsiAPI pubchem access. python/mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. python/mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. python/cc54; CCSD dipole with user-specified basis set. python/cc-amps; API access to CCSD amplitudes. python/databases; PsiAPI energy example. python/energy; PsiAPI energy example. python/3-index-transforms; examine JK packing forms. python/curve; PsiAPI scanning a potential energy curve. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Test Suite and Sample Inputs; PYTHON. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_python.html:454,test,test,454,psi4manual/1.7.x/autodoc_testsuite_python.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_python.html,4,['test'],['test']
Testability,"﻿. PYTHON. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Test Suite and Sample Inputs; PYTHON. PYTHON¶. Input File; Description. python/mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. python/energy; PsiAPI energy example. python/3-index-transforms; examine JK packing forms. python/mints13; test fragment decomposition + to/from_dict. python/mints14; Check for correctness of ESP values. The ESP values are calculated using one or four threads The one thread values are checked against the four thread values. The one thread values are also checked against the reference values (1 thread values computed, when generating this test). Caution: The reference values are not obtained using an actual physical reference, but rather generated by Psi4 at one point in time. python/cc54; CCSD dipole with user-specified basis set. python/databases; PsiAPI energy example. python/curve; PsiAPI scanning a potential energy curve. python/cc-amps; API access to CCSD amplitudes. python/mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. python/pubchem; PsiAPI pubchem access. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Test Suite and Sample Inputs; PYTHON. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_python.html:182,test,test,182,psi4manual/1.8.x/autodoc_testsuite_python.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_python.html,4,['test'],['test']
Testability,"﻿. PYTHON. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Test Suite and Sample Inputs; PYTHON. PYTHON¶. Input File; Description. python/pubchem; PsiAPI pubchem access. python/energy; PsiAPI energy example. python/mints13; test fragment decomposition + to/from_dict. python/cc54; CCSD dipole with user-specified basis set. python/3-index-transforms; examine JK packing forms. python/cc-amps; API access to CCSD amplitudes. python/mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. python/mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. python/curve; PsiAPI scanning a potential energy curve. python/mints14; Check for correctness of ESP values. The ESP values are calculated using one or four threads The one thread values are checked against the four thread values. The one thread values are also checked against the reference values (1 thread values computed, when generating this test). Caution: The reference values are not obtained using an actual physical reference, but rather generated by Psi4 at one point in time. python/databases; PsiAPI energy example. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Test Suite and Sample Inputs; PYTHON. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_python.html:258,test,test,258,psi4manual/1.9.x/autodoc_testsuite_python.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_python.html,4,['test'],['test']
Testability,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; How to impose code style through your editor; How to impose code style through Git hooks; How to run code-style tools clang-format and yapf manually. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Releasing PSI4¶. Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.8.2). Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase; How to Ignore the Bots. Miscellaneous¶. Test Suite; Adding PSIthon Test Cases; Adding PsiAPI Test Cases; How to set up PSIthon tests to run through pytest; How to find tests without output.ref; How to do GitHub issue management and code review. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Releasing PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. © ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_faq.html:856,test,testing,856,psi4manual/master/prog_faq.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_faq.html,1,['test'],['testing']
Testability,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase. Miscellaneous¶. Adding Test Cases. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/prog_faq-1.html:702,test,testing,702,psi4manual/1.2.1/prog_faq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_faq-1.html,2,['test'],['testing']
Testability,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Adding New Code to PSI4. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase. Miscellaneous¶. Adding Test Cases. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Adding New Code to PSI4. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/prog_faq-1.html:682,test,testing,682,psi4manual/1.3.2/prog_faq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/prog_faq-1.html,2,['test'],['testing']
Testability,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; How to impose code style through your editor; How to impose code style through Git hooks; How to run code-style tools clang-format and yapf manually. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Releasing PSI4¶. Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1). Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase; How to Ignore the Bots. Miscellaneous¶. Adding PSIthon Test Cases; Adding PsiAPI Test Cases; How to find tests without output.ref; How to do GitHub issue management and code review. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Releasing PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_faq-1.html:847,test,testing,847,psi4manual/1.4.0/prog_faq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_faq-1.html,2,['test'],['testing']
Testability,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; How to impose code style through your editor; How to impose code style through Git hooks; How to run code-style tools clang-format and yapf manually. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Releasing PSI4¶. Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1). Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase; How to Ignore the Bots. Miscellaneous¶. Adding PSIthon Test Cases; Adding PsiAPI Test Cases; How to find tests without output.ref; How to do GitHub issue management and code review. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Releasing PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/prog_faq-1.html:847,test,testing,847,psi4manual/1.5.0/prog_faq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/prog_faq-1.html,2,['test'],['testing']
Testability,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; How to impose code style through your editor; How to impose code style through Git hooks; How to run code-style tools clang-format and yapf manually. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Releasing PSI4¶. Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1). Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase; How to Ignore the Bots. Miscellaneous¶. Test Suite; Adding PSIthon Test Cases; Adding PsiAPI Test Cases; How to set up PSIthon tests to run through pytest; How to find tests without output.ref; How to do GitHub issue management and code review. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Releasing PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. © Copyright 2022, Th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/prog_faq.html:847,test,testing,847,psi4manual/1.6.x/prog_faq.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_faq.html,1,['test'],['testing']
Testability,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; How to impose code style through your editor; How to impose code style through Git hooks; How to run code-style tools clang-format and yapf manually. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Releasing PSI4¶. Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1). Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase; How to Ignore the Bots. Miscellaneous¶. Test Suite; Adding PSIthon Test Cases; Adding PsiAPI Test Cases; How to set up PSIthon tests to run through pytest; How to find tests without output.ref; How to do GitHub issue management and code review. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Releasing PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. © Copyright 2007-202",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/prog_faq.html:847,test,testing,847,psi4manual/1.7.x/prog_faq.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/prog_faq.html,1,['test'],['testing']
Testability,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; How to impose code style through your editor; How to impose code style through Git hooks; How to run code-style tools clang-format and yapf manually. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Releasing PSI4¶. Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.3.1). Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase; How to Ignore the Bots. Miscellaneous¶. Test Suite; Adding PSIthon Test Cases; Adding PsiAPI Test Cases; How to set up PSIthon tests to run through pytest; How to find tests without output.ref; How to do GitHub issue management and code review. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Releasing PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. © Copyright 2007",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/prog_faq.html:849,test,testing,849,psi4manual/1.8.x/prog_faq.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/prog_faq.html,1,['test'],['testing']
Testability,"﻿. Programmers FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. Programmers FAQ¶. C++ Style in PSI4¶. Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; How to impose code style through your editor; How to impose code style through Git hooks; How to run code-style tools clang-format and yapf manually. Modules in PSI4¶. How to name keywords in psi4/src/read_options.cc; How to call BLAS & LAPACK in ; How to use low-level BLAS/LAPACK with psi4.core.Matrix; How to name orbital bases (e.g., AO & SO); How to name orbital dimensions; How to name orbital spaces (e.g., docc). Interfacing with PSI4¶. How to use an Add-On’s name in directory structure, build, and distribution; How to integrate an Add-On into build, testing, and docs. Versioning PSI4¶. How to bump a version; How to create and remove an annotated Git tag on a remote; What is the suggested GitHub workflow; What Psi4 version is running. Releasing PSI4¶. Annual; Pre-Release (e.g., v1.3rc1); Release (e.g., v1.3); Post-Release (e.g., v1.8.2). Workflow¶. How to use a local Add-On repository in the Psi4 build; What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi; How to use gdb and lldb with Psi4; How to locate non-ascii characters in the codebase; How to Ignore the Bots. Miscellaneous¶. Test Suite; Adding PSIthon Test Cases; Adding PsiAPI Test Cases; How to set up PSIthon tests to run through pytest; How to find tests without output.ref; How to do GitHub issue management and code review. table of contents. Programmers FAQ; C++ Style in PSI4; Modules in PSI4; Interfacing with PSI4; Versioning PSI4; Releasing PSI4; Workflow; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Adding New Code to PSI4; Programmers FAQ. © Copyright 2007",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/prog_faq.html:849,test,testing,849,psi4manual/1.9.x/prog_faq.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/prog_faq.html,1,['test'],['testing']
Testability,"﻿. Psithon: Structuring an Input File — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:590,test,test,590,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,4,['test'],['test']
Testability,"﻿. Psithon: Structuring an Input File — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html:605,test,test,605,psi4manual/4.0b3/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html,4,['test'],['test']
Testability,"﻿. Psithon: Structuring an Input File — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:605,test,test,605,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['test'],['test']
Testability,"﻿. Psithon: Structuring an Input File — PSI4 [beta5] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psithoninput-1.html:605,test,test,605,psi4manual/4.0b5/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psithoninput-1.html,4,['test'],['test']
Testability,"﻿. Psithon: Structuring an Input File — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, Psi4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; Psi4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level Psi4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all Psi4 input files.; For convenience, the physical constants used within the Psi4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within Psi4, which are automatically; made available within all Psi4 input files.; # @END LICENSE; #. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/include/physconst.h; psi_h = 6.62606896E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:612,test,test,612,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,4,['test'],['test']
Testability,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Psithon: Structuring an Input File. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples.; The equivalent Python PsiAPI syntax is shown alongside the Psithon code snippets.; When using the Python API, one must import the PSI4 module with:; import psi4. No such directive is neccesary when using Psithon, which is run using the psi4; executable. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made availa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:607,test,test,607,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,2,['test'],['test']
Testability,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of lig",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:562,test,test,562,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,4,['test'],['test']
Testability,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:564,test,test,564,psi4manual/1.2.1/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html,4,['test'],['test']
Testability,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psithoninput-1.html:564,test,test,564,psi4manual/1.3.2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psithoninput-1.html,4,['test'],['test']
Testability,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Psithon: Structuring an Input File. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:598,test,test,598,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,4,['test'],['test']
Testability,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Psithon: Structuring an Input File. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psithoninput-1.html:598,test,test,598,psi4manual/1.5.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psithoninput-1.html,4,['test'],['test']
Testability,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon: Structuring an Input File. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psithoninput.html:598,test,test,598,psi4manual/1.6.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psithoninput.html,2,['test'],['test']
Testability,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon: Structuring an Input File. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psithoninput.html:598,test,test,598,psi4manual/1.7.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psithoninput.html,2,['test'],['test']
Testability,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Psithon: Structuring an Input File. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psithoninput.html:600,test,test,600,psi4manual/1.8.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psithoninput.html,2,['test'],['test']
Testability,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Psithon: Structuring an Input File. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psithoninput.html:600,test,test,600,psi4manual/1.9.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psithoninput.html,2,['test'],['test']
Testability,"﻿. REPL_OTF — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices »; Keywords by Module »; DETCI ». REPL_OTF¶. Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI’s) but is somewhat flaky and hasn’t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. Type: boolean; Default: false. Previous topic; REFERENCE_SYM; Next topic; RESTART; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices »; Keywords by Module »; DETCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/detci__repl_otf-1.html:316,test,tested,316,psi4manual/4.0b2/autodir_options_c/detci__repl_otf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/detci__repl_otf-1.html,2,['test'],['tested']
Testability,"﻿. REPL_OTF — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Keywords by Module »; DETCI ». REPL_OTF¶. Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI’s) but is somewhat flaky and hasn’t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. Type: boolean; Default: false. Previous topic; REFERENCE_SYM; Next topic; RESTART; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Keywords by Module »; DETCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/detci__repl_otf-1.html:331,test,tested,331,psi4manual/4.0b3/autodir_options_c/detci__repl_otf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/detci__repl_otf-1.html,2,['test'],['tested']
Testability,"﻿. REPL_OTF — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices »; Keywords by Module »; DETCI ». REPL_OTF¶. Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI’s) but is somewhat flaky and hasn’t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. Type: boolean; Default: false. Previous topic; REFERENCE_SYM; Next topic; RESTART; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices »; Keywords by Module »; DETCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/detci__repl_otf-1.html:331,test,tested,331,psi4manual/4.0b4/autodir_options_c/detci__repl_otf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/detci__repl_otf-1.html,2,['test'],['tested']
Testability,"﻿. REPL_OTF — PSI4 [beta5] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Appendices »; Keywords by Module »; DETCI ». REPL_OTF¶. Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI’s) but is somewhat flaky and hasn’t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. Type: boolean; Default: false. Previous topic; REFERENCE_SYM; Next topic; RESTART; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Appendices »; Keywords by Module »; DETCI ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/detci__repl_otf-1.html:331,test,tested,331,psi4manual/4.0b5/autodir_options_c/detci__repl_otf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/detci__repl_otf-1.html,2,['test'],['tested']
Testability,"﻿. REPL_OTF — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Keywords by Module »; DETCI ». REPL_OTF¶. Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI’s) but is somewhat flaky and hasn’t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. Type: boolean; Default: false. Previous topic; REFERENCE_SYM; Next topic; RESTART. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Keywords by Module »; DETCI ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/detci__repl_otf-1.html:338,test,tested,338,psi4manual/1.0.0/autodir_options_c/detci__repl_otf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/detci__repl_otf-1.html,2,['test'],['tested']
Testability,"﻿. REPL_OTF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; DETCI; REPL_OTF. REPL_OTF¶. Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI’s) but is somewhat flaky and hasn’t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; DETCI; REPL_OTF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/detci__repl_otf.html:301,test,tested,301,psi4manual/master/autodir_options_c/detci__repl_otf.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/detci__repl_otf.html,1,['test'],['tested']
Testability,"﻿. REPL_OTF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; DETCI; REPL_OTF. REPL_OTF¶. Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI’s) but is somewhat flaky and hasn’t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; DETCI; REPL_OTF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/detci__repl_otf-1.html:292,test,tested,292,psi4manual/1.4.0/autodir_options_c/detci__repl_otf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/detci__repl_otf-1.html,2,['test'],['tested']
Testability,"﻿. REPL_OTF. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; DETCI; REPL_OTF. REPL_OTF¶. Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI’s) but is somewhat flaky and hasn’t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; DETCI; REPL_OTF. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/detci__repl_otf-1.html:292,test,tested,292,psi4manual/1.5.0/autodir_options_c/detci__repl_otf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/detci__repl_otf-1.html,2,['test'],['tested']
Testability,"﻿. REPL_OTF. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; DETCI; REPL_OTF. REPL_OTF¶. Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI’s) but is somewhat flaky and hasn’t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; DETCI; REPL_OTF. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/detci__repl_otf.html:292,test,tested,292,psi4manual/1.6.x/autodir_options_c/detci__repl_otf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/detci__repl_otf.html,1,['test'],['tested']
Testability,"﻿. REPL_OTF. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; DETCI; REPL_OTF. REPL_OTF¶. Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI’s) but is somewhat flaky and hasn’t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; DETCI; REPL_OTF. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/detci__repl_otf.html:292,test,tested,292,psi4manual/1.7.x/autodir_options_c/detci__repl_otf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/detci__repl_otf.html,1,['test'],['tested']
Testability,"﻿. REPL_OTF. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; DETCI; REPL_OTF. REPL_OTF¶. Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI’s) but is somewhat flaky and hasn’t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; DETCI; REPL_OTF. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/detci__repl_otf.html:294,test,tested,294,psi4manual/1.8.x/autodir_options_c/detci__repl_otf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/detci__repl_otf.html,1,['test'],['tested']
Testability,"﻿. REPL_OTF. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; DETCI; REPL_OTF. REPL_OTF¶. Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI’s) but is somewhat flaky and hasn’t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; DETCI; REPL_OTF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/detci__repl_otf.html:294,test,tested,294,psi4manual/1.9.x/autodir_options_c/detci__repl_otf.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/detci__repl_otf.html,1,['test'],['tested']
Testability,"﻿. RSE42 — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Psithon Functions: Invoking a Calculation »; Database, database() ». RSE42¶. Database of radical stabilization energies.; Geometries from [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)].; Reference radical stabilization energies from [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)] at CCSD(T)/cc-pCVTZ level. benchmark; 'RSE42' [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)].; 'RSE42' [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)]. subset; 'small' <members_description>; 'large' <members_description>; 'RSE30' smaller systems in RSE42; '<subset>' <members_description>. S22¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries from Jurecka et al. PCCP 8 1985 (2006).; First revision to interaction energies (S22A) from Takatani et al. JCP 132 144104 (2010).; Second revision to interaction energies (S22B) from Marshall et al. JCP 135 194102 (2011). cp 'off' || 'on'; rlxd 'off'; benchmark; 'S220' Jurecka et al. PCCP 8 1985 (2006).; 'S22A' Takatani et al. JCP 132 144104 (2010).; 'S22B' Marshall et al. JCP 135 194102 (2011). subset; 'small' water dimer, methane dimer, ethene-ethine; 'large' adenine-thymine; 'HB' hydrogen-bonded systems; 'MX' mixed-influence systems; 'DD' dispersion-dominated systems; 'S11' smaller systems in S22; 'WATER' water dimer. A24¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries from <Reference>.; Reference interaction energies from Rezac and Hobza, JCTC (in press). cp 'off' <erase this comment and after unless on is a valid option> || 'on'; rlxd 'off' <erase this comment and after unless on is valid option> || 'on'; benchmark; '<benchmark_name>' <Reference>.; '<default_benchmark_name>' <Reference>. subset; 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. BAKERJCC96¶. Geometries from Baker and Chan",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_available_databases-1.html:449,benchmark,benchmark,449,psi4manual/1.0.0/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_available_databases-1.html,2,['benchmark'],['benchmark']
Testability,"﻿. RSE42. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Psithon Functions: Invoking a Calculation; Database — database(); RSE42. RSE42¶. Database of radical stabilization energies.; Geometries from [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)].; Reference radical stabilization energies from [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)] at CCSD(T)/cc-pCVTZ level. benchmark. 'RSE42' [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)].; \(\Rightarrow\) 'RSE42' \(\Leftarrow\) [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)]. subset. 'small' <members_description>; 'large' <members_description>; 'RSE30' smaller systems in RSE42; '<subset>' <members_description>. O24by5¶. Database (O24) of interaction energies for small open-shell high-spin bimolecular complexes.; Geometries taken from https://gitlab.com/piotr.zuchowski/o24x5/-/tree/4ec3cae0546b6ae4f4f2cf28482cd164c8323cc6.; Reference interaction energies taken from J. Chem. Phys. 154, 134106 (2021) https://doi.org/10.1063/5.0043793.; Variant without midbonds. no | name | subset. 1 | CN - He | DD; 2 | NH - He | DD; 3 | C2H3 - C2H4 | DD; 4 | O2 - H2 | DD; 5 | NH - Ar | DD; 6 | CN - Ar | DD; 7 | O2 - N2 | DD; 8 | H2O - O2(sp) | DD; 9 | O2 - O2 | DD. 10 | NH - NH | ED; 11 | CH2O - NH2 | ED; 12 | H2O - Na | ED; 13 | H2O - OH | ED; 14 | H2O - O2H | ED; 15 | Li - NH3(gm) | ED; 16 | Li - O2 | MX; 17 | CN - H2 | MX; 18 | Li - NH3(lm) | MX; 19 | H2O - O2(gm) | MX; 20 | Na - Li | MX; 21 | CO2 - O2 | MX; 22 | C2H3 - CO2 | MX; 23 | He* - He* | MX; 24 | HF - CO+ | MX. cp 'on'; subset; - 'DD' dispersion-dominated systems; - 'ED' electrostatically-dominated systems; - 'MX' mixed-interaction systems. SSI¶. Database (Merz) of interaction energies for protein sidechain-sidechain interactions.; Geometries from Kenneth Merz Group, Univ. of Florida.; Reference interaction energies from <Reference>.; Part of the BioFragment Database (BFDb). cp 'off' || 'on'; rlxd 'off'. RGC10¶. Database (Sher",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_available_databases.html:412,benchmark,benchmark,412,psi4manual/master/autodoc_available_databases.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_available_databases.html,1,['benchmark'],['benchmark']
Testability,"﻿. Release Procedures. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. Release Procedures¶. Annual¶. On January first; Update copyright year; Update counter scripts. Pre-Release (e.g., v1.3rc1)¶. Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Tag (pre)release; Build extra Conda packages for Psi4 channel; Build Psi4conda set; Generate download page for psicode.org. Release (e.g., v1.3)¶. Update samples (if no prerelease); Collect new authors (if no prerelease); Anticipate next release (if no prerelease); Build Conda ecosystem stack (if no prerelease); Run long tests; Do final pass before release tag; Tag (pre)release; Initialize release branch; Build extra Conda packages for Psi4 channel; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish psicode.org release; Finalize release. Post-Release (e.g., v1.8.2)¶. Assemble postrelease changes; Tweak Conda for postrelease; Tag postrelease; Build Psi4conda set; Build extra Conda packages for Psi4 channel; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode.org release; Finalize release. On January first¶. Screenshot https://anaconda.org/psi4/psi4 .; Screenshot https://anaconda.org/conda-forge/psi4 .; Add new year title and images to website; https://github.com/psi4/psicode-hugo-website/edit/master/content/posts/downloads.md .; On the next day, check that the new year’s plot appears at https://psicode.netlify.app/posts/downloads/ . Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md. Also, in content of psi4/doc/sphinxman/source/conf.p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/manage_release.html:701,test,tests,701,psi4manual/master/manage_release.html,https://psicode.org,https://psicode.org/psi4manual/master/manage_release.html,1,['test'],['tests']
Testability,"﻿. Release Procedures. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Managing: Git, Conda, CMake and all that; Release Procedures. Release Procedures¶. Annual¶. On January first; Update copyright year; Update counter scripts. Pre-Release (e.g., v1.3rc1)¶. Update samples; Collect new authors; Anticipate next release; Build Conda ecosystem stack; Tag (pre)release; Build extra Conda packages for Psi4 channel; Build Psi4conda set; Generate download page for psicode.org. Release (e.g., v1.3)¶. Update samples (if no prerelease); Collect new authors (if no prerelease); Anticipate next release (if no prerelease); Build Conda ecosystem stack (if no prerelease); Run long tests; Do final pass before release tag; Tag (pre)release; Initialize release branch; Build extra Conda packages for Psi4 channel; Build Psi4conda set; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub release; Publish psicode.org release; Finalize release. Post-Release (e.g., v1.8.2)¶. Assemble postrelease changes; Tweak Conda for postrelease; Tag postrelease; Build Psi4conda set; Build extra Conda packages for Psi4 channel; Generate download page for psicode.org; Collect documentation snapshot; Publish GitHub postrelease; Publish psicode.org release; Finalize release. On January first¶. Screenshot https://anaconda.org/psi4/psi4 .; Screenshot https://anaconda.org/conda-forge/psi4 .; Add new year title and images to website; https://github.com/psi4/psicode-hugo-website/edit/master/content/posts/downloads.md .; On the next day, check that the new year’s plot appears at https://psicode.netlify.app/posts/downloads/ . Update copyright year¶. cd ~/path/to/psi4; Primary target is licenses. grep -rl ""(c) 2007-2017"" * | xargs sed -i '' ""s/(c) 2007-2017/(c) 2007-2018/g""; On Linux, drop the '' in above command; Need to do psi4/ and docs/ dirs. Also, license in these files. tests/runtest.py; README.md. Also, in content of psi4/doc/sphinxman/source/conf.py.in#L1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/manage_release.html:694,test,tests,694,psi4manual/1.9.x/manage_release.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/manage_release.html,1,['test'],['tests']
Testability,"﻿. SYMM_TOL. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; OPTKING; SYMM_TOL. SYMM_TOL¶. Symmetry tolerance for testing whether a mode is symmetric. Type: conv double; Default: 0.05. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; OPTKING; SYMM_TOL. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/optking__symm_tol-1.html:166,test,testing,166,psi4manual/1.4.0/autodir_options_c/optking__symm_tol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/optking__symm_tol-1.html,2,['test'],['testing']
Testability,"﻿. SYMM_TOL. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; OPTKING; SYMM_TOL. SYMM_TOL¶. Symmetry tolerance for testing whether a mode is symmetric. Type: conv double; Default: 0.05. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; OPTKING; SYMM_TOL. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/optking__symm_tol-1.html:166,test,testing,166,psi4manual/1.5.0/autodir_options_c/optking__symm_tol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/optking__symm_tol-1.html,2,['test'],['testing']
Testability,"﻿. SYMM_TOL. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; OPTKING; SYMM_TOL. SYMM_TOL¶. Symmetry tolerance for testing whether a mode is symmetric. Type: conv double; Default: 0.05. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; OPTKING; SYMM_TOL. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/optking__symm_tol.html:166,test,testing,166,psi4manual/1.6.x/autodir_options_c/optking__symm_tol.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/optking__symm_tol.html,1,['test'],['testing']
Testability,"﻿. TEST_B — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices »; Keywords by Module »; OPTKING ». TEST_B¶. Do test B matrix?. Type: boolean; Default: false. Previous topic; STEP_TYPE; Next topic; TEST_DERIVATIVE_B; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices »; Keywords by Module »; OPTKING ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/optking__test_b-1.html:166,test,test,166,psi4manual/4.0b2/autodir_options_c/optking__test_b-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/optking__test_b-1.html,2,['test'],['test']
Testability,"﻿. TEST_B — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Keywords by Module »; OPTKING ». TEST_B¶. Do test B matrix?. Type: boolean; Default: false. Previous topic; STEP_TYPE; Next topic; TEST_DERIVATIVE_B; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Keywords by Module »; OPTKING ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/optking__test_b-1.html:181,test,test,181,psi4manual/4.0b3/autodir_options_c/optking__test_b-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/optking__test_b-1.html,2,['test'],['test']
Testability,"﻿. TEST_B — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices »; Keywords by Module »; OPTKING ». TEST_B¶. Do test B matrix?. Type: boolean; Default: false. Previous topic; STEP_TYPE; Next topic; TEST_DERIVATIVE_B; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices »; Keywords by Module »; OPTKING ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/optking__test_b-1.html:181,test,test,181,psi4manual/4.0b4/autodir_options_c/optking__test_b-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/optking__test_b-1.html,2,['test'],['test']
Testability,"﻿. TEST_B — PSI4 [beta5] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Appendices »; Keywords by Module »; OPTKING ». TEST_B¶. Do test B matrix?. Type: boolean; Default: false. Previous topic; STEP_TYPE; Next topic; TEST_DERIVATIVE_B; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Appendices »; Keywords by Module »; OPTKING ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/optking__test_b-1.html:181,test,test,181,psi4manual/4.0b5/autodir_options_c/optking__test_b-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/optking__test_b-1.html,2,['test'],['test']
Testability,"﻿. TEST_B — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Keywords by Module »; OPTKING ». TEST_B¶. Do test B matrix?. Type: boolean; Default: false. Previous topic; STEP_TYPE; Next topic; TEST_DERIVATIVE_B. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Keywords by Module »; OPTKING ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/optking__test_b-1.html:188,test,test,188,psi4manual/1.0.0/autodir_options_c/optking__test_b-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/optking__test_b-1.html,2,['test'],['test']
Testability,"﻿. TEST_B. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_B. TEST_B¶. Do test B matrix?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_B. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/optking__test_b.html:149,test,test,149,psi4manual/master/autodir_options_c/optking__test_b.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/optking__test_b.html,1,['test'],['test']
Testability,"﻿. TEST_B. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_B. TEST_B¶. Do test B matrix?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_B. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/optking__test_b-1.html:140,test,test,140,psi4manual/1.4.0/autodir_options_c/optking__test_b-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/optking__test_b-1.html,2,['test'],['test']
Testability,"﻿. TEST_B. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_B. TEST_B¶. Do test B matrix?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_B. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/optking__test_b-1.html:140,test,test,140,psi4manual/1.5.0/autodir_options_c/optking__test_b-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/optking__test_b-1.html,2,['test'],['test']
Testability,"﻿. TEST_B. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_B. TEST_B¶. Do test B matrix?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_B. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/optking__test_b.html:140,test,test,140,psi4manual/1.6.x/autodir_options_c/optking__test_b.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/optking__test_b.html,1,['test'],['test']
Testability,"﻿. TEST_B. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_B. TEST_B¶. Do test B matrix?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_B. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/optking__test_b.html:140,test,test,140,psi4manual/1.7.x/autodir_options_c/optking__test_b.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/optking__test_b.html,1,['test'],['test']
Testability,"﻿. TEST_B. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_B. TEST_B¶. Do test B matrix?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_B. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/optking__test_b.html:142,test,test,142,psi4manual/1.8.x/autodir_options_c/optking__test_b.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/optking__test_b.html,1,['test'],['test']
Testability,"﻿. TEST_B. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_B. TEST_B¶. Do test B matrix?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_B. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/optking__test_b.html:142,test,test,142,psi4manual/1.9.x/autodir_options_c/optking__test_b.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/optking__test_b.html,1,['test'],['test']
Testability,"﻿. TEST_DERIVATIVE_B — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices »; Keywords by Module »; OPTKING ». TEST_DERIVATIVE_B¶. Do test derivative B matrix?. Type: boolean; Default: false. Previous topic; TEST_B; Next topic; PSIMRCC; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices »; Keywords by Module »; OPTKING ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/optking__test_derivative_b-1.html:188,test,test,188,psi4manual/4.0b2/autodir_options_c/optking__test_derivative_b-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/optking__test_derivative_b-1.html,2,['test'],['test']
Testability,"﻿. TEST_DERIVATIVE_B — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Keywords by Module »; OPTKING ». TEST_DERIVATIVE_B¶. Do test derivative B matrix?. Type: boolean; Default: false. Previous topic; TEST_B; Next topic; PSIMRCC; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Keywords by Module »; OPTKING ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/optking__test_derivative_b-1.html:203,test,test,203,psi4manual/4.0b3/autodir_options_c/optking__test_derivative_b-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/optking__test_derivative_b-1.html,2,['test'],['test']
Testability,"﻿. TEST_DERIVATIVE_B — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices »; Keywords by Module »; OPTKING ». TEST_DERIVATIVE_B¶. Do test derivative B matrix?. Type: boolean; Default: false. Previous topic; TEST_B; Next topic; PSIMRCC; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices »; Keywords by Module »; OPTKING ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/optking__test_derivative_b-1.html:203,test,test,203,psi4manual/4.0b4/autodir_options_c/optking__test_derivative_b-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/optking__test_derivative_b-1.html,2,['test'],['test']
Testability,"﻿. TEST_DERIVATIVE_B — PSI4 [beta5] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Appendices »; Keywords by Module »; OPTKING ». TEST_DERIVATIVE_B¶. Do test derivative B matrix?. Type: boolean; Default: false. Previous topic; TEST_B; Next topic; PSIMRCC; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Appendices »; Keywords by Module »; OPTKING ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/optking__test_derivative_b-1.html:203,test,test,203,psi4manual/4.0b5/autodir_options_c/optking__test_derivative_b-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/optking__test_derivative_b-1.html,2,['test'],['test']
Testability,"﻿. TEST_DERIVATIVE_B — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Keywords by Module »; OPTKING ». TEST_DERIVATIVE_B¶. Do test derivative B matrix?. Type: boolean; Default: false. Previous topic; TEST_B; Next topic; PSIMRCC. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Keywords by Module »; OPTKING ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/optking__test_derivative_b-1.html:210,test,test,210,psi4manual/1.0.0/autodir_options_c/optking__test_derivative_b-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/optking__test_derivative_b-1.html,2,['test'],['test']
Testability,"﻿. TEST_DERIVATIVE_B. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_DERIVATIVE_B. TEST_DERIVATIVE_B¶. Do test derivative B matrix?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_DERIVATIVE_B. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/optking__test_derivative_b.html:182,test,test,182,psi4manual/master/autodir_options_c/optking__test_derivative_b.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/optking__test_derivative_b.html,1,['test'],['test']
Testability,"﻿. TEST_DERIVATIVE_B. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_DERIVATIVE_B. TEST_DERIVATIVE_B¶. Do test derivative B matrix?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_DERIVATIVE_B. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/optking__test_derivative_b-1.html:173,test,test,173,psi4manual/1.4.0/autodir_options_c/optking__test_derivative_b-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/optking__test_derivative_b-1.html,2,['test'],['test']
Testability,"﻿. TEST_DERIVATIVE_B. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_DERIVATIVE_B. TEST_DERIVATIVE_B¶. Do test derivative B matrix?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_DERIVATIVE_B. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/optking__test_derivative_b-1.html:173,test,test,173,psi4manual/1.5.0/autodir_options_c/optking__test_derivative_b-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/optking__test_derivative_b-1.html,2,['test'],['test']
Testability,"﻿. TEST_DERIVATIVE_B. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_DERIVATIVE_B. TEST_DERIVATIVE_B¶. Do test derivative B matrix?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_DERIVATIVE_B. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/optking__test_derivative_b.html:173,test,test,173,psi4manual/1.6.x/autodir_options_c/optking__test_derivative_b.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/optking__test_derivative_b.html,1,['test'],['test']
Testability,"﻿. TEST_DERIVATIVE_B. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_DERIVATIVE_B. TEST_DERIVATIVE_B¶. Do test derivative B matrix?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_DERIVATIVE_B. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/optking__test_derivative_b.html:173,test,test,173,psi4manual/1.7.x/autodir_options_c/optking__test_derivative_b.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/optking__test_derivative_b.html,1,['test'],['test']
Testability,"﻿. TEST_DERIVATIVE_B. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_DERIVATIVE_B. TEST_DERIVATIVE_B¶. Do test derivative B matrix?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_DERIVATIVE_B. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/optking__test_derivative_b.html:175,test,test,175,psi4manual/1.8.x/autodir_options_c/optking__test_derivative_b.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/optking__test_derivative_b.html,1,['test'],['test']
Testability,"﻿. TEST_DERIVATIVE_B. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_DERIVATIVE_B. TEST_DERIVATIVE_B¶. Do test derivative B matrix?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; OPTKING; TEST_DERIVATIVE_B. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/optking__test_derivative_b.html:175,test,test,175,psi4manual/1.9.x/autodir_options_c/optking__test_derivative_b.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/optking__test_derivative_b.html,1,['test'],['test']
Testability,"﻿. Test Suite and Sample Inputs — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices ». Test Suite and Sample Inputs¶; PSI4 is distributed with an extensive test suite, which can be found in; psi4/tests. After building the source code, these can automatically be; run by running make tests in the compilation directory. Sample input; files can be found in the the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below. Input File; Description. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in CH2. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. min_input; This checks that all energy methods can run with a minimal input and set symmetry. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. fd-gradient; SCF STO-3G finite-difference tests. scf6; Tests RHF/ROHF/UHF SCF gradients. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. mcscf1; ROHF 6-31G** energy of the state of CH2, with Z-matrix input. The occupations are specified explicitly. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dcft2; DCFT-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc32; CC3/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. dcft4; DCFT calculation for the HF+ using DCFT-06 functional. This performs both two-step and simultaneous update of the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/testsuite-1.html:212,test,test,212,psi4manual/4.0b2/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/testsuite-1.html,8,['test'],"['test', 'tests']"
Testability,"﻿. Test Suite and Sample Inputs — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices ». Test Suite and Sample Inputs¶; PSI4 is distributed with an extensive test suite, which can be found in; psi4/tests. After building the source code, these can automatically be; run by running make tests in the compilation directory. Sample input; files can be found in the the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below. Input File; Description. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in CH2. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. min_input; This checks that all energy methods can run with a minimal input and set symmetry. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. fd-gradient; SCF STO-3G finite-difference tests. scf6; Tests RHF/ROHF/UHF SCF gradients. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. mcscf1; ROHF 6-31G** energy of the state of CH2, with Z-matrix input. The occupations are specified explicitly. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dcft2; DCFT-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/testsuite-1.html:227,test,test,227,psi4manual/4.0b3/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/testsuite-1.html,6,['test'],"['test', 'tests']"
Testability,"﻿. Test Suite and Sample Inputs — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices ». Test Suite and Sample Inputs¶; PSI4 is distributed with an extensive test suite, which can be found in; psi4/tests. After building the source code, these can automatically be; run by running make tests in the compilation directory. Sample input; files can be found in the the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below. Input File; Description. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. fnocc2; Test G2 method for H2O. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in CH2. fnocc4; Test FNO-DF-CCSD(T) energy. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. min_input; This checks that all energy methods can run with a minimal input and set symmetry. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF. omp2_5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. fd-gradient; SCF STO-3G finite-difference tests. scf6; Tests RHF/ROHF/UHF SCF gradients. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. mcscf1; ROHF 6-31G** energy of the state of CH2, with Z-matrix input. The occupations are specified explicitly. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. sapt5; SAPT0 aug-cc-pVTZ ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/testsuite-1.html:227,test,test,227,psi4manual/4.0b4/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/testsuite-1.html,8,['test'],"['test', 'tests']"
Testability,"﻿. Test Suite and Sample Inputs — PSI4 [beta5] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Appendices ». Test Suite and Sample Inputs¶; PSI4 is distributed with an extensive test suite, which can be found in; psi4/tests. After building the source code, these can automatically be; run by running make tests in the compilation directory. Sample input; files can be found in the the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below. Input File; Description. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. fnocc2; Test G2 method for H2O. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in CH2. fnocc4; Test FNO-DF-CCSD(T) energy. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. min_input; This checks that all energy methods can run with a minimal input and set symmetry. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF. omp2_5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. fd-gradient; SCF STO-3G finite-difference tests. scf6; Tests RHF/ROHF/UHF SCF gradients. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. mcscf1; ROHF 6-31G** energy of the state of CH2, with Z-matrix input. The occupations are specified explicitly. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. sapt5; SAPT0 aug-cc-pVTZ ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/testsuite-1.html:227,test,test,227,psi4manual/4.0b5/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/testsuite-1.html,8,['test'],"['test', 'tests']"
Testability,"﻿. Test Suite and Sample Inputs — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices ». Test Suite and Sample Inputs¶; Psi4 is distributed with an extensive test suite, which can; be found in psi4/tests. After building the source code, these; can automatically be run by running ctest in the compilation; directory. More info on ctest options can be found on the; Wiki. Sample input files; can be found in the the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. DFTD3; MRCC; CFOUR; LIBEFP; PCMSOLVER; DMRG. Sample inputs for Psi4 as distributed are below. Input File; Description. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). soscf2; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. dcft-grad1; DCFT DC-06 gradient for the O2 molecule with cc-pVDZ basis set. pubchem2; Superficial test of PubChem interface. cepa-module; routing check on lccd, lccsd, cepa(0). cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/testsuite-1.html:234,test,test,234,psi4manual/1.0.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/testsuite-1.html,4,['test'],"['test', 'tests']"
Testability,"﻿. Test Suite and Sample Inputs. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Test Suite and Sample Inputs. Test Suite and Sample Inputs¶; PSI4 is distributed with an extensive test suite, which can; be found in psi4/tests. After building the source code, these; can automatically be run by running ctest in the compilation; directory. More info on ctest options can be found; here. Sample input files; can be found in the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. BRIANQC; CFOUR; CHEMPS2; COOKBOOK; DFTD3; DFTD4; DKH; LIBEFP; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. dft-freq-analytic2; Analytic UKS SVWN frequencies, compared to finite difference values. numpy-array-interface; Numpy interface testing. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. remp-energy1; integral conventional REMP/cc-pVDZ energies for the H2O molecule. results were independently verified against the initial wavels implementation. fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C pa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/testsuite.html:1016,test,testing,1016,psi4manual/master/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/master/testsuite.html,1,['test'],['testing']
Testability,"﻿. Test Suite and Sample Inputs. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Test Suite and Sample Inputs. Test Suite and Sample Inputs¶; PSI4 is distributed with an extensive test suite, which can; be found in psi4/tests. After building the source code, these; can automatically be run by running ctest in the compilation; directory. More info on ctest options can be found; here. Sample input files; can be found in the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. BRIANQC; CFOUR; CHEMPS2; COOKBOOK; DFTD3; DFTD4; DKH; LIBEFP; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. dft-freq-analytic2; Analytic UKS SVWN frequencies, compared to finite difference values. numpy-array-interface; Numpy interface testing. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. remp-energy1; integral conventional REMP/cc-pVDZ energies for the H2O molecule. results were independently verified against the initial wavels implementation. fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C par",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/testsuite.html:221,test,test,221,psi4manual/master/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/master/testsuite.html,2,['test'],"['test', 'tests']"
Testability,"﻿. Test Suite and Sample Inputs. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices. Test Suite and Sample Inputs¶; PSI4 is distributed with an extensive test suite, which can; be found in psi4/tests. After building the source code, these; can automatically be run by running ctest in the compilation; directory. More info on ctest options can be found; here. Sample input files; can be found in the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. CFOUR; CHEMPS2; DFTD3; DKH; LIBEFP; ERD; GDMA; MRCC; PCMSOLVER. Sample inputs for PSI4 as distributed are below. Input File; Description. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. opt11; Transition-state optimizations of HOOH to both torsional transition states. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. casscf-sp; CASSCF/6-31G** energy point. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:182,test,test,182,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['test'],"['test', 'tests']"
Testability,"﻿. Test Suite and Sample Inputs. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices. Test Suite and Sample Inputs¶; PSI4 is distributed with an extensive test suite, which can; be found in psi4/tests. After building the source code, these; can automatically be run by running ctest in the compilation; directory. More info on ctest options can be found; here. Sample input files; can be found in the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. CFOUR; CHEMPS2; COOKBOOK; DFTD3; DKH; LIBEFP; ERD; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. opt11; Transition-state optimizations of HOOH to both torsional transition states. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. casscf-sp; CASSCF/6-31G** energy point. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dfscf-bz2; Benzene Dimer DF-HF/cc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/testsuite-1.html:184,test,test,184,psi4manual/1.2.1/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/testsuite-1.html,4,['test'],"['test', 'tests']"
Testability,"﻿. Test Suite and Sample Inputs. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices. Test Suite and Sample Inputs¶; PSI4 is distributed with an extensive test suite, which can; be found in psi4/tests. After building the source code, these; can automatically be run by running ctest in the compilation; directory. More info on ctest options can be found; here. Sample input files; can be found in the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. CFOUR; CHEMPS2; COOKBOOK; DFTD3; DKH; LIBEFP; ERD; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. cubeprop-frontier; ROHF frontier orbitals of CH2(s) and CH2(t). mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. opt11; Transition-state optimizations of HOOH to both torsional transition states. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. casscf-sp; CASSCF/6-31G** energy point. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fd-freq-gradient; SCF STO-3G finite-differences frequenc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/testsuite-1.html:184,test,test,184,psi4manual/1.3.2/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/testsuite-1.html,4,['test'],"['test', 'tests']"
Testability,"﻿. Test Suite and Sample Inputs. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Test Suite and Sample Inputs. Test Suite and Sample Inputs¶; PSI4 is distributed with an extensive test suite, which can; be found in psi4/tests. After building the source code, these; can automatically be run by running ctest in the compilation; directory. More info on ctest options can be found; here. Sample input files; can be found in the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. ADCC; BRIANQC; CFOUR; CHEMPS2; COOKBOOK; DFTD3; DKH; LIBEFP; ERD; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. cubeprop; RHF orbitals and density for water. dft1-alt; DFT Functional Test. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. opt-multi-frozen-dimer-c2h; Frozen-fragment opt of C2h methane dimer with user-combined reference points. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. opt8; Various constrained energy minimizations of HOOH with cc-pvdz",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/testsuite-1.html:212,test,test,212,psi4manual/1.4.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/testsuite-1.html,4,['test'],"['test', 'tests']"
Testability,"﻿. Test Suite and Sample Inputs. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Test Suite and Sample Inputs. Test Suite and Sample Inputs¶; PSI4 is distributed with an extensive test suite, which can; be found in psi4/tests. After building the source code, these; can automatically be run by running ctest in the compilation; directory. More info on ctest options can be found; here. Sample input files; can be found in the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. ADCC; BRIANQC; CFOUR; CHEMPS2; COOKBOOK; DFTD3; DKH; LIBEFP; ERD; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. tdscf-5; td-camb3lyp with DiskDF and method/basis specification. scf-cholesky-basis; incremental Cholesky filtered SCF. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. scf-upcast-custom-basis; test scf castup with custom basis sets. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. cisd-sp-2; 6-31G** H2O T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/testsuite-1.html:212,test,test,212,psi4manual/1.5.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/testsuite-1.html,6,['test'],"['test', 'tests']"
Testability,"﻿. Test Suite and Sample Inputs. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Test Suite and Sample Inputs. Test Suite and Sample Inputs¶; PSI4 is distributed with an extensive test suite, which can; be found in psi4/tests. After building the source code, these; can automatically be run by running ctest in the compilation; directory. More info on ctest options can be found; here. Sample input files; can be found in the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. BRIANQC; CFOUR; CHEMPS2; COOKBOOK; DFTD3; DFTD4; DKH; LIBEFP; ERD; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. tdscf-7; TD-HF test variable access. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). tdscf-4; td-wb97x singlet excitation energies of methylene (tda). fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. tdscf-1; td-uhf test on triplet states of methylene (rpa). zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. cubeprop; RHF orbitals and density for water. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega= (589 355 nm). cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). pywrap-checkrun-convcrit; Advanced python example set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/testsuite.html:212,test,test,212,psi4manual/1.6.x/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/testsuite.html,2,['test'],"['test', 'tests']"
Testability,"﻿. Test Suite and Sample Inputs. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Test Suite and Sample Inputs. Test Suite and Sample Inputs¶; PSI4 is distributed with an extensive test suite, which can; be found in psi4/tests. After building the source code, these; can automatically be run by running ctest in the compilation; directory. More info on ctest options can be found; here. Sample input files; can be found in the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. BRIANQC; CFOUR; CHEMPS2; COOKBOOK; DFTD3; DFTD4; DKH; LIBEFP; ERD; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). mp2-1; All-electron MP2 6-31G** geometry optimization of water. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. pubchem2; Superficial test of PubChem interface. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. lccd-grad2; LCCD cc-pVDZ gradient for the NO radical. aediis-1; ADIIS test case, from 10.1063/1.3304922. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, ex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/testsuite.html:212,test,test,212,psi4manual/1.7.x/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/testsuite.html,2,['test'],"['test', 'tests']"
Testability,"﻿. Test Suite and Sample Inputs. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Test Suite and Sample Inputs. Test Suite and Sample Inputs¶; PSI4 is distributed with an extensive test suite, which can; be found in psi4/tests. After building the source code, these; can automatically be run by running ctest in the compilation; directory. More info on ctest options can be found; here. Sample input files; can be found in the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. BRIANQC; CFOUR; CHEMPS2; COOKBOOK; DFTD3; DFTD4; DKH; LIBEFP; ERD; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. fci-h2o-2; 6-31G H2O Test FCI Energy Point. fd-gradient; SCF STO-3G finite-difference tests. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. phi-ao; Test computing values of basis functions (puream and non-puream) at points. dfcasscf-sp; CASSCF/6-31G** energy point. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. sapt-dft2; SAPT(DFT) aug-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/testsuite.html:214,test,test,214,psi4manual/1.8.x/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/testsuite.html,2,['test'],"['test', 'tests']"
Testability,"﻿. Test Suite and Sample Inputs. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Test Suite and Sample Inputs. Test Suite and Sample Inputs¶; PSI4 is distributed with an extensive test suite, which can; be found in psi4/tests. After building the source code, these; can automatically be run by running ctest in the compilation; directory. More info on ctest options can be found; here. Sample input files; can be found in the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. BRIANQC; CFOUR; CHEMPS2; COOKBOOK; DFTD3; DFTD4; DKH; LIBEFP; ERD; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. fd-gradient; SCF STO-3G finite-difference tests. cc36; CC2(RHF)/cc-pVDZ energy of H2O. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/testsuite.html:214,test,test,214,psi4manual/1.9.x/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/testsuite.html,2,['test'],"['test', 'tests']"
Testability,"﻿. Test Suite. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Test Suite. Test Suite¶; A test suite plays a vital role in open-source software use and development. For a PSI4 user, tests provide models of inputs that should work; “as-is” and a searchable collection of syntax and capabilities.; The test suite also allows high-quality development snapshots of the; codebase to be built automatically for users.; For a user who has PSI4 as part of a complex computational molecular software environment, a test suite alongside installed PSI4 can be used to show that the PSI4 piece is working.; For a feature developer, adding tests provides confidence that you; can leave your code untouched and still advertise that the feature works; years later. With tests, proposed changes to PSI4 that break your; code fall upon the change proposer to fix, rather than being merged; silently and lying in wait for a concientious user to detect and report; and then likely falling upon you to fix.; For a general developer, the test suite allows confidence in refactoring, switching out underlying libraries, maintenance, and upgrading. CTest and pytest, PSIthon and PsiAPI¶; In designing a test, sometimes you want it to be a model input for the user in a single file or you don’t want a lot of psi4. or Python syntax cluttering the input.; In this case, follow Adding PSIthon Test Cases to prepare as PSIthon (psi4 input.dat) for, roughly speaking, running through ctest.; The PSIthon/CTest test suite occupies the whole of psi4/tests except psi4/tests/pytests.; At other times you want the test to check several variations of a template job or you want to test error handling or you want to focus on PsiAPI rather than PSIthon or you want to control the compute conditions with environment variables.; In this case, follow Adding PsiAPI Test Cases to prepare as PsiAPI (import psi4) for, roughly speaking, running through pytest.; The PsiAPI/pytest test suite occupies psi4/tests/",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/add_tests.html:119,test,test,119,psi4manual/master/add_tests.html,https://psicode.org,https://psicode.org/psi4manual/master/add_tests.html,6,['test'],"['test', 'tests']"
Testability,"﻿. Test Suite. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Test Suite. Test Suite¶; A test suite plays a vital role in open-source software use and development. For a PSI4 user, tests provide models of inputs that should work; “as-is” and a searchable collection of syntax and capabilities.; The test suite also allows high-quality development snapshots of the; codebase to be built automatically for users.; For a user who has PSI4 as part of a complex computational molecular software environment, a test suite alongside installed PSI4 can be used to show that the PSI4 piece is working.; For a feature developer, adding tests provides confidence that you; can leave your code untouched and still advertise that the feature works; years later. With tests, proposed changes to PSI4 that break your; code fall upon the change proposer to fix, rather than being merged; silently and lying in wait for a concientious user to detect and report; and then likely falling upon you to fix.; For a general developer, the test suite allows confidence in refactoring, switching out underlying libraries, maintenance, and upgrading. CTest and pytest, PSIthon and PsiAPI¶; In designing a test, sometimes you want it to be a model input for the user in a single file or you don’t want a lot of psi4. or Python syntax cluttering the input.; In this case, follow Adding PSIthon Test Cases to prepare as PSIthon (psi4 input.dat) for, roughly speaking, running through ctest.; The PSIthon/CTest test suite occupies the whole of psi4/tests except psi4/tests/pytests.; At other times you want the test to check several variations of a template job or you want to test error handling or you want to focus on PsiAPI rather than PSIthon or you want to control the compute conditions with environment variables.; In this case, follow Adding PsiAPI Test Cases to prepare as PsiAPI (import psi4) for, roughly speaking, running through pytest.; The PsiAPI/pytest test suite occupies psi4/tests/pytests.;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/add_tests.html:110,test,test,110,psi4manual/1.6.x/add_tests.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/add_tests.html,6,['test'],"['test', 'tests']"
Testability,"﻿. Test Suite. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Test Suite. Test Suite¶; A test suite plays a vital role in open-source software use and development. For a PSI4 user, tests provide models of inputs that should work; “as-is” and a searchable collection of syntax and capabilities.; The test suite also allows high-quality development snapshots of the; codebase to be built automatically for users.; For a user who has PSI4 as part of a complex computational molecular software environment, a test suite alongside installed PSI4 can be used to show that the PSI4 piece is working.; For a feature developer, adding tests provides confidence that you; can leave your code untouched and still advertise that the feature works; years later. With tests, proposed changes to PSI4 that break your; code fall upon the change proposer to fix, rather than being merged; silently and lying in wait for a concientious user to detect and report; and then likely falling upon you to fix.; For a general developer, the test suite allows confidence in refactoring, switching out underlying libraries, maintenance, and upgrading. CTest and pytest, PSIthon and PsiAPI¶; In designing a test, sometimes you want it to be a model input for the user in a single file or you don’t want a lot of psi4. or Python syntax cluttering the input.; In this case, follow Adding PSIthon Test Cases to prepare as PSIthon (psi4 input.dat) for, roughly speaking, running through ctest.; The PSIthon/CTest test suite occupies the whole of psi4/tests except psi4/tests/pytests.; At other times you want the test to check several variations of a template job or you want to test error handling or you want to focus on PsiAPI rather than PSIthon or you want to control the compute conditions with environment variables.; In this case, follow Adding PsiAPI Test Cases to prepare as PsiAPI (import psi4) for, roughly speaking, running through pytest.; The PsiAPI/pytest test suite occupies psi4/tests/pytests.;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/add_tests.html:110,test,test,110,psi4manual/1.7.x/add_tests.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/add_tests.html,6,['test'],"['test', 'tests']"
Testability,"﻿. Test Suite. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Test Suite. Test Suite¶; A test suite plays a vital role in open-source software use and development. For a PSI4 user, tests provide models of inputs that should work; “as-is” and a searchable collection of syntax and capabilities.; The test suite also allows high-quality development snapshots of the; codebase to be built automatically for users.; For a user who has PSI4 as part of a complex computational molecular software environment, a test suite alongside installed PSI4 can be used to show that the PSI4 piece is working.; For a feature developer, adding tests provides confidence that you; can leave your code untouched and still advertise that the feature works; years later. With tests, proposed changes to PSI4 that break your; code fall upon the change proposer to fix, rather than being merged; silently and lying in wait for a concientious user to detect and report; and then likely falling upon you to fix.; For a general developer, the test suite allows confidence in refactoring, switching out underlying libraries, maintenance, and upgrading. CTest and pytest, PSIthon and PsiAPI¶; In designing a test, sometimes you want it to be a model input for the user in a single file or you don’t want a lot of psi4. or Python syntax cluttering the input.; In this case, follow Adding PSIthon Test Cases to prepare as PSIthon (psi4 input.dat) for, roughly speaking, running through ctest.; The PSIthon/CTest test suite occupies the whole of psi4/tests except psi4/tests/pytests.; At other times you want the test to check several variations of a template job or you want to test error handling or you want to focus on PsiAPI rather than PSIthon or you want to control the compute conditions with environment variables.; In this case, follow Adding PsiAPI Test Cases to prepare as PsiAPI (import psi4) for, roughly speaking, running through pytest.; The PsiAPI/pytest test suite occupies psi4/tests/pytests",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/add_tests.html:112,test,test,112,psi4manual/1.8.x/add_tests.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/add_tests.html,6,['test'],"['test', 'tests']"
Testability,"﻿. Test Suite. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Test Suite. Test Suite¶; A test suite plays a vital role in open-source software use and development. For a PSI4 user, tests provide models of inputs that should work; “as-is” and a searchable collection of syntax and capabilities.; The test suite also allows high-quality development snapshots of the; codebase to be built automatically for users.; For a user who has PSI4 as part of a complex computational molecular software environment, a test suite alongside installed PSI4 can be used to show that the PSI4 piece is working.; For a feature developer, adding tests provides confidence that you; can leave your code untouched and still advertise that the feature works; years later. With tests, proposed changes to PSI4 that break your; code fall upon the change proposer to fix, rather than being merged; silently and lying in wait for a concientious user to detect and report; and then likely falling upon you to fix.; For a general developer, the test suite allows confidence in refactoring, switching out underlying libraries, maintenance, and upgrading. CTest and pytest, PSIthon and PsiAPI¶; In designing a test, sometimes you want it to be a model input for the user in a single file or you don’t want a lot of psi4. or Python syntax cluttering the input.; In this case, follow Adding PSIthon Test Cases to prepare as PSIthon (psi4 input.dat) for, roughly speaking, running through ctest.; The PSIthon/CTest test suite occupies the whole of psi4/tests except psi4/tests/pytests.; At other times you want the test to check several variations of a template job or you want to test error handling or you want to focus on PsiAPI rather than PSIthon or you want to control the compute conditions with environment variables.; In this case, follow Adding PsiAPI Test Cases to prepare as PsiAPI (import psi4) for, roughly speaking, running through pytest.; The PsiAPI/pytest test suite occupies psi4/tests/pytests",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/add_tests.html:112,test,test,112,psi4manual/1.9.x/add_tests.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/add_tests.html,6,['test'],"['test', 'tests']"
Testability,"﻿. TestComparisonError. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. TestComparisonError¶. exception psi4.driver.TestComparisonError(msg)[source]¶; Bases: psi4.driver.p4util.exceptions.PsiException; Error called when a test case fails due to a failed; compare_values() call. Prints error message msg to standard; output stream and output file. args¶. with_traceback()¶; Exception.with_traceback(tb) –; set self.__traceback__ to tb and return self. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.testcomparisonerror.html:278,test,test,278,psi4manual/1.2.1/api/psi4.driver.testcomparisonerror.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.testcomparisonerror.html,1,['test'],['test']
Testability,"﻿. TestComparisonError. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. TestComparisonError¶. exception psi4.driver.TestComparisonError(msg)[source]¶; Bases: psi4.driver.p4util.exceptions.PsiException; Error called when a test case fails due to a failed; compare_values() call. Prints error message msg to standard; output stream and output file. args¶. with_traceback()¶; Exception.with_traceback(tb) –; set self.__traceback__ to tb and return self. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.testcomparisonerror.html:278,test,test,278,psi4manual/1.3.2/api/psi4.driver.testcomparisonerror.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.testcomparisonerror.html,1,['test'],['test']
Testability,"﻿. TestComparisonError. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; TestComparisonError. TestComparisonError¶. exception psi4.driver.TestComparisonError(msg)[source]¶; Error called when a test case fails due to a failed; compare_values() call. Prints error message msg to standard; output stream and output file. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; TestComparisonError. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.testcomparisonerror.html:246,test,test,246,psi4manual/1.4.0/api/psi4.driver.testcomparisonerror.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.testcomparisonerror.html,1,['test'],['test']
Testability,"﻿. TestComparisonError. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; TestComparisonError. TestComparisonError¶. exception psi4.driver.TestComparisonError(msg)[source]¶; Error called when a test case fails due to a failed; compare_values() call. Prints error message msg to standard; output stream and output file. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; TestComparisonError. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.testcomparisonerror.html:246,test,test,246,psi4manual/1.5.0/api/psi4.driver.testcomparisonerror.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.testcomparisonerror.html,1,['test'],['test']
Testability,"﻿. TestComparisonError. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; TestComparisonError. TestComparisonError¶. exception psi4.driver.TestComparisonError(msg)[source]¶; Error called when a test case fails due to a failed; compare_values() call. Prints error message msg to standard; output stream and output file. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; TestComparisonError. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.TestComparisonError.html:246,test,test,246,psi4manual/1.6.x/api/psi4.driver.TestComparisonError.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.TestComparisonError.html,1,['test'],['test']
Testability,"﻿. USE_DF_INTS — PSI4 [beta5] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Appendices »; Keywords by Module »; FNOCC ». USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. Previous topic; TRIPLES_LOW_MEMORY; Next topic; MCSCF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Appendices »; Keywords by Module »; FNOCC ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/fnocc__use_df_ints-1.html:260,test,testing,260,psi4manual/4.0b5/autodir_options_c/fnocc__use_df_ints-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/fnocc__use_df_ints-1.html,2,['test'],['testing']
Testability,"﻿. USE_DF_INTS — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Keywords by Module »; FNOCC ». USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. Previous topic; TRIPLES_LOW_MEMORY; Next topic; GDMA. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Keywords by Module »; FNOCC ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/fnocc__use_df_ints-1.html:267,test,testing,267,psi4manual/1.0.0/autodir_options_c/fnocc__use_df_ints-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/fnocc__use_df_ints-1.html,2,['test'],['testing']
Testability,"﻿. USE_DF_INTS. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; FNOCC; USE_DF_INTS. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; FNOCC; USE_DF_INTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/fnocc__use_df_ints.html:233,test,testing,233,psi4manual/master/autodir_options_c/fnocc__use_df_ints.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/fnocc__use_df_ints.html,1,['test'],['testing']
Testability,"﻿. USE_DF_INTS. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; FNOCC; USE_DF_INTS. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; FNOCC; USE_DF_INTS. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/fnocc__use_df_ints-1.html:224,test,testing,224,psi4manual/1.4.0/autodir_options_c/fnocc__use_df_ints-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/fnocc__use_df_ints-1.html,2,['test'],['testing']
Testability,"﻿. USE_DF_INTS. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; FNOCC; USE_DF_INTS. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; FNOCC; USE_DF_INTS. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/fnocc__use_df_ints-1.html:224,test,testing,224,psi4manual/1.5.0/autodir_options_c/fnocc__use_df_ints-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/fnocc__use_df_ints-1.html,2,['test'],['testing']
Testability,"﻿. USE_DF_INTS. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; FNOCC; USE_DF_INTS. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; FNOCC; USE_DF_INTS. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/fnocc__use_df_ints.html:224,test,testing,224,psi4manual/1.6.x/autodir_options_c/fnocc__use_df_ints.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/fnocc__use_df_ints.html,1,['test'],['testing']
Testability,"﻿. USE_DF_INTS. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; FNOCC; USE_DF_INTS. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; FNOCC; USE_DF_INTS. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/fnocc__use_df_ints.html:224,test,testing,224,psi4manual/1.7.x/autodir_options_c/fnocc__use_df_ints.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/fnocc__use_df_ints.html,1,['test'],['testing']
Testability,"﻿. USE_DF_INTS. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; FNOCC; USE_DF_INTS. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; FNOCC; USE_DF_INTS. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/fnocc__use_df_ints.html:226,test,testing,226,psi4manual/1.8.x/autodir_options_c/fnocc__use_df_ints.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/fnocc__use_df_ints.html,1,['test'],['testing']
Testability,"﻿. USE_DF_INTS. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; FNOCC; USE_DF_INTS. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; FNOCC; USE_DF_INTS. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/fnocc__use_df_ints.html:226,test,testing,226,psi4manual/1.9.x/autodir_options_c/fnocc__use_df_ints.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/fnocc__use_df_ints.html,1,['test'],['testing']
Testability,"﻿. V2RDM_CASSCF. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Test Suite and Sample Inputs; V2RDM_CASSCF. V2RDM_CASSCF¶. Input File; Description. v2rdm_casscf/v2rdm6; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm5; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm7; STO-3g benzene (6,6) guess orbital rotation test DQG. v2rdm_casscf/v2rdm1; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm2; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm4; v2rdm_casscf 1,4-phenylenedinitrene/(10,10)/cc-pVDZ. v2rdm_casscf/v2rdm3; H3 / cc-pvdz / D+D3 vs full CI, scf_type = PK. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Test Suite and Sample Inputs; V2RDM_CASSCF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_v2rdm_casscf.html:377,test,test,377,psi4manual/master/autodoc_testsuite_v2rdm_casscf.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_v2rdm_casscf.html,1,['test'],['test']
Testability,"﻿. V2RDM_CASSCF. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Test Suite and Sample Inputs. V2RDM_CASSCF¶. Input File; Description. v2rdm_casscf/v2rdm3; H3 / cc-pvdz / D+D3 vs full CI, scf_type = PK. v2rdm_casscf/v2rdm4; v2rdm_casscf 1,4-phenylenedinitrene/(10,10)/cc-pVDZ. v2rdm_casscf/v2rdm6; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm2; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm1; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm7; STO-3g benzene (6,6) guess orbital rotation test DQG. v2rdm_casscf/v2rdm5; cc-pvdz N2 (6,6) active space Test DQG. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Test Suite and Sample Inputs. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_v2rdm_casscf-1.html:559,test,test,559,psi4manual/1.3.2/autodoc_testsuite_v2rdm_casscf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_v2rdm_casscf-1.html,2,['test'],['test']
Testability,"﻿. V2RDM_CASSCF. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Test Suite and Sample Inputs; V2RDM_CASSCF. V2RDM_CASSCF¶. Input File; Description. v2rdm_casscf/v2rdm1; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm7; STO-3g benzene (6,6) guess orbital rotation test DQG. v2rdm_casscf/v2rdm4; v2rdm_casscf 1,4-phenylenedinitrene/(10,10)/cc-pVDZ. v2rdm_casscf/v2rdm5; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm3; H3 / cc-pvdz / D+D3 vs full CI, scf_type = PK. v2rdm_casscf/v2rdm6; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm2; cc-pvdz N2 (6,6) active space Test DQG. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Test Suite and Sample Inputs; V2RDM_CASSCF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_v2rdm_casscf-1.html:307,test,test,307,psi4manual/1.4.0/autodoc_testsuite_v2rdm_casscf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_v2rdm_casscf-1.html,2,['test'],['test']
Testability,"﻿. V2RDM_CASSCF. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Test Suite and Sample Inputs; V2RDM_CASSCF. V2RDM_CASSCF¶. Input File; Description. v2rdm_casscf/v2rdm6; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm4; v2rdm_casscf 1,4-phenylenedinitrene/(10,10)/cc-pVDZ. v2rdm_casscf/v2rdm3; H3 / cc-pvdz / D+D3 vs full CI, scf_type = PK. v2rdm_casscf/v2rdm7; STO-3g benzene (6,6) guess orbital rotation test DQG. v2rdm_casscf/v2rdm1; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm5; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm2; cc-pvdz N2 (6,6) active space Test DQG. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Test Suite and Sample Inputs; V2RDM_CASSCF. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_v2rdm_casscf-1.html:449,test,test,449,psi4manual/1.5.0/autodoc_testsuite_v2rdm_casscf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_v2rdm_casscf-1.html,2,['test'],['test']
Testability,"﻿. V2RDM_CASSCF. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Test Suite and Sample Inputs; V2RDM_CASSCF. V2RDM_CASSCF¶. Input File; Description. v2rdm_casscf/v2rdm5; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm7; STO-3g benzene (6,6) guess orbital rotation test DQG. v2rdm_casscf/v2rdm1; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm3; H3 / cc-pvdz / D+D3 vs full CI, scf_type = PK. v2rdm_casscf/v2rdm2; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm6; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm4; v2rdm_casscf 1,4-phenylenedinitrene/(10,10)/cc-pVDZ. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Test Suite and Sample Inputs; V2RDM_CASSCF. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_v2rdm_casscf.html:307,test,test,307,psi4manual/1.6.x/autodoc_testsuite_v2rdm_casscf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_v2rdm_casscf.html,1,['test'],['test']
Testability,"﻿. V2RDM_CASSCF. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Test Suite and Sample Inputs; V2RDM_CASSCF. V2RDM_CASSCF¶. Input File; Description. v2rdm_casscf/v2rdm3; H3 / cc-pvdz / D+D3 vs full CI, scf_type = PK. v2rdm_casscf/v2rdm6; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm1; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm4; v2rdm_casscf 1,4-phenylenedinitrene/(10,10)/cc-pVDZ. v2rdm_casscf/v2rdm7; STO-3g benzene (6,6) guess orbital rotation test DQG. v2rdm_casscf/v2rdm2; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm5; cc-pvdz N2 (6,6) active space Test DQG. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Test Suite and Sample Inputs; V2RDM_CASSCF. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_v2rdm_casscf.html:510,test,test,510,psi4manual/1.7.x/autodoc_testsuite_v2rdm_casscf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_v2rdm_casscf.html,1,['test'],['test']
Testability,"﻿. V2RDM_CASSCF. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Test Suite and Sample Inputs; V2RDM_CASSCF. V2RDM_CASSCF¶. Input File; Description. v2rdm_casscf/v2rdm6; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm2; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm5; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm4; v2rdm_casscf 1,4-phenylenedinitrene/(10,10)/cc-pVDZ. v2rdm_casscf/v2rdm1; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm7; STO-3g benzene (6,6) guess orbital rotation test DQG. v2rdm_casscf/v2rdm3; H3 / cc-pvdz / D+D3 vs full CI, scf_type = PK. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Test Suite and Sample Inputs; V2RDM_CASSCF. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_v2rdm_casscf.html:566,test,test,566,psi4manual/1.8.x/autodoc_testsuite_v2rdm_casscf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_v2rdm_casscf.html,1,['test'],['test']
Testability,"﻿. V2RDM_CASSCF. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Test Suite and Sample Inputs; V2RDM_CASSCF. V2RDM_CASSCF¶. Input File; Description. v2rdm_casscf/v2rdm1; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm3; H3 / cc-pvdz / D+D3 vs full CI, scf_type = PK. v2rdm_casscf/v2rdm5; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm7; STO-3g benzene (6,6) guess orbital rotation test DQG. v2rdm_casscf/v2rdm2; cc-pvdz N2 (6,6) active space Test DQG. v2rdm_casscf/v2rdm4; v2rdm_casscf 1,4-phenylenedinitrene/(10,10)/cc-pVDZ. v2rdm_casscf/v2rdm6; cc-pvdz N2 (6,6) active space Test DQG. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Test Suite and Sample Inputs; V2RDM_CASSCF. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_v2rdm_casscf.html:438,test,test,438,psi4manual/1.9.x/autodoc_testsuite_v2rdm_casscf.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_v2rdm_casscf.html,1,['test'],['test']
Testability,"﻿. Ways to Add Code: Psi4NumPy, Plugins, Full Integration. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Adding New Code to PSI4. Ways to Add Code: Psi4NumPy, Plugins, Full Integration¶. Easier and more rapid development¶; Fully featured electronic structure programs are large and complex.; However, the Psi4 ecosystem provides a path for easier and more; rapid development of new features.; Overview of what Psi4NumPy and Plugins are. Suggest that Psi4NumPy; might be the easiest and most rapid way to initially test new code.; Then the code could go to a Plugin, which could be subseqently; integrated fully into Psi4, or stay as a Plugin.; There is a separate section that more fully explains plugins. table of contents. Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Easier and more rapid development. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Adding New Code to PSI4. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/prog_ways_to_add-1.html:538,test,test,538,psi4manual/1.3.2/prog_ways_to_add-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/prog_ways_to_add-1.html,2,['test'],['test']
Testability,"﻿. basis_helper. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. basis_helper¶. psi4.driver.basis_helper(block, name='', key='BASIS', set_option=True)[source]¶; Helper to specify a custom basis set in PsiAPI mode.; This function forms a basis specification function from block; and associates it with keyword key under handle name. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and; cc54 test cases. Parameters:. block (str) – Text that goes in a PSIthon basis {...} block.; name (str) – Name label to associated with basis specified by block.; key (str) – Basis keyword specified by block.; set_option (bool) – When True, execute the equivalent of set key name or set_option({key: name}). When False, skip execution. table of contents. basis_helper; basis_helper(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.basis_helper.html:540,test,test,540,psi4manual/master/api/psi4.driver.basis_helper.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.basis_helper.html,1,['test'],['test']
Testability,"﻿. basis_helper. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. basis_helper¶. psi4.driver.p4util.basis_helper(block, name='', key='BASIS', set_option=True)[source]¶; Helper to specify a custom basis set in PsiAPI mode.; This function forms a basis specification function from block; and associates it with keyword key under handle name. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and; cc54 test cases. Parameters:. block (str) – Text that goes in a PSIthon basis {...} block.; name (str) – Name label to associated with basis specified by block.; key (str) – Basis keyword specified by block.; set_option (bool) – When True, execute the equivalent of set key name or set_option({key: name}). When False, skip execution. table of contents. basis_helper; basis_helper(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.p4util.basis_helper.html:547,test,test,547,psi4manual/master/api/psi4.driver.p4util.basis_helper.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.p4util.basis_helper.html,1,['test'],['test']
Testability,"﻿. basis_helper. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. basis_helper¶. psi4.driver.basis_helper(block, name='', key='BASIS', set_option=True)[source]¶; For PsiAPI mode, forms a basis specification function from block; and associates it with keyword key under handle name. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and cc54 test cases. Unless; set_option is False, name will be set as current active key,; equivalent to set key name or set_option({key: name}). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.basis_helper-1.html:467,test,test,467,psi4manual/1.2.1/api/psi4.driver.basis_helper-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.basis_helper-1.html,2,['test'],['test']
Testability,"﻿. basis_helper. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. basis_helper¶. psi4.driver.basis_helper(block, name='', key='BASIS', set_option=True)[source]¶; For PsiAPI mode, forms a basis specification function from block; and associates it with keyword key under handle name. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and cc54 test cases. Unless; set_option is False, name will be set as current active key,; equivalent to set key name or set_option({key: name}). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.basis_helper-1.html:467,test,test,467,psi4manual/1.3.2/api/psi4.driver.basis_helper-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.basis_helper-1.html,2,['test'],['test']
Testability,"﻿. basis_helper. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. basis_helper¶. psi4.driver.basis_helper(block, name='', key='BASIS', set_option=True)[source]¶; For PsiAPI mode, forms a basis specification function from block; and associates it with keyword key under handle name. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and cc54 test cases. Unless; set_option is False, name will be set as current active key,; equivalent to set key name or set_option({key: name}). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.basis_helper-1.html:479,test,test,479,psi4manual/1.4.0/api/psi4.driver.basis_helper-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.basis_helper-1.html,2,['test'],['test']
Testability,"﻿. basis_helper. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. basis_helper¶. psi4.driver.basis_helper(block, name='', key='BASIS', set_option=True)[source]¶; For PsiAPI mode, forms a basis specification function from block; and associates it with keyword key under handle name. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and cc54 test cases. Unless; set_option is False, name will be set as current active key,; equivalent to set key name or set_option({key: name}). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.basis_helper-1.html:479,test,test,479,psi4manual/1.5.0/api/psi4.driver.basis_helper-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.basis_helper-1.html,2,['test'],['test']
Testability,"﻿. basis_helper. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. basis_helper¶. psi4.driver.basis_helper(block, name='', key='BASIS', set_option=True)[source]¶; For PsiAPI mode, forms a basis specification function from block; and associates it with keyword key under handle name. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and cc54 test cases. Unless; set_option is False, name will be set as current active key,; equivalent to set key name or set_option({key: name}). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.basis_helper.html:479,test,test,479,psi4manual/1.6.x/api/psi4.driver.basis_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.basis_helper.html,1,['test'],['test']
Testability,"﻿. basis_helper. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. basis_helper¶. psi4.driver.basis_helper(block, name='', key='BASIS', set_option=True)[source]¶; Helper to specify a custom basis set in PsiAPI mode.; This function forms a basis specification function from block; and associates it with keyword key under handle name. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and; cc54 test cases. Parameters:. block (str) – Text that goes in a PSIthon basis {...} block.; name (str) – Name label to associated with basis specified by block.; key (str) – Basis keyword specified by block.; set_option (bool) – When True, execute the equivalent of set key name or set_option({key: name}). When False, skip execution. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.basis_helper.html:531,test,test,531,psi4manual/1.7.x/api/psi4.driver.basis_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.basis_helper.html,1,['test'],['test']
Testability,"﻿. basis_helper. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. basis_helper¶. psi4.driver.p4util.basis_helper(block, name='', key='BASIS', set_option=True)[source]¶; Helper to specify a custom basis set in PsiAPI mode.; This function forms a basis specification function from block; and associates it with keyword key under handle name. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and; cc54 test cases. Parameters:. block (str) – Text that goes in a PSIthon basis {...} block.; name (str) – Name label to associated with basis specified by block.; key (str) – Basis keyword specified by block.; set_option (bool) – When True, execute the equivalent of set key name or set_option({key: name}). When False, skip execution. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.p4util.basis_helper.html:538,test,test,538,psi4manual/1.7.x/api/psi4.driver.p4util.basis_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.p4util.basis_helper.html,1,['test'],['test']
Testability,"﻿. basis_helper. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. basis_helper¶. psi4.driver.basis_helper(block, name='', key='BASIS', set_option=True)[source]¶; Helper to specify a custom basis set in PsiAPI mode.; This function forms a basis specification function from block; and associates it with keyword key under handle name. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and; cc54 test cases. Parameters:. block (str) – Text that goes in a PSIthon basis {...} block.; name (str) – Name label to associated with basis specified by block.; key (str) – Basis keyword specified by block.; set_option (bool) – When True, execute the equivalent of set key name or set_option({key: name}). When False, skip execution. table of contents. basis_helper; basis_helper(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.basis_helper.html:533,test,test,533,psi4manual/1.8.x/api/psi4.driver.basis_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.basis_helper.html,1,['test'],['test']
Testability,"﻿. basis_helper. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. basis_helper¶. psi4.driver.p4util.basis_helper(block, name='', key='BASIS', set_option=True)[source]¶; Helper to specify a custom basis set in PsiAPI mode.; This function forms a basis specification function from block; and associates it with keyword key under handle name. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and; cc54 test cases. Parameters:. block (str) – Text that goes in a PSIthon basis {...} block.; name (str) – Name label to associated with basis specified by block.; key (str) – Basis keyword specified by block.; set_option (bool) – When True, execute the equivalent of set key name or set_option({key: name}). When False, skip execution. table of contents. basis_helper; basis_helper(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.basis_helper.html:540,test,test,540,psi4manual/1.8.x/api/psi4.driver.p4util.basis_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.basis_helper.html,1,['test'],['test']
Testability,"﻿. basis_helper. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. basis_helper¶. psi4.driver.basis_helper(block, name='', key='BASIS', set_option=True)[source]¶; Helper to specify a custom basis set in PsiAPI mode.; This function forms a basis specification function from block; and associates it with keyword key under handle name. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and; cc54 test cases. Parameters:. block (str) – Text that goes in a PSIthon basis {...} block.; name (str) – Name label to associated with basis specified by block.; key (str) – Basis keyword specified by block.; set_option (bool) – When True, execute the equivalent of set key name or set_option({key: name}). When False, skip execution. table of contents. basis_helper; basis_helper(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.basis_helper.html:533,test,test,533,psi4manual/1.9.x/api/psi4.driver.basis_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.basis_helper.html,1,['test'],['test']
Testability,"﻿. basis_helper. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. basis_helper¶. psi4.driver.p4util.basis_helper(block, name='', key='BASIS', set_option=True)[source]¶; Helper to specify a custom basis set in PsiAPI mode.; This function forms a basis specification function from block; and associates it with keyword key under handle name. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and; cc54 test cases. Parameters:. block (str) – Text that goes in a PSIthon basis {...} block.; name (str) – Name label to associated with basis specified by block.; key (str) – Basis keyword specified by block.; set_option (bool) – When True, execute the equivalent of set key name or set_option({key: name}). When False, skip execution. table of contents. basis_helper; basis_helper(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; basis_helper. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.p4util.basis_helper.html:540,test,test,540,psi4manual/1.9.x/api/psi4.driver.p4util.basis_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.p4util.basis_helper.html,1,['test'],['test']
Testability,"﻿. benchmark_blas1. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1¶. psi4.core.benchmark_blas1(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas1.html:240,benchmark,benchmark,240,psi4manual/master/api/psi4.core.benchmark_blas1.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas1.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_blas1. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1¶. psi4.core.benchmark_blas1(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.benchmark_blas1-1.html:231,benchmark,benchmark,231,psi4manual/1.4.0/api/psi4.core.benchmark_blas1-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.benchmark_blas1-1.html,2,['benchmark'],['benchmark']
Testability,"﻿. benchmark_blas1. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1¶. psi4.core.benchmark_blas1(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.benchmark_blas1-1.html:231,benchmark,benchmark,231,psi4manual/1.5.0/api/psi4.core.benchmark_blas1-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.benchmark_blas1-1.html,2,['benchmark'],['benchmark']
Testability,"﻿. benchmark_blas1. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1¶. psi4.core.benchmark_blas1(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.benchmark_blas1.html:231,benchmark,benchmark,231,psi4manual/1.6.x/api/psi4.core.benchmark_blas1.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.benchmark_blas1.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_blas1. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1¶. psi4.core.benchmark_blas1(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas1.html:231,benchmark,benchmark,231,psi4manual/1.7.x/api/psi4.core.benchmark_blas1.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas1.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_blas1. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1¶. psi4.core.benchmark_blas1(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html:233,benchmark,benchmark,233,psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas1.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_blas1. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1¶. psi4.core.benchmark_blas1(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas1.html:233,benchmark,benchmark,233,psi4manual/1.9.x/api/psi4.core.benchmark_blas1.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas1.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_blas2. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2¶. psi4.core.benchmark_blas2(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas2.html:240,benchmark,benchmark,240,psi4manual/master/api/psi4.core.benchmark_blas2.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas2.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_blas2. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2¶. psi4.core.benchmark_blas2(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.benchmark_blas2-1.html:231,benchmark,benchmark,231,psi4manual/1.4.0/api/psi4.core.benchmark_blas2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.benchmark_blas2-1.html,2,['benchmark'],['benchmark']
Testability,"﻿. benchmark_blas2. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2¶. psi4.core.benchmark_blas2(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.benchmark_blas2-1.html:231,benchmark,benchmark,231,psi4manual/1.5.0/api/psi4.core.benchmark_blas2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.benchmark_blas2-1.html,2,['benchmark'],['benchmark']
Testability,"﻿. benchmark_blas2. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2¶. psi4.core.benchmark_blas2(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.benchmark_blas2.html:231,benchmark,benchmark,231,psi4manual/1.6.x/api/psi4.core.benchmark_blas2.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.benchmark_blas2.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_blas2. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2¶. psi4.core.benchmark_blas2(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas2.html:231,benchmark,benchmark,231,psi4manual/1.7.x/api/psi4.core.benchmark_blas2.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas2.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_blas2. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2¶. psi4.core.benchmark_blas2(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html:233,benchmark,benchmark,233,psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas2.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_blas2. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2¶. psi4.core.benchmark_blas2(max_dim: int, min_time: float) → None¶; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas2.html:233,benchmark,benchmark,233,psi4manual/1.9.x/api/psi4.core.benchmark_blas2.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas2.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_blas3. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3¶. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1) → None¶; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas3.html:258,benchmark,benchmark,258,psi4manual/master/api/psi4.core.benchmark_blas3.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_blas3.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_blas3. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3¶. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1) → None¶; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.benchmark_blas3-1.html:249,benchmark,benchmark,249,psi4manual/1.4.0/api/psi4.core.benchmark_blas3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.benchmark_blas3-1.html,2,['benchmark'],['benchmark']
Testability,"﻿. benchmark_blas3. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3¶. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1) → None¶; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.benchmark_blas3-1.html:249,benchmark,benchmark,249,psi4manual/1.5.0/api/psi4.core.benchmark_blas3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.benchmark_blas3-1.html,2,['benchmark'],['benchmark']
Testability,"﻿. benchmark_blas3. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3¶. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1) → None¶; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.benchmark_blas3.html:249,benchmark,benchmark,249,psi4manual/1.6.x/api/psi4.core.benchmark_blas3.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.benchmark_blas3.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_blas3. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3¶. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1) → None¶; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas3.html:249,benchmark,benchmark,249,psi4manual/1.7.x/api/psi4.core.benchmark_blas3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_blas3.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_blas3. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3¶. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1) → None¶; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html:251,benchmark,benchmark,251,psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_blas3.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_blas3. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3¶. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1) → None¶; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas3.html:251,benchmark,benchmark,251,psi4manual/1.9.x/api/psi4.core.benchmark_blas3.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas3.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_disk. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk¶. psi4.core.benchmark_disk(max_dim: int, min_time: float) → None¶; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_disk.html:236,benchmark,benchmark,236,psi4manual/master/api/psi4.core.benchmark_disk.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_disk.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_disk. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk¶. psi4.core.benchmark_disk(max_dim: int, min_time: float) → None¶; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.benchmark_disk-1.html:227,benchmark,benchmark,227,psi4manual/1.4.0/api/psi4.core.benchmark_disk-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.benchmark_disk-1.html,2,['benchmark'],['benchmark']
Testability,"﻿. benchmark_disk. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk¶. psi4.core.benchmark_disk(max_dim: int, min_time: float) → None¶; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.benchmark_disk-1.html:227,benchmark,benchmark,227,psi4manual/1.5.0/api/psi4.core.benchmark_disk-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.benchmark_disk-1.html,2,['benchmark'],['benchmark']
Testability,"﻿. benchmark_disk. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk¶. psi4.core.benchmark_disk(max_dim: int, min_time: float) → None¶; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.benchmark_disk.html:227,benchmark,benchmark,227,psi4manual/1.6.x/api/psi4.core.benchmark_disk.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.benchmark_disk.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_disk. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk¶. psi4.core.benchmark_disk(max_dim: int, min_time: float) → None¶; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_disk.html:227,benchmark,benchmark,227,psi4manual/1.7.x/api/psi4.core.benchmark_disk.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_disk.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_disk. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk¶. psi4.core.benchmark_disk(max_dim: int, min_time: float) → None¶; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_disk.html:229,benchmark,benchmark,229,psi4manual/1.8.x/api/psi4.core.benchmark_disk.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_disk.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_disk. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk¶. psi4.core.benchmark_disk(max_dim: int, min_time: float) → None¶; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_disk.html:229,benchmark,benchmark,229,psi4manual/1.9.x/api/psi4.core.benchmark_disk.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_disk.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_integrals. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals¶. psi4.core.benchmark_integrals(max_am: int, min_time: float) → None¶; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. table of contents. benchmark_integrals; benchmark_integrals(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_integrals.html:255,benchmark,benchmark,255,psi4manual/master/api/psi4.core.benchmark_integrals.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_integrals.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_integrals. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals¶. psi4.core.benchmark_integrals(max_am: int, min_time: float) → None¶; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.benchmark_integrals-1.html:246,benchmark,benchmark,246,psi4manual/1.4.0/api/psi4.core.benchmark_integrals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.benchmark_integrals-1.html,2,['benchmark'],['benchmark']
Testability,"﻿. benchmark_integrals. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals¶. psi4.core.benchmark_integrals(max_am: int, min_time: float) → None¶; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.benchmark_integrals-1.html:246,benchmark,benchmark,246,psi4manual/1.5.0/api/psi4.core.benchmark_integrals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.benchmark_integrals-1.html,2,['benchmark'],['benchmark']
Testability,"﻿. benchmark_integrals. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals¶. psi4.core.benchmark_integrals(max_am: int, min_time: float) → None¶; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.benchmark_integrals.html:246,benchmark,benchmark,246,psi4manual/1.6.x/api/psi4.core.benchmark_integrals.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.benchmark_integrals.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_integrals. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals¶. psi4.core.benchmark_integrals(max_am: int, min_time: float) → None¶; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_integrals.html:246,benchmark,benchmark,246,psi4manual/1.7.x/api/psi4.core.benchmark_integrals.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_integrals.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_integrals. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals¶. psi4.core.benchmark_integrals(max_am: int, min_time: float) → None¶; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. table of contents. benchmark_integrals; benchmark_integrals(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html:248,benchmark,benchmark,248,psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_integrals.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_integrals. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals¶. psi4.core.benchmark_integrals(max_am: int, min_time: float) → None¶; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. table of contents. benchmark_integrals; benchmark_integrals(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_integrals.html:248,benchmark,benchmark,248,psi4manual/1.9.x/api/psi4.core.benchmark_integrals.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_integrals.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_math. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math¶. psi4.core.benchmark_math(min_time: float) → None¶; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. table of contents. benchmark_math; benchmark_math(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_math.html:222,benchmark,benchmark,222,psi4manual/master/api/psi4.core.benchmark_math.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.benchmark_math.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_math. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math¶. psi4.core.benchmark_math(min_time: float) → None¶; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.benchmark_math-1.html:213,benchmark,benchmark,213,psi4manual/1.4.0/api/psi4.core.benchmark_math-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.benchmark_math-1.html,2,['benchmark'],['benchmark']
Testability,"﻿. benchmark_math. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math¶. psi4.core.benchmark_math(min_time: float) → None¶; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.benchmark_math-1.html:213,benchmark,benchmark,213,psi4manual/1.5.0/api/psi4.core.benchmark_math-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.benchmark_math-1.html,2,['benchmark'],['benchmark']
Testability,"﻿. benchmark_math. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math¶. psi4.core.benchmark_math(min_time: float) → None¶; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.benchmark_math.html:213,benchmark,benchmark,213,psi4manual/1.6.x/api/psi4.core.benchmark_math.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.benchmark_math.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_math. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math¶. psi4.core.benchmark_math(min_time: float) → None¶; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_math.html:213,benchmark,benchmark,213,psi4manual/1.7.x/api/psi4.core.benchmark_math.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.benchmark_math.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_math. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math¶. psi4.core.benchmark_math(min_time: float) → None¶; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. table of contents. benchmark_math; benchmark_math(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_math.html:215,benchmark,benchmark,215,psi4manual/1.8.x/api/psi4.core.benchmark_math.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.benchmark_math.html,1,['benchmark'],['benchmark']
Testability,"﻿. benchmark_math. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math¶. psi4.core.benchmark_math(min_time: float) → None¶; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. table of contents. benchmark_math; benchmark_math(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_math.html:215,benchmark,benchmark,215,psi4manual/1.9.x/api/psi4.core.benchmark_math.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_math.html,1,['benchmark'],['benchmark']
Testability,"﻿. compare_arrays. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. compare_arrays¶. psi4.driver.compare_arrays(expected, computed, digits, label)[source]¶; Function to compare two numpy arrays. Prints util.success(); when elements of vector computed match elements of vector expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.compare_arrays-1.html:483,test,test,483,psi4manual/1.2.1/api/psi4.driver.compare_arrays-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.compare_arrays-1.html,2,['test'],['test']
Testability,"﻿. compare_arrays. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. compare_arrays¶. psi4.driver.compare_arrays(expected, computed, digits, label, rtol=1e-16)[source]¶; Function to compare two numpy arrays. Prints util.success(); when elements of vector computed match elements of vector expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. Sets rtol to zero to match expected Psi4 behaviour, otherwise measured as:; absolute(computed - expected) <= (atol + rtol * absolute(expected)). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.compare_arrays-1.html:495,test,test,495,psi4manual/1.3.2/api/psi4.driver.compare_arrays-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.compare_arrays-1.html,2,['test'],['test']
Testability,"﻿. compare_cubes. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. compare_cubes¶. psi4.driver.compare_cubes(expected, computed, label)[source]¶; Function to compare two cube files. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.compare_cubes-1.html:367,test,test,367,psi4manual/1.2.1/api/psi4.driver.compare_cubes-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.compare_cubes-1.html,2,['test'],['test']
Testability,"﻿. compare_cubes. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. compare_cubes¶. psi4.driver.compare_cubes(expected, computed, label)[source]¶; Function to compare two cube files. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.compare_cubes-1.html:367,test,test,367,psi4manual/1.3.2/api/psi4.driver.compare_cubes-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.compare_cubes-1.html,2,['test'],['test']
Testability,"﻿. compare_fchkfiles. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. compare_fchkfiles¶. psi4.driver.compare_fchkfiles(expected, computed, atol_exponent, label)[source]¶; Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4’s FCHK files. Parameters:. expected (str) – Path to reference FCHK file against which computed is compared.; computed (str) – Path to input FCHK file to compare against expected.; atol_exponent (Union[int, float]) – Absolute tolerance for high accuracy fields – 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str) – Label for passed and error messages. table of contents. compare_fchkfiles; compare_fchkfiles(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.compare_fchkfiles.html:689,log,logical,689,psi4manual/master/api/psi4.driver.compare_fchkfiles.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.compare_fchkfiles.html,2,"['log', 'test']","['logical', 'test']"
Testability,"﻿. compare_fchkfiles. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. compare_fchkfiles¶. psi4.driver.p4util.compare_fchkfiles(expected, computed, atol_exponent, label)[source]¶; Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4’s FCHK files. Parameters:. expected (str) – Path to reference FCHK file against which computed is compared.; computed (str) – Path to input FCHK file to compare against expected.; atol_exponent (Union[int, float]) – Absolute tolerance for high accuracy fields – 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str) – Label for passed and error messages. table of contents. compare_fchkfiles; compare_fchkfiles(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.p4util.compare_fchkfiles.html:696,log,logical,696,psi4manual/master/api/psi4.driver.p4util.compare_fchkfiles.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.p4util.compare_fchkfiles.html,2,"['log', 'test']","['logical', 'test']"
Testability,"﻿. compare_fchkfiles. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. compare_fchkfiles¶. psi4.driver.compare_fchkfiles(expected, computed, atol_exponent, label)[source]¶; Comparison function for output data in FCHK (formatted checkpoint) file format.; Compares many fields including number of electrons, highest angular momentum, basis; set exponents, densities, final gradient.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4’s FCHK files. Parameters. expected (file) – Reference FCHK file against which computed is compared.; computed (file) – Input FCHK file to compare against expected.; atol_exponent (int or float) – Absolute tolerance for high accuracy fields – 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str) – Label for passed and error messages. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.compare_fchkfiles.html:680,log,logical,680,psi4manual/1.6.x/api/psi4.driver.compare_fchkfiles.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.compare_fchkfiles.html,2,"['log', 'test']","['logical', 'test']"
Testability,"﻿. compare_fchkfiles. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. compare_fchkfiles¶. psi4.driver.compare_fchkfiles(expected, computed, atol_exponent, label)[source]¶; Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4’s FCHK files. Parameters:. expected (str) – Path to reference FCHK file against which computed is compared.; computed (str) – Path to input FCHK file to compare against expected.; atol_exponent (Union[int, float]) – Absolute tolerance for high accuracy fields – 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str) – Label for passed and error messages. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.compare_fchkfiles.html:680,log,logical,680,psi4manual/1.7.x/api/psi4.driver.compare_fchkfiles.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.compare_fchkfiles.html,2,"['log', 'test']","['logical', 'test']"
Testability,"﻿. compare_fchkfiles. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. compare_fchkfiles¶. psi4.driver.p4util.compare_fchkfiles(expected, computed, atol_exponent, label)[source]¶; Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4’s FCHK files. Parameters:. expected (str) – Path to reference FCHK file against which computed is compared.; computed (str) – Path to input FCHK file to compare against expected.; atol_exponent (Union[int, float]) – Absolute tolerance for high accuracy fields – 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str) – Label for passed and error messages. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.p4util.compare_fchkfiles.html:687,log,logical,687,psi4manual/1.7.x/api/psi4.driver.p4util.compare_fchkfiles.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.p4util.compare_fchkfiles.html,2,"['log', 'test']","['logical', 'test']"
Testability,"﻿. compare_fchkfiles. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. compare_fchkfiles¶. psi4.driver.compare_fchkfiles(expected, computed, atol_exponent, label)[source]¶; Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4’s FCHK files. Parameters:. expected (str) – Path to reference FCHK file against which computed is compared.; computed (str) – Path to input FCHK file to compare against expected.; atol_exponent (Union[int, float]) – Absolute tolerance for high accuracy fields – 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str) – Label for passed and error messages. table of contents. compare_fchkfiles; compare_fchkfiles(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html:682,log,logical,682,psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fchkfiles.html,2,"['log', 'test']","['logical', 'test']"
Testability,"﻿. compare_fchkfiles. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. compare_fchkfiles¶. psi4.driver.p4util.compare_fchkfiles(expected, computed, atol_exponent, label)[source]¶; Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4’s FCHK files. Parameters:. expected (str) – Path to reference FCHK file against which computed is compared.; computed (str) – Path to input FCHK file to compare against expected.; atol_exponent (Union[int, float]) – Absolute tolerance for high accuracy fields – 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str) – Label for passed and error messages. table of contents. compare_fchkfiles; compare_fchkfiles(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.compare_fchkfiles.html:689,log,logical,689,psi4manual/1.8.x/api/psi4.driver.p4util.compare_fchkfiles.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.compare_fchkfiles.html,2,"['log', 'test']","['logical', 'test']"
Testability,"﻿. compare_fchkfiles. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. compare_fchkfiles¶. psi4.driver.compare_fchkfiles(expected, computed, atol_exponent, label)[source]¶; Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4’s FCHK files. Parameters:. expected (str) – Path to reference FCHK file against which computed is compared.; computed (str) – Path to input FCHK file to compare against expected.; atol_exponent (Union[int, float]) – Absolute tolerance for high accuracy fields – 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str) – Label for passed and error messages. table of contents. compare_fchkfiles; compare_fchkfiles(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.compare_fchkfiles.html:682,log,logical,682,psi4manual/1.9.x/api/psi4.driver.compare_fchkfiles.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.compare_fchkfiles.html,2,"['log', 'test']","['logical', 'test']"
Testability,"﻿. compare_fchkfiles. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. compare_fchkfiles¶. psi4.driver.p4util.compare_fchkfiles(expected, computed, atol_exponent, label)[source]¶; Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient.; Note only Psi4-style signature ((expected, computed, atol_exponent, label)) available.; An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4’s FCHK files. Parameters:. expected (str) – Path to reference FCHK file against which computed is compared.; computed (str) – Path to input FCHK file to compare against expected.; atol_exponent (Union[int, float]) – Absolute tolerance for high accuracy fields – 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So 1 means atol=0.1 and 2 means atol=0.01 but 0.04 means atol=0.04; Note that the largest expressable processed atol will be ~0.99.; label (str) – Label for passed and error messages. table of contents. compare_fchkfiles; compare_fchkfiles(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fchkfiles. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.p4util.compare_fchkfiles.html:689,log,logical,689,psi4manual/1.9.x/api/psi4.driver.p4util.compare_fchkfiles.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.p4util.compare_fchkfiles.html,2,"['log', 'test']","['logical', 'test']"
Testability,"﻿. compare_fcidumps. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. compare_fcidumps¶. psi4.driver.compare_fcidumps(expected, computed, label)[source]¶; Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. ‘norb’ : number of basis functions; ‘nelec’ : number of electrons; ‘ms2’ : spin polarization of the system; ‘isym’ : symmetry of state (if present in FCIDUMP); ‘orbsym’ : list of symmetry labels of each orbital; ‘uhf’ : whether restricted or unrestricted; ‘ONE-ELECTRON ENERGY’ : SCF one-electron energy; ‘TWO-ELECTRON ENERGY’ : SCF two-electron energy; ‘SCF TOTAL ENERGY’ : SCF total energy; ‘MP2 CORRELATION ENERGY’ : MP2 correlation energy. Parameters:. expected (str) – Reference FCIDUMP file against which computed is compared.; computed (str) – Input FCIDUMP file to compare against expected.; label (str) – string labeling the test. table of contents. compare_fcidumps; compare_fcidumps(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.compare_fcidumps.html:1008,test,test,1008,psi4manual/master/api/psi4.driver.compare_fcidumps.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.compare_fcidumps.html,1,['test'],['test']
Testability,"﻿. compare_fcidumps. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. compare_fcidumps¶. psi4.driver.p4util.compare_fcidumps(expected, computed, label)[source]¶; Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. ‘norb’ : number of basis functions; ‘nelec’ : number of electrons; ‘ms2’ : spin polarization of the system; ‘isym’ : symmetry of state (if present in FCIDUMP); ‘orbsym’ : list of symmetry labels of each orbital; ‘uhf’ : whether restricted or unrestricted; ‘ONE-ELECTRON ENERGY’ : SCF one-electron energy; ‘TWO-ELECTRON ENERGY’ : SCF two-electron energy; ‘SCF TOTAL ENERGY’ : SCF total energy; ‘MP2 CORRELATION ENERGY’ : MP2 correlation energy. Parameters:. expected (str) – Reference FCIDUMP file against which computed is compared.; computed (str) – Input FCIDUMP file to compare against expected.; label (str) – string labeling the test. table of contents. compare_fcidumps; compare_fcidumps(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.p4util.compare_fcidumps.html:1015,test,test,1015,psi4manual/master/api/psi4.driver.p4util.compare_fcidumps.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.p4util.compare_fcidumps.html,1,['test'],['test']
Testability,"﻿. compare_fcidumps. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. compare_fcidumps¶. psi4.driver.compare_fcidumps(expected, computed, label)[source]¶; Function to compare two FCIDUMP files. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. Returns:a dictionary of energies computed from the MO integrals. The key-value pairs are:. ‘NUCLEAR REPULSION ENERGY’ : nuclear repulsion plus frozen core energy; ‘ONE-ELECTRON ENERGY’ : SCF one-electron energy; ‘TWO-ELECTRON ENERGY’ : SCF two-electron energy; ‘SCF TOTAL ENERGY’ : SCF total energy; ‘MP2 CORRELATION ENERGY’ : MP2 correlation energy. Parameters:; expected – reference FCIDUMP file; computed – computed FCIDUMP file; label – string labelling the test. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.compare_fcidumps-1.html:379,test,test,379,psi4manual/1.2.1/api/psi4.driver.compare_fcidumps-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.compare_fcidumps-1.html,4,['test'],['test']
Testability,"﻿. compare_fcidumps. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. compare_fcidumps¶. psi4.driver.compare_fcidumps(expected, computed, label)[source]¶; Function to compare two FCIDUMP files. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. Returns:a dictionary of energies computed from the MO integrals. The key-value pairs are:. ‘NUCLEAR REPULSION ENERGY’ : nuclear repulsion plus frozen core energy; ‘ONE-ELECTRON ENERGY’ : SCF one-electron energy; ‘TWO-ELECTRON ENERGY’ : SCF two-electron energy; ‘SCF TOTAL ENERGY’ : SCF total energy; ‘MP2 CORRELATION ENERGY’ : MP2 correlation energy. Parameters:; expected – reference FCIDUMP file; computed – computed FCIDUMP file; label – string labelling the test. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.compare_fcidumps-1.html:379,test,test,379,psi4manual/1.3.2/api/psi4.driver.compare_fcidumps-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.compare_fcidumps-1.html,4,['test'],['test']
Testability,"﻿. compare_fcidumps. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. compare_fcidumps¶. psi4.driver.compare_fcidumps(expected, computed, label)[source]¶; Function to compare two FCIDUMP files. Prints success; when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. Returns; a dictionary of energies computed from the MO integrals.; - ‘NUCLEAR REPULSION ENERGY’ : nuclear repulsion plus frozen core energy; - ‘ONE-ELECTRON ENERGY’ : SCF one-electron energy; - ‘TWO-ELECTRON ENERGY’ : SCF two-electron energy; - ‘SCF TOTAL ENERGY’ : SCF total energy; - ‘MP2 CORRELATION ENERGY’ : MP2 correlation energy. Parameters. expected – reference FCIDUMP file; computed – computed FCIDUMP file; label – string labelling the test. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.compare_fcidumps-1.html:388,test,test,388,psi4manual/1.4.0/api/psi4.driver.compare_fcidumps-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.compare_fcidumps-1.html,4,['test'],['test']
Testability,"﻿. compare_fcidumps. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. compare_fcidumps¶. psi4.driver.compare_fcidumps(expected, computed, label)[source]¶; Function to compare two FCIDUMP files. Prints success; when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. Returns; a dictionary of energies computed from the MO integrals.; - ‘NUCLEAR REPULSION ENERGY’ : nuclear repulsion plus frozen core energy; - ‘ONE-ELECTRON ENERGY’ : SCF one-electron energy; - ‘TWO-ELECTRON ENERGY’ : SCF two-electron energy; - ‘SCF TOTAL ENERGY’ : SCF total energy; - ‘MP2 CORRELATION ENERGY’ : MP2 correlation energy. Parameters. expected – reference FCIDUMP file; computed – computed FCIDUMP file; label – string labelling the test. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.compare_fcidumps-1.html:388,test,test,388,psi4manual/1.5.0/api/psi4.driver.compare_fcidumps-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.compare_fcidumps-1.html,4,['test'],['test']
Testability,"﻿. compare_fcidumps. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. compare_fcidumps¶. psi4.driver.compare_fcidumps(expected, computed, label)[source]¶; Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. ‘norb’ : number of basis functions; ‘nelec’ : number of electrons; ‘ms2’ : spin polarization of the system; ‘isym’ : symmetry of state (if present in FCIDUMP); ‘orbsym’ : list of symmetry labels of each orbital; ‘uhf’ : whether restricted or unrestricted; ‘ONE-ELECTRON ENERGY’ : SCF one-electron energy; ‘TWO-ELECTRON ENERGY’ : SCF two-electron energy; ‘SCF TOTAL ENERGY’ : SCF total energy; ‘MP2 CORRELATION ENERGY’ : MP2 correlation energy. Parameters. expected – Reference FCIDUMP file against which computed is compared.; computed – Input FCIDUMP file to compare against expected.; label – string labeling the test. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.compare_fcidumps.html:980,test,test,980,psi4manual/1.6.x/api/psi4.driver.compare_fcidumps.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.compare_fcidumps.html,1,['test'],['test']
Testability,"﻿. compare_fcidumps. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. compare_fcidumps¶. psi4.driver.compare_fcidumps(expected, computed, label)[source]¶; Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. ‘norb’ : number of basis functions; ‘nelec’ : number of electrons; ‘ms2’ : spin polarization of the system; ‘isym’ : symmetry of state (if present in FCIDUMP); ‘orbsym’ : list of symmetry labels of each orbital; ‘uhf’ : whether restricted or unrestricted; ‘ONE-ELECTRON ENERGY’ : SCF one-electron energy; ‘TWO-ELECTRON ENERGY’ : SCF two-electron energy; ‘SCF TOTAL ENERGY’ : SCF total energy; ‘MP2 CORRELATION ENERGY’ : MP2 correlation energy. Parameters:. expected (str) – Reference FCIDUMP file against which computed is compared.; computed (str) – Input FCIDUMP file to compare against expected.; label (str) – string labeling the test. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.compare_fcidumps.html:999,test,test,999,psi4manual/1.7.x/api/psi4.driver.compare_fcidumps.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.compare_fcidumps.html,1,['test'],['test']
Testability,"﻿. compare_fcidumps. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. compare_fcidumps¶. psi4.driver.p4util.compare_fcidumps(expected, computed, label)[source]¶; Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. ‘norb’ : number of basis functions; ‘nelec’ : number of electrons; ‘ms2’ : spin polarization of the system; ‘isym’ : symmetry of state (if present in FCIDUMP); ‘orbsym’ : list of symmetry labels of each orbital; ‘uhf’ : whether restricted or unrestricted; ‘ONE-ELECTRON ENERGY’ : SCF one-electron energy; ‘TWO-ELECTRON ENERGY’ : SCF two-electron energy; ‘SCF TOTAL ENERGY’ : SCF total energy; ‘MP2 CORRELATION ENERGY’ : MP2 correlation energy. Parameters:. expected (str) – Reference FCIDUMP file against which computed is compared.; computed (str) – Input FCIDUMP file to compare against expected.; label (str) – string labeling the test. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.p4util.compare_fcidumps.html:1006,test,test,1006,psi4manual/1.7.x/api/psi4.driver.p4util.compare_fcidumps.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.p4util.compare_fcidumps.html,1,['test'],['test']
Testability,"﻿. compare_fcidumps. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. compare_fcidumps¶. psi4.driver.compare_fcidumps(expected, computed, label)[source]¶; Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. ‘norb’ : number of basis functions; ‘nelec’ : number of electrons; ‘ms2’ : spin polarization of the system; ‘isym’ : symmetry of state (if present in FCIDUMP); ‘orbsym’ : list of symmetry labels of each orbital; ‘uhf’ : whether restricted or unrestricted; ‘ONE-ELECTRON ENERGY’ : SCF one-electron energy; ‘TWO-ELECTRON ENERGY’ : SCF two-electron energy; ‘SCF TOTAL ENERGY’ : SCF total energy; ‘MP2 CORRELATION ENERGY’ : MP2 correlation energy. Parameters:. expected (str) – Reference FCIDUMP file against which computed is compared.; computed (str) – Input FCIDUMP file to compare against expected.; label (str) – string labeling the test. table of contents. compare_fcidumps; compare_fcidumps(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html:1001,test,test,1001,psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.compare_fcidumps.html,1,['test'],['test']
Testability,"﻿. compare_fcidumps. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. compare_fcidumps¶. psi4.driver.p4util.compare_fcidumps(expected, computed, label)[source]¶; Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. ‘norb’ : number of basis functions; ‘nelec’ : number of electrons; ‘ms2’ : spin polarization of the system; ‘isym’ : symmetry of state (if present in FCIDUMP); ‘orbsym’ : list of symmetry labels of each orbital; ‘uhf’ : whether restricted or unrestricted; ‘ONE-ELECTRON ENERGY’ : SCF one-electron energy; ‘TWO-ELECTRON ENERGY’ : SCF two-electron energy; ‘SCF TOTAL ENERGY’ : SCF total energy; ‘MP2 CORRELATION ENERGY’ : MP2 correlation energy. Parameters:. expected (str) – Reference FCIDUMP file against which computed is compared.; computed (str) – Input FCIDUMP file to compare against expected.; label (str) – string labeling the test. table of contents. compare_fcidumps; compare_fcidumps(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.compare_fcidumps.html:1008,test,test,1008,psi4manual/1.8.x/api/psi4.driver.p4util.compare_fcidumps.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.compare_fcidumps.html,1,['test'],['test']
Testability,"﻿. compare_fcidumps. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. compare_fcidumps¶. psi4.driver.compare_fcidumps(expected, computed, label)[source]¶; Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. ‘norb’ : number of basis functions; ‘nelec’ : number of electrons; ‘ms2’ : spin polarization of the system; ‘isym’ : symmetry of state (if present in FCIDUMP); ‘orbsym’ : list of symmetry labels of each orbital; ‘uhf’ : whether restricted or unrestricted; ‘ONE-ELECTRON ENERGY’ : SCF one-electron energy; ‘TWO-ELECTRON ENERGY’ : SCF two-electron energy; ‘SCF TOTAL ENERGY’ : SCF total energy; ‘MP2 CORRELATION ENERGY’ : MP2 correlation energy. Parameters:. expected (str) – Reference FCIDUMP file against which computed is compared.; computed (str) – Input FCIDUMP file to compare against expected.; label (str) – string labeling the test. table of contents. compare_fcidumps; compare_fcidumps(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.compare_fcidumps.html:1001,test,test,1001,psi4manual/1.9.x/api/psi4.driver.compare_fcidumps.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.compare_fcidumps.html,1,['test'],['test']
Testability,"﻿. compare_fcidumps. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. compare_fcidumps¶. psi4.driver.p4util.compare_fcidumps(expected, computed, label)[source]¶; Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. ‘norb’ : number of basis functions; ‘nelec’ : number of electrons; ‘ms2’ : spin polarization of the system; ‘isym’ : symmetry of state (if present in FCIDUMP); ‘orbsym’ : list of symmetry labels of each orbital; ‘uhf’ : whether restricted or unrestricted; ‘ONE-ELECTRON ENERGY’ : SCF one-electron energy; ‘TWO-ELECTRON ENERGY’ : SCF two-electron energy; ‘SCF TOTAL ENERGY’ : SCF total energy; ‘MP2 CORRELATION ENERGY’ : MP2 correlation energy. Parameters:. expected (str) – Reference FCIDUMP file against which computed is compared.; computed (str) – Input FCIDUMP file to compare against expected.; label (str) – string labeling the test. table of contents. compare_fcidumps; compare_fcidumps(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; compare_fcidumps. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.p4util.compare_fcidumps.html:1008,test,test,1008,psi4manual/1.9.x/api/psi4.driver.p4util.compare_fcidumps.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.p4util.compare_fcidumps.html,1,['test'],['test']
Testability,"﻿. compare_integers. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. compare_integers¶. psi4.driver.compare_integers(expected, computed, label)[source]¶; Function to compare two integers. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.compare_integers-1.html:374,test,test,374,psi4manual/1.2.1/api/psi4.driver.compare_integers-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.compare_integers-1.html,2,['test'],['test']
Testability,"﻿. compare_integers. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. compare_integers¶. psi4.driver.compare_integers(expected, computed, label)[source]¶; Function to compare two integers. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.compare_integers-1.html:374,test,test,374,psi4manual/1.3.2/api/psi4.driver.compare_integers-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.compare_integers-1.html,2,['test'],['test']
Testability,"﻿. compare_matrices. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. compare_matrices¶. psi4.driver.compare_matrices(expected, computed, digits, label)[source]¶; Function to compare two matrices. Prints util.success(); when elements of matrix computed match elements of matrix expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.compare_matrices-1.html:486,test,test,486,psi4manual/1.2.1/api/psi4.driver.compare_matrices-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.compare_matrices-1.html,2,['test'],['test']
Testability,"﻿. compare_matrices. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. compare_matrices¶. psi4.driver.compare_matrices(expected, computed, digits, label)[source]¶; Function to compare two matrices. Prints util.success(); when elements of matrix computed match elements of matrix expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.compare_matrices-1.html:486,test,test,486,psi4manual/1.3.2/api/psi4.driver.compare_matrices-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.compare_matrices-1.html,2,['test'],['test']
Testability,"﻿. compare_strings. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. compare_strings¶. psi4.driver.compare_strings(expected, computed, label)[source]¶; Function to compare two strings. Prints util.success(); when string computed exactly matches string expected.; Performs a system exit on failure. Used in input files in the test suite. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.compare_strings-1.html:380,test,test,380,psi4manual/1.2.1/api/psi4.driver.compare_strings-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.compare_strings-1.html,2,['test'],['test']
Testability,"﻿. compare_strings. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. compare_strings¶. psi4.driver.compare_strings(expected, computed, label)[source]¶; Function to compare two strings. Prints util.success(); when string computed exactly matches string expected.; Performs a system exit on failure. Used in input files in the test suite. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.compare_strings-1.html:380,test,test,380,psi4manual/1.3.2/api/psi4.driver.compare_strings-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.compare_strings-1.html,2,['test'],['test']
Testability,"﻿. compare_values. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. compare_values¶. psi4.driver.compare_values(expected, computed, digits, label, exitonfail=True)[source]¶; Function to compare two values. Prints util.success(); when value computed matches value expected to number of digits; (or to digits itself when digits < 1 e.g. digits=0.04). Performs; a system exit on failure unless exitonfail False, in which case; returns error message. Used in input files in the test suite. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.compare_values-1.html:529,test,test,529,psi4manual/1.2.1/api/psi4.driver.compare_values-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.compare_values-1.html,2,['test'],['test']
Testability,"﻿. compare_values. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. compare_values¶. psi4.driver.compare_values(expected, computed, digits, label, exitonfail=True)[source]¶; Function to compare two values. Prints util.success(); when value computed matches value expected to number of digits; (or to digits itself when digits < 1 e.g. digits=0.04). Performs; a system exit on failure unless exitonfail False, in which case; returns error message. Used in input files in the test suite. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.compare_values-1.html:529,test,test,529,psi4manual/1.3.2/api/psi4.driver.compare_values-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.compare_values-1.html,2,['test'],['test']
Testability,"﻿. compare_vectors. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. compare_vectors¶. psi4.driver.compare_vectors(expected, computed, digits, label)[source]¶; Function to compare two vectors. Prints util.success(); when elements of vector computed match elements of vector expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.compare_vectors-1.html:481,test,test,481,psi4manual/1.2.1/api/psi4.driver.compare_vectors-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.compare_vectors-1.html,2,['test'],['test']
Testability,"﻿. compare_vectors. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. compare_vectors¶. psi4.driver.compare_vectors(expected, computed, digits, label)[source]¶; Function to compare two vectors. Prints util.success(); when elements of vector computed match elements of vector expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.compare_vectors-1.html:481,test,test,481,psi4manual/1.3.2/api/psi4.driver.compare_vectors-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.compare_vectors-1.html,2,['test'],['test']
Testability,"﻿. compare_wavefunctions. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. compare_wavefunctions¶. psi4.driver.compare_wavefunctions(expected, computed, digits=9, label='Wavefunctions equal')[source]¶; Function to compare two wavefunctions. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.compare_wavefunctions-1.html:426,test,test,426,psi4manual/1.3.2/api/psi4.driver.compare_wavefunctions-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.compare_wavefunctions-1.html,2,['test'],['test']
Testability,"﻿. psi4.driver.TestComparisonError. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. psi4.driver.TestComparisonError¶. exception psi4.driver.TestComparisonError(msg)[source]¶; Bases: psi4.driver.p4util.exceptions.PsiException; Error called when a test case fails due to a failed; compare_values() call. Prints error message msg to standard; output stream and output file. args¶. with_traceback()¶; Exception.with_traceback(tb) –; set self.__traceback__ to tb and return self. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.testcomparisonerror.html:256,test,test,256,psi4manual/1.1.0/api/psi4.driver.testcomparisonerror.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.testcomparisonerror.html,1,['test'],['test']
Testability,"﻿. psi4.driver.basis_helper. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. psi4.driver.basis_helper¶. psi4.driver.basis_helper(block, name='', key='BASIS', set_option=True)[source]¶; For PsiAPI mode, forms a basis specification function from block; and associates it with keyword key under handle name. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see mints2, mints9, and cc54 test cases. Unless; set_option is False, name will be set as current active key,; equivalent to set key name or set_option({key: name}). Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.basis_helper.html:445,test,test,445,psi4manual/1.1.0/api/psi4.driver.basis_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.basis_helper.html,1,['test'],['test']
Testability,"﻿. psi4.driver.compare_arrays. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. psi4.driver.compare_arrays¶. psi4.driver.compare_arrays(expected, computed, digits, label)[source]¶; Function to compare two numpy arrays. Prints util.success(); when elements of vector computed match elements of vector expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_arrays.html:461,test,test,461,psi4manual/1.1.0/api/psi4.driver.compare_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_arrays.html,1,['test'],['test']
Testability,"﻿. psi4.driver.compare_cubes. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. psi4.driver.compare_cubes¶. psi4.driver.compare_cubes(expected, computed, label)[source]¶; Function to compare two cube files. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_cubes.html:345,test,test,345,psi4manual/1.1.0/api/psi4.driver.compare_cubes.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_cubes.html,1,['test'],['test']
Testability,"﻿. psi4.driver.compare_integers. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. psi4.driver.compare_integers¶. psi4.driver.compare_integers(expected, computed, label)[source]¶; Function to compare two integers. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_integers.html:352,test,test,352,psi4manual/1.1.0/api/psi4.driver.compare_integers.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_integers.html,1,['test'],['test']
Testability,"﻿. psi4.driver.compare_matrices. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. psi4.driver.compare_matrices¶. psi4.driver.compare_matrices(expected, computed, digits, label)[source]¶; Function to compare two matrices. Prints util.success(); when elements of matrix computed match elements of matrix expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_matrices.html:464,test,test,464,psi4manual/1.1.0/api/psi4.driver.compare_matrices.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_matrices.html,1,['test'],['test']
Testability,"﻿. psi4.driver.compare_strings. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. psi4.driver.compare_strings¶. psi4.driver.compare_strings(expected, computed, label)[source]¶; Function to compare two strings. Prints util.success(); when string computed exactly matches string expected.; Performs a system exit on failure. Used in input files in the test suite. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_strings.html:358,test,test,358,psi4manual/1.1.0/api/psi4.driver.compare_strings.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_strings.html,1,['test'],['test']
Testability,"﻿. psi4.driver.compare_values. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. psi4.driver.compare_values¶. psi4.driver.compare_values(expected, computed, digits, label, exitonfail=True)[source]¶; Function to compare two values. Prints util.success(); when value computed matches value expected to number of digits; (or to digits itself when digits < 1 e.g. digits=0.04). Performs; a system exit on failure unless exitonfail False, in which case; returns error message. Used in input files in the test suite. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_values.html:507,test,test,507,psi4manual/1.1.0/api/psi4.driver.compare_values.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_values.html,1,['test'],['test']
Testability,"﻿. psi4.driver.compare_vectors. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. psi4.driver.compare_vectors¶. psi4.driver.compare_vectors(expected, computed, digits, label)[source]¶; Function to compare two vectors. Prints util.success(); when elements of vector computed match elements of vector expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_vectors.html:459,test,test,459,psi4manual/1.1.0/api/psi4.driver.compare_vectors.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.compare_vectors.html,1,['test'],['test']
Testability,"﻿. qcdb.oldpymodules — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». Source code for qcdb.oldpymodules; # Obtained from http://code.activestate.com/recipes/576693/ on 15 Nov 2014. # Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.; # Passes Python2.7's test suite and incorporates all the latest updates. from __future__ import absolute_import; from __future__ import print_function; try:; from thread import get_ident as _get_ident; except ImportError:; from dummy_thread import get_ident as _get_ident. try:; from _abcoll import KeysView, ValuesView, ItemsView; except ImportError:; pass. [docs]class OrderedDict(dict):; 'Dictionary that remembers insertion order'; # An inherited dict maps keys to values.; # The inherited dict provides __getitem__, __len__, __contains__, and get.; # The remaining methods are order-aware.; # Big-O running times for all methods are the same as for regular dictionaries. # The internal self.__map dictionary maps keys to links in a doubly linked list.; # The circular doubly linked list starts and ends with a sentinel element.; # The sentinel element never gets deleted (this simplifies the algorithm).; # Each link is stored as a list of length three: [PREV, NEXT, KEY]. def __init__(self, *args, **kwds):; '''Initialize an ordered dictionary. Signature is the same as for; regular dictionaries, but keyword arguments are not recommended; because their insertion order is arbitrary. '''; if len(args) > 1:; raise TypeError('expected at most 1 arguments, got %d' % len(args)); try:; self.__root; except AttributeError:; self.__root = root = [] # sentinel node; root[:] = [root, root, None]; self.__map = {}; self.__update(*args, **kwds). def __setitem__(self, key, value, dict_setitem=dict.__setitem__):; 'od.__setitem__(i, y) <==> od[i]=y'; # Setting a new item creates a new link which goes at the end of the linked; # list, and the inherited dictionary is updated wi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:347,test,test,347,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,1,['test'],['test']
Testability,"﻿. qcdb.psiutil — PSI4 [beta3] documentation. Navigation. index. modules    . toc    ; PSI4 [beta3] » ; Module code ». Source code for qcdb.psiutil; r""""""Stuff stolen from psi. Should import or not as necessary; or some better way. Apologies to the coders. """"""; import sys; import math; import re; from vecutil import *. def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if abs(expected - computed) > 10 ** (-digits):; print(""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits)); sys.exit(1); if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f) to %d digits.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected[row][col], computed[row][col])); failed = 1; break. if failed:; print(""The Failed Test Matrices\n""); show(computed); print('\n'); show(expected); sys.exit(1); _success(label). [do",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/psiutil.html:796,test,test,796,psi4manual/4.0b3/_modules/qcdb/psiutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/psiutil.html,1,['test'],['test']
Testability,"﻿. qcdb.psiutil — PSI4 [beta4] documentation. Navigation. index. modules    . toc    ; PSI4 [beta4] » ; Module code ». Source code for qcdb.psiutil; r""""""Stuff stolen from psi. Should import or not as necessary; or some better way. Apologies to the coders. """"""; import sys; import math; import re; from vecutil import *. def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if abs(expected - computed) > 10 ** (-digits):; print(""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits)); sys.exit(1); if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f) to %d digits.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected[row][col], computed[row][col])); failed = 1; break. if failed:; print(""The Failed Test Matrices\n""); show(computed); print('\n'); show(expected); sys.exit(1); _success(label). [do",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/psiutil.html:796,test,test,796,psi4manual/4.0b4/_modules/qcdb/psiutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/psiutil.html,1,['test'],['test']
Testability,"﻿. qcelemental.molutil.align. Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; qcelemental.molutil.align. Source code for qcelemental.molutil.align; import collections; import itertools; import time; from typing import Union. import numpy as np. from ..exceptions import ValidationError; from ..models import AlignmentMill; from ..physical_constants import constants; from ..testing import compare_values; from ..util import distance_matrix, linear_sum_assignment, random_rotation_matrix, uno, which_import. def _nre(Z, geom):; """"""Nuclear repulsion energy"""""". nre = 0.0; for at1 in range(geom.shape[0]):; for at2 in range(at1):; dist = np.linalg.norm(geom[at1] - geom[at2]); nre += Z[at1] * Z[at2] / dist; return nre. def _pseudo_nre(Zhash, geom):; """"""Pseudo nuclear repulsion energy where non-physical Z contrived from `Zhash`."""""". Zidx = list(set(sorted(Zhash))); pZ = [Zidx.index(z) for z in Zhash]; return _nre(pZ, geom). [docs]def B787(; cgeom: np.ndarray,; rgeom: np.ndarray,; cuniq: np.ndarray,; runiq: np.ndarray,; do_plot: bool = False,; verbose: int = 1,; atoms_map: bool = False,; run_resorting: bool = False,; mols_align: Union[bool, float] = False,; run_to_completion: bool = False,; algorithm: str = ""hungarian_uno"",; uno_cutoff: float = 1.0e-3,; run_mirror: bool = False,; ):; r""""""Use Kabsch algorithm to find best alignment of geometry `cgeom` onto; `rgeom` while sampling atom mappings restricted by `runiq` and `cuniq`. Parameters; ----------; rgeom; (nat, 3) array of reference/target/unchanged geometry. Assumed [a0]; for RMSD purposes.; cgeom; (nat, 3) array of concern/changeable geometry. Assumed [a0] for RMSD; purposes. Must have same nat, units, and atom content as rgeom.; runiq; (nat,) array of str indicating which rows (atoms) in `rgeom` are shuffleable; without changing the molecule. Generally hashes of element symbol and; mass are used, but could be as simple as ['C', 'H', 'H', 'D', 'H'] for; monodeuterated methane.; cuniq; (nat,) array of str",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html:397,test,testing,397,psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,1,['test'],['testing']
Testability,"﻿. qcelemental.molutil.align. Navigation. Index. modules    .    .  · ; 1.5;  · . PSI4. Module code; qcelemental.molutil.align. Source code for qcelemental.molutil.align; import collections; import itertools; import time; from typing import Union. import numpy as np. from ..exceptions import ValidationError; from ..models import AlignmentMill; from ..physical_constants import constants; from ..testing import compare_values; from ..util import distance_matrix, linear_sum_assignment, random_rotation_matrix, uno, which_import. def _nre(Z, geom):; """"""Nuclear repulsion energy"""""". nre = 0.0; for at1 in range(geom.shape[0]):; for at2 in range(at1):; dist = np.linalg.norm(geom[at1] - geom[at2]); nre += Z[at1] * Z[at2] / dist; return nre. def _pseudo_nre(Zhash, geom):; """"""Pseudo nuclear repulsion energy where non-physical Z contrived from `Zhash`."""""". Zidx = list(set(sorted(Zhash))); pZ = [Zidx.index(z) for z in Zhash]; return _nre(pZ, geom). [docs]def B787(; cgeom: np.ndarray,; rgeom: np.ndarray,; cuniq: np.ndarray,; runiq: np.ndarray,; do_plot: bool = False,; verbose: int = 1,; atoms_map: bool = False,; run_resorting: bool = False,; mols_align: Union[bool, float] = False,; run_to_completion: bool = False,; algorithm: str = ""hungarian_uno"",; uno_cutoff: float = 1.0e-3,; run_mirror: bool = False,; ):; r""""""Use Kabsch algorithm to find best alignment of geometry `cgeom` onto; `rgeom` while sampling atom mappings restricted by `runiq` and `cuniq`. Parameters; ----------; rgeom; (nat, 3) array of reference/target/unchanged geometry. Assumed [a0]; for RMSD purposes.; cgeom; (nat, 3) array of concern/changeable geometry. Assumed [a0] for RMSD; purposes. Must have same nat, units, and atom content as rgeom.; runiq; (nat,) array of str indicating which rows (atoms) in `rgeom` are shuffleable; without changing the molecule. Generally hashes of element symbol and; mass are used, but could be as simple as ['C', 'H', 'H', 'D', 'H'] for; monodeuterated methane.; cuniq; (nat,) array of str",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/qcelemental/molutil/align.html:397,test,testing,397,psi4manual/1.5.0/_modules/qcelemental/molutil/align.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/qcelemental/molutil/align.html,1,['test'],['testing']
Testability,"﻿. qcelemental.molutil.align. Navigation. Index. modules    .    .  · ; 1.6;  · . PSI4. Module code; qcelemental.molutil.align. Source code for qcelemental.molutil.align; import collections; import itertools; import time; from typing import Union. import numpy as np. from ..exceptions import ValidationError; from ..models import AlignmentMill; from ..physical_constants import constants; from ..testing import compare_values; from ..util import distance_matrix, linear_sum_assignment, random_rotation_matrix, uno, which_import. def _nre(Z, geom):; """"""Nuclear repulsion energy"""""". nre = 0.0; for at1 in range(geom.shape[0]):; for at2 in range(at1):; dist = np.linalg.norm(geom[at1] - geom[at2]); nre += Z[at1] * Z[at2] / dist; return nre. def _pseudo_nre(Zhash, geom):; """"""Pseudo nuclear repulsion energy where non-physical Z contrived from `Zhash`."""""". Zidx = list(set(sorted(Zhash))); pZ = [Zidx.index(z) for z in Zhash]; return _nre(pZ, geom). [docs]def B787(; cgeom: np.ndarray,; rgeom: np.ndarray,; cuniq: np.ndarray,; runiq: np.ndarray,; do_plot: bool = False,; verbose: int = 1,; atoms_map: bool = False,; run_resorting: bool = False,; mols_align: Union[bool, float] = False,; run_to_completion: bool = False,; algorithm: str = ""hungarian_uno"",; uno_cutoff: float = 1.0e-3,; run_mirror: bool = False,; ):; r""""""Use Kabsch algorithm to find best alignment of geometry `cgeom` onto; `rgeom` while sampling atom mappings restricted by `runiq` and `cuniq`. Parameters; ----------; rgeom; (nat, 3) array of reference/target/unchanged geometry. Assumed [a0]; for RMSD purposes.; cgeom; (nat, 3) array of concern/changeable geometry. Assumed [a0] for RMSD; purposes. Must have same nat, units, and atom content as rgeom.; runiq; (nat,) array of str indicating which rows (atoms) in `rgeom` are shuffleable; without changing the molecule. Generally hashes of element symbol and; mass are used, but could be as simple as ['C', 'H', 'H', 'D', 'H'] for; monodeuterated methane.; cuniq; (nat,) array of str",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html:397,test,testing,397,psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/molutil/align.html,1,['test'],['testing']
Testability,"﻿. qcelemental.testing. Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html:15,test,testing,15,psi4manual/master/_modules/qcelemental/testing.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/qcelemental/testing.html,9,"['log', 'test']","['log', 'logging', 'test', 'testing']"
Testability,"﻿. qcelemental.testing. Navigation. Index. modules    .    .  · ; 1.6;  · . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np; from pydantic import BaseModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to np.isclose. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and computed are None.; quiet; Whether to log the return message.; return",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/testing.html:15,test,testing,15,psi4manual/1.6.x/_modules/qcelemental/testing.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcelemental/testing.html,9,"['log', 'test']","['log', 'logging', 'test', 'testing']"
Testability,"﻿. qcelemental.testing. Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal_phase; Compare computed *or its opposite* as equal.; passnone; Return True when both expected and comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/qcelemental/testing.html:15,test,testing,15,psi4manual/1.7.x/_modules/qcelemental/testing.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/qcelemental/testing.html,9,"['log', 'test']","['log', 'logging', 'test', 'testing']"
Testability,"﻿. qcelemental.testing. Navigation. Index. modules    .    .  · ; 1.8.2;  · . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html:15,test,testing,15,psi4manual/1.8.x/_modules/qcelemental/testing.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/qcelemental/testing.html,9,"['log', 'test']","['log', 'logging', 'test', 'testing']"
Testability,"﻿. qcelemental.testing. Navigation. Index. modules    .    .  · ; 1.9.1;  · . PSI4. Module code; qcelemental.testing. Source code for qcelemental.testing; import copy; import logging; import pprint; import sys; from typing import Callable, Dict, List, Tuple, Union. import numpy as np. try:; from pydantic.v1 import BaseModel; except ImportError: # Will also trap ModuleNotFoundError; from pydantic import BaseModel. from qcelemental.models.basemodels import ProtoModel. pp = pprint.PrettyPrinter(width=120). def _handle_return(passfail: bool, label: str, message: str, return_message: bool, quiet: bool = False):; """"""Function to print a '*label*...PASSED' line to log."""""". if not quiet:; if passfail:; logging.info(f"" {label:.<53}PASSED""); else:; logging.error(f"" {label:.<53}FAILED""); logging.error(f"" {message:.<53}""). if return_message:; return passfail, message; else:; return passfail. def tnm() -> str:; """"""Returns the name of the calling function, usually name of test case."""""". return sys._getframe().f_back.f_code.co_name. [docs]; def compare_values(; expected: Union[float, List, np.ndarray],; computed: Union[float, List, np.ndarray],; label: str = None,; *,; atol: float = 1.0e-6,; rtol: float = 1.0e-16,; equal_nan: bool = False,; equal_phase: bool = False,; passnone: bool = False,; quiet: bool = False,; return_message: bool = False,; return_handler: Callable = None,; ) -> Union[bool, Tuple[bool, str]]:; r""""""Returns True if two floats or float arrays are element-wise equal within a tolerance. Parameters; ----------; expected; float or float array-like; Reference value against which `computed` is compared.; computed; float or float array-like; Input value to compare against `expected`.; atol; Absolute tolerance (see formula below).; label; Label for passed and error messages. Defaults to calling function name.; rtol; Relative tolerance (see formula below). By default set to zero so `atol` dominates.; equal_nan; Passed to :func:`numpy.isclose`. Compare NaN's as equal.; equal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/qcelemental/testing.html:15,test,testing,15,psi4manual/1.9.x/_modules/qcelemental/testing.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/qcelemental/testing.html,9,"['log', 'test']","['log', 'logging', 'test', 'testing']"
Usability," # * below, process values of `levels`, which are modelchem strings, into kwargs specs; nbodies_per_mc_level = []; prev_body = 0; for nb in levels:; nbodies = []; if nb == ""supersystem"":; nbodies.append(nb); elif nb != (prev_body + 1):; for m in range(prev_body + 1, nb + 1):; nbodies.append(m); else:; nbodies.append(nb); nbodies_per_mc_level.append(nbodies); prev_body += 1. plan.max_nbody = max(nb for nb in levels if nb != ""supersystem""); plan.nbodies_per_mc_level = nbodies_per_mc_level. for mc_level_idx, mtd in enumerate(levels.values()):; method, basis, cbsmeta = expand_cbs_methods(mtd, basis, driver, cbsmeta=cbsmeta, **kwargs); packet.update({'method': method, 'basis': basis}). # Tell the task builder which level to add a task list for; # * see https://github.com/psi4/psi4/pull/1351#issuecomment-549948276 for discussion of where build_tasks logic should live; if method == ""cbs"":; # This CompositeComputer is discarded after being used for dermode.; simplekwargs = copy.deepcopy(kwargs); simplekwargs.pop('dertype', None); simplecbsmeta = copy.deepcopy(cbsmeta); simplecbsmeta['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplecbsmeta, molecule=original_molecule, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info(""PLANNING MB(CBS): {mc_level_idx=} {packet=} {cbsmeta=} kw={kwargs}""); plan.build_tasks(CompositeComputer, **packet, mc_level_idx=mc_level_idx, **cbsmeta, **kwargs). else:; logger.info(; f""PLANNING MB(FD(CBS): {mc_level_idx=} {packet=} {cbsmeta=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; computer=CompositeComputer,; **cbsmeta,; **current_findif_kwargs,; **kwargs). else:; dermode = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_planner.html:7524,simpl,simplekwargs,7524,psi4manual/1.7.x/_modules/psi4/driver/task_planner.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_planner.html,4,['simpl'],['simplekwargs']
Usability," 'casscf']:; ciwfn = run_detcas(name, **kwargs); else:; ciwfn = run_detci(name, **kwargs). # All property names are just CI; if 'CI' in name.upper():; name = 'CI'. states = core.get_global_option('avg_states'); nroots = core.get_global_option('num_roots'); if len(states) != nroots:; states = range(nroots). # Run OEProp; oe = core.OEProp(ciwfn); oe.set_title(name.upper()); for prop in ci_prop:; oe.add(prop.upper()). # Compute ""the"" CI density; oe.compute(); ciwfn.set_oeprop(oe). # If we have more than one root, compute all data; if nroots > 1:; core.print_out(""\n ===> %s properties for all CI roots <=== \n\n"" % name.upper()); for root in states:; oe.set_title(""%s ROOT %d"" % (name.upper(), root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(root, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(root, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(root, root, ""B"", True)); oe.compute(). # Transition density matrices; if (nroots > 1) and len(ci_trans):; oe.clear(); for tprop in ci_trans:; oe.add(tprop.upper()). core.print_out(""\n ===> %s properties for all CI transition density matrices <=== \n\n"" % name.upper()); for root in states[1:]:; oe.set_title(""%s ROOT %d -> ROOT %d"" % (name.upper(), 0, root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(0, root, ""B"", True)); oe.compute(). optstash.restore(); return ciwfn. def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if name == 'eom-ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); core.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CCSD'); core.set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:78898,clear,clear,78898,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['clear'],['clear']
Usability," 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=assembled_results[""module""]),; 'extras': {; 'qcvars': qcvars,; 'cbs_record': copy.deepcopy(self.cbsrec),; },; 'return_result': assembled_results['ret_ptype'],; 'success': True,; }). logger.debug('CBS QCSchema:\n' + pp.pformat(cbs_model.dict())). return cbs_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables; - module if simple. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; cbs_model = self.get_results(client=client). if cbs_model.driver == 'energy':; ret_ptype = cbs_model.return_result; else:; ret_ptype = core.Matrix.from_array(cbs_model.return_result); wfn = _cbs_schema_to_wfn(cbs_model). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _cbs_schema_to_wfn(cbs_model):; """"""Helper function to produce Wavefunction from a Composite-flavored AtomicResult."""""". mol = core.Molecule.from_schema(cbs_model.molecule.dict()); basis = core.BasisSet.build(mol, ""ORBITAL"", 'def2-svp', quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(cbs_model.provenance, ""module""):; wfn.set_module(cbs_model.provenance.module). # wfn.set_energy(cbs_model['extras'['qcvars'].get('CBS TOTAL ENERGY')) # catches Wfn.energy_; for qcv, val in cbs_model.extras['qcvars'].ite",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:61300,simpl,simple,61300,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,3,['simpl'],['simple']
Usability," (eliminates all entries). computeExternExternInteraction(self, arg0, arg1); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential, arg1: bool) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.externalpotential.html:1615,clear,clear,1615,psi4manual/1.4.0/api/psi4.core.externalpotential.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.externalpotential.html,2,['clear'],['clear']
Usability," (this is the usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and without diffuse \(d\) functions on heavy atoms) (Papajak:2011:10). So,; we’ll use that as our standard basis set. The SAPT code is designed to use density fitting techniques, because they introduce minimal errors while providing much faster computations (Hohenstein:2010:184111,Hohenstein:2010:014101). Since we’re using density fitting for the SAPT, we might as well also use it for the Hartree-Fock; computations that are performed as part of the SAPT. We can specify that by adding 'scf_type': 'df' to the dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that pair with the primary basis set. Fortunately, Psi4 is usually smart enough to figure out what auxiliary basis sets are needed for a given computation. In this case, jun-cc-pVDZ is a standard enough basis set (just a simple truncation of the very popular aug-cc-pVDZ basis set) that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the SAPT; procedure.; To speed up the computation a little, we also tell the SAPT procedure to freeze the core electrons by adding 'freeze_core': 'true' to the dictionary passed to psi4.set_options(). The SAPT procedure is invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here, Psi4 knows to automatically run two monomer computations and a dimer computation and then use these results to perform the SAPT analysis. The various energy components are printed at the end of the output, in addition to; the total SAPT0 interaction energy. An explanation of the various energy components can be found in the review by Jeziorski, Moszynski, and Szalewicz (Jeziorski:1994:1887), and this is discussed in more detail in the SAPT section of the Psi4 manual.; For now, we’ll note that most of the SAPT energy components are negative; this means those are attractive contribut",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:14475,simpl,simple,14475,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,11,['simpl'],['simple']
Usability," 18-point dissociation curve for helium dimer; 'HeNe' 18-point dissociation curve for helium-neon complex; 'HeAr' 18-point dissociation curve for helium-argon complex; 'HeKr' 18-point dissociation curve for helium-krypton complex; 'NeNe' 18-point dissociation curve for neon dimer; 'NeAr' 18-point dissociation curve for neon-argon complex; 'NeKr' 18-point dissociation curve for neon-krypton complex; 'ArAr' 18-point dissociation curve for argon dimer; 'ArKr' 18-point dissociation curve for argon-krypton complex; 'KrKr' 18-point dissociation curve for krypton dimer. S66¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries and reference energies from Rezac et al. JCTC 7 2427 (2011). cp 'off' || 'on'; rlxd 'off'; subset; 'small'; 'large'; 'HB' hydrogen-bonded systems; 'MX' mixed-influence systems; 'DD' dispersion-dominated systems. CORE¶. Database of Pulay corannulene structures. Subsumed into CFLOW. cp 'off' || 'on'; rlxd 'off'. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. NHTBH¶. Database (Truhlar) of non-hydrogen-transfer barrier height reactions.; Geometries and Reaction energies from Truhlar and coworkers at site http://t1.chem.umn.edu/misc/database_group/database_therm_bh/non_H.htm. cp 'off'; rlxd 'off'; subset; 'small'; 'large'. HBC6¶. Database (Sherrill) of interaction energies for dissociation curves of doubly hydrogen-bonded bimolecular complexes.; Geometries from and original reference interaction energies from Thanthiriwatte et al. JCTC 7 88 (2011).; Revised reference interaction energies from Marshall et al. JCP 135 194102 (2011). cp 'off' || 'on'; rlxd 'off' || 'on'; benchmark; 'HBC60' Thanthiriwatte et al. JCTC 7 88 (2011).; 'HBC6A' Marshall et al. JCP 135 194102 (2011).; 'HBC6ARLX' Sherrill group, unpublished. subset; 'small'; 'large'; 'equilibrium' equilibrium points for the six systems; 'FaOOF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_available_databases-1.html:6071,simpl,simple,6071,psi4manual/4.0b5/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_available_databases-1.html,4,['simpl'],['simple']
Usability," 18-point dissociation curve for helium dimer; 'HeNe' 18-point dissociation curve for helium-neon complex; 'HeAr' 18-point dissociation curve for helium-argon complex; 'HeKr' 18-point dissociation curve for helium-krypton complex; 'NeNe' 18-point dissociation curve for neon dimer; 'NeAr' 18-point dissociation curve for neon-argon complex; 'NeKr' 18-point dissociation curve for neon-krypton complex; 'ArAr' 18-point dissociation curve for argon dimer; 'ArKr' 18-point dissociation curve for argon-krypton complex; 'KrKr' 18-point dissociation curve for krypton dimer. S66¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries and reference energies from Rezac et al. JCTC 7 2427 (2011). cp 'off' || 'on'; rlxd 'off'; subset; 'small'; 'large'; 'HB' hydrogen-bonded systems; 'MX' mixed-influence systems; 'DD' dispersion-dominated systems. CORE¶; Database of Pulay corannulene structures. Subsumed into CFLOW. cp 'off' || 'on'; rlxd 'off'. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. NHTBH¶. Database (Truhlar) of non-hydrogen-transfer barrier height reactions.; Geometries and Reaction energies from Truhlar and coworkers at site http://t1.chem.umn.edu/misc/database_group/database_therm_bh/non_H.htm. cp 'off'; rlxd 'off'; subset; 'small'; 'large'. HBC6¶. Database (Sherrill) of interaction energies for dissociation curves of doubly hydrogen-bonded bimolecular complexes.; Geometries from and original reference interaction energies from Thanthiriwatte et al. JCTC 7 88 (2011).; Revised reference interaction energies from Marshall et al. JCP 135 194102 (2011). cp 'off' || 'on'; rlxd 'off' || 'on'; benchmark; 'HBC60' Thanthiriwatte et al. JCTC 7 88 (2011).; 'HBC6A' Marshall et al. JCP 135 194102 (2011).; 'HBC6ARLX' Sherrill group, unpublished. subset; 'small'; 'large'; 'equilibrium' equilibrium points for the six systems; 'FaOOF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_available_databases-1.html:4703,simpl,simple,4703,psi4manual/4.0b3/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_available_databases-1.html,8,['simpl'],['simple']
Usability," 18-point dissociation curve for helium dimer; 'HeNe' 18-point dissociation curve for helium-neon complex; 'HeAr' 18-point dissociation curve for helium-argon complex; 'HeKr' 18-point dissociation curve for helium-krypton complex; 'NeNe' 18-point dissociation curve for neon dimer; 'NeAr' 18-point dissociation curve for neon-argon complex; 'NeKr' 18-point dissociation curve for neon-krypton complex; 'ArAr' 18-point dissociation curve for argon dimer; 'ArKr' 18-point dissociation curve for argon-krypton complex; 'KrKr' 18-point dissociation curve for krypton dimer. S66¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries and reference energies from Rezac et al. JCTC 7 2427 (2011). cp 'off' || 'on'; rlxd 'off'; subset; 'small'; 'large'; 'HB' hydrogen-bonded systems; 'MX' mixed-influence systems; 'DD' dispersion-dominated systems. CORE¶; Database of Pulay corannulene structures. Subsumed into CFLOW. cp 'off' || 'on'; rlxd 'off'. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. NHTBH¶. Database (Truhlar) of non-hydrogen-transfer barrier height reactions.; Geometries and Reaction energies from Truhlar and coworkers at site http://t1.chem.umn.edu/misc/database_group/database_therm_bh/non_H.htm. cp 'off'; rlxd 'off'; subset; 'small'; 'large'. HBC6¶. Database (Sherrill) of interaction energies for dissociation curves of doubly hydrogen-bonded bimolecular complexes.; Geometries from and original reference interaction energies from Thanthiriwatte et al. JCTC 7 88 (2011).; Revised reference interaction energies from Marshall et al. JCP 135 194102 (2011). cp 'off' || 'on'; rlxd 'off' || 'on'; benchmark; 'HBC60' Thanthiriwatte et al. JCTC 7 88 (2011).; 'HBC6A' Marshall et al. JCP 135 194102 (2011).; 'HBC6ARLX' Sherrill group, unpublished. subset; 'small'; 'large'; 'equilibrium'. HSG¶. Database (Merz) of interaction energies",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_available_databases-1.html:4314,simpl,simple,4314,psi4manual/4.0b2/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_available_databases-1.html,4,['simpl'],['simple']
Usability," = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str +=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:28344,clear,clear,28344,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,10,['clear'],['clear']
Usability," = psi4.variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. PSIthonPsiAPI# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = psi4.energy(...); E = psi4.optimize(...); E = psi4.frequency(...); G = psi4.gradient(...) # used by optimize(); H = psi4.hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction. PSIthonPsiAPI# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:10264,simpl,simple,10264,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['simpl'],['simple']
Usability," >>> psi4 --test. # Mac; # py36|py37|py38|py39 for alternate python versions; >>> curl -O ""http://vergil.chemistry.gatech.edu/download/Psi4conda-latest-py35-MacOSX-x86_64.sh"" --keepalive-time 2; >>> curl ""http://vergil.chemistry.gatech.edu/psicode-download/Psi4conda-1.4rc1-py38-MacOSX-x86_64.sh"" -o Psi4conda-latest-py38-MacOSX-x86_64.sh --keepalive-time 2; >>> bash Psi4conda-latest-py38-MacOSX-x86_64.sh -b -p $HOME/psi4conda # agrees to license terms; >>> (bash) echo $'. $HOME/psi4conda/etc/profile.d/conda.sh\nconda activate' >> ~/.bash_profile; >>> (tcsh) echo ""source $HOME/psi4conda/etc/profile.d/conda.csh\nconda activate"" >> ~/.tcshrc; # log out, log back in so conda and psi4 in path; >>> psi4 --test. # Windows; # py38 only python version; # download via button at https://psicode.netlify.app/installs/latest with ""Windows"", ""Installer"", and ""Stable Release"" selected; >>> # install via GUI by double-clicking downloaded `.exe` file analogous to https://conda.io/projects/conda/en/latest/user-guide/install/windows.html; >>> # -OR- install via following line; >>> start /wait """" Psi4conda-1.4rc1-py38-Windows-x86_64.exe /InstallationType=JustMe /RegisterPython=0 /S /D=%UserProfile%\psi4conda; >>> psi4 --test. That last command tested that psi4 is in your path, and it’s finding; all the libraries it needs. It works because PSI_SCRATCH; defaults to /tmp. Now you need only specify a permanent scratch; directory (see Scratch Files) by replacing the placeholder in the; following:; >>> echo ""export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files"" >> ~/.bashrc; # log out, log back in so variable takes effect. All done!; Configuration for this set-up is summarized at How to run Psi4 as executable or Python module from conda installation. Note; PSI4 installs a Python distribution alongside, so you should choose an installer based on the Python version you want, irrespective of any Python version you have. How to install a Psi4 binary into an An",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/conda-1.html:4209,guid,guide,4209,psi4manual/1.4.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/conda-1.html,4,['guid'],['guide']
Usability," A double called FREQUENCY_SCALE_FACTOR with a default of 1.0.; A string called DATA_FILE, with a default of “data.dat” and any possible value.; A string called AO_BASIS with a default of “NONE”, and possible values of “NONE”, “DISK”, or “DIRECT”. The purpose of the “if” statement in the above read_options function is; the following. Suppose in an input file the user sets an option through; the construct set mymodule print 1 or through a set mymodule {...}; block. The first thing to happen is a call to read_options with name set; to “MYMODULE”. (Note that all user input is converted to upper case.) This; call to read_options should tell the Options object only about those; options expected by the module called “mymodule”; this prevents overlap of; options between different modules.; Notice also that there’s a special comment immediately before the; declaration of each keyword. You must provide these comments for any; options you add as they will be automatically inserted into the user; manual Providing a clear description will also help you to remember what; the keywords do and how they’re used. The comments must live between the; special comment delimiters. For options that most users shouldn’t need,; add an expert flag to the comment. This will place these options in a; separate section of the user manual.; /*- comment -*/; options.add_ ...; /*- comment !expert -*/; options.add_ ... As is apparent from the examples above, comments can span multiple lines; (see PRINT), can refer to other options (through hyperlinks; see; SAVE_INFO), can refer to sections of the manual (through hyperlinks;; see DOCC), and can contain LaTeX notation (see AO_BASIS). (To get; the LaTeX subscript command, use “@@” instead of “_”.); See Best Practices; for guidelines on naming options. What is has_changed ?¶; There are times when we need to know whether an option was provided by the; user or if the defaults are being used. For this reason, the Options; object stores a boolean has_changed ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optionshandling-1.html:3376,clear,clear,3376,psi4manual/1.0.0/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optionshandling-1.html,8,['clear'],['clear']
Usability," A double called FREQUENCY_SCALE_FACTOR with a default of 1.0.; A string called DATA_FILE, with a default of “data.dat” and any possible value.; A string called AO_BASIS with a default of “NONE”, and possible values of “NONE”, “DISK”, or “DIRECT”. The purpose of the “if” statement in the above read_options function is; the following. Suppose in an input file the user sets an option through; the construct set mymodule print 1 or through a set mymodule {...}; block. The first thing to happen is a call to read_options with name set; to “MYMODULE”. (Note that all user input is converted to upper case.) This; call to read_options should tell the Options object only about those; options expected by the module called “mymodule”; this prevents overlap of; options between different modules.; Notice also that there’s a special comment immediately before the; declaration of each keyword. You must provide these comments for any; options you add as they will be automatically inserted into the user; manual Providing a clear description will also help you to remember what; the keywords do and how they’re used. The comments must live between the; special comment delimiters. For options that most users shouldn’t need,; add an expert flag to the comment. This will place these options in a; separate section of the user manual.; 1; 2; 3; 4/*- comment -*/; options.add_ ...; /*- comment !expert -*/; options.add_ ... As is apparent from the examples above, comments can span multiple lines; (see PRINT), can refer to other options (through hyperlinks; see; SAVE_INFO), can refer to sections of the manual (through hyperlinks;; see DOCC), and can contain LaTeX notation (see AO_BASIS). (To get; the LaTeX subscript command, use “@@” instead of “_”.); See Best Practices; for guidelines on naming options. What is has_changed ?¶; There are times when we need to know whether an option was provided by the; user or if the defaults are being used. For this reason, the Options; object stores a boolean ha",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optionshandling-1.html:3381,clear,clear,3381,psi4manual/1.1.0/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optionshandling-1.html,6,['clear'],['clear']
Usability," And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; 1; 2; 3; 4; 5; 6; 7CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. A PSI4 Tutorial. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 20",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:22806,simpl,simple,22806,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,2,['simpl'],['simple']
Usability," And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; 1; 2; 3; 4; 5; 6; 7CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. A PSI4 Tutorial. © Copyright 2018, The Psi4 Project.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/tutorial-1.html:22808,simpl,simple,22808,psi4manual/1.2.1/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/tutorial-1.html,2,['simpl'],['simple']
Usability," And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; 1; 2; 3; 4; 5; 6; 7CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. A PSI4 Tutorial. © Copyright 2019, The Psi4 Project.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/tutorial-1.html:22806,simpl,simple,22806,psi4manual/1.3.2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/tutorial-1.html,2,['simpl'],['simple']
Usability," And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. A PSI4 Tutorial; Psithon Tutorial: Using PSI4 as an Executable. © ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/tutorial.html:22644,simpl,simple,22644,psi4manual/master/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/master/tutorial.html,1,['simpl'],['simple']
Usability," And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. A PSI4 Tutorial; Psithon Tutorial: Using PSI4 as an Executable. © Copyright",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/tutorial-1.html:22642,simpl,simple,22642,psi4manual/1.4.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/tutorial-1.html,2,['simpl'],['simple']
Usability," And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. A PSI4 Tutorial; Psithon Tutorial: Using PSI4 as an Executable. © Copyright",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/tutorial-1.html:22642,simpl,simple,22642,psi4manual/1.5.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/tutorial-1.html,2,['simpl'],['simple']
Usability," And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. A PSI4 Tutorial; Psithon Tutorial: Using PSI4 as an Executable. © Copyright",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/tutorial.html:22635,simpl,simple,22635,psi4manual/1.6.x/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/tutorial.html,1,['simpl'],['simple']
Usability," And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. A PSI4 Tutorial; Psithon Tutorial: Using PSI4 as an Executable. © Copyright",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/tutorial.html:22635,simpl,simple,22635,psi4manual/1.7.x/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/tutorial.html,1,['simpl'],['simple']
Usability," And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. A PSI4 Tutorial; Psithon Tutorial: Using PSI4 as an Executable. © Copyrig",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/tutorial.html:22637,simpl,simple,22637,psi4manual/1.8.x/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/tutorial.html,1,['simpl'],['simple']
Usability," And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. A PSI4 Tutorial; Psithon Tutorial: Using PSI4 as an Executable. © Copyrig",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/tutorial.html:22637,simpl,simple,22637,psi4manual/1.9.x/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/tutorial.html,1,['simpl'],['simple']
Usability," B3LYP often; producing absurdly accurate results.; A more advanced GKS functional technology which has developed enormous; popularity in recent years is the Long-Range Corrected (LRC) ansatz. LRC; recognizes that the local DFA is potentially exact at short range in the; exchange hole, and that the hybrid-exchange energy of the noninteracting; quasiparticles is also exact for true electrons at long range in the exchange; hole. Therefore LRC switches from DFA at short range to hybrid exchange at long; range, typically using the function as a; partition function.; Tying all these pieces together, a full LRC-hybrid GKS functional has the; generic form,. For LRC functionals, the choice of range-separtion parameter has; been the subject of considerable activity since the inception of LRC; functionals. Some authors advocate a static range-separation parameter; determined by optimization over a test set of chemical systems. However, a more; physically-motivated and often more accurate approach is the idea of “gap; fitting” or “optimal tuning” or simply “tuning.” The most popular tuned-LRC; approach is IP-fitting, in which the is varied until the; Koopman’s IP (the opposite of the HOMO energy) matches the true IP (the; difference between -electron and -electron total; energies), within the LRC functional ansatz. This guarantees the asymptotics of; the exchange potential,. Note that LRC functionals with default only capture the; dependence,. hybrid functionals only capture part of the dependence,. and local functionals decay exponentially, resulting in completely incorrect; asymptotics,. IP-tuned LRC functionals effectively pin the chemical potential at ; electrons to the correct value determined by the ionization potential. This; often cleans up the MSIE problem for a surprisingly large number of high-lying; occupied orbitals, as determined by fractional particle curves. Other gap; fitting techniques involving the electron affinity or band gap are sometimes; also used. IP-f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:7213,simpl,simply,7213,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,10,['simpl'],['simply']
Usability," C++ signature :. void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i). psi4.NablaInt.origin()¶; Python Library Documentation: property. The origin about which the one body ints are being computed. psi4.NablaInt.py_buffer()¶; Python Library Documentation: property. docstring. psi4.NablaInt.py_buffer_object()¶; Python Library Documentation: property. docstring. psi4.NablaInt.set_enable_pybuffer()¶; Python Library Documentation: method set_enable_pybuffer; set_enable_pybuffer(...) unbound psi4.NablaInt method. set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :. docstring; C++ signature :. void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b). OEProp¶. psi4.OEProp.add()¶; Python Library Documentation: method add; add(...) unbound psi4.OEProp method. add( (OEProp)arg1, (str)arg2) -> None :. docstring; C++ signature :. void add(N3psi6OEPropE {lvalue},Ss). psi4.OEProp.clear()¶; Python Library Documentation: method clear; clear(...) unbound psi4.OEProp method. clear( (OEProp)arg1) -> None :. docstring; C++ signature :. void clear(N3psi6OEPropE {lvalue}). psi4.OEProp.compute()¶; Python Library Documentation: method compute; compute(...) unbound psi4.OEProp method. compute( (OEProp)arg1) -> None :. docstring; C++ signature :. void compute(N3psi6OEPropE {lvalue}). psi4.OEProp.set_Da_ao()¶; Python Library Documentation: method set_Da_ao; set_Da_ao(...) unbound psi4.OEProp method. set_Da_ao( (OEProp)arg1, (Matrix)arg2, (int)arg3) -> None :. docstring; C++ signature :. void set_Da_ao(N3psi6OEPropE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE,i). psi4.OEProp.set_Da_mo()¶; Python Library Documentation: method set_Da_mo; set_Da_mo(...) unbound psi4.OEProp method. set_Da_mo( (OEProp)arg1, (Matrix)arg2) -> None :. docstring; C++ signature :. void set_Da_mo(N3psi6OEPropE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE). psi4.OEProp.set_Da_so()¶; Python Library Documentation: method set_Da_so; set_Da_so(...) unbound psi4.OEProp method. set_Da_so( (OEProp)arg1, (Matrix)arg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:261268,clear,clear,261268,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['clear'],['clear']
Usability," Caution; Use of isotopic substitution in PSI4 is not well; developed, and the syntax is subject to change. At present, isotopes can only be specified at creation-time of the molecule; The syntax for a deuterium- and tritium-substituted water is below. Note; that asymmetric isotopic substitution such as this will change the; molecule’s point group symmetry.; molecule dto {; units au; O 0.00000000 0.00000000 0.00000000; H@2.014101779 0.00000000 1.93042809 -1.10715266; H_label@3.01604927 0.00000000 -1.93042809 -1.10715266; }. The masses used by PSI4 can be found at; psi4/psi4/include/psi4/masses.h. See freq-isotope2 for about; the only use to which isotopologues can presently be put in PSI4. PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to the output file, prompting the user to provide a more; specific name. For example, if we know that we want to run a computation on a; compound whos",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html:7390,intuit,intuitive,7390,psi4manual/1.4.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html,9,['intuit'],['intuitive']
Usability," FiniteDifferenceComputer]. psi4.driver.task_planner.expand_cbs_methods(method, basis, driver, **kwargs)[source]¶; Sort out the user input method string into recognized fields.; Handles cases like:. ""mp2"" – passes through;; ""mp2/cc-pvdz"" – broken into method and basis fields;; ""mp2/cc-pv[d,t]z"" – processed into method=”cbs” & CBSMetadata spec;; method=""cbs"", cbsmeta=CBSMetadata – passes through. Parameters:. method (str) – User first argument to driver function. A string hint of the method –; see cases above.; basis (str) – User basis hint.; driver (DriverEnum) – The calling driver function. Note for finite difference that this is; the target driver, not the means driver. Return type:; Tuple[str, str, Dict]. psi4.driver.task_planner.task_planner(driver, method, molecule, **kwargs)[source]¶; Plans a task graph of a complex computation. Canonical Task layering:; ManyBody - BSSE treatment, many-body expansion; FiniteDifference - derivatives through stencils; Composite - basis set extrapolation, focal-point methods; Atomic - analytic single-points. Parameters:. driver (DriverEnum) – The resulting type of computation: e/g/h. Note for finite difference; that this should be the target driver, not the means driver.; method (str) – A string representation of the method such as “HF” or “B3LYP”. Special; cases are: “cbs”.; molecule (Molecule) – A Psi4 base molecule to use.; kwargs – User keyword arguments, often used to configure task computers. Returns:; A simple (AtomicComputer) or layered (CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer) task object. Layered objects contain many and multiple types of computers in a graph. Return type:; Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .  · ; 1.7;  · . PSI4. External API Objects. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/external_apis.html:8256,simpl,simple,8256,psi4manual/1.7.x/external_apis.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/external_apis.html,1,['simpl'],['simple']
Usability," Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; 1; 2; 3; 4; 5; 6; 7; 8; 9molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B.[Kallay:2008:144101]_ Psi4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be; more robust by Martin.[Martin:2014:785]_. name; calls method in Kallay’s MRCC program [manual]. mrccsd; CC through doubles. mrccsdt; CC through triples. mr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/mrcc-1.html:1235,simpl,simply,1235,psi4manual/1.1.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/mrcc-1.html,6,['simpl'],['simply']
Usability," Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. print_out(self: psi4.core.Vector) → None¶; Prints the vector to the output file. save(self: psi4.core.Vector, psio: psi4.core.IO, file: int) → None¶; Save the vector to disk. scale(self: psi4.core.Vector, sc: float) → None¶; Scales the elements of a vector by sc. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.ProtoVector) → None¶; Set a vector block. to_array(copy=True, dense=False)¶; Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector]) – Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {‘matrix’, ‘vector’}. Return type:; Dict[str, Any]. vector_dot(self: psi4.core.Vector, other: psi4.core.Vector) → float¶; Take the dot pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Vector.html:6634,simpl,simply,6634,psi4manual/1.7.x/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Vector.html,4,['simpl'],['simply']
Usability," OH All -7.033 6.931 -0.362 -1.860 -2.040 -4.364; PH All -2.062 2.936 -0.140 -0.435 -3.074 -2.774; All OH -11.167 6.965 -0.730 -1.739 -1.923 -8.594; All PH 2.072 2.903 0.229 -0.556 -3.191 1.456; All All -9.095 9.867 -0.501 -2.295 -5.114 -7.138. Note that the assignment of linking sigma bond contributions is a small point of; ambiguity in F-SAPT. The fsapt.dat file presents the “links-by-charge”; assignment at the top and the “links by 50-50” assignment at the bottom. We; generally prefer the latter, but both generally give qualitatively identical; energetic partitions.; Users should check the files fragA.dat and fragB.dat to ensure that; there is not too much charge delocalization from one fragment to another. This; is presented in the “Orbital Check” section in these files – a value larger than; 0.1 docc is an indication that the picture of localizable functional groups may; be breaking down. We also strongly discourage the cutting of double,; triple, or aromatic bonding motifs when partitioning the molecule into fragments; – cuts across only simple sigma bonds are encouraged. Caution; November 2022, previous to QCEngine v0.26.0 and Psi4; v1.7.0, there was a scaling inconsistency in the pairwise analysis; such that 2-BODY PAIRWISE DISPERSION CORRECTION ANALYSIS; was doubled when generated from dftd3 compared to the output from other; programs (s-dftd3 and dftd4). This shows up in the QCVariable and in the; Empirical_Disp.dat file written during energy(""fisapt0-d3"") (all; -D3 variants). Fortunately, the fsapt.py script compensated; for dftd3 (by far the most used program for this task). Users of the; pairwise analysis should take care to use the new QCEngine; AND fsapt.py script distributed with NEW Psi4. fisapt0-d4 run; with previous Psi4/fsapt.py will be wrong. fisapt0-d3 run with previous; Psi4/fsapt.py but new QCEngine will be wrong. If you’ve got legacy; calculations, it is extremely easy to check or reanalyze them to; salvage them, so please contact the develo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/fisapt.html:6842,simpl,simple,6842,psi4manual/1.7.x/fisapt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/fisapt.html,4,['simpl'],['simple']
Usability," OH All -7.033 6.931 -0.362 -1.860 -2.040 -4.364; PH All -2.062 2.936 -0.140 -0.435 -3.074 -2.774; All OH -11.167 6.965 -0.730 -1.739 -1.923 -8.594; All PH 2.072 2.903 0.229 -0.556 -3.191 1.456; All All -9.095 9.867 -0.501 -2.295 -5.114 -7.138. Note that the assignment of linking sigma bond contributions is a small point of; ambiguity in F-SAPT. The fsapt.dat file presents the “links-by-charge”; assignment at the top and the “links by 50-50” assignment at the bottom. We; generally prefer the latter, but both generally give qualitatively identical; energetic partitions.; Users should check the files fragA.dat and fragB.dat to ensure that; there is not too much charge delocalization from one fragment to another. This; is presented in the “Orbital Check” section in these files – a value larger than; 0.1 docc is an indication that the picture of localizable functional groups may; be breaking down. We also strongly discourage the cutting of double,; triple, or aromatic bonding motifs when partitioning the molecule into fragments; – cuts across only simple sigma bonds are encouraged. Order-1 Visualization with PyMol¶; The fsapt.py script above also generates a number of order-1 .pdb files; that can be used to get a quick qualitative picture of the F-SAPT partition. The; preferred way to do this is to use PyMol to make plots of the molecular geometry; with the atoms colored according to their order-1 F-SAPT contributions. We have; a set of template .pymol scripts to help with this process. These can be; obtained by running:; 1>>> copy_pymol.py. and then in PyMol:; 1>>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; Elst.pymol), which in turn load in the molecule and order-1 analysis; (contained in the .pdb file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some specific; details of the .pymol files require some small tweaks to permit; publication-quality renderings. Difference F-SAPT Ana",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fisapt-1.html:6994,simpl,simple,6994,psi4manual/1.1.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fisapt-1.html,6,['simpl'],['simple']
Usability," OH All -7.033 6.931 -0.362 -1.860 -2.040 -4.364; PH All -2.062 2.936 -0.140 -0.435 -3.074 -2.774; All OH -11.167 6.965 -0.730 -1.739 -1.923 -8.594; All PH 2.072 2.903 0.229 -0.556 -3.191 1.456; All All -9.095 9.867 -0.501 -2.295 -5.114 -7.138. Note that the assignment of linking sigma bond contributions is a small point of; ambiguity in F-SAPT. The fsapt.dat file presents the “links-by-charge”; assignment at the top and the “links by 50-50” assignment at the bottom. We; generally prefer the latter, but both generally give qualitatively identical; energetic partitions.; Users should check the files fragA.dat and fragB.dat to ensure that; there is not too much charge delocalization from one fragment to another. This; is presented in the “Orbital Check” section in these files – a value larger than; 0.1 docc is an indication that the picture of localizable functional groups may; be breaking down. We also strongly discourage the cutting of double,; triple, or aromatic bonding motifs when partitioning the molecule into fragments; – cuts across only simple sigma bonds are encouraged. Order-1 Visualization with PyMol¶; The fsapt.py script above also generates a number of order-1 .pdb files; that can be used to get a quick qualitative picture of the F-SAPT partition. The; preferred way to do this is to use PyMol to make plots of the molecular geometry; with the atoms colored according to their order-1 F-SAPT contributions. We have; a set of template .pymol scripts to help with this process. These can be; obtained by running:; >>> copy_pymol.py. and then in PyMol:; >>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; Elst.pymol), which in turn load in the molecule and order-1 analysis; (contained in the .pdb file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some specific; details of the .pymol files require some small tweaks to permit; publication-quality renderings. Difference F-SAPT Analy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fisapt-1.html:6842,simpl,simple,6842,psi4manual/1.4.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fisapt-1.html,5,['simpl'],['simple']
Usability," PSIDATADIR; export PATH=/theoryfs2/ds/cdsgroup/miniconda/envs/tpsi4/bin:$PATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/disk/for/scratch/files. Report problems at http://forum.psicode.org/t/report-conda-update-psi4-oddities-here/32. Nuclear Repulsion Energy..........................................PASSED; SAPT0 Eelst.......................................................PASSED; SAPT0 Eexch.......................................................PASSED; SAPT0 Eind........................................................PASSED; SAPT0 Edisp.......................................................PASSED; SAPT0 Etotal......................................................PASSED. [ COMPLETE ]|#######################################################################################################| 100%. Configure environment. Preceeding steps have placed conda and psi4 in your PATH, either permanently through rc-files or temporarily in this terminal session. You can keep or undo these changes. For general psi4 use, you must enable the psi4 executable to be found through any of:. prepending to PATH in shell, ~/.bashrc, ~/.tcshrc, or PBS cmd file; activating the conda environment (p4env above) in shell, ~/.bashrc, or PBS cmd file; supplying full path to executable (shell or PBS cmd file). Similarly, the scratch directory (see Scratch Files and Elementary Restart) must be specified through:. defining PSI_SCRATCH in shell, ~/.bashrc, ~/.tcshrc, or PBS cmd file. Suitable values for these variables have been printed to screen during installation (see last codeblock in step 6). Useful Commands¶. Update to latest Psi4 version; >>> conda update psi4. Install into a conda environment “p4env” instead of “root”. Second command only works on bash; for csh/tsch, setenv PATH /path/to/miniconda/envs/p4env/bin:$PATH instead. This creates a sandbox with just Psi4 and python (loaded as dependency).; >>> conda create -y -n p4env psi4; >>> source activate p4env. Install a part",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/conda-1.html:12857,undo,undo,12857,psi4manual/1.0.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/conda-1.html,2,['undo'],['undo']
Usability," Podeszwa and Szalewicz Dispersion Correction. wb88_x; B88 Short-Range GGA Exchange (HJS Model). wb97; Parameterized LRC B97 GGA XC Functional. wb97x; Parameterized Hybrid LRC B97 GGA XC Functional. wb97x-d; Parameterized Hybrid LRC B97 GGA XC Functional with Dispersion w/ Chai and Head-Gordon Dispersion Correction. wblyp; BLYP SR-XC Functional (HJS Model). wpbe; PBE SR-XC Functional (HJS Model). wpbe0; PBE0 SR-XC Functional (HJS Model). wpbe_x; PBE Short-Range GGA Exchange (HJS Model). wpbesol; PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/opt-1.html:6818,clear,clear,6818,psi4manual/4.0b3/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html,2,['clear'],['clear']
Usability," Sokolov; Module: Keywords, PSI Variables, DCFT. Theory¶; Density cumulant functional theory (DCFT) is a density-based ab initio theory; that can compute electronic energies without the use of the wavefunction. The; theory starts by writing the exact energy expression in terms of the one- and; two-particle density matrices (OPDM and TPDM):. Here we used Einstein convention for the summation over the repeated indices,; and are the standard one- and two-electron integrals,; and are the elements of the OPDM and TPDM,; respectively. Naively, one might expect that it is possible to minimize the; energy functional in the equation above and obtain the exact energy. This is,; however, not trivial, as the density matrix elements and; cannot be varied arbitrarily, but must satisfy some; conditions that make sure that the density matrices are N-representable, i.e.; correspond to an antisymmetric N-electron wavefunction. Unfortunately, no; simple set of necessary and sufficient N-representability conditions are known,; and some of the known conditions are not easily imposed. In addition, the lack; of separability of the density matrices may result in the loss of; size-consistency and size-extensivity. In DCFT one takes a different route and; replaces the TPDM in favor of its two-particle density cumulant:. The one-particle density matrix is separated into its idempotent part; and a correction :. The idempotent part of the OPDM corresponds to a Hartree-Fock-like density of; non-interacting electrons, while the non-idempotent correction ; depends on the density cumulant and describes the electron correlation effects.; Inserting the above two equations into the energy expression, we obtain:. where the antisymmetrized two-electron integrals and the generalized Fock operator; matrix elements were defined as follows:. Energy functional has several important properties. First,; the energy is now a function of two types of independent parameters, the; idempotent part of OPDM and the den",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dcft-1.html:1265,simpl,simple,1265,psi4manual/4.0b4/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dcft-1.html,4,['simpl'],['simple']
Usability," This specifies that there are two neutral, spin-singlet fragments. It is; possible to further specify that the overall complex is neutral and spin-singlet; by inserting another charge multiplicity line, separated from the first; molecule block by a – line. If any information is missing, PSI4 will set the; unprovided charges and multiplicities to be consistent with those that are given.; For example, the overall charge must be simply the sum of all fragment charges.; PSI4 further assumes that any unpaired electrons are coupled to yield the highest; possible \(M_s\) value. Psi will also favor neutral, spin-singlet fragments.; For anything complicated, we strongly suggest explicitly providing the charge; and multiplicity of each fragment as well as the total molecular charge and multiplicity. For details and examples, see https://github.com/MolSSI/QCElemental/blob/master/qcelemental/molparse/chgmult.py#L105-L136 .; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fragmented. Advanced Python¶; A named molecule in an input file is a full-fledged instance of the; powerful C++ Molecule class. Thus, all member; functions (that have been exp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psithonmol.html:16002,simpl,simple,16002,psi4manual/1.8.x/psithonmol.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psithonmol.html,3,['simpl'],['simple']
Usability," While this isn’t used for any testing machinery (except for the nearly decommissioned psi4/tests/psitest.pl for CC tests; full decommission expected by v1.6), it can be handy for users or developers to consult. test_input.py¶; Starting March 2022, one can also run tests designed as above for CTest through pytest.; To bring the test to pytest’s notice, add a file to the directory named test_input.py.; Below is an example for the psi4/tests/ci-property/test_input.py; from addons import *. @ctest_labeler(""quick;ci;cas;properties;cart;noc1""); def test_ci_property():; ctest_runner(__file__, [""grid.dat""]). This file contains much the same information as the CMakeLists.txt.; The def test_ci_property contains the name of the test, now with underscores rather than hyphens.; def test_ identifies it to pytest as a test.; That part of the function name and the name of the file, test_input.py are required, but no further registration with CMake is necessary.; Most tests need only the simple form of the runner line ctest_runner(__file__).; This uses QCEngine machinery to execute python psi4 input.dat.; If additional input files are needed from the test directory, their names can be added to the the second argument list as shown above.; Those additional input files do need to be registered in psi4/psi4/CMakeLists.txt.; Finally, the label string passed to CTest is here handed to pytest, with a few changes:. psi added automatically, so exclude it when copying from CTest CMakeLists.txt; cli added automatically to distinguish CTest origin from deliberate pytest origin, which have api added; smoke used instead of CTest smoketests; quick used instead of CTest quicktests; long used instead of CTest longtests; addon and <name-of-addon> added automatically when @uusing(""<name-of-addon>"") decorates the test or marks=using(""<name-of-addon>"") marks the test. CTest “labels” are called “marks” in pytest.; Any new marks should be added to psi4/pytest.ini. Running for Debugging¶. PSIthon tests th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/add_tests.html:9492,simpl,simple,9492,psi4manual/1.6.x/add_tests.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/add_tests.html,1,['simpl'],['simple']
Usability," [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:15540,simpl,simple,15540,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,8,['simpl'],"['simple', 'simply']"
Usability," [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:13250,simpl,simple,13250,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,8,['simpl'],"['simple', 'simply']"
Usability," [1, 0]; under the above-mentioned reduction in symmetry. The state,; whose singly-occupied orbitals are. SOCC = [0, 0, 0, 1]; would be mapped to. SOCC = [1, 0]; which is the same occupation as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; Psi4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. Psi4 provides a very simple mechanism; for doing so: simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html:13736,simpl,simple,13736,psi4manual/1.0.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html,4,['simpl'],"['simple', 'simply']"
Usability," \; conv_float2negexp(opt['SCF']['D_CONVERGENCE']['value']). if 'MAXITER' in opt['SCF']:; options['CFOUR']['CFOUR_SCF_MAXCYC']['value'] = \; opt['SCF']['MAXITER']['value']. if 'DAMPING_PERCENTAGE' in opt['SCF']:; options['CFOUR']['CFOUR_SCF_DAMPING']['value'] = \; int(10 * opt['SCF']['DAMPING_PERCENTAGE']['value']). for item in options['CFOUR']:; options['CFOUR'][item]['clobber'] = False; return text, options. # Philosophy break:; # Specification options; # Massaging options. # * No program's defaults should be tampered with w/o provokation. # want all defaults applied to all programs, so p4 scf_conv is 5 and c4 scf_conv is 5; # want separate regimes, so conv 6 covers all the p4 parts and cfour_conv = 8 covers the c4 parts; # want mixture, so basis gets applied to c4 but others don't; # first case, when options specified explicitly. # [scf][d_convergence] [cfour][cfour_scf_conv] what happens?; # 8 from opt() 7 by default; # 6 from set {...} 7 by default 6 (guideline that psi4 format converts when clear); # 8 from opt() 5 from set {...} 5 (local trumps); # 6 from set {...} 5 from set {...} 5 (local trumps); #; # energy(name) [cfour][cfour_calc_level]; # c4-scf SCF by default; # c4-scf CCSD from set {...}. [docs]def muster_modelchem(name, dertype):; """"""Transform calculation method *name* and derivative level *dertype*; into options for cfour. While deliberately requested pieces,; generally |cfour__cfour_deriv_level| and |cfour__cfour_calc_level|,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, like |cfour__cfour_cc_program|, can be; countermanded by keywords in input file ('clobber' set to False).; Occasionally, want these pieces to actually overcome keywords in; input file ('superclobber' set to True). """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)). if dertype == 0:; if lowername == 'cfour':; pass # permit clean operation of sandwich mode; else:; options['CFOUR']['CFOUR_DERIV_LEVE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:29818,guid,guideline,29818,psi4manual/1.0.0/_modules/qcdb/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html,2,"['clear', 'guid']","['clear', 'guideline']"
Usability," a new item creates a new link which goes at the end of the linked; # list, and the inherited dictionary is updated with the new key/value pair.; if key not in self:; root = self.__root; last = root[0]; last[1] = root[0] = self.__map[key] = [last, root, key]; dict_setitem(self, key, value). def __delitem__(self, key, dict_delitem=dict.__delitem__):; 'od.__delitem__(y) <==> del od[y]'; # Deleting an existing item uses self.__map to find the link which is; # then removed by updating the links in the predecessor and successor nodes.; dict_delitem(self, key); link_prev, link_next, key = self.__map.pop(key); link_prev[1] = link_next; link_next[0] = link_prev. def __iter__(self):; 'od.__iter__() <==> iter(od)'; root = self.__root; curr = root[1]; while curr is not root:; yield curr[2]; curr = curr[1]. def __reversed__(self):; 'od.__reversed__() <==> reversed(od)'; root = self.__root; curr = root[0]; while curr is not root:; yield curr[2]; curr = curr[0]. [docs] def clear(self):; 'od.clear() -> None. Remove all items from od.'; try:; for node in self.__map.itervalues():; del node[:]; root = self.__root; root[:] = [root, root, None]; self.__map.clear(); except AttributeError:; pass; dict.clear(self). [docs] def popitem(self, last=True):; '''od.popitem() -> (k, v), return and remove a (key, value) pair.; Pairs are returned in LIFO order if last is true or FIFO order if false. '''; if not self:; raise KeyError('dictionary is empty'); root = self.__root; if last:; link = root[0]; link_prev = link[0]; link_prev[1] = root; root[0] = link_prev; else:; link = root[1]; link_next = link[1]; root[1] = link_next; link_next[0] = root; key = link[2]; del self.__map[key]; value = dict.pop(self, key); return key, value. # -- the following methods do not depend on the internal structure --. [docs] def keys(self):; 'od.keys() -> list of keys in od'; return list(self). [docs] def values(self):; 'od.values() -> list of values in od'; return [self[key] for key in self]. [docs] def items(self):",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:2875,clear,clear,2875,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,1,['clear'],['clear']
Usability," a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (i.e., each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (i.e., each monomer utilizes only its; own basis set). It is also possible to run a closed-shell SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; sapt_basis='monomer' to the energy function, such as; energy('sapt2',sapt_basis='monomer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. The open-shell SAPT0 code is not; compatible yet with monomer-centered computations. Computations with Mid-bonds¶; SAPT computations with midbonds can be accomplished by adding a third ghost; monomer to the computation. For example; molecule dimer {; 0 1; He 0 0 5; --; 0 1; He 0 0 -5; --; 0 1; @He 0 0 0; }. Here the functions of the third monomer will be added to the virtual space of; the entire computation. Note that an error will be thrown if each atom in the; third monomer is not a ghost to prevent confusion with three-body SAPT which is; not currently supported by Psi4. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water di",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:32188,simpl,simply,32188,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['simpl'],['simply']
Usability," above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry; can be specified by a line reading symmetry symbol, where; symbol is the Schönflies symbol of the; (Abelian) point group to use for the computation. This need not be; specified, as the molecular symmetry is automatically detected by; PSI4. Certain computations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By default, Ångström units are used; this is changed by; adding a line that reads units spec, where spec is one; of ang, angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] datab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:8452,simpl,simplified,8452,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['simpl'],['simplified']
Usability," according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input.; Should needed elements be missing from the best; auxiliary basis or should the orbital basis be unknown to PSI4,; the auxiliary basis will fall back on def2 quad-zeta fitting bases.; Note that if BASIS is known to be larger than quad-zeta,; PSI4 will not attempt to fall back on the def2 fitting bases.; The same basis “block” syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; 1; 2; 3; 4; 5; 6; 7set df_basis_mp2 cc-pvdz-ri. or. df_basis_mp2 {; assign cc-pVDZ-RI; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; 1; 2; 3df_basis_mp2 {; assign C aug-cc-pVDZ-RI; }. Decontracted Basis Sets¶; Decontraction of the basis set can be useful in certain situations. In; order to decontract a given basis set, simply add “-decon” to the name; of the primary basis set (e.g. decontract).; 1set basis cc-pvdz-decon. Obviously this will add significantly to the computational cost of any given calculation, however it can; be useful when checking the basis set dependence of a particular calculated property or in certain situations; where a large basis set is critical. Currently it is recommended that a decontracted basis is always used when performing relativistic calculations using the X2C Hamiltonian. User-Defined Basis Sets¶. Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. There are three routes by which a basis set in G94 format can be introduced to PSI4‘s notice.; (1) Install new basis set file into PSI4 basis library.; Copy the basis set definitions for all elements into a blank file. Exclamation points denote comments.; As the first line of the file, add the word spherical or cartesian to indicate; whether the basis set wi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/basissets-1.html:6134,simpl,simply,6134,psi4manual/1.1.0/basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/basissets-1.html,2,['simpl'],['simply']
Usability," according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input.; Should needed elements be missing from the best; auxiliary basis or should the orbital basis be unknown to PSI4,; the auxiliary basis will fall back on def2 quad-zeta fitting bases.; Note that if BASIS is known to be larger than quad-zeta,; PSI4 will not attempt to fall back on the def2 fitting bases.; The same basis “block” syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; 1; 2; 3; 4; 5; 6; 7set df_basis_mp2 cc-pvdz-ri. or. df_basis_mp2 {; assign cc-pVDZ-RI; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; 1; 2; 3df_basis_mp2 {; assign C aug-cc-pVDZ-RI; }. Decontracted Basis Sets¶; Decontraction of the basis set can be useful in certain situations. In; order to decontract a given basis set, simply add “-decon” to the name; of the primary basis set (e.g. decontract).; 1set basis cc-pvdz-decon. Obviously this will add significantly to the computational cost of any given calculation, however it can; be useful when checking the basis set dependence of a particular calculated property or in certain situations; where a large basis set is critical. Currently it is recommended that a decontracted basis is always used when performing relativistic calculations using the X2C Hamiltonian. User-Defined Basis Sets¶. Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. There are three routes by which a basis set in G94 format can be introduced to PSI4’s notice.; (1) Install new basis set file into PSI4 basis library.; Copy the basis set definitions for all elements into a blank file. Exclamation points denote comments.; As the first line of the file, add the word spherical or cartesian to indicate; whether the basis set wi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/basissets-1.html:6136,simpl,simply,6136,psi4manual/1.2.1/basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/basissets-1.html,4,['simpl'],['simply']
Usability," an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; To indicate MRCC as the target software, set QC_MODULE=MRCC.; This is a change as of October 2022; previously, one prefixed the method by “mr”; to indicate MRCC (e.g., energy('mrccsdt')).; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; qc_module mrcc; }; energy('ccsdt'). 'ccsdt' in the call to energy() plus qc_module=mrcc instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; Here the qc_module=mrcc is optional since PSI4 has no builtin module; that can perform CCSDT. For a method like CCSD, no specification of QC_MODULE; will default to the CCENERGY module, and specification with value mrcc is; required to route the computation to the MRCC program.; For a CCSDT(Q) energy, simply use 'ccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you can call it directly; For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be; more robust by Martin. [Martin:2014:785]. QC_MODULE=MRCC. name; calls method in Kallay’s MRCC program [manual]. ccsd; CC through doubles [details]. ccsdt; CC through triple",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/mrcc.html:1744,simpl,simply,1744,psi4manual/1.7.x/mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/mrcc.html,4,['simpl'],['simply']
Usability," are 12 such “chunks”, which; are ordered Px,Py,Pz,Qx,Qy,Qz,Rx,Ry,Rz,Sx,Sy,Sz, where the Px refers to the x; derivative with respect to the basis functions in shell P. Note that all; integral derivatives are provided by the new integral code, unlike the previous; version where only 9 of 12 were provided and the user was responsible for using; translation invariance relationships to fill in the rest. The addresses for; each chunk are updated in the vector after each call to compute integrals, so; the user should keep a const reference to that object, and query that for the; address of interest. Density Screening¶; The old code looked only at the integral to determine whether terms can be; avoided a priori. However, if the integral is to be contracted with a; density or a density-like quantity, the screening can be performed on the; product, which yields more sparsity. To enable this, simply call the integral; object’s update_density member, passing it a SharedMatrix holding the; current density (remember that it changes during each iteration of the SCF) and; the product will be considered during screening. If only coulomb-like terms; are to be computed, the needs_exchange argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking¶; Each underlying integral engine knows whether it will use blocks, and will set up; the metadata automatically. Instead of looping over individual shells, the; user should loop over blocks supplied by the integral object; these blocks will; be just a single shell quartet combination for the case where blocking is not; used. It is simple to loop over pairs within each block using C++11 syntax, as; demonstrated in the code snippet above. Only shell pairs with significant; overlap are included in the shell block information, making this an efficient; way to loop over non-negligible terms. P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_integrals-1.html:6449,simpl,simply,6449,psi4manual/1.4.0/prog_integrals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_integrals-1.html,9,['simpl'],['simply']
Usability," are used; this is changed by adding a line that reads; units spec, where spec is one of ang,; angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to the output file, prompting the user to provide a more; specific name. For example, if we know that we want to run a computation on a; compound whos",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html:7472,intuit,intuitive,7472,psi4manual/4.0b3/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html,2,['intuit'],['intuitive']
Usability," are used; this is changed by; adding a line that reads units spec, where spec is one; of ang, angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to the output file, prompting the user to provide a more; specific name. For example, if we know that we want to run a computation on a; compound whos",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:9179,intuit,intuitive,9179,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['intuit'],['intuitive']
Usability," arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a giv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.hf.html:17476,simpl,simply,17476,psi4manual/1.4.0/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.hf.html,2,['simpl'],['simply']
Usability," by default. To explicitly activate a named; molecule, the activate command is provided. With it, the above input file can be; equivalently written as follows. Alternatively, the molecule can be specified; directly to the computing function. Below, the third calculation is the same as; the first.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28molecule h2 {; H; H 1 0.9; }. molecule h {; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf') # on H2. clean(). activate(h); set basis cc-pvdz; set reference uhf; energy('scf') # on H. # --------------------------------------; # equivalent to previous input ends here. clean(). set reference rhf; energy('scf', molecule=h2) # on H2. Job Control Keywords provides more details about the job control; and calculation keywords used in the above examples. Ghost Atoms¶; While many common computations, particularly SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; 1; 2; 3; 4molecule he2 {; He; Gh(He) 1 2.0; }. or; 1; 2; 3; 4molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Isotopic Substitution¶. Caution; Use of isotopic substitution in PSI4 is not well; developed, and the syntax is subject to change. At present, isotopes can only be specified at creation-time of the molecule; The syntax for a deuterium- and tritium-substituted water is below. Note; that asymmetric isotopic substitution such as this will change the; molecule’s point group symmetry.; 1; 2; 3; 4; 5; 6molecule dto {; units au; O 0.00000000 0.00000000 0.00000000; H@2.014101779 0.00000000 1.93042809 -1.10715266; H_label@3.01604927 0.00000000 -1.9304",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:6298,simpl,simplified,6298,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['simpl'],['simplified']
Usability," call detected; if ""cbs_metadata"" not in cbsmeta:; method = cbsmeta[""method""]; basis = cbsmeta[""basis""]; else:; method = ""cbs""; else:; cbsmeta = {}. return method, basis, cbsmeta. [docs]; def task_planner(driver: DriverEnum, method: str, molecule: core.Molecule, **kwargs) -> TaskComputers:; """"""Plans a task graph of a complex computation. Canonical Task layering:; - ManyBody - BSSE treatment, many-body expansion; - FiniteDifference - derivatives through stencils; - Composite - basis set extrapolation, focal-point methods; - Atomic - analytic single-points. Parameters; ----------; driver; The resulting type of computation: e/g/h. Note for finite difference; that this should be the target driver, not the means driver.; method; A string representation of the method such as ""HF"" or ""B3LYP"". Special; cases are: ""cbs"".; molecule; A Psi4 base molecule to use.; kwargs; User keyword arguments, often used to configure task computers. Returns; -------; Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer]; A simple (:class:`~psi4.driver.AtomicComputer`) or layered (:class:`~psi4.driver.driver_cbs.CompositeComputer`, :class:`~psi4.driver.driver_findif.FiniteDifferenceComputer`, :class:`~psi4.driver.driver_nbody.ManyBodyComputer`) task object. Layered objects contain many and multiple types of computers in a graph. """""". # Only pull the changed options; keywords = p4util.prepare_options_for_set_options(). keywords[""function_kwargs""] = {}; if ""external_potentials"" in kwargs:; keywords[""function_kwargs""].update({""external_potentials"": kwargs.pop(""external_potentials"")}). # Need to add full path to pcm file; if ""PCM__PCMSOLVER_PARSED_FNAME"" in keywords.keys():; fname = keywords[""PCM__PCMSOLVER_PARSED_FNAME""]; keywords[""PCM__PCMSOLVER_PARSED_FNAME""] = os.path.join(os.getcwd(), fname). # Pull basis out of kwargs, override globals if user specified; basis = kwargs.pop(""basis"", keywords.pop(""BASIS"", ""(auto)"")); method = method.lower(). # Expand CBS methods; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html:3831,simpl,simple,3831,psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_planner.html,3,['simpl'],['simple']
Usability," compute(self); docstring. set_Da_ao(self, Da, symmetry); docstring. set_Da_mo(self, arg0); docstring. set_Da_so(self, arg0); docstring. set_Db_ao(self, Db, symmetry); docstring. set_Db_mo(self, arg0); docstring. set_Db_so(self, arg0); docstring. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MAYER_INDICES', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']¶. Methods Documentation. Exvals(self: psi4.core.OEProp) → List[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; docstring. clear(self: psi4.core.OEProp) → None¶; docstring. compute(self: psi4.core.OEProp) → None¶; docstring. set_Da_ao(self: psi4.core.OEProp, Da: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. Exvals(self: psi4.core.OEProp) → List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.oeprop.html:1580,clear,clear,1580,psi4manual/1.3.2/api/psi4.core.oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.oeprop.html,2,['clear'],['clear']
Usability," core.Dimension (optional)) – If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 – Same as dim1 only if using a psi4.core.Dimension object. Returns:matrix – Returns the given Psi4 object. Return type:Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; 1; 2>>> data = np.random.rand(20); >>> vector = array_to_matrix(data). 1; 2; 3; 4>>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); (2, 0, 4). Matrix to Array¶; A general function that converts NumPy arrays to PSI4 data objects. psi4.driver.p4util.numpy_helper._to_array(matrix, copy=True, dense=False)[source]¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. table of contents. Interface to NumPy; Basics; NumPy Views; PSI4 Data Objects with Irreps; Array to Matrix; Matrix to Array. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wed",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/numpy-1.html:4172,simpl,simply,4172,psi4manual/1.2.1/numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/numpy-1.html,2,['simpl'],['simply']
Usability," d[k] = v. dict(**kwargs) -> new dictionary initialized with the name=value pairs. in the keyword argument list. For example: dict(one=1, two=2). Methods defined here:. __cmp__(...). x.__cmp__(y) <==> cmp(x,y). __contains__(...). D.__contains__(k) -> True if D has a key k, else False. __delitem__(...). x.__delitem__(y) <==> del x[y]. __eq__(...). x.__eq__(y) <==> x==y. __ge__(...). x.__ge__(y) <==> x>=y. __getattribute__(...). x.__getattribute__(‘name’) <==> x.name. __getitem__(...). x.__getitem__(y) <==> x[y]. __gt__(...). x.__gt__(y) <==> x>y. __init__(...). x.__init__(...) initializes x; see help(type(x)) for signature. __iter__(...). x.__iter__() <==> iter(x). __le__(...). x.__le__(y) <==> x<=y. __len__(...). x.__len__() <==> len(x). __lt__(...). x.__lt__(y) <==> x<y. __ne__(...). x.__ne__(y) <==> x!=y. __repr__(...). x.__repr__() <==> repr(x). __setitem__(...). x.__setitem__(i, y) <==> x[i]=y. __sizeof__(...). D.__sizeof__() -> size of D in memory, in bytes. clear(...). D.clear() -> None. Remove all items from D. copy(...). D.copy() -> a shallow copy of D. fromkeys(...). dict.fromkeys(S[,v]) -> New dict with keys from S and values equal to v. v defaults to None. get(...). D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. has_key(...). D.has_key(k) -> True if D has a key k, else False. items(...). D.items() -> list of D’s (key, value) pairs, as 2-tuples. iteritems(...). D.iteritems() -> an iterator over the (key, value) items of D. iterkeys(...). D.iterkeys() -> an iterator over the keys of D. itervalues(...). D.itervalues() -> an iterator over the values of D. keys(...). D.keys() -> list of D’s keys. pop(...). D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. popitem(...). D.popitem() -> (k, v), remove and return some (key, value) pair as a. 2-tuple; but raise KeyError if D is empty. setdefault(...). D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:115358,clear,clear,115358,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,12,['clear'],['clear']
Usability," defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:9141,simpl,simply,9141,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,10,['simpl'],['simply']
Usability," dense_ret[start:start + d1] = arr; start += d1; else:; dense_ret = np.zeros(shape=(ndim1, ndim2)); start1 = 0; start2 = 0; for d1, d2, arr in zip(dim1, dim2, matrix_views):; if (d1 == 0) or (d2 == 0): continue. dense_ret[start1:start1 + d1, start2:start2 + d2] = arr; start1 += d1; start2 += d2. return dense_ret. else:; return _get_raw_views(matrix, copy=copy)[0]. @property; def _np_shape(self):; """"""; Shape of the Psi4 data object; """"""; view_data = _get_raw_views(self); if self.nirrep() > 1:; return tuple(view_data[x].shape for x in range(self.nirrep())); else:; return view_data[0].shape. @property; def _np_view(self):; """"""; View without only one irrep; """"""; if self.nirrep() > 1:; raise ValidationError(""Attempted to call .np on a Psi4 data object with multiple irreps.""; ""Please use .nph for objects with irreps.""); return _get_raw_views(self)[0]. @property; def _nph_view(self):; """"""; View with irreps.; """"""; return _get_raw_views(self). @property; def _array_conversion(self):; """"""; Provides the array interface to simply classes so that np.array(core.Matrix(5, 5)) works flawlessly.; """"""; if self.nirrep() > 1:; raise ValidationError(""__array__interface__ can only be called on Psi4 data object with only one irrep!""); else:; return self.np.__array_interface__. def _np_write(self, filename=None, prefix=""""):; """"""; Writes the irreped matrix to a NumPy zipped file. Can return the packed data for saving many matrices into the same file.; """""". ret = {}; ret[prefix + ""Irreps""] = self.nirrep(); ret[prefix + ""Name""] = self.name; for h, v in enumerate(self.nph):; # If returning arrays to user, we want to return copies (snapshot), not; # views of the core.Matrix's memory.; if filename is None and not v.flags['OWNDATA']:; v = np.copy(v); ret[prefix + ""IrrepData"" + str(h)] = v. if isinstance(self, core.Matrix):; ret[prefix + ""Dim1""] = self.rowdim().to_tuple(); ret[prefix + ""Dim2""] = self.coldim().to_tuple(); if isinstance(self, core.Vector):; ret[prefix + ""Dim""] = [self.dim(x) for x in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html:8120,simpl,simply,8120,psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,2,['simpl'],['simply']
Usability," exit; msg = ""\tPubchemError\n""; msg += ""\tMultiple pubchem results were found. Replace\n\n\t\tpubchem:%s\n\n"" % (string); msg += ""\twith the Chemical ID number or exact name from one of the following and re-run.\n\n""; msg += ""\t Chemical ID IUPAC Name\n\n""; for result in results:; msg += ""%s"" % (result); if result.name().lower() == string.lower():; #We've found an exact match!; return result.getMoleculeString(); return msg. [docs]def process_molecule_command(matchobj):; """"""Function to process match of ``molecule name? { ... }``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); geometry = matchobj.group(3); pubchemre = re.compile(r'^(\s*pubchem\s*:\s*(.*)\n)$', re.MULTILINE | re.IGNORECASE); geometry = pubchemre.sub(process_pubchem_command, geometry); from_filere = re.compile(r'^(\s*from_file\s*:\s*(.*)\n)$', re.MULTILINE | re.IGNORECASE); geometry = from_filere.sub(process_from_file_command,geometry); molecule = spaces. molecule += 'psi4.efp_init()\n' # clear EFP object before Molecule read in; molecule += spaces. if name != """":; molecule += '%s = ' % (name). molecule += 'geometry(""""""%s""""""' % (geometry); if name != """":; molecule += ',""%s""' % (name). molecule += "")\n""; molecule += '%spsi4.IO.set_default_namespace(""%s"")' % (spaces, name). return molecule. [docs]def process_literal_blocks(matchobj):; """"""Function to process match of ``literals_psi4_yo-...``.""""""; return literals[matchobj.group(1)]. [docs]def process_cfour_command(matchobj):; """"""Function to process match of ``cfour name? { ... }``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); cfourblock = matchobj.group(3). literalkey = str(random.randint(0, 99999)); literals[literalkey] = cfourblock; return ""%spsi4.set_global_option(\""%s\"", \""\""\""%s\n\""\""\"")\n"" % \; (spaces, 'LITERAL_CFOUR', 'literals_psi4_yo-' + literalkey). [docs]def process_extract_command(matchobj):; """"""Function to process match of ``extract_subsets``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); result = matchobj.g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:7536,clear,clear,7536,psi4manual/1.0.0/_modules/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html,1,['clear'],['clear']
Usability," extrapolation stage as `scf` or `corl`, by default only the first stage is `scf` and every later one is `corl`.; `stage`: tag for the stage used in tables. The next items in the `cbs_metadata` array extrapolate correlation. All of the above parameters are available, with only the `wfn` and `basis` keywords required. Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters:; molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html:12636,simpl,simple,12636,psi4manual/1.7.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html,8,['simpl'],['simple']
Usability," for code used from other parties are included in; # the corresponding files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; from __future__ import print_function; from __future__ import absolute_import; import re; import os; import math; import warnings; import driver_cbs; #from wrappers import *; #from gaussian_n import * # CU; #from wrappers_cfour import * # CU; #from qmmm import * # CU. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. [docs]def fake_file11(wfn, filename='fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :type filename: string; :param filename: destination file name for file11 file. :type wfn: :ref:`Wavefunction<sec:psimod_Wavefunction>`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/aliases.html:1323,simpl,simple,1323,psi4manual/1.0.0/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/aliases.html,1,['simpl'],['simple']
Usability," form, run it locally, rename the output to output.ref, and check it into the repository alongside input.dat.; While this isn’t used for any testing machinery, it can be handy for users or developers to consult. test_input.py¶; Starting March 2022, one can also run tests designed as above for CTest through pytest.; To bring the test to pytest’s notice, add a file to the directory named test_input.py.; Below is an example for the psi4/tests/ci-property/test_input.py; from addons import *. @ctest_labeler(""quick;ci;cas;properties;cart;noc1""); def test_ci_property():; ctest_runner(__file__, [""grid.dat""]). This file contains much the same information as the CMakeLists.txt.; The def test_ci_property contains the name of the test, now with underscores rather than hyphens.; def test_ identifies it to pytest as a test.; That part of the function name and the name of the file, test_input.py are required, but no further registration with CMake is necessary.; Most tests need only the simple form of the runner line ctest_runner(__file__).; This uses QCEngine machinery to execute python psi4 input.dat.; If additional input files are needed from the test directory, their names can be added to the the second argument list as shown above.; Those additional input files do need to be registered in psi4/psi4/CMakeLists.txt.; Finally, the label string passed to CTest is here handed to pytest, with a few changes:. psi added automatically, so exclude it when copying from CTest CMakeLists.txt; cli added automatically to distinguish CTest origin from deliberate pytest origin, which have api added; smoke used instead of CTest smoketests; quick used instead of CTest quicktests; long used instead of CTest longtests; addon and <name-of-addon> added automatically when @uusing(""<name-of-addon>"") decorates the test or marks=using(""<name-of-addon>"") marks the test. CTest “labels” are called “marks” in pytest.; Any new marks should be added to psi4/pytest.ini. Running for Debugging¶. PSIthon tests th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/add_tests.html:9382,simpl,simple,9382,psi4manual/1.7.x/add_tests.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/add_tests.html,4,['simpl'],['simple']
Usability," format. Optimizations; are not allowed. Just as for QM, the center of mass; coordinates in the XYZABC format and all coordinates in the POINTS format are; taken to be in Angstroms by default or in Bohr if units au is present.; Charge and multiplicity specifications are encoded in the fragment file; and so are not read from input.; Any combination of EFP and QM fragments can be placed in a molecule; even; the oddity below is legitimate. Note that symmetry and reorientation are; automatically turned off when EFP fragments are present (symmetry c1; and no_com and no_reorient are implied).; molecule qmefp {; efp nh3 0.0 0.0 5.0 5 2 8; --; C 0.0 0.0 0.0; O 0.0 1.5 0.0; O 0.0 -1.5 0.0; --; efp h2o 5.0 0.0 0.0 5 2 8; --; He -3.0 4.0 4.0; He -4.0 5.0 4.0; --; efp ch3oh; 1.275 -2.447 -4.673; 0.709 -3.191 -3.592; 2.213 -1.978 -4.343; }. Running EFP¶; EFP can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the EFP interaction energy for benzene and two waters,; simply provide the following:; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o 4.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. energy('efp'). This computation involves purely EFP/EFP fragment interactions and is; performed entirely by the LIBEFP library. PSI4 can also handle mixed; systems of quantum mechanical (QM) and EFP fragments through the native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/libefp-1.html:4962,simpl,simply,4962,psi4manual/1.4.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/libefp-1.html,9,['simpl'],['simply']
Usability," format. Optimizations; are not allowed. Just as for QM, the center of mass; coordinates in the XYZABC format and all coordinates in the POINTS format are; taken to be in Angstroms by default or in Bohr if units au is present.; Charge and multiplicity specifications are encoded in the fragment file; and so are not read from input.; Any combination of EFP and QM fragments can be placed in a molecule; even; the oddity below is legitimate. Note that symmetry and reorientation are; automatically turned off when EFP fragments are present (symmetry c1; and no_com and no_reorient are implied).; molecule qmefp {; efp nh3 0.0 0.0 5.0 5 2 8; --; C 0.0 0.0 0.0; O 0.0 1.5 0.0; O 0.0 -1.5 0.0; --; efp h2o 5.0 0.0 0.0 5 2 8; --; He -3.0 4.0 4.0; He -4.0 5.0 4.0; --; efp ch3oh; 1.275 -2.447 -4.673; 0.709 -3.191 -3.592; 2.213 -1.978 -4.343; }. Running EFP¶; EFP can be invoked in similar fashion as other theories provided in Psi4.; For example, if you want to obtain the EFP interaction energy for benzene and two waters,; simply provide the following:; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o 4.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. energy('efp'). This computation involves purely EFP/EFP fragment interactions and is; performed entirely by the LIBEFP library. Psi4 can also handle mixed; systems of quantum mechanical (QM) and EFP fragments through the native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/libefp-1.html:4316,simpl,simply,4316,psi4manual/1.0.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/libefp-1.html,2,['simpl'],['simply']
Usability," functional.; # A useful optional argument is nmax, the total number of electrons to; # strip out of the molecule, in this case, 2.; # Many optional arguments are available, see the python file; frac.frac_nuke('wb97', molecule=h2o, nmax = 2). Dispersion Corrections¶; DFT-D dispersion corrections are discussed here.; HF-3c and PBEh-3c dispersion and BSSE corrections are discussed here.; DFT-NL dispersion corrections are discussed here. Recommendations¶; The KS-DFT code is quite new, but relatively complete. During code development,; emphasis was placed on flexibility of functional technology, efficiency for; medium to large systems in difficult electronic environments (e.g., compact; spatial extents, diffuse basis sets, low band-gaps, LRC and/or hybrid GKS; functionals), and time to code completion. We are very interested in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Advanced Functional Use and Manipulation¶; New DFT functionals can be created from scratch from within the input; file and accessed using the dft_functional k",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dft-1.html:26294,guid,guidelines,26294,psi4manual/1.3.2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dft-1.html,2,['guid'],['guidelines']
Usability," functional.; # A useful optional argument is nmax, the total number of electrons to; # strip out of the molecule, in this case, 2.; # Many optional arguments are available, see the python file; frac.frac_nuke('wb97', molecule=h2o, nmax = 2). Dispersion Corrections¶; DFT-D dispersion corrections are discussed here.; HF-3c and PBEh-3c dispersion and BSSE corrections are discussed here.; DFT-NL dispersion corrections are discussed here. Recommendations¶; The KS-DFT code is quite new, but relatively complete. During code development,; emphasis was placed on flexibility of functional technology, efficiency for; medium to large systems in difficult electronic environments (e.g., compact; spatial extents, diffuse basis sets, low band-gaps, LRC and/or hybrid GKS; functionals), and time to code completion. We are very interested in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Advanced Functional Use and Manipulation¶; Using the dft_functional keyword argument in the energy procedure call, one is able to use the orbitals generated b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:26612,guid,guidelines,26612,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,2,['guid'],['guidelines']
Usability," functional.; # A useful optional argument is nmax, the total number of electrons to; # strip out of the molecule, in this case, 2.; # Many optional arguments are available, see the python file; frac.frac_nuke('wb97', molecule=h2o, nmax = 2). Dispersion Corrections¶; DFT-D dispersion corrections are discussed here.; HF-3c and PBEh-3c dispersion and BSSE corrections are discussed here.; DFT-NL dispersion corrections are discussed here. Recommendations¶; The KS-DFT code is quite new, but relatively complete. During code development,; emphasis was placed on flexibility of functional technology, efficiency for; medium to large systems in difficult electronic environments (e.g., compact; spatial extents, diffuse basis sets, low band-gaps, LRC and/or hybrid GKS; functionals), and time to code completion. We are very interested in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Advanced Functional Use and Manipulation¶; New DFT functionals can be created from scratch from within the input; file and accessed using the dft_functional keyword argument in the; energy call:; # DFT C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:27902,guid,guidelines,27902,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,9,['guid'],['guidelines']
Usability," guess. This hybrid DF/conventional procedure can significantly accelerate SCF; computations requiring exact integrals, especially when used in concert with the; integral-direct conventional algorithm.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbita",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/scf-1.html:4335,simpl,simplest,4335,psi4manual/4.0b4/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/scf-1.html,4,['simpl'],['simplest']
Usability," have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import sys; import numpy as np. from psi4 import core; from .exceptions import *. ### Matrix and Vector properties. # The next three functions make me angry; def translate_interface(interface):; """"""; This is extra stupid with unicode; """""". if sys.version_info[0] > 2:; return interface. nouni_interface = {}; for k, v in interface.items():; if k == 'typestr':; nouni_interface[k.encode('ascii', 'ignore')] = v.encode('ascii', 'ignore'); else:; nouni_interface[k.encode('ascii', 'ignore')] = v. return nouni_interface. class numpy_holder(object):; """"""; Blank object, stupid. Apparently you cannot create a view directly from a dictionary; """"""; def __init__(self, interface):; self.__array_interface__ = translate_interface(interface). def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; ret = []; for data in self.array_interface():. # Yet another hack; if isinstance(data[""shape""], list):; data[""shape""] = tuple(data[""shape""]). if 0 in data[""shape""]:; ret.append(np.empty(shape=data[""shape""])); else:; ret.append(np.array(numpy_holder(data), copy=copy)); return ret. def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; try:; arr.shape; except:; raise ValidationError(""Expected numpy array, found object of type '%s'"", type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]def array_to_matrix(self, arr, name=""New Matrix"", dim1=None, dim2=None):; """"""; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters; ----------; arr : ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html:1878,simpl,simple,1878,psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,1,['simpl'],['simple']
Usability," high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbita",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:3678,simpl,simplest,3678,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,4,['simpl'],['simplest']
Usability," installed (instructions at Quick Installation),; gdma can be obtained through conda install gdma.; Then enable it as a feature with ENABLE_gdma,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect gdma and activate dependent code. To remove a conda installation, conda remove gdma. Source. If using PSI4 built from source and you want gdma built from; from source also,; enable it as a feature with ENABLE_gdma,; and let the build system fetch and build it and activate dependent code. Input¶; The distributed multipole analysis (DMA) technique, developed by Anthony J.; Stone and implemented by him into the GDMA package, is available in PSI4.; The current implementation simply embeds Stone’s GDMA code into the main; executable, and generates the appropriate input files automatically. The; program takes as input a data file, and a Gaussian formatted checkpoint (see; Section FCHK) file. The simplest usage of the GDMA code is; demonstrated below, along with a listing of the options supported; these; options correspond to the options described in the; GDMA manual.; If more advanced usage is desired, which is not is permitted by the options; listed below, the user may provide their own data file containing keywords to; control the GDMA code. Simply place the data file in the directory PSI4; is called from, and provide the file name as the datafile argument to the; gdma() routine. For example, if GDMA data file is called; control.dma, the GDMA code is called as follows:; 1; 2grad, wfn = gradient('mp2', return_wfn=True); gdma(wfn, datafile='control.dma'). An FCHK file will be generated for the GDMA code to read; this file will have; the prefix given by WRITER_FILE_LABEL (if set), or else by the name; of the output file plus the name of the current molecule, and the suffix will; be ‘.fchk’. This FCHK file name should be passed to the ‘File’ keyword in the; DGMA data file, to ensure that the GDMA code reads the correct wavefunction; information.; After running, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/gdma-1.html:1581,simpl,simplest,1581,psi4manual/1.1.0/gdma-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/gdma-1.html,2,['simpl'],['simplest']
Usability," is tl;dr; # be on clean master up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3rc1'; -__version_long = '1.3rc1+5a7522a'; -__version_upcoming_annotated_v_tag = '1.3rc2'; +__version__ = '1.3rc2'; +__version_long = '1.3rc2+zzzzzzz'; +__version_upcoming_annotated_v_tag = '1.3rc3'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3rc2""; [master bc8d7f5] v1.3rc2. >>> git log --oneline | head -1; bc8d7f5 v1.3rc2; >>> git tag -a v1.3rc2 bc8d7f5 -m ""v1.3rc2"". # goto GH:psi4/psi4 > Settings > Branches > master > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/424295; # uncheck ""Do not allow bypassing the above settings"" for admins and Save changes. >>> git push --atomic upstream master v1.3rc2. # pause here and push to upstream and let Azure complete for an; # on-tag Windows conda package and docs, not tag+1.dev1 .; # the atomic flag below pushes commit and tag together so only one CI; # which is necessary for Windows conda package to compute the right version.; # After push, can temporarily re-engage admins ""Do not allow ..."" protections.; # also, grab the docs build from GHA artifacts. >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version_long = '1.3rc2+zzzzzzz'; +__version_long = '1.3rc2+bc8d7f5'. >>> git add psi4/metadata.py; >>> git commit -m ""Records tag for v1.3rc2""; [master 16dbd3e] Records tag for v1.3rc2. # goto GH:psi4/psi4 > Settings > Branches > master > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/424295; # uncheck admins ""Do not allow ..."" and Save changes. >>> git push upstream master. # re-engage admins ""Do not allow ..."" protections. Tag postrelease¶. # be on clean maintenance branch up-to-date with upstream in both commits and tags; # * mi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/manage_release.html:10263,pause,pause,10263,psi4manual/1.9.x/manage_release.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/manage_release.html,2,['pause'],['pause']
Usability," k, v in iterable:. d[k] = v. dict(**kwargs) -> new dictionary initialized with the name=value pairs. in the keyword argument list. For example: dict(one=1, two=2). Methods defined here:. __cmp__(...). x.__cmp__(y) <==> cmp(x,y). __contains__(...). D.__contains__(k) -> True if D has a key k, else False. __delitem__(...). x.__delitem__(y) <==> del x[y]. __eq__(...). x.__eq__(y) <==> x==y. __ge__(...). x.__ge__(y) <==> x>=y. __getattribute__(...). x.__getattribute__(‘name’) <==> x.name. __getitem__(...). x.__getitem__(y) <==> x[y]. __gt__(...). x.__gt__(y) <==> x>y. __init__(...). x.__init__(...) initializes x; see help(type(x)) for signature. __iter__(...). x.__iter__() <==> iter(x). __le__(...). x.__le__(y) <==> x<=y. __len__(...). x.__len__() <==> len(x). __lt__(...). x.__lt__(y) <==> x<y. __ne__(...). x.__ne__(y) <==> x!=y. __repr__(...). x.__repr__() <==> repr(x). __setitem__(...). x.__setitem__(i, y) <==> x[i]=y. __sizeof__(...). D.__sizeof__() -> size of D in memory, in bytes. clear(...). D.clear() -> None. Remove all items from D. copy(...). D.copy() -> a shallow copy of D. fromkeys(...). dict.fromkeys(S[,v]) -> New dict with keys from S and values equal to v. v defaults to None. get(...). D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. has_key(...). D.has_key(k) -> True if D has a key k, else False. items(...). D.items() -> list of D’s (key, value) pairs, as 2-tuples. iteritems(...). D.iteritems() -> an iterator over the (key, value) items of D. iterkeys(...). D.iterkeys() -> an iterator over the keys of D. itervalues(...). D.itervalues() -> an iterator over the values of D. keys(...). D.keys() -> list of D’s keys. pop(...). D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. popitem(...). D.popitem() -> (k, v), remove and return some (key, value) pair as a. 2-tuple; but raise KeyError if D is empty. setdefault(...). D.setdefault(k[,d]) -> D.get(k,d)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:115344,clear,clear,115344,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,12,['clear'],['clear']
Usability," make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library; (full pathnames are recommended):; BLASLIB = /home/david/software/atlas3.9.25/lib/libf77blas.a /home/david/software/atlas3.9.25/lib/libatlas.a. Edit Makefile as necessary (probably not needed).; make. Copy the resulting file [lapack_($ARCH).a] where you want it; (a standard location like /usr/local/lib is easier for PSI to find).; It is probably helpful to rename the file liblapack.a. V. Miscellaneous Architecture-Specific Notes¶. Linux on x86 and x86_64; Intel compilers: We had trouble with icpc 12.0.x. Use 12.1 or; later. VI. Common Problems with PSI Compilation¶. No rule to make target foo.h, needed by bar.d. Stop.; This commonly happens after pulling updates from the repository. It happens; when a library header file is removed or renamed by the update, but there are; still old dependency files in the object directory, which think that they; still need to know about that header. There’s a simple remedy, just run; >>> make DODEPEND=no dclean. in the object directory. Make gets stuck in an infinite loop; This means that the makefiles have not been properly updated. Running; >>> autoconf. in the top-level Psi directory, followed by; >>> ./config.status --recheck; >>> ./config.status. in the object directory should fix it. This procedure will need to be run; whenever an update changes the directory structure. Incompatible g++/icpc; The Intel compilers require an installed set of C++ headers. Unfortunately,; the GNU compilers tend to be more cutting-edge than the Intel compilers,; meaning that Intel is always playing catch-up to new features in g++. This; means the two are often incompatible, leading to trouble if one wants to use; icpc to compile PSI4 (or anything else...). Your best bet in general is to not; upgrade Linux too fast, and always keep the very latest Intel compilers; around. Missing symbols like “do_fio” or “e_wsfe”; See Section IV(3) above. Table Of Contents. Installation Instruc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:26324,simpl,simple,26324,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,3,['simpl'],['simple']
Usability," mass; coordinates in the XYZABC format and all coordinates in the POINTS format are; taken to be in Angstroms by default or in Bohr if units au is present.; Charge and multiplicity specifications are encoded in the fragment file; and so are not read from input.; Any combination of EFP and QM fragments can be placed in a molecule; even; the oddity below is legitimate. Note that symmetry and reorientation are; automatically turned off when EFP fragments are present (symmetry c1; and no_com and no_reorient are implied).; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17molecule qmefp {; efp nh3 0.0 0.0 5.0 5 2 8; --; C 0.0 0.0 0.0; O 0.0 1.5 0.0; O 0.0 -1.5 0.0; --; efp h2o 5.0 0.0 0.0 5 2 8; --; He -3.0 4.0 4.0; He -4.0 5.0 4.0; --; efp ch3oh; 1.275 -2.447 -4.673; 0.709 -3.191 -3.592; 2.213 -1.978 -4.343; }. Running EFP¶; EFP can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the EFP interaction energy for benzene and two waters,; simply provide the following:; 1; 2; 3; 4; 5; 6; 7; 8; 9molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o 4.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. energy('efp'). This computation involves purely EFP/EFP fragment interactions and is; performed entirely by the LIBEFP library. PSI4 can also handle mixed; systems of quantum mechanical (QM) and EFP fragments through the native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/libefp-1.html:4960,simpl,simply,4960,psi4manual/1.1.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/libefp-1.html,6,['simpl'],['simply']
Usability," matrix is separated into its idempotent part; and a correction :. The idempotent part of the OPDM corresponds to a Hartree-Fock-like density of; non-interacting electrons, while the non-idempotent correction ; depends on the density cumulant and describes the electron correlation effects.; Inserting the above two equations into the energy expression, we obtain:. where the antisymmetrized two-electron integrals and the generalized Fock operator; matrix elements were defined as follows:. Energy functional has several important properties. First,; the energy is now a function of two types of independent parameters, the; idempotent part of OPDM and the density cumulant; . As a result, the energy functional is Hermitian,; which is important for the evaluation of the molecular properties. The additive; separability of the density cumulant guarantees that all of the DCFT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent part of the OPDM is; N-representable by construction. One only needs to worry about the; N-representability of the density cumulant, which is a relatively small part of; the TPDM.; In order to obtain the DCFT energy, two conditions must be satisfied:; 1) The energy must be stationary with respect to the variation of the; idempotent part of the one-particle density matrix . This is; achieved by the self-consistent diagonalization of the generalized Fock; operator matrix defined above, which introduces the relaxation of the orbitals.; 2) The energy must be stationary with respect to the variation of the density; cumulant , constrained to the N-representability conditions.; Making the energy stationary requires the solution of the two sets of coupled; equations for the orbital and cumulant updates, respectively (also known as; residual equations). At the present moment three different algorithms for the; solution of the system of coupled equations are available (see s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dcft-1.html:2650,simpl,simplified,2650,psi4manual/4.0b4/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dcft-1.html,4,['simpl'],['simplified']
Usability," name_hint (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; dashcoeff[dashlevel][functional-without-dashlevel] or; dashcoeff_supplement[dashlevel][functional-with-dashlevel]; can be overwritten via param_tweaks.; level_hint (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to one.; param_tweaks (Union[Dict, List, None]) – Values for the same keys as dashcoeff[dashlevel][‘default’]; (and same order if list) used to override any or all values; initialized by name_hint. Extra parameters will error.; engine (Optional[str]) – Override which code computes dispersion. See above for allowed; values. Formerly (pre Nov 2022) only relevant for -D2, which can be computed by; libdisp or dftd3. Now (post Nov 2022) also relevant for -D3 variants,; which can be computed by dftd3 executable or simple-dftd3 Python module.; gcp_engine (Optional[str]) – Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp (bool) – Whether to request atomic pairwise analysis. Methods Summary. compute_energy(molecule[, wfn]); Compute dispersion energy based on engine, dispersion level, and parameters in self. compute_gradient(molecule[, wfn]); Compute dispersion gradient based on engine, dispersion level, and parameters in self. compute_hessian(molecule[, wfn]); Compute dispersion Hessian based on engine, dispersion level, and parameters in self. print_out(); Format dispersion parameters of self for output file. Methods Documentation. compute_energy(molecule, wfn=None)[source]¶; Compute dispersion energy based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule) – System for which to compute empirical dispersion correction.; wfn (Optional[Wavefunction]) – Location",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.EmpiricalDispersion.html:3497,simpl,simple-,3497,psi4manual/1.7.x/api/psi4.driver.EmpiricalDispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.EmpiricalDispersion.html,3,['simpl'],['simple-']
Usability," name_hint (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; dashcoeff[dashlevel][functional-without-dashlevel] or; dashcoeff_supplement[dashlevel][functional-with-dashlevel]; can be overwritten via param_tweaks.; level_hint (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to one.; param_tweaks (Union[Dict, List, None]) – Values for the same keys as dashcoeff[dashlevel][‘default’]; (and same order if list) used to override any or all values; initialized by name_hint. Extra parameters will error.; engine (Optional[str]) – Override which code computes dispersion. See above for allowed; values. Formerly (pre Nov 2022) only relevant for -D2, which can be computed by; libdisp or dftd3. Now (post Nov 2022) also relevant for -D3 variants,; which can be computed by dftd3 executable or simple-dftd3 Python module.; gcp_engine (Optional[str]) – Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp (bool) – Whether to request atomic pairwise analysis. table of contents. Interface to DFTD3 by S. Grimme; Empirical Dispersion Implementations; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections; run_dftd3(); run_dftd4(); EmpiricalDispersion; EmpiricalDispersion.dashlevel; EmpiricalDispersion.dashparams; EmpiricalDispersion.fctldash; EmpiricalDispersion.description; EmpiricalDispersion.dashlevel_citation; EmpiricalDispersion.dashparams_citation; EmpiricalDispersion.dashcoeff_supplement; EmpiricalDispersion.engine; EmpiricalDispersion.disp; EmpiricalDispersion.ordered_params. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to DFTD3 by S.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/dftd3.html:19852,simpl,simple-,19852,psi4manual/master/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/master/dftd3.html,1,['simpl'],['simple-']
Usability," name_hint (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; dashcoeff[dashlevel][functional-without-dashlevel] or; dashcoeff_supplement[dashlevel][functional-with-dashlevel]; can be overwritten via param_tweaks.; level_hint (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to one.; param_tweaks (Union[Dict, List, None]) – Values for the same keys as dashcoeff[dashlevel][‘default’]; (and same order if list) used to override any or all values; initialized by name_hint. Extra parameters will error.; engine (Optional[str]) – Override which code computes dispersion. See above for allowed; values. Formerly (pre Nov 2022) only relevant for -D2, which can be computed by; libdisp or dftd3. Now (post Nov 2022) also relevant for -D3 variants,; which can be computed by dftd3 executable or simple-dftd3 Python module.; gcp_engine (Optional[str]) – Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp (bool) – Whether to request atomic pairwise analysis. table of contents. Interface to DFTD3 by S. Grimme; Empirical Dispersion Implementations; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections; run_dftd3(); run_dftd4(); EmpiricalDispersion; EmpiricalDispersion.dashlevel; EmpiricalDispersion.dashparams; EmpiricalDispersion.fctldash; EmpiricalDispersion.description; EmpiricalDispersion.dashlevel_citation; EmpiricalDispersion.dashparams_citation; EmpiricalDispersion.dashcoeff_supplement; EmpiricalDispersion.engine; EmpiricalDispersion.disp; EmpiricalDispersion.ordered_params. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to DFTD3 by S. Grimme",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/dftd3.html:19845,simpl,simple-,19845,psi4manual/1.9.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/dftd3.html,1,['simpl'],['simple-']
Usability," ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]; Serializes instance into dictionary according to schema dtype. to_string(dtype, units='Angstrom', atom_format=None, ghost_format=None, width=17, prec=12)[source]; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int) → int; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule) → str; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int) → float; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int) → psi4.core.Vector3; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int) → float; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int) → float; z position [Bohr] of atom arg0 (0-indexed without dummies). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:61878,clear,clearing,61878,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,1,['clear'],['clearing']
Usability," number of a posteriori dispersion corrections are available in; PSI4. While some are computed within PSI4‘s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 or -D4 corrections and their variants are; available only through the DFTD3 or DFTD4 programs. Once installed, the; dftd3/PSI4 and dftd4/PSI4 interfaces are transparent, and all corrections are; interfaced exactly alike.; The -D3 interface can use classic or simple-dftd3 programs interchangeably and will prefer the latter.; Despite different defaults in these programs when run independently,; when run through PSI4 as EmpiricalDispersion engine, each should; produce the same result. Moreover, PSI4‘s own defaults and aliases; are unchanged by the new engines, so -D continues to mean -D2,; -D3 continues to mean zero-damping without 3-body correction,; and input files should continue producing the same results. Please file; an issue if found otherwise.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, a B3LYP-D3 (zero-damping), and a B3LYP-D4 (Becke-Johnson damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'); energy('b3lyp-d4'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2.; No text output is available from the dftd4 or s-dftd3 programs. Variants of dispersion corrections¶. Extension [1] and Aliases; Variant; Computing Program (engine); DFT_DISPERSION_PARAMETERS [11]. -D; alias to -D2. -D1; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:6979,simpl,simple,6979,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,2,['simpl'],['simple']
Usability," obtained through conda install dftd3 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; the dftd3 executable can be obtained through conda install dftd3 -c psi4.; To remove a conda installation, conda remove dftd3. Source. If using PSI4 built from source and you want to build DFTD3 from; from source also,; follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a; Fortran compiler, and run make). From version 3.1.0 onwards, DFTD3 can; be used as-is; for earlier versions, patches are available:; psi4/psi4/share/psi4/scripts/patch_grimme_dftd3.3.0.2. To be used by PSI4, the program binary (dftd3) must be; found in your PSIPATH or PATH (in that order). If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular dftd3 compilation, simply adjust its; position in the path environment variables. Theory¶; The local or semilocal character of conventional density functionals; necessarily leads to neglect of the long-range correlation interactions; which capture attractive van der Waals forces. Initially proposed by Yang; [Wu:2002:515] and assiduously developed by Grimme, [Grimme:2004:1463]; [Grimme:2006:1787] [Grimme:2010:154104] the DFT+Dispersion method; appends to the base functional a scaled, damped, and fitted leading term; to the well-known dispersion energy series, \(E_{disp} = -C_6/R^6; -C_8/R^8 -C_{10}/R^{10}-\cdots\). The DFT-D2 [Grimme:2006:1787] variant; takes the explicit form below. Here, dispersion coefficients,; \(C_6^{ij}\), obtained from the geometric mean of tabulated elemental; values, are summed over interatomic distances, \(R_{ij}\), modulated; by a damping function, \(f_{damp}(R_{ij})\), that gradually activates; the dispersion correction (at a rate characterized by \(\alpha_6\)); over a distance c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dftd3-1.html:1551,simpl,simply,1551,psi4manual/1.4.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dftd3-1.html,5,['simpl'],['simply']
Usability," of process_input() applied to the XYZ format of molecule, passed as either fragmented geometry string mol or molecule instance mol. format_options_for_input([molecule]); Function to return a string of commands to replicate the current state of user-modified options. free_atom_volumes(wfn, **kwargs); Computes free-atom volumes using MBIS density partitioning. get_memory(); Return the total memory allocation in bytes. get_psifile(fileno[, pidspace]); Form full path and filename for psi scratch file. getattr_ignorecase(module, attr); Extract attribute attr from module if attr is available in any possible lettercase permutation. hamiltonian_solver(engine, guess, *, nroot); Finds the smallest eigenvalues and associated right and left hand eigenvectors of a large real Hamiltonian eigenvalue problem emulated through an engine. hold_options_state(); Return a context manager that will collect the current state of Process:environment.options on entry to the with-statement and clear and restore the collected keywords state when exiting the with-statement. import_ignorecase(module); Import loader for module in any possible lettercase permutation. kwargs_lower(kwargs); Function to rebuild and return kwargs dictionary sanitized. levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. libint2_configuration(); Returns information on integral classes, derivatives, and AM from currently linked Libint2. libint2_print_out(). rtype:; None. mat2arr(mat); Convert Matrix to List. message_box(message[, max_width, min_width]); Put a message string into a box for extra attention. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. pcm_helper(block); Helper to specify the multiline PCMSolver syntax for PCM. plump_qcvar(key, val); Prepare serialized QCVariables for QCSchema AtomicResult.extras[""qcvars""] by converting flat arrays into numpy, shaped ones and floating strings. prefactor_ecd(); Prefactor for converting microscopic observable to decadic molar exti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psi4api.html:26020,clear,clear,26020,psi4manual/1.8.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psi4api.html,1,['clear'],['clear']
Usability," of process_input() applied to the XYZ format of molecule, passed as either fragmented geometry string mol or molecule instance mol. format_options_for_input([molecule]); Function to return a string of commands to replicate the current state of user-modified options. free_atom_volumes(wfn, **kwargs); Computes free-atom volumes using MBIS density partitioning. get_memory(); Return the total memory allocation in bytes. get_psifile(fileno[, pidspace]); Form full path and filename for psi scratch file. getattr_ignorecase(module, attr); Extract attribute attr from module if attr is available in any possible lettercase permutation. hamiltonian_solver(engine, guess, *, nroot); Finds the smallest eigenvalues and associated right and left hand eigenvectors of a large real Hamiltonian eigenvalue problem emulated through an engine. hold_options_state(); Return a context manager that will collect the current state of Process:environment.options on entry to the with-statement and clear and restore the collected keywords state when exiting the with-statement. import_ignorecase(module); Import loader for module in any possible lettercase permutation. kwargs_lower(kwargs); Function to rebuild and return kwargs dictionary sanitized. levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. mat2arr(mat); Convert Matrix to List. message_box(message[, max_width, min_width]); Put a message string into a box for extra attention. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. pcm_helper(block); Helper to specify the multiline PCMSolver syntax for PCM. plump_qcvar(val, shape_clue[, ret]); Prepare serialized QCVariable for set_variable() by converting flat arrays into shaped ones and floating strings. prefactor_ecd(); Prefactor for converting microscopic observable to decadic molar extinction coefficient in electronic circular dichroism. prefactor_opa(); Prefactor for converting microscopic observable to decadic molar extinction coefficient in one-photo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:25920,clear,clear,25920,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,1,['clear'],['clear']
Usability," of the; molecule block, they are interpreted as the molecular charge and multiplicity; (), respectively. The symmetry can be specified by a line reading; symmetry symbol, where symbol is; the Schönflies symbol of the (Abelian) point group to use for the; computation; see Sec. Symmetry for more details. This need not be; specified, as the molecular symmetry is automatically detected by PSI4.; Certain computations require that the molecule is not reoriented; this can be; achieved by adding either no_reorient or noreorient. By default,; Ångström units are used; this is changed by adding a line that reads; units spec, where spec is one of ang,; angstrom, a.u., au, or bohr. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to the output file, prompting the user to provide a more; specific name. For example, if we know that we want to run a computation on a; compound whos",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:6902,intuit,intuitive,6902,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,2,['intuit'],['intuitive']
Usability," one electron integral code used translational invariance relations to; minimze the number of integrals to be computed, leaving the caller with some; bookkeeping to do to compute all terms. For example, consider an overlap; integral: its value depends only on the relative separation of the two centers; and not their absolute positions in space. Therefore, the derivative with; respect to center A is the negative of the same derivative with respect to; center B, so one is trivially gleaned from the other. Extending this to second; derivatives, the same principle leads to the fact that double derivatives with; respect to center A are equal to double derivatives with respect to center B,; which are also equal to the negative of the mixed double derivatives with; respect to both center A and B. The old code only provided the double; derivative with respect to center A, leaving the caller to determine the other; values. The Libint2 engine instead provides all integrals, so the caller; simply needs to loop over all of the buffers provided in the appropriate order. Changes to External Potential Engines¶; Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted “CartAO”) and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set.; Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges woul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/prog_integrals.html:14798,simpl,simply,14798,psi4manual/1.6.x/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html,5,['simpl'],['simply']
Usability," one it wants is what you inserted into PYTHONPATH at pos’n 1.; The way around this is to move the python file you’re running to any other directory. Or, within the file, do sys.path.insert(0, {objdir}/stage/{prefix}/lib/{pymod_lib_dir}. How to find tests without output.ref¶; Ideally, each new test or much-altered test should add its own; output.ref. When that doesn’t happen, this command helps.; find tests/ -mindepth 1 -maxdepth 1 -type d '!' -exec test -e ""{}/output.ref"" "";"" -print. How to do GitHub issue management and code review¶. Anyone, core-dev or not, is encouraged to review PRs. It’s actually good practice for interacting with other open-source projects, where you don’t have the advantage of knowing or working with the contributors. Before venturing into projects on GitHub where you don’t know the maintainers, it doesn’t hurt to read https://snarky.ca/setting-expectations-for-open-source-participation/ .; Psi4 is a learning tool for all involved, so partial reviews in areas of confidence and questions and comments on PRs in general are encouraged.; Approving before CI completes is fine, though it can be mildly personally embarrassing when CI catches something you didn’t.; All main branches (master and 1.N.x maintenance) are protected by GitHub, including administrators, so even with write access, no one can accidentally push (master) or rewrite the history (master and maintenance).; PR owners who also have maintainer status can merge their PRs as GitHub enforces three external reviews.; Unless there’s been a lot of discussion on core-dev about merge order, generally the 3rd positive reviewer merges the PR. Also fine to add review and leave merge for later.; Presently only Travis-CI is set up as a required-to-merge service. Incomplete Azure won’t block merging, but we do usually let it complete before merging unless it’s a trivial PR.; We don’t enforce branches to be up to date before merging since that’d be a lot of extra CI time and coordination when merg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/manage_git-1.html:8728,learn,learning,8728,psi4manual/1.4.0/manage_git-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/manage_git-1.html,6,['learn'],['learning']
Usability," one it wants is what you inserted into PYTHONPATH at pos’n 1.; The way around this is to move the python file you’re running to any other directory. Or, within the file, do sys.path.insert(0, {objdir}/stage/{prefix}/lib/{pymod_lib_dir}. How to find tests without output.ref¶; Ideally, each new test or much-altered test should add its own; output.ref. When that doesn’t happen, this command helps.; find tests/ -mindepth 1 -maxdepth 1 -type d '!' -exec test -e ""{}/output.ref"" "";"" -print. How to do GitHub issue management and code review¶. Anyone, core-dev or not, is encouraged to review PRs. It’s actually good practice for interacting with other open-source projects, where you don’t have the advantage of knowing or working with the contributors. Before venturing into projects on GitHub where you don’t know the maintainers, it doesn’t hurt to read https://snarky.ca/setting-expectations-for-open-source-participation/ .; Psi4 is a learning tool for all involved, so partial reviews in areas of confidence and questions and comments on PRs in general are encouraged.; Approving before CI completes is fine, though it can be mildly personally embarrassing when CI catches something you didn’t.; All main branches (master and 1.N.x maintenance) are protected by GitHub, including administrators, so even with write access, no one can accidentally push (master) or rewrite the history (master and maintenance).; PR owners who also have maintainer status can merge their PRs as GitHub enforces two external reviews.; Unless there’s been a lot of discussion on core-dev about merge order, generally the 2nd positive reviewer merges the PR. Also fine to add review and leave merge for later.; Presently only Azure is set up as a required-to-merge service. Incomplete GHA Ecosystem or Docs won’t block merging, but we do usually let it complete before merging unless it’s a trivial PR.; We don’t enforce branches to be up to date before merging since that’d be a lot of extra CI time and coordination",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/manage_git.html:8730,learn,learning,8730,psi4manual/1.8.x/manage_git.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/manage_git.html,3,['learn'],['learning']
Usability," or conda remove gcp-correction. Source. If using PSI4 built from source and you want to build gCP from; from source also, follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a Fortran compiler, and run make). To be used by PSI4, the program binary (gcp or mctc-gcp) must be; found in your PATH so that QCEngine can detect it. Check if and where; found through qcengine info. If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The interface; can use classic or mctc-gcp executables interchangeably and will prefer the latter.; A DFTD3 executable, classic or simple-dftd3,; must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; optimize('pbeh3c'). HF-3c with non-standard basis; set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/gcp.html:2171,simpl,simple-,2171,psi4manual/1.7.x/gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/gcp.html,2,['simpl'],['simple-']
Usability," passed position b in Bohr with a tolerance tol.; >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. atom_entry(atom)[source]¶; Returns the CoordEntry for an atom. atom_to_unique(iatom)[source]¶; NYI Converts an atom number to the number of its generating unique atom.; The return value is in [0, nunique). atom_to_unique_offset(iatom)[source]¶; NYI Converts an atom number to the offset of this atom; in the list of generated atoms. The unique atom itself is allowed offset 0. center_of_mass()[source]¶; Computes center of mass of molecule (does not translate molecule).; >>> H2OH2O.center_of_mass(); [-0.12442647346606871, 0.00038657002584110707, 0.0]. charge(atom)[source]¶; Returns charge of atom (0-indexed).; Related to SAD guess in libmints version.; >>> print H2OH2O.charge(4); 1.0. charge_specified()[source]¶; Whether the charge was given by the user; >>> print H2OH2O.charge_specified(); True. clear()[source]¶; Zero it out. clone()[source]¶; Returns new, independent Molecule object.; >>> dimer = H2OH2O.clone(). create_molecule_from_string(text)[source]¶; Given a string geom of psi4-style geometry specification; (including newlines to separate lines), builds a new molecule.; Called from constructor. create_psi4_string_from_molecule()[source]¶; Regenerates a input file molecule specification string from the; current state of the Molecule. Contains geometry info,; fragmentation, charges and multiplicities, and any frame; restriction. deactivate_all_fragments()[source]¶; Sets all fragments in the molecule to be inactive. distance_matrix()[source]¶; Computes a matrix depicting distances between atoms. Prints; formatted and returns array.; >>> H2OH2O.distance_matrix(); Interatomic Distances (Angstroms); [1] [2] [3] [4] [5] [6]; [1] 0.00000; [2] 0.95711 0.00000; [3] 0.96391 1.51726 0.00000; [4] 2.91042 3.34878 1.95159 0.00000; [5] 3.32935 3.86422 2.43843 0.95895 0.00000; [6] 3.32935 3.86422 2.438",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:45651,clear,clear,45651,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['clear'],['clear']
Usability," passed position b in Bohr with a tolerance tol.; >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. atom_entry(atom)[source]¶; Returns the CoordEntry for an atom. atom_to_unique(iatom)[source]¶; NYI Converts an atom number to the number of its generating unique atom.; The return value is in [0, nunique). atom_to_unique_offset(iatom)[source]¶; NYI Converts an atom number to the offset of this atom; in the list of generated atoms. The unique atom itself is allowed offset 0. center_of_mass()[source]¶; Computes center of mass of molecule (does not translate molecule).; >>> H2OH2O.center_of_mass(); [-0.12442647346606871, 0.00038657002584110707, 0.0]. charge(atom)[source]¶; Returns charge of atom (0-indexed).; Related to SAD guess in libmints version.; >>> print H2OH2O.charge(4); 1.0. charge_specified()[source]¶; Whether the charge was given by the user; >>> print H2OH2O.charge_specified(); True. clear()[source]¶; Zero it out. clone()[source]¶; Returns new, independent Molecule object.; >>> dimer = H2OH2O.clone(). create_molecule_from_string(text)[source]¶; Given a string geom of psi4-style geometry specification; (including newlines to separate lines), builds a new molecule.; Called from constructor. deactivate_all_fragments()[source]¶; Sets all fragments in the molecule to be inactive. distance_matrix()[source]¶; Computes a matrix depicting distances between atoms. Prints; formatted and returns array.; >>> H2OH2O.distance_matrix(); Interatomic Distances (Angstroms); [1] [2] [3] [4] [5] [6]; [1] 0.00000; [2] 0.95711 0.00000; [3] 0.96391 1.51726 0.00000; [4] 2.91042 3.34878 1.95159 0.00000; [5] 3.32935 3.86422 2.43843 0.95895 0.00000; [6] 3.32935 3.86422 2.43843 0.95895 1.51712 0.00000. equivalent(iuniq, j)[source]¶; NYI Returns the j’th atom equivalent to iuniq. everything()[source]¶; Quick print of class data. extract_fragments(reals, ghosts=[])[source]¶; Makes a copy of the molecule, retur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:41911,clear,clear,41911,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,4,['clear'],['clear']
Usability," perpendicular geometry does not allow much overlap between the monomers.; Hence, the SAPT analysis helps clarify (and quantify) our physical; understanding about the interaction between the two monomers. Potential Surface Scans and Counterpoise Correction Made Easy with Psithon¶; Finally, let’s consider an example that shows how the Python driver; in PSI4 simplifies some routine tasks. PSI4 can interpret; valid Python code in addition to the computational chemistry directives; we’ve seen in the previous examples; we call this mixture Psithon.; The Python computer language is very easy to pick up, and even users; previously unfamiliar with Python can use it to simplify tasks by; modifying some of the example input files supplied with PSI4; in the psi4/samples directory.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; create separate input files for each distance to be studied. But most of; these input files are identical, except that the interatomic distance is; different. Psithon lets you specify all this in a single input file,; looping over the different distances with an array like this:; Rvals=[2.5, 3.0, 4.0].; Let’s also suppose you want to do counterpoise (CP) corrected energies.; Counterpoise correction involves computing the dimer energy and then; subtracting out the energies of the two monomers, each evaluated in the; dimer basis. Again, each of these computations could be run in a separate; input file, but because counterpoise correction is a fairly standard; procedure for intermolecular interactions, PSI4 knows about it and has; a built-in routine to perform counterpoise correction. It only needs to; know what method you want to do the counterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s monomer; B. This last issue of specifying the mon",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:14517,simpl,simple,14517,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,8,['simpl'],['simple']
Usability," perpendicular geometry does not allow much overlap between the monomers.; Hence, the SAPT analysis helps clarify (and quantify) our physical; understanding about the interaction between the two monomers. Potential Surface Scans and Counterpoise Correction Made Easy with Psithon¶; Finally, let’s consider an example that shows how the Python driver; in PSI4 simplifies some routine tasks. PSI4 can interpret; valid Python code in addition to the computational chemistry directives; we’ve seen in the previous examples; we call this mixture Psithon.; The Python computer language is very easy to pick up, and even users; previously unfamiliar with Python can use it to simplify tasks by; modifying some of the example input files supplied with PSI4; in the psi4/samples directory.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; create separate input files for each distance to be studied. Most of; these input files are identical, except that the interatomic distance is; different. Psithon lets you specify all this in a single input file,; looping over the different distances with an array like this:; Rvals=[2.5, 3.0, 4.0].; Let’s also suppose you want to do counterpoise (CP) correction to compute interaction energies.; Counterpoise correction involves computing the dimer energy and then; subtracting out the energies of the two monomers, each evaluated in the; dimer basis. Again, each of these computations could be run in a separate; input file, but because counterpoise correction is a fairly standard; procedure for intermolecular interactions, PSI4 knows about it and has; a built-in routine to perform counterpoise correction. It only needs to; know what method you want to do the counterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s monomer; B. This last issue o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:16372,simpl,simple,16372,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,15,['simpl'],['simple']
Usability," perpendicular geometry does not allow much overlap between the monomers.; Hence, the SAPT analysis helps clarify (and quantify) our physical; understanding about the interaction between the two monomers. Potential Surface Scans and Counterpoise Correction Made Easy with Psithon¶; Finally, let’s consider an example that shows how the Python driver; in Psi4 simplifies some routine tasks. Psi4 can interpret; valid Python code in addition to the computational chemistry directives; we’ve seen in the previous examples; we call this mixture Psithon.; The Python computer language is very easy to pick up, and even users; previously unfamiliar with Python can use it to simplify tasks by; modifying some of the example input files supplied with Psi4; in the psi4/samples directory.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; create separate input files for each distance to be studied. Most of; these input files are identical, except that the interatomic distance is; different. Psithon lets you specify all this in a single input file,; looping over the different distances with an array like this:; Rvals=[2.5, 3.0, 4.0].; Let’s also suppose you want to do counterpoise (CP) corrected energies.; Counterpoise correction involves computing the dimer energy and then; subtracting out the energies of the two monomers, each evaluated in the; dimer basis. Again, each of these computations could be run in a separate; input file, but because counterpoise correction is a fairly standard; procedure for intermolecular interactions, Psi4 knows about it and has; a built-in routine to perform counterpoise correction. It only needs to; know what method you want to do the counterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s monomer; B. This last issue of specifying the monomer",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:15632,simpl,simple,15632,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['simpl'],['simple']
Usability," perturbation; Use PRINT options to indicate printing to output file. Use WRITE; options to indicate printing to another file. This probably isn’t; entirely valid now but should be observed in future. The complement to; WRITE is READ. PRINT, READ, and WRITE will usually; be the last words in an option name.; Use FOLLOW_ROOT for the state to be followed in geometry optimizations; WFN (not wavefunction); You’re welcome to use WFN and DERTYPE as internal options, but; plan to have these set by the python driver and mark them as !expert; options. Really avoid using JOBTYPE.; You’re not welcome to add CHARGE or MULTP options. Plan to get; these quantities from the molecule object. Since we frequently use subsets; of systems (with their own charge and multiplicity), this is safer.; Conform. Just grep 'add' psi4/src/read_options.cc to get a list of; all the option names in PSI4 and try to match any conventions you; find.; If you have a quantity you’d like to call a cutoff, a threshold, a; tolerance, or a convergence, consider the following guidelines in naming; it. If its value is typically greater than ~0.001, give it a name with CUTOFF.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with larger values (e.g.,; integrals, occupations, eigenvectors), give it a name with TOLERANCE.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with smaller values (e.g., energy; changes, residual errors, gradients), give it a name with; CONVERGENCE. In deciding how to arrange words in an option name, place the context; first (e.g., MP2_AMPS_PRINT, TRIPLES_DIIS). This means PRINT; will generally be at the end of an option name.; Use INTS_TOLERANCE (not schwarz_cutoff); H in an option name is reserved for Hamiltonian (or hydrogen).; Hessian should be HESS.; All option names should be all caps and separated by underscores.; If you have an option that instructs your module",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/manage_addon-1.html:8481,guid,guidelines,8481,psi4manual/1.4.0/manage_addon-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/manage_addon-1.html,9,['guid'],['guidelines']
Usability," perturbation; Use PRINT options to indicate printing to output file. Use WRITE; options to indicate printing to another file. This probably isn’t; entirely valid now but should be observed in future. The complement to; WRITE is READ. PRINT, READ, and WRITE will usually; be the last words in an option name.; Use FOLLOW_ROOT for the state to be followed in geometry optimizations; WFN (not wavefunction); You’re welcome to use WFN and DERTYPE as internal options, but; plan to have these set by the python driver and mark them as !expert; options. Really avoid using JOBTYPE.; You’re not welcome to add CHARGE or MULTP options. Plan to get; these quantities from the molecule object. Since we frequently use subsets; of systems (with their own charge and multiplicity), this is safer.; Conform. Just grep 'add' psi4/src/read_options.cc to get a list of; all the option names in PSI4 and try to match any conventions you; find.; If you have a quantity you’d like to call a cutoff, a threshold, a; tolerance, or a convergence, consider the following guidelines in naming; it.; If its value is typically greater than ~0.001, give it a name with CUTOFF.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with larger values (e.g.,; integrals, occupations, eigenvectors), give it a name with TOLERANCE.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with smaller values (e.g., energy; changes, residual errors, gradients), give it a name with; CONVERGENCE. In deciding how to arrange words in an option name, place the context; first (e.g., MP2_AMPS_PRINT, TRIPLES_DIIS). This means PRINT; will generally be at the end of an option name.; Use INTS_TOLERANCE (not schwarz_cutoff); H in an option name is reserved for Hamiltonian (or hydrogen).; Hessian should be HESS.; All option names should be all caps and separated by underscores.; If you have an option that instructs your modul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/manage_addon-1.html:8474,guid,guidelines,8474,psi4manual/1.2.1/manage_addon-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/manage_addon-1.html,4,['guid'],['guidelines']
Usability," printing. Type:; list. Parameters:. name_hint (str) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; dashcoeff[dashlevel][functional-without-dashlevel] or; dashcoeff_supplement[dashlevel][functional-with-dashlevel]; can be overwritten via param_tweaks.; level_hint (str) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to one.; param_tweaks (Union[Dict, List]) – Values for the same keys as dashcoeff[dashlevel][‘default’]; (and same order if list) used to override any or all values; initialized by name_hint. Extra parameters will error.; engine (str) – Override which code computes dispersion. See above for allowed; values. Formerly (pre Nov 2022) only relevant for -D2, which can be computed by; libdisp or dftd3. Now (post Nov 2022) also relevant for -D3 variants,; which can be computed by dftd3 executable or simple-dftd3 Python module.; gcp_engine (str) – Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp (bool) – Whether to request atomic pairwise analysis. Methods Summary. compute_energy(molecule[, wfn]); Compute dispersion energy based on engine, dispersion level, and parameters in self. compute_gradient(molecule[, wfn]); Compute dispersion gradient based on engine, dispersion level, and parameters in self. compute_hessian(molecule[, wfn]); Compute dispersion Hessian based on engine, dispersion level, and parameters in self. print_out(); Format dispersion parameters of self for output file. Methods Documentation. compute_energy(molecule, wfn=None)[source]¶; Compute dispersion energy based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule) – System for which to compute empirical dispersion correction.; wfn (Wavefunction) – Location to set QCVariables.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html:3463,simpl,simple-,3463,psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html,1,['simpl'],['simple-']
Usability," printing. Type:; list. Parameters:. name_hint (str) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; dashcoeff[dashlevel][functional-without-dashlevel] or; dashcoeff_supplement[dashlevel][functional-with-dashlevel]; can be overwritten via param_tweaks.; level_hint (str) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to one.; param_tweaks (Union[Dict, List]) – Values for the same keys as dashcoeff[dashlevel][‘default’]; (and same order if list) used to override any or all values; initialized by name_hint. Extra parameters will error.; engine (str) – Override which code computes dispersion. See above for allowed; values. Formerly (pre Nov 2022) only relevant for -D2, which can be computed by; libdisp or dftd3. Now (post Nov 2022) also relevant for -D3 variants,; which can be computed by dftd3 executable or simple-dftd3 Python module.; gcp_engine (str) – Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp (bool) – Whether to request atomic pairwise analysis. table of contents. Interface to DFTD3 by S. Grimme; Empirical Dispersion Implementations; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections; run_dftd3(); run_dftd4(); EmpiricalDispersion; EmpiricalDispersion.dashlevel; EmpiricalDispersion.dashparams; EmpiricalDispersion.fctldash; EmpiricalDispersion.description; EmpiricalDispersion.dashlevel_citation; EmpiricalDispersion.dashparams_citation; EmpiricalDispersion.dashcoeff_supplement; EmpiricalDispersion.engine; EmpiricalDispersion.disp; EmpiricalDispersion.ordered_params. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to DFTD3 by S. Grimme. © Copyri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/dftd3.html:19583,simpl,simple-,19583,psi4manual/1.8.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/dftd3.html,1,['simpl'],['simple-']
Usability," psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet) → psi4.core.RHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(save_fock, max_diis_vectors)¶; docstring. Return type; float. Parameters. save_fock (bool) – ; max_diis_vectors (int) – . compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → Li",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.RHF.html:18038,simpl,simply,18038,psi4manual/1.6.x/api/psi4.core.RHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.RHF.html,1,['simpl'],['simply']
Usability," psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet) → psi4.core.UHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(save_fock, max_diis_vectors)¶; docstring. Return type; float. Parameters. save_fock (bool) – ; max_diis_vectors (int) – . compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → Li",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.UHF.html:18038,simpl,simply,18038,psi4manual/1.6.x/api/psi4.core.UHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.UHF.html,1,['simpl'],['simply']
Usability," psi4.core.ElectrostaticInt¶; Bases: psi4.core.OneBodyAOInt; docstring. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; docstring. origin¶; The origin about which the one body ints are being computed. class psi4.core.ErfComplementERI¶; Bases: psi4.core.TwoBodyAOInt; docstring. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; docstring. class psi4.core.ErfERI¶; Bases: psi4.core.TwoBodyAOInt; docstring. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; docstring. class psi4.core.ExternalPotential¶; Bases: object; docstring. addBasis(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet, arg1: psi4.core.Vector) → None¶; docstring. addCharge(self: psi4.core.ExternalPotential, arg0: float, arg1: float, arg2: float, arg3: float) → None¶; docstring. clear(self: psi4.core.ExternalPotential) → None¶; docstring. computePotentialMatrix(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet) → psi4.core.Matrix¶; docstring. print_out(self: psi4.core.ExternalPotential) → None¶; docstring. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; docstring. class psi4.core.F12¶; Bases: psi4.core.TwoBodyAOInt; docstring. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; docstring. class psi4.core.F12DoubleCommutator¶; Bases: psi4.core.TwoBodyAOInt; docstring. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; docstring. class psi4.core.F12G12¶; Bases: psi4.core.TwoBodyAOInt; docstring. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; docstring. class psi4.core.F12Squared¶; Bases: psi4.core.TwoBodyAOInt; docstring. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) →",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:41461,clear,clear,41461,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['clear'],['clear']
Usability," rational damping form of; Becke and Johnson was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now \(s_6\), \(s_8\),; \(a_1\), and \(a_2\). \[E_{disp}^{\text{D3BJ}}=-\sum_{n=6,8} s_n \sum_{i,j>i}^{N_{at}}; \frac{C_n^{ij}}{(R_{ij})^n + (f_{damp})^n}\]. \[f_{damp} = a_1 \sqrt{\frac{C_8^{ij}}{C_6^{ij}}} + a_2\]; All parameters characterizing the dispersion correction are taken from; Grimme’s website; or else from the literature.; With s-dftd3, parameters are also tabulated in the program source. Running DFTD3 or DFTD4¶; A number of a posteriori dispersion corrections are available in; PSI4. While some are computed within PSI4‘s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 or -D4 corrections and their variants are; available only through the DFTD3 or DFTD4 programs. Once installed, the; dftd3/PSI4 and dftd4/PSI4 interfaces are transparent, and all corrections are; interfaced exactly alike.; The -D3 interface can use classic or simple-dftd3 programs interchangeably and will prefer the latter.; Despite different defaults in these programs when run independently,; when run through PSI4 as EmpiricalDispersion engine, each should; produce the same result. Moreover, PSI4‘s own defaults and aliases; are unchanged by the new engines, so -D continues to mean -D2,; -D3 continues to mean zero-damping without 3-body correction,; and input files should continue producing the same results. Please file; an issue if found otherwise.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, a B3LYP-D3 (zero-damping), and a B3LYP-D4 (Becke-Johnson damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'); energy('b3lyp-d4'). Consult th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:6359,simpl,simple-,6359,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,2,['simpl'],['simple-']
Usability," rational damping form of; Becke and Johnson was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now \(s_6\), \(s_8\),; \(a_1\), and \(a_2\). \[E_{disp}^{\text{D3BJ}}=-\sum_{n=6,8} s_n \sum_{i,j>i}^{N_{at}}; \frac{C_n^{ij}}{(R_{ij})^n + (f_{damp})^n}\]. \[f_{damp} = a_1 \sqrt{\frac{C_8^{ij}}{C_6^{ij}}} + a_2\]; All parameters characterizing the dispersion correction are taken from; Grimme’s website; or else from the literature.; With s-dftd3, parameters are also tabulated in the program source. Running DFTD3 or DFTD4¶; A number of a posteriori dispersion corrections are available in; PSI4. While some are computed within PSI4‘s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 or -D4 corrections and their variants are; available only through the DFTD3 or DFTD4 programs. Once installed, the; dftd3/PSI4 and dftd4/PSI4 interfaces are transparent, and all corrections are; interfaced exactly alike.; The -D3 interface can use classic or simple-dftd3 programs interchangeably and will prefer the latter.; Starting in v1.9, the classic program is no longer supported or tested, though it isn’t deliberately disabled.; Despite different defaults in these programs when run independently,; when run through PSI4 as EmpiricalDispersion engine, each should; produce the same result. Moreover, PSI4‘s own defaults and aliases; are unchanged by the new engines, so -D continues to mean -D2,; -D3 continues to mean zero-damping without 3-body correction,; and input files should continue producing the same results. Please file; an issue if found otherwise.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, a B3LYP-D3 (zero-damping), and a B3LYP-D4 (Becke-Johnson damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; };",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/dftd3.html:6473,simpl,simple-,6473,psi4manual/1.9.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/dftd3.html,2,['simpl'],['simple-']
Usability," recommended for all CC calculations up to CCSD(T) and has been implemented for energy, gradient, second-derivative, and excitation energy calculations. Type: string; Possible Values: STANDARD, AOBASIS; Default: STANDARD. CFOUR_ACTIVE_ORBI (CFOUR); CFOUR — Specifies the active orbitals used in a TCSCF calculation and has to be used in combination with the keyword CFOUR_CORE_ORBITALS. The active orbitals are specified by either NIRREP or 2*NIRREP integers specifying the number of active orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. For more information and an example see CFOUR_OCCUPATION . Type: array; Default: No Default. CFOUR_ANH_ALGORITHM (CFOUR); CFOUR — Specifies which algorithm is used for CFOUR_ANHARMONIC =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations being done in series. If PARALLEL (=1), then the job stops after the second-derivative calculation at the reference geometry and generates out all input geometries for the remaining calculation. These can be then processed in “parallel” (currently not recommended). Note that it is recommended to carry out all calculations with PARALLEL, even when the actual calculation is carried out in a sequential mode. Type: string; Possible Values: STANDARD, PARALLEL; Default: STANDARD. CFOUR_ANH_DERIVATIVES (CFOUR); CFOUR — Specifies whether the anharmonic force field is calculated using analytic gradients (=FIRST) or analytic Hessians (=SECOND). Type: string; Possible Values: FIRST, SECOND; Default: SECOND. CFOUR_ANH_STEPSIZE (CFOUR); CFOUR — Controls the stepsize used in anharmonic force field calculations. The value is specified in reduced normal coordinates, which are dimensionless. The actual stepsize used in the calculation is \(\times ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:18464,simpl,simply,18464,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['simpl'],['simply']
Usability," recommended for all CC calculations up to CCSD(T) and has been implemented for energy, gradient, second-derivative, and excitation energy calculations. Type: string; Possible Values: STANDARD, AOBASIS; Default: STANDARD. CFOUR_ACTIVE_ORBI (CFOUR); CFOUR — Specifies the active orbitals used in a TCSCF calculation and has to be used in combination with the keyword CFOUR_CORE_ORBITALS. The active orbitals are specified by either NIRREP or 2*NIRREP integers specifying the number of active orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. For more information and an example see CFOUR_OCCUPATION . Type: array; Default: No Default. CFOUR_ANH_ALGORITHM (CFOUR); CFOUR — Specifies which algorithm is used for CFOUR_ANHARMONIC =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations being done in series. If PARALLEL (=1), then the job stops after the second-derivative calculation at the reference geometry and generates out all input geometries for the remaining calculation. These can be then processed in “parallel” (currently not recommended). Note that it is recommended to carry out all calculations with PARALLEL, even when the actual calculation is carried out in a sequential mode. Type: string; Possible Values: STANDARD, PARALLEL; Default: STANDARD. CFOUR_ANH_DERIVATIVES (CFOUR); CFOUR — Specifies whether the anharmonic force field is calculated using analytic gradients (=FIRST) or analytic Hessians (=SECOND). Type: string; Possible Values: FIRST, SECOND; Default: SECOND. CFOUR_ANH_STEPSIZE (CFOUR); CFOUR — Controls the stepsize used in anharmonic force field calculations. The value is specified in reduced normal coordinates, which are dimensionless. The actual stepsize used in the calculation is the integ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:18789,simpl,simply,18789,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['simpl'],['simply']
Usability," see the python file; frac_nuke(h2o, nmax = 2). Note: this feature is new/powerful enough that we have several papers pending on; it, and are interested in expanding this work. If you would like to publish; results using this code, please contact Rob Parrish to make arrangements for; collaboration. Dispersion Corrections¶; Dispersion corrections are discussed here.; HF-3c and PBEh-3c dispersion and BSSE corrections are discussed here. Recommendations¶; The KS-DFT code is quite new, but relatively complete. During code development,; emphasis was placed on flexibility of functional technology, efficiency for; medium to large systems in difficult electronic environments (e.g., compact; spatial extents, diffuse basis sets, low band-gaps, LRC and/or hybrid GKS; functionals), and time to code completion. We are very interested in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). table of contents. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dft-1.html:26224,guid,guidelines,26224,psi4manual/1.1.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dft-1.html,2,['guid'],['guidelines']
Usability," solved iteratively where each iteration costs the same; as a normal Fock build (). The overall SOSCF operation is; thus broken down into micro- and macroiterations where the microiterations; refer to solving the SOSCF equations and macroiterations are the construction; of a new Fock matrix based on the orbitals from a SOSCF step.; SOSCF requires that all elements of the gradient to be less than one before the; method is valid. To this end, pre-SOSCF SCF iterations use normal; gradient-based extrapolation procedures (e.g., DIIS) until the gradient; conditions are met. Note that while the total number of macroiterations will be; less for SOSCF than gradient-based convergence acceleration the cost of solving; the microiterations typically results in the overall cost being greater for; SOSCF than for gradient-based methods. Therefore, SOSCF should only be used if; it is difficult to locate a stable minimum.; SOSCF is only available for RHF, ROHF, and UHF reference. To turn on simply set; the option SOSCF to true. Additional options to modify the number of; microiterations taken are as follows:. SOSCF_R_START: when to start SOSCF based on the current density RMS; SOSCF_MAX_ITER: the maximum number of SOSCF microiterations per macroiteration; SOSCF_CONV: the relative convergence tolerance of the SOSCF microiterations; SOSCF_PRINT: option to print the microiterations or not. Stability Analysis¶; SCF algorithms attempt to minimize the gradient of the energy with respect; to orbital variation parameters. At convergence, the gradient should be approximately zero; given a convergence criterion. Although this is enough to make sure the SCF converged to a; stationary point, this is not a sufficient condition for a minimal SCF solution. It may be; a sadle point or a maximum.; To ensure that a minimum has been found, the electronic Hessian, i.e. the matrix of second; derivatives of the energy with respect to orbital variation parameters, must be computed.; If one or more eigenvalu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:22899,simpl,simply,22899,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['simpl'],['simply']
Usability," some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embeddi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html:4882,simpl,simple,4882,psi4manual/1.4.0/prog_ways_to_add-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html,9,['simpl'],['simple']
Usability," sphinx-psi-theme https://github.com/psi4/sphinx-psi-theme; See [“message” lines] for advice on obtaining docs dependencies or [conda env spec]; See psi4/.github/workflows/docs.yml for full docs building procedure to follow. Ambit — https://github.com/jturney/ambit; CheMPS2 — [what is CheMPS2?] [CheMPS2 min version]. HDF5 https://support.hdfgroup.org/HDF5/; zlib http://www.zlib.net/. ecpint — [what is ecpint?] [ecpint min version]; dkh — [what is dkh?] [dkh min version]. Fortran Compiler. gdma — [what is gdma?] [gdma min version]. Fortran Compiler. PCMSolver — [what is PCMSolver?]. Fortran Compiler; zlib http://www.zlib.net/. simint — [what is simint?] [simint min version]. Additionally, there are runtime-loaded capabilities:. PylibEFP & libefp — [what is LibEFP?] [LibEFP min version]; cfour — [what is CFOUR?]; dftd3 — [what is DFTD3?]; simple-dftd3 — [what is DFTD3?] (Nov 2022; added by v1.7) preferred alternative to dftd3 https://github.com/dftd3/simple-dftd3; gcp — [what is gCP?]; mctc-gcp — [what is gCP?] (Nov 2022; added by v1.7) preferred alternative to gcp https://github.com/grimme-lab/gcp; dftd4 — <sec:dftd3> https://github.com/dftd4/dftd4; mrcc — [what is MPCC?]; v2rdm_casscf — [what is v2rdm_casscf?]; sns-mp2 — https://github.com/DEShawResearch/sns-mp2/commits/master; resp — https://github.com/cdsgroup/resp; gpu_dfcc — https://github.com/edeprince3/gpu_dfcc/commits/master; OpenFermion-Psi4 — https://github.com/quantumlib/OpenFermion; cppe — https://github.com/maxscheurer/cppe; mp2d — https://github.com/Chandemonium/MP2D; FockCI — https://github.com/shannonhouck/psi4fockci; cct3 — https://github.com/piecuch-group/cct3; adcc — https://github.com/adc-connect/adcc; BrianQC — https://www.brianqc.com/; i-PI — http://ipi-code.org/; psixas — https://github.com/Masterluke87/psixas; MDI — https://github.com/MolSSI-MDI/MDI_Library; ddx — https://github.com/ddsolvation/ddx. How to use conda to get a Psi4 development environment¶; PSI4 has a lot of dependencies, some of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/build_planning.html:8792,simpl,simple-,8792,psi4manual/1.8.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/build_planning.html,3,['simpl'],['simple-']
Usability," start2 += d2. return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret_view = np.asarray(ret); ret_view[:] = arr; return ret. elif arr_type == psi4.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError (""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""); ; dim1 = psi4.Dimension.from_list(dim1) ; ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.array_interfaces()):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1 . return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret_view = np.asarray(ret); ret_view[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def to_array(matrix, copy=True, dense=False):; """"""; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view.; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. ret = []; for h in matrix.array_interfaces():; if 0 in h.__array_interface__[""shape""]:; ret.append(np.empty(shape = h.__array_interface__[""shape""])); else:; ret.append(np.array(h, copy=copy)). # Return the list of arrays; if dense is False:; return ret; ; # Build the dense matrix; if isinstance(matrix, psi4.Vector):; ret_type = '1D'; elif isinstance(matrix, psi4.Matrix):; ret_type = '2D'; else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % type(matrix)). dim1 = []; dim2 = []; for h in ret:; # Ignore zero dim irreps; if 0 in h.shape:; dim1.append(0); dim2.append(0); else:; dim1.append(h.shape[0]); if ret_type == '2D':; dim2.append(h.shape[1]). ndim1 = np.sum(dim1); ndim2 = np.sum(dim2); if ret_type == '1D':; dense_ret = np.zeros(shape=(ndim1)); start = 0; for d1, arr in zip(dim1, ret):; if d1 == 0: continue; dense_ret[start: start + d1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html:6187,simpl,simply,6187,psi4manual/1.0.0/_modules/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html,1,['simpl'],['simply']
Usability," the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. A PSI4 Tutorial; Psithon Tutorial: Using PSI4 as an Executable. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/tutorial-1.html:23094,clear,clear,23094,psi4manual/1.4.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/tutorial-1.html,2,['clear'],['clear']
Usability," the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. A PSI4 Tutorial; Psithon Tutorial: Using PSI4 as an Executable. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/tutorial-1.html:23094,clear,clear,23094,psi4manual/1.5.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/tutorial-1.html,2,['clear'],['clear']
Usability," the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; 1; 2; 3; 4; 5; 6; 7CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. A PSI4 Tutorial. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/tutorial-1.html:23279,clear,clear,23279,psi4manual/1.2.1/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/tutorial-1.html,2,['clear'],['clear']
Usability," the one-particle electronic density and B) there exists a set of; noninteracting quasiparticles with the same density as the true set of; electrons, with the quasiparticle states determined as eigenvectors of an; effective one-body potential encapsulating the true -body quantum; effects. The former idea allows the electronic density to be dealt with instead; of the much more complicated wavefunction, while the latter allows for the; treatment of the troublesome kinetic energy term via the implicit one-body; Kohn-Sham orbitals. KS-DFT borrows much of the machinery of Hartree-Fock, as is; evident by looking at the energy expression,. Here is the noninteracting quasiparticle kinetic energy operator,; is the nucleus-electron attraction potential, ; is the total electron density matrix, and is the (potentially nonlocal) exchange, correlation, and residual; kinetic energy functional. The residual kinetic energy term is usually quite; small, and is often ignored, hence is often referred to; as simply the exchange-correlation functional (exchange and correlation, not; just exchange-type correlation).; In practice, the first few generations of KS-DFT functionals were chosen to be; local, meaning that the form of the exchange correlation energy is an integral; over all of space of a function depending only on local information in the; density, such as the density value or derivatives. The simplest variants are; Local Spin-Density Approximations (LSDA), which depend only on the spin density; or ,. The most popular variants are Generalized Gradient Approximation (GGA); functionals which use the norm of the density gradient; , or; to build an inhomogeneity; parameter. where,. GGA functionals are essentially the same cost as LSDA functionals, and are often; considerably more accurate.; Another local variant which has gained some popularity (though perhaps not as; much as GGA functionals) is the meta approximation, in which information about; the second derivative of the density i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:1882,simpl,simply,1882,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,10,['simpl'],['simply']
Usability," the problem of Many-Electron Self-Interaction; Error (MSIE), which presents as spurious low-lying charge transfer states in; excited-state calculations, eventual metallic breakdown in extended insulators,; poor thermochemistry, and complete lack of a derivative discontinuity in the; chemical potential as integer particle numbers are crossed. On the correlation; side, this is primarily observed in the inability of KS-DFT to treat dispersion; interactions.; Generalized Kohn-Sham (GKS) functionals incorporate long-range information into; the functional through orbital-dependent contributions, and are designed to; combat the failures of local KS-DFT, particularly the MSIE on the exchange side.; Note that these functionals are often referred to as “implicit” density; functionals, as the orbitals are themselves functionals of the Kohn-Sham; potential.; The simplest form of an exchange-side GKS is the global hybrid ansatz, in which; some fraction of the exact Hartree-Fock exchange of the noninteracting; quasiparticles is added to the functional, with the local part of the exchange; functional decreased by the corresponding amount. Note that the term; “exact-exchange” refers to the Hartree-Fock being the exact exchange energy of; the noninteracting quasiparticles, not the true electrons. Therefore, adding; 100% exact exchange is not physically reasonable, and will often lead to; extremely poor results. The fraction of exact-exchange, denoted ,; is often determined by adiabatic or heuristic arguments, and is typically around; 25%. The addition of exact exchange borrows another piece from an existing; Hartree-Fock code, with the caveat that Hartree-Fock exchange is often much more; costly to obtain than the Coulomb matrix. The global hybrid ansatz has become; exceedingly popular, with functionals such as the ubiquitous B3LYP often; producing absurdly accurate results.; A more advanced GKS functional technology which has developed enormous; popularity in recent years is the L",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:5181,simpl,simplest,5181,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,10,['simpl'],['simplest']
Usability," the problem of Many-Electron Self-Interaction; Error (MSIE), which presents as spurious low-lying charge transfer states in; excited-state calculations, eventual metallic breakdown in extended insulators,; poor thermochemistry, and complete lack of a derivative discontinuity in the; chemical potential as integer particle numbers are crossed. On the correlation; side, this is primarily observed in the inability of KS-DFT to treat dispersion; interactions.; Generalized Kohn–Sham (GKS) functionals incorporate long-range information into; the functional through orbital-dependent contributions, and are designed to; combat the failures of local KS-DFT, particularly the MSIE on the exchange side.; Note that these functionals are often referred to as “implicit” density; functionals, as the orbitals are themselves functionals of the Kohn–Sham; potential.; The simplest form of an exchange-side GKS is the global hybrid ansatz, in which; some fraction of the exact Hartree–Fock exchange of the noninteracting; quasiparticles is added to the functional, with the local part of the exchange; functional decreased by the corresponding amount. Note that the term; “exact-exchange” refers to the Hartree–Fock being the exact exchange energy of; the noninteracting quasiparticles, not the true electrons. Therefore, adding; 100% exact exchange is not physically reasonable, and will often lead to; extremely poor results. The fraction of exact-exchange, denoted \(\alpha\),; is often determined by adiabatic or heuristic arguments and is typically around; 25%. The addition of exact exchange borrows another piece from an existing; Hartree–Fock code, with the caveat that Hartree–Fock exchange is often much more; costly to obtain than the Coulomb matrix. The global hybrid ansatz has become; exceedingly popular, with functionals such as the ubiquitous B3LYP often; producing absurdly accurate results.; A more advanced GKS functional technology which has developed enormous; popularity in recent years",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:7683,simpl,simplest,7683,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,15,['simpl'],['simplest']
Usability," the; command basis {...}, as shown below. Multiple basis sets can be; specified by adding additional sections within the surrounding brackets.; Use assign statements to actually request the basis set. This; basis {...} section replaces the usual set basis XXX line.; In a more complex input, if the user needs to call the user-defined; basis by name, this can be achieved using the syntax basis mybas {...},; and then the basis can be recalled later as set basis mybas.; To use a custom basis set as described in this section, it must be; defined prior to its use in a function that performs a computation.; basis {. # assign basset to all atoms and addl to hydrogens; assign basset; assign H addl. # basis set section like in snippet above goes here; [basset]; ... # additional basis set sections follow; [addl]; ...; }. The test case mints2 provides a complete example of; user-specified basis sets. Inputting effective core potentials (ECPs)¶; For ECP containing basis sets, all of the above mechanisms may still be used to; input the basis set; simply place the ECP definitions (in G94 format) in the; same file or input section as the orbital basis definition. Because the ECP; appears in the same section as the orbital basis, it will be parsed; automatically and the number of core electrons the ECP represents will be; detected, so no further input is required to use a core potential. See; Effective core potentials (ECPs) for more information about using ECPs and the; Def2-TZVP basis set definition; for an example of their input syntax. table of contents. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Psithon: Structuring an Input File; Basis Sets. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/basissets.html:10338,simpl,simply,10338,psi4manual/master/basissets.html,https://psicode.org,https://psicode.org/psi4manual/master/basissets.html,1,['simpl'],['simply']
Usability," where k is determined by MAX_NUM_VECS ? For open-shell systems REFERENCE is ROHF, WFN is ZAPTN), DETCI will compute the ZAPTn series. GUESS_VECTOR must be set to UNIT, HD_OTF must be set to TRUE, and HD_AVG must be set to orb_ener; these should happen by default for MPN = TRUE. Type: boolean; Default: false. For larger computations, additional keywords may be required, as; described in the DETCI section of the Appendix DETCI. Arbitrary Order Perturbation Theory¶; The DETCI module is capable of computing energies for arbitrary; order Møller–Plesset perturbation theory (MPn, for closed-shell; systems with an RHF reference) and for Z-averaged perturbation theory; (ZAPTn, open-shell systems with an ROHF reference). However, please; note that these computations are essentially doing high-order CI (up to; full CI) computations to obtain these results, and hence they will only; be possible for very small systems (generally a dozen electrons or less).; The simplest way to run high-order perturbation theory computations is to; call, e.g., energy('mp10') to invoke a MP10 computation or; energy('zapt25') to invoke a ZAPT25 computation. This will; automatically set several additional user options to their appropriate; values. The program uses the Wigner (2n+1) rule to obtain higher-order; energies from lower-order wavefunctions.; For the interested reader, the additional user options that are; automatically set up by the calls above are as follows. A call like; energy('mp10') sets MPN to TRUE.; The program uses the Wigner (2n+1) rule by default; (MPN_WIGNER = TRUE); and figures out what order of wavefunction is; necessary to reach the desired order in the energy. The program then; sets MAX_NUM_VECS to the required order in the; wavefunction.; By default, the requested n-th order energy is saved as the current; energy to the process environment. ZAPTN works essentially the same; way for an ROHF reference. Arbitrary Order Coupled-Cluster Theory¶; This DETCI-based version of this ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/detci-1.html:9368,simpl,simplest,9368,psi4manual/1.0.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/detci-1.html,10,['simpl'],['simplest']
Usability," {mc_level_idx=} {packet=} {cbsmeta=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; computer=CompositeComputer,; **cbsmeta,; **current_findif_kwargs,; **kwargs). else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1); if dermode[0] == dermode[1]: # analytic; logger.info(f""PLANNING MB: {mc_level_idx=} {packet=}""); plan.build_tasks(AtomicComputer, **packet, mc_level_idx=mc_level_idx, **kwargs); else:; logger.info(; f""PLANNING MB(FD): {mc_level_idx=} {packet=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; **current_findif_kwargs,; **kwargs). return plan. # Check for CBS; elif method == ""cbs"":; kwargs.update(cbsmeta); # This CompositeComputer is discarded after being used for dermode. Could have used directly for analytic except for excess printing with FD; simplekwargs = copy.deepcopy(kwargs); simplekwargs['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info('PLANNING CBS: packet={packet} kw={kwargs}'); plan = CompositeComputer(**packet, **kwargs); return plan; else:; # For FD(CBS(Atomic)), the CompositeComputer above is discarded after being used for dermode.; logger.info(; f'PLANNING FD(CBS): dermode={dermode} packet={packet} findif_kw={current_findif_kwargs} kw={kwargs}'); plan = FiniteDifferenceComputer(**packet,; findif_mode=dermode,; computer=CompositeComputer,; **current_findif_kwargs,; **kwargs); return plan. # Done with Wrappers -- know we want E, G, or H -- but may still be FD or AtomicComputer",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_planner.html:9261,simpl,simplekwargs,9261,psi4manual/1.7.x/_modules/psi4/driver/task_planner.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_planner.html,4,['simpl'],['simplekwargs']
Usability," | ; | py_buffer; | docstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None :; | ; | C++ signature :; | void __init__(P7_object,N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | C++ signature :; | void add(N3psi6OEPropE {lvalue},Ss); | ; | clear(...); | clear( (OEProp)arg1) -> None :; | docstring; | ; | C++ signature :; | void clear(N3psi6OEPropE {lvalue}); | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | C++ signature :; | void compute(N3psi6OEPropE {lvalue}); | ; | set_Da_ao(...); | set_Da_ao( (OEProp)arg1, (Matrix)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void set_Da_ao(N3psi6OEPropE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE,i); | ; | set_Da_mo(...); | set_Da_mo( (OEProp)arg1, (Matrix)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_Da_mo(N3psi6OEPropE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE); | ; | set_Da_so(...); | set_Da_so( (OEProp)arg1, (Matrix)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_Da_so(N3psi6OEPropE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE); | ; | set_Db_ao(...); | set_Db_ao( (OEProp)arg1, (Matrix)arg2, (int)arg3) -> None :; | docstring; | ; | C++ sig",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:566479,clear,clear,566479,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['clear'],['clear']
Usability," – If a single dense NumPy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 (Optional[Dimension]) – Same as dim1 only if using a Dimension object. Returns:; Returns the given (self) Psi4 object. Return type:; Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; >>> data = np.random.rand(20,1); >>> vector = psi4.core.Matrix.from_array(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4). Matrix to Array¶; A general function that converts NumPy arrays to PSI4 data objects. psi4.driver.p4util.numpy_helper._to_array(matrix, copy=True, dense=False)[source]¶; Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. table of contents. Interface to NumPy; Basics; NumPy Views; PSI4 Data Objects with Irreps; Array to Matrix; Matrix to Array. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/numpy.html:4229,simpl,simply,4229,psi4manual/1.7.x/numpy.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/numpy.html,1,['simpl'],['simply']
Usability," – If a single dense NumPy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 (Optional[Dimension]) – Same as dim1 only if using a Dimension object. Returns:; Returns the given (self) Psi4 object. Return type:; Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; >>> data = np.random.rand(20,1); >>> vector = psi4.core.Matrix.from_array(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4). Matrix to Array¶; A general function that converts NumPy arrays to PSI4 data objects. psi4.driver.p4util.numpy_helper._to_array(matrix, copy=True, dense=False)[source]¶; Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. table of contents. Interface to NumPy; Basics; NumPy Views; PSI4 Data Objects with Irreps; Array to Matrix; array_to_matrix(). Matrix to Array; _to_array(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy. © Copyright 2007-2024, The Psi4 Proje",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/numpy.html:4238,simpl,simply,4238,psi4manual/master/numpy.html,https://psicode.org,https://psicode.org/psi4manual/master/numpy.html,1,['simpl'],['simply']
Usability," – If a single dense NumPy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 (Optional[Dimension]) – Same as dim1 only if using a Dimension object. Returns:; Returns the given (self) Psi4 object. Return type:; Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; >>> data = np.random.rand(20,1); >>> vector = psi4.core.Matrix.from_array(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4). Matrix to Array¶; A general function that converts NumPy arrays to PSI4 data objects. psi4.driver.p4util.numpy_helper._to_array(matrix, copy=True, dense=False)[source]¶; Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. table of contents. Interface to NumPy; Basics; NumPy Views; PSI4 Data Objects with Irreps; Array to Matrix; array_to_matrix(). Matrix to Array; _to_array(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy. © Copyright 2007-2023, The Psi4 Project.; La",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/numpy.html:4231,simpl,simply,4231,psi4manual/1.8.x/numpy.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/numpy.html,1,['simpl'],['simply']
Usability," – If a single dense NumPy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 (Optional[Dimension]) – Same as dim1 only if using a Dimension object. Returns:; Returns the given (self) Psi4 object. Return type:; Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; >>> data = np.random.rand(20,1); >>> vector = psi4.core.Matrix.from_array(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4). Matrix to Array¶; A general function that converts NumPy arrays to PSI4 data objects. psi4.driver.p4util.numpy_helper._to_array(matrix, copy=True, dense=False)[source]¶; Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. table of contents. Interface to NumPy; Basics; NumPy Views; PSI4 Data Objects with Irreps; Array to Matrix; array_to_matrix(). Matrix to Array; _to_array(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy. © Copyright 2007-2024, The Psi4 Project.; La",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/numpy.html:4231,simpl,simply,4231,psi4manual/1.9.x/numpy.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/numpy.html,1,['simpl'],['simply']
Usability," ✓̲. ✓̳. ✓̲. ✓̳. ✓̲. ✓̲. ✓̳. b3lyp, Hybrid DFT; SCF_TYPE; ✓̲. ✓̳. ✓̲. ✓̲. ✓̳. ✓̲. ✓̳. ✓̲. ✓̲. ✓̳. wb97x, LRC DFT; SCF_TYPE; ✓̲. ✓̳. ✓̲. ✓̳. ✓̲. ✓̳. ✓̲. ✓̳. b2plyp, DH DFT[5]; SCF_TYPE; ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲. ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲. [1]; Algorithm type selection keyword below. Values to the right: conventional CV, density-fitted DF, and Cholesky-decomposed CD. [2]; Active orbital values to the right: all-electron A and frozen-core F. [3]; (1,2,3); Finite difference gradients are not marked explicitly by “∷”, but the capability can be gleaned from the energy availability. [4]; (1,2,3); Finite difference Hessians are not marked explicitly by “∷”, but the capability can be gleaned from the gradient or energy availability. [5]; DH-DFT only available with DF-MP2. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; memory 512 MB. molecule h2o {; 0 1 # must be neutral; O; H 1 1.0; H 1 1.0 2 104.5; # IP fitting runs in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; }. # Optional arguments are minimum omega, maximum omega, molecule object; omega = ip_fitting('wb97', 0.4, 2.0, molecule=h2o). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dft.html:26567,simpl,simply,26567,psi4manual/1.7.x/dft.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dft.html,4,['simpl'],['simply']
Usability,""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activate(user_molecule); user_molecule.update_geometry(); psi4.set_global_option(""BASIS"", user_basis); psi4.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; psi4.revoke_global_option_changed('REFERENCE'); psi4.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt')",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:51515,clear,clear,51515,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['clear'],['clear']
Usability,"""""""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). PsiMod.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); PsiMod.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); PsiMod.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; PsiMod.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activate(user_molecule); user_molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", user_basis); PsiMod.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; PsiMod.revoke_global_option_changed('REFERENCE'); PsiMod.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy . [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:50869,clear,clear,50869,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,1,['clear'],['clear']
Usability,"""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:9954,clear,cleared,9954,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['clear'],['cleared']
Usability,"""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); psi4.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if name == 'bccd(t)':; psi4.cctriples(ref_wfn). optstash.restore(); return ref_wfn. [docs]def run_dft_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DFT calculations. This is a simple alias to :py:func:`~proc.run_scf`; since DFT properties all handled through oeprop. """"""; optstash = proc_util.dft_set_reference_local(name). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). scf_wfn = run_scf(name, scf_do_dipole=False, *kwargs). # Run OEProp; oe = psi4.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(). optstash.restore(); return scf_wfn. [docs]def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). scf_wfn = run_scf(name, scf_do_dipole=False, **kwargs). # Run OEProp; oe = psi4.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(). optstash.restore(); return scf_wfn. [docs]def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; optstash = p4util.OptionsState(; ['WFN'],; ['DERTYPE'],; ['ONEPDM'],; ['PROPERTY'],; ['CCLAMBDA', 'R_CONVERGENCE'],; ['CCEOM', 'R_CONVERGENCE'],; ['CCEOM', 'E_CONVERGENCE']). oneel_properties = ['dipole', 'quadrupole']; twoel_properties = []; response_properties = ['polarizability', 'rotation', 'roa', 'roa_tensor']; excited_properties = ['oscillator_strength', 'rotational_strength']. one = []; two = []; response = []; excite",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:58452,simpl,simple,58452,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['simpl'],['simple']
Usability,"#; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; import re; import os; import math; import warnings; import psi4; import p4util; from driver import *; from wrappers import *; #from extend_Molecule import *; from molutil import *. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end of this file. [docs]def sherrill_gold_standard(name='mp2', **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~wrappers.complete_basis_set` to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~wrappers.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html:1163,simpl,simple,1163,psi4manual/4.0b5/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html,1,['simpl'],['simple']
Usability,"% (db_name), MSDerror); PsiMod.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); PsiMod.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; PsiMod.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activate(user_molecule); user_molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", user_basis); PsiMod.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; PsiMod.revoke_global_option_changed('REFERENCE'). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy . [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:51026,simpl,simple,51026,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,1,['simpl'],['simple']
Usability,"% (table_delimit). PsiMod.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); PsiMod.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); PsiMod.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; PsiMod.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activate(user_molecule); user_molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", user_basis); PsiMod.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; PsiMod.revoke_global_option_changed('REFERENCE'). return finalenergy. [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:50120,simpl,simple,50120,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['simpl'],['simple']
Usability,"%10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. # Quickly normalize the types for both python 2 and 3; try:; unicode = unicode; except NameError:; # 'unicode' is undefined, must be Python 3; str = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:28826,simpl,simple,28826,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,2,['simpl'],['simple']
Usability,"%10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.wrapper_database. © Cop",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/wrapper_database.html:21862,simpl,simple,21862,psi4manual/master/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/wrapper_database.html,1,['simpl'],['simple']
Usability,"%10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.3.2;  · . PSI4. Module code. © Copyright 2019, The Psi4 Project.; Last ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:28759,simpl,simple,28759,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,1,['simpl'],['simple']
Usability,"%10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.wrapper_database. © Copyright 20",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:21934,simpl,simple,21934,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,1,['simpl'],['simple']
Usability,"%10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.5;  · . PSI4. Module code; psi4.driver.wrapper_database. © Copyright 20",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/wrapper_database.html:21934,simpl,simple,21934,psi4manual/1.5.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/wrapper_database.html,1,['simpl'],['simple']
Usability,"%10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.6;  · . PSI4. Module code; psi4.driver.wrapper_database. © Copyright 20",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/wrapper_database.html:21934,simpl,simple,21934,psi4manual/1.6.x/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/wrapper_database.html,1,['simpl'],['simple']
Usability,"%10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.wrapper_database. © Copyright 20",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/wrapper_database.html:21873,simpl,simple,21873,psi4manual/1.7.x/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/wrapper_database.html,1,['simpl'],['simple']
Usability,"%10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.8.2;  · . PSI4. Module code; psi4.driver.wrapper_database. © Copyright ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:21877,simpl,simple,21877,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,1,['simpl'],['simple']
Usability,"%10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.9.1;  · . PSI4. Module code; psi4.driver.wrapper_database. © Copyright ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/wrapper_database.html:21855,simpl,simple,21855,psi4manual/1.9.x/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/wrapper_database.html,1,['simpl'],['simple']
Usability,"(function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). 1; 2>>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). 1; 2; 3>>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). 1; 2>>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:10727,simpl,simple,10727,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,7,['simpl'],['simple']
Usability,"(msg)); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning. For; cases where the syntax just has to jump, this can be used to trap; the old syntax at first error and suggest the new. """""". def __init__(self, old, new, version, elaboration):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description : str; Type of QC routine that has failed (e.g., SCF); iteration : int; What iteration we failed on. """""". def __init__(self, eqn_description, iteration, additional_info=None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:2592,simpl,simple,2592,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,3,['simpl'],['simple']
Usability,"(nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]¶; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]¶; Serializes instance into dictionary according to schema dtype. to_string(dtype, units=None, atom_format=None, ghost_format=None, width=17, prec=12)[source]¶; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int) → int¶; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule) → str¶; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int) → float¶; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int) → psi4.core.Vector3¶; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int) → float¶; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int) → float¶; z position [Bohr] of atom arg0 (0-indexed without dummies). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; Molecule. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Molecule.html:38811,clear,clearing,38811,psi4manual/1.6.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Molecule.html,1,['clear'],['clearing']
Usability,") -> ModuleType:; """"""Import loader for *module* in any possible lettercase permutation. Parameters; ----------; module; Name of module with uncertain case. Returns; -------; types.ModuleType; Module object. """"""; modobj = None; for permutation in list(all_casings(module)):; try:; modobj = __import__(permutation); except ImportError:; pass; else:; break. return modobj. _modules = [; # Psi4 Modules; ""CCENERGY"",; ""CCEOM"",; ""CCDENSITY"",; ""CCLAMBDA"",; ""CCHBAR"",; ""CCRESPONSE"",; ""CCTRANSORT"",; ""CCTRIPLES"",; ""CPHF"",; ""DCT"",; ""DETCI"",; ""DFEP2"",; ""DFMP2"",; ""DFOCC"",; ""DLPNO"",; ""DMRG"",; ""EFP"",; ""FINDIF"",; ""FISAPT"",; ""FNOCC"",; ""GDMA"",; ""MCSCF"",; ""MINTS"",; ""MRCC"",; ""OCC"",; ""OPTKING"",; ""PCM"",; ""PE"",; ""PSIMRCC"",; ""RESPONSE"",; ""SAPT"",; ""SCF"",; ""THERMO"",; # External Modules; ""CFOUR"",; ]. [docs]@contextmanager; def hold_options_state() -> Iterator[None]:; """"""Return a context manager that will collect the current state of; ``Process:environment.options`` on entry to the with-statement and clear; and restore the collected keywords state when exiting the with-statement. """"""; pofm = prepare_options_for_modules(; changedOnly=True, commandsInsteadDict=False, globalsOnly=False, stateInsteadMediated=True; ); yield; _reset_pe_options(pofm). def _reset_pe_options(pofm: Dict):; """"""Acts on ``Process::environment.options`` to clear it, then set it to; state encoded in `pofm`. Parameters; ----------; pofm; Result of :py:func:`prepare_options_for_modules` with; ``changedOnly=True``, ``commandsInsteadDict=False``, and; ``stateInsteadMediated=True``. """"""; core.clean_options(). for go, dgo in pofm['GLOBALS'].items():; if dgo['has_changed']:; core.set_global_option(go, dgo['value']). for module in _modules:; for lo, dlo in pofm[module].items():; if dlo['has_changed']:; core.set_local_option(module, lo, dlo['value']). ## this is a more defensive version if defaults may have changed; # for go, dgo in pofm['GLOBALS'].items():; # core.set_global_option(go, dgo['value']); # if not dgo['has_changed']:; # core.r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html:9743,clear,clear,9743,psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,1,['clear'],['clear']
Usability,") for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet) → psi4.core.CUHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:38563,simpl,simply,38563,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['simpl'],['simply']
Usability,") for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet) → psi4.core.ROHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:215460,simpl,simply,215460,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['simpl'],['simply']
Usability,")'¶. field cbsrec: List[Dict[str, Any]] = []¶. field compute_list: List[Dict[str, Any]] = []¶. field driver: DriverEnum [Required]¶. field keywords: Dict[str, Any] = {}¶. field metadata: Any = None¶. field metameta: Dict[str, Any] = {}¶. field method: str = '(auto)'¶. field molecule: Any = None¶. Validated by:. set_molecule. field results_list: List[Any] = []¶. field task_list: List[AtomicComputer] = []¶. field trove: List[Dict[str, Any]] = []¶. field verbose: int = 1¶. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶. Parameters:; client (qcportal.FractalClient | None). get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. molecule; dummy basis, def2-svp; e/g/h member data; QCVariables; module if simple. client (qcportal.FractalClient | None). Returns:. ret – Energy, gradient, or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. Return type:; float | Matrix | Tuple[float | Matrix, Wavefunction]. get_results(client=None)[source]¶; Return results as Composite-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None). Return type:; AtomicResult. plan()[source]¶. validator set_molecule  »  molecule[source]¶. table of contents. Complete Basis Set; Output; Extrapolation Schemes; xtpl_highest_1(); scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(); scf_xtpl_helgaker_3(); corl_xtpl_helgaker_2(); _get_default_xtpl(); register_xtpl_function(). Aliases; sherrill_gold_standard(); allen_focal_point(); register_composite_function(). API; CompositeComputer; CompositeComputer.basis; CompositeComputer.cbsrec; CompositeComputer.compute_list; CompositeComputer.driver; CompositeComputer.keyw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cbs.html:40236,simpl,simple,40236,psi4manual/master/cbs.html,https://psicode.org,https://psicode.org/psi4manual/master/cbs.html,1,['simpl'],['simple']
Usability,")}\) are not very similar to; each other. Hence, in 2016 universal scaling of all \(S^{2}\) approximated terms; was turned off by default.; Finally, in 2014 Parker et al. [Parker:2014:094106] empirically discovered that; SAPT0 energies for van der Waals dimers with close contacts benefit from a slightly modified; recipe that involves an empirically adjusted exponent \(\alpha = 3.0\).; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]). (9)¶\[E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)}; + \delta_{HF}^{(2)}\]; where \(\delta_{HF}^{(2)}\) is computed without any scaling. Please note that; sSAPT0 is thus not the same as requesting exch_scale_alpha 3.0, and that the; scaling is automatically performed by requesting energy('ssapt0'). A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods,; not all of them).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis aug-cc-pvdz. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and open-shell monomers.; Higher-order SAPT and SAPT(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/sapt.html:11949,simpl,simplest,11949,psi4manual/1.9.x/sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/sapt.html,2,['simpl'],['simplest']
Usability,"+, SAPT2+(3), and SAPT2+3 energies for closed-shell systems; only. Publications resulting from the use of the higher-order SAPT code; should cite the following:; [Hohenstein:2010:014101].; For methods SAPT2+ and above, one can replace the many-body treatment of; dispersion by an improved method based on coupled-cluster doubles (CCD).; This approach tends to give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]).; As shown in [Parker:2014:094106], whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102], the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102].; To request CCD dispersion treatment in a SAPT computation, simply append; (ccd) to the name of the method, as in the following examples; energy('sapt2+(ccd)'); energy('sapt2+(3)(ccd)'); energy('sapt2+3(ccd)'). The \(\delta_{MP2}\) corrections can also be computed automatically; by appending dmp2 to the name of the method, with or without CCD dispersion; energy('sapt2+dmp2'); energy('sapt2+(3)dmp2'); energy('sapt2+3dmp2'); energy('sapt2+(ccd)dmp2'); energy('sapt2+(3)(ccd)dmp2'); energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold \(3o^2v^2+v^2N_{aux}\) arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:25293,simpl,simply,25293,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['simpl'],['simply']
Usability,"+= """"""%23s %19s %8.4f\n"""""" % ('Minimal Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). PsiMod.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); PsiMod.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); PsiMod.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; PsiMod.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activate(user_molecule); user_molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", user_basis); PsiMod.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; PsiMod.revoke_global_option_changed('REFERENCE'). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy . [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:50568,clear,clear,50568,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,1,['clear'],['clear']
Usability,", is below.; # Install GCC 5.2 into a non-primary conda environment; >>> conda create -n gcc52 -c psi4 gcc-5-mp. # To Build, either:. # (A) activate environment (prepends PATH); >>> source activate gcc52. # (B) tell CMake to tell the compiler which GCC to use; >>> vi do-configure; GCC5=/path/to/miniconda/envs/gcc52; cmake -H. -Bbuild \; -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gcc-name=${GCC5}/bin/gcc"" \; -DCMAKE_CXX_FLAGS=""-gcc-name=${GCC5}/bin/gcc -gxx-name=${GCC5}/bin/g++"" \; ...; # if Fortran active ...; -DCMAKE_Fortran_COMPILER=icpc \; -DCMAKE_Fortran_FLAGS=""-gcc-name=${GCC5}/bin/gcc -gxx-name=${GCC5}/bin/g++"" \. # Configure and build. # To Run:; >>> export LD_LIBRARY_PATH=${GCC5}/lib:$LD_LIBRARY_PATH. How to configure a Psi4 build on Cray¶; Cray systems strongly prefer to build static libraries, but PSI4; needs to be dynamic to function as a Python module. Courtesy of @misha; at the forum and various supercomputer guides, building PSI4 on; Cray requires setting environment variables CRAYPE_LINK_TYPE; and CRAY_ADD_RPATH before running cmake.; 1CRAYPE_LINK_TYPE=dynamic CRAY_ADD_RPATH=yes cmake ... How to configure Fortran compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a Fortran compiler in unneeded for core; features but may be required for add-ons.; Downstream Dependencies; PSI4 (\(\Leftarrow\) optional) Fortran Compiler; erd, dkh, gdma, PCMSolver \(\Leftarrow\) Fortran Compiler. CMake Variables. CMAKE_Fortran_COMPILER — CMake variable to specify name or full path to Fortran compiler.; CMAKE_Fortran_FLAGS — CMake variable to specify any additional custom compiler flags for Fortran source. Examples. Build with detected compiler from PATH. >>> cmake. Build with specific (Intel) compiler from PATH. >>> cmake -DCMAKE_Fortran_COMPILER=ifort. What Fortran compilers are approved¶; On Linux and Mac, the following work nicely. GNU: gfortran; Intel: ifort. Packages to install for specific OS or package managers:; Ubun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:28694,guid,guides,28694,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['guid'],['guides']
Usability,", ix)). fig, ax1 = plt.subplots(figsize=(16, 6)); plt.axvline(0.0, color='#cccc00'); ax1.set_xlim(xmin, xmax); ax1.hist(data, bins=30, range=(xmin, xmax), color='#2d4065', alpha=0.7); ax1.set_xlabel(xtitle); ax1.set_ylabel('Count'). ax2 = ax1.twinx(); ax2.fill(pdfx, pdfy, color='k', alpha=0.2); ax2.set_ylabel('Probability Density'). plt.title(title). # save and show; pltuid = title + '_' + hashlib.sha1(title + str(me) + str(stde) + str(xmin) + str(xmax)).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='disthist_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close(); return files_saved. #def thread(data, labels, color=None, title='', xlimit=4.0, mae=None, mape=None):; # """"""Generates a tiered slat diagram between model chemistries with; # errors (or simply values) in list *data*, which is supplied as part of the; # dictionary for each participating reaction, along with *dbse* and *rxn* keys; # in argument *data*. The plot is labeled with *title* and each tier with; # an element of *labels* and plotted at *xlimit* from the zero-line. If; # *color* is None, slats are black, if 'sapt', colors are taken from *color*; # key in *data* [0, 1]. Summary statistics *mae* are plotted on the; # overbound side and relative statistics *mape* on the underbound side.; #; # """"""; # from random import random; # import matplotlib.pyplot as plt; #; # # initialize tiers/wefts; # Nweft = len(labels); # lenS = 0.2; # gapT = 0.04; # positions = range(-1, -1 * Nweft - 1, -1); # posnS = []; # for weft in range(Nweft):; # posnS.extend([positions[weft] + lenS, positions[weft] - lenS, None]); # posnT = []; # for weft in range(Nweft - 1):; # posnT.extend([positions[weft] - lenS - gapT, positions[weft + 1] + lenS + gapT, None]); #; # # initialize plot; # fht = Nweft * 0.8; # fig, ax = plt.s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:13298,simpl,simply,13298,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['simpl'],['simply']
Usability,", their coupling is assumed to be high spin, i.e.; two doublets would interact to form a triplet. The S2 approximation and scaling¶; All exchange terms in SAPT arise from the antisymmetrization; of the wavefunctions of monomers A and B. Taking into account exchange of all possible; electron pairs between the two monomers yields to complicated formulae.; For this reason, exchange terms are often evaluated in the \(S^{2}\); approximation, that can be interpreted as the exchange of a single electron; pair between monomers.; The \(S^{2}\) approximation is usually pretty good, but may; break down for short intermolecular distance, particularly in high-order; terms. To compensate these deviations, Parker et al. [Parker:2014:094106]; recommend to scale all \(S^{2}\) approximated exchange terms by the ratio:. \[p_{EX}(\alpha) = \left( \frac{E_{exch}^{(10)}}{E_{exch}^{(10)}(S^{2})} \right)^{\alpha}\]; where the recommended exponent is \(\alpha = 1\). To obtain SAPT energies with this scaling,; simply set the keyword exch_scale_alpha true. Alternatively, another value for \(\alpha\); can be specified by setting EXCH_SCALE_ALPHA to a value. For example,; 1set exch_scale_alpha 1.0. will set \(\alpha = 1.0\) and scale exchange energies with \(p_{EX}(1.0)\).; Instead of this straightforward scaling, SAPT0 energies benefit from a slightly modified; recipe that involves an empirically adjusted exponent \(\alpha = 3.0\).; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]). (8)¶\[E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)}; + \delta_{HF}^{(2)}\]; where \(\delta_{HF}^{(2)}\) is computed without any scaling. Please note that; sSAPT0 is thus not the same as requesting exch_scale_alpha 3.0, and that the; scaling is automatically performed by requesting energy('ssapt0'). A First Example¶; The following is the simplest ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:7318,simpl,simply,7318,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,6,['simpl'],['simply']
Usability,", their coupling is assumed to be high spin, i.e.; two doublets would interact to form a triplet. The S2 approximation and scaling¶; All exchange terms in SAPT arise from the antisymmetrization; of the wavefunctions of monomers A and B. Taking into account exchange of all possible; electron pairs between the two monomers yields to complicated formulae.; For this reason, exchange terms are often evaluated in the \(S^{2}\); approximation, that can be interpreted as the exchange of a single electron; pair between monomers.; The \(S^{2}\) approximation is usually pretty good, but may; break down for short intermolecular distance, particularly in high-order; terms. To compensate these deviations, Parker et al. [Parker:2014:094106]; recommend to scale all \(S^{2}\) approximated exchange terms by the ratio:. \[p_{EX}(\alpha) = \left( \frac{E_{exch}^{(10)}}{E_{exch}^{(10)}(S^{2})} \right)^{\alpha}\]; where the recommended exponent is \(\alpha = 1\). To obtain SAPT energies with this scaling,; simply set the keyword exch_scale_alpha true. Alternatively, another value for \(\alpha\); can be specified by setting EXCH_SCALE_ALPHA to a value. For example,; set exch_scale_alpha 1.0. will set \(\alpha = 1.0\) and scale exchange energies with \(p_{EX}(1.0)\).; Instead of this straightforward scaling, SAPT0 energies benefit from a slightly modified; recipe that involves an empirically adjusted exponent \(\alpha = 3.0\).; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]). (9)¶\[E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)}; + \delta_{HF}^{(2)}\]; where \(\delta_{HF}^{(2)}\) is computed without any scaling. Please note that; sSAPT0 is thus not the same as requesting exch_scale_alpha 3.0, and that the; scaling is automatically performed by requesting energy('ssapt0'). A First Example¶; The following is the simplest p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:8981,simpl,simply,8981,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,7,['simpl'],['simply']
Usability,", we will compute the Hartree-Fock SCF energy with the cc-pVDZ basis set by passing the method/basis set as a string ('scf/cc-pvdz') into the function psi4.energy(); API:. [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section Compiling and Installing from Source).; This very simple input is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin multiplicity (1 for a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program correctly guessed all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not all the electrons are paired. For example, let’s run a computation on methylene (\(\text{CH}_2\)), whose ground electronic state has two unpaired electrons (triplet electronic state, or a spin multiplicity \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is not correct, so we need to tell the program the true value (3). Like many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:4234,simpl,simple,4234,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,6,['simpl'],['simple']
Usability,",; 'model': {; ""basis"": self.basis,; 'method': self.method,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=self.findifrec[""reference""][""module""]),; 'extras': {; 'qcvars': qcvars,; 'findif_record': copy.deepcopy(self.findifrec),; },; 'return_result': self.findifrec['reference'][self.driver.name],; 'success': True,; }). logger.debug('\nFINDIF QCSchema:\n' + pp.pformat(findif_model)). return findif_model. [docs] def get_psi_results(self, return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - undisplaced molecule; - compute basis if simple, else dummy basis def2-svp; - e/g/h member data; - QCVariables; - module. Returns; -------; ret; Gradient or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; findif_model = self.get_results(). ret_ptype = core.Matrix.from_array(findif_model.return_result); wfn = _findif_schema_to_wfn(findif_model). gradient_write(wfn); hessian_write(wfn). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _findif_schema_to_wfn(findif_model: AtomicResult) -> core.Wavefunction:; """"""Helper function to produce Wavefunction and Psi4 files from a FiniteDifference-flavored AtomicResult."""""". # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; mol = core.Molecule.from_schema(findif_model.molecule.dict(), nonphysical=True); sbasis = ""def2-svp"" if (findif_model.model.basis == ""(auto)"") else findif_model.model.basis; basis = core.BasisSet.build(mol, ""ORBITAL"", sbasis, quiet=True); wfn = core.Wavefunction(mol, basis);",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:52465,simpl,simple,52465,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,1,['simpl'],['simple']
Usability,",; can be formulated as RAS CI’s. A RAS CI selects determinants for the; model space as those which have no more than \(n\) holes in the lowest set; of orbitals (called RAS I) and no more than \(m\) electrons in the highest; set of orbitals (called RAS III). An intermediate set of orbitals, if; present (RAS II), has no restrictions placed upon it. All determinants; satisfying these rules are included in the RAS CI.; The DETCI module is also very efficient at computing full configuration; interaction; wavefunctions, and it is used in this capacity in the complete-active-space; self-consistent-field (CASSCF) code. It can also perform approximate; CASSCF computations in which one uses RAS restrictions on the CI excitations,; rather than doing a full CI in the active space. This is called a; RASSCF. CASSCF and RASSCF computations are types of multi-configurational; self-consistent-field procedures, and are described in sec:mcscf.; As mentioned above, the DETCI module is designed for challenging; chemical systems for which simple CISD is not suitable. Because; CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,; typically the DETCI code will be used in cases where the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. Higher order; single-referen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/detci-1.html:3726,simpl,simple,3726,psi4manual/1.2.1/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/detci-1.html,6,['simpl'],['simple']
Usability,",outfile);. // Block matrix should be free_blocked; free_block(A);. Important Lapack Routines¶. DSYEV: Eigenvalues and, optionally eigenvectors of a symmetric matrix. Eigenvectors take up to 10x longer than eigenvalues.; DGEEV: Eigenvalues and, optionally eigenvectors of a general matrix. Up to 10x slower than DSYEV.; DGESV: General solver (uses LU decomposition).; DGESVD: General singular value decomposition.; DGETRF: LU decomposition.; DPOTRF: Cholesky decomposition (much more stable/faster); DGETRS: Solver, given LU decomposition by DGETRF; DPOTRS: Solver, given Cholesky decomposition by DPOTRF; DGETRI: Inverse, given LU decomposition by DGETRF (Warning: it’s faster and more stable just to solve with DGETRS); DPOTRI: Inverse, given Cholesky decomposition by DPOTRF (Warning: it’s faster and more stable just to solve with DPOTRS). How to use low-level BLAS/LAPACK with psi4.core.Matrix¶; Jet’s awesome new Matrix object has a lot of simple BLAS/LAPACK built in,; but you can just as easily use the double*** array underneath if you are; careful (the outer index is the submatrix for each irrep). Here’s an; example:; // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // Matrix; #include ""psi4/libmints/matrix.h"". using namespace psi;; ...; int n = 100;. // Allocate A Matrix (new C1 convenience constructor);; shared_ptr<Matrix> A(new Matrix(""Still A, but way cooler"", n,n));; // Get the pointer to the 0 irrep (C1 for now, it errors if you ask for too high of an index); double** A_pointer = A->get_pointer(0);. // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A_pointer[0], n);. // Wow that's a lot easier; A->print();. // Don't free, it's shared_ptr!. How to name orbital bases (e.g., AO & SO)¶; Many different working bases (the internal linear algebraic basis, not the; name of the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_blas-1.html:7356,simpl,simple,7356,psi4manual/1.4.0/prog_blas-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_blas-1.html,9,['simpl'],['simple']
Usability,",outfile);. // Block matrix should be free_blocked; free_block(A);. Important Lapack Routines¶. DSYEV: Eigenvalues and, optionally eigenvectors of a symmetric matrix. Eigenvectors take up to 10x longer than eigenvalues.; DGEEV: Eigenvalues and, optionally eigenvectors of a general matrix. Up to 10x slower than DSYEV.; DGESV: General solver (uses LU decomposition).; DGESVD: General singular value decomposition.; DGETRF: LU decomposition.; DPOTRF: Cholesky decomposition (much more stable/faster); DGETRS: Solver, given LU decomposition by DGETRF; DPOTRS: Solver, given Cholesky decomposition by DPOTRF; DGETRI: Inverse, given LU decomposition by DGETRF (Warning: it’s faster and more stable just to solve with DGETRS); DPOTRI: Inverse, given Cholesky decomposition by DPOTRF (Warning: it’s faster and more stable just to solve with DPOTRS). How to use low-level BLAS/LAPACK with psi4.core.Matrix¶; Jet’s awesome new Matrix object has a lot of simple BLAS/LAPACK built in,; but you can just as easily use the double*** array underneath if you are; careful (the outer index is the submatrix for each irrep). Here’s an; example:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33// BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // Matrix; #include ""psi4/libmints/matrix.h"". using namespace psi;; ...; int n = 100;. // Allocate A Matrix (new C1 convenience constructor);; shared_ptr<Matrix> A(new Matrix(""Still A, but way cooler"", n,n));; // Get the pointer to the 0 irrep (C1 for now, it errors if you ask for too high of an index); double** A_pointer = A->get_pointer(0);. // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A_pointer[0], n);. // Wow that's a lot easier; A->print();. // Don't free, it's shared_ptr!. How to nam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:7601,simpl,simple,7601,psi4manual/1.2.1/prog_blas-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html,4,['simpl'],['simple']
Usability,"----------------------------------------------------------------------!; ! !; ! asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by !; ! difference (1.0000). !; ! !; !----------------------------------------------------------------------------------!. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]; class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation :class:`FutureWarning`.; For cases where the syntax just has to jump, an UpgradeHelper can be used; to trap the old syntax at first error and suggest the new. An UpgradeHelper can also be used after the :class:`FutureWarning`; described above has expired. Then the body of the code can be deleted while; the definition is preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters; ----------; old; Previously valid syntax.; new; Suggested replacement syntax.; version; First Major.minor version at which `old` syntax won't run. Generally; the next release at time of commit.; elaboration; Any additional message to convey. Should start with a space. """"""; def __init__(self, old: str, new: str, version: str, elaboration: str):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]; class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF, optimization).; iteration; Iteration number on which routine failed.; additional_info; Any additional message to convey. Attributes; ----------; message; Human readable string",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:4360,guid,guide,4360,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,3,['guid'],['guide']
Usability,"------------------------------------------------------------------------!; ! !; ! asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by !; ! difference (1.0000). !; ! !; !----------------------------------------------------------------------------------!. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation :class:`FutureWarning`.; For cases where the syntax just has to jump, an UpgradeHelper can be used; to trap the old syntax at first error and suggest the new. An UpgradeHelper can also be used after the :class:`FutureWarning`; described above has expired. Then the body of the code can be deleted while; the definition is preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters; ----------; old; Previously valid syntax.; new; Suggested replacement syntax.; version; First Major.minor version at which `old` syntax won't run. Generally; the next release at time of commit.; elaboration; Any additional message to convey. Should start with a space. """"""; def __init__(self, old: str, new: str, version: str, elaboration: str):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF, optimization).; iteration; Iteration number on which routine failed.; additional_info; Any additional message to convey. Attributes; ----------; message; Human readable string d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html:4348,guid,guide,4348,psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html,1,['guid'],['guide']
Usability,"------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | C++ signature :; | void addBasis(N3psi17ExternalPotentialE {lvalue},N5boost10shared_ptrIN3psi8BasisSetEEE,N5boost10shared_ptrIN3psi6VectorEEE); | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | C++ signature :; | void addCharge(N3psi17ExternalPotentialE {lvalue},d,d,d,d); | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | C++ signature :; | void clear(N3psi17ExternalPotentialE {lvalue}); | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE computePotentialMatrix(N3psi17ExternalPotentialE {lvalue},N5boost10shared_ptrIN3psi8BasisSetEEE); | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | C++ signature :; | void print_out(N3psi17ExternalPotentialE {lvalue}); | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | C++ signature :; | void setName(N3psi17ExternalPotentialE {lvalue},Ss); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_si",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:452254,clear,clear,452254,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['clear'],['clear']
Usability,"------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class OEProp(Boost.Python.instance); | docstring; | ; | Method resolution order:; | OEProp; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1, (Wavefunction)arg2) -> None :; | ; | C++ signature :; | void __init__(P7_object,N5boost10shared_ptrIN3psi12WavefunctionEEE); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | add(...); | add( (OEProp)arg1, (str)arg2) -> None :; | docstring; | ; | C++ signature :; | void add(N3psi6OEPropE {lvalue},Ss); | ; | clear(...); | clear( (OEProp)arg1) -> None :; | docstring; | ; | C++ signature :; | void clear(N3psi6OEPropE {lvalue}); | ; | compute(...); | compute( (OEProp)arg1) -> None :; | docstring; | ; | C++ signature :; | void compute(N3psi6OEPropE {lvalue}); | ; | set_Da_ao(...); | set_Da_ao( (OEProp)arg1, (Matrix)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void set_Da_ao(N3psi6OEPropE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE,i); | ; | set_Da_mo(...); | set_Da_mo( (OEProp)arg1, (Matrix)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_Da_mo(N3psi6OEPropE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE); | ; | set_Da_so(...); | set_Da_so( (OEProp)arg1, (Matrix)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_Da_so(N3psi6OEPropE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE); | ; | set_Db_ao(...); | set_Db_ao( (OEProp)arg1, (Matrix)arg2, (int)arg3) -> None :; | docstring; | ; | C++ signature :; | void set_Db_ao(N3psi6OEPropE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE,i); | ; | set_Db_mo(...); | set_Db_mo( (OEProp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:566493,clear,clear,566493,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['clear'],['clear']
Usability,"----------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class F12(TwoElectronInt); | docstring; | ; | Method resolution order:; | F1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:36373,clear,clear,36373,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['clear'],['clear']
Usability,"----------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittedSlaterCorrelationFactor(CorrelationFactor); | docstring; | ; | M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:19734,clear,clear,19734,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,4,['clear'],['clear']
Usability,"----------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class FittingMetric(Boost.Python.instance); | docstring; | ; | Method resolu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:17981,clear,clear,17981,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,2,['clear'],['clear']
Usability,"-> ModuleType:; """"""Import loader for *module* in any possible lettercase permutation. Parameters; ----------; module; Name of module with uncertain case. Returns; -------; types.ModuleType; Module object. """"""; modobj = None; for permutation in list(all_casings(module)):; try:; modobj = __import__(permutation); except ImportError:; pass; else:; break. return modobj. _modules = [; # Psi4 Modules; ""CCENERGY"",; ""CCEOM"",; ""CCDENSITY"",; ""CCLAMBDA"",; ""CCHBAR"",; ""CCRESPONSE"",; ""CCTRANSORT"",; ""CCTRIPLES"",; ""CPHF"",; ""DCT"",; ""DETCI"",; ""DFEP2"",; ""DFMP2"",; ""DFOCC"",; ""DLPNO"",; ""DMRG"",; ""EFP"",; ""FINDIF"",; ""FISAPT"",; ""FNOCC"",; ""GDMA"",; ""MCSCF"",; ""MINTS"",; ""MRCC"",; ""OCC"",; ""OPTKING"",; ""PCM"",; ""PE"",; ""PSIMRCC"",; ""RESPONSE"",; ""SAPT"",; ""SCF"",; ""THERMO"",; # External Modules; ""CFOUR"",; ]. [docs]; @contextmanager; def hold_options_state() -> Iterator[None]:; """"""Return a context manager that will collect the current state of; ``Process:environment.options`` on entry to the with-statement and clear; and restore the collected keywords state when exiting the with-statement. """"""; pofm = prepare_options_for_modules(; changedOnly=True, commandsInsteadDict=False, globalsOnly=False, stateInsteadMediated=True; ); yield; _reset_pe_options(pofm). def _reset_pe_options(pofm: Dict):; """"""Acts on ``Process::environment.options`` to clear it, then set it to; state encoded in `pofm`. Parameters; ----------; pofm; Result of :py:func:`prepare_options_for_modules` with; ``changedOnly=True``, ``commandsInsteadDict=False``, and; ``stateInsteadMediated=True``. """"""; core.clean_options(). for go, dgo in pofm['GLOBALS'].items():; if dgo['has_changed']:; core.set_global_option(go, dgo['value']). for module in _modules:; for lo, dlo in pofm[module].items():; if dlo['has_changed']:; core.set_local_option(module, lo, dlo['value']). ## this is a more defensive version if defaults may have changed; # for go, dgo in pofm['GLOBALS'].items():; # core.set_global_option(go, dgo['value']); # if not dgo['has_changed']:; # core.r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:9747,clear,clear,9747,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,3,['clear'],['clear']
Usability,". # build with Intel; >>> cmake -H. -Bbuild \; -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gnu-prefix=${HOST}-"" \; -DCMAKE_CXX_FLAGS=""-gnu-prefix=${HOST}-"" \. # (B) tell CMake to tell the compiler which GCC to use; >>> GCC7=/path/to/miniconda/envs/gcc72; >>> cmake -H. -Bbuild \; -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \; -DCMAKE_CXX_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \; ...; # if Fortran active ...; -DCMAKE_Fortran_COMPILER=ifort \; -DCMAKE_Fortran_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \. # Configure and build. # To Run:; >>> export LD_LIBRARY_PATH=${GCC5}/lib:$LD_LIBRARY_PATH. How to configure a Psi4 build on Cray¶; Cray systems strongly prefer to build static libraries, but PSI4; needs to be dynamic to function as a Python module. Courtesy of @misha; at the forum and various supercomputer guides, building PSI4 on; Cray requires setting environment variables CRAYPE_LINK_TYPE; and CRAY_ADD_RPATH before running cmake.; 1CRAYPE_LINK_TYPE=dynamic CRAY_ADD_RPATH=yes cmake ... How to configure Fortran compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a Fortran compiler in unneeded for core; features but may be required for add-ons.; Downstream Dependencies; PSI4 (\(\Leftarrow\) optional) Fortran Compiler; erd, dkh, gdma, PCMSolver \(\Leftarrow\) Fortran Compiler. CMake Variables. CMAKE_Fortran_COMPILER — CMake variable to specify name or full path to Fortran compiler.; CMAKE_Fortran_FLAGS — CMake variable to specify any additional custom compiler flags for Fortran source. Examples. Build with detected compiler from PATH. >>> cmake. Build with specific (Intel) compiler from PATH. >>> cmake -DCMAKE_Fortran_COMPILER=ifort. What Fortran compilers are approved¶; On Linux and Mac, the following work nicely. GNU: gfortran; Intel: ifort. Packages to install for specific OS or package managers:; Ubun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:33556,guid,guides,33556,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['guid'],['guides']
Usability,". # build with Intel; >>> cmake -H. -Bbuild \; -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gnu-prefix=${HOST}-"" \; -DCMAKE_CXX_FLAGS=""-gnu-prefix=${HOST}-"" \. # (B) tell CMake to tell the compiler which GCC to use; >>> GCC7=/path/to/miniconda/envs/gcc72; >>> cmake -H. -Bbuild \; -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \; -DCMAKE_CXX_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \; ...; # if Fortran active ...; -DCMAKE_Fortran_COMPILER=ifort \; -DCMAKE_Fortran_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \. # Configure and build. # To Run:; >>> export LD_LIBRARY_PATH=${GCC7}/lib:$LD_LIBRARY_PATH. How to configure a Psi4 build on Cray¶; Cray systems strongly prefer to build static libraries, but PSI4; needs to be dynamic to function as a Python module. Courtesy of @misha; at the forum and various supercomputer guides, building PSI4 on; Cray requires setting environment variables CRAYPE_LINK_TYPE; and CRAY_ADD_RPATH before running cmake.; 1CRAYPE_LINK_TYPE=dynamic CRAY_ADD_RPATH=yes cmake ... How to configure Fortran compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a Fortran compiler in unneeded for core; features but may be required for add-ons.; Downstream Dependencies; PSI4 (\(\Leftarrow\) optional) Fortran Compiler; erd, dkh, gdma, PCMSolver \(\Leftarrow\) Fortran Compiler. CMake Variables. CMAKE_Fortran_COMPILER — CMake variable to specify name or full path to Fortran compiler.; CMAKE_Fortran_FLAGS — CMake variable to specify any additional custom compiler flags for Fortran source. Examples. Build with detected compiler from PATH. >>> cmake. Build with specific (Intel) compiler from PATH. >>> cmake -DCMAKE_Fortran_COMPILER=ifort. What Fortran compilers are approved¶; On Linux and Mac, the following work nicely. GNU: gfortran; Intel: ifort. Packages to install for specific OS or package managers:; Ubun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:36033,guid,guides,36033,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['guid'],['guides']
Usability,". :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +---------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:49348,guid,guide,49348,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['guid'],['guide']
Usability,". Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. Ways to Add Code: Psi4NumPy, Plugins, Full Integration¶. Easier and more rapid development¶; Fully-featured electronic structure programs are large and complex. However,; the PSI4 ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of PSI4 were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user’s perspective, programming was; still relatively difficult because it required modifications to be made in C++; code.; Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html:1102,simpl,simplified,1102,psi4manual/1.4.0/prog_ways_to_add-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html,2,['simpl'],['simplified']
Usability,". Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. Ways to Add Code: Psi4NumPy, Plugins, Full Integration¶. Easier and more rapid development¶; Fully-featured electronic structure programs are large and complex. However,; the PSI4 ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of PSI4 were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user’s perspective, programming was; still relatively difficult because it required modifications to be made in C++; code.; Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/prog_ways_to_add-1.html:1102,simpl,simplified,1102,psi4manual/1.5.0/prog_ways_to_add-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/prog_ways_to_add-1.html,2,['simpl'],['simplified']
Usability,". Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. Ways to Add Code: Psi4NumPy, Plugins, Full Integration¶. Easier and more rapid development¶; Fully-featured electronic structure programs are large and complex. However,; the PSI4 ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of PSI4 were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user’s perspective, programming was; still relatively difficult because it required modifications to be made in C++; code.; Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:1102,simpl,simplified,1102,psi4manual/1.6.x/prog_ways_to_add.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html,1,['simpl'],['simplified']
Usability,". Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. Ways to Add Code: Psi4NumPy, Plugins, Full Integration¶. Easier and more rapid development¶; Fully-featured electronic structure programs are large and complex. However,; the PSI4 ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of PSI4 were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user’s perspective, programming was; still relatively difficult because it required modifications to be made in C++; code.; Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/prog_ways_to_add.html:1102,simpl,simplified,1102,psi4manual/1.7.x/prog_ways_to_add.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/prog_ways_to_add.html,1,['simpl'],['simplified']
Usability,". Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Interfaces: Enhancing Psi4 Capabilities ». Interface to DFTD3 by S. Grimme¶; Code author: Lori A. Burns; Section author: Lori A. Burns; Module: Samples; Psi4 contains code to interface to the DFTD3 program of S. Grimme, which is freely; downloadable from http://www.thch.uni-bonn.de/tc/index.php?section=downloads&subsection=getd3&lang=english). Installation¶; DFTD3 is available as conda package. If using the Psi4 binary, the; dftd3 executable has already been installed alongside. If using; Psi4 built from source, and anaconda or miniconda has already; been installed (instructions at Quick Installation), the dftd3; executable can be obtained through conda install dftd3.; To be used by Psi4, the program binary (dftd3) must be; found in your PSIPATH or PATH (in that order). If; Psi4 is unable to execute the binary, an error will be reported.; To preferentially use a particular dftd3 compilation, simply adjust its; position in the path environment variables. To remove the dftd3 that; conda installs alongside Psi4, conda remove dftd3.; Alternatively, to build DFTD3 yourself,; follow the instructions provided with the source; (essentially, unpack the source, edit the Makefile to select a; Fortran compiler, and run make). From version 3.1.0 onwards, DFTD3 can be used; as-is; for earlier versions, patches are available:; psi4/share/scripts/patch_grimme_dftd3.3.0.2.; >>> cd dftd3; >>> ls; dftd3.tar; patch_grimme_dftd3.3.0.2; >>> tar -xvf dftd3.tar; copyc6.f; dftd3.f; Makefile; man.pdf; pars.f; param; >>> patch < patch_grimme_dftd3.3.0.2; patching file dftd3.f; >>> make; making dftd3.o from dftd3.f; ifort -O -c dftd3.f -o dftd3.o; making copyc6.o from copyc6.f; ifort -O -c copyc6.f -o copyc6.o; ifort dftd3.o copyc6.o -o ./dftd3; >>> ls; Makefile copyc6.o dftd3.f dftd3.tar param patch_grimme_dftd3.3.0.2; copyc6.f dftd3 dftd3.o man.pdf pars.f. Theory¶; The local or semilocal character of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dftd3-1.html:1059,simpl,simply,1059,psi4manual/1.0.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dftd3-1.html,2,['simpl'],['simply']
Usability,". To instruct the I/O manager to send all files to; another location, say /scratch/user, add the following command to the ~/.psi4rc; file.:; psi4_io.set_default_path('/scratch/user'). For batch jobs running through a queue, it might be more convenient to use an; environmental variable (in this case $MYSCRATCH) to set the scratch directory;; the following code will do that:; import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). Individual files can be sent to specific locations. For example, file 32 is; the checkpoint file that the user might want to retain in the working directory; (i.e., where PSI4 was launched from) for restart purposes. This is; accomplished by the commands below:; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). which is equivalent to; psi4_io.set_specific_path(PSIF_CHKPT, './'); psi4_io.set_specific_retention(PSIF_CHKPT, True). A guide to the contents of individual scratch files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously.; To override any of these defaults for selected jobs, simply place the; appropriate commands from the snippets above in the input file itself. During; excecution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed. Executing PSI4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; psi4 -m. Alternately, the scratch directory can be set through the environment; variable PSI_SCRATCH (overrides ~/.psi4rc settings). (First line; for C shell; second line for bash.); setenv PSI_SCRATCH /scratch/user; export PSI_SCRATCH=/scratch/user. The ~/.psi4rc file can also be used to define constants that are ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/external-1.html:3885,guid,guide,3885,psi4manual/4.0b4/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/external-1.html,4,['guid'],['guide']
Usability,". auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. Mark virtual functions in derived classes with override¶; The override keyword introduced in C++11 is used to mark a function in a; derived class and guarantee that it is overloading a function with the same; signature in the base class. This behavior is checked at compile time. Prefer GiB for memory printing¶; As memory sizes get larger, we should work in giga (requires decimal printing to not round to zero) rather than mega units.; As it’s what we’re computing anyways, we should work in 1024-based (mebi, gibi, etc. https://en.wikipedia.org/wiki/Gibibyte) rather than 1000-based units.; As it’s a unit, put it in brackets.; Note that users can supply MiB, GB, bytes, or whatever; this guideline is for output printing.; outfile->Printf("" DFHelper Memory: AOs need %.3f [GiB]; user supplied %.3f [GiB]. "",; (required * 8 / (1024 * 1024 * 1024.0)),. table of contents. C++ Style; Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; Mark virtual functions in derived classes with override; Prefer GiB for memory printing. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Adding New Code to PSI4; C++ Style. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/prog_style_c.html:3064,guid,guideline,3064,psi4manual/1.7.x/prog_style_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/prog_style_c.html,1,['guid'],['guideline']
Usability,". field cbsrec: List[Dict[str, Any]] = []¶. field compute_list: List[Dict[str, Any]] = []¶. field driver: DriverEnum [Required]¶. field keywords: Dict[str, Any] = {}¶. field metadata: Any = None¶. field metameta: Dict[str, Any] = {}¶. field method: str = '(auto)'¶. field molecule: Any = None¶. Validated by:. set_molecule. field results_list: List[Any] = []¶. field task_list: List[AtomicComputer] = []¶. field trove: List[Dict[str, Any]] = []¶. field verbose: int = 1¶. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶. Parameters:; client (qcportal.FractalClient | None) – . get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. molecule; dummy basis, def2-svp; e/g/h member data; QCVariables; module if simple. client (qcportal.FractalClient | None) – . Returns:. ret – Energy, gradient, or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. Return type:; float | Matrix | Tuple[float | Matrix, Wavefunction]. get_results(client=None)[source]¶; Return results as Composite-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None) – . Return type:; AtomicResult. plan()[source]¶. validator set_molecule  »  molecule[source]¶. table of contents. Complete Basis Set; Output; Extrapolation Schemes; xtpl_highest_1(); scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(); scf_xtpl_helgaker_3(); corl_xtpl_helgaker_2(); _get_default_xtpl(); register_xtpl_function(). Aliases; sherrill_gold_standard(); allen_focal_point(); register_composite_function(). API; CompositeComputer; CompositeComputer.basis; CompositeComputer.cbsrec; CompositeComputer.compute_list; CompositeComputer.driver; CompositeCompute",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/cbs.html:40200,simpl,simple,40200,psi4manual/1.8.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/cbs.html,2,['simpl'],['simple']
Usability,". set_Db_so(self, arg0); docstring. set_names(self, arg0); Instruct OEProp to save variables under all specified names. set_title(self, title); Title OEProp for print purposes. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']¶. Methods Documentation. Exvals(self: psi4.core.OEProp) → List[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp) → None¶; Clear the list of properties to compute. compute(self: psi4.core.OEProp) → None¶; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0) → None¶; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0) → None¶; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_names(self: psi4.core.OEProp, arg0: Set[str]) → None¶; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str) → None¶; Title OEProp for print purposes. As a side effect, saves variables",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.OEProp.html:1900,clear,clear,1900,psi4manual/1.6.x/api/psi4.core.OEProp.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.OEProp.html,4,['clear'],['clear']
Usability,". set_Db_so(self, arg0); docstring. set_names(self, arg0); Instruct OEProp to save variables under all specified names. set_title(self, title); Title OEProp for print purposes. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']¶. Methods Documentation. Exvals(self: psi4.core.OEProp) → list[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → list[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → list[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → list[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp) → None¶; Clear the list of properties to compute. compute(self: psi4.core.OEProp) → None¶; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0) → None¶; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0) → None¶; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_names(self: psi4.core.OEProp, arg0: set[str]) → None¶; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str) → None¶; Title OEProp for print purposes. As a side effect, saves variables",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.OEProp.html:1891,clear,clear,1891,psi4manual/master/api/psi4.core.OEProp.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.OEProp.html,1,['clear'],['clear']
Usability,".) at each grid point. add((self: psi4.core.OEProp, arg0: str) -> None); docstring. clear((self: psi4.core.Prop) -> None); docstring. compute((self: psi4.core.OEProp) -> None); docstring. set_Da_ao((self: psi4.core.Prop, ...); docstring. set_Da_mo((self: psi4.core.Prop, ...); docstring. set_Da_so((self: psi4.core.Prop, ...); docstring. set_Db_ao((self: psi4.core.Prop, ...); docstring. set_Db_mo((self: psi4.core.Prop, ...); docstring. set_Db_so((self: psi4.core.Prop, ...); docstring. Methods Documentation. Exvals(self: psi4.core.OEProp) → List[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; docstring. clear(self: psi4.core.Prop) → None¶; docstring. compute(self: psi4.core.OEProp) → None¶; docstring. set_Da_ao(self: psi4.core.Prop, Da: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Da_mo(self: psi4.core.Prop, arg0: psi::Matrix) → None¶; docstring. set_Da_so(self: psi4.core.Prop, arg0: psi::Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.Prop, Db: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Db_mo(self: psi4.core.Prop, arg0: psi::Matrix) → None¶; docstring. set_Db_so(self: psi4.core.Prop, arg0: psi::Matrix) → None¶; docstring. Exvals(self: psi4.core.OEProp) → List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.oeprop.html:1573,clear,clear,1573,psi4manual/1.1.0/api/psi4.core.oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.oeprop.html,1,['clear'],['clear']
Usability,"./do-configure. Compile the code, run the tests, and (if tests pass) install it.; >>> make; >>> make tests; >>> make install. That’s it! The details about final user configuration are given below in; Section III(7). If something goes wrong,; check Section VI about common compilation problems. III. Detailed Installation Instructions¶; This section provides a more detailed explanation of the procedure for; compiling and installing the PSI4 package. Step 1: Configuration. General Information about Configuration; First, we recommend that you choose for the top-level psi4 source; directory something other than /usr/local/psi; $HOME/psi4 or; /usr/local/src/psi4 are convenient choices. Next, in the top-level psi4; source directory you’ve chosen, first run autoconf to generate the configure; script from configure.ac. It is best to keep the source code separate; from the compilation area, so you must first choose a subdirectory for; compilation of the codes. A simple option is psi4/objdir, which should; work for most environments. However, if you need executables for several; architectures, you should choose more meaningful subdirectory names. Note; The compilation directory will be referred to as $objdir for the; remainder of these instructions. In $objdir, run the configure script found in the PSI4 top-level source; directory. This script will scan your system to locate certain libraries,; header files, etc. needed for complete compilation. The script accepts a; number of options, all of which are listed above. The most important of; these is the --prefix option, which selects the installation directory for; the executables, the libraries, header files, basis set data, and other; administrative files. The default --prefix is /usr/local/psi. Note; The configure script’s --prefix directory will be referred to as; $prefix for the remainder of these instructions. Besides --prefix, PSI often needs a few additional options for the; configure script. To make it easy to recompile ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:5444,simpl,simple,5444,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,3,['simpl'],['simple']
Usability,".BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: list[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: list[psi4.core.ShellInfo], L: list[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: list[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: list[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: list[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: list[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html:1788,clear,clear,1788,psi4manual/master/api/psi4.core.BSVec.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html,1,['clear'],['clear']
Usability,".Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet) → psi4.core.CUHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(save_fock, max_diis_vectors)¶; docstring. Return type; float. Parameters. save_fock (bool) – ; max_diis_vectors (int) – . compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → Li",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:17893,simpl,simply,17893,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,1,['simpl'],['simply']
Usability,".Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet) → psi4.core.CUHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a giv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:17452,simpl,simply,17452,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,1,['simpl'],['simply']
Usability,".Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet) → psi4.core.ROHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(save_fock, max_diis_vectors)¶; docstring. Return type; float. Parameters. save_fock (bool) – ; max_diis_vectors (int) – . compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → Li",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.rohf.html:18260,simpl,simply,18260,psi4manual/1.5.0/api/psi4.core.rohf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.rohf.html,1,['simpl'],['simply']
Usability,".Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet) → psi4.core.ROHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a giv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.rohf.html:17523,simpl,simply,17523,psi4manual/1.4.0/api/psi4.core.rohf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.rohf.html,1,['simpl'],['simply']
Usability,".__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | C++ signature :; | void addBasis(N3psi17ExternalPotentialE {lvalue},N5boost10shared_ptrIN3psi8BasisSetEEE,N5boost10shared_ptrIN3psi6VectorEEE); | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | C++ signature :; | void addCharge(N3psi17ExternalPotentialE {lvalue},d,d,d,d); | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | C++ signature :; | void clear(N3psi17ExternalPotentialE {lvalue}); | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE computePotentialMatrix(N3psi17ExternalPotentialE {lvalue},N5boost10shared_ptrIN3psi8BasisSetEEE); | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | C++ signature :; | void print_out(N3psi17ExternalPotentialE {lvalue}); | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | C++ signature :; | void setName(N3psi17ExternalPotentialE {lvalue},Ss); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ---",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:452268,clear,clear,452268,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['clear'],['clear']
Usability,".core.Slice) → psi4.core.Vector¶; Get a vector block. nirrep(self: psi4.core.Vector) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. print_out(self: psi4.core.Vector) → None¶; Prints the vector to the output file. scale(self: psi4.core.Vector, sc: float) → None¶; Scales the elements of a vector by sc. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None¶; Set a vector block. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a NumPy array. Either copies the data or simply; constructs a view. Parameters. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns; Returns either a list of np.array’s or the base array depending on options. Return type; numpy.ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; Vector. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.vector.html:4496,simpl,simply,4496,psi4manual/1.4.0/api/psi4.core.vector.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.vector.html,1,['simpl'],['simply']
Usability,".core.Slice) → psi4.core.Vector¶; Get a vector block. nirrep(self: psi4.core.Vector) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. print_out(self: psi4.core.Vector) → None¶; Prints the vector to the output file. scale(self: psi4.core.Vector, sc: float) → None¶; Scales the elements of a vector by sc. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None¶; Set a vector block. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a NumPy array. Either copies the data or simply; constructs a view. Parameters. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns; Returns either a list of np.array’s or the base array depending on options. Return type; numpy.ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; Vector. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.vector.html:4498,simpl,simply,4498,psi4manual/1.5.0/api/psi4.core.vector.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.vector.html,1,['simpl'],['simply']
Usability,"/scratch/parrish/psi.12345.32. get_memory()[source]¶; Function to return the total memory allocation. get_num_threads()[source]¶; Function to return the number of threads to parallelize across. oeprop(*args, **kwargs)[source]¶. set_memory(bytes)[source]¶; Function to reset the total memory allocation. set_num_threads(nthread)[source]¶; Function to reset the number of threads to parallelize across. success(label)[source]¶; Function to print a ‘label...PASSED’ line to screen.; Used by util.compare_values() family when functions pass. basislistdunning¶; Module (auto-generated from make_dunning.pl script); with commands building BasisFamily objects that; encode the Dunning basis set orbital definitions in; psi4/lib/basis/NOTES and fitting bases designed for those; orbital bases. load_basfam_dunning()[source]¶. aliases¶; Module with functions that call upon those in modules; proc, driver, and wrappers. Place in this file quickly defined procedures such as. aliases for complex methods; simple modifications to existing methods. run_mp2_5(name, **kwargs)[source]¶; Function that computes MP2.5 energy from results of a DETCI; MP3 calculation. Psi variables:. MP2.5 TOTAL ENERGY; MP2.5 CORRELATION ENERGY. >>> energy('mp2.5'). sherrillgroup_gold_standard(name='conv-mp2', **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluateo; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> energy('sherrillgroup_gold_standard'). qcdb¶; Module to facilitate quantum chemical computations on chemical; databases. Contains Molecule class and physical constants from psi4 suite.; Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. class CartesianEntry(entry_number, Z, charge, mass, symbol, la",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:34030,simpl,simple,34030,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,2,['simpl'],['simple']
Usability,"/scratch/parrish/psi.12345.32. get_memory()[source]¶; Function to return the total memory allocation. get_num_threads()[source]¶; Function to return the number of threads to parallelize across. oeprop(*args, **kwargs)[source]¶. set_memory(bytes)[source]¶; Function to reset the total memory allocation. set_num_threads(nthread)[source]¶; Function to reset the number of threads to parallelize across. success(label)[source]¶; Function to print a ‘label...PASSED’ line to screen.; Used by util.compare_values() family when functions pass. basislistdunning¶; Module (auto-generated from make_dunning.pl script); with commands building BasisFamily objects that; encode the Dunning basis set orbital definitions in; psi4/lib/basis/NOTES and fitting bases designed for those; orbital bases. load_basfam_dunning()[source]¶. aliases¶; Module with functions that call upon those in modules; proc, driver, and wrappers. Place in this file quickly defined procedures such as. aliases for complex methods; simple modifications to existing methods. sherrillgroup_gold_standard(name='mp2', **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> energy('sherrillgroup_gold_standard'). qcdb¶; Module to facilitate quantum chemical computations on chemical; databases. Contains Molecule class and physical constants from psi4 suite.; Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. class CartesianEntry(entry_number, Z, charge, mass, symbol, label, x, y, z)[source]¶; Class to hold all information about an atom, including its; coordinate specification as three Cartesians. clone()[source]¶; Returns new, independent CartesianEntry object. compute",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:36520,simpl,simple,36520,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,2,['simpl'],['simple']
Usability,"0,3)), np.random.rand(4, 4)]; >>> matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); (2, 0, 4). classmethod from_serial(json_data); Converts serialized data to the correct Psi4 data type. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Vector, arg0: int) -> float. docstring. get(self: psi4.core.Vector, arg0: int, arg1: int) -> float. docstring. name; The name of the Vector. Used in printing. nirrep(self: psi4.core.Vector) → int; docstring. np; View without only one irrep. classmethod np_read(filename, prefix=''). np_write(filename=None, prefix=''). nph; View with irreps. print_out(self: psi4.core.Vector) → None; docstring. scale(self: psi4.core.Vector, arg0: float) → None; docstring. set(*args, **kwargs); Overloaded function. set(self: psi4.core.Vector, arg0: int, arg1: float) -> None. docstring. set(self: psi4.core.Vector, arg0: int, arg1: int, arg2: float) -> None. docstring. shape; Shape of the Psi4 data object. to_array(matrix, copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data); Converts an object with a .nph accessor to a serialized dictionary. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html:6218,simpl,simply,6218,psi4manual/1.1.0/api/psi4.core.vector.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html,1,['simpl'],['simply']
Usability,"0.8; # fig, axt = plt.subplots(figsize=(12.0, fht)); # plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); #; # axt.set_xticks([]); # axt.set_yticks([]); # plt.axis('off'); #; # for item in range(nplots):; # mcdat = mcdats[item]; # label = labels[item]; # title = titles[item]; #; # erdat = np.array(mcdat); # yvals = np.ones(len(mcdat)); # y = np.array([sapt_colors.sapt_colors[dbname][i] for i in label]); #; # ax = Subplot(fig, nplots, 1, item + 1); # fig.add_subplot(ax); # sc = ax.scatter(erdat, yvals, c=y, s=3000, marker=""|"", cmap=mpl.cm.jet, vmin=0, vmax=1); #; # ax.set_yticks([]); # ax.set_xticks([]); # ax.set_frame_on(False); # ax.set_xlim([xmin, xmax]); #; # # Write files with only slats; # plt.savefig('scratch/' + pltfile + '_plain' + '.png', transparent=True, format='PNG'); # plt.savefig('scratch/' + pltfile + '_plain' + '.pdf', transparent=True, format='PDF'); # plt.savefig('scratch/' + pltfile + '_plain' + '.eps', transparent=True, format='EPS'); #; # # Rewrite files with guides and labels; # for item in range(nplots):; # ax_again = fig.add_subplot(nplots, 1, item + 1); # ax_again.set_title(titles[item], fontsize=8); # ax_again.text(xmin + 0.3, 1.0, stats(np.array(mcdats[item])), fontsize=7, family='monospace', verticalalignment='center'); # ax_again.plot([0, 0], [0.9, 1.1], color='#cccc00', lw=2); # ax_again.set_frame_on(False); # ax_again.set_yticks([]); # ax_again.set_xticks([-12.0, -8.0, -4.0, -2.0, -1.0, 0.0, 1.0, 2.0, 4.0, 8.0, 12.0]); # ax_again.tick_params(axis='both', which='major', labelbottom='off', bottom='off'); # ax_again.set_xticks([-12.0, -8.0, -4.0, -2.0, -1.0, 0.0, 1.0, 2.0, 4.0, 8.0, 12.0]); # ax_again.tick_params(axis='both', which='major', labelbottom='on', bottom='off'); #; # plt.savefig('scratch/' + pltfile + '_trimd' + '.png', transparent=True, format='PNG'); # plt.savefig('scratch/' + pltfile + '_trimd' + '.pdf', transparent=True, format='PDF'); # plt.savefig('scratch/' + pltfile + '_trimd' + '.eps', transparent=True, format='EPS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:7822,guid,guides,7822,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['guid'],['guides']
Usability,"012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595. return d / 1.5. [docs]def auto_fragments(**kwargs):; r""""""Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. :returns: :ref:`Molecule<sec:psimod_Molecule>`) |w--w| fragmented molecule. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> molecule mol {\nH 0.0 0.0 0.0\nH 2.0 0.0 0.0\nF 0.0 1.0 0.0\nF 2.0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. """"""; # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molname = molecule.name(). geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]. symbol = list(range(numatoms)); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(numatoms):; A = F[f + 1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_autofrag.html:2352,simpl,simple,2352,psi4manual/1.0.0/_modules/wrapper_autofrag.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_autofrag.html,1,['simpl'],['simple']
Usability,"0]. It can solve for restricted active space; configuration interaction (RAS CI) wavefunctions as described by Olsen,; Roos, Jorgensen, and Aa. Jensen [Olsen:1988]. Excitation-class; selected multi-reference CI wavefunctions, such as second-order CI,; can be formulated as RAS CI’s. A RAS CI selects determinants for the; model space as those which have no more than holes in the lowest set; of orbitals (called RAS I) and no more than electrons in the highest; set of orbitals (called RAS III). An intermediate set of orbitals, if; present (RAS II), has no restrictions placed upon it. All determinants; satisfying these rules are included in the CI.; The DETCI module is also very efficient at computing full configuration; interaction; wavefunctions, and it is used in this capacity in the complete-active-space; self-consistent-field (CASSCF) code. Use of DETCI for CASSCF; wavefunctions is described in another section of this manual.; As just mentioned, the DETCI module is designed for challenging; chemical systems for which simple CISD is not suitable. Because; CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,; typically the DETCI code will be used in cases where the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; The division of the molecular orbitals into various subspaces such as; RAS spaces, or frozen vs. active orbitals, etc., needs to be clear not; only to detci, but also at least to the transformation program; (and in the case of MCSCF, to other programs as well). Thus, orbital; subspace keywords such as RAS1,; RAS2, RAS3, F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/detci-1.html:3102,simpl,simple,3102,psi4manual/1.0.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/detci-1.html,10,['simpl'],['simple']
Usability,"0^{ij}))^{- \alpha_n}}\]; A modified damping scheme for DFT-D3 using the rational damping form of; Becke and Johnson was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now \(s_6\), \(s_8\),; \(a_1\), and \(a_2\). \[E_{disp}^{\text{D3BJ}}=-\sum_{n=6,8} s_n \sum_{i,j>i}^{N_{at}}; \frac{C_n^{ij}}{(R_{ij})^n + (f_{damp})^n}\]. \[f_{damp} = a_1 \sqrt{\frac{C_8^{ij}}{C_6^{ij}}} + a_2\]; All parameters characterizing the dispersion correction are taken from; http://toc.uni-muenster.de/DFTD3/; or else from the literature. Running DFTD3¶; A number of a posteriori dispersion corrections are available in; PSI4. While most are computed within PSI4‘s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/PSI4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of S. Grimme’s -D correction¶. Extension [1]; Variant and Computing Program; DFT_DISPERSION_PARAMETERS. -D; alias to -D2P4;  . -D1; -D1 [2] within PSI4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within PSI4; [\(s_6\)]. -D2GR; -D2 [3] t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dftd3-1.html:4673,simpl,simple,4673,psi4manual/1.1.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dftd3-1.html,2,['simpl'],['simple']
Usability,"0^{ij}))^{- \alpha_n}}\]; A modified damping scheme for DFT-D3 using the rational damping form of; Becke and Johnson was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now \(s_6\), \(s_8\),; \(a_1\), and \(a_2\). \[E_{disp}^{\text{D3BJ}}=-\sum_{n=6,8} s_n \sum_{i,j>i}^{N_{at}}; \frac{C_n^{ij}}{(R_{ij})^n + (f_{damp})^n}\]. \[f_{damp} = a_1 \sqrt{\frac{C_8^{ij}}{C_6^{ij}}} + a_2\]; All parameters characterizing the dispersion correction are taken from; http://toc.uni-muenster.de/DFTD3/; or else from the literature. Running DFTD3¶; A number of a posteriori dispersion corrections are available in; PSI4. While most are computed within PSI4’s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/PSI4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of S. Grimme’s -D correction¶. Extension [1]; Variant and Computing Program; DFT_DISPERSION_PARAMETERS. -D; alias to -D2P4;  . -D1; -D1 [2] within PSI4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within PSI4; [\(s_6\)]. -D2GR; -D2 [3] t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dftd3-1.html:4836,simpl,simple,4836,psi4manual/1.2.1/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dftd3-1.html,2,['simpl'],['simple']
Usability,"2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of whi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:9403,simpl,simple,9403,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,10,['simpl'],['simple']
Usability,"2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:10688,simpl,simple,10688,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['simpl'],['simple']
Usability,"238902. while a non-relativistic calculation yields the following energy:; @RHF Final Energy: -100.01928891411315. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.6645256529074572; Two-Electron Energy = 45.4685031765008461; Total Energy = -100.0192889141131474. Basis sets options¶; The X2C module in PSI4 supports different combinations of basis set.; By default, if the input file specifies only BASIS, then the X2C; module will solve the modified Dirac equation in an uncontracted basis and then; recontract the X2C Hamiltonian in the original basis.; Alternatively, the user can use BASIS_RELATIVISTIC to specify a different; basis set to solve the modified Dirac equation.; set {; basis cc-pvdz-dk; basis_relativistic cc-pvtz-dk; relativistic x2c; }. It is recommended that when employing the X2C relativistic Hamiltonian, that you use a fully; decontracted basis set. This can be done simply in the input by adding “-decon” to the; name of the primary basis you want to use for the calculation as detailed in; Decontracted Basis Sets. Publications resulting from the use; of X2C should cite the following publication: [Verma:2015]. Theory¶; X2C is based on exact decoupling of; positive-energy ( \(h^{FW}_{\rm ++}\); ) and negative-energy (\(h^{FW}_{\rm --}\) ); blocks of the Dirac Hamiltonian (\(h^{D}\)). \[\begin{split}U^\dagger h^{\rm D} U =; U^\dagger; \begin{pmatrix}; h_{LL} & h_{LS} \\; h_{SL} & h_{SS}; \end{pmatrix}; U; =; \begin{pmatrix}; h^{\rm FW}_{++} & 0 \\; 0 & h^{\rm FW}_{--}; \end{pmatrix}\end{split}\]; The transformation ( \(U\) ) is obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984] treatment.; In the X2C treatment, the positive-energy block of the Hamiltonian ( \(h^{FW}_{\rm ++}\) ); is given by the sum; of a transformed kinetic (\(T_{\rm X2C}\)) and potential energy ( \(V_{\rm X2C}\) ) contribution.; Relativistic kinetic energy ( \(T_{\rm X2C}\) ) and nuclear-electron inte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/relativistic-1.html:2650,simpl,simply,2650,psi4manual/1.4.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/relativistic-1.html,9,['simpl'],['simply']
Usability,"3 computation. run_psimrcc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. run_psimrcc_scf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. run_sapt(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a SAPT calculation of any level. run_sapt_ct(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. run_scf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation. run_scf_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a SCF gradient calculation. run_scf_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to run_scf(); since SCF properties all handled through oeprop. run_scs_omp2(name, **kwargs)¶; Function encoding sequence of PSI module calls for; a spin-component scaled OMP2 computation. run_scs_omp3(name, **kwargs)¶; Function encoding sequence of PSI module calls for; a spin-component scaled OMP3 computation. run_sos_omp2(name, **kwargs)¶; Function encoding sequence of PSI module calls for; a spin-opposite scaled OMP2 computation. run_sos_omp3(name, **kwargs)¶; Function encoding sequence of PSI module calls for; a spin-opposite scaled OMP3 computation. scf_helper(name, **kwargs)[source]¶; Function serving as helper to SCF, choosing whether to cast; up or just run SCF with a standard guess. This preserves; previous SCF options set by other procedures (e.g., SAPT; output file types for SCF). dashparam¶; Module to hold and distribute the -D dispersion correction parameters. dash_server(func, dashlvl, mode='psi4')[source]¶; Function to serve up dispersion correction parameters in whatever form needed.; Whe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:12112,simpl,simple,12112,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,2,['simpl'],['simple']
Usability,"36924. And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. Psi4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in Psi4. Table Of Contents. A Psi4 Tutorial; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. Previous topic; Binary Distribution; Next topic; Psithon: Structuring an Input File. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. module",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:21698,simpl,simple,21698,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['simpl'],['simple']
Usability,"3].; Publications resulting from the use of the OCEPA code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the MP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the CEPA0 code should cite the following publication(s):; [Bozkaya:2011:omp2]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals generally provide much better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals we can simply use “reference rohf” option. For DFT orbitals one should use “reference uks” and “dft_functional b3lyp” options. Of; course users can use any DFT functional available in Psi4. Methods¶; The conventional and orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. omp2; Orbital-Optimized MP2; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/occ-1.html:5582,simpl,simply,5582,psi4manual/4.0b5/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/occ-1.html,2,['simpl'],['simply']
Usability,"4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; from __future__ import print_function; from __future__ import absolute_import; import os; import re; import math; import warnings. from psi4.driver import driver_cbs. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn, filename='fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :type filename: string; :param filename: destination file name for file11 file. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/aliases.html:1277,simpl,simple,1277,psi4manual/1.2.1/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/aliases.html,1,['simpl'],['simple']
Usability,"4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; from __future__ import print_function; from __future__ import absolute_import; import re; import os; import math; import warnings; from psi4.driver import driver_cbs; #from wrappers import *; #from gaussian_n import * # CU; #from wrappers_cfour import * # CU; #from qmmm import * # CU. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn, filename='fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :type filename: string; :param filename: destination file name for file11 file. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/aliases.html:1275,simpl,simple,1275,psi4manual/1.1.0/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/aliases.html,1,['simpl'],['simple']
Usability,"4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; import os; import re; import math; import warnings. from psi4.driver import driver_cbs. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn, filename='fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :type filename: string; :param filename: destination file name for file11 file. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradien",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/aliases.html:1277,simpl,simple,1277,psi4manual/1.3.2/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/aliases.html,1,['simpl'],['simple']
Usability,"4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; import os; import re; import warnings. from psi4.driver import driver_cbs. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn, filename='fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :type filename: str; :param filename: destination file name for file11 file. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:1296,simpl,simple,1296,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html,2,['simpl'],['simple']
Usability,"4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; import os; import re; import warnings; from typing import Any, Dict, List. CBSMetadata = List[Dict[str, Any]]. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn, filename='fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :type filename: str; :param filename: destination file name for file11 file. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/aliases.html:1296,simpl,simple,1296,psi4manual/1.6.x/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/aliases.html,1,['simpl'],['simple']
Usability,"4.set_local_option('SCF', 'D_CONVERGENCE', pscf_Dc); if verbose >= 2:; print(pscf_Dc, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'D_CONVERGENCE'), end=' '). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if procedures['energy'][method_name] not in [proc.run_scf, proc.run_dft]:; psi4.set_global_option('E_CONVERGENCE', gen_Ec); if verbose >= 2:; print(gen_Ec, end=' '); else:; if procedures['energy'][method_name] not in [proc.run_scf, proc.run_dft]:; if verbose >= 2:; print('CUSTOM', psi4.get_global_option('E_CONVERGENCE'), end=' '). if verbose >= 2:; print(''); return optstash. [docs]def parse_arbitrary_order(name):; r""""""Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. """""". name = name.lower(). # matches 'mrccsdt(q)'; if name.startswith('mrcc'):. # avoid undoing fn's good work when called twice; if name == 'mrcc':; return name, None. # grabs 'sdt(q)'; ccfullname = name[4:]. # A negative order indicates perturbative method; methods = {; 'sd' : { 'method': 1, 'order': 2, 'fullname': 'CCSD' },; 'sdt' : { 'method': 1, 'order': 3, 'fullname': 'CCSDT' },; 'sdtq' : { 'method': 1, 'order': 4, 'fullname': 'CCSDTQ' },; 'sdtqp' : { 'method': 1, 'order': 5, 'fullname': 'CCSDTQP' },; 'sdtqph' : { 'method': 1, 'order': 6, 'fullname': 'CCSDTQPH' },; 'sd(t)' : { 'method': 3, 'order': -3, 'fullname': 'CCSD(T)' },; 'sdt(q)' : { 'method': 3, 'order': -4, 'fullname': 'CCSDT(Q)' },; 'sdtq(p)' : { 'method': 3, 'order': -5, 'fullname': 'CCSDTQ(P)' },; 'sdtqp(h)' : { 'method': 3, 'order': -6, 'fullname': 'CCSDTQP(H)' },; 'sd(t)_l' : { 'method': 4, 'order': -3, 'fullname': 'CCSD(T)_L' },; 'sdt(q)_l' : { 'method': 4, 'order': -4, 'fullname': 'CCSDT(Q)_L' },; 'sdtq(p)_l' : { 'method': 4, 'order': -5, 'fullname': 'CCSDTQ(P)_L' },; 'sdtqp(h)_l' : { 'method': 4, 'order': -6, 'fullname': 'CCSDTQP(H)_L",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:4590,undo,undoing,4590,psi4manual/1.0.0/_modules/driver_util.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html,1,['undo'],['undoing']
Usability,"4_io. To instruct the I/O manager to send all files to; another location, say /scratch/user, add the following command to your input; file:; psi4_io.set_default_path('/scratch/user'). For batch jobs running through a queue, it might be more convenient to use an; environmental variable (in this case $MYSCRATCH) to set the scratch directory;; the following code will do that:; import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). Individual files can be sent to specific locations. For example, file 32 is; the checkpoint file that the user might want to retain in the working directory; (i.e., where Psi4 was launched from) for restart purposes. This is; accomplished by the commands below:; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). which is equivalent to; psi4_io.set_specific_path(PSIF_CHKPT, './'); psi4_io.set_specific_retention(PSIF_CHKPT, True). A guide to the contents of individual scratch files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the Psi4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously. This also means that if the user wants Psi4 to use; information from a previous file, like molecular orbitals, he needs to provide the; name of the file. This can be done through the restart_file option; energy('scf',restart_file='./psi.PID.name.filenumber'). where by default, PID is the process number, name the name of the molecule,; and filenumber is listed in content. Only the filenumber; is necessary for the driver to appropriately rename the file for the next Psi4; job, and if none is found it defaults to 32, a checkpoint file. If two or more files; are to be read, they need to be provided as a Python list; energy('scf',restart_file=['./file1.filenumber','./file2.filenumber']). N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:3844,guid,guide,3844,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['guid'],['guide']
Usability,"4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * p4const.psi_cal2J); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. # Quickly normalize the types for both python 2 and 3; try:; unicode = unicode; except NameError:; # 'unicode' is undefined, must be Python 3; str = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:28716,simpl,simple,28716,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['simpl'],['simple']
Usability,": float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: list[tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → list[tuple[float, float, float, float]]¶; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential) → psi4.core.Matrix¶; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.gradient_on_charges(); ExternalPotential.print_out(); ExternalPotential.setName(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html:2861,clear,clear,2861,psi4manual/master/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html,1,['clear'],['clear']
Usability,": float. Overrides the default \alpha parameter used in the listed :py:func:`corl_xtpl_helgaker_2` correlation; extrapolation to the corl stage. The supplied \alpha does not impact delta or any further stages. .. hlist::; :columns: 1. * :py:func:`corl_xtpl_helgaker_2`. :type delta_alpha: float. Overrides the default \alpha parameter used in the listed; :py:func:`corl_xtpl_helgaker_2` correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different \alpha might; be more appropriate. .. hlist::; :columns: 1. * :py:func:`corl_xtpl_helgaker_2`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:36119,simpl,simple,36119,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['simpl'],['simple']
Usability,"; ) -> Union[core.BasisSet, List[core.BasisSet]]:; """"""Build a primary or auxiliary basis set. Parameters; ----------; mol; Molecule for which to build the basis set instance.; key; {'BASIS', 'ORBITAL', 'DF_BASIS_SCF', 'DF_BASIS_MP2', 'DF_BASIS_CC', 'BASIS_RELATIVISTIC', 'DF_BASIS_SAD'}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ``""ORBITAL""`` or ``""BASIS""``.; target; Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely from primary default, can be; an empty string. If None, value taken from `key` in global options. If; a user-defined-basis callable is available at string `target`, `target`; value will be set to it. In practice, setting this argument to a; |PSIfour| keyword (e.g., ``core.get_option(""SCF"", ""DF_BASIS_SCF"")`` or; ``core.get_global_option(""BASIS"")``) works to handle both simple and; user-defined bases.; fitrole; {'ORBITAL', 'JKFIT', 'RIFIT', 'DECON'}; Role for which to build basis. Only used when `key` indicates auxiliary; (i.e., *is not* ``""BASIS""``) and auxiliary spec from processing `target`; can't complete the `mol`. Then, primary spec from `other` can be used; to complete the auxiliary basis by looking up suitable default basis; according to `fitrole`.; other; Only used when building auxiliary basis sets. Defines the primary basis through a string or callable like `target`.; puream; Whether to override the native spherical/cartesian-ness of `target` for; returned basis? Value ``1`` forces spherical, value ``0`` forces; Cartesian, value ``-1`` (default) uses native puream. Note that; explicitly setting :term:`PUREAM <PUREAM (GLOBALS)>` trumps both native; puream and this `puream` argument.; return_atomlist; Build one-atom basis sets (e.g., for SAD) rather than one whole-`mol`; basis set.; quiet; When True, do not print to the output file.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:3426,simpl,simple,3426,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['simpl'],['simple']
Usability,"; Code author: Daniel G. A. Smith, C. David Sherrill, and Matthew L. Leininger; Section author: Daniel G. A. Smith and C. David Sherrill; Module: Keywords, PSI Variables, DETCI; Configuration interaction (CI) is one of the most general ways to; improve upon Hartree–Fock theory by adding a description of the; correlated motions of electrons. Simply put, a CI wavefunction; is a linear combination of Slater determinants (or spin-adapted; configuration state functions), with the linear coefficients being; determined variationally via diagonalization of the Hamiltonian in the; given subspace of determinants. For a “single-reference” CI based; on reference function \(| \Phi_0 \rangle\), we can write the CI expansion as; follows:. (1)¶\[| \Psi \rangle = c_0 | \Phi_0 \rangle; + \sum_i^{\rm occ} \sum_a^{\rm vir} c_i^a | \Phi_i^a \rangle; + \sum_{i<j}^{\rm occ} \sum_{a<b}^{\rm vir} c_{ij}^{ab}; | \Phi_{ij}^{ab} \rangle; + \sum_{i<j<k}^{\rm occ} \sum_{a<b<c}^{\rm vir} c_{ijk}^{abc}; | \Phi_{ijk}^{abc} \rangle + \cdots\]; The simplest standard CI method that improves upon Hartree–Fock is a CI; that adds all singly \(| \Phi_i^a \rangle\) and doubly; \(| \Phi_{ij}^{ab} \rangle\); substituted determinants (CISD) to the reference determinant; \(| \Phi_0 \rangle\). The CISD wavefunction has fallen out of favor; because truncated CI wavefunctions are not size-extensive, meaning; that their quality degrades for larger molecules. MP2 is a less; expensive alternative giving results similar to those of CISD for small; molecules, but the quality of MP2 does not degrade for larger molecules.; Coupled-cluster singles and doubles (CCSD) is another size-extensive; alternative; it is only slightly more costly computationally than CISD,; but it typically provides significantly more accurate results.; The CI code in PSI4 is described in detail in; [Sherrill:1999:CI]. For the reasons stated above, the CI code in; PSI4 is not optimized for CISD computations, and it uses data structures; that are pa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:1226,simpl,simplest,1226,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,9,['simpl'],['simplest']
Usability,"; Code author: Daniel G. A. Smith, C. David Sherrill, and Matthew L. Leininger; Section author: Daniel G. A. Smith and C. David Sherrill; Module: Keywords, PSI Variables, DETCI; Configuration interaction (CI) is one of the most general ways to; improve upon Hartree–Fock theory by adding a description of the; correlated motions of electrons. Simply put, a CI wavefunction; is a linear combination of Slater determinants (or spin-adapted; configuration state functions), with the linear coefficients being; determined variationally via diagonalization of the Hamiltonian in the; given subspace of determinants. For a “single-reference” CI based; on reference function \(| \Phi_0 \rangle\), we can write the CI expansion as; follows:. (1)¶\[| \Psi \rangle = c_0 | \Phi_0 \rangle; + \sum_i^{\rm occ} \sum_a^{\rm vir} c_i^a | \Phi_i^a \rangle; + \sum_{i<j}^{\rm occ} \sum_{a<b}^{\rm vir} c_{ij}^{ab}; | \Phi_{ij}^{ab} \rangle; + \sum_{i<j<k}^{\rm occ} \sum_{a<b<c}^{\rm vir} c_{ijk}^{abc}; | \Phi_{ijk}^{abc} \rangle + \cdots\]; The simplest standard CI method that improves upon Hartree–Fock is a CI; that adds all singly \(| \Phi_i^a \rangle\) and doubly; \(| \Phi_{ij}^{ab} \rangle\); substituted determinants (CISD) to the reference determinant; \(| \Phi_0 \rangle\). The CISD wavefunction has fallen out of favor; because truncated CI wavefunctions are not size-extensive, meaning; that their quality degrades for larger molecules. MP2 is a less; expensive alternative giving results similar to those of CISD for small; molecules, but the quality of MP2 does not degrade for larger molecules.; Coupled-cluster singles and doubles (CCSD) is another size-extensive; alternative; it is only slightly more costly computationally than CISD,; but it typically provides significantly more accurate results.; The CI code in PSI4 is described in detail in; [Sherrill:1999:CI]. For the reasons stated above, the CI code in; PSI4 is not optimized for CISD computations. Instead, emphasis; has been placed on de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/detci-1.html:1197,simpl,simplest,1197,psi4manual/1.2.1/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/detci-1.html,6,['simpl'],['simplest']
Usability,"; Fully-featured electronic structure programs are large and complex. However,; the PSI4 ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of PSI4 were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user’s perspective, programming was; still relatively difficult because it required modifications to be made in C++; code.; Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; NumPy provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html:1441,simpl,simpler,1441,psi4manual/1.4.0/prog_ways_to_add-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html,9,['simpl'],['simpler']
Usability,"; dft_spherical_points 590 # Often needed; dft_radial_points 99 # Often needed; dft_radial_scheme treutler # Rarely needed; dft_nuclear_scheme treutler # Rarely needed; dft_basis_tolerance 1.0E-11 # Can speed things up, but benchmark the error; }. energy('b3lyp'). ERI Algorithms¶; The ERI algorithms for the Coulomb and hybrid exchange are identical to those; listed above for Hartree-Fock. However, for LRC functionals, the long-range; exchange contributions to the Kohn-Sham matrix have only been implemented in the; DF and DIRECT algorithms. The use of DF is highly recommended for KS-DFT, as the; errors incurred by the density fitting approximation (in a proper -JKFIT; auxiliary basis) are orders of magnitude smaller than the accuracy of any known; functional. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; memory 512 MB. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # IP fitting must be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; dft_functional wb97; }. # Arguments are molecule object, minimum omega, maximum omega; ip_fitting(h2o, 0.4, 2.0). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of , though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; . The procedure can also be assisted by providing a tighter guess; for the bounds of . This small test case has a tuned; of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized ; between 0.1 and 0.5. Fractional ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/dft-1.html:18558,simpl,simply,18558,psi4manual/4.0b2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/dft-1.html,4,['simpl'],['simply']
Usability,"; difference between -electron and -electron total; energies), within the LRC functional ansatz. This guarantees the asymptotics of; the exchange potential,. Note that LRC functionals with default only capture the; dependence,. hybrid functionals only capture part of the dependence,. and local functionals decay exponentially, resulting in completely incorrect; asymptotics,. IP-tuned LRC functionals effectively pin the chemical potential at ; electrons to the correct value determined by the ionization potential. This; often cleans up the MSIE problem for a surprisingly large number of high-lying; occupied orbitals, as determined by fractional particle curves. Other gap; fitting techniques involving the electron affinity or band gap are sometimes; also used. IP-fitting is found to be particularly critical for the qualitative; determination of excited state ordering in many low band-gap systems.; For dispersion-bound complexes, a very simple additive empirical dispersion; potential, based on a damped Lennard-Jones potential can often produce; remarkably accurate results with KS-DFT. This approach was championed by Grimme,; whose “-D2” approach is a de facto industry standard. The more modern “-D3”; approach is gaining popularity, and may supersede -D2 in the next few years. Minimal Input¶; Minimal input for a KS-DFT computation is a molecule block, basis set; option, and a call to energy('b3lyp') (or other valid functional name):; molecule {; He; }. set basis sto-3g. energy('b3lyp'). This will run a B3LYP Restricted Kohn-Sham (RKS) on neutral singlet Helium in; spatial symmetry with a minimal STO-3G basis, 1.0E-8 energy; and density convergence criteria, a PK ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more information on; any of these options, see the relevant section below, or in the Hartree-Fock; section above. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of KS-DFT, including:. Restricted Koh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/dft-1.html:8223,simpl,simple,8223,psi4manual/4.0b2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/dft-1.html,8,['simpl'],['simple']
Usability,"; difference between -electron and -electron total; energies), within the LRC functional ansatz. This guarantees the asymptotics of; the exchange potential,. Note that LRC functionals with default only capture the; dependence,. hybrid functionals only capture part of the dependence,. and local functionals decay exponentially, resulting in completely incorrect; asymptotics,. IP-tuned LRC functionals effectively pin the chemical potential at ; electrons to the correct value determined by the ionization potential. This; often cleans up the MSIE problem for a surprisingly large number of high-lying; occupied orbitals, as determined by fractional particle curves. Other gap; fitting techniques involving the electron affinity or band gap are sometimes; also used. IP-fitting is found to be particularly critical for the qualitative; determination of excited state ordering in many low band-gap systems.; For dispersion-bound complexes, a very simple additive empirical dispersion; potential, based on a damped Lennard-Jones potential can often produce; remarkably accurate results with KS-DFT. This approach was championed by Grimme,; whose “-D2” approach is a de facto industry standard. The more modern “-D3”; approach is gaining popularity, and may supersede -D2 in the next few years. Minimal Input¶; Minimal input for a KS-DFT computation is a molecule block, basis set; option, and a call to energy('b3lyp') (or other valid functional name):; molecule {; He; }. set basis sto-3g. energy('b3lyp'). This will run a B3LYP Restricted Kohn-Sham (RKS) on neutral singlet Helium in; spatial symmetry with a minimal STO-3G basis, 1.0E-8 energy; and density convergence criteria, a PK ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more information on; any of these options, see the relevant section below, or in the Hartree-Fock; section above. Spin/Symmetry Treatment¶; Psi4 implements the most popular spin specializations of KS-DFT, including:. Restricted Koh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:8333,simpl,simple,8333,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,2,['simpl'],['simple']
Usability,"; pass; else:; break. return modobj. _modules = [; # Psi4 Modules; ""CCENERGY"",; ""CCEOM"",; ""CCDENSITY"",; ""CCLAMBDA"",; ""CCHBAR"",; ""CCRESPONSE"",; ""CCTRANSORT"",; ""CCTRIPLES"",; ""CPHF"",; ""DCT"",; ""DETCI"",; ""DFEP2"",; ""DFMP2"",; ""DFOCC"",; ""DLPNO"",; ""DMRG"",; ""EFP"",; ""FINDIF"",; ""FISAPT"",; ""FNOCC"",; ""GDMA"",; ""MCSCF"",; ""MINTS"",; ""MRCC"",; ""OCC"",; ""OPTKING"",; ""PCM"",; ""PE"",; ""PSIMRCC"",; ""RESPONSE"",; ""SAPT"",; ""SCF"",; ""THERMO"",; # External Modules; ""CFOUR"",; ]. [docs]@contextmanager; def hold_options_state() -> Iterator[None]:; """"""Return a context manager that will collect the current state of; ``Process:environment.options`` on entry to the with-statement and clear; and restore the collected keywords state when exiting the with-statement. """"""; pofm = prepare_options_for_modules(; changedOnly=True, commandsInsteadDict=False, globalsOnly=False, stateInsteadMediated=True; ); yield; _reset_pe_options(pofm). def _reset_pe_options(pofm: Dict):; """"""Acts on ``Process::environment.options`` to clear it, then set it to; state encoded in `pofm`. Parameters; ----------; pofm; Result of :py:func:`prepare_options_for_modules` with; ``changedOnly=True``, ``commandsInsteadDict=False``, and; ``stateInsteadMediated=True``. """"""; core.clean_options(). for go, dgo in pofm['GLOBALS'].items():; if dgo['has_changed']:; core.set_global_option(go, dgo['value']). for module in _modules:; for lo, dlo in pofm[module].items():; if dlo['has_changed']:; core.set_local_option(module, lo, dlo['value']). ## this is a more defensive version if defaults may have changed; # for go, dgo in pofm['GLOBALS'].items():; # core.set_global_option(go, dgo['value']); # if not dgo['has_changed']:; # core.revoke_global_option_changed(go); # for module in _modules:; # for lo, dlo in pofm[module].items():; # core.set_local_option(module, lo, dlo['value']); # if not dlo['has_changed']:; # core.revoke_local_option_changed(module, lo). [docs]def prepare_options_for_modules(; changedOnly: bool = False,; commandsInsteadDict: bool = False,; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html:10075,clear,clear,10075,psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,1,['clear'],['clear']
Usability,"; scf_type df; dft_spherical_points 590 # Often needed; dft_radial_points 99 # Often needed; dft_radial_scheme treutler # Rarely needed; dft_nuclear_scheme treutler # Rarely needed; dft_basis_tolerance 1.0E-11 # Can speed things up, but benchmark the error; }. energy('b3lyp'). ERI Algorithms¶; The ERI algorithms for the Coulomb and hybrid exchange are identical to; those for Hartree–Fock. However, for LRC functionals, the long-range; exchange contributions to the Kohn–Sham matrix have only been implemented in the; DF and DIRECT algorithms. The use of DF is highly recommended for KS-DFT, as the; errors incurred by the density fitting approximation (in a proper -JKFIT; auxiliary basis) are orders of magnitude smaller than the accuracy of any known; functional. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18memory 512 MB. molecule h2o {; 0 1 # must be neutral; O; H 1 1.0; H 1 1.0 2 104.5; # IP fitting runs in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; }. # Optional arguments are minimum omega, maximum omega, molecule object; omega = ip_fitting('wb97', 0.4, 2.0, molecule=h2o). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of 0.4 and 2.0. Lar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dft-1.html:22655,simpl,simply,22655,psi4manual/1.3.2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dft-1.html,2,['simpl'],['simply']
Usability,"; scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # if we're doing MBIS; if 'MBIS_VOLUME_RATIOS' in props:; p4util.free_atom_volumes(scf_wfn). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(""SCF"", ""MOLDEN_WRITE""):; filename = core.get_writer_file_prefix(scf_molecule.name()) + "".molden""; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). occa = scf_wfn.occupation_a(); occb = scf_wfn.occupation_a(). mw = core.MoldenWriter(scf_wfn); mw.write(filename, scf_wfn.Ca(), scf_wfn.Cb(), scf_wfn.epsilon_a(),; scf_wfn.epsilon_b(), scf_wfn.occupation_a(),; scf_wfn.occupation_b(), dovirt). # Write checkpoint file (orbitals and basis); Can be disabled, e.g., for findif displacements; if write_checkpoint_file and isinstance(_chkfile, str):; filename = kwargs['write_orbitals']; scf_wfn.to_file(filename); # core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif write_checkpoint_file:; filename = scf_wfn.get_scratch_filename(180); scf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:51376,simpl,simplefilter,51376,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['simpl'],['simplefilter']
Usability,"; thus, the PSI4-GauXC interface must be built; for sn-LinK to be used. Second, the GauXC sn-LinK interface is more; efficient than the PSI4 COSX code on multiple levels. For CPU execution, GauXC’s sn-LinK uses highly-optimized; kernels for the contraction of the analytic integrals, whereas PSI4’s COSX uses a less-optimized, more; general contraction kernel. Additionally, GauXC’s sn-LinK code supports execution on GPUs, allowing for; GPU-enabled construction of the Exchange matrix, while PSI4’s COSX does not. In general,; sn-LinK will provide better runtime performance for hitting a desired accuracy; threshold compared to PSI4’s COSX. Third, some low-level implementation details differ between the two.; For example, PSI4’s COSX uses a dual-grid scheme similar to that originally proposed by Neese,; converging the SCF on a small grid, then running a number of SCF iterations,; equal to the value set by the COSX_MAXITER_FINAL, on a larger grid.; In contrast, sn-LinK only uses a single-grid scheme, simply converging the SCF on one grid.; As another example, while the COSX grid defaults are selected to emphasize speed over accuracy,; the defaults for sn-LinK are selected to achieve higher accuracy (~0.1 kcal/mol error for interaction/conformer energies).; To control compilation and linking of the optional GauXC dependency required for the sn-LinK algorithm,; here are the list of compile-time options provided. ENABLE_gauxc: Compile Psi4 with support for GauXC.; gauxc_DIR: Location of the external GauXC install to compile Psi4 with, if using an external GauXC instance.; gauxc_ENABLE_GPU: Enable GPU support for the Psi4-GauXC interface class. When building GauXC internally within Psi4, this keyword controls whether to enable GPU support on the internally-built GauXC instance. When using an external GauXC build, this keyword must align with the GPU capabilities of the external GauXC install. To control the sn-LinK algorithm, here are the list of options provided. SNLINK_RADIAL",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/scf.html:42433,simpl,simply,42433,psi4manual/master/scf.html,https://psicode.org,https://psicode.org/psi4manual/master/scf.html,1,['simpl'],['simply']
Usability,"; }. energy('b3lyp'). ERI Algorithms¶; The ERI algorithms for the Coulomb and hybrid exchange are identical to those; listed above for Hartree-Fock. However, for LRC functionals, the long-range; exchange contributions to the Kohn-Sham matrix have only been implemented in the; DF and DIRECT algorithms. The use of DF is highly recommended for KS-DFT, as the; errors incurred by the density fitting approximation (in a proper -JKFIT; auxiliary basis) are orders of magnitude smaller than the accuracy of any known; functional.; Note: gradients with LRC functionals and DF integrals technology are not; currently enabled. We hope to have a patch for this deficit soon. Please let us; know if you have a strong need for this capability, and we will move the; priority up. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; memory 512 MB. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # IP fitting must be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; dft_functional wb97; }. # Arguments are molecule object, minimum omega, maximum omega; ip_fitting(h2o, 0.4, 2.0). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of , though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; . The procedure can also be assisted by providing a tighter guess; for the bounds of . This small test case has a tuned; of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized ; between 0.1 and 0.5. Fractional ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dft-1.html:19084,simpl,simply,19084,psi4manual/4.0b4/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dft-1.html,4,['simpl'],['simply']
Usability,"; }. energy('b3lyp'). ERI Algorithms¶; The ERI algorithms for the Coulomb and hybrid exchange are identical to those; listed above for Hartree-Fock. However, for LRC functionals, the long-range; exchange contributions to the Kohn-Sham matrix have only been implemented in the; DF and DIRECT algorithms. The use of DF is highly recommended for KS-DFT, as the; errors incurred by the density fitting approximation (in a proper -JKFIT; auxiliary basis) are orders of magnitude smaller than the accuracy of any known; functional.; Note: gradients with LRC functionals and DF integrals technology are not; currently enabled. We hope to have a patch for this deficit soon. Please let us; know if you have a strong need for this capability, and we will move the; priority up. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; memory 512 MB; from frac import *. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # IP fitting must be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; dft_functional wb97; }. # Arguments are molecule object, minimum omega, maximum omega; ip_fitting(h2o, 0.4, 2.0). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of , though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; . The procedure can also be assisted by providing a tighter guess; for the bounds of . This small test case has a tuned; of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized ; between 0.1 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:19169,simpl,simply,19169,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,2,['simpl'],['simply']
Usability,"= H) (0-indexed); >>> print H2OH2O.symbol(4); H. symmetrize()[source]¶; NYI Force the molecule to have the symmetry specified in pg.; This is to handle noise coming in from optking. symmetry_frame(tol=1e-08)[source]¶; Determine symmetry reference frame. If noreorient is not set,; this is the rotation matrix applied to the geometry in update_geometry.; >>> print H2OH2O.symmetry_frame(); [[1.0, -0.0, 0.0], [0.0, 1.0, 0.0], [0.0, -0.0, 1.0]]. symmetry_from_input()[source]¶; Returns the symmetry specified in the input.; >>> print H2OH2O.symmetry_from_input(); C1. translate(r)[source]¶; Translates molecule by r.; >>> H2OH2O.translate([1.0, 1.0, 0.0]). unique(iuniq)[source]¶; NYI Returns the overall number of the iuniq’th unique atom. units()[source]¶; Gets the geometry units; >>> print H2OH2O.units(); Angstrom. update_geometry()[source]¶; Updates the geometry, by (re)interpreting the string used to; create the molecule, and the current values of the variables.; The atoms list is cleared, and then rebuilt by this routine.; This function must be called after first instantiation of Molecule.; >>> H2 = qcdb.Molecule(""H\nH 1 0.74\n""); >>> print H2.natom(); 0; >>> H2.update_geometry(); >>> print H2.natom(); 2. valid_atom_map(tol=0.01)[source]¶; NYI Check if current geometry fits current point group. x(atom)[source]¶; x position of atom (0-indexed) in Bohr; >>> print H2OH2O.x(4); 3.17549201425. xyz(atom, posn=None)[source]¶; Returns a Vector3 with x, y, z position of atom (0-indexed); in Bohr or coordinate at posn; >>> print H2OH2O.xyz(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. y(atom)[source]¶; y position of atom (0-indexed) in Bohr; >>> print H2OH2O.y(4); -0.706268134631. z(atom)[source]¶; z position of atom (0-indexed) in Bohr; >>> print H2OH2O.z(4); -1.43347254509. Module to facilitate quantum chemical computations on chemical; databases. Contains Molecule class and physical constants from psi4 suite.; File to. dictify_database_docstrings()[source]¶.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:57853,clear,cleared,57853,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,6,['clear'],['cleared']
Usability,"= psi4.MintsHelper(); mints.integrals(). psi4.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'). while True:; psi4.transqt2(); psi4.ccsort(); psi4.ccenergy(); psi4.print_out('Brueckner convergence check: %d\n' % psi4.get_variable('BRUECKNER CONVERGED')); if (psi4.get_variable('BRUECKNER CONVERGED') == True):; break. optstash.restore(). [docs]def run_bccd_t(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD(T) calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCTRIPLES', 'WFN']). psi4.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); psi4.set_local_option('CCSORT', 'WFN', 'BCCD_T'); psi4.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); psi4.set_local_option('CCTRIPLES', 'WFN', 'BCCD_T'); run_bccd(name, **kwargs); psi4.cctriples(). optstash.restore(). [docs]def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). run_scf(name, **kwargs). optstash.restore(). [docs]def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; oneel_properties = ['dipole', 'quadrupole']; twoel_properties = []; response_properties = ['polarizability', 'rotation', 'roa']; excited_properties = ['oscillator_strength', 'rotational_strength']. one = []; two = []; response = []; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs.pop('properties'); properties = p4util.drop_duplicates(properties). for prop in properties:; if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(pro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:28176,simpl,simple,28176,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['simpl'],['simple']
Usability,"==> od[i]=y'; # Setting a new item creates a new link which goes at the end of the linked; # list, and the inherited dictionary is updated with the new key/value pair.; if key not in self:; root = self.__root; last = root[0]; last[1] = root[0] = self.__map[key] = [last, root, key]; dict_setitem(self, key, value). def __delitem__(self, key, dict_delitem=dict.__delitem__):; 'od.__delitem__(y) <==> del od[y]'; # Deleting an existing item uses self.__map to find the link which is; # then removed by updating the links in the predecessor and successor nodes.; dict_delitem(self, key); link_prev, link_next, key = self.__map.pop(key); link_prev[1] = link_next; link_next[0] = link_prev. def __iter__(self):; 'od.__iter__() <==> iter(od)'; root = self.__root; curr = root[1]; while curr is not root:; yield curr[2]; curr = curr[1]. def __reversed__(self):; 'od.__reversed__() <==> reversed(od)'; root = self.__root; curr = root[0]; while curr is not root:; yield curr[2]; curr = curr[0]. [docs] def clear(self):; 'od.clear() -> None. Remove all items from od.'; try:; for node in self.__map.itervalues():; del node[:]; root = self.__root; root[:] = [root, root, None]; self.__map.clear(); except AttributeError:; pass; dict.clear(self). [docs] def popitem(self, last=True):; '''od.popitem() -> (k, v), return and remove a (key, value) pair.; Pairs are returned in LIFO order if last is true or FIFO order if false. '''; if not self:; raise KeyError('dictionary is empty'); root = self.__root; if last:; link = root[0]; link_prev = link[0]; link_prev[1] = root; root[0] = link_prev; else:; link = root[1]; link_next = link[1]; root[1] = link_next; link_next[0] = root; key = link[2]; del self.__map[key]; value = dict.pop(self, key); return key, value. # -- the following methods do not depend on the internal structure --. [docs] def keys(self):; 'od.keys() -> list of keys in od'; return list(self). [docs] def values(self):; 'od.values() -> list of values in od'; return [self[key] for key in self]. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:2857,clear,clear,2857,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,1,['clear'],['clear']
Usability,"> C, H4 = H) (0-indexed); >>> print H2OH2O.symbol(4); H. symmetrize()[source]¶; Force the molecule to have the symmetry specified in pg.; This is to handle noise coming in from optking. symmetry_frame(tol=1e-08)[source]¶; Determine symmetry reference frame. If noreorient is not set,; this is the rotation matrix applied to the geometry in update_geometry.; >>> print H2OH2O.symmetry_frame(); [[1.0, -0.0, 0.0], [0.0, 1.0, 0.0], [0.0, -0.0, 1.0]]. symmetry_from_input()[source]¶; Returns the symmetry specified in the input.; >>> print H2OH2O.symmetry_from_input(); C1. translate(r)[source]¶; Translates molecule by r.; >>> H2OH2O.translate([1.0, 1.0, 0.0]). unique(iuniq)[source]¶; Returns the overall number of the iuniq’th unique atom. units()[source]¶; Gets the geometry units; >>> print H2OH2O.units(); Angstrom. update_geometry()[source]¶; Updates the geometry, by (re)interpreting the string used to; create the molecule, and the current values of the variables.; The atoms list is cleared, and then rebuilt by this routine.; This function must be called after first instantiation of Molecule.; >>> H2 = qcdb.Molecule(""H\nH 1 0.74\n""); >>> print H2.natom(); 0; >>> H2.update_geometry(); >>> print H2.natom(); 2. valid_atom_map(tol=0.01)[source]¶; Check if current geometry fits current point group. x(atom)[source]¶; x position of atom (0-indexed) in Bohr; >>> print H2OH2O.x(4); 3.17549201425. xyz(atom, posn=None)[source]¶; Returns a Vector3 with x, y, z position of atom (0-indexed); in Bohr or coordinate at posn; >>> print H2OH2O.xyz(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. y(atom)[source]¶; y position of atom (0-indexed) in Bohr; >>> print H2OH2O.y(4); -0.706268134631. z(atom)[source]¶; z position of atom (0-indexed) in Bohr; >>> print H2OH2O.z(4); -1.43347254509. atom_present_in_geom(geom, b, tol=1e-08)[source]¶; Function used by set_full_point_group() to scan a given geometry; and determine if an atom is present at a given location. compute_atom_map(m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:93257,clear,cleared,93257,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['clear'],['cleared']
Usability,"APT2+(3), and SAPT2+3 energies for closed-shell systems; only. Publications resulting from the use of the higher-order SAPT code; should cite the following:; [Hohenstein:2010:014101].; For methods SAPT2+ and above, one can replace the many-body treatment of; dispersion by an improved method based on coupled-cluster doubles (CCD).; This approach tends to give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]).; As shown in [Parker:2014:094106], whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102], the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102].; To request CCD dispersion treatment in a SAPT computation, simply append; (ccd) to the name of the method, as in the following examples; 1; 2; 3energy('sapt2+(ccd)'); energy('sapt2+(3)(ccd)'); energy('sapt2+3(ccd)'). The \(\delta_{MP2}\) corrections can also be computed automatically; by appending dmp2 to the name of the method, with or without CCD dispersion; 1; 2; 3; 4; 5; 6energy('sapt2+dmp2'); energy('sapt2+(3)dmp2'); energy('sapt2+3dmp2'); energy('sapt2+(ccd)dmp2'); energy('sapt2+(3)(ccd)dmp2'); energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold \(3o^2v^2+v^2N_{aux}\) arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:19616,simpl,simply,19616,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,6,['simpl'],['simply']
Usability,"CF', 'SCF_TYPE'), ref_wfn). psi4.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); psi4.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; while True:; if (psi4.get_global_option(""RUN_CCTRANSORT"")):; psi4.cctransort(ref_wfn); else:; psi4.transqt2(ref_wfn); psi4.ccsort(). ref_wfn = psi4.ccenergy(ref_wfn); psi4.print_out('Brueckner convergence check: %s\n' % bool(psi4.get_variable('BRUECKNER CONVERGED'))); if (psi4.get_variable('BRUECKNER CONVERGED') == True):; break. if bcc_iter_cnt >= psi4.get_option('CCENERGY', 'BCCD_MAXITER'):; psi4.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); psi4.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if name == 'bccd(t)':; psi4.cctriples(ref_wfn). optstash.restore(); return ref_wfn. [docs]def run_dft_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DFT calculations. This is a simple alias to :py:func:`~proc.run_scf`; since DFT properties all handled through oeprop. """"""; optstash = proc_util.dft_set_reference_local(name). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). scf_wfn = run_scf(name, scf_do_dipole=False, *kwargs). # Run OEProp; oe = psi4.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(). optstash.restore(); return scf_wfn. [docs]def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). scf_wfn = run_scf(name, scf_do_dipole=False, **kwargs). # Run OEProp; oe = psi4.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(). optstash.restore(); re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:57876,simpl,simple,57876,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['simpl'],['simple']
Usability,"COND_ORDER, NMR, HYPERPOL, DYN_HYP, SHG, OPT_REC, VERDET; Default: OFF. CFOUR_PROP_INTEGRAL¶. Allows storage of property integrals computed in xvdint on internal files (e.g., MOINTS and GAMLAM, default choice INTERNAL, =0) or on external files (EXTERNAL, =1). Type: string; Possible Values: INTERNAL, EXTERNAL; Default: INTERNAL. CFOUR_QRHFGUES¶. If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_QRHF_GENERAL CFOUR_QRHF_ORBITAL and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge “difficult” SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calcualtion; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the CFOUR_REFERENCE keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. CFOUR_QRHF_GENERAL¶. The presence of this keyword specifies that a QRHF based CC calculation, or alternatively, an SCF calculation that uses the CFOUR_QRHFGUES option, is to be performed. Type: array; Default: No Default. CFOUR_QRHF_ORBITAL¶. By default, in QRHF calculations, electrons are removed from the highest occupied orbital in a symmetry block (symmetry block HOMO), while electrons are added to the lowest unoccupied orbital within a symmetry block (symmetry block LUMO). The purpose of the QRHF_ORBITAL keyword is to allow additional flexibility in choosing which orbitals will have their occupation numbers altered. The value of this keyword gives the offset with respect to the default orbital for the orbital which will be depopulated (or populated) in QRHF-CC calculations. For calculations involving more than one removal or addition of electrons, values are separated by commas and correspond to the CFOUR_Q",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:48688,simpl,simply,48688,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['simpl'],['simply']
Usability,"COND_ORDER, NMR, HYPERPOL, DYN_HYP, SHG, OPT_REC, VERDET; Default: OFF. CFOUR_PROP_INTEGRAL¶. Allows storage of property integrals computed in xvdint on internal files (e.g., MOINTS and GAMLAM, default choice INTERNAL, =0) or on external files (EXTERNAL, =1). Type: string; Possible Values: INTERNAL, EXTERNAL; Default: INTERNAL. CFOUR_QRHFGUES¶. If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_QRHF_GENERAL CFOUR_QRHF_ORBITAL and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge “difficult” SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calculation; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the CFOUR_REFERENCE keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. CFOUR_QRHF_GENERAL¶. The presence of this keyword specifies that a QRHF based CC calculation, or alternatively, an SCF calculation that uses the CFOUR_QRHFGUES option, is to be performed. Type: array; Default: No Default. CFOUR_QRHF_ORBITAL¶. By default, in QRHF calculations, electrons are removed from the highest occupied orbital in a symmetry block (symmetry block HOMO), while electrons are added to the lowest unoccupied orbital within a symmetry block (symmetry block LUMO). The purpose of the QRHF_ORBITAL keyword is to allow additional flexibility in choosing which orbitals will have their occupation numbers altered. The value of this keyword gives the offset with respect to the default orbital for the orbital which will be depopulated (or populated) in QRHF-CC calculations. For calculations involving more than one removal or addition of electrons, values are separated by commas and correspond to the CFOUR_Q",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:48677,simpl,simply,48677,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,15,['simpl'],['simply']
Usability,"DEVIATION' % (db_name), MADerror); PsiMod.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; PsiMod.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activate(user_molecule); user_molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", user_basis); PsiMod.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; PsiMod.revoke_global_option_changed('REFERENCE'); PsiMod.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy . [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:51327,simpl,simple,51327,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,1,['simpl'],['simple']
Usability,"DF_BASIS_SCF), the name by which the new basis can be; recalled (get_str(‘DF_BASIS_SCF’)), the fitting role if defaults need to; be computed (JKFIT), the. How for Programmers¶; To get a BasisSet object into your module, just call pyconstruct where; formerly you called construct. There are two flavors, one for orbital; basis sets and one for auxiliary basis sets. There’s no difference in the; BasisSet objects they return or even the code used to assemble them- the; two flavors are just for sane argument naming and to establish different; signatures for Boost binding. Orbital Basis¶; Give the function a Molecule object for which to build basis, a label for; the basis (generally, BASIS), and a hint for finding the basis. This last; argument gets used to find a python function by that name camoflaged; (that’s what basis {...} blocks in the input file get translated into); or failing that a string to find a gbs file defining the basis.; // simple; boost::shared_ptr<BasisSet> primary = BasisSet::pyconstruct_orbital(molecule,; ""BASIS"", ""CC-PVDZ"");. // self-contained; boost::shared_ptr<BasisSet> primary = BasisSet::pyconstruct_orbital(Process::environment.molecule(),; ""BASIS"", Process::environment.options.get_str(""BASIS""));. Auxiliary Basis¶; Give the function a Molecule object for which to build basis, a label for; the basis, a hint for finding the basis, a fitting role to apply if; defaults need to be generated, and a hint for finding the orbital basis to; build defaults against.; // simple; boost::shared_ptr<BasisSet> auxiliary = BasisSet::pyconstruct_auxiliary(molecule,; ""DF_BASIS_SCF"", """",; ""JKFIT"", ""CC-PVDZ"");. // self-contained and force Spherical; boost::shared_ptr<BasisSet> auxiliary = BasisSet::pyconstruct_auxiliary(Process::environment.molecule(),; ""DF_BASIS_SCF"", Process::environment.options.get_str(""DF_BASIS_SCF""),; ""JKFIT"", Process:environment.options.get_str(""BASIS""), 1);. Adding Basis Option to Code¶. Register new basis keyword with psi4/src/bin/psi4/read_opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/prog_basissets-1.html:2805,simpl,simple,2805,psi4manual/1.0.0/prog_basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/prog_basissets-1.html,2,['simpl'],['simple']
Usability,"Derror /= float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * constants.cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:28307,clear,clear,28307,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,10,['clear'],['clear']
Usability,"Dict[str, psi4.driver.task_base.BaseComputer]). Validators:. set_driver » driver; set_molecule » molecule. field driver: DriverEnum [Required]¶. Validated by:. set_driver. field findifrec: Dict[str, Any] = {}¶. field metameta: Dict[str, Any] = {}¶. field method: str [Required]¶. field molecule: Any = None¶. Validated by:. set_molecule. field task_list: Dict[str, BaseComputer] = {}¶. computer¶; alias of AtomicComputer. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶; Run each job in task list. Parameters:; client (qcportal.FractalClient | None) – . get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. undisplaced molecule; compute basis if simple, else dummy basis def2-svp; e/g/h member data; QCVariables; module. client (qcportal.FractalClient | None) – . Returns:. ret – Gradient or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. Return type:; float | Matrix | Tuple[float | Matrix, Wavefunction]. get_results(client=None)[source]¶; Return results as FiniteDifference-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None) – . Return type:; AtomicResult. plan()[source]¶. validator set_driver  »  driver[source]¶. validator set_molecule  »  molecule[source]¶. table of contents. Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Visualization of Normal Modes; Molden Interface Keywords; NORMAL_MODES_WRITE; WRITER_FILE_LABEL. psi4.driver.qcdb.vib Module; Functions. API; FiniteDifferenceComputer; FiniteDifferenceComputer.driver; FiniteDifferenceComputer.findifrec; FiniteDifferenceComputer.metameta; FiniteDifferenceComputer.method; FiniteDiffe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/freq.html:10223,simpl,simple,10223,psi4manual/1.8.x/freq.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/freq.html,2,['simpl'],['simple']
Usability,"D’ line to screen.; Used by util.compare_values() family when functions pass. xml2dict(filename=None)[source]¶; Read XML filename into nested OrderedDict-s. filename defaults to; active CSX file. array_to_matrix¶; classmethod(function) -> method; Convert a function to be a class method.; A class method receives the class as implicit first argument,; just like an instance method receives the instance.; To declare a class method, use this idiom:. class C:; def f(cls, arg1, arg2, ...): ...; f = classmethod(f). It can be called either on the class (e.g. C.f()) or on an instance; (e.g. C().f()). The instance is ignored except for its class.; If a class method is called for a derived class, the derived class; object is passed as the implied first argument.; Class methods are different than C++ or Java static methods.; If you want those, see the staticmethod builtin. to_array(matrix, copy=True, dense=False)[source]¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Module with utility functions used by several Python functions. all_casings(input_string)[source]¶; Function to return a generator of all lettercase permutations; of input_string. drop_duplicates(seq)[source]¶; Function that given an array seq, returns an array without any duplicate; entries. There is no guarantee of which duplicate entry is dropped. expand_psivars(pvdefs)[source]¶; Dictionary pvdefs has keys with names of PsiVariables to be; created and values with dictionary of two keys: ‘args’, the; PsiVariables that contribute to the key and ‘func’, a function (or; lambda) to combine them. This function builds those PsiVariables if; all the contributors are available. Helpful printing is available when; PRINT > 2. extract_sowreap_from_output(sowout, quantity, sownum, linkage, allvital=False, label='electronic energy')[source]¶; Function to examine file sowout from a sow/reap distributed job; for formatted line with electronic energy information about inde",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:138110,simpl,simply,138110,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['simpl'],['simply']
Usability,"EAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activate(user_molecule); user_molecule.update_geometry(); psi4.set_global_option(""BASIS"", user_basis); psi4.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; psi4.revoke_global_option_changed('REFERENCE'); psi4.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def complete_basis_set(name, **kwargs):; r""""""Function to define ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:51935,simpl,simple,51935,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['simpl'],['simple']
Usability,ERAGED TOTAL ENERGY. CI TOTAL ENERGY. CI_DIIS (MCSCF). CI_FILE_START (DETCI). CI_MAXITER (DETCI). ci_nat_orbs() (psi4.core.CIWavefunction method). CI_NUM_THREADS (DETCI). CI_TYPE (GLOBALS). CIBLKS_PRINT (DETCI). CIn CORRELATION ENERGY. CIn TOTAL ENERGY. CISD CORRELATION ENERGY. CISD DIPOLE. CISD DOUBLES ENERGY. CISD OPPOSITE-SPIN CORRELATION ENERGY. CISD QUADRUPOLE. CISD SAME-SPIN CORRELATION ENERGY. CISD SINGLES ENERGY. CISD TOTAL ENERGY. CISDT CORRELATION ENERGY. CISDT TOTAL ENERGY. CISDTQ CORRELATION ENERGY. CISDTQ TOTAL ENERGY. citation() (psi4.core.Dispersion method). (psi4.core.Functional method). (psi4.core.SuperFunctional method). CIVector (class in psi4.core). CIWavefunction (class in psi4.core). Ck() (psi4.core.SOMCSCF method). clean() (in module psi4.core). clean_options() (in module psi4.core). clean_timers() (in module psi4.core). clean_variables() (in module psi4.core). cleanup_ci() (psi4.core.CIWavefunction method). cleanup_dpd() (psi4.core.CIWavefunction method). clear() (psi4.core.BSVec method). (psi4.core.ExternalPotential method). (psi4.core.OEProp method). clear_all() (psi4.core.DFHelper method). clear_collocation_cache() (psi4.core.VBase method). clear_D_prev() (psi4.core.CompositeJK method). clear_external_cpscf_perturbations() (psi4.core.HF method). clear_external_potentials() (psi4.core.HF method). clear_spaces() (psi4.core.DFHelper method). clone() (psi4.core.IntVector method). (psi4.core.Matrix method). (psi4.core.Molecule method). (psi4.core.Vector method). close() (psi4.core.IO method). close_io_files() (psi4.core.CIVector method). close_outfile() (in module psi4.core). coef (psi4.core.SalcComponent attribute). coef() (psi4.core.GaussianShell method). coldim() (psi4.core.dpdbuf4 method). (psi4.core.dpdfile2 method). (psi4.core.Matrix method). COLLAPSE_SIZE (DETCI). COLLAPSE_WITH_LAST (CCEOM). COLLAPSE_WITH_LAST_CC3 (CCEOM). collocation. collocation_size() (psi4.core.MolecularGrid method). colors (psi4.driver.p4util.InPsight attribute). col,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/genindex.html:25912,clear,clear,25912,psi4manual/1.9.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/genindex.html,2,['clear'],['clear']
Usability,"EZZ. CIROOTnTOTALENERGY. CIS_AMPLITUDE_CUTOFF (CPHF). CISDCORRELATIONENERGY. CISDDIPOLEX. CISDDIPOLEY. CISDDIPOLEZ. CISDQUADRUPOLEXX. CISDQUADRUPOLEXY. CISDQUADRUPOLEXZ. CISDQUADRUPOLEYY. CISDQUADRUPOLEYZ. CISDQUADRUPOLEZZ. CISDTCORRELATIONENERGY. CISDTOTALENERGY. CISDTQCORRELATIONENERGY. CISDTQTOTALENERGY. CISDTTOTALENERGY. CISTATE-AVERAGEDCORRELATIONENERGY. CISTATE-AVERAGEDTOTALENERGY. citation() psi4.core.Dispersion method, [1], [2]. psi4.core.Functional method, [1], [2]. psi4.core.LibXCFunctional method, [1]. psi4.core.SuperFunctional method, [1], [2]. CITOTALENERGY. CIVector class in psi4.core, [1]. CIWavefunction class in psi4.core, [1]. Ck() psi4.core.DFSOMCSCF method, [1]. psi4.core.DiskSOMCSCF method, [1]. psi4.core.SOMCSCF method, [1], [2]. clean() in module psi4.core, [1]. clean_options() in module psi4.core, [1]. clean_variables() in module psi4.core, [1]. cleanup_ci() psi4.core.CIWavefunction method, [1], [2]. cleanup_dpd() psi4.core.CIWavefunction method, [1], [2]. clear() psi4.core.ExternalPotential method, [1], [2]. psi4.core.OEProp method, [1], [2]. clear_all() psi4.core.DFHelper method, [1], [2]. clear_collocation_cache() psi4.core.VBase method, [1], [2]. clear_external_potentials() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. clear_spaces() psi4.core.DFHelper method, [1], [2]. clone() psi4.core.Matrix method, [1], [2]. psi4.core.Molecule method, [1], [2]. close() psi4.core.IO method, [1], [2]. close_io_files() psi4.core.CIVector method, [1], [2]. close_outfile() in module psi4.core, [1]. coef psi4.core.SalcComponent attribute, [1], [2]. coef() psi4.core.GaussianShell method, [1], [2]. coldim() psi4.core.Matrix method, [1], [2]. COLLAPSE_SIZE (DETCI). COLLAPSE_WITH_LAST (CCEOM). collocation. collocation_size() psi4.core.DFTGrid method, [1]. psi4.core.MolecularGrid method, [1], [2]. cols() psi4.core.Matrix method, [1], [2]. com_fixed() psi4.core.Molecule ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:28864,clear,clear,28864,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['clear'],['clear']
Usability,"HF). CIS_OPDM_STATES (CPHF). CIS_TOPDM_STATES (CPHF). CISDCORRELATIONENERGY. CISDDIPOLEX. CISDDIPOLEY. CISDDIPOLEZ. CISDQUADRUPOLEXX. CISDQUADRUPOLEXY. CISDQUADRUPOLEXZ. CISDQUADRUPOLEYY. CISDQUADRUPOLEYZ. CISDQUADRUPOLEZZ. CISDTCORRELATIONENERGY. CISDTOTALENERGY. CISDTQCORRELATIONENERGY. CISDTQTOTALENERGY. CISDTTOTALENERGY. CISTATE-AVERAGEDCORRELATIONENERGY. CISTATE-AVERAGEDTOTALENERGY. citation() psi4.core.Dispersion method, [1], [2]. psi4.core.Functional method, [1], [2]. psi4.core.LibXCFunctional method, [1]. psi4.core.SuperFunctional method, [1], [2]. CITOTALENERGY. CIVector class in psi4.core, [1]. CIWavefunction class in psi4.core, [1]. Ck() psi4.core.DFSOMCSCF method, [1]. psi4.core.DiskSOMCSCF method, [1]. psi4.core.SOMCSCF method, [1], [2]. clean() in module psi4.core, [1]. clean_options() in module psi4.core, [1]. clean_variables() in module psi4.core, [1]. cleanup_ci() psi4.core.CIWavefunction method, [1], [2]. cleanup_dpd() psi4.core.CIWavefunction method, [1], [2]. clear() psi4.core.ExternalPotential method, [1], [2]. psi4.core.OEProp method, [1], [2]. clear_all() psi4.core.DFHelper method, [1], [2]. clear_spaces() psi4.core.DFHelper method, [1], [2]. clone() psi4.core.Matrix method, [1], [2]. psi4.core.Molecule method, [1], [2]. close() psi4.core.IO method, [1], [2]. close_io_files() psi4.core.CIVector method, [1], [2]. close_outfile() in module psi4.core, [1]. coef() psi4.core.GaussianShell method, [1], [2]. coldim() psi4.core.Matrix method, [1], [2]. COLLAPSE_SIZE (DETCI). COLLAPSE_WITH_LAST (CCEOM). collocation. cols() psi4.core.Matrix method, [1], [2]. com_fixed() psi4.core.Molecule method, [1], [2]. compare_arrays() in module psi4.driver. compare_csx() in module psi4.driver. compare_cubes() in module psi4.driver. compare_fcidumps() in module psi4.driver. compare_integers() in module psi4.driver. compare_matrices() in module psi4.driver. compare_strings() in module psi4.driver. compare_values() in module psi4.driver. compare_vectors() in module ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:26807,clear,clear,26807,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['clear'],['clear']
Usability,"Hamiltonians¶; Code author: Prakash Verma and Francesco A. Evangelista; Section author: Prakash Verma, Wallace D. Derricotte, and Francesco A. Evangelista; The exact-two-component (X2C) approch is a convenient way to introduce scalar; relativistic effects in DFT and wave function-based methods.; Psi4 implements the spin-free one-electron version of X2C, which produces; a modified one-electron Hamiltonian :. that is a sum of a kinetic energy () and potential energy; () operator.; Our implementation is equivalent to the one reported by Cheng and Gauss [Cheng:084114].; X2C calculations require the use of special (alternatively fully uncontracted) basis sets designed for relativistic; calculations. Common choices include the Dunning Douglass–Kroll basis sets; (cc-pVXZ-DK, cc-pCVXZ-DK, cc-pwCVXZ-DK) and Roos’ ANO basis sets. Note; See also Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess for another relativistic Hamiltonian. A First Example¶; The following is a simple input that will perform a Hartree–Fock calculation; using the X2C Hamiltonian.; molecule {; H; F 1 0.92; }. set {; scf_type pk; basis cc-pvdz-decontract; relativistic x2c; }. energy('hf'). This computation yields the following result:; @RHF Final Energy: -100.10545426415609. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.7826788086396448; Two-Electron Energy = 45.5004909821901009; Total Energy = -100.1054542641560516. while a non-relativistic calculation yields the following energy:; @RHF Final Energy: -100.01041683847258. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.6714586298456027; Two-Electron Energy = 45.4843082290795309; Total Energy = -100.0104168384725796. Basis sets options¶; The X2C module in Psi4 supports different combinations of basis set.; By default, if the input file specifies only the basis keyword, then the X2C; module will solve the modified Dirac equation in an uncontracted basis and then; re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/relativistic-1.html:1187,simpl,simple,1187,psi4manual/1.0.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/relativistic-1.html,2,['simpl'],['simple']
Usability,"Hohenstein:2012:WIREs] with the jun-cc-pVDZ basis (this is the; usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and; without diffuse functions on heavy atoms) [Papajak:2011:10]. So,; we’ll use that as our standard basis set. The SAPT code is designed to; use density fitting techniques, because they introduce minimal errors; while providing much faster computations [Hohenstein:2010:184111]; [Hohenstein:2010:014101]. Since we’re using density fitting for the SAPT,; we might as well also use it for the Hartree–Fock computations that are; performed as part of the SAPT. We can specify that with; scf_type DF.; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, PSI4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that PSI4 correctly guesses that we want the jun-cc-pVDZ-JKFIT; auxiliary basis for the Hartree–Fock, and the jun-cc-pVDZ-RI basis set; for the SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons with freeze_core True. The SAPT; procedure is invoked with the simple call, energy('sapt0'). This; call knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in addition; to the total SAPT0 interaction energy. An explanation of the various; energy components can be found in the review by Jeziorski, Moszynski, and; Szalewicz [Jeziorski:1994:1887], and this is discussed in more detail; in the SAPT section later in this manual. For now, we’ll note that most of; the SAPT energy components are negative; this means those are attractive; contributions (the zero of energy in a SAPT computation is defined a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/tutorial-1.html:11782,simpl,simple,11782,psi4manual/4.0b4/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/tutorial-1.html,4,['simpl'],['simple']
Usability,"Hohenstein:2012:WIREs] with the jun-cc-pVDZ basis (this is the; usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and; without diffuse functions on heavy atoms) [Papajak:2011:10]. So,; we’ll use that as our standard basis set. The SAPT code is designed to; use density fitting techniques, because they introduce minimal errors; while providing much faster computations [Hohenstein:2010:184111]; [Hohenstein:2010:014101]. Since we’re using density fitting for the SAPT,; we might as well also use it for the Hartree–Fock computations that are; performed as part of the SAPT. We can specify that with; scf_type DF.; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT; auxiliary basis for the Hartree–Fock, and the jun-cc-pVDZ-RI basis set; for the SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons with freeze_core True. The SAPT; procedure is invoked with the simple call, energy('sapt0'). This; call knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in addition; to the total SAPT0 interaction energy. An explanation of the various; energy components can be found in the review by Jeziorski, Moszynski, and; Szalewicz [Jeziorski:1994:1887], and this is discussed in more detail; in the SAPT section later in this manual. For now, we’ll note that most of; the SAPT energy components are negative; this means those are attractive; contributions (the zero of energy in a SAPT computation is defined a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:12465,simpl,simple,12465,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['simpl'],['simple']
Usability,"I selects determinants for the; model space as those which have no more than \(n\) holes in the lowest set; of orbitals (called RAS I) and no more than \(m\) electrons in the highest; set of orbitals (called RAS III). An intermediate set of orbitals, if; present (RAS II), has no restrictions placed upon it. All determinants; satisfying these rules are included in the RAS CI.; The DETCI module is also very efficient at computing full configuration; interaction; wavefunctions, and it is used in this capacity in the complete-active-space; self-consistent-field (CASSCF) code. It can also perform approximate; CASSCF computations in which one uses RAS restrictions on the CI excitations,; rather than doing a full CI in the active space. This is called a; RASSCF. CASSCF and RASSCF computations are types of multi-configurational; self-consistent-field procedures, and are described in MCSCF: Multi-Configurational Self-Consistent-Field.; As mentioned above, the DETCI module is designed for challenging; chemical systems for which simple CISD is not suitable. Because; CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,; typically the DETCI code will be used in cases where the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. As mentioned above, codes; w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:3957,simpl,simple,3957,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,9,['simpl'],['simple']
Usability,"I4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Ap",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:16488,simpl,simply,16488,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['simpl'],['simply']
Usability,IROOTn->ROOTmDIPOLEX. CIROOTn->ROOTmDIPOLEY. CIROOTn->ROOTmDIPOLEZ. CIROOTn->ROOTmQUADRUPOLEXX. CIROOTn->ROOTmQUADRUPOLEXY. CIROOTn->ROOTmQUADRUPOLEXZ. CIROOTn->ROOTmQUADRUPOLEYY. CIROOTn->ROOTmQUADRUPOLEYZ. CIROOTn->ROOTmQUADRUPOLEZZ. CIROOTnCORRELATIONENERGY. CIROOTnDIPOLEX. CIROOTnDIPOLEY. CIROOTnDIPOLEZ. CIROOTnQUADRUPOLEXX. CIROOTnQUADRUPOLEXY. CIROOTnQUADRUPOLEXZ. CIROOTnQUADRUPOLEYY. CIROOTnQUADRUPOLEYZ. CIROOTnQUADRUPOLEZZ. CIROOTnTOTALENERGY. CIS_AD_STATES (CPHF). CIS_AMPLITUDE_CUTOFF (CPHF). CIS_DOPDM_STATES (CPHF). CIS_MEM_SAFETY_FACTOR (CPHF). CIS_NO_STATES (CPHF). CIS_OPDM_STATES (CPHF). CIS_TOPDM_STATES (CPHF). CISDCORRELATIONENERGY. CISDDIPOLEX. CISDDIPOLEY. CISDDIPOLEZ. CISDQUADRUPOLEXX. CISDQUADRUPOLEXY. CISDQUADRUPOLEXZ. CISDQUADRUPOLEYY. CISDQUADRUPOLEYZ. CISDQUADRUPOLEZZ. CISDTCORRELATIONENERGY. CISDTOTALENERGY. CISDTQCORRELATIONENERGY. CISDTQTOTALENERGY. CISDTTOTALENERGY. CISTATE-AVERAGEDCORRELATIONENERGY. CISTATE-AVERAGEDTOTALENERGY. CITOTALENERGY. clear() LibmintsMolecule method. clone() CartesianEntry method. LibmintsMolecule method. NumberValue method. VariableValue method. ZMatrixEntry method. COLLAPSE_SIZE (DETCI). COLLAPSE_WITH_LAST (CCEOM). compare_integers() in module p4util.util. compare_matrices() in module p4util.util. in module qcdb.psiutil. compare_strings() in module p4util.util. compare_values() in module p4util.util. in module qcdb.psiutil. compare_vectors() in module p4util.util. compilers. compiling. complete_basis_set(); . see cbs(); . complete_basis_set() in module wrappers. COMPLEX_TOLERANCE (CCEOM). compute() CartesianEntry method. NumberValue method. VariableValue method. ZMatrixEntry method. COMPUTE_MP4_TRIPLES (FNOCC). COMPUTE_TRIPLES (FNOCC). CONSECUTIVE_BACKSTEPS (OPTKING). contact. conv_dval() GetkwParser method. conv_ival() GetkwParser method. conv_lval() GetkwParser method. convert() in module wrappers. convert_area_scalar() in module pcmpreprocess. convert_length_array() in module pcmpreprocess. convert_length_scal,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/genindex.html:14088,clear,clear,14088,psi4manual/4.0b5/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/genindex.html,1,['clear'],['clear']
Usability,"IROOTn->ROOTmDIPOLEX. CIROOTn->ROOTmDIPOLEY. CIROOTn->ROOTmDIPOLEZ. CIROOTn->ROOTmQUADRUPOLEXX. CIROOTn->ROOTmQUADRUPOLEXY. CIROOTn->ROOTmQUADRUPOLEXZ. CIROOTn->ROOTmQUADRUPOLEYY. CIROOTn->ROOTmQUADRUPOLEYZ. CIROOTn->ROOTmQUADRUPOLEZZ. CIROOTnCORRELATIONENERGY. CIROOTnDIPOLEX. CIROOTnDIPOLEY. CIROOTnDIPOLEZ. CIROOTnQUADRUPOLEXX. CIROOTnQUADRUPOLEXY. CIROOTnQUADRUPOLEXZ. CIROOTnQUADRUPOLEYY. CIROOTnQUADRUPOLEYZ. CIROOTnQUADRUPOLEZZ. CIROOTnTOTALENERGY. CIS_AD_STATES (CPHF). CIS_AMPLITUDE_CUTOFF (CPHF). CIS_DOPDM_STATES (CPHF). CIS_MEM_SAFETY_FACTOR (CPHF). CIS_NO_STATES (CPHF). CIS_OPDM_STATES (CPHF). CIS_TOPDM_STATES (CPHF). CISDCORRELATIONENERGY. CISDDIPOLEX. CISDDIPOLEY. CISDDIPOLEZ. CISDQUADRUPOLEXX. CISDQUADRUPOLEXY. CISDQUADRUPOLEXZ. CISDQUADRUPOLEYY. CISDQUADRUPOLEYZ. CISDQUADRUPOLEZZ. CISDTCORRELATIONENERGY. CISDTOTALENERGY. CISDTQCORRELATIONENERGY. CISDTQTOTALENERGY. CISDTTOTALENERGY. CISTATE-AVERAGEDCORRELATIONENERGY. CISTATE-AVERAGEDTOTALENERGY. CITOTALENERGY. clear() LibmintsMolecule method. clone() CartesianEntry method. LibmintsMolecule method. NumberValue method. VariableValue method. ZMatrixEntry method. COLLAPSE_SIZE (DETCI). COLLAPSE_WITH_LAST (CCEOM). compare_integers() in module util. compare_matrices() in module qcdb.psiutil. in module util. compare_strings() in module util. compare_values() in module qcdb.psiutil. in module util. compare_vectors() in module util. compilers. compiling. complete_basis_set(); . see cbs(); . complete_basis_set() in module wrappers. COMPLEX_TOLERANCE (CCEOM). compute() CartesianEntry method. NumberValue method. VariableValue method. ZMatrixEntry method. COMPUTE_MP4_TRIPLES (FNOCC). COMPUTE_TRIPLES (FNOCC). CONSECUTIVE_BACKSTEPS (OPTKING). contact. convert() in module wrappers. CoordEntry class in qcdb.libmintscoordentry. CoordValue class in qcdb.libmintscoordentry. copy() Table method. copy_file_from_scratch() in module util. copy_file_to_scratch() in module util. CORE module, [1]. corl_xtpl_helgaker_2() in module wra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/genindex.html:13590,clear,clear,13590,psi4manual/4.0b4/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/genindex.html,1,['clear'],['clear']
Usability,"IROOTn->ROOTmDIPOLEX. CIROOTn->ROOTmDIPOLEY. CIROOTn->ROOTmDIPOLEZ. CIROOTn->ROOTmQUADRUPOLEXX. CIROOTn->ROOTmQUADRUPOLEXY. CIROOTn->ROOTmQUADRUPOLEXZ. CIROOTn->ROOTmQUADRUPOLEYY. CIROOTn->ROOTmQUADRUPOLEYZ. CIROOTn->ROOTmQUADRUPOLEZZ. CIROOTnCORRELATIONENERGY. CIROOTnDIPOLEX. CIROOTnDIPOLEY. CIROOTnDIPOLEZ. CIROOTnQUADRUPOLEXX. CIROOTnQUADRUPOLEXY. CIROOTnQUADRUPOLEXZ. CIROOTnQUADRUPOLEYY. CIROOTnQUADRUPOLEYZ. CIROOTnQUADRUPOLEZZ. CIROOTnTOTALENERGY. CIS_AD_STATES (CPHF). CIS_AMPLITUDE_CUTOFF (CPHF). CIS_DOPDM_STATES (CPHF). CIS_MEM_SAFETY_FACTOR (CPHF). CIS_NO_STATES (CPHF). CIS_OPDM_STATES (CPHF). CIS_TOPDM_STATES (CPHF). CISDCORRELATIONENERGY. CISDDIPOLEX. CISDDIPOLEY. CISDDIPOLEZ. CISDQUADRUPOLEXX. CISDQUADRUPOLEXY. CISDQUADRUPOLEXZ. CISDQUADRUPOLEYY. CISDQUADRUPOLEYZ. CISDQUADRUPOLEZZ. CISDTCORRELATIONENERGY. CISDTOTALENERGY. CISDTQCORRELATIONENERGY. CISDTQTOTALENERGY. CISDTTOTALENERGY. CISTATE-AVERAGEDCORRELATIONENERGY. CISTATE-AVERAGEDTOTALENERGY. CITOTALENERGY. clear() LibmintsMolecule method. clone() CartesianEntry method. LibmintsMolecule method. NumberValue method. VariableValue method. ZMatrixEntry method. COLLAPSE_SIZE (DETCI). COLLAPSE_WITH_LAST (CCEOM). compare_integers() in module util. compare_matrices() in module qcdb.psiutil. in module util. compare_strings() in module util. compare_values() in module qcdb.psiutil. in module util. compare_vectors() in module util. compilers. compiling. complete_basis_set(); . see cbs(); . complete_basis_set() in module wrappers. COMPLEX_TOLERANCE (CCEOM). compute() CartesianEntry method. NumberValue method. VariableValue method. ZMatrixEntry method. CONSECUTIVE_BACKSTEPS (OPTKING). contact. convert() in module wrappers. CoordEntry class in qcdb.libmintscoordentry. CoordValue class in qcdb.libmintscoordentry. copy() Table method. copy_file_from_scratch() in module util. copy_file_to_scratch() in module util. CORE module, [1]. corl_xtpl_helgaker_2() in module wrappers. CORR_ANSATZ (PSIMRCC). CORR_CCSD_T (PSIMRCC). C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/genindex.html:13341,clear,clear,13341,psi4manual/4.0b3/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/genindex.html,1,['clear'],['clear']
Usability,ITUDE_CUTOFF (CPHF). CISD CORRELATION ENERGY. CISD DIPOLE. CISD DIPOLE X. CISD DIPOLE Y. CISD DIPOLE Z. CISD DOUBLES ENERGY. CISD OPPOSITE-SPIN CORRELATION ENERGY. CISD QUADRUPOLE. CISD QUADRUPOLE XX. CISD QUADRUPOLE XY. CISD QUADRUPOLE XZ. CISD QUADRUPOLE YY. CISD QUADRUPOLE YZ. CISD QUADRUPOLE ZZ. CISD SAME-SPIN CORRELATION ENERGY. CISD SINGLES ENERGY. CISD TOTAL ENERGY. CISDT CORRELATION ENERGY. CISDT TOTAL ENERGY. CISDTQ CORRELATION ENERGY. CISDTQ TOTAL ENERGY. citation() psi4.core.Dispersion method. psi4.core.Functional method. psi4.core.LibXCFunctional method. psi4.core.SuperFunctional method. CIVector class in psi4.core. CIWavefunction class in psi4.core. Ck() psi4.core.DFSOMCSCF method. psi4.core.DiskSOMCSCF method. psi4.core.SOMCSCF method. clean() in module psi4.core. clean_options() in module psi4.core. clean_timers() in module psi4.core. clean_variables() in module psi4.core. cleanup_ci() psi4.core.CIWavefunction method. cleanup_dpd() psi4.core.CIWavefunction method. clear() psi4.core.BSVec method. psi4.core.ExternalPotential method. psi4.core.OEProp method. clear_all() psi4.core.DFHelper method. clear_collocation_cache() psi4.core.VBase method. clear_external_cpscf_perturbations() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. clear_external_potentials() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. clear_spaces() psi4.core.DFHelper method. clone() psi4.core.Matrix method. psi4.core.Molecule method. close() psi4.core.IO method. close_io_files() psi4.core.CIVector method. close_outfile() in module psi4.core. coef psi4.core.SalcComponent attribute. coef() psi4.core.GaussianShell method. coldim() psi4.core.Matrix method. COLLAPSE_SIZE (DETCI). COLLAPSE_WITH_LAST (CCEOM). COLLAPSE_WITH_LAST_CC3 (CCEOM). collocation. collocation_size() psi4.core.DFTGrid method. psi4.core.MolecularGrid method. cols() psi4.core.Matrix method. com_fix,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:28704,clear,clear,28704,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,2,['clear'],['clear']
Usability,"In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of the; molecule block, they are interpreted as the molecular charge and multiplicity; (), respectively. The symmetry can be specified by a line reading; symmetry symbol, where symbol is; the Schönflies symbol of the (Abelian) point group to use for the; computation; see Sec. Symmetry for more details. This need not be; specified, as the molecular symmetry is automatically detected by PSI4.; Certain computations require that the molecule is not reoriented; this can be; achieved by adding either no_reorient or noreorient. By default,; Ångström units are used; this is changed by adding a line that reads; units spec, where spec is one of ang,; angstrom, a.u., au, or bohr. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:6798,intuit,intuitive,6798,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,2,['intuit'],['intuitive']
Usability,"Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. Ways to Add Code: Psi4NumPy, Plugins, Full Integration¶. Easier and more rapid development¶; Fully-featured electronic structure programs are large and complex. However,; the PSI4 ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of PSI4 were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user’s perspective, programming was; still relatively difficult because it required modifications to be made in C++; code.; Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/prog_ways_to_add.html:1104,simpl,simplified,1104,psi4manual/1.8.x/prog_ways_to_add.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/prog_ways_to_add.html,1,['simpl'],['simplified']
Usability,"Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. Ways to Add Code: Psi4NumPy, Plugins, Full Integration¶. Easier and more rapid development¶; Fully-featured electronic structure programs are large and complex. However,; the PSI4 ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of PSI4 were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user’s perspective, programming was; still relatively difficult because it required modifications to be made in C++; code.; Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/prog_ways_to_add.html:1104,simpl,simplified,1104,psi4manual/1.9.x/prog_ways_to_add.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/prog_ways_to_add.html,1,['simpl'],['simplified']
Usability,"Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. delta3_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. delta4_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. delta5_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:8574,simpl,simple,8574,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,2,['simpl'],['simple']
Usability,LATION ENERGY. CI STATE-AVERAGED TOTAL ENERGY. CI TOTAL ENERGY. CI_DIIS (MCSCF). CI_FILE_START (DETCI). CI_MAXITER (DETCI). ci_nat_orbs() psi4.core.CIWavefunction method. CI_NUM_THREADS (DETCI). CI_TYPE (GLOBALS). CIBLKS_PRINT (DETCI). CIn CORRELATION ENERGY. CIn TOTAL ENERGY. CISD CORRELATION ENERGY. CISD DIPOLE. CISD DOUBLES ENERGY. CISD OPPOSITE-SPIN CORRELATION ENERGY. CISD QUADRUPOLE. CISD SAME-SPIN CORRELATION ENERGY. CISD SINGLES ENERGY. CISD TOTAL ENERGY. CISDT CORRELATION ENERGY. CISDT TOTAL ENERGY. CISDTQ CORRELATION ENERGY. CISDTQ TOTAL ENERGY. citation() psi4.core.Dispersion method. psi4.core.Functional method. psi4.core.SuperFunctional method. CIVector class in psi4.core. CIWavefunction class in psi4.core. Ck() psi4.core.SOMCSCF method. clean() in module psi4.core. clean_options() in module psi4.core. clean_timers() in module psi4.core. clean_variables() in module psi4.core. cleanup_ci() psi4.core.CIWavefunction method. cleanup_dpd() psi4.core.CIWavefunction method. clear() psi4.core.BSVec method. psi4.core.ExternalPotential method. psi4.core.OEProp method. clear_all() psi4.core.DFHelper method. clear_collocation_cache() psi4.core.VBase method. clear_D_prev() psi4.core.CompositeJK method. clear_external_cpscf_perturbations() psi4.core.HF method. clear_external_potentials() psi4.core.HF method. clear_spaces() psi4.core.DFHelper method. clone() psi4.core.IntVector method. psi4.core.Matrix method. psi4.core.Molecule method. psi4.core.Vector method. close() psi4.core.IO method. close_io_files() psi4.core.CIVector method. close_outfile() in module psi4.core. coef psi4.core.SalcComponent attribute. coef() psi4.core.GaussianShell method. coldim() psi4.core.dpdbuf4 method. psi4.core.dpdfile2 method. psi4.core.Matrix method. COLLAPSE_SIZE (DETCI). COLLAPSE_WITH_LAST (CCEOM). COLLAPSE_WITH_LAST_CC3 (CCEOM). collocation. collocation_size() psi4.core.MolecularGrid method. colors psi4.driver.p4util.InPsight attribute. cols() psi4.core.Matrix method. com_fixed() psi4,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/genindex.html:25392,clear,clear,25392,psi4manual/1.8.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/genindex.html,1,['clear'],['clear']
Usability,LATION ENERGY. CI STATE-AVERAGED TOTAL ENERGY. CI TOTAL ENERGY. CI_DIIS (MCSCF). CI_FILE_START (DETCI). CI_MAXITER (DETCI). ci_nat_orbs() psi4.core.CIWavefunction method. CI_NUM_THREADS (DETCI). CI_TYPE (GLOBALS). CIBLKS_PRINT (DETCI). CIn CORRELATION ENERGY. CIn TOTAL ENERGY. CISD CORRELATION ENERGY. CISD DIPOLE. CISD DOUBLES ENERGY. CISD OPPOSITE-SPIN CORRELATION ENERGY. CISD QUADRUPOLE. CISD SAME-SPIN CORRELATION ENERGY. CISD SINGLES ENERGY. CISD TOTAL ENERGY. CISDT CORRELATION ENERGY. CISDT TOTAL ENERGY. CISDTQ CORRELATION ENERGY. CISDTQ TOTAL ENERGY. citation() psi4.core.Dispersion method. psi4.core.Functional method. psi4.core.SuperFunctional method. CIVector class in psi4.core. CIWavefunction class in psi4.core. Ck() psi4.core.SOMCSCF method. clean() in module psi4.core. clean_options() in module psi4.core. clean_timers() in module psi4.core. clean_variables() in module psi4.core. cleanup_ci() psi4.core.CIWavefunction method. cleanup_dpd() psi4.core.CIWavefunction method. clear() psi4.core.BSVec method. psi4.core.ExternalPotential method. psi4.core.OEProp method. clear_all() psi4.core.DFHelper method. clear_collocation_cache() psi4.core.VBase method. clear_D_prev() psi4.core.DFJCOSK method. clear_external_cpscf_perturbations() psi4.core.HF method. clear_external_potentials() psi4.core.HF method. clear_spaces() psi4.core.DFHelper method. clone() psi4.core.IntVector method. psi4.core.Matrix method. psi4.core.Molecule method. psi4.core.Vector method. close() psi4.core.IO method. close_io_files() psi4.core.CIVector method. close_outfile() in module psi4.core. coef psi4.core.SalcComponent attribute. coef() psi4.core.GaussianShell method. coldim() psi4.core.dpdbuf4 method. psi4.core.dpdfile2 method. psi4.core.Matrix method. COLLAPSE_SIZE (DETCI). COLLAPSE_WITH_LAST (CCEOM). COLLAPSE_WITH_LAST_CC3 (CCEOM). collocation. collocation_size() psi4.core.MolecularGrid method. colors psi4.driver.p4util.InPsight attribute. cols() psi4.core.Matrix method. com_fixed() psi4.cor,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:25362,clear,clear,25362,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,1,['clear'],['clear']
Usability,"N ENERGY` ordering. Used for printing. Parameters; ----------; name_hint; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; ``dashcoeff[dashlevel][functional-without-dashlevel]`` or; ``dashcoeff_supplement[dashlevel][functional-with-dashlevel]``; can be overwritten via `param_tweaks`.; level_hint; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to one.; param_tweaks; Values for the same keys as `dashcoeff[dashlevel]['default']`; (and same order if list) used to override any or all values; initialized by `name_hint`. Extra parameters will error.; engine; Override which code computes dispersion. See above for allowed; values. Formerly (pre Nov 2022) only relevant for -D2, which can be computed by; libdisp or dftd3. Now (post Nov 2022) also relevant for -D3 variants,; which can be computed by dftd3 executable or simple-dftd3 Python module.; gcp_engine; Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp; Whether to request atomic pairwise analysis. """"""; def __init__(self, *, name_hint: str = None, level_hint: str = None, param_tweaks: Union[Dict, List] = None, engine: str = None, gcp_engine: str = None, save_pairwise_disp: bool = False):; from .dft import dashcoeff_supplement; self.dashcoeff_supplement = dashcoeff_supplement; self.save_pairwise_disp = save_pairwise_disp. resolved = qcng.programs.empirical_dispersion_resources.from_arrays(; name_hint=name_hint,; level_hint=level_hint,; param_tweaks=param_tweaks,; dashcoeff_supplement=self.dashcoeff_supplement); self.fctldash = resolved['fctldash']; self.dashlevel = resolved['dashlevel']; self.dashparams = resolved['dashparams']; self.description = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['description']; self.order",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:6061,simpl,simple-,6061,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,4,['simpl'],['simple-']
Usability,"P-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. A PSI4 Tutorial; Psithon Tutorial: Using PSI4 as an Executable. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/tutorial.html:23087,clear,clear,23087,psi4manual/1.7.x/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/tutorial.html,1,['clear'],['clear']
Usability,"PSI4 binary, gdma has already been installed alongside. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; gdma can be obtained through conda install gdma -c psi4.; Then enable it as a feature with ENABLE_gdma,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect gdma and activate dependent code. Previous bullet had details. To build PSI4 from source and use; gdma from conda without thinking, consult sec:condapsi4dev. To remove a conda installation, conda remove gdma. Source. If using PSI4 built from source and you want gdma built from; from source also,; enable it as a feature with ENABLE_gdma,; and let the build system fetch and build it and activate dependent code. Input¶; The distributed multipole analysis (DMA) technique, developed by Anthony J.; Stone and implemented by him into the GDMA package, is available in PSI4.; The current implementation simply embeds Stone’s GDMA code into the main; executable, and generates the appropriate input files automatically. The; program takes as input a data file, and a Gaussian formatted checkpoint (see; Section FCHK) file. The simplest usage of the GDMA code is; demonstrated below, along with a listing of the options supported; these; options correspond to the options described in the; GDMA manual.; If more advanced usage is desired, which is not is permitted by the options; listed below, the user may provide their own data file containing keywords to; control the GDMA code. Simply place the data file in the directory PSI4; is called from, and provide the file name as the datafile argument to the; gdma() routine. For example, if GDMA data file is called; control.dma, the GDMA code is called as follows:; 1; 2grad, wfn = gradient('mp2', return_wfn=True); gdma(wfn, datafile='control.dma'). An FCHK file will be generated for the GDMA code to read; this file will have; the prefix given by WRITER_FILE_LABEL (if set), or else by the name;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/gdma-1.html:1492,simpl,simply,1492,psi4manual/1.2.1/gdma-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/gdma-1.html,4,['simpl'],['simply']
Usability,"PSI4 for the computation of excited states,; see ADC capabilities of Psi4.; The methods are available via an interface to the adcc python module.; After a more general introduction, specific aspects of the implementation will be highlighted; in section Interface to adcc. ADC capabilities of Psi4¶. Method; References; Exc. Energies; Props; Supported values for kind keyword. ADC(1); RHF, UHF; yes; yes; any, singlet, triplet, spin_flip. ADC(2); RHF, UHF; yes; yes; any, singlet, triplet, spin_flip. ADC(2)-x; RHF, UHF; yes; yes; any, singlet, triplet, spin_flip. ADC(3); RHF, UHF; yes; yes | any, singlet, triplet, spin_flip. CVS-ADC(1); RHF, UHF; yes; yes | any, singlet, triplet. CVS-ADC(2); RHF, UHF; yes; yes; any, singlet, triplet. CVS-ADC(2)-x; RHF, UHF; yes; yes; any, singlet, triplet. CVS-ADC(3); RHF, UHF; yes; yes; any, singlet, triplet. The leftmost column of table ADC capabilities of Psi4 provides the supported ADC methods.; If only excitation energies are desired, one can simply pass one; of the listed method strings to the function energy().; For example, energy('adc(2)-x') will compute; excitation energies at ADC(2)-x level.; Properties such as oscillator strengths, transition or state dipole moments; are available by calling the function properties(); with appropriate arguments.; Most commonly users will want to compute at least oscillator strengths; along with the excitation energies,; resulting in a call like properties('adc(2)', properties=[""oscillator_strength""]). Running ADC calculations¶; Section author: Michael F. Herbst; Running an ADC calculation with PSI4 requires; the call to properties() as discussed above; as well as one or more mandatory keyword arguments.; The most important keyword argument is ROOTS_PER_IRREP,; which is an array with the number of excited states desired; for each irreducible representation. Most ADC methods; are only supported at C1 symmetry at the moment, such that; this option should in most cases be set to an array with a si",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/adc.html:4174,simpl,simply,4174,psi4manual/1.7.x/adc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/adc.html,4,['simpl'],['simply']
Usability,"PsiAPI mode, you write a pure; Python script with import psi4 at the top and commands are behind; the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the Psithon; mode. Note; Some PSI4 functions and keywords have aliases. For example,; frequency(), frequencies(), and freq() all work to; obtain vibrational frequencies. Basic Input File Structure¶; PSI4 reads input from a text file, which can be prepared in any standard; text editor. The default input file name is input.dat and the; default output file name is output.dat. So that you can give your; files meaningful names, these defaults can be changed by specifying; the input file name and output file name on the the command line.; The syntax is:; >>> psi4 input-name output-name. If you give an input name but no output name, then the output name will; be the same as the input name (replacing any “.in” or “.dat” extension by “.out”). Sample Input Files¶; Below, we will provide a few simple input files as examples. A large; number of sample input files, covering everything from single-point energies; using density-functional theory to response properties from coupled-cluster; theory, can be found in the psi4/samples directory. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 600 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). Note; The memory and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/tutorial-1.html:1513,simpl,simple,1513,psi4manual/1.3.2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/tutorial-1.html,11,['simpl'],['simple']
Usability,RT (DETCI). CI_MAXITER (DETCI). ci_nat_orbs() psi4.core.CIWavefunction method. CI_NUM_THREADS (DETCI). CI_TYPE (GLOBALS). CIBLKS_PRINT (DETCI). CIn CORRELATION ENERGY. CIn TOTAL ENERGY. CISD CORRELATION ENERGY. CISD DIPOLE. CISD DOUBLES ENERGY. CISD OPPOSITE-SPIN CORRELATION ENERGY. CISD QUADRUPOLE. CISD SAME-SPIN CORRELATION ENERGY. CISD SINGLES ENERGY. CISD TOTAL ENERGY. CISDT CORRELATION ENERGY. CISDT TOTAL ENERGY. CISDTQ CORRELATION ENERGY. CISDTQ TOTAL ENERGY. citation() psi4.core.Dispersion method. psi4.core.Functional method. psi4.core.LibXCFunctional method. psi4.core.SuperFunctional method. CIVector class in psi4.core. CIWavefunction class in psi4.core. Ck() psi4.core.DFSOMCSCF method. psi4.core.DiskSOMCSCF method. psi4.core.SOMCSCF method. clean() in module psi4.core. clean_options() in module psi4.core. clean_timers() in module psi4.core. clean_variables() in module psi4.core. cleanup_ci() psi4.core.CIWavefunction method. cleanup_dpd() psi4.core.CIWavefunction method. clear() psi4.core.BSVec method. psi4.core.ExternalPotential method. psi4.core.OEProp method. clear_all() psi4.core.DFHelper method. clear_collocation_cache() psi4.core.VBase method. clear_D_prev() psi4.core.DFJCOSK method. clear_external_cpscf_perturbations() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. clear_external_potentials() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. clear_spaces() psi4.core.DFHelper method. clone() psi4.core.Matrix method. psi4.core.Molecule method. psi4.core.Vector method. close() psi4.core.IO method. close_io_files() psi4.core.CIVector method. close_outfile() in module psi4.core. coef psi4.core.SalcComponent attribute. coef() psi4.core.GaussianShell method. coldim() psi4.core.dpdbuf4 method. psi4.core.dpdfile2 method. psi4.core.Matrix method. COLLAPSE_SIZE (DETCI). COLLAPSE_WITH_LAST (CCEOM). COLLAPSE_WITH_LAST_CC3 (CCEOM). collocatio,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/genindex.html:29973,clear,clear,29973,psi4manual/1.6.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/genindex.html,1,['clear'],['clear']
Usability,"SAFETY_FACTOR (CPHF). CIS_NO_STATES (CPHF). CIS_OPDM_STATES (CPHF). CIS_TOPDM_STATES (CPHF). CISDCORRELATIONENERGY. CISDDIPOLEX. CISDDIPOLEY. CISDDIPOLEZ. CISDQUADRUPOLEXX. CISDQUADRUPOLEXY. CISDQUADRUPOLEXZ. CISDQUADRUPOLEYY. CISDQUADRUPOLEYZ. CISDQUADRUPOLEZZ. CISDTCORRELATIONENERGY. CISDTOTALENERGY. CISDTQCORRELATIONENERGY. CISDTQTOTALENERGY. CISDTTOTALENERGY. CISTATE-AVERAGEDCORRELATIONENERGY. CISTATE-AVERAGEDTOTALENERGY. citation() psi4.core.Dispersion method, [1], [2]. psi4.core.Functional method, [1], [2]. psi4.core.SuperFunctional method, [1], [2]. CITOTALENERGY. CIVector class in psi4.core, [1]. CIWavefunction class in psi4.core, [1]. Ck() psi4.core.DFSOMCSCF method, [1]. psi4.core.DiskSOMCSCF method, [1]. psi4.core.SOMCSCF method, [1], [2]. clean() in module psi4.core, [1]. clean_options() in module psi4.core, [1]. clean_variables() in module psi4.core, [1]. cleanup_ci() psi4.core.CIWavefunction method, [1], [2]. cleanup_dpd() psi4.core.CIWavefunction method, [1], [2]. clear() psi4.core.ExternalPotential method, [1], [2]. psi4.core.OEProp method, [1], [2]. clone() psi4.core.Matrix method, [1], [2]. psi4.core.Molecule method, [1], [2]. close() psi4.core.IO method, [1], [2]. close_io_files() psi4.core.CIVector method, [1], [2]. close_outfile() in module psi4.core, [1]. coef() psi4.core.GaussianShell method, [1], [2]. coldim() psi4.core.Matrix method, [1], [2]. COLLAPSE_SIZE (DETCI). COLLAPSE_WITH_LAST (CCEOM). cols() psi4.core.Matrix method, [1], [2]. compare_arrays() in module psi4.driver. compare_csx() in module psi4.driver. compare_cubes() in module psi4.driver. compare_integers() in module psi4.driver. compare_matrices() in module psi4.driver. compare_strings() in module psi4.driver. compare_values() in module psi4.driver. compare_vectors() in module psi4.driver. compilers. compiling. complete_basis_set(). . see cbs(). COMPLEX_TOLERANCE (CCEOM). COMPUT_S2 (DFOCC). compute() psi4.core.Deriv method, [1], [2]. psi4.core.EFP method, [1], [2]. psi4.core.JK me",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:23076,clear,clear,23076,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['clear'],['clear']
Usability,"SD equations.; For a detailed discussion of the properties of various coupled-pair; methods, see [Wennmohs:2008:217].; What follows is a very basic description of the practical differences in; the equations that define each of the coupled-pair methods implemented in; PSI4. We begin with the CISD wave function. (3)¶\[| \Psi \rangle = | \Psi_0 \rangle + \sum_i^{occ} \sum_a^{vir} t_i^a | \Psi_i^a\rangle + \frac{1}{4}\sum_{ij}^{occ} \sum_{ab}^{vir} t_{ij}^{ab} | \Psi_{ij}^{ab}\rangle,\]; where we have chosen the intermediate normalization, \(\langle \Psi_0; | \Psi \rangle = 1\). The CISD correlation energy is given by. (4)¶\[E_c = \langle \Psi_0 | \hat{H} - E_0 | \Psi \rangle,\]; and the amplitudes can be determined by the solution to the coupled set of; equations:. (5)¶\[\begin{split}0 &= \langle \Psi_{ij}^{ab} | \hat{H} - E_0 - E_c | \Psi \rangle, \\; 0 &= \langle \Psi_{i}^{a} | \hat{H} - E_0 - E_c | \Psi \rangle.\end{split}\]; The CISD method is not size-extensive, but this problem can be overcome by; making very simple modifications to the amplitude equations. We replace; the correlation energy, \(E_c\), with generalized shifts for the; doubles and singles equations, \(\Delta_{ij}\) and \(\Delta_i\):. (6)¶\[\begin{split}0 &= \langle \Psi_{ij}^{ab} | \hat{H} - E_0 - \Delta_{ij} | \Psi \rangle, \\; 0 &= \langle \Psi_{i}^{a} | \hat{H} - E_0 - \Delta_i | \Psi \rangle.\end{split}\]; These shifts approximate the effects of triple and quadruple excitations.; The values for \(\Delta_{ij}\) and \(\Delta_i\) used in several; coupled-pair methods are given in Table CEPA Shifts. Note that these shifts are defined in a spin-free; formalism for closed-shell references only. method; \(\Delta_{ij}\); \(\Delta_i\). cisd; \(E_c\); \(E_c\). cepa(0); 0; 0. cepa(1); \(\frac{1}{2}\sum_k(\epsilon_{ik}+\epsilon_{jk})\); \(\sum_k \epsilon_{ik}\). cepa(3); \(-\epsilon_{ij}+\sum_k(\epsilon_{ik}+\epsilon_{jk})\); \(-\epsilon_{ii}+2\sum_k \epsilon_{ik}\). acpf; \(\frac{2}{N} E_c\); \(\frac{2}{N}",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:8508,simpl,simple,8508,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,15,['simpl'],['simple']
Usability,"T provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/sapt-1.html:1564,simpl,simplest,1564,psi4manual/4.0b2/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html,6,['simpl'],['simplest']
Usability,"T provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligible errors into the SAPT energy; (often less than 0.01 kcal/mol for small dimers) and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/sapt-1.html:1828,simpl,simplest,1828,psi4manual/4.0b5/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/sapt-1.html,2,['simpl'],['simplest']
Usability,"T provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, , the fluctuation potential of each monomer, , and the; interaction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of Psi4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); The and terms take into; account higher-order induction effects and are included in the definition; of SAPT terms. They are computed from the Hartree-Fock supermolecular interaction energy; and are only available in dimer-centered basis SAPT; computations, which is the default (see below for monomer-centered basis; computations). They are defined by:. (6). (7); Additionally, high-order coupling between induction and dispersion can be; extracted from the supermolecular MP2 interaction energy:. where is the correlation part of the supermolecular MP2; interaction energy. and also improve the; description of electrostatically dominated complexes. ; can be applied to SAPT2+ or SAPT2+(3) energies whereas ; should be applied to SAPT2+3 energies.; A thorough analysis of the performance of these truncations of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:2465,simpl,simplest,2465,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['simpl'],['simplest']
Usability,"TH={prefix}/bin:$PATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. Run PSI4 as executable.; 1; 2; 3; 4; 5; 6; 7; 8>>> cat sample.in; molecule {; He; }; energy('hf/cc-pvdz'); compare_values(-2.85518839, get_variable('current energy'), 5, 'SCF E'); >>> psi4 sample.in; SCF E.............................................................PASSED. or Run PSI4 as Python module.; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable after compilation using driver from source¶; When developing python driver code, it can be annoying to keep makeing to test the code. PSI4 can be run “inplace” through the; following procedure. To be clear, this is running compiled C++ from the; build directory and python from the source directory. This is an expert; option for development, and not all functionality will be available.; 1; 2; 3>>> cd {objdir}; >>> ln -s {top-level-psi4-dir}/{objdir}/stage/lib/psi4/core.cpython-{ext_will_vary}.so ../psi4/core.cpython-{ext_will_vary}.so; >>> python ../psi4/run_psi4.py --inplace input.dat. Why not to set PSIDATADIR¶; PSIDATADIR is an environment variable containing the location of the; text resource parts of the PSI4 codebase (e.g., basis sets,; databases, EFP fragments). It is for developer use only. In PSI4 1.1; and beyond, the program always knows where its resources are, and the; only reason to set this variable is to point to another location.; Previously in PSI4 1.0 and previous, only installed executables knew; the location, so it always needed to be explicitly set when run from the; compilation directory.; At runtime; >>> psi4 -p {top-level-psi4-dir}/psi4/share/psi4. Or in the shell; # csh, tcsh: add to shell or ~/.tcshrc ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:28099,clear,clear,28099,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['clear'],['clear']
Usability,"TH={prefix}/bin:$PATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. Run PSI4 as executable.; 1; 2; 3; 4; 5; 6; 7; 8>>> cat sample.in; molecule {; He; }; energy('hf/cc-pvdz'); compare_values(-2.85518839, get_variable('current energy'), 5, 'SCF E'); >>> psi4 sample.in; SCF E.............................................................PASSED. or Run PSI4 as Python module.; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable after compilation using driver from source¶; When developing python driver code, it can be annoying to keep makeing to test the code. PSI4 can be run “inplace” through the; following procedure. To be clear, this is running compiled C++ from the; build directory and python from the source directory. This is an expert; option for development, and not all functionality will be available.; 1; 2; 3>>> cd {objdir}; >>> ln -s {top-level-psi4-dir}/{objdir}/stage/{prefix}/lib/psi4/core.so ../psi4/core.so; >>> python ../psi4/run_psi4.py --inplace input.dat. How to set PSIDATADIR and why¶; PSIDATADIR is an environment variable containing the location of the; text resource parts of the PSI4 codebase (e.g., basis sets,; databases, EFP fragments). It is for developer use only. In PSI4 1.1; and beyond, the program always knows where its resources are, and the; only reason to set this variable is to point to another location.; Previously in PSI4 1.0 and previous, only installed executables knew; the location, so it always needed to be explicitly set when run from the; compilation directory.; At runtime; >>> psi4 -p {top-level-psi4-dir}/psi4/share/psi4. Or in the shell; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSIDATADIR {top-level-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:23400,clear,clear,23400,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['clear'],['clear']
Usability,"TH={prefix}/bin:$PATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. Run PSI4 as executable.; 1; 2; 3; 4; 5; 6; 7; 8>>> cat sample.in; molecule {; He; }; energy('hf/cc-pvdz'); compare_values(-2.85518839, get_variable('current energy'), 5, 'SCF E'); >>> psi4 sample.in; SCF E.............................................................PASSED. or Run PSI4 as Python module.; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable after compilation using driver from source¶; When developing python driver code, it can be annoying to keep makeing to test the code. PSI4 can be run “inplace” through the; following procedure. To be clear, this is running compiled C++ from the; build directory and python from the source directory. This is an expert; option for development, and not all functionality will be available.; 1; 2; 3>>> cd {objdir}; >>> ln -s {top-level-psi4-dir}/{objdir}/stage/{prefix}/lib/psi4/core.so ../psi4/core.so; >>> python ../psi4/run_psi4.py --inplace input.dat. Why not to set PSIDATADIR¶; PSIDATADIR is an environment variable containing the location of the; text resource parts of the PSI4 codebase (e.g., basis sets,; databases, EFP fragments). It is for developer use only. In PSI4 1.1; and beyond, the program always knows where its resources are, and the; only reason to set this variable is to point to another location.; Previously in PSI4 1.0 and previous, only installed executables knew; the location, so it always needed to be explicitly set when run from the; compilation directory.; At runtime; >>> psi4 -p {top-level-psi4-dir}/psi4/share/psi4. Or in the shell; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSIDATADIR {top-level-psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:26775,clear,clear,26775,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['clear'],['clear']
Usability,"What follows is a very basic description of the practical differences in; the equations that define each of the coupled-pair methods implemented in; Psi4. We begin with the CISD wave function. (3); where we have chosen the intermediate normalization, . The CISD correlation energy is given by. (4); and the amplitudes can be determined by the solution to the coupled set of; eqations:. (5); The CISD method is not size-extensive, but this problem can be overcome by; making very simple modifications to the amplitude equations. We replace; the correlation energy, , with generalized shifts for the; doubles and singles equations, and :. (6); These shifts approximate the effects of triple and quadruple excitations.; The values for and used in several; coupled-pair methods are given in Table CEPA Shifts. Note that these shifts are defined in a spin-free; formalism for closed-shell references only. method. cisd. cepa(0); 0; 0. cepa(1). cepa(3). acpf. aqcc. The pair correlation energy, , is simply a partial; sum of the correlation energy. In a spin-free formalism, the pair energy; is given by. (7); Methods whose shifts ( and ) do not; explicitly depend on orbitals or (CISD, CEPA(0), ACPF,; and AQCC) have solutions that render the energy stationary with respect; variations in the amplitudes. This convenient property allows density; matrices and 1-electron properties to be evaluated without any additional; effort. Note, however, that 1-electron properties are currently; unavailable when coupling these stationary CEPA-like methods with frozen; natural orbitals. Density-fitted coupled cluster¶; Density fitting (DF) [or the resolution of the identity (RI)] and Cholesky; decomposition (CD) techniques are popular in quantum chemistry to avoid; the computation and storage of the 4-index electron repulsion integral; (ERI) tensor and even to reduce the computational scaling of some terms.; DF/CD-CCSD(T) computations are available in Psi4, with or without the; use of FNOs, through the FNOC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/fnocc-1.html:7700,simpl,simply,7700,psi4manual/1.0.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/fnocc-1.html,2,['simpl'],['simply']
Usability,"Write the natural bond orbitals to a file. class psi4.core.NablaInt¶; Bases: psi4.core.OneBodyAOInt; Computes nabla integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; Compute integrals between basis functions in the given shell pair. origin¶; The origin about which the one body ints are being computed. class psi4.core.OEProp¶; Bases: psi4.core.Prop; docstring. Exvals(self: psi4.core.OEProp) → List[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; docstring. clear(self: psi4.core.OEProp) → None¶; docstring. compute(self: psi4.core.OEProp) → None¶; docstring. set_Da_ao(self: psi4.core.OEProp, Da: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_title(self: psi4.core.Prop, arg0: str) → None¶; docstring. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MAYER_INDICES', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']¶. class psi4.core.OneBodyAOInt¶; Bases: pybind11_builtins.pybind11_object; Basis class for all one-electron integrals. basis¶; The basis set on center one. basis1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:149480,clear,clear,149480,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['clear'],['clear']
Usability,"X_COMPILER=${CXX} \. # build with Intel; >>> cmake -S. -Bbuild \; -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gnu-prefix=${HOST}-"" \; -DCMAKE_CXX_FLAGS=""-gnu-prefix=${HOST}-"" \. # (B) tell CMake to tell the compiler which GCC to use; >>> GCC7=/path/to/miniconda/envs/gcc72; >>> cmake -S. -Bbuild \; -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \; -DCMAKE_CXX_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \; ...; # if Fortran active ...; -DCMAKE_Fortran_COMPILER=ifort \; -DCMAKE_Fortran_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \. # Configure and build. # To Run:; >>> export LD_LIBRARY_PATH=${GCC7}/lib:$LD_LIBRARY_PATH. How to configure a Psi4 build on Cray¶; Cray systems strongly prefer to build static libraries, but PSI4; needs to be dynamic to function as a Python module. Courtesy of @misha; at the forum and various supercomputer guides, building PSI4 on; Cray requires setting environment variables before running cmake.; CRAYPE_LINK_TYPE=dynamic CRAY_ADD_RPATH=yes cmake ... CRAYPE_LINK_TYPE¶; Set to allow PSI4 to build as shared library on Cray supercomputers. CRAY_ADD_RPATH¶; Set to true to allow PSI4 to build on Cray supercomputers. How to configure Fortran compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a Fortran compiler in unneeded for core; features but may be required for add-ons.; Downstream Dependencies. PSI4 (\(\Leftarrow\) optional) Fortran Compiler; dkh, gdma, PCMSolver \(\Leftarrow\) Fortran Compiler. CMake Variables. CMAKE_Fortran_COMPILER — CMake variable to specify name or full path to Fortran compiler.; CMAKE_Fortran_FLAGS — CMake variable to specify any additional custom compiler flags for Fortran source. Examples. Build with detected compiler from PATH. >>> cmake. Build with specific (Intel) compiler from PATH. >>> cmake -DCMAKE_Fortran_COMPILER=ifort. What Fortran compilers are approved",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_planning.html:40495,guid,guides,40495,psi4manual/master/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/master/build_planning.html,1,['guid'],['guides']
Usability,"X_COMPILER=${CXX} \. # build with Intel; >>> cmake -S. -Bbuild \; -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gnu-prefix=${HOST}-"" \; -DCMAKE_CXX_FLAGS=""-gnu-prefix=${HOST}-"" \. # (B) tell CMake to tell the compiler which GCC to use; >>> GCC7=/path/to/miniconda/envs/gcc72; >>> cmake -S. -Bbuild \; -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \; -DCMAKE_CXX_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \; ...; # if Fortran active ...; -DCMAKE_Fortran_COMPILER=ifort \; -DCMAKE_Fortran_FLAGS=""-gnu-prefix=${GCC7}/bin/x86_64-conda_cos6-linux-gnu-"" \. # Configure and build. # To Run:; >>> export LD_LIBRARY_PATH=${GCC7}/lib:$LD_LIBRARY_PATH. How to configure a Psi4 build on Cray¶; Cray systems strongly prefer to build static libraries, but PSI4; needs to be dynamic to function as a Python module. Courtesy of @misha; at the forum and various supercomputer guides, building PSI4 on; Cray requires setting environment variables before running cmake.; CRAYPE_LINK_TYPE=dynamic CRAY_ADD_RPATH=yes cmake ... CRAYPE_LINK_TYPE¶; Set to allow PSI4 to build as shared library on Cray supercomputers. CRAY_ADD_RPATH¶; Set to true to allow PSI4 to build on Cray supercomputers. How to configure Fortran compilers for building Psi4¶; Role and Dependencies. Role — In PSI4, a Fortran compiler in unneeded for core; features but may be required for add-ons.; Downstream Dependencies. PSI4 (\(\Leftarrow\) optional) Fortran Compiler; erd, dkh, gdma, PCMSolver \(\Leftarrow\) Fortran Compiler. CMake Variables. CMAKE_Fortran_COMPILER — CMake variable to specify name or full path to Fortran compiler.; CMAKE_Fortran_FLAGS — CMake variable to specify any additional custom compiler flags for Fortran source. Examples. Build with detected compiler from PATH. >>> cmake. Build with specific (Intel) compiler from PATH. >>> cmake -DCMAKE_Fortran_COMPILER=ifort. What Fortran compilers are app",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:39060,guid,guides,39060,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,8,['guid'],['guides']
Usability,Y. CIn TOTAL ENERGY. CISD CORRELATION ENERGY. CISD DIPOLE. CISD DIPOLE X. CISD DIPOLE Y. CISD DIPOLE Z. CISD DOUBLES ENERGY. CISD OPPOSITE-SPIN CORRELATION ENERGY. CISD QUADRUPOLE. CISD QUADRUPOLE XX. CISD QUADRUPOLE XY. CISD QUADRUPOLE XZ. CISD QUADRUPOLE YY. CISD QUADRUPOLE YZ. CISD QUADRUPOLE ZZ. CISD SAME-SPIN CORRELATION ENERGY. CISD SINGLES ENERGY. CISD TOTAL ENERGY. CISDT CORRELATION ENERGY. CISDT TOTAL ENERGY. CISDTQ CORRELATION ENERGY. CISDTQ TOTAL ENERGY. citation() psi4.core.Dispersion method. psi4.core.Functional method. psi4.core.LibXCFunctional method. psi4.core.SuperFunctional method. CIVector class in psi4.core. CIWavefunction class in psi4.core. Ck() psi4.core.DFSOMCSCF method. psi4.core.DiskSOMCSCF method. psi4.core.SOMCSCF method. clean() in module psi4.core. clean_options() in module psi4.core. clean_timers() in module psi4.core. clean_variables() in module psi4.core. cleanup_ci() psi4.core.CIWavefunction method. cleanup_dpd() psi4.core.CIWavefunction method. clear() psi4.core.BSVec method. psi4.core.ExternalPotential method. psi4.core.OEProp method. clear_all() psi4.core.DFHelper method. clear_collocation_cache() psi4.core.VBase method. clear_external_cpscf_perturbations() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. clear_external_potentials() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. clear_spaces() psi4.core.DFHelper method. clone() psi4.core.Matrix method. psi4.core.Molecule method. close() psi4.core.IO method. close_io_files() psi4.core.CIVector method. close_outfile() in module psi4.core. coef psi4.core.SalcComponent attribute. coef() psi4.core.GaussianShell method. coldim() psi4.core.Matrix method. COLLAPSE_SIZE (DETCI). COLLAPSE_WITH_LAST (CCEOM). COLLAPSE_WITH_LAST_CC3 (CCEOM). collocation. collocation_size() psi4.core.DFTGrid method. psi4.core.MolecularGrid method. cols() psi4.core.Matrix method. com_fix,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/genindex-1.html:28974,clear,clear,28974,psi4manual/1.5.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/genindex-1.html,2,['clear'],['clear']
Usability,"[Hohenstein:2012:WIREs] with the jun-cc-pVDZ basis (this is the; usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and; without diffuse functions on heavy atoms) [Papajak:2011:10]. So,; we’ll use that as our standard basis set. The SAPT code is designed to; use density fitting techniques, because they introduce minimal errors; whil providing much faster computations [Hohenstein:2010:184111]; [Hohenstein:2010:014101]. Since we’re using density fitting for the SAPT,; we might as well also use it for the Hartree–Fock computations that are; performed as part of the SAPT. We can specify that with; scf_type DF.; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, PSI4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that PSI4 correctly guesses that we want the jun-cc-pVDZ-JKFIT; auxiliary basis for the Hartree–Fock, and the jun-cc-pVDZ-RI basis set; for the SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons with freeze_core True. The SAPT; procedure is invoked with the simple call, energy('sapt0'). This; call knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in addition; to the total SAPT0 interaction energy. An explanation of the various; energy components can be found in the review by Jeziorski, Moszynski, and; Szalewicz [Jeziorski:1994:1887], and this is discussed in more detail; in the SAPT section later in this manual. For now, we’ll note that most of; the SAPT energy components are negative; this means those are attractive; contributions (the zero of energy in a SAPT computation is defined a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/tutorial-1.html:11376,simpl,simple,11376,psi4manual/4.0b3/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/tutorial-1.html,2,['simpl'],['simple']
Usability,"[Hohenstein:2012:WIREs] with the jun-cc-pVDZ basis (this is the; usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and; without diffuse functions on heavy atoms) [Papajak:2011:10]. So,; we’ll use that as our standard basis set. The SAPT code is designed to; use density fitting techniques, because they introduce minimal errors; whil providing much faster computations [Hohenstein:2010:184111]; [Hohenstein:2010:014101]. Since we’re using density fitting for the SAPT,; we might as well also use it for the Hartree–Fock computations that are; performed as part of the SAPT. We can specify that with; scf_type DF.; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, PSI4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that PSI4 correctly guesses that we want the jun-cc-pVDZ-JKFIT; auxiliary basis for the Hartree–Fock, and the jun-cc-pVDZ-RI basis set; for the SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons with freeze_core True. The SAPT; procedure is invoked with the simple call, energy('sapt0')}. This; call knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in addition; to the total SAPT0 interaction energy. An explanation of the various; energy components can be found in the review by Jeziorski, Moszynski, and; Szalewicz [Jeziorski:1994:1887], and this is discussed in more detail; in the SAPT section later in this manual. For now, we’ll note that most of; the SAPT energy components are negative; this means those are attractive; contributions (the zero of energy in a SAPT computation is defined ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:11349,simpl,simple,11349,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,2,['simpl'],['simple']
Usability,"[docs] def bits_to_full_name(bits):; """""". """"""; if bits == PointGroups['C1']:; return ""C1""; elif bits == PointGroups['Ci']:; return ""Ci""; elif bits == PointGroups['C2X']:; return ""C2(x)""; elif bits == PointGroups['C2Y']:; return ""C2(y)""; elif bits == PointGroups['C2Z']:; return ""C2(z)""; elif bits == PointGroups['CsZ']:; return ""Cs(Z)""; elif bits == PointGroups['CsY']:; return ""Cs(Y)""; elif bits == PointGroups['CsX']:; return ""Cs(X)""; elif bits == PointGroups['D2']:; return ""D2""; elif bits == PointGroups['C2vX']:; return ""C2v(X)""; elif bits == PointGroups['C2vY']:; return ""C2v(Y)""; elif bits == PointGroups['C2vZ']:; return ""C2v(Z)""; elif bits == PointGroups['C2hX']:; return ""C2h(X)""; elif bits == PointGroups['C2hY']:; return ""C2h(Y)""; elif bits == PointGroups['C2hZ']:; return ""C2h(Z)""; elif bits == PointGroups['D2h']:; return ""D2h""; else:; raise ValidationError(""Unrecognized point group bits: %d\n"" % (bits)). @staticmethod; [docs] def bits_to_basic_name(bits):; """"""From bit representation of point group, returns string of simple; (non-directional) Schoenflies symbol. """"""; if bits == PointGroups['C1']:; return ""c1""; elif bits == PointGroups['Ci']:; return ""ci""; elif bits in [PointGroups['C2X'], PointGroups['C2Y'], PointGroups['C2Z']]:; return ""c2""; elif bits in [PointGroups['CsZ'], PointGroups['CsY'], PointGroups['CsX']]:; return ""cs""; elif bits == PointGroups['D2']:; return ""d2""; elif bits in [PointGroups['C2vX'], PointGroups['C2vY'], PointGroups['C2vZ']]:; return ""c2v""; elif bits in [PointGroups['C2hX'], PointGroups['C2hY'], PointGroups['C2hZ']]:; return ""c2h""; elif bits == PointGroups['D2h']:; return ""d2h""; else:; raise ValidationError('Unrecognized point group bits: %d\n' % (bits)). @staticmethod; [docs] def full_name_to_bits(pg): # altered signature from (pg, bits):; """""". """"""; pgc = pg.capitalize(). if pgc == 'C1':; bits = PointGroups['C1']; elif pgc == 'Ci':; bits = PointGroups['Ci']; elif pgc == 'C2(x)' or pgc == 'C2x' or pgc == 'C2_x':; bits = PointGroups['C2X']",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:44099,simpl,simple,44099,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['simpl'],['simple']
Usability,"\lambda\sigma) + E_{\mathrm{xc}} [\rho_\alpha, \rho_\beta]\end{split}\]; Here, \(T\) is the noninteracting quasiparticle kinetic energy operator,; \(V\) is the nucleus-electron attraction potential, \(D^{\mathrm{T}}\); is the total electron density matrix, and \(E_{\mathrm{xc}} [\rho_\alpha,; \rho_\beta]\) is the (potentially nonlocal) exchange, correlation, and residual; kinetic energy functional. The residual kinetic energy term is usually quite; small, and is often ignored, hence \(E_{\mathrm{xc}}\) is often referred to; as simply the exchange-correlation functional (exchange and correlation, not; just exchange-type correlation).; In practice, the first few generations of KS-DFT functionals were chosen to be; local, meaning that the form of the exchange correlation energy is an integral; over all of space of a function depending only on local information in the; density, such as the density value or derivatives. The simplest variants are; Local Spin-Density Approximations (LSDA), which depend only on the spin density; \(\rho_\alpha\) or \(\rho_\beta\),. \[\rho_\sigma (\vec r_1) = D_{\mu\nu}^{\sigma} \phi_{\mu} (\vec r_1); \phi_\nu (\vec r_1)\]; The most popular variants are Generalized Gradient Approximation (GGA); functionals which use the norm of the density gradient; \(\gamma_{\alpha\alpha}\), \(\gamma_{\alpha\beta}\) or; \(\gamma_{\beta\beta}\) to build an inhomogeneity; parameter. \[\gamma_{\alpha\alpha} (\vec r_1) = \nabla \rho_{\alpha} (\vec r_1) \cdot \nabla; \rho_{\alpha} (\vec r_1)\]. \[\gamma_{\alpha\beta} (\vec r_1) = \nabla \rho_{\alpha} (\vec r_1) \cdot \nabla; \rho_{\beta} (\vec r_1)\]; where,. \[\nabla \rho_{\sigma} (\vec r_1) = 2 D_{\mu\nu}^{\sigma} \phi_{\mu}; (\vec r_1) \nabla \phi_{\nu} (\vec r_1)\]; GGA functionals are essentially the same cost as LSDA functionals and are often; considerably more accurate.; Another local variant which has gained some popularity (though perhaps not as; much as GGA functionals) is the meta approximation, in whi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:2978,simpl,simplest,2978,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,15,['simpl'],['simplest']
Usability,"\mathrm{x}}^{\mathrm{LRC}} (r) = -; \frac{1}{r},\]; hybrid functionals only capture part of the \(-1/r\) dependence,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{Hybrid}} (r) = -; \frac{\alpha}{r},\]; and local functionals decay exponentially, resulting in completely incorrect; asymptotics,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{Local}} (r) = 0\]; IP-tuned LRC functionals effectively pin the chemical potential at \(N\); electrons to the correct value determined by the ionization potential. This; often cleans up the MSIE problem for a surprisingly large number of high-lying; occupied orbitals, as determined by fractional particle curves. Other gap; fitting techniques involving the electron affinity or band gap are sometimes; also used. IP-fitting is found to be particularly critical for the qualitative; determination of excited state ordering in many low band-gap systems.; For dispersion-bound complexes, a very simple additive empirical dispersion; potential, based on a damped Lennard-Jones potential can often produce; remarkably accurate results with KS-DFT. This approach was championed by Grimme,; whose “-D2” and more modern “-D3” approaches are a de facto industry standards. Minimal Input¶; Minimal input for a KS-DFT computation is a molecule block, basis set; option, and a call to energy('b3lyp') (or other valid functional name):; 1; 2; 3; 4; 5; 6; 7molecule {; He; }. set basis sto-3g. energy('b3lyp'). This will run a B3LYP Restricted Kohn–Sham (RKS) on neutral singlet Helium in; \(D_{2h}\) spatial symmetry with a minimal STO-3G basis, 1.0E-6 energy; and density convergence criteria, a DF ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess (because single atom). For more information on; any of these options, see the relevant section below, or in the preceding; Hartree–Fock section. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of KS-DFT, including:. Restricted Kohn–Sham (RKS) [Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:12055,simpl,simple,12055,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,6,['simpl'],['simple']
Usability,"\mathrm{x}}^{\mathrm{LRC}} (r) = -; \frac{1}{r},\]; hybrid functionals only capture part of the \(-1/r\) dependence,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{Hybrid}} (r) = -; \frac{\alpha}{r},\]; and local functionals decay exponentially, resulting in completely incorrect; asymptotics,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{Local}} (r) = 0\]; IP-tuned LRC functionals effectively pin the chemical potential at \(N\); electrons to the correct value determined by the ionization potential. This; often cleans up the MSIE problem for a surprisingly large number of high-lying; occupied orbitals, as determined by fractional particle curves. Other gap; fitting techniques involving the electron affinity or band gap are sometimes; also used. IP-fitting is found to be particularly critical for the qualitative; determination of excited state ordering in many low band-gap systems.; For dispersion-bound complexes, a very simple additive empirical dispersion; potential, based on a damped Lennard-Jones potential can often produce; remarkably accurate results with KS-DFT. This approach was championed by Grimme,; whose “-D2” and more modern “-D3” approaches are a de facto industry standards. Minimal Input¶; Minimal input for a KS-DFT computation is a molecule block, basis set; option, and a call to energy('b3lyp') (or other valid functional name):; molecule {; He; }. set basis sto-3g. energy('b3lyp'). This will run a B3LYP Restricted Kohn–Sham (RKS) on neutral singlet Helium in; \(D_{2h}\) spatial symmetry with a minimal STO-3G basis, 1.0E-6 energy; and density convergence criteria, a DF ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess (because single atom). For more information on; any of these options, see the relevant section below, or in the preceding; Hartree–Fock section. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of KS-DFT, including:. Restricted Kohn–Sham (RKS) [Default]Appropriate onl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:12576,simpl,simple,12576,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,9,['simpl'],['simple']
Usability,"]¶; Flag the atom as either ghost or real. set_shell(bshash, key='BASIS')[source]¶; Set the hash for this atom; * @param key Keyword from input file, basis, ri_basis, etc.; * @param bshash hash string of one-atom BasisSet. shell(key='BASIS')[source]¶; Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. shells()[source]¶; Returns shells sets to atom map. symbol()[source]¶; The atomic symbol. class CoordValue(fixed=False, computed=False)[source]¶; An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. everything()[source]¶. fixed()[source]¶; Get whether the coordinate value is fixed or not. invalidate()[source]¶; Flag the current value as outdated. set_fixed(fixed)[source]¶; Set whether the coordinate value is fixed or not. class NumberValue(value, fixed=False)[source]¶; Specialization of CoordValue that is simply a number to be stored. clone()[source]¶; Returns new, independent NumberValue object. compute()[source]¶; Computes value of coordinate from member data. everything()[source]¶. rset(val)[source]¶; Resets value of coordinate if not fixed. type()[source]¶; Gets specialization type of CoordValue. variable_to_string(precision)[source]¶; Takes a CoordValue object, and returns a string for printing. class VariableValue(name, geometryVariables, negate=False, fixed=False)[source]¶; Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. clone()[source]¶; Returns new, independent VariableValue object. compute()[source]¶; Computes value of coordinate from member data. everything()[source]¶. name()[source]¶; Gets the name of the variable. negated()[source]¶; Gets whether the coordinate value is actually the negative of the variable value. rset(val)[source]¶; Resets value of coordinate if not fixed. typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:116809,simpl,simply,116809,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['simpl'],['simply']
Usability,"]¶; Returns the order of the group. p(x1, x2, i=None)[source]¶; Returns the element (x1, x2) of the i’th representation matrix.; Or Returns the character for the x1’th contribution to the x2’th; representation matrix. symbol()[source]¶; Returns the Mulliken symbol for the irrep. symbol_ns()[source]¶; Returns the Mulliken symbol for the irrep without special; characters. class PointGroup(*args)[source]¶; The PointGroup class is really a place holder for a CharacterTable.; It contains a string representation of the Schoenflies symbol of a; point group, a frame of reference for the symmetry operation; transformation matrices, and a point of origin. The origin is not; respected by the symmetry operations, so if you want to use a point; group with a nonzero origin, first translate all your coordinates to; the origin and then set the origin to zero. bits()[source]¶; Returns the bitwise representation of the point group. static bits_to_basic_name(bits)[source]¶; From bit representation of point group, returns string of simple; (non-directional) Schoenflies symbol. static bits_to_full_name(bits)[source]¶. char_table()[source]¶; Returns the CharacterTable for this point group. constructor_bits(bits)[source]¶; Using the bitwise representation constructor the point group; object. constructor_bits_origin(bits, origin)[source]¶; Using the bitwise representation constructor the point group; object. constructor_schoenflies(s)[source]¶; This constructor takes a string containing the Schoenflies; symbol of the point group as its only argument. constructor_schoenflies_origin(s, origin)[source]¶; Like the above, but this constructor also takes a point of; origin as an argument. static full_name_to_bits(pg)[source]¶. origin()[source]¶; Returns the origin of the symmetry frame. set_symbol(sym)[source]¶; Sets (or resets) the Schoenflies symbol. symbol()[source]¶; Returns the Schoenflies symbol for this point group. class SymRep(*args)[source]¶; The SymRep class provides an n dimensional ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:14360,simpl,simple,14360,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['simpl'],['simple']
Usability,"_IND30_EXCH_SINF¶. For SAPT2+3, compute the non-approximated third-order exchange-induction term. Type: boolean; Default: false. SAPT0-D¶; In SAPT0, the computation of \(E_{disp}^{(20)} + E_{exch-disp}^{(20)}\) represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; Grimme’s dispersion corrections are discussed here.; The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D; variants using default parameters optimized for Hartee–Fock interaction energies,; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters.; A simple water dimer computation using SAPT0-D may look like:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis jun-cc-pvdz. energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; energy(""fsapt0-d3mbj""). See FSAPT documentation for more details on using FSAPT; for functional group analyses. table of contents. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; CPHF_R_CONVERGENCE; MAXITER; PRINT. Advanced",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/sapt.html:49680,simpl,simple,49680,psi4manual/master/sapt.html,https://psicode.org,https://psicode.org/psi4manual/master/sapt.html,1,['simpl'],['simple']
Usability,"_IND30_EXCH_SINF¶. For SAPT2+3, compute the non-approximated third-order exchange-induction term. Type: boolean; Default: false. SAPT0-D¶; In SAPT0, the computation of \(E_{disp}^{(20)} + E_{exch-disp}^{(20)}\) represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; Grimme’s dispersion corrections are discussed here.; The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D; variants using default parameters optimized for Hartee–Fock interaction energies,; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters.; A simple water dimer computation using SAPT0-D may look like:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis jun-cc-pvdz. energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; energy(""fsapt0-d3mbj""). See FSAPT documentation for more details on using FSAPT; for functional group analyses. table of contents. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; D_CONVERGENCE; E_CONVERGENCE; MAXITER; PRINT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/sapt.html:49187,simpl,simple,49187,psi4manual/1.7.x/sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/sapt.html,3,['simpl'],['simple']
Usability,"_IND30_EXCH_SINF¶. For SAPT2+3, compute the non-approximated third-order exchange-induction term. Type: boolean; Default: false. SAPT0-D¶; In SAPT0, the computation of \(E_{disp}^{(20)} + E_{exch-disp}^{(20)}\) represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; Grimme’s dispersion corrections are discussed here.; The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D; variants using default parameters optimized for Hartee–Fock interaction energies,; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters.; A simple water dimer computation using SAPT0-D may look like:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis jun-cc-pvdz. energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; energy(“fsapt0-d3mbj”). See FSAPT <fisapt> documentation for more details on using FSAPT; for functional group analyses. table of contents. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; D_CONVERGENCE; E_CONVERGENCE; MAXIT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/sapt.html:48102,simpl,simple,48102,psi4manual/1.6.x/sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/sapt.html,1,['simpl'],['simple']
Usability,"_helgaker_3`. .. hlist::; :columns: 1. * :py:func:`scf_xtpl_helgaker_2`; * :py:func:`scf_xtpl_truhlar_2`; * :py:func:`scf_xtpl_karton_2`. :type corl_alpha: float. Overrides the default \alpha parameter used in the listed :py:func:`corl_xtpl_helgaker_2` correlation; extrapolation to the corl stage. The supplied \alpha does not impact delta or any further stages. .. hlist::; :columns: 1. * :py:func:`corl_xtpl_helgaker_2`. :type delta_alpha: float. Overrides the default \alpha parameter used in the listed; :py:func:`corl_xtpl_helgaker_2` correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different \alpha might; be more appropriate. .. hlist::; :columns: 1. * :py:func:`corl_xtpl_helgaker_2`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correcti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:35972,simpl,simple,35972,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['simpl'],['simple']
Usability,"_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into ManyBody-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - supersystem molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; nbody_model = self.get_results(client=client); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., ""2""); dicts = [; #""energies"", # retired; #""ptype"", # retired; ""intermediates"",; ""intermediates_energy"", #""intermediates2"",; ""intermediates_gradient"", #""intermediates_ptype"",; ""intermediates_hessian"", #""intermediates_ptype"",; ""energy_body_dict"",; ""gradient_body_dict"", # ptype_body_dict; ""hessian_body_dict"", # ptype_body_dict; ""nbody"",; ""cp_energy_body_dict"",; ""nocp_energy_body_dict"",; ""vmfc_energy_body_dict"",; ""cp_gradient_body_dict"",; ""nocp_gradient_body_dict"",; ""vmfc_gradient_body_dict"",; ""cp_hessian_body_dict"",; ""nocp_hessian_body_dict"",; ""vmfc_hessian_body_dict"",; ]. for qcv, val in nbody_model.extras['qcvars'].items():; if isinstance(val, dict):; if qcv in dicts:; for qcv2, val2 in val.items():; for obj in [core, wfn]:; try:; obj.set_variable(str(qcv2), val2); except ValidationError:; obj.set_variable(f""{self.driver.name} {qcv2}"", val2); else:; for obj in [core, wfn]:; obj.set_variable(qcv, val). if self.driver == 'gradient':; ret = core.M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:92211,simpl,simple,92211,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,3,['simpl'],['simple']
Usability,"_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; computer=CompositeComputer,; **cbsmeta,; **current_findif_kwargs,; **kwargs). else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1); if dermode[0] == dermode[1]: # analytic; logger.info(f""PLANNING MB: {mc_level_idx=} {packet=}""); plan.build_tasks(AtomicComputer, **packet, mc_level_idx=mc_level_idx, **kwargs); else:; logger.info(; f""PLANNING MB(FD): {mc_level_idx=} {packet=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; **current_findif_kwargs,; **kwargs). return plan. # Check for CBS; elif method == ""cbs"":; kwargs.update(cbsmeta); # This CompositeComputer is discarded after being used for dermode. Could have used directly for analytic except for excess printing with FD; simplekwargs = copy.deepcopy(kwargs); simplekwargs['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info('PLANNING CBS: packet={packet} kw={kwargs}'); plan = CompositeComputer(**packet, **kwargs); return plan; else:; # For FD(CBS(Atomic)), the CompositeComputer above is discarded after being used for dermode.; logger.info(; f'PLANNING FD(CBS): dermode={dermode} packet={packet} findif_kw={current_findif_kwargs} kw={kwargs}'); plan = FiniteDifferenceComputer(**packet,; findif_mode=dermode,; computer=CompositeComputer,; **current_findif_kwargs,; **kwargs); return plan. # Done with Wrappers -- know we want E, G, or H -- but may still be FD or AtomicComputer; else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_planner.html:9299,simpl,simplekwargs,9299,psi4manual/1.7.x/_modules/psi4/driver/task_planner.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_planner.html,8,['simpl'],['simplekwargs']
Usability,"_tuple(); (2, 0, 4). classmethod from_serial(json_data)¶; Converts serialized data to the correct Psi4 data type. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Vector, arg0: int) -> float. docstring. get(self: psi4.core.Vector, arg0: int, arg1: int) -> float. docstring. name¶; The name of the Vector. Used in printing. nirrep(self: psi4.core.Vector) → int¶; docstring. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶. np_write(filename=None, prefix='')¶. nph¶; View with irreps. print_out(self: psi4.core.Vector) → None¶; docstring. scale(self: psi4.core.Vector, arg0: float) → None¶; docstring. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Vector, arg0: int, arg1: float) -> None. docstring. set(self: psi4.core.Vector, arg0: int, arg1: int, arg2: float) -> None. docstring. shape¶; Shape of the Psi4 data object. to_array(matrix, copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data)¶; Converts an object with a .nph accessor to a serialized dictionary. class psi4.core.Vector3¶; Bases: object; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations. cross(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → psi4.core.Vector3¶; Returns cross product of arg1 and arg2. dis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:134948,simpl,simply,134948,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['simpl'],['simply']
Usability,"_{ij}/(s_{r,n} R_0^{ij}))^{- \alpha_n}}\]; A modified damping scheme for DFT-D3 using the rational damping form of; Becke and Johnson was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now \(s_6\), \(s_8\),; \(a_1\), and \(a_2\). \[E_{disp}^{\text{D3BJ}}=-\sum_{n=6,8} s_n \sum_{i,j>i}^{N_{at}}; \frac{C_n^{ij}}{(R_{ij})^n + (f_{damp})^n}\]. \[f_{damp} = a_1 \sqrt{\frac{C_8^{ij}}{C_6^{ij}}} + a_2\]; All parameters characterizing the dispersion correction are taken from; Grimme’s website; or else from the literature. Running DFTD3¶; A number of a posteriori dispersion corrections are available in; PSI4. While some are computed within PSI4‘s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/PSI4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of dispersion corrections¶. Extension 1; Variant; Computing Program (engine); DFT_DISPERSION_PARAMETERS 11. -D; alias to -D2. -D1; -D1 2; PSI4‘s libdisp; [\(s_6\)]. -D2; -D2 3; PSI4‘s libdisp OR dftd3; [\(s_6\), \(\alpha_6\), \(s_{r,6}\)]. -D3; alias to -D3ZERO. -D3ZE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dftd3-1.html:4854,simpl,simple,4854,psi4manual/1.4.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dftd3-1.html,2,['simpl'],['simple']
Usability,"_{ij}/(s_{r,n} R_0^{ij}))^{- \alpha_n}}\]; A modified damping scheme for DFT-D3 using the rational damping form of; Becke and Johnson was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now \(s_6\), \(s_8\),; \(a_1\), and \(a_2\). \[E_{disp}^{\text{D3BJ}}=-\sum_{n=6,8} s_n \sum_{i,j>i}^{N_{at}}; \frac{C_n^{ij}}{(R_{ij})^n + (f_{damp})^n}\]. \[f_{damp} = a_1 \sqrt{\frac{C_8^{ij}}{C_6^{ij}}} + a_2\]; All parameters characterizing the dispersion correction are taken from; Grimme’s website; or else from the literature. Running DFTD3¶; A number of a posteriori dispersion corrections are available in; PSI4. While some are computed within PSI4’s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/PSI4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of dispersion corrections¶. Extension [1]; Variant; Computing Program (engine); DFT_DISPERSION_PARAMETERS [11]. -D; -D1; -D2; -D3; -D3ZERO; -D3BJ; -D3(BJ); -D3M; -D3MZERO; -D3MBJ; -D3M(BJ); -NL; -CHG; -DAS2009; -DAS2010; alias to -D2; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dftd3-1.html:4819,simpl,simple,4819,psi4manual/1.3.2/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dftd3-1.html,2,['simpl'],['simple']
Usability,"`, which are modelchem strings, into kwargs specs; nbodies_per_mc_level = []; prev_body = 0; for nb in levels:; nbodies = []; if nb == ""supersystem"":; nbodies.append(nb); elif nb != (prev_body + 1):; for m in range(prev_body + 1, nb + 1):; nbodies.append(m); else:; nbodies.append(nb); nbodies_per_mc_level.append(nbodies); prev_body += 1. plan.max_nbody = max(nb for nb in levels if nb != ""supersystem""); plan.nbodies_per_mc_level = nbodies_per_mc_level. for mc_level_idx, mtd in enumerate(levels.values()):; method, basis, cbsmeta = expand_cbs_methods(mtd, basis, driver, cbsmeta=cbsmeta, **kwargs); packet.update({'method': method, 'basis': basis}). # Tell the task builder which level to add a task list for; # * see https://github.com/psi4/psi4/pull/1351#issuecomment-549948276 for discussion of where build_tasks logic should live; if method == ""cbs"":; # This CompositeComputer is discarded after being used for dermode.; simplekwargs = copy.deepcopy(kwargs); simplekwargs.pop('dertype', None); simplecbsmeta = copy.deepcopy(cbsmeta); simplecbsmeta['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplecbsmeta, molecule=original_molecule, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info(""PLANNING MB(CBS): {mc_level_idx=} {packet=} {cbsmeta=} kw={kwargs}""); plan.build_tasks(CompositeComputer, **packet, mc_level_idx=mc_level_idx, **cbsmeta, **kwargs). else:; logger.info(; f""PLANNING MB(FD(CBS): {mc_level_idx=} {packet=} {cbsmeta=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; computer=CompositeComputer,; **cbsmeta,; **current_findif_kwargs,; **kwargs). else:; dermode = negotiate_derivative_type(driver, met",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_planner.html:7559,simpl,simplecbsmeta,7559,psi4manual/1.7.x/_modules/psi4/driver/task_planner.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_planner.html,4,['simpl'],['simplecbsmeta']
Usability,"`highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. :type delta4_scheme: function; :param delta4_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. :type delta5_scheme: function; :param delta5_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:62002,simpl,simple,62002,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['simpl'],['simple']
Usability,"ables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:10904,simpl,simple,10904,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['simpl'],['simple']
Usability,"aika code. There are a; number of reasons motivating this switch. For methods requiring; potentials and fields evaluated at many external sites, such as PCM and; polarizable embedding, the efficiency of the one electron integrals can be rate; limiting. We also started to introduce integral screening, and it is important; to balance the screening used for one- and two-electron terms carefully, so this; is a good opportunity to re-evaluate the code. Finally, given the complexity; of the OS recursion code, the switch to an external library leaves a more; compact codebase to maintain. The one electron integrals which are not provided by Libint2; are now handled by a new implementation of the McMurchie-Davidson (M-D) algorithm,; leading to removal of the OS code in version 1.6. An overview of the one electron integrals; is shown in table Algorithms used for One Electron Integrals, together with the implementation they use.; The tips below serve as a guide to what changed,; why it changed, and how to interface with PSI4’s one-electron integral; machinery now. Calling compute_shell(int P, int Q)¶; The hand-implemented OS recursion code also took care of the Cartesian->pure; transformation (if required by the basis set). The mechanism for handling this; was to provide a public facing compute_shell(int P, int Q) method for the; caller; this then looked up the appropriate GaussianShell objects that were; passed into the corresponding (private) compute_pair(GaussianShell &s1,; GaussianShell &s2) function that computed the integrals and transformed them; to the spherical harmonic basis, if needed. The switch to Libint2 integrals; preserves this mechanism, but the compute_shell(int P, int Q) simply looks; up the appropriate Libint2-compatible shells and hands them off to the; re-written, private compute_pair() routines, which call Libint2 directly.; Therefore, any calls to shell-pair level integral computations should look the; same as before the introduction of Libint2, however",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/prog_integrals.html:11747,guid,guide,11747,psi4manual/1.6.x/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html,5,['guid'],['guide']
Usability,"al computations should look the; same as before the introduction of Libint2, however access to the integrals has; changed, as described below. Accessing integrals¶; Before the Libint2 transition, one electron integrals were computed in a flat; array, internally called buffer_, which was accessed through the integral; object’s buffer() method. For integrals with multiple operators, e.g.,; dipole operators that have three distinct components, the buffer was simply; elongated by the appropriate amount and the caller was responsible for striding; through each resulting batch correctly. The Libint2 engines instead return a; list of pointers into each operator’s batch of integrals, the ordering of which; are detailed on the Libint2 wiki. For this reason, the call to buffer(); that returns a single buffer must be replaced with a call to buffer() to; get a list of pointers; we recommend that be assigned the type const auto; &. For simple integrals, such as overlap or kinetic, only the buffer; corresponding to the zeroth element of this array contains integrals. Derivative Integrals¶; The old one electron integral code used translational invariance relations to; minimze the number of integrals to be computed, leaving the caller with some; bookkeeping to do to compute all terms. For example, consider an overlap; integral: its value depends only on the relative separation of the two centers; and not their absolute positions in space. Therefore, the derivative with; respect to center A is the negative of the same derivative with respect to; center B, so one is trivially gleaned from the other. Extending this to second; derivatives, the same principle leads to the fact that double derivatives with; respect to center A are equal to double derivatives with respect to center B,; which are also equal to the negative of the mixed double derivatives with; respect to both center A and B. The old code only provided the double; derivative with respect to center A, leaving the caller to de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/prog_integrals.html:13641,simpl,simple,13641,psi4manual/1.6.x/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html,5,['simpl'],['simple']
Usability,"al. set(self: psi4.core.Matrix, m: int, n: int, val: float) -> None. Sets a single element of a matrix to val at row m, col n. set(self: psi4.core.Matrix, h: int, m: int, n: int, val: float) -> None. Sets a single element of a matrix, subblock h, row m, col n, with value val. set_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice, block: psi4.core.Matrix) → None¶; Set a matrix block. shape¶; Shape of the Psi4 data object. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → None¶; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix) → float¶; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule) → None¶; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int¶; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float¶; Returns the trace of the matrix. transform(*args, **kwargs)¶; Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transfo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:109228,simpl,simply,109228,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['simpl'],['simply']
Usability,"al. set(self: psi4.core.Matrix, m: int, n: int, val: float) -> None. Sets a single element of a matrix to val at row m, col n. set(self: psi4.core.Matrix, h: int, m: int, n: int, val: float) -> None. Sets a single element of a matrix, subblock h, row m, col n, with value val. set_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice, block: psi4.core.Matrix) → None¶; Set a matrix block. shape¶; Shape of the Psi4 data object. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → None¶; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix) → float¶; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule) → None¶; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int¶; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float¶; Returns the trace of the matrix. transform(*args, **kwargs)¶; Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:139499,simpl,simply,139499,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['simpl'],['simply']
Usability,"allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1; 3 1.000000. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:9640,simpl,simple,9640,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,7,['simpl'],['simple']
Usability,"alpha} (\vec r_1),; \rho_{\beta} (\vec r_1),; \gamma_{\alpha\alpha} (\vec r_1),; \gamma_{\alpha\beta} (\vec r_1),; \gamma_{\beta\beta} (\vec r_1),; \tau_{\alpha} (\vec r_1),; \tau_{\beta} (\vec r_1); ; \omega \right) \ \mathrm{d} ^3 r_1\]. \[-\frac{1}{2} \sum_{i,j}; \delta_{\sigma_{i} \sigma_{j}} \alpha \iint_{\mathrm{R}^6} \phi_{i}^1 \phi_{j}^1; \frac{1}{r_{12}} \phi_{i}^2 \phi_{j}^2 \ \mathrm{d}^3 r_1 \ \mathrm{d}^3 r_2\]. \[-\frac{1}{2} \sum_{i,j}; \delta_{\sigma_{i} \sigma_{j}} (1-\alpha)\iint_{\mathrm{R}^6} \phi_{i}^1 \phi_{j}^1; \frac{\mathrm{erf}(\omega r_{12})}{r_{12}} \phi_{i}^2 \phi_{j}^2 \ \mathrm{d}^3 r_1 \ \mathrm{d}^3 r_2\]; For LRC functionals, the choice of range-separation parameter \(\omega\) has; been the subject of considerable activity since the inception of LRC; functionals. Some authors advocate a static range-separation parameter; determined by optimization over a test set of chemical systems. However, a more; physically-motivated and often more accurate approach is the idea of “gap; fitting” or “optimal tuning” or simply “tuning.” The most popular tuned-LRC; approach is IP-fitting, in which the \(\omega\) is varied until the; Koopman’s IP (the opposite of the HOMO energy) matches the true IP (the; difference between \(N-1\)-electron and \(N\)-electron total; energies), within the LRC functional ansatz. This guarantees the asymptotics of; the exchange potential,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{tuned-LRC}} (r) = -; \frac{1}{r} + I_{\mathrm{IP}} +; \epsilon_{\mathrm{HOMO}}\]; Note that LRC functionals with default \(\omega\) only capture the; \(-1/r\) dependence,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{LRC}} (r) = -; \frac{1}{r},\]; hybrid functionals only capture part of the \(-1/r\) dependence,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{Hybrid}} (r) = -; \frac{\alpha}{r},\]; and local functionals decay exponentially, resulting in completely incorrect; asymptotics,. \[\lim_{r\rightarrow\infty} v_{\ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:10499,simpl,simply,10499,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,15,['simpl'],['simply']
Usability,"ample has the acetylene; perpendicular to the ethylene, with the acetylene hydrogen pointing; directly at the double bond in ethylene; this will be attractive because; the H atoms in acetylene bear a partial positive charge, while the; electron rich double bond in ethylene bears a partial negative charge.; At the same time, the dispersion interaction should be smaller because; the perpendicular geometry does not allow much overlap between the; monomers. Hence, the SAPT analysis helps clarify (and quantify) our; physical understanding about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops and string formatting to make our lives; simpler. Additionally, let’s suppose you want to do counterpoise (CP); correction to compute interaction energies. Counterpoise correction; involves computing the dimer energy and then subtracting out the; energies of the two monomers, each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of specifying the monomers separately was; already dealt with in the previous SAPT example, where we saw that two; dashes in the psi4.geometry(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:17431,simpl,simple,17431,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['simpl'],['simple']
Usability,"an) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html:1855,guid,guide,1855,psi4manual/1.3.2/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html,6,['guid'],['guide']
Usability,"analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:97059,simpl,simply,97059,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['simpl'],['simply']
Usability,"and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once Psi4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about , so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity ).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, Psi4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:2626,simpl,simple,2626,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['simpl'],['simple']
Usability,"and the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. A PSI4 Tutorial; Psithon Tutorial: Using PSI4 as an Executable. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/tutorial.html:23087,clear,clear,23087,psi4manual/1.6.x/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/tutorial.html,1,['clear'],['clear']
Usability,"appa^{\dagger} A \kappa}\]; where \({\bf w}\) is the MO gradient vector, \({\bf \kappa}\) is the MO rotation vector,; and \({\bf A}\) is the MO Hessian matrix. Therefore, minimizing the energy with respect to \({\bf \kappa}\); yields. \[{\bf \kappa} = -{\bf A^{-1}w}\]; This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the orbital-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals, simply set reference rohf. For DFT orbitals, set reference uks and set dft_functional b3lyp. Of; course users can use any DFT functional available in PSI4. Methods¶; The orbital-optimized MPn and OLCCD methods currently supported in; PSI4 are outlined in Table Orbital-Optimzed OCC/DFOCC; Methods. The following methods are available; and can be controlled through OCC (conventional integrals CONV); and DFOCC (density-fitted DF and Cholesky-decomposed CD); keywords. Switching between the integrals treatments is controlled; through “type select” values in the rightmost Table column. Orbital-Optimized MP and LCCD capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. omp2; Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE CONV. Density-Fitted Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —; MP2_TYPE CD. omp3; Orbital-Optimized MP3; R",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/occ-1.html:8887,simpl,simply,8887,psi4manual/1.1.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/occ-1.html,11,['simpl'],['simply']
Usability,"are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; 1; 2; 3Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about \(1.0 \times 10^{-6}\), so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity \(2S+1 = 3\)).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. No",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/tutorial-1.html:3225,simpl,simple,3225,psi4manual/1.3.2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/tutorial-1.html,2,['simpl'],['simple']
Usability,"argument is nmax, the total number of electrons to; # strip out of the molecule, in this case, 2.; # Many optional arguments are available, see the python file; frac_nuke(h2o, nmax = 2). Note: this feature is new/powerful enough that we have several papers pending on; it, and are interested in expanding this work. If you would like to publish; results using this code, please contact Rob Parrish to make arrangements for; collaboration. Recommendations¶; The KS-DFT code is quite new, but relatively complete. During code development,; emphasis was placed on flexibility of functional technology, efficiency for; medium to large systems in difficult electronic environments (e.g., compact; spatial extents, diffuse basis sets, low band-gaps, LRC and/or hybrid GKS; functionals), and time to code completion. We are very interested in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Table Of Contents. Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Recommendations. Previous topic; Hartree–Fock Theory; Next topic; Dens",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/dft-1.html:22056,guid,guidelines,22056,psi4manual/4.0b2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/dft-1.html,2,['guid'],['guidelines']
Usability,"ark the error; }. energy('b3lyp'). ERI Algorithms¶; The ERI algorithms for the Coulomb and hybrid exchange are identical to; those for Hartree–Fock. However, for LRC functionals, the long-range; exchange contributions to the Kohn–Sham matrix have only been implemented in the; DF and DIRECT algorithms. The use of DF is highly recommended for KS-DFT, as the; errors incurred by the density fitting approximation (in a proper -JKFIT; auxiliary basis) are orders of magnitude smaller than the accuracy of any known; functional.; Note: gradients with LRC functionals and DF integrals technology are not; currently enabled. We hope to have a patch for this deficit soon. Please let us; know if you have a strong need for this capability, and we will move the; priority up. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20memory 512 MB; from frac import *. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # IP fitting must be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; dft_functional wb97; }. # Arguments are molecule object, minimum omega, maximum omega; ip_fitting(h2o, 0.4, 2.0). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dft-1.html:22336,simpl,simply,22336,psi4manual/1.1.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dft-1.html,2,['simpl'],['simply']
Usability,"ark the error; }. energy('b3lyp'). ERI Algorithms¶; The ERI algorithms for the Coulomb and hybrid exchange are identical to; those for Hartree–Fock. However, for LRC functionals, the long-range; exchange contributions to the Kohn–Sham matrix have only been implemented in the; DF and DIRECT algorithms. The use of DF is highly recommended for KS-DFT, as the; errors incurred by the density fitting approximation (in a proper -JKFIT; auxiliary basis) are orders of magnitude smaller than the accuracy of any known; functional.; Note: gradients with LRC functionals and DF integrals technology are not; currently enabled. We hope to have a patch for this deficit soon. Please let us; know if you have a strong need for this capability, and we will move the; priority up. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18memory 512 MB. molecule h2o {; 0 1 # must be neutral; O; H 1 1.0; H 1 1.0 2 104.5; # IP fitting runs in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; }. # Optional arguments are minimum omega, maximum omega, molecule object; omega = ip_fitting('wb97', 0.4, 2.0, molecule=h2o). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of 0.4 and 2.0. Lar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:22973,simpl,simply,22973,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,2,['simpl'],['simply']
Usability,"artree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. Psi4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in Psi4. Table Of Contents. A Psi4 Tutorial; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. Previous topic; Binary Distribution; Next topic; Psithon: Structuring an Input File. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » . © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:22150,clear,clear,22150,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['clear'],['clear']
Usability,"at extrapolation stage as `scf` or `corl`, by default only the first stage is `scf` and every later one is `corl`.; `stage`: tag for the stage used in tables. The next items in the `cbs_metadata` array extrapolate correlation. All of the above parameters are available, with only the `wfn` and `basis` keywords required. Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters; molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html:12639,simpl,simple,12639,psi4manual/1.6.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html,2,['simpl'],['simple']
Usability,"at extrapolation stage as `scf` or `corl`, by default only the first stage is `scf` and every later one is `corl`.; `stage`: tag for the stage used in tables. The next items in the `cbs_metadata` array extrapolate correlation. All of the above parameters are available, with only the `wfn` and `basis` keywords required. Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters; molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html:12631,simpl,simple,12631,psi4manual/1.4.0/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html,8,['simpl'],['simple']
Usability,"ath; >>> psi4 --test. # Mac; # py38|py39|py310 for alternate python versions; >>> curl -O ""http://vergil.chemistry.gatech.edu/download/Psi4conda-latest-py35-MacOSX-x86_64.sh"" --keepalive-time 2; >>> curl ""http://vergil.chemistry.gatech.edu/psicode-download/Psi4conda-1.4rc1-py38-MacOSX-x86_64.sh"" -o Psi4conda-latest-py38-MacOSX-x86_64.sh --keepalive-time 2; >>> bash Psi4conda-latest-py38-MacOSX-x86_64.sh -b -p $HOME/psi4conda # agrees to license terms; >>> (bash) echo $'. $HOME/psi4conda/etc/profile.d/conda.sh\nconda activate' >> ~/.bash_profile; >>> (tcsh) echo ""source $HOME/psi4conda/etc/profile.d/conda.csh\nconda activate"" >> ~/.tcshrc; # log out, log back in so conda and psi4 in path; >>> psi4 --test. # Windows; # py38 only python version; # download via button at https://psicode.netlify.app/installs/latest with ""Windows"", ""Installer"", and ""Stable Release"" selected; >>> # install via GUI by double-clicking downloaded `.exe` file analogous to https://conda.io/projects/conda/en/latest/user-guide/install/windows.html; >>> # -OR- install via following line; >>> start /wait """" Psi4conda-1.4rc1-py38-Windows-x86_64.exe /InstallationType=JustMe /RegisterPython=0 /S /D=%UserProfile%\psi4conda; >>> psi4 --test. That last command tested that psi4 is in your path, and it’s finding; all the libraries it needs. It works because PSI_SCRATCH; defaults to /tmp. Now you need only specify a permanent scratch; directory (see Scratch Files) by replacing the placeholder in the; following:; >>> echo ""export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files"" >> ~/.bashrc; # log out, log back in so variable takes effect. All done!; Configuration for this set-up is summarized at How to run Psi4 as executable or Python module from conda installation. Note; PSI4 installs a Python distribution alongside, so you should choose an installer based on the Python version you want, irrespective of any Python version you have. How to install a Psi4 binary into an An",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/conda.html:4200,guid,guide,4200,psi4manual/1.6.x/conda.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/conda.html,5,['guid'],['guide']
Usability,"ation.; #! Sample UHF/6-31G** CH2 computation. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; 1@UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:5487,simpl,simple,5487,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,6,['simpl'],['simple']
Usability,"ations are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about \(1.0 \times 10^{-6}\), so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity \(2S+1 = 3\)).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. No",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/tutorial-1.html:3263,simpl,simple,3263,psi4manual/1.4.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/tutorial-1.html,9,['simpl'],['simple']
Usability,"ations into the energy expression, we obtain:. \[E_{DCFT} = \frac{1}{2} \left( h_p^q + f_p^q \right) \gamma_q^p + \frac{1}{4} \bar{g}_{pq}^{rs} \lambda_{rs}^{pq}\]; where the antisymmetrized two-electron integrals and the generalized Fock operator; matrix elements were defined as follows:. \[\bar{g}_{pq}^{rs} = g_{pq}^{rs} - g_{pq}^{sr}\]. \[f_p^q = h_p^q + \bar{g}_{pr}^{qs} \gamma_{s}^{r}\]; Energy functional \(E_{DCFT}\) has several important properties. First,; the energy is now a function of two sets of independent parameters, the; idempotent part of \(\boldsymbol{\gamma_1}\) (\(\boldsymbol{\kappa}\)) and the density cumulant; (\(\boldsymbol{\lambda_2}\)). As a result, the energy functional is Hermitian,; which is important for the evaluation of the molecular properties. The additive; separability of the density cumulant guarantees that all of the DCFT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent part of \(\boldsymbol{\gamma_1}\) is; N-representable by construction. One only needs to worry about the; N-representability of the density cumulant, which is a relatively small part of; \(\boldsymbol{\gamma_2}\).; In order to obtain the DCFT energy, two conditions must be satisfied:. The energy must be stationary with respect to a set of orbitals. This can be done by; diagonalizing the generalized Fock operator (as in the DC-06 and DC-12 methods, see below),; which introduces partial orbital relaxation, or by fully relaxing the orbitals and minimizing the entire energy expression; (as in the ODC-06 and ODC-12 methods).; The energy must be stationary with respect to the variation of the density; cumulant \(\boldsymbol{\lambda_2}\), constrained to N-representability conditions. Making the energy stationary requires solution of two sets of coupled; equations for orbitals and density cumulant, respectively (also known as; residual equations). At the present moment, three diff",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dcft-1.html:3391,simpl,simplified,3391,psi4manual/1.2.1/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dcft-1.html,6,['simpl'],['simplified']
Usability,"ature :. void set_enable_pybuffer(N3psi12TwoBodyAOIntE {lvalue},b). ExternalPotential¶. psi4.ExternalPotential.addBasis()¶; Python Library Documentation: method addBasis; addBasis(...) unbound psi4.ExternalPotential method. addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :. docstring; C++ signature :. void addBasis(N3psi17ExternalPotentialE {lvalue},N5boost10shared_ptrIN3psi8BasisSetEEE,N5boost10shared_ptrIN3psi6VectorEEE). psi4.ExternalPotential.addCharge()¶; Python Library Documentation: method addCharge; addCharge(...) unbound psi4.ExternalPotential method. addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :. docstring; C++ signature :. void addCharge(N3psi17ExternalPotentialE {lvalue},d,d,d,d). psi4.ExternalPotential.clear()¶; Python Library Documentation: method clear; clear(...) unbound psi4.ExternalPotential method. clear( (ExternalPotential)arg1) -> None :. docstring; C++ signature :. void clear(N3psi17ExternalPotentialE {lvalue}). psi4.ExternalPotential.computePotentialMatrix()¶; Python Library Documentation: method computePotentialMatrix; computePotentialMatrix(...) unbound psi4.ExternalPotential method. computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE computePotentialMatrix(N3psi17ExternalPotentialE {lvalue},N5boost10shared_ptrIN3psi8BasisSetEEE). psi4.ExternalPotential.print_out()¶; Python Library Documentation: method print_out; print_out(...) unbound psi4.ExternalPotential method. print_out( (ExternalPotential)arg1) -> None :. docstring; C++ signature :. void print_out(N3psi17ExternalPotentialE {lvalue}). psi4.ExternalPotential.setName()¶; Python Library Documentation: method setName; setName(...) unbound psi4.ExternalPotential method. setName( (ExternalPotential)arg1, (str)arg2) -> None :. docstring; C++ signature :. void setName(N3psi17ExternalPotentialE {lvalue},Ss). F12¶. psi4.F12.comput",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:135649,clear,clear,135649,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['clear'],['clear']
Usability,"ature of preceeding or following; jobs, it is prudent to separate them with the following:; clean() # removes Psi4 scratch files; clean_variables() # empties the PSI variables list; cfour {} # empties the cfour block. Warning; Because p4c4 does not inspect the contents of the cfour {...}; block, once the user specifies a Psi4-style molecule, the; interface cannot judge whether a sandwich mode (drop the Psi4 molecule; and use the cfour block as the entirety of the ZMAT) or a standard mode; (translate the Psi4 molecule and append additional input from the; cfour block) is intended. The latter is what actually occurs. If; there is both a Psi4 molecule and a molecule in the cfour block,; ZMAT will end up with multiple molecules and multiple *CFOUR(...); blocks, and it will not run. Therefore, if mixing sandwich and; standard or pure-Psi4 computations in an input file, place all; the sandwich jobs at the beginning before declaring Psi4; molecules. If necessary, clear the cfour block with cfour {} before; commencing standard P4C4 jobs. Output¶; The output of xcfour invoked from a Psi4 input file is; written to the Psi4 output file as the computation progresses. If a; Cfour module terminates with a non-zero error code, the value will show up; in CFOUR ERROR CODE.; Energies & Scalars; After execution of xcfour has completed, the output string is; extensively parsed and appropriate results are stored in PSI; Variables. All gleaned variables are printed in the; Cfour output section of the Psi4 output file, as shown below.; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//; // Cfour c4-ccsd(t) Energy Results //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. Variable Map:; ----------------------------------------------------------------------------; ""(T) CORRECTION ENERGY"" => -0.007263598030; ""CCSD CORRELATION ENERGY"" => -0.275705492359; ""CCSD TOTAL ENERGY"" => -76.338453952539; ""CCSD(T) CORRELATION ENERGY"" => -0.007263598030; ""CCSD(T) TOTAL ENERGY"" => -76.345717550569; ""CFOUR ERROR CODE"" => 0.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:18629,clear,clear,18629,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['clear'],['clear']
Usability,"author: Lori A. Burns; Section author: Lori A. Burns; Module: Samples. Installation¶; Binary. gCP is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the PSI4 binary, gCP has already been installed alongside. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; the gcp executable can be obtained through conda install gcp. To remove a conda installation, conda remove gcp. Source. If using PSI4 built from source and you want to build gCP from; from source also, follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a Fortran compiler, and run make). To be used by PSI4, the program binary (gcp) must be; found in your PSIPATH or PATH (in that order). If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The DFTD3 executable must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; 1energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; 1optimize('pbeh3c'). HF-3c with non-standard basis; 1; 2set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; 1; 2set basis cc-pvdz; energy('pbeh3c/'). If only BSS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/gcp-1.html:1176,simpl,simply,1176,psi4manual/1.1.0/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/gcp-1.html,2,['simpl'],['simply']
Usability,"ay(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def _to_array(matrix, copy=True, dense=False):; """"""; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters; ----------; matrix : :py:class:`~psi4.core.Matrix` or :py:class:`~psi4.core.Vector`; Pointers to which Psi4 core class should be used in the construction.; copy : bool, optional; Copy the data if `True`, return a view otherwise; dense : bool, optional; Converts irreped Psi4 objects to diagonally blocked dense arrays if `True`. Returns a list of arrays otherwise. Returns; -------; array : ndarray or list of ndarray; Returns either a list of np.array's or the base array depending on options. Notes; -----; This is a generalized function to convert a Psi4 object to a NumPy array. Examples; --------. >>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. matrix_views = _get_raw_views(matrix, copy=copy). # Return the list of arrays; if dense is False:; return matrix_views. # Build the dense matrix; if isinstance(matrix,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html:5533,simpl,simply,5533,psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,2,['simpl'],['simply']
Usability,"bal_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; # retire components by v1.5; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); core.set_variable(""CURRENT DIPOLE X"", core.variable(name.upper() + "" DIPOLE X"")); core.set_variable(""CURRENT DIPOLE Y"", core.variable(name.upper() + "" DIPOLE Y"")); core.set_variable(""CURRENT DIPOLE Z"", core.variable(name.upper() + "" DIPOLE Z"")); core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_dis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:166817,simpl,simplefilter,166817,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['simpl'],['simplefilter']
Usability,"be obtained through conda install dftd3 -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; the dftd3 executable can be obtained through conda install dftd3 -c psi4. To remove a conda installation, conda remove dftd3. Source. If using PSI4 built from source and you want to build DFTD3 from; from source also,; follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a; Fortran compiler, and run make). From version 3.1.0 onwards, DFTD3 can; be used as-is; for earlier versions, patches are available:; psi4/psi4/share/psi4/scripts/patch_grimme_dftd3.3.0.2. To be used by PSI4, the program binary (dftd3) must be; found in your PSIPATH or PATH (in that order). If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular dftd3 compilation, simply adjust its; position in the path environment variables. Theory¶; The local or semilocal character of conventional density functionals; necessarily leads to neglect of the long-range correlation interactions; which capture attractive van der Waals forces. Initially proposed by Yang; [Wu:2002:515] and assiduously developed by Grimme, [Grimme:2004:1463]; [Grimme:2006:1787] [Grimme:2010:154104] the DFT+Dispersion method; appends to the base functional a scaled, damped, and fitted leading term; to the well-known dispersion energy series, \(E_{disp} = -C_6/R^6; -C_8/R^8 -C_{10}/R^{10}-\cdots\). The DFT-D2 [Grimme:2006:1787] variant; takes the explicit form below. Here, dispersion coefficients,; \(C_6^{ij}\), obtained from the geometric mean of tabulated elemental; values, are summed over interatomic distances, \(R_{ij}\), modulated; by a damping function, \(f_{damp}(R_{ij})\), that gradually activates; the dispersion correction (at a rate characterized by \(\alpha_6\)); over a distance c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dftd3-1.html:1516,simpl,simply,1516,psi4manual/1.2.1/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dftd3-1.html,4,['simpl'],['simply']
Usability,"ber of irreps. np; View without only one irrep. classmethod np_read(filename, prefix=''); Reads the data from a NumPy compress file. np_write(filename=None, prefix=''); Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph; View with irreps. print_out(self: psi4.core.Vector) → None; Prints the vector to the output file. scale(self: psi4.core.Vector, sc: float) → None; Scales the elements of a vector by sc. set(*args, **kwargs); Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None; Set a vector block. shape; Shape of the Psi4 data object. to_array(copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.vector.html:7940,simpl,simply,7940,psi4manual/1.3.2/api/psi4.core.vector.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.vector.html,1,['simpl'],['simply']
Usability,"ber of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if name == 'bccd(t)':; core.cctriples(ref_wfn). optstash.restore(); return ref_wfn. def run_dft_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DFT calculations. This is a simple alias to :py:func:`~proc.run_scf`; since DFT properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.dft_set_reference_local(name). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). scf_wfn = run_scf(name, scf_do_dipole=False, do_timer=False, **kwargs). # Run OEProp; oe = core.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); scf_wfn.set_oeprop(oe). core.tstop(); optstash.restore(); return scf_wfn. def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). scf_wfn = run_scf(name, scf_do_dipole=False, do_timer=False, **kwargs). # Run OEProp; oe = core.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); scf_wfn.set_oeprop(oe). core.tstop(); optstash.restore(); return scf_wfn. def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; optstash = p4util.OptionsState(; ['WFN'],; ['DERTYPE'],; ['ONEPDM'],; ['PROPERTY'],; ['CCLAMBDA', 'R_CONVERGENCE'],; ['CCEOM', 'R_CONVERGENCE'],; ['CCEOM', 'E_CONVERGENCE']). oneel_properties = ['dipole', 'quadrupole']; twoel_properties = []; response_properties = ['polarizability', 'rotation', 'roa', 'roa_tensor']; excited_properties = ['oscillator_strength', 'r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:71047,simpl,simple,71047,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['simpl'],['simple']
Usability,"between different modules.; Notice also that there’s a special comment immediately before the; declaration of each keyword. You must provide these comments for any; options you add as they will be automatically inserted into the user; manual Providing a clear description will also help you to remember what; the keywords do and how they’re used. The comments must live between the; special comment delimiters. For options that most users shouldn’t need,; add an expert flag to the comment. This will place these options in a; separate section of the user manual.; /*- comment -*/; options.add_ ...; /*- comment !expert -*/; options.add_ ... As is apparent from the examples above, comments can span multiple lines; (see PRINT), can refer to other options (through hyperlinks; see; SAVE_INFO), can refer to sections of the manual (through hyperlinks;; see DOCC), and can contain LaTeX notation (see AO_BASIS). (To get; the LaTeX subscript command, use “@@” instead of “_”.); See Best Practices; for guidelines on naming options. What is has_changed ?¶; There are times when we need to know whether an option was provided by the; user or if the defaults are being used. For this reason, the Options; object stores a boolean has_changed value, in addition to the option; value itself. A clarification of definition:. [a] has_changed DOESN’T answer “Has option been changed by the user?”; [b] has_changed DOESN’T answer “Is option now different from the default?”; [c] has_changed DOES answer “Has option value been touched at all, by user or code?”. The above items notwithstanding, psi4 code should be written so that; has_changed DOES effectively mean, “Has option been changed by the; user?”. The way to do this is to isolate and nullify any changes to; options made by the code, the difference between [a] and [c]. C-side,; there is no concern since options are read but essentially never; written-to within the modules.; Py-side is another matter since the driver’s role is to take terse; instruct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optionshandling-1.html:4121,guid,guidelines,4121,psi4manual/1.0.0/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optionshandling-1.html,8,['guid'],['guidelines']
Usability,"bilities; Interface to MRCC by M. Kállay. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; To indicate MRCC as the target software, set QC_MODULE=MRCC.; This is a change as of October 2022; previously, one prefixed the method by “mr”; to indicate MRCC (e.g., energy('mrccsdt')).; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; qc_module mrcc; }; energy('ccsdt'). 'ccsdt' in the call to energy() plus qc_module=mrcc instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; Here the qc_module=mrcc is optional since PSI4 has no builtin module; that can perform CCSDT. For a method like CCSD, no specification of QC_MODULE; will default to the CCENERGY module, and specification with value mrcc is; required to route the computation to the MRCC program.; For a CCSDT(Q) energy, simply use 'ccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you can call it directly; For other methods, you will",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/mrcc.html:1151,simpl,simply,1151,psi4manual/1.7.x/mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/mrcc.html,4,['simpl'],['simply']
Usability,"brary or suffix to use. --with-boost-regex[=special-lib] —; Use the Regex library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-regex=boost_regex-gcc-mt-d-1_33_1. --with-boost-serialization[=special-lib] —; Use the Serialization library from boost. It is possible to specify a; certain library for the linker e.g.,; --with-boost-serialization=boost_serialization-gcc-mt-d-1_33_1. --with-boost-system[=special-lib] —; Use the System library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-system=boost_system-gcc-mt. --with-boost-thread[=special-lib] —; Use the Thread library from boost. It is possible to specify a certain; library for the linker e.g.,; --with-boost-thread=boost_thread-gcc-mt. Step 2: Compilation; Running make (which must be GNU’s ‘make’ utility) in $objdir will compile; the PSI4 libraries and executable modules. Step 3: Testing; To execute automatically the ever-growing number of test cases after; compilation, simply execute make tests in the $objdir directory.; This will run each (relatively small) test case and report the results.; Failure of any of the test cases should be reported to the developers.; By default, any such failure will stop the testing process. If you desire; to run the entire testing suit without interruption, execute make tests; TESTFLAGS='-u -q'. Note that you must do a make testsclean in $objdir; to run the test suite again. Step 4: Installation; Once testing is complete, installation into $prefix is accomplished by; running make install in $objdir. Executable modules are installed in; $prefix/bin, include files in $prefix/include, libraries in $prefix/lib, and; basis set data and various control structures in $prefix/share. Step 5: Building Documentation; This is not recommended because all of the documentation should be; available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is au",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:17174,simpl,simply,17174,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,3,['simpl'],['simply']
Usability,"brid DF/Direct procedure can significantly accelerate SCF; computations requiring exact integrals.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree–Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) \(\{\psi_i\}\),. \[\psi_i(\vec x_1) = C_{\mu i} \phi_{\mu} (\vec x_1).\]; Here, \(\{\phi_{\mu}\}\) are the basis functions, which, in PSI4 are; contracted Cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix \(C_{\mu i}\) contains the MO coefficients, which are the; constrained variational parameters in Hartree–Fock. The molecular orbitals are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. \[\begin{split}| \Psi_0 \rangle =; \frac{1}{\sqrt{N!}} \left | \begin{array}{cccc}; \psi_1 (\vec x_1) & \psi_2(\vec x_1) & \ldots & \psi_N (\vec x_1) \\; \psi_1 (\vec x_2) & \psi_2(\vec x_2) & \ldots & \psi_N (\vec x_2) \\; \vdots & \vdots & \ddots & \vdots \\; \psi_1 (\vec x_N) & \psi_2(\vec x_N) & \ldots & \psi_N (\vec x_N) \\; \end{array}\right |\end{split}\]; This form for the Hartree–Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; \(\mathbb{R}^6\) instead of a more complicated effect in; \(\mathbb{R}^N\).; Considering the electronic Hamiltonian,. \[\hat H = \sum_{i} -\frac{1}{2} \nabla_i^2 + \sum_{i} \sum_{A} -; \frac{Z_A}{r_{iA}} + \sum_{i>j} \frac{1}{r_{ij}},\]; the Hartree–Fock energy is, by Slater’s rules,. \[E_{\mathrm{HF}} =; \langle \Psi_0 | \hat H | \Psi_0 \rangle; = \sum_{i} \langle i | \hat h | i \rangle; + \frac 1 2 \sum_{i,j} [ii|jj] - [ij",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:4487,simpl,simplest,4487,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,15,['simpl'],['simplest']
Usability,"butions specific to PSI4 (in addition to; appropriate references for the underlying theory, which are not necessarily; included in the list below).; Regardless of the type of the calculation, an initial guess is; necessary. PSI4 features several initial guesses for the; molecular orbitals. The default guess is the superposition of atomic; densities (SAD), discussed in. “Principles for a direct SCF approach to LCAO-MO ab-initio; calculations”, J. Almlöf, K. Faegri, and K. Korsell,; J. Comput. Chem. 3, 385 (1982).; (doi: 10.1002/jcc.540030314).; “Starting SCF calculations by superposition of atomic; densities”, J. H. Van Lenthe, R. Zwaans, H. J. J. Van Dam,; and M. F. Guest, J. Comput. Chem. 27, 926 (2006).; (doi: 10.1002/jcc.20393). PSI4 also features an extended Hückel guess, which employs; on-the-fly atomic calculations alike the SAD guess. The Hückel guess; has been described in. “An assessment of initial guesses for self-consistent field; calculations. Superposition of Atomic Potentials: simple yet; efficient”, S. Lehtola, J. Chem. Theory Comput. (2019); (doi: 10.1021/acs.jctc.8b01089). Density Cumulant Functional Theory (DCFT)¶; PSI4 features several formulations of newly-developed density cumulant; functional theory (DCFT). The theory and benchmark of this theory are; discussed in the following papers:; DC-06 (also known as DCFT-06):. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423). DC-12:. “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/introduction-1.html:5359,simpl,simple,5359,psi4manual/1.3.2/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/introduction-1.html,2,['simpl'],['simple']
Usability,"c single-geometry computations. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. Table([rows, row_label_width, ...]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Error called for problems with the input file. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psi4api.html:23225,simpl,simple,23225,psi4manual/1.6.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html,1,['simpl'],['simple']
Usability,"c) 2007-2018 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import sys. import numpy as np. from psi4 import core; from .exceptions import *. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]def array_to_matrix(self, arr, name=""New Matrix"", dim1=None, dim2=None):; """"""; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters; ----------; arr : array or list of arrays; Numpy array or list of arrays to use as the data for a new core.Matrix; name : str; Name to give the new core.Matrix; dim1 : list, tup",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html:1262,simpl,simple,1262,psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,1,['simpl'],['simple']
Usability,"casscf']:; ciwfn = run_detcas(name, **kwargs); else:; ciwfn = run_detci(name, **kwargs). # All property names are just CI; if 'CI' in name.upper():; name = 'CI'. states = psi4.get_global_option('avg_states'); nroots = psi4.get_global_option('num_roots'); if len(states) != nroots:; states = range(1, nroots + 1). # Run OEProp; oe = psi4.OEProp(ciwfn); oe.set_title(name.upper()); for prop in ci_prop:; oe.add(prop.upper()). # Compute ""the"" CI density; oe.compute(). # If we have more than one root, compute all data; if nroots > 1:; psi4.print_out(""\n ===> %s properties for all CI roots <=== \n\n"" % name.upper()); for root in states:; oe.set_title(""%s ROOT %d"" % (name.upper(), root)); root = root - 1; if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(root, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(root, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(root, root, ""B"", True)); oe.compute(). # Transition density matrices; if (nroots > 1) and len(ci_trans):; oe.clear(); for tprop in ci_trans:; oe.add(tprop.upper()). psi4.print_out(""\n ===> %s properties for all CI transition density matrices <=== \n\n"" % name.upper()); for root in states[1:]:; oe.set_title(""%s ROOT %d -> ROOT %d"" % (name.upper(), 1, root)); root = root - 1; if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(0, root, ""B"", True)); oe.compute(). optstash.restore(); return ciwfn. [docs]def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if name == 'eom-ccsd':; psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCHBAR', 'WFN'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:66024,clear,clear,66024,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['clear'],['clear']
Usability,"cation.; #! Sample UHF/6-31G** CH2 computation. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/tutorial-1.html:5524,simpl,simple,5524,psi4manual/1.4.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/tutorial-1.html,9,['simpl'],['simple']
Usability,"ch directory unless user instructs otherwise; keep = yes.match(str(kwargs['keep'])) if 'keep' in kwargs else False; os.chdir('..'); try:; if keep or ('path' in kwargs):; core.print_out('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURREN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:13125,clear,clear,13125,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,4,['clear'],['clear']
Usability,"compute_shell( (OneBodyAOInt)arg1, (int)arg2, (int)arg3) -> None :. docstring; C++ signature :. void compute_shell(N3psi12OneBodyAOIntE {lvalue},i,i). psi4.NablaInt.origin()¶; Python Library Documentation: property. The origin about which the one body ints are being computed. psi4.NablaInt.py_buffer()¶; Python Library Documentation: property. docstring. psi4.NablaInt.py_buffer_object()¶; Python Library Documentation: property. docstring. psi4.NablaInt.set_enable_pybuffer()¶; Python Library Documentation: method set_enable_pybuffer; set_enable_pybuffer(...) unbound psi4.NablaInt method. set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :. docstring; C++ signature :. void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b). OEProp¶. psi4.OEProp.add()¶; Python Library Documentation: method add; add(...) unbound psi4.OEProp method. add( (OEProp)arg1, (str)arg2) -> None :. docstring; C++ signature :. void add(N3psi6OEPropE {lvalue},Ss). psi4.OEProp.clear()¶; Python Library Documentation: method clear; clear(...) unbound psi4.OEProp method. clear( (OEProp)arg1) -> None :. docstring; C++ signature :. void clear(N3psi6OEPropE {lvalue}). psi4.OEProp.compute()¶; Python Library Documentation: method compute; compute(...) unbound psi4.OEProp method. compute( (OEProp)arg1) -> None :. docstring; C++ signature :. void compute(N3psi6OEPropE {lvalue}). psi4.OEProp.set_Da_ao()¶; Python Library Documentation: method set_Da_ao; set_Da_ao(...) unbound psi4.OEProp method. set_Da_ao( (OEProp)arg1, (Matrix)arg2, (int)arg3) -> None :. docstring; C++ signature :. void set_Da_ao(N3psi6OEPropE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE,i). psi4.OEProp.set_Da_mo()¶; Python Library Documentation: method set_Da_mo; set_Da_mo(...) unbound psi4.OEProp method. set_Da_mo( (OEProp)arg1, (Matrix)arg2) -> None :. docstring; C++ signature :. void set_Da_mo(N3psi6OEPropE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE). psi4.OEProp.set_Da_so()¶; Python Library Documentation: method set_Da_so; se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:261175,clear,clear,261175,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,6,['clear'],['clear']
Usability,"conditions (e.g., reference, algorithm, active orbitals, QC module, etc.) requested. MissingMethodError(msg); Error called when requested level or theory or derivative level are not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for PSI4. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. TestComparisonError(msg); Error called when a compare_values() or other comparison function fails. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Input specification has problems. Class Inheritance Diagram¶. psi4.driver.p4util Package¶; Miscellaneous tools for driver and users. Functions¶. OptionsStateCM(osd); Return a context manager that will collect the state (value and changed :rtype: Iterator[None]. all_casings(input_string); Return a generator of all lettercase permutations of input_string. array_to_matrix(self, arr[, name, dim1, dim2]); Converts a NumPy array or list of NumPy arrays into a PSI4 Matrix or Vector (irrepped if list). banner(text[, type, width, strNotOutfile]); Format text into a banner style and print or return it. basis_helper(block[, name, key, set_option]); Helper to specify a custom basis set in PsiAPI mode. block_diagonal_array(*args); Convert square NumPy array to a single block diagonal array. cg_solver(rhs_vec, hx_function, preconditioner); Solves the \(Ax = b\) linear equations via Conjugate Gradient. com",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psi4api.html:22294,simpl,simple,22294,psi4manual/1.9.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psi4api.html,1,['simpl'],['simple']
Usability,"conditions (e.g., reference, algorithm, active orbitals, QC module, etc.) requested. MissingMethodError(msg); Error called when requested level or theory or derivative level are not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for PSI4. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. TestComparisonError(msg); Error called when a compare_values() or other comparison function fails. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Input specification has problems. Class Inheritance Diagram¶. psi4.driver.p4util Package¶; Miscellaneous tools for driver and users. Functions¶. OptionsStateCM(osd); Return a context manager that will collect the state (value and changed status) of a list of keywords osd that can initialize OptionsState on entry to the with-statement and restore the collected state when exiting the with-statement. all_casings(input_string); Return a generator of all lettercase permutations of input_string. array_to_matrix(self, arr[, name, dim1, dim2]); Converts a NumPy array or list of NumPy arrays into a PSI4 Matrix or Vector (irrepped if list). banner(text[, type, width, strNotOutfile]); Format text into a banner style and print or return it. basis_helper(block[, name, key, set_option]); Helper to specify a custom basis set in PsiAPI mode. block_diagonal_array(*args); Convert square NumPy array to a singl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:22289,simpl,simple,22289,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,3,['simpl'],['simple']
Usability,"convergence. This is particularly likely for large systems, metallic systems,; multireference systems, open-shell systems, anions, and systems with diffuse; basis sets.; For initial orbital selection, several options are available. These include:. CORE; Diagonalization of the core Hamiltonian, removing even mean-field electron; repulsion. Simple, but often too far from the final solution for larger; systems. READ becomes the default for the second and later iterations; of geometry optimizations.; SAD [Default]; Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH [Default]; Generalized Wolfsberg-Helmholtz, a simple Hückel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. This becomes the; default for the second and later iterations of geometry optimizations. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; BASIS_GUESS = SMALL_BASIS to the options list. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:16875,simpl,simple,16875,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['simpl'],['simple']
Usability,"cstring; | ; | py_buffer_object; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:36359,clear,clear,36359,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['clear'],['clear']
Usability,"ct(mol, ""DF_BASIS_MP2"", """", ""RIFIT"", ""6-31+G(d,p)"")``. """"""; #print type(mol), type(key), type(target), type(fitrole), type(other); orbonly = True if (fitrole == 'BASIS' and other is None) else False; if orbonly:; orb = target; aux = None; else:; orb = other; aux = target. #print 'BasisSet::pyconstructP', 'key =', key, 'aux =', aux, 'fitrole =', fitrole, 'orb =', orb, 'orbonly =', orbonly #, mol. # Create (if necessary) and update qcdb.Molecule; if isinstance(mol, basestring):; mol = Molecule(mol); returnBasisSet = False; elif isinstance(mol, Molecule):; returnBasisSet = True; else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); mol.update_geometry(). # Apply requested basis set(s) to the molecule; # - basstrings only a temp object so using fitrole as dict key instead of psi4 keyword; # - error checking not needed since C-side already checked for NULL ptr; mol.clear_basis_all_atoms(); # TODO now need to clear shells, too; basstrings = defaultdict(dict); if orb is None or orb == '':; raise ValidationError(""""""Orbital basis argument must not be empty.""""""); elif callable(orb):; basstrings['BASIS'] = orb(mol, 'BASIS'); elif isinstance(orb, basestring):; mol.set_basis_all_atoms(orb, role='BASIS'); else:; raise ValidationError(""""""Orbital basis argument must be function that applies basis sets to Molecule or a string of the basis to be applied to all atoms.""""""). if aux is None or aux == '':; pass; elif callable(aux):; basstrings[fitrole] = aux(mol, fitrole); elif isinstance(aux, basestring):; mol.set_basis_all_atoms(aux, role=fitrole); else:; raise ValidationError(""""""Auxiliary basis argument must be function that applies basis sets to Molecule or a string of the basis to be applied to all atoms.""""""). # Not like we're ever using a non-G94 format; parser = Gaussian94BasisSetParser(). # Molecule and parser prepped, call the constructor; bs, msg = BasisSet.construct(parser, mol, fitrole, None if fitrole == 'BASIS' else fitrole, basstrings[fitrole]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:19482,clear,clear,19482,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,1,['clear'],['clear']
Usability,"ction capabilities. The; immediate solution, however, is to form symlinks between the; library names that exist and the names expected. Consult file; psi4/cmake/math/MathLibs.cmake for the library patterns being; sought.; The BLAS/LAPACK interface is standardized, so only libraries, not; headers, need to be detected. The exception is MKL, where the mkl.h; header defines additional functionality; it must be located to use; BLAS threading. How to configure Python for building Psi4¶; Role and Dependencies. Role — In PSI4, Python allows the core compiled C++ code to; be flexibly accessed for manipulation and extension in an interpreted; language.; Downstream Dependencies — PSI4 \(\Leftarrow\) Python Interpreter. CMake Variables; Note that in v1.4, PSI4 switched from Numpy-written CMake Python; detection to new CMake-written CMake Python detection. Usually only; Python_EXECUTABLE is now needed to hint Python’s location. See; https://cmake.org/cmake/help/latest/module/FindPython.html for full; guidance. Python_EXECUTABLE — specify name or full path to Python interpreter.; Python_LIBRARY — specify path to Python library.; Python_INCLUDE_DIR — specify directory of Python headers. Contains Python.h. Examples. Build with detected Python from PATH. >>> cmake. Build with specific Python. >>> cmake -DPython_EXECUTABLE=/path/to/interp/python3.9. Build with full Python specification to root directory ${PFXC}. >>> cmake -DPython_EXECUTABLE=""${PFXC}/bin/python"" \; -DPython_LIBRARY=""${PFXC}/lib/libpython3.9.so"" \; -DPython_INCLUDE_DIR=""${PFXC}/include/python3.9"". What Python is Psi4 running¶; The Python detected at build-time is embedded into the PSI4; executable. That is, the top line of bin/psi4 is something like; #!/path/to/miniconda/envs/p4deps/bin/python3.5, and that’s the Python; through which PSI4 is running, rather than the Python of which python.; To use a different Python with PSI4 in the short term, just; path/to/desired/python psi4 on the command line to override the; she",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:47358,guid,guidance,47358,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,9,['guid'],['guidance']
Usability,"cumented for particular databases the availability of the generic; database function options cp, rlxd, benchmark, and the string; options for subset. The full reagent member list, which can also be used; in conjunction with subset, is not included here for consideration of space; and may be found in the database file. The database Python files are very; readable and should be consulted for more particular questions. A24¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries from <Reference>.; Reference interaction energies from Rezac and Hobza, JCTC (in press). cp 'off' <erase this comment and after unless on is a valid option> || 'on'; rlxd 'off' <erase this comment and after unless on is valid option> || 'on'; benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. BBI¶. Database (Merz) of protein backbone-backbone interactions.; Geometries from Kenneth Merz Group, Univ. of Florida.; Reference interaction energies from Sherrill group, Georgia Tech.; Part of the BioFragment Database (BFDb). cp 'off' || 'on'; rlxd 'off'. BENCH12¶. Database of <description of members and reference energy type>.; Geometries from <Reference>.; Reference interaction energies from <Reference>. benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small'; 'large'; 'alkenes'; 'alkanes'; 'acenes'; 'thiophenes'; 'h2o_size'; 'h2o_shape'; 'atoms'; 'S22_HB'; 'S22_MX'; 'S22_DD'. O24by5mb¶. Database (O24) of interaction energies for small open-shell high-spin bimolecular complexes.; Geometries taken from https://gitlab.com/piotr.zuchowski/o24x5/-/tree/4ec3cae0546b6a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/db.html:12390,simpl,simple,12390,psi4manual/1.9.x/db.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/db.html,1,['simpl'],['simple']
Usability,"d CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. A PSI4 Tutorial; Psithon Tutorial: Using PSI4 as an Executable. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/tutorial.html:23096,clear,clear,23096,psi4manual/master/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/master/tutorial.html,1,['clear'],['clear']
Usability,"d as discussed; in Ref. [Saitow:2012]. Using the ADC(2) code¶; A complete list of keywords related to ADC(2) computations is provided in; Appendix ADC. Some sample inputs are provided in; psi4/samples, in directories starting with the name adc. The most; important keyword is ROOTS_PER_IRREP, which is an array; giving the number of excited states desired for each irreducible; representation. Implementation¶; Some very essential points are emphasized for understanding of the; nature and the limitations of the theory. The ADC(2) response matrix,; denoted as , is expanded in the single (S) and double (D); excitation manifolds as. where the superscript on each matrix block indicates the order of; the fluctuation. Instead of solving the above equation explicitly,; the large D manifold is treated effectively as. This form of the ADC(2) equation requires 7 – 10 iterations for; convergence on only one root. But thanks to Newton-Raphson; acceleration,. the computational time reduces to shorter than half of the simple iterative; procedure. Construction of the denominator of the second term in the above; equation is less computationally expensive than contruction of one $sigma$-vector with respect to the effective response matrix. The non-iterative excitation energy stated above is calculated as a diagonal element of the Davidson mini-Hamiltonian matrix in the SEM as,. where and denote the CIS; excitation energy and wave function, respectively. The explicit form of the; σ-vector is provided in a note accompanying the source code,; in the file psi4/src/bin/adc/sigma.pdf. Table Of Contents. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Previous topic; OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; Next topic; SAPT: Symmetry-Adapted Perturbation Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/adc-1.html:5912,simpl,simple,5912,psi4manual/4.0b3/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/adc-1.html,2,['simpl'],['simple']
Usability,"d as discussed; in Ref. [Saitow:2012]. Using the ADC(2) code¶; A complete list of keywords related to ADC(2) computations is provided in; Appendix ADC. Some sample inputs are provided in; psi4/samples, in directories starting with the name adc. The most; important keyword is ROOTS_PER_IRREP, which is an array; giving the number of excited states desired for each irreducible; representation. Implementation¶; Some very essential points are emphasized for understanding of the; nature and the limitations of the theory. The ADC(2) response matrix,; denoted as , is expanded in the single (S) and double (D); excitation manifolds as. where the superscript on each matrix block indicates the order of; the fluctuation. Instead of solving the above equation explicitly,; the large D manifold is treated effectively as. This form of the ADC(2) equation requires 7 – 10 iterations for; convergence on only one root. But thanks to Newton-Raphson; acceleration,. the computational time reduces to shorter than half of the simple iterative; procedure. Construction of the denominator of the second term in the above; equation is less computationally expensive than contruction of one $sigma$-vector with respect to the effective response matrix. The non-iterative excitation energy stated above is calculated as a diagonal element of the Davidson mini-Hamiltonian matrix in the SEM as,. where and denote the CIS; excitation energy and wave function, respectively. The explicit form of the; σ-vector is provided in a note accompanying the source code,; in the file psi4/src/bin/adc/sigma.pdf. Table Of Contents. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Previous topic; SAPT: Symmetry-Adapted Perturbation Theory; Next topic; Geometry Optimization; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/adc-1.html:5912,simpl,simple,5912,psi4manual/4.0b4/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/adc-1.html,2,['simpl'],['simple']
Usability,"d as discussed; in Ref. [Saitow:2012]. Using the ADC(2) code¶; A complete list of keywords related to ADC(2) computations is provided in; Appendix ADC. Some sample inputs are provided in; psi4/samples, in directories starting with the name adc. The most; important keyword is ROOTS_PER_IRREP, which is an array; giving the number of excited states desired for each irreducible; representation. Implementation¶; Some very essential points are emphasized for understanding of the; nature and the limitations of the theory. The ADC(2) response matrix,; denoted as , is expanded in the single (S) and double (D); excitation manifolds as. where the superscript on each matrix block indicates the order of; the fluctuation. Instead of solving the above equation explicitly,; the large D manifold is treated effectively as. This form of the ADC(2) equation requires 7 – 10 iterations for; convergence on only one root. But thanks to Newton-Raphson; acceleration,. the computational time reduces to shorter than half of the simple iterative; procedure. Construction of the denominator of the second term in the above; equation is less computationally expensive than contruction of one $sigma$-vector with respect to the effective response matrix. The non-iterative excitation energy stated above is calculated as a diagonal element of the Davidson mini-Hamiltonian matrix in the SEM as,. where and denote the CIS; excitation energy and wave function, respectively. The explicit form of the; σ-vector is provided in a note accompanying the source code,; in the file psi4/src/bin/adc/sigma.pdf. Table Of Contents. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Previous topic; SAPT: Symmetry-Adapted Perturbation Theory; Next topic; Geometry Optimization; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Theoretical",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/adc-1.html:5912,simpl,simple,5912,psi4manual/4.0b5/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/adc-1.html,2,['simpl'],['simple']
Usability,"d as discussed; in Ref. [Saitow:2012]. Using the ADC(2) code¶; A complete list of keywords related to ADC(2) computations is provided in; Appendix ADC. Some sample inputs are provided in; psi4/samples, in directories starting with the name adc. The most; important keyword is ROOTS_PER_IRREP, which is an array; giving the number of excited states desired for each irreducible; representation. Implementation¶; Some very essential points are emphasized for understanding of the; nature and the limitations of the theory. The ADC(2) response matrix,; denoted as , is expanded in the single (S) and double (D); excitation manifolds as. where the superscript on each matrix block indicates the order of; the fluctuation. Instead of solving the above equation explicitly,; the large D manifold is treated effectively as. This form of the ADC(2) equation requires 7 – 10 iterations for; convergence on only one root. But thanks to Newton-Raphson; acceleration,. the computational time reduces to shorter than half of the simple iterative; procedure. Construction of the denominator of the second term in the above; equation is less computationally expensive than contruction of one $sigma$-vector with respect to the effective response matrix. The non-iterative excitation energy stated above is calculated as a diagonal element of the Davidson mini-Hamiltonian matrix in the SEM as,. where and denote the CIS; excitation energy and wave function, respectively. The explicit form of the; σ-vector is provided in a note accompanying the source code,; in the file psi4/src/bin/adc/sigma.pdf. Table Of Contents. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Previous topic; SAPT: Symmetry-Adapted Perturbation Theory; Next topic; Scalar relativistic Hamiltonians. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a7",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/adc-1.html:5911,simpl,simple,5911,psi4manual/1.0.0/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/adc-1.html,2,['simpl'],['simple']
Usability,"d as discussed; in Ref. [Saitow:2012]. Using the ADC(2) code¶; A complete list of keywords related to ADC(2) computations is provided in; Appendix ADC. Some sample inputs are provided in; psi4/samples, in directories starting with the name adc. The most; important keyword is ROOTS_PER_IRREP, which is an array; giving the number of excited states desired for each irreducible; representation. Implementation¶; Some very essential points are emphasized for understanding of the; nature and the limitations of the theory. The ADC(2) response matrix,; denoted as , is expanded in the single (S) and double (D); excitation manifolds as. where the superscript on each matrix block indicates the order of; the fluctuation. Instead of solving the above equation explicitly,; the large D manifold is treated effectively as. This form of the ADC(2) equation requires 7 – 10 iterations for; convergence on only one root. But thanks to Newton-Raphson; acceleration,. the computational time reduces to shorter than half of the simple iterative; procedure. Construction of the denominator of the second term in the above; equation is less computationally expensive than contruction of one $sigma$-vector with respect to the effective response matrix. The non-iterative excitation energy stated above is calculated as a diagonal element of the Davidson mini-Hamiltonian matrix in the SEM as,. where and denote the CIS; excitation energy and wave function, respectively. The explicit form of the; σ-vector is provided in a note accompanying the source code,; in the file psi4/src/bin/adc/sigma.pdf. Table Of Contents. Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Previous topic; Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Next topic; Symmetry-Adapted Perturbation Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/adc-1.html:5887,simpl,simple,5887,psi4manual/4.0b2/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/adc-1.html,2,['simpl'],['simple']
Usability,"d retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; NumPy provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, PSI4 exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate PSI4 functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; Psi4NumPy repository. Avoiding the need to modify Psi4, using plugins¶; In the early days when PSI4 was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of PSI4, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of PSI4, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html:2465,simpl,simply,2465,psi4manual/1.4.0/prog_ways_to_add-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html,9,['simpl'],['simply']
Usability,"d to be high spin, i.e.; two doublets would interact to form a triplet. The S2 approximation and scaling¶; All exchange terms in SAPT arise from the antisymmetrization; of the wavefunctions of monomers A and B. Taking into account exchange of all possible; electron pairs between the two monomers yields to complicated formulae.; For this reason, exchange terms are often evaluated in the \(S^{2}\); approximation, that can be interpreted as the exchange of a single electron; pair between monomers.; The \(S^{2}\) approximation is usually pretty good, but may; break down for short intermolecular distance, particularly in high-order; terms. To compensate for these deviations, in 2014 Parker et al. [Parker:2014:094106]; recommended to scale all \(S^{2}\) approximated exchange terms by the ratio:. \[p_{EX}(\alpha) = \left( \frac{E_{exch}^{(10)}}{E_{exch}^{(10)}(S^{2})} \right)^{\alpha}\]; and recommended using the ratio with exponent \(\alpha = 1\). To obtain SAPT energies with this scaling,; simply set the keyword exch_scale_alpha true. Alternatively, another value for \(\alpha\); can be specified by setting EXCH_SCALE_ALPHA to a value. For example,; set exch_scale_alpha 1.0. will set \(\alpha = 1.0\) and scale exchange energies with \(p_{EX}(1.0)\).; However, as pointed out by Schaffer and Jansen [Schaffer:2013:2570]; in the context of DFT-based SAPT, the ratios \(E_{exch}^{(1)}(S^{2})/E_{exch}^{(1)}\),; \(E_{\rm exch-ind}^{(2)}(S^2)/E_{\rm exch-ind}^{(2)}\), and; \(E_{\rm exch-disp}^{(2)}(S^2)/E_{\rm exch-disp}^{(2)}\) are not very similar to; each other. Hence, in 2016 universal scaling of all \(S^{2}\) approximated terms; was turned off by default.; Finally, in 2014 Parker et al. [Parker:2014:094106] empirically discovered that; SAPT0 energies for van der Waals dimers with close contacts benefit from a slightly modified; recipe that involves an empirically adjusted exponent \(\alpha = 3.0\).; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/sapt.html:10464,simpl,simply,10464,psi4manual/1.9.x/sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/sapt.html,2,['simpl'],['simply']
Usability,"d) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet) → psi4.core.CUHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html:4207,simpl,simply,4207,psi4manual/1.3.2/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html,1,['simpl'],['simply']
Usability,"d) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet) → psi4.core.ROHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.rohf.html:4457,simpl,simply,4457,psi4manual/1.3.2/api/psi4.core.rohf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.rohf.html,1,['simpl'],['simply']
Usability,"da install gcp -c psi4 or the newer implementation; through conda install gcp-correction -c conda-forge.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; the gcp executable can be obtained through conda install gcp -c psi4; or conda install gcp-correction -c conda-forge.; To remove a conda installation, conda remove gcp or conda remove gcp-correction. Source. If using PSI4 built from source and you want to build gCP from; from source also, follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a Fortran compiler, and run make). To be used by PSI4, the program binary (gcp or mctc-gcp) must be; found in your PATH so that QCEngine can detect it. Check if and where; found through qcengine info. If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The interface; can use classic or mctc-gcp executables interchangeably and will prefer the latter.; A DFTD3 executable, classic or simple-dftd3,; must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; optimize('pbeh3c'). HF-3c with non-standard basis; set basis cc-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/gcp.html:1783,simpl,simply,1783,psi4manual/1.7.x/gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/gcp.html,2,['simpl'],['simply']
Usability,"da install gcp -c psi4 or the newer implementation; through conda install gcp-correction -c conda-forge.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; the gcp executable can be obtained through conda install gcp -c psi4; or conda install gcp-correction -c conda-forge.; To remove a conda installation, conda remove gcp or conda remove gcp-correction. Source. If using PSI4 built from source and you want to build gCP from; from source also, follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a Fortran compiler, and run make). To be used by PSI4, the program binary (gcp or mctc-gcp) must be; found in your PATH so that QCEngine can detect it. Check if and where; found through qcengine info. If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672], “PBEh-3c”; [Grimme:2015:054107], “B97-3c” [Brandenburg:2018:b973c], “r2SCAN-3c” [Grimme:2021:064103],; and “wB97X-3c” [Muller:2023:014103] methods (both energy and gradient).; The interface can use classic or mctc-gcp executables but only the latter implements “B97-3c” and “r2SCAN-3c”.; The newest wB97X-3c method doesn’t use a gcp correction (it does use ECPs down to first row elements); but is listed here for completeness of the “3c” family.; A DFTD3 executable, classic or simple-dftd3, must also be available for; the HF-3c, PBEh-3c, or B97-3c methods to run.; A DFTD4 python module must also be available for; the r2SCAN-3c or wB97X-3c methods to run.; These method are defined with their own basis set and thus no basis set should be set by the user.; PSI4 will select the intended basis sets: HF-3c/MINIX, PB",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/gcp.html:1912,simpl,simply,1912,psi4manual/1.9.x/gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/gcp.html,2,['simpl'],['simply']
Usability,"data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); (2, 0, 4). classmethod from_serial(json_data)¶; Converts serialized data to the correct Psi4 data type. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Vector, arg0: int) -> float. docstring. get(self: psi4.core.Vector, arg0: int, arg1: int) -> float. docstring. nirrep(self: psi4.core.Vector) → int¶; docstring. classmethod np_read(filename, prefix='')¶. np_write(filename=None, prefix='')¶. print_out(self: psi4.core.Vector) → None¶; docstring. scale(self: psi4.core.Vector, arg0: float) → None¶; docstring. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Vector, arg0: int, arg1: float) -> None. docstring. set(self: psi4.core.Vector, arg0: int, arg1: int, arg2: float) -> None. docstring. to_array(matrix, copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data)¶; Converts an object with a .nph accessor to a serialized dictionary. array_interface(self: psi4.core.Vector) → list. dim(self: psi4.core.Vector, arg0: int) → int; docstring. classmethod from_array(arr, name='New Matrix', dim1=None, dim2=None); Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Pa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html:3319,simpl,simply,3319,psi4manual/1.1.0/api/psi4.core.vector.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html,1,['simpl'],['simply']
Usability,"default_path('/scratch/user/'). For batch jobs running through a queue, it might be more convenient to use an; environmental variable (in this case $MYSCRATCH) to set the scratch directory;; the following code will do that:; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). Individual files can be send to specific locations. For example, file 32 is; the checkpoint file that the user might want to retain in the working directory; (i.e., where PSI4 was launched from) for restart purposes. This is; accomplished by the commands below:; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously.; To override any of these defaults for selected jobs, simply place the; appropriate commands from the snippets above in the input file itself. During; excecution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed. Executing PSI4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; psi4 -m. Alternately, the scratch directory can be set through the environment; variable PSI_SCRATCH (overrides ~/.psi4rc settings).; The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every PSI4 instance. Threading¶; Most new modules in PSI4 are designed to run efficiently on SMP architectures; via application of several thread models. The de facto standard for PSI4; involves using threaded BLAS/LAPACK (particularly Intel’s excellent MKL package); for most tensor-like operations, OpenMP for more general operations, and Boost; Threads for some special-case operations. Note: Using Op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/external-1.html:3287,simpl,simply,3287,psi4manual/4.0b2/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/external-1.html,2,['simpl'],['simply']
Usability,"defined here:; | ; | __instance_size__ = 368; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class ExternalPotential(Boost.Python.instance); | docstring; | ; | Method resolution order:; | ExternalPotential; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __init__(...); | __init__( (object)arg1) -> None; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | addBasis(...); | addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :; | docstring; | ; | addCharge(...); | addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :; | docstring; | ; | clear(...); | clear( (ExternalPotential)arg1) -> None :; | docstring; | ; | computePotentialMatrix(...); | computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :; | docstring; | ; | print_out(...); | print_out( (ExternalPotential)arg1) -> None :; | docstring; | ; | setName(...); | setName( (ExternalPotential)arg1, (str)arg2) -> None :; | docstring; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __instance_size__ = 32; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:17967,clear,clear,17967,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,6,['clear'],['clear']
Usability,"did something special to get it to; # converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; run_scf('scf', **kwargs). # If the scf type is DF, then the AO integrals were never generated; if PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; mints = PsiMod.MintsHelper(); mints.integrals(). PsiMod.set_global_option('DELETE_TEI', 'false'). while True:; PsiMod.transqt2(); PsiMod.ccsort(); returnvalue = PsiMod.ccenergy(); PsiMod.print_out('Brueckner convergence check: %d\n' % PsiMod.get_variable('BRUECKNER CONVERGED')); if (PsiMod.get_variable('BRUECKNER CONVERGED') == True):; break. return returnvalue. [docs]def run_bccd_t(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD(T) calculation. """"""; PsiMod.set_global_option('WFN', 'BCCD_T'); run_bccd(name, **kwargs). return PsiMod.cctriples(). [docs]def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """"""; run_scf(name, **kwargs). [docs]def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; oneel_properties = ['dipole', 'quadrupole']; twoel_properties = []; response_properties = ['polarizability', 'rotation', 'roa']; excited_properties = ['oscillator_strength', 'rotational_strength']. one = []; two = []; response = []; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs.pop('properties'); properties = drop_duplicates(properties). for prop in properties:; if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""The \""properties\"" keyword is required with the property() function.""). n_one = len(one); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:16177,simpl,simple,16177,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['simpl'],['simple']
Usability,"ding. Orbital Basis¶; Give the function a Molecule object for which to build basis, a label for; the basis (generally, BASIS), and a hint for finding the basis. This last; argument gets used to find a python function by that name camoflaged; (that’s what basis {...} blocks in the input file get translated into); or failing that a string to find a gbs file defining the basis.; // simple; boost::shared_ptr<BasisSet> primary = BasisSet::pyconstruct_orbital(molecule,; ""BASIS"", ""CC-PVDZ"");. // self-contained; boost::shared_ptr<BasisSet> primary = BasisSet::pyconstruct_orbital(Process::environment.molecule(),; ""BASIS"", Process::environment.options.get_str(""BASIS""));. Auxiliary Basis¶; Give the function a Molecule object for which to build basis, a label for; the basis, a hint for finding the basis, a fitting role to apply if; defaults need to be generated, and a hint for finding the orbital basis to; build defaults against.; // simple; boost::shared_ptr<BasisSet> auxiliary = BasisSet::pyconstruct_auxiliary(molecule,; ""DF_BASIS_SCF"", """",; ""JKFIT"", ""CC-PVDZ"");. // self-contained and force Spherical; boost::shared_ptr<BasisSet> auxiliary = BasisSet::pyconstruct_auxiliary(Process::environment.molecule(),; ""DF_BASIS_SCF"", Process::environment.options.get_str(""DF_BASIS_SCF""),; ""JKFIT"", Process:environment.options.get_str(""BASIS""), 1);. Adding Basis Option to Code¶. Register new basis keyword with psi4/src/bin/psi4/read_options.cc; (of course). The default should be the empty string.; options.add_str(""DF_BASIS_ELST"", """");. Register new basis keyword with the input parser; psi4/share/python/inputparser.py. In the main function; process_input, add it to the regex below. This ensures that users can; define basis_keyword basis_name {...} blocks where the contents of; the block get associated with basis_name and assigned to your; basis_keyword.; basis_block = re.compile(r'^(\s*?)(basis|df_basis_scf|df_basis_mp2|df_basis_cc|df_basis_sapt)[=\s]*(\w*?)\s*\{(.*?)\}',; re.MULTILINE | re.D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/prog_basissets-1.html:3359,simpl,simple,3359,psi4manual/1.0.0/prog_basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/prog_basissets-1.html,2,['simpl'],['simple']
Usability,"drew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supporte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/mrcc-1.html:1223,simpl,simply,1223,psi4manual/4.0b2/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html,8,['simpl'],['simply']
Usability,"ds are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. # Establish method for reference energy; if do_corl and cbs_corl_wfn.startswith('c4-'):; default_scf = 'c4-hf'; else:; default_scf = 'hf'; cbs_scf_wfn = kwargs.pop('scf_wfn', default_scf).lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # ... resume correlation logic; if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:39548,resume,resume,39548,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['resume'],['resume']
Usability,"ds used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be provided; in the molecule block. If two integers are encountered on any line of the; molecule block, they are interpreted as the molecular charge and multiplicity; (), respectively. The symmetry can be specified by a line reading; symmetry symbol, where symbol is; the Schönflies symbol of the (Abelian) point group to use for the; computation; see Sec. Symmetry for more details. This need not be; specified, as the molecular symmetry is automatically detected by PSI4.; Certain computations require that the molecule is not reoriented; this can be; achieved by adding either no_reorient or noreorient. By default,; Ångström units are used; this is changed by adding a line that reads; units spec, where spec is one of ang,; angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] datab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html:6745,simpl,simplified,6745,psi4manual/4.0b3/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html,2,['simpl'],['simplified']
Usability,"dules are now libraries, not separate executables, which are; linked into the main Psi executable. The single-executable design is; conducive to code reuse, as it allows common tasks to be implemented as a; class instead of a module; the functionality can then be easily obtained; throughout the code by creating objects as required. Examples of this are; the LibMints class, which provides similar functionality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is made, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, Psi4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; Psi4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, Psi4 will complain.; >>> psi4 --new-plugin myplugin. Psi4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory and type make. Then execute; psi4 in the directory on the de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:1571,learn,learn,1571,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,2,['learn'],['learn']
Usability,"dules are now libraries, not separate executables, which are; linked into the main Psi executable. The single-executable design is; conducive to code reuse, as it allows common tasks to be implemented as a; class instead of a module; the functionality can then be easily obtained; throughout the code by creating objects as required. Examples of this are; the LibMints class, which provides similar functionality to the old cints; module, and LibTrans, which replaces the old transqt code. When codes are; wrapped in a library, they should be placed into psi4/src/lib, and; codes that resemble modules belong in psi4/src/bin.; The single-executable design leads to a somewhat cumbersome development; cycle, since every time a change is make, one must compile the code,; archive it into a library, and then re-link the code into the main; executable. It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with previous versions due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. To be able to use plugins, you should compile; your source code with the --with-plugins flag passed to configure;; this will enable loading of plugins at runtime. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --new-plugin myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:1549,learn,learn,1549,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,8,['learn'],['learn']
Usability,"e :; | d get(N3psi6VectorE {lvalue},i); | ; | get( (Vector)arg1, (int)arg2, (int)arg3) -> float :; | docstring; | ; | C++ signature :; | d get(N3psi6VectorE {lvalue},i,i); | ; | nirrep(...); | nirrep( (Vector)arg1) -> int :; | docstring; | ; | C++ signature :; | i nirrep(N3psi6VectorE {lvalue}); | ; | print_out(...); | print_out( (Vector)arg1) -> None :; | docstring; | ; | C++ signature :; | void print_out(N3psi6VectorE {lvalue}); | ; | scale(...); | scale( (Vector)arg1, (float)arg2) -> None :; | docstring; | ; | C++ signature :; | void scale(N3psi6VectorE {lvalue},d); | ; | set(...); | set( (Vector)arg1, (int)arg2, (float)arg3) -> None :; | docstring; | ; | C++ signature :; | void set(N3psi6VectorE {lvalue},i,d); | ; | set( (Vector)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :; | docstring; | ; | C++ signature :; | void set(N3psi6VectorE {lvalue},i,i,d); | ; | to_array(matrix, copy=True, dense=False); | Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; | consturcts a view.; | ; | ----------------------------------------------------------------------; | Class methods defined here:; | ; | from_array = array_to_matrix(self, arr, name='New Matrix', dim1=None, dim2=None) from Boost.Python.class; | Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list).; | ; | Parameters; | ----------; | arr : array or list of arrays; | Numpy array or list of arrays to use as the data for a new psi4.Matrix; | name : str; | Name to give the new psi4.Matrix; | dim1 : list, tuple, or psi4.Dimension (optional); | If a single dense numpy array is given, a dimension can be supplied to; | apply irreps to this array. Note that this discards all extra information; | given in the matrix besides the diagonal blocks determined by the passed; | dimension.; | dim2 :; | Same as dim1 only if using a Psi4.Dimension object.; | ; | Returns; | -------; | ret : psi4.Vector or psi4.Matrix; | Returns the given Psi4 object ; | ; | Notes; | ----",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:641120,simpl,simply,641120,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['simpl'],['simply']
Usability,"e CUBIC can be still used and is equivalent to VPT2) generates all cubic constants and all quartic constants apart from those of the form , which is enough for: 1) generation of cubic constants of isotopologs (see manual entries associated with anharmonic calculations for an example); 2) calculation of vibrational energy levels with VPT2. This keyword also directs the program to analyze resonances and calculate intensities of one- and two-quantum transitions. FULLQUARTIC (=2) (not part of the public release) is largely self-explanatory; it directs the program to calculate all quartic constants. This is sufficient (but this has not been implemented) to generate the full quartic force field of all isotopologs. Type: string; Possible Values: CUBIC, VPT2, FULLQUARTIC, VIBROT, OFF; Default: OFF. CFOUR_ANH_ALGORITHM¶. Specifies which algorithm is used for CFOUR_ANHARMONIC =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations being done in series. If PARALLEL (=1), then the job stops after the second-derivative calculation at the reference geometry and generates out all input geometries for the remaining calculation. These can be then processed in “parallel” (currently not recommended). Note that it is recommended to carry out all calculations with PARALLEL, even when the actual calculation is carried out in a sequential mode. Type: string; Possible Values: STANDARD, PARALLEL; Default: STANDARD. CFOUR_ANH_DERIVATIVES¶. Specifies whether the anharmonic force field is calculated using analytic gradients (=FIRST) or analytic Hessians (=SECOND). Type: string; Possible Values: FIRST, SECOND; Default: SECOND. CFOUR_ANH_STEPSIZE¶. Controls the stepsize used in anharmonic force field calculations. The value is specified in reduced normal coordinates, which are dimensionless. The actual stepsize used in the calculation is the integer value specified. Type: inte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:3247,simpl,simply,3247,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['simpl'],['simply']
Usability,"e SOLVER_MAX_SUBSPACE, especially if you solve; for a large number of roots. This will result in a higher computational cost of each iteration, but should; make the solver better behaved. However, note that SOLVER_MAX_SUBSPACE should never be larger than; the full subspace minus the number of desired roots to avoid adding artificial zero eigenvalues.; This may happen in minimal basis sets, especially with symmetry, but the code automatically adjusts; SOLVER_MAX_SUBSPACE if it is too large.; If the solver seems to converge on the wrong eigenvalue, try increasing SOLVER_N_GUESS.; Otherwise, if the solver is almost converged but reaches the maximum number of iterations, try increasing; SOLVER_MAXITER. Effective core potentials (ECPs)¶; PSI4 supports the use of effective core potentials to describe the; innermost electrons in heavy elements.; ECPs are only available if PSI4 is compiled with the LibECPInt library.; If a basis set is designed to use an; effective core potential, the ECP definition should be simply placed alongside; the orbital basis set definition, c.f. Inputting effective core potentials (ECPs). All; information related to the definition and number of core electrons will; automatically be detected and no further input is required to use the; ECP-containing basis set. See scf-ecp and dfmp2-ecp; for examples of computations with ECP-containing basis sets. Warning; Prior to May 2022, v1.6, Psi4 used a built-in ECP code. Analytic derivatives of ECPs were not available. The HF and DFT derivatives were implemented in a semi-numerical scheme, where numerical ECP gradients were added to analytic SCF gradients. For post-SCF methods, the entire gradient computation needed to be run as finite difference of energies. Warning; As of May 2022, v1.6, Psi4 uses the LibECPInt library, and analytic derivatives and Hessians of ECPs are available. Analytic derivatives of molecular systems including ECPs should be available whenever the method has analytic derivatives, but t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/scf.html:42659,simpl,simply,42659,psi4manual/1.6.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/scf.html,1,['simpl'],['simply']
Usability,"e ValidationError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(""""""CBS gufunc: Too many brackets given! %s """""" % method_str). if method_str.count('/') != 1:; raise ValidationError(""""""CBS gufunc: All methods must specify a basis with '/'. %s"""""" % method_str). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; A text based wrapper of the CBS function. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; func : function; Function to be called (energy, gradient, frequency or cbs).; total_method_name : str; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.cbs`. Returns; -------; tuple or float; Float, or if ``return_wfn`` is specified, a tuple of ``(value, wavefunction)``.; """""". # Catch kwarg issues for all methods; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:63099,simpl,simple,63099,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['simpl'],['simple']
Usability,"e Z at (x,y,z). clear(self); Reset the field to zero (eliminates all entries). computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None; Add a charge Z at (x,y,z). clear(self: psi4.core.ExternalPotential) → None; Reset the field to zero (eliminates all entries). computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix; Compute the external potential matrix in the given basis set. print_out(self: psi4.core.ExternalPotential) → None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None; Sets the name. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.externalpotential.html:1745,clear,clear,1745,psi4manual/1.2.1/api/psi4.core.externalpotential.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.externalpotential.html,1,['clear'],['clear']
Usability,"e applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. [2]This applies to properties computed through the property() function. [3]Post-HF methods that do not rely upon the usual 4-index AO integrals use a density-; fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; He; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('scf'). Table Of Contents. HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Sta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/scf-1.html:20798,simpl,simple,20798,psi4manual/4.0b3/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/scf-1.html,2,['simpl'],['simple']
Usability,"e convergence settings,; if these are not a vital part of the test. In choosing the number of; digits for compare_values() and other compare_* functions,; select a number looser than the convergence set in the test or the; default convergence for the calculation type (energy, gradient, etc.). Adding PsiAPI Test Cases¶; Sometimes you want to add tests that check several variations of a; template job or that test error handling or that are PsiAPI rather than; PSIthon focused. In these cases, you’ll want to add to the second test; suite that lives at psi4/tests/pytests. Presently, the “normal”; (everything in the tests/ directory that isn’t in tests/pytests/); are run through ctest, while the pytests are run through pytest. In; future, all will be run through Pytest, but the former will still be; run as PSIthon (psi4 input.dat) while the latter will still be; run as PsiAPI (import psi4). In other words, in designing a test,; choose its mode based on whether PSIthon or PsiAPI suits it better and; whether it’s a simple model for users (probably PSIthon) or for expert; users (probably PsiAPI). Both will continue to work in future.; In developing a Pytest test, you probably want to edit it in place,; rather than running make after each change. Easiest is from; <objdir>, run pytest ../tests/pytests. Add any filters (-k; test_name_fragment) or parallelism (-n <N> if pytest-xdist; installed) or print test names (-v) or print warnings (-rws). To; see stdout output from an otherwise passing test, easiest to add assert; 0 at its end to trigger failure. An important point is that because; they’re PsiAPI, import psi4 is happening, so the <objdir> PSI4; module must be in PYTHONPATH. Also, any call to QCEngine is; using which psi4, so the <objdir> PSI4 executable must be in; PATH. The easiest way to prepare your local environment is to; execute the printout of <objdir>/stage/bin/psi4 --psiapi. Test must be in the psi4/tests/pytests/ directory.; Test file name must start with test_. T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/add_tests-1.html:4087,simpl,simple,4087,psi4manual/1.4.0/add_tests-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/add_tests-1.html,4,['simpl'],['simple']
Usability,"e density-fitted calculation, or similar.; * ```treatment```: treat extrapolation stage as ```scf``` or ```corl```, by default only the first stage is ```scf``` and every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:33163,simpl,simple,33163,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,5,['simpl'],['simple']
Usability,"e density-fitted calculation, or similar.; * ```treatment```: treat extrapolation stage as ```scf``` or ```corl```, by default only the first stage is ```scf``` and every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:45372,simpl,simple,45372,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['simpl'],['simple']
Usability,"e developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; 1; 2set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1; 3 1.000000. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; 1; 2; 3; 4F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; 1; 2; 3; 4F 1 3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:10045,simpl,simplest,10045,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,18,['simpl'],"['simple', 'simplest', 'simply']"
Usability,"e example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; 1; 2; 3; 4; 5; 6; 7CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. A PSI4 Tutorial. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:23277,clear,clear,23277,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,2,['clear'],['clear']
Usability,"e following and re-run.\n\n""; msg += ""\t Chemical ID IUPAC Name\n\n""; for result in results:; msg += ""%s"" % (result); if result.name().lower() == string.lower():; #We've found an exact match!; return result.getMoleculeString(); return msg. def process_molecule_command(matchobj):; """"""Function to process match of ``molecule name? { ... }``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); geometry = matchobj.group(3); geometry = pubchemre.sub(process_pubchem_command, geometry); from_filere = re.compile(r'^(\s*from_file\s*:\s*(.*)\n)$', re.MULTILINE | re.IGNORECASE); geometry = from_filere.sub(process_from_file_command, geometry); molecule = spaces. if name != """":; if sys.version_info >= (3, 0):; if not name.isidentifier():; raise ValidationError('Molecule name not valid Python identifier: ' + name); else:; if not re.match(r'^[^\d\W]\w*\Z', name):; raise ValidationError('Molecule name not valid Python identifier: ' + name). molecule += 'core.efp_init()\n' # clear EFP object before Molecule read in; molecule += spaces. if name != """":; molecule += '%s = ' % (name). molecule += 'geometry(""""""%s""""""' % (geometry); if name != """":; molecule += ',""%s""' % (name). molecule += "")\n""; molecule += '%score.IO.set_default_namespace(""%s"")' % (spaces, name). return molecule. def process_literal_blocks(matchobj):; """"""Function to process match of ``literals_psi4_yo-...``.""""""; return literals[matchobj.group(1)]. def process_cfour_command(matchobj):; """"""Function to process match of ``cfour name? { ... }``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); cfourblock = matchobj.group(3). literalkey = str(uuid.uuid4())[:8]; literals[literalkey] = cfourblock; return ""%score.set_global_option(\""%s\"", \""\""\""%s\n\""\""\"")\n"" % \; (spaces, 'LITERAL_CFOUR', 'literals_psi4_yo-' + literalkey). def process_extract_command(matchobj):; """"""Function to process match of ``extract_subsets``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); result = matchobj.group(0); result += '%s%s.s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/inputparser.html:8217,clear,clear,8217,psi4manual/1.2.1/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/inputparser.html,1,['clear'],['clear']
Usability,"e is aware of it; unless cc’d), are brought up at workshops (where people may be absent, no; record is left, and not everyone may have prepared a position on the; topic), or agreed between a couple people over g-chat (others remain; unaware of plans), or planned by someone (who may not have committed those; plans to a ticket or who wants general approval before restructuring the; code). Path of a PsiPEP¶. Someone creates a file psi4/doc/sphinxman/source/pepXXXX.rst modeled; on psi4/doc/sphinxman/source/pep0000model.rst and adds; it to STATICDOC in psi4/doc/sphinxman/Makefile.in. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/pep0001-1.html:1556,simpl,simple,1556,psi4manual/1.1.0/pep0001-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/pep0001-1.html,14,['simpl'],['simple']
Usability,"e of computation intended, find appropriate options at; Keywords. These keyword summaries contain the same; information as the proper CFOUR options list; plus notes on keyword relevance when run through PSI4. Information; at the CFOUR manual may; also be useful, as may the many samples at psi4/samples/cfour.; Set Cfour keywords just like PSI4 keywords. The names of keywords; are unchanged beyond a prepended “cfour_”. (Though be aware that common; abbreviations like CALC and REF must be fully spelled out as; CFOUR_CALC_LEVEL and CFOUR_REFERENCE when used in; PSI4.); In limited trial cases, keywords nominally directed at non-Cfour modules; are translated into their Cfour counterparts. For example, setting; REFERENCE will appropriately set CFOUR_REFERENCE. For a; list of applicable keywords, see source of; muster_psi4options.; Consult Functionality for information on what Cfour; functionality is accessible through PSI4. PSI4 for Cfour Users¶; In the simplest use of the Psi4/Cfour interface, a PSI4 input file; can simply “wrap” a ZMAT file and execute xcfour. This is; illustrated in the following example:; cfour {; UHF-SCF energy calculation; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0. *ACES2(CALC=HF,BASIS=qz2p; MULT=2,REF=UHF; OCCUPATION=3-1-1-0/3-0-1-0; SCF_CONV=12; MEMORY=20000000); }. energy('cfour'). Here, the contents of the cfour {...} block are written directly to a; ZMAT file. This is joined by a default GENBAS file; (psi4/psi4/share/psi4/basis/GENBAS). To preferentially use your own GENBAS,; place it in PATH or PSIPATH. The line calling; energy() with argument 'cfour' invokes; xcfour.; After execution of the energy('cfour') line completes, Cfour results; are read back into PSI4 format and are thereafter accessible for; further processing in the input file. See Output for; details. This storage of results in variables and arrays in memory for; the duration of the PSI4 instance (as opposed to solely in files); is the only advantage thus far incurred by the P4C4 interf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:2907,simpl,simplest,2907,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,18,['simpl'],"['simplest', 'simply']"
Usability,"e the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not; all the electrons are paired. For example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not correct, so we need to tell the program the true value (3). Like; many programs, Psi4 can get the charge and multiplicity as the first two; integers in the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:4163,simpl,simple,4163,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['simpl'],['simple']
Usability,"e the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; The division of the molecular orbitals into various subspaces such as; RAS spaces, or frozen vs. active orbitals, etc., needs to be clear not; only to detci, but also at least to the transformation program; (and in the case of MCSCF, to other programs as well). Thus, orbital; subspace keywords such as RAS1,; RAS2, RAS3, FROZEN_DOCC,; FROZEN_UOCC,; ACTIVE, etc., should be set; in the global section of input so they may also be read by other modules.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. Higher order; single-refernce CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specifed by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Basic DETCI Keywords¶. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF; Default: RHF. R",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/detci-1.html:4296,simpl,simply,4296,psi4manual/1.0.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/detci-1.html,2,['simpl'],['simply']
Usability,"e verbose; std::vector<std::pair<double, std::array<double, 3>>> type instead, to be; consistent with Libint2’s convention. New Operators Available¶; Libint2 provides a range of integrals that were previously not available in; PSI4, such as the Erfc attenuated nuclear potential integrals needed for; Ewald methods. If new integrals are added to Libint2 but are not yet; interfaced to PSI4, please open an issue on the PSI4 GitHub page to; alert the developers, who will be able to add the appropriate code.; Available integrals classes and parameters currently documented at; Libint2 C++11 Interface Wiki. Shell Pairs¶; To ensure consistency between one- and two-electron terms when screening, and; for efficiency reasons, shell pair lists should be used to iterate over pairs; of Gaussian shells. These lists contain integer pair numbers, corresponding to; the pairs of shells that have sufficient overlap to survive the screening; process. Iterating over these lists is simple:; const auto& shell_pairs = Vint->shellpairs();; size_t n_pairs = shell_pairs.size();; for (size_t p = 0; p < n_pairs; ++p) {; auto P = shell_pairs[p].first;; auto Q = shell_pairs[p].second;; // do something with shells P and Q; }. Note that list considers all P,Q pairs if the two basis sets differ, but only; P>=Q if the basis sets are the same; the caller should account for this; restricted summation in the latter case. One Electron Integral Algorithm Overview¶; The following table summarizes which implementation is used; for each type of one electron integral in PSI4. Algorithms used for One Electron Integrals¶. Integral; Class; Implementation; Comment. Three-Center Overlap; ThreeCenterOverlapInt; Libint2; using libint2::Operator::delta for 4-center integrals. Angular Momentum; AngularMomentumInt; M-D. Dipole; DipoleInt; Libint2; no derivatives supported. Electric Field; ElectricFieldInt; Libint2; using first derivative of libint2::Operator::nuclear. Coulomb Potential; ElectrostaticInt; Libint2; evaluat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/prog_integrals.html:17003,simpl,simple,17003,psi4manual/1.6.x/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html,5,['simpl'],['simple']
Usability,"e, or core.Dimension (optional)) – If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 – Same as dim1 only if using a Psi4.Dimension object. Returns:matrix – Returns the given Psi4 object. Return type:Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; 1; 2>>> data = np.random.rand(20); >>> vector = array_to_matrix(data). 1; 2; 3; 4>>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); (2, 0, 4). Matrix to Array¶; A general function that converts NumPy arrays to PSI4 data objects. psi4.driver.p4util.numpy_helper._to_array(matrix, copy=True, dense=False)[source]¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. table of contents. Interface to NumPy; Basics; NumPy Views; PSI4 Data Objects with Irreps; Array to Matrix; Matrix to Array. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/numpy-1.html:4508,simpl,simply,4508,psi4manual/1.1.0/numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/numpy-1.html,2,['simpl'],['simply']
Usability,"e,; triple, or aromatic bonding motifs when partitioning the molecule into fragments; – cuts across only simple sigma bonds are encouraged. Caution; November 2022, previous to QCEngine v0.26.0 and Psi4; v1.7.0, there was a scaling inconsistency in the pairwise analysis; such that 2-BODY PAIRWISE DISPERSION CORRECTION ANALYSIS; was doubled when generated from dftd3 compared to the output from other; programs (s-dftd3 and dftd4). This shows up in the QCVariable and in the; Empirical_Disp.dat file written during energy(""fisapt0-d3"") (all; -D3 variants). Fortunately, the fsapt.py script compensated; for dftd3 (by far the most used program for this task). Users of the; pairwise analysis should take care to use the new QCEngine; AND fsapt.py script distributed with NEW Psi4. fisapt0-d4 run; with previous Psi4/fsapt.py will be wrong. fisapt0-d3 run with previous; Psi4/fsapt.py but new QCEngine will be wrong. If you’ve got legacy; calculations, it is extremely easy to check or reanalyze them to; salvage them, so please contact the developers with the circumstances; for guidance. Order-1 Visualization with PyMol¶; The fsapt.py script above also generates a number of order-1 .pdb files; that can be used to get a quick qualitative picture of the F-SAPT partition. The; preferred way to do this is to use PyMol to make plots of the molecular geometry; with the atoms colored according to their order-1 F-SAPT contributions. We have; a set of template .pymol scripts to help with this process. These can be; obtained by running:; >>> copy_pymol.py. and then in PyMol:; >>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; Elst.pymol), which in turn load in the molecule and order-1 analysis; (contained in the .pdb file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some specific; details of the .pymol files require some small tweaks to permit; publication-quality renderings. Difference F-SAPT Analysis¶; Fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/fisapt.html:7815,guid,guidance,7815,psi4manual/1.7.x/fisapt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/fisapt.html,4,['guid'],['guidance']
Usability,"e.Matrix, arg0: float) → None¶; docstring. scale_column(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float) → None¶; docstring. scale_row(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float) → None¶; docstring. schmidt(self: psi4.core.Matrix) → None¶. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Matrix, arg0: float) -> None. docstring. set(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float) -> None. docstring. set(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int, arg3: float) -> None. docstring. set(self: psi4.core.Matrix, arg0: list) -> None. docstring. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → None¶; docstring. sum_of_squares(self: psi4.core.Matrix) → float¶; docstring. symmetrize_gradient(self: psi4.core.Matrix, arg0: psi::Molecule) → None¶; docstring. symmetry(self: psi4.core.Matrix) → int¶; docstring. to_array(matrix, copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data)¶; Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float¶; docstring. transform(*args, **kwargs)¶; Overloaded function. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:8617,simpl,simply,8617,psi4manual/1.1.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html,1,['simpl'],['simply']
Usability,"e.Vector¶; Get a vector block. nirrep(self: psi4.core.Vector) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. print_out(self: psi4.core.Vector) → None¶; Prints the vector to the output file. scale(self: psi4.core.Vector, sc: float) → None¶; Scales the elements of a vector by sc. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None¶; Set a vector block. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. array_interface(self: psi4.core.Vector) → list. dim(self: psi4.core.Vector, h: int) → int; Returns the dimensions of the vector per irrep h. classmethod from_array(arr, name='New Matrix', dim1=None, dim2=None); Converts a numpy array or list of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.vector.html:4212,simpl,simply,4212,psi4manual/1.2.1/api/psi4.core.vector.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.vector.html,1,['simpl'],['simply']
Usability,"e.Vector¶; Get a vector block. nirrep(self: psi4.core.Vector) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. print_out(self: psi4.core.Vector) → None¶; Prints the vector to the output file. scale(self: psi4.core.Vector, sc: float) → None¶; Scales the elements of a vector by sc. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None¶; Set a vector block. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. array_interface(self: psi4.core.Vector) → list. dim(self: psi4.core.Vector, h: int=0) → int; Returns the dimensions of the vector per irrep h. dimpi(self: psi4.core.Vector) → psi4.core.Dimension; Returns the Dimension object. classmethod from_array(arr, nam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.vector.html:4327,simpl,simply,4327,psi4manual/1.3.2/api/psi4.core.vector.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.vector.html,1,['simpl'],['simply']
Usability,"e: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:57183,simpl,simple,57183,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['simpl'],['simple']
Usability,"e; docstring. scale_column(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float) → None; docstring. scale_row(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float) → None; docstring. schmidt(self: psi4.core.Matrix) → None. set(*args, **kwargs); Overloaded function. set(self: psi4.core.Matrix, arg0: float) -> None. docstring. set(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float) -> None. docstring. set(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int, arg3: float) -> None. docstring. set(self: psi4.core.Matrix, arg0: list) -> None. docstring. shape; Shape of the Psi4 data object. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → None; docstring. sum_of_squares(self: psi4.core.Matrix) → float; docstring. symmetrize_gradient(self: psi4.core.Matrix, arg0: psi::Molecule) → None; docstring. symmetry(self: psi4.core.Matrix) → int; docstring. to_array(matrix, copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data); Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float; docstring. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) -> N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:15334,simpl,simply,15334,psi4manual/1.1.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html,1,['simpl'],['simply']
Usability,"e; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; 1; 2set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1; 3 1.000000. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; 1; 2; 3; 4F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:9965,simpl,simple,9965,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,6,['simpl'],['simple']
Usability,"e]¶; Whether the current atom is ghosted or not. label()[source]¶; The atom label. mass()[source]¶; The atomic mass of the current atom. static r(a1, a2)[source]¶; Computes the distance between two sets of coordinates. set_basisset(name, role='BASIS')[source]¶; Set the basis for this atom; * @param type Keyword from input file, basis, ri_basis, etc.; * @param name Value from input file. set_ghosted(gh)[source]¶; Flag the atom as either ghost or real. set_shell(bshash, key='BASIS')[source]¶; Set the hash for this atom; * @param key Keyword from input file, basis, ri_basis, etc.; * @param bshash hash string of one-atom BasisSet. shell(key='BASIS')[source]¶; Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. shells()[source]¶; Returns shells sets to atom map. symbol()[source]¶; The atomic symbol. class CoordValue(fixed=False, computed=False)[source]¶; An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. everything()[source]¶. fixed()[source]¶; Get whether the coordinate value is fixed or not. invalidate()[source]¶; Flag the current value as outdated. set_fixed(fixed)[source]¶; Set whether the coordinate value is fixed or not. class NumberValue(value, fixed=False)[source]¶; Specialization of CoordValue that is simply a number to be stored. clone()[source]¶; Returns new, independent NumberValue object. compute()[source]¶; Computes value of coordinate from member data. everything()[source]¶. rset(val)[source]¶; Resets value of coordinate if not fixed. type()[source]¶; Gets specialization type of CoordValue. variable_to_string(precision)[source]¶; Takes a CoordValue object, and returns a string for printing. class VariableValue(name, geometryVariables, negate=False, fixed=False)[source]¶; Specialization of CoordValue, where the current value depends; on the list",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:116448,simpl,simplifying,116448,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['simpl'],['simplifying']
Usability,"e_alpha true. Alternatively, another value for \(\alpha\); can be specified by setting EXCH_SCALE_ALPHA to a value. For example,; 1set exch_scale_alpha 1.0. will set \(\alpha = 1.0\) and scale exchange energies with \(p_{EX}(1.0)\).; Instead of this straightforward scaling, SAPT0 energies benefit from a slightly modified; recipe that involves an empirically adjusted exponent \(\alpha = 3.0\).; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]). (8)¶\[E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)}; + \delta_{HF}^{(2)}\]; where \(\delta_{HF}^{(2)}\) is computed without any scaling. Please note that; sSAPT0 is thus not the same as requesting exch_scale_alpha 3.0, and that the; scaling is automatically performed by requesting energy('ssapt0'). A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis aug-cc-pvdz. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interacti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:8309,simpl,simplest,8309,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,6,['simpl'],['simplest']
Usability,"e_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :. docstring; C++ signature :. void set_enable_pybuffer(N3psi12TwoBodyAOIntE {lvalue},b). ExternalPotential¶. psi4.ExternalPotential.addBasis()¶; Python Library Documentation: method addBasis; addBasis(...) unbound psi4.ExternalPotential method. addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :. docstring; C++ signature :. void addBasis(N3psi17ExternalPotentialE {lvalue},N5boost10shared_ptrIN3psi8BasisSetEEE,N5boost10shared_ptrIN3psi6VectorEEE). psi4.ExternalPotential.addCharge()¶; Python Library Documentation: method addCharge; addCharge(...) unbound psi4.ExternalPotential method. addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :. docstring; C++ signature :. void addCharge(N3psi17ExternalPotentialE {lvalue},d,d,d,d). psi4.ExternalPotential.clear()¶; Python Library Documentation: method clear; clear(...) unbound psi4.ExternalPotential method. clear( (ExternalPotential)arg1) -> None :. docstring; C++ signature :. void clear(N3psi17ExternalPotentialE {lvalue}). psi4.ExternalPotential.computePotentialMatrix()¶; Python Library Documentation: method computePotentialMatrix; computePotentialMatrix(...) unbound psi4.ExternalPotential method. computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE computePotentialMatrix(N3psi17ExternalPotentialE {lvalue},N5boost10shared_ptrIN3psi8BasisSetEEE). psi4.ExternalPotential.print_out()¶; Python Library Documentation: method print_out; print_out(...) unbound psi4.ExternalPotential method. print_out( (ExternalPotential)arg1) -> None :. docstring; C++ signature :. void print_out(N3psi17ExternalPotentialE {lvalue}). psi4.ExternalPotential.setName()¶; Python Library Documentation: method setName; setName(...) unbound psi4.ExternalPotential method. setName( (ExternalPotential)arg1, (str)arg2) -> None :. docstring; C++ signature :. v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:135573,clear,clear,135573,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['clear'],['clear']
Usability,"ebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 or -D4 corrections and their variants are; available only through the DFTD3 or DFTD4 programs. Once installed, the; dftd3/PSI4 and dftd4/PSI4 interfaces are transparent, and all corrections are; interfaced exactly alike.; The -D3 interface can use classic or simple-dftd3 programs interchangeably and will prefer the latter.; Starting in v1.9, the classic program is no longer supported or tested, though it isn’t deliberately disabled.; Despite different defaults in these programs when run independently,; when run through PSI4 as EmpiricalDispersion engine, each should; produce the same result. Moreover, PSI4‘s own defaults and aliases; are unchanged by the new engines, so -D continues to mean -D2,; -D3 continues to mean zero-damping without 3-body correction,; and input files should continue producing the same results. Please file; an issue if found otherwise.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, a B3LYP-D3 (zero-damping), and a B3LYP-D4 (Becke-Johnson damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'); energy('b3lyp-d4'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2.; No text output is available from the dftd4 or s-dftd3 programs. Variants of dispersion corrections¶. Extension [1] and Aliases; Variant; Computing Program (engine); DFT_DISPERSION_PARAMETERS [11]. -D; alias to -D2. -D1; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/dftd3.html:7205,simpl,simple,7205,psi4manual/1.9.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/dftd3.html,2,['simpl'],['simple']
Usability,"ecial options for lower method in a given stage. This is useful to calculate a direct stage in an otherwise density-fitted calculation, or similar.; `treatment`: treat extrapolation stage as `scf` or `corl`, by default only the first stage is `scf` and every later one is `corl`.; `stage`: tag for the stage used in tables. The next items in the `cbs_metadata` array extrapolate correlation. All of the above parameters are available, with only the `wfn` and `basis` keywords required. Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters; molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html:12481,simpl,simple,12481,psi4manual/1.6.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html,2,['simpl'],['simple']
Usability,"ecial options for lower method in a given stage. This is useful to calculate a direct stage in an otherwise density-fitted calculation, or similar.; `treatment`: treat extrapolation stage as `scf` or `corl`, by default only the first stage is `scf` and every later one is `corl`.; `stage`: tag for the stage used in tables. The next items in the `cbs_metadata` array extrapolate correlation. All of the above parameters are available, with only the `wfn` and `basis` keywords required. Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters; molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html:12473,simpl,simple,12473,psi4manual/1.4.0/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html,8,['simpl'],['simple']
Usability,"ecify ghost atoms, and we didn’t need; to call the monomer and dimer computations separately. The built-in; Psithon function cp() does it all for us, automatically.; And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol, which is; defined in Sec. Scratch Files and the ~/.psi4rc File. Notice the loop over to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. Table Of Contents. A PSI4 Tutorial; Basic Input File Structure; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. Previous topic; Installation and Runtime Configuration; Next topic; Psithon: Structuring an Input File; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/tutorial-1.html:19695,simpl,simple,19695,psi4manual/4.0b3/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/tutorial-1.html,4,"['clear', 'simpl']","['clear', 'simple']"
Usability,"ecify ghost atoms, and we didn’t need; to call the monomer and dimer computations separately. The built-in; Psithon function cp() does it all for us, automatically.; And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol, which is; defined in Sec. Scratch Files and the ~/.psi4rc File. Notice the loop over to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. Table Of Contents. A PSI4 Tutorial; Basic Input File Structure; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. Previous topic; Installation and Runtime Configuration; Next topic; Psithon: Structuring an Input File; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . © Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/tutorial-1.html:20101,simpl,simple,20101,psi4manual/4.0b4/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/tutorial-1.html,4,"['clear', 'simpl']","['clear', 'simple']"
Usability,"ecify ghost atoms, and we didn’t need; to call the monomer and dimer computations separately. The built-in; Psithon function cp() does it all for us, automatically.; And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol, which is; defined in Sec. Scratch Files and the ~/.psi4rc File. Notice the loop over to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. Table Of Contents. A PSI4 Tutorial; Basic Input File Structure; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. Previous topic; Installation and Runtime Configuration; Next topic; Psithon: Structuring an Input File; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » . © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/tutorial-1.html:19533,simpl,simple,19533,psi4manual/4.0b5/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/tutorial-1.html,4,"['clear', 'simpl']","['clear', 'simple']"
Usability,"ed (instructions at Quick Installation),; gdma can be obtained through conda install gdma -c psi4.; Then enable it as a feature with ENABLE_gdma,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect gdma and activate dependent code. To remove a conda installation, conda remove gdma. Source. If using PSI4 built from source and you want gdma built from; from source also,; enable it as a feature with ENABLE_gdma,; and let the build system fetch and build it and activate dependent code. Input¶; The distributed multipole analysis (DMA) technique, developed by Anthony J.; Stone and implemented by him into the GDMA package, is available in PSI4.; The current implementation simply embeds Stone’s GDMA code into the main; executable, and generates the appropriate input files automatically. The; program takes as input a data file, and a Gaussian formatted checkpoint (see; Section FCHK) file. The simplest usage of the GDMA code is; demonstrated below, along with a listing of the options supported; these; options correspond to the options described in the; GDMA manual.; If more advanced usage is desired, which is not is permitted by the options; listed below, the user may provide their own data file containing keywords to; control the GDMA code. Simply place the data file in the directory PSI4; is called from, and provide the file name as the datafile argument to the; gdma() routine. For example, if GDMA data file is called; control.dma, the GDMA code is called as follows:; grad, wfn = gradient('mp2', return_wfn=True); gdma(wfn, datafile='control.dma'). An FCHK file will be generated for the GDMA code to read; this file will have; the prefix given by WRITER_FILE_LABEL (if set), or else by the name; of the output file plus the name of the current molecule, and the suffix will; be ‘.fchk’. This FCHK file name should be passed to the ‘File’ keyword in the; DGMA data file, to ensure that the GDMA code reads the correct wavefunction; information.; After running, two ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/gdma-1.html:1665,simpl,simplest,1665,psi4manual/1.4.0/gdma-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/gdma-1.html,9,['simpl'],['simplest']
Usability,"ed as approximations to CCSD or as; size-extensive modifications of CISD. The methods have the same; complexity as CISD, and solving the CISD or coupled-pair equations; requires fewer floating point operations than solving the CCSD. CISD,; CCSD, and the coupled-pair methods discussed below all scale formally with; the sixth power of system size, and, as with the QCISD method, CEPA; methods retain complexity of the CCSD equations.; For a detailed discussion of the properties of various coupled-pair; methods, see Ref. [Wennmohs:2008:217].; What follows is a very basic description of the practical differences in; the equations that define each of the coupled-pair methods implemented in; PSI4. We begin with the CISD wave function. (3); where we have chosen the intermediate normalization, . The CISD correlation energy is given by. (4); and the amplitudes can be determined by the solution to the coupled set of; eqations:. (5); The CISD method is not size-extensive, but this problem can be overcome by; making very simple modifications to the amplitude equations. We replace; the correlation energy, , with generalized shifts for the; doubles and singles equations, and :. (6); These shifts approximate the effects of triple and quadruple excitations.; The values for and used in several; coupled-pair methods are given in Table CEPA Shifts. Note that these shifts are defined in a spin-free; formalism for closed-shell references only. method. sdci. dci. NA. cepa(0); 0; 0. cepa(1). cepa(3). acpf. aqcc. The pair correlation energy, , is simply a partial; sum of the correlation energy. In a spin-free formalism, the pair energy; is given by. (7); Methods whose shifts ( and ) do not; explicitly depend on orbitals or (CISD, CEPA(0), ACPF,; and AQCC) have solutions that render the energy stationary with respect; variations in the amplitudes. This convenient property allows density; matrices and 1-electron properties to be evaluated without any additional; effort. Note, however, that 1-e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/fnocc-1.html:6521,simpl,simple,6521,psi4manual/4.0b4/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/fnocc-1.html,4,['simpl'],['simple']
Usability,"ed as approximations to CCSD or as; size-extensive modifications of CISD. The methods have the same; complexity as CISD, and solving the CISD or coupled-pair equations; requires fewer floating point operations than solving the CCSD. CISD,; CCSD, and the coupled-pair methods discussed below all scale formally with; the sixth power of system size, and, as with the QCISD method, CEPA; methods retain complexity of the CCSD equations.; For a detailed discussion of the properties of various coupled-pair; methods, see Ref. [Wennmohs:2008:217].; What follows is a very basic description of the practical differences in; the equations that define each of the coupled-pair methods implemented in; Psi4. We begin with the CISD wave function. (3); where we have chosen the intermediate normalization, . The CISD correlation energy is given by. (4); and the amplitudes can be determined by the solution to the coupled set of; eqations:. (5); The CISD method is not size-extensive, but this problem can be overcome by; making very simple modifications to the amplitude equations. We replace; the correlation energy, , with generalized shifts for the; doubles and singles equations, and :. (6); These shifts approximate the effects of triple and quadruple excitations.; The values for and used in several; coupled-pair methods are given in Table CEPA Shifts. Note that these shifts are defined in a spin-free; formalism for closed-shell references only. method. cisd. cepa(0); 0; 0. cepa(1). cepa(3). acpf. aqcc. The pair correlation energy, , is simply a partial; sum of the correlation energy. In a spin-free formalism, the pair energy; is given by. (7); Methods whose shifts ( and ) do not; explicitly depend on orbitals or (CISD, CEPA(0), ACPF,; and AQCC) have solutions that render the energy stationary with respect; variations in the amplitudes. This convenient property allows density; matrices and 1-electron properties to be evaluated without any additional; effort. Note, however, that 1-electron p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/fnocc-1.html:7185,simpl,simple,7185,psi4manual/1.0.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/fnocc-1.html,2,['simpl'],['simple']
Usability,"ed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate command is provided. With it, the above input file can be; equivalently written as follows. Alternatively, the molecule can be specified; directly to the computing function. Below, the third calculation is the same as; the first.; molecule h2 {; H; H 1 0.9; }. molecule h {; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf') # on H2. clean(). activate(h); set basis cc-pvdz; set reference uhf; energy('scf') # on H. # --------------------------------------; # equivalent to previous input ends here. clean(). set reference rhf; energy('scf', molecule=h2) # on H2. Job Control Keywords provides more details about the job control; and calculation keywords used in the above examples. Ghost Atoms¶; While many common computations, particularly SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2-1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Isotopic Substitution¶. Caution; Use of isotopic substitution in PSI4 is not well; developed, and the syntax is subject to change. At present, isotopes can only be specified at creation-time of the molecule; The syntax for a deuterium- and tritium-substituted water is below. Note; that asymmetric isotopic substitution such as this will change the; molecule’s point group symmetry.; molecule dto {; units au; O 0.00000000 0.00000000 0.00000000; H@2.014101779 0.00000000 1.93042809 -1.10715266; H_label@3.01604927 0.00000000 -1.93042809 -1.10715266; }. The masses used",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html:5962,simpl,simplified,5962,psi4manual/1.4.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html,9,['simpl'],['simplified']
Usability,"ed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate command is provided. With it, the above input file can be; equivalently written as follows. Alternatively, the molecule can be specified; directly to the computing function. Below, the third calculation is the same as; the first.; molecule h2 {; H; H 1 0.9; }. molecule h {; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf') # on H2. clean(). activate(h); set basis cc-pvdz; set reference uhf; energy('scf') # on H. # --------------------------------------; # equivalent to previous input ends here. clean(). set reference rhf; energy('scf', molecule=h2) # on H2. Job Control Keywords provides more details about the job control; and calculation keywords used in the above examples. Ghost Atoms¶; While many common computations, particularly SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Isotopic Substitution¶. Caution; Use of isotopic substitution in Psi4 is not well; developed, and the syntax is subject to change. At present, isotopes can only be specified at creation-time of the molecule; The syntax for a deuterium- and tritium-substituted water is below. Note; that asymmetric isotopic substitution such as this will change the; molecule’s point group symmetry.; molecule dto {; units au; O 0.00000000 0.00000000 0.00000000; H@2.014101779 0.00000000 1.93042809 -1.10715266; H_label@3.01604927 0.00000000 -1.93042809 -1.10715266; }. The masses used",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html:5981,simpl,simplified,5981,psi4manual/1.0.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html,2,['simpl'],['simplified']
Usability,"ed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet) → psi4.core.RHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:197868,simpl,simply,197868,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['simpl'],['simply']
Usability,"ed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet) → psi4.core.UHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:244625,simpl,simply,244625,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['simpl'],['simply']
Usability,"efile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; Psi4 code is not necessary.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of Psi4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main Psi4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:6409,simpl,simple,6409,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,4,['simpl'],"['simple', 'simpler']"
Usability,"eginning at R_CONVERGENCE). It is defined; according to the quantum chemical method and so its default value is set; by each module individually. 7(1,2,3); For frequency computations by finite difference of energies,; convergence criteria are tightened further still to 10 for; E_CONVERGENCE and D_CONVERGENCE for SCF of HF or DFT, 11; for E_CONVERGENCE and D_CONVERGENCE for SCF of post-HF,; and 10 for E_CONVERGENCE for post-HF of post-HF. Recommendations¶; The SCF code is quite flexible and powerful.; We have tried as much as possible to keep the number of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'). table of contents. HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Sym",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:41962,simpl,simple,41962,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,5,['simpl'],['simple']
Usability,"egin{split}\begin{pmatrix}; \mathbf{A_{SS}^{(2)}} & \mathbf{A_{SD}^{(1)}}\\; \mathbf{A_{DS}^{(1)}} & \mathbf{A_{DD}^{(0)}}; \end{pmatrix}; \begin{pmatrix}; \mathbf{X_S}\\; \mathbf{X_D}; \end{pmatrix}; =\omega; \begin{pmatrix}; \mathbf{X_S}\\; \mathbf{X_D}; \end{pmatrix}\end{split}\]; where the superscript on each matrix block indicates the order of; the fluctuation. Instead of solving the above equation explicitly,; the large D manifold is treated effectively as. \[[\mathbf{A_{SS}^{(2)}}+; \mathbf{A_{SD}^{(1)}}^{\dagger}(\omega-; \mathbf{A_{DD}^{(0)}})^{-1}\mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}=; \omega\mathbf{X_{S}}.\]; This form of the ADC(2) equation requires 7–10 iterations for; convergence on only one root. But thanks to Newton-Raphson; acceleration,. \[\omega^{n+1}=\omega^{n}-; \frac{\omega^n-\mathbf{X_{S}}(\omega^n)^{\dagger}; [\mathbf{A_{SS}^{(2)}}+; \mathbf{A_{SD}^{(1)}}^{\dagger}(\omega^n-\mathbf{A_{DD}^{(0)}})^{-1}; \mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}(\omega^n)}{1+\mathbf{X_{S}}; (\omega^n)^{\dagger}[\mathbf{A_{SD}^{(1)}}^{\dagger}; (\omega^n-\mathbf{A_{DD}^{(0)}})^{-2}\mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}; (\omega^n)}\]; the computational time reduces to shorter than half of the simple iterative; procedure. Construction of the denominator of the second term in the above; equation is less computationally expensive than construction of one \(\sigma\)-vector with respect to the effective response matrix. The non-iterative excitation energy stated above is calculated as a diagonal element of the Davidson mini-Hamiltonian matrix in the SEM as,. \[\omega^{Non-Iterative}=; \mathbf{X_{CIS}}^{\dagger}[\mathbf{A_{SS}^{(2)}}+; \mathbf{A_{SD}^{(1)}}^{\dagger}(\omega^{CIS}-\mathbf{A_{DD}^{(0)}})^{-1}; \mathbf{A_{DS}^{(1)}}]\mathbf{X_{CIS}}\]; where \(\omega^{CIS}\) and \(\mathbf{X_{CIS}}\) denote the CIS; excitation energy and wave function, respectively. The explicit form of the; σ-vector is provided in a note accompanying the source code,; in the file psi4/psi4/src/p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/adc-1.html:6645,simpl,simple,6645,psi4manual/1.2.1/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/adc-1.html,6,['simpl'],['simple']
Usability,"egin{split}\begin{pmatrix}; \mathbf{A_{SS}^{(2)}} & \mathbf{A_{SD}^{(1)}}\\; \mathbf{A_{DS}^{(1)}} & \mathbf{A_{DD}^{(0)}}; \end{pmatrix}; \begin{pmatrix}; \mathbf{X_S}\\; \mathbf{X_D}; \end{pmatrix}; =\omega; \begin{pmatrix}; \mathbf{X_S}\\; \mathbf{X_D}; \end{pmatrix}\end{split}\]; where the superscript on each matrix block indicates the order of; the fluctuation. Instead of solving the above equation explicitly,; the large D manifold is treated effectively as. \[[\mathbf{A_{SS}^{(2)}}+; \mathbf{A_{SD}^{(1)}}^{\dagger}(\omega-; \mathbf{A_{DD}^{(0)}})^{-1}\mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}=; \omega\mathbf{X_{S}}.\]; This form of the ADC(2) equation requires 7–10 iterations for; convergence on only one root. But thanks to Newton-Raphson; acceleration,. \[\omega^{n+1}=\omega^{n}-; \frac{\omega^n-\mathbf{X_{S}}(\omega^n)^{\dagger}; [\mathbf{A_{SS}^{(2)}}+; \mathbf{A_{SD}^{(1)}}^{\dagger}(\omega^n-\mathbf{A_{DD}^{(0)}})^{-1}; \mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}(\omega^n)}{1+\mathbf{X_{S}}; (\omega^n)^{\dagger}[\mathbf{A_{SD}^{(1)}}^{\dagger}; (\omega^n-\mathbf{A_{DD}^{(0)}})^{-2}\mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}; (\omega^n)}\]; the computational time reduces to shorter than half of the simple iterative; procedure. Construction of the denominator of the second term in the above; equation is less computationally expensive than construction of one \(\sigma\)-vector; with respect to the effective response matrix. The non-iterative excitation energy stated; above is calculated as a diagonal element of the Davidson mini-Hamiltonian matrix in the SEM as,. \[\omega^{Non-Iterative}=; \mathbf{X_{CIS}}^{\dagger}[\mathbf{A_{SS}^{(2)}}+; \mathbf{A_{SD}^{(1)}}^{\dagger}(\omega^{CIS}-\mathbf{A_{DD}^{(0)}})^{-1}; \mathbf{A_{DS}^{(1)}}]\mathbf{X_{CIS}}\]; where \(\omega^{CIS}\) and \(\mathbf{X_{CIS}}\) denote the CIS; excitation energy and wave function, respectively. The explicit form of the; σ-vector is provided in a note accompanying the source code,; in the file psi4/psi4/src",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/adc-1.html:16749,simpl,simple,16749,psi4manual/1.4.0/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/adc-1.html,5,['simpl'],['simple']
Usability,"ell.is_pure(); tst = prim_count; tsp = prim_count + shell_nprim; self.shells[shell_count] = GaussianShell(am, shell_nprim,; self.uoriginal_coefficients[tst:tsp],; self.ucoefficients[tst:tsp],; self.uerd_coefficients[tst:tsp],; self.uexponents[tst:tsp],; 'Pure' if self.puream else 'Cartesian',; center, self.xyz, bf_count); self.shells[shell_count].pyprint(); for thisbf in range(shell.nfunction()):; self.function_to_shell[bf_count] = shell_count; self.function_center[bf_count] = center; bf_count += 1; for thisao in range(shell.ncartesian()):; self.ao_to_shell[ao_count] = shell_count; ao_count += 1; shell_count += 1; prim_count += shell_nprim. # <<< Methods for Construction by Another Name >>>. @staticmethod; [docs] def zero_ao_basis_set():; """"""Returns an empty basis set object.; Returns a BasisSet object that actually has a single s-function; at the origin with an exponent of 0.0 and contraction of 1.0.; * @return A new empty BasisSet object. """"""; # In the new implementation, we simply call the default constructor; return BasisSet(). [docs] def atomic_basis_set(self, center):; """"""Return a BasisSet object containing all shells at center i (0-index); * Used for Atomic HF computations for SAD Guesses; * @param center Atomic center to provide a basis object for.; * @returns A new basis set object for the atomic center. """"""; return BasisSet(self, center). @staticmethod; [docs] def build(molecule, shells):; """"""Builder factory method; * @param molecule the molecule to build the BasisSet around; * @param shells array of *atom-numbered* GaussianShells to build the BasisSet from; * @return BasisSet corresponding to this molecule and set of shells. """"""; raise FeatureNotImplemented('BasisSet::build'). @staticmethod; [docs] def pyconstruct_combined(mol, keys, targets, fitroles, others):. # make sure the lengths are all the same; if len(keys) != len(targets) or len(keys) != len(fitroles):; raise ValidationError(""""""Lengths of keys, targets, and fitroles must be equal""""""). # Create (i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:14237,simpl,simply,14237,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,1,['simpl'],['simply']
Usability,"else:; otfcounter += 1; otffootnotes[res.group('fntext')] = localcounter; newcells.append(res.group('cellpre') + r""""""\footnotemark["""""" + str(localcounter) + ']' + res.group('cellpost')); changed = True; else:; newcells.append(cell); if changed:; lines2replace[idx] = '&'.join(newcells); for idx, line in iteritems(lines2replace):; text[idx] = line. # search-and-suppress ""blank"" lines; if suppressblanks:; for idx, line in enumerate(text):; if line.strip().endswith('\\'):; innards = ''.join(line.rstrip("""""" \\"""""").split('&')[1:]); if innards.isspace():; text[idx] = '%' + text[idx]. # finish out table; text.append(r""""""\end{tabular}""""""); text.append(r""""""\end{ruledtabular}""""""); for idx, fn in enumerate(footnotes):; text.append(r""""""\footnotetext[%d]{%s}"""""" % (idx + 1, fn)); for fn, idx in iteritems(otffootnotes):; text.append(r""""""\footnotetext[%d]{%s}"""""" % (idx, fn)); text.append(r""""""\end{%s}"""""" % ('sidewaystable' if landscape else 'table')); text.append(r""""""\endgroup""""""); text.append(r""""""\clearpage""""""); text.append(''). def matelem(dict_row, dict_col):; """"""Return merge of index dictionaries *dict_row* and *dict_col* (precedence) with error string from serrors appended at key 'matelem'.""""""; kw = dict(dict_row, **dict_col); errpiece = serrors['-'.join([kw[bit] for bit in ['mtd', 'opt', 'bas']])][kw['sset']][kw['dbse']]; kw['matelem'] = errpiece[kw['err']]; if 'tgtcnt' in errpiece:; kw['count'] = errpiece['tgtcnt']; if 'misscnt' in errpiece and errpiece['misscnt'] != 0 and 'tgtcnt' in errpiece:; kw['footnote'] = r""""""\footnotemark{Missing %d of %d reactions.}"""""" % (errpiece['misscnt'], errpiece['tgtcnt']); else:; kw['footnote'] = ''; return kw. # avoid misunderstandings; keysincolumnplan = set(sum([col[-1].keys() for col in columnplan], [])); for key in ['dbse', 'sset', 'mtd', 'opt', 'bas', 'err']:; if len(locals()[key]) > 1:; if key not in rowplan and key not in keysincolumnplan:; print(""""""Warning: non-first values in argument '{0}' won't """"""; """"""get used. Add '{0}' to rowplan",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html:5331,clear,clearpage,5331,psi4manual/1.0.0/_modules/qcdb/textables.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html,1,['clear'],['clearpage']
Usability,"eme.; An exception is the default, 'highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:; scf_scheme (function) – highest_1 || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy. corl_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy. delta_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. delta2_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('conv-mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('conv-mp2', ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cbs-1.html:5999,simpl,simple,5999,psi4manual/4.0b3/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cbs-1.html,2,['simpl'],['simple']
Usability,"eme.; An exception is the default, 'highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:; scf_scheme (function) – highest_1 || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy. corl_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy. delta_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. delta2_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cbs-1.html:5834,simpl,simple,5834,psi4manual/4.0b2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cbs-1.html,4,['simpl'],['simple']
Usability,"ence from the MCSCF module. run_psimrcc_scf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. run_qchf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an density-fitted orbital-optimized MP2 computation. run_sapt(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a SAPT calculation of any level. run_sapt_ct(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. run_scf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation. run_scf_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a SCF gradient calculation. run_scf_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to run_scf(); since SCF properties all handled through oeprop. scf_helper(name, **kwargs)[source]¶; Function serving as helper to SCF, choosing whether to cast; up or just run SCF with a standard guess. This preserves; previous SCF options set by other procedures (e.g., SAPT; output file types for SCF). select_ccsd(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. select_ccsd_at_(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. select_ccsd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. select_ccsd_t_(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. select_ccsd_t__gradient(name, **kwargs)[source]¶; Fun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:165965,simpl,simple,165965,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['simpl'],['simple']
Usability,"end(r""""""\textit{Minimal Absolute Error} """"""); summlines[3].append(r""""""\textit{Maximal Signed Error} """"""); summlines[4].append(r""""""\textit{Maximal Absolute Error} """"""); summlines[5].append(r""""""\textit{Mean Signed Error} """"""); summlines[6].append(r""""""\textit{Mean Absolute Error} """"""); summlines[7].append(r""""""\textit{Root-Mean-Square Error} """"""); elif col in ['e', 'pe']:; summlines[0].append(''); summlines[1].append(blkerrors['nex' + col]); summlines[2].append(blkerrors['min' + col]); summlines[3].append(blkerrors['pex' + col]); summlines[4].append(blkerrors['max' + col]); summlines[5].append(blkerrors['m' + col]); summlines[6].append(blkerrors['ma' + col]); summlines[7].append(blkerrors['rms' + col]); else:; for ln in range(len(summlines)):; summlines[ln].append(''); for ln in range(len(summlines)):; tablelines.append(' & '.join(summlines[ln]) + r"""""" \\ """"""). # table conclusion; tablelines.append(r""""""\end{longtable}""""""); tablelines.append(r""""""\endgroup""""""); tablelines.append(r""""""\clearpage""""""); tablelines.append('\n\n'). # form table index; thisindextitle = indextitle.format(dbse=self.dbse, mc=fancymodelchem.strip(),; sset='All' if sset == 'default' else sset.upper()); indexlines.append(r""""""\scriptsize \ref{%s} & \scriptsize %s \\ """""" % \; (ref, thisindextitle)). if standalone:; tablelines += textables.end_latex_document(). # form table and index return structures; if filename is None:; return tablelines, indexlines; else:; if filename.endswith('.tex'):; filename = filename[:-4]; with open(filename + '.tex', 'w') as handle:; handle.write('\n'.join(tablelines)); with open(filename + '_index.tex', 'w') as handle:; handle.write('\n'.join(indexlines) + '\n'); print(""""""\n LaTeX index written to {filename}_index.tex\n""""""; """""" LaTeX table written to {filename}.tex\n""""""; """""" >>> pdflatex {filename}\n""""""; """""" >>> open /Applications/Preview.app {filename}.pdf\n"""""".format(filename=filename)); filedict = {'data': os.path.abspath(filename) + '.tex',; 'index': os.path.abspath(filen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:93605,clear,clearpage,93605,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['clear'],['clearpage']
Usability,"energy expression in terms of the one- and; two-particle density matrices (\(\boldsymbol{\gamma_1}\) and \(\boldsymbol{\gamma_2}\)):. \[E = h_p^q \gamma_q^p + \frac{1}{2} g_{pq}^{rs} \gamma_{rs}^{pq}\]; Here we used Einstein convention for the summation over the repeated indices.; \(h_p^q\) and \(g_{pq}^{rs}\) are the standard one- and two-electron integrals, and; \(\gamma_p^q\) and \(\gamma_{pq}^{rs}\) are the elements of \(\boldsymbol{\gamma_1}\) and \(\boldsymbol{\gamma_2}\),; respectively. Naively, one might expect that it is possible to minimize the; energy functional in the equation above and obtain the exact energy. This is,; however, not trivial, as the density matrix elements \(\gamma_p^q\) and; \(\gamma_{pq}^{rs}\) cannot be varied arbitrarily, but must satisfy some; conditions that make sure that the density matrices are N-representable, i.e.; correspond to an antisymmetric N-electron wavefunction. Unfortunately, no; simple set of necessary and sufficient N-representability conditions are known,; and some of the known conditions are not easily imposed. In addition, the lack; of separability of the density matrices may result in the loss of; size-consistency and size-extensivity. In DCFT, one takes a different route and; replaces \(\boldsymbol{\gamma_2}\) in favor of its two-particle density cumulant:. \[\lambda_{pq}^{rs} = \gamma_{pq}^{rs} - \gamma_p^r \gamma_q^s + \gamma_p^s \gamma_q^r\]; The one-particle density matrix is separated into its idempotent part; \(\boldsymbol{\kappa}\) and a correction \(\boldsymbol{\tau}\):. \[\gamma_p^q = \kappa_p^q + \tau_p^q\]; The idempotent part of \(\boldsymbol{\gamma_1}\) corresponds to a mean-field Hartree–Fock-like density,; while the non-idempotent correction \(\boldsymbol{\tau}\); depends on the density cumulant and describes the electron correlation effects.; Inserting the above two equations into the energy expression, we obtain:. \[E_{DCFT} = \frac{1}{2} \left( h_p^q + f_p^q \right) \gamma_q^p + \frac{1}{4} \ba",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dcft-1.html:1483,simpl,simple,1483,psi4manual/1.2.1/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dcft-1.html,6,['simpl'],['simple']
Usability,"energy expression in terms of the one- and; two-particle density matrices (\(\boldsymbol{\gamma_1}\) and \(\boldsymbol{\gamma_2}\)):. \[E = h_p^q \gamma_q^p + \frac{1}{2} g_{pq}^{rs} \gamma_{rs}^{pq}\]; Here we used Einstein convention for the summation over the repeated indices.; \(h_p^q\) and \(g_{pq}^{rs}\) are the standard one- and two-electron integrals, and; \(\gamma_p^q\) and \(\gamma_{pq}^{rs}\) are the elements of \(\boldsymbol{\gamma_1}\) and \(\boldsymbol{\gamma_2}\),; respectively. Naively, one might expect that it is possible to minimize the; energy functional in the equation above and obtain the exact energy. This is,; however, not trivial, as the density matrix elements \(\gamma_p^q\) and; \(\gamma_{pq}^{rs}\) cannot be varied arbitrarily, but must satisfy some; conditions that make sure that the density matrices are N-representable, i.e.; correspond to an antisymmetric N-electron wavefunction. Unfortunately, no; simple set of necessary and sufficient N-representability conditions are known,; and some of the known conditions are not easily imposed. In addition, the lack; of separability of the density matrices may result in the loss of; size-consistency and size-extensivity. In DCT, one takes a different route and; replaces \(\boldsymbol{\gamma_2}\) in favor of its two-particle density cumulant:. \[\lambda_{pq}^{rs} = \gamma_{pq}^{rs} - \gamma_p^r \gamma_q^s + \gamma_p^s \gamma_q^r\]; The one-particle density matrix is separated into its idempotent part; \(\boldsymbol{\kappa}\) and a correction \(\boldsymbol{\tau}\):. \[\gamma_p^q = \kappa_p^q + \tau_p^q\]; The idempotent part of \(\boldsymbol{\gamma_1}\) corresponds to a mean-field Hartree–Fock-like density,; while the non-idempotent correction \(\boldsymbol{\tau}\); depends on the density cumulant and describes the electron correlation effects.; Inserting the above two equations into the energy expression, we obtain:. \[E_{DCT} = \frac{1}{2} \left( h_p^q + f_p^q \right) \gamma_q^p + \frac{1}{4} \bar{",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:1474,simpl,simple,1474,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,9,['simpl'],['simple']
Usability,"eneric; database function options cp, rlxd, benchmark, and the string; options for subset. The full reagent member list, which can also be used; in conjunction with subset, is not included here for consideration of space; and may be found in the database file. The database Python files are very; readable and should be consulted for more particular questions. CORE¶. Database of Pulay corannulene structures. Subsumed into CFLOW. cp 'off' || 'on'; rlxd 'off'. BAKERJCC93¶. Database of molecules that are challenging to optimize.; Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported; in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002), with a few; further corrections.; No reference energies defined. cp 'off'; rlxd 'off'; subset. 'small'; 'large'. BAKERJCC96¶. Geometries from Baker and Chan J. Comput. Chem. 17 888 (1996),. as reported in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002). No reference energies defined. cp 'off'; rlxd 'off'. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. HTR40¶. Database of Hydrogen transfer reactions.; Geometries from Bozkaya and Sherrill.; Reference energies from Bozkaya and Sherrill. benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. A24alt¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries from <Reference>.; Reference interaction energies from Rezac and Hobza, JCTC (in press). cp 'off' <erase this comment and after unless on is a valid option> || 'on'; rlxd 'off' <erase this comment and after unless on is valid option> || 'on'; benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' <members_description>; 'large' <memb",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/db.html:12447,simpl,simple,12447,psi4manual/1.7.x/db.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/db.html,1,['simpl'],['simple']
Usability,"ent for engine =libdisp. Psi4 class instance prepared; to compute dispersion. Type:; Dispersion. ordered_params¶; Fixed-order list of relevant parameters for dashlevel. Matches; DISPERSION CORRECTION ENERGY ordering. Used for printing. Type:; list. Parameters:. name_hint (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; dashcoeff[dashlevel][functional-without-dashlevel] or; dashcoeff_supplement[dashlevel][functional-with-dashlevel]; can be overwritten via param_tweaks.; level_hint (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to one.; param_tweaks (Union[Dict, List, None]) – Values for the same keys as dashcoeff[dashlevel][‘default’]; (and same order if list) used to override any or all values; initialized by name_hint. Extra parameters will error.; engine (Optional[str]) – Override which code computes dispersion. See above for allowed; values. Formerly (pre Nov 2022) only relevant for -D2, which can be computed by; libdisp or dftd3. Now (post Nov 2022) also relevant for -D3 variants,; which can be computed by dftd3 executable or simple-dftd3 Python module.; gcp_engine (Optional[str]) – Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp (bool) – Whether to request atomic pairwise analysis. table of contents. Interface to DFTD3 by S. Grimme; Empirical Dispersion Implementations; Installation; Theory; Running DFTD3 or DFTD4; Three-Body Dispersion Corrections. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to DFTD3 by S. Grimme. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:19617,simpl,simple-,19617,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,1,['simpl'],['simple-']
Usability,"equations into the energy expression, we obtain:. \[E_{DCT} = \frac{1}{2} \left( h_p^q + f_p^q \right) \gamma_q^p + \frac{1}{4} \bar{g}_{pq}^{rs} \lambda_{rs}^{pq}\]; where the antisymmetrized two-electron integrals and the generalized Fock operator; matrix elements were defined as follows:. \[\bar{g}_{pq}^{rs} = g_{pq}^{rs} - g_{pq}^{sr}\]. \[f_p^q = h_p^q + \bar{g}_{pr}^{qs} \gamma_{s}^{r}\]; Energy functional \(E_{DCT}\) has several important properties. First,; the energy is now a function of two sets of independent parameters, the; idempotent part of \(\boldsymbol{\gamma_1}\) (\(\boldsymbol{\kappa}\)) and the density cumulant; (\(\boldsymbol{\lambda_2}\)). As a result, the energy functional is Hermitian,; which is important for the evaluation of the molecular properties. The additive; separability of the density cumulant guarantees that all of the DCT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent part of \(\boldsymbol{\gamma_1}\) is; N-representable by construction. One only needs to worry about the; N-representability of the density cumulant, which is a relatively small part of; \(\boldsymbol{\gamma_2}\).; In order to obtain the DCT energy, two conditions must be satisfied:. The energy must be stationary with respect to a set of orbitals. This can be done by; diagonalizing the generalized Fock operator (as in the DC-06 and DC-12 methods, see below),; which introduces partial orbital relaxation, or by fully relaxing the orbitals and minimizing the entire energy expression; (as in the ODC-06 and ODC-12 methods).; The energy must be stationary with respect to the variation of the density; cumulant \(\boldsymbol{\lambda_2}\), constrained to N-representability conditions. Making the energy stationary requires solution of two sets of coupled; equations for orbitals and density cumulant, respectively (also known as; residual equations). At the present moment, three diffe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:3378,simpl,simplified,3378,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,9,['simpl'],['simplified']
Usability,"er instructs otherwise; keep = yes.match(str(kwargs['keep'])) if 'keep' in kwargs else False; os.chdir('..'); try:; if keep or ('path' in kwargs):; core.print_out('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; core.get_gradient().print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; core.get_gradient().print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; gobas = core.get_global_option('BASIS') if core.get_global_option('BASIS') else 'sto-3g'; basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = core.get_gradient(); wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURRENT HESSIAN'); # finalquantity.print_out(). return wfn. def cfour_list():; """"""Form list of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html:12912,clear,clear,12912,psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,3,['clear'],['clear']
Usability,"ery later one is ```corl```.; * ```stage```: tag for the stage used in tables. The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters; are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters; are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it; is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the; ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:43923,simpl,simple,43923,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['simpl'],['simple']
Usability,"es, because they introduce minimal errors; whil providing much faster computations [Hohenstein:2010:184111]; [Hohenstein:2010:014101]. Since we’re using density fitting for the SAPT,; we might as well also use it for the Hartree–Fock computations that are; performed as part of the SAPT. We can specify that with; scf_type DF.; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, PSI4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that PSI4 correctly guesses that we want the jun-cc-pVDZ-JKFIT; auxiliary basis for the Hartree–Fock, and the jun-cc-pVDZ-RI basis set; for the SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons with freeze_core True. The SAPT; procedure is invoked with the simple call, energy('sapt0'). This; call knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in addition; to the total SAPT0 interaction energy. An explanation of the various; energy components can be found in the review by Jeziorski, Moszynski, and; Szalewicz [Jeziorski:1994:1887], and this is discussed in more detail; in the SAPT section later in this manual. For now, we’ll note that most of; the SAPT energy components are negative; this means those are attractive; contributions (the zero of energy in a SAPT computation is defined as; non-interacting monomers). The exchange contributions are positive; (repulsive). In this example, the most attractive contribution between; ethylene and acetylene is an electrostatic term of -2.12 kcal mol-1; (Elst10,r where the 1 indicates the first-order; perturbation theory result with respect to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/tutorial-1.html:11762,simpl,simple,11762,psi4manual/4.0b3/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/tutorial-1.html,2,['simpl'],['simple']
Usability,"es, because they introduce minimal errors; whil providing much faster computations [Hohenstein:2010:184111]; [Hohenstein:2010:014101]. Since we’re using density fitting for the SAPT,; we might as well also use it for the Hartree–Fock computations that are; performed as part of the SAPT. We can specify that with; scf_type DF.; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, PSI4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that PSI4 correctly guesses that we want the jun-cc-pVDZ-JKFIT; auxiliary basis for the Hartree–Fock, and the jun-cc-pVDZ-RI basis set; for the SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons with freeze_core True. The SAPT; procedure is invoked with the simple call, energy('sapt0')}. This; call knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in addition; to the total SAPT0 interaction energy. An explanation of the various; energy components can be found in the review by Jeziorski, Moszynski, and; Szalewicz [Jeziorski:1994:1887], and this is discussed in more detail; in the SAPT section later in this manual. For now, we’ll note that most of; the SAPT energy components are negative; this means those are attractive; contributions (the zero of energy in a SAPT computation is defined as; non-interacting monomers). The exchange contributions are positive; (repulsive). In this example, the most attractive contribution between; ethylene and acetylene is an electrostatic term of -2.12 kcal mol-1; (Elst10,r where the 1 indicates the first-order; perturbation theory result with respect to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:11735,simpl,simple,11735,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,2,['simpl'],['simple']
Usability,"esent in delta3_basis and xtpl_highest_1() otherwise. delta4_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:9624,simpl,simple,9624,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,2,['simpl'],['simple']
Usability,"essary for changes made to; files in $PSIDATADIR, including those described below. Creating a Database¶; A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an examp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/quickadddatabase-1.html:1204,simpl,simply,1204,psi4manual/1.0.0/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/quickadddatabase-1.html,10,['simpl'],['simply']
Usability,"est_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:57041,simpl,simple,57041,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['simpl'],['simple']
Usability,"eters:; scf_scheme (function) – highest_1 || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy. corl_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy. delta_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. delta2_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('conv-mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('conv-mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, del",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cbs-1.html:6141,simpl,simple,6141,psi4manual/4.0b3/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cbs-1.html,2,['simpl'],['simple']
Usability,"eters:; scf_scheme (function) – highest_1 || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy. corl_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy. delta_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. delta2_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cbs-1.html:5976,simpl,simple,5976,psi4manual/4.0b2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cbs-1.html,4,['simpl'],['simple']
Usability,"ev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). PsiMod.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); PsiMod.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); PsiMod.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; PsiMod.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activate(user_molecule); user_molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", user_basis); PsiMod.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; PsiMod.revoke_global_option_changed('REFERENCE'); PsiMod.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy . [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:50906,clear,clear,50906,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,1,['clear'],['clear']
Usability,"every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:33321,simpl,simple,33321,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,5,['simpl'],['simple']
Usability,"every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:45530,simpl,simple,45530,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['simpl'],['simple']
Usability,"eyword is slightly complicated. For TDA calculations, the default is EXPECTATION since the evaluation of transition moments involves only a negligible amount of additional computation relative to the evaluation of the excitation energies. For EOMCC, the default is OFF since evaluation of any transition moments or properties requires approximately twice the computational time. Transition moments and dipole strengths are evaluated by default for all values of ESTATE_PROP other than OFF. Type: string; Possible Values: OFF, EXPECTATION, UNRELAXED, RESPONSE; Default: No Default. CFOUR_ESTATE_SYM (CFOUR)¶CFOUR — Specifies the number of excited states which are to be determined in each irreducible representation of the computational subgroup. The program attempts to find all of the lowest roots, but this is not guaranteed because the eigenvalue problem is not solved by direct matrix diagonalization, but rather by an iterative (modified Davidson) algorithm. For excited state gradient calculations, only one root (clearly) is used. In such a case, one and only one non-zero entry in the string can be used, and this value is usually set to one (i.e. 0/1/0/0). (However sometimes one wants to calculate the gradient for, say, the second root of a given symmetry, and in such a case, one could use 0/2/0/0. What happens is that both roots are calculated, but only the second one is used in the subsequent density matrix and gradient calculation.) The format used for this keyword is identical to that used in CFOUR_OCCUPATION. For example, for a computational subgroup having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Psi4 Interface: The array above is specified in PSI as (white space tolerant) [3,1,0,2]. Type: array; Default: No Default. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:37622,clear,clearly,37622,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['clear'],['clearly']
Usability,"f (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except:; raise PastureRequiredError(""RUN_CCTRANSORT""). while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if (core.variable('BRUECKNER CONVERGED') == True):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if name == 'bccd(t)':; core.cctriples(ref_wfn). optstash.restore(); return ref_wfn. def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.append(prop); elif (prop in oeprop_list_vals) or (""MULTIPOLE("" in prop):; oe_properties.append(prop); else:; unknown_property.append(prop). if ""DIPOLE"" not in oe_properties:; oe_properties.append(""DIPOLE""). # Throw if we dont know what something is; if len(unknown_property):; complete_options = oeprop_list_vals + response_list_vals; alt_method_name = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:73467,simpl,simple,73467,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['simpl'],['simple']
Usability,"f interaction energies for bimolecular complexes.; Geometries and reference interaction energies from Rezac et al. JCTC 7 2427 (2011).; Note that the S66by8-N-1.0 members are not quite the same geometries as S66-N. cp 'off' || 'on'; rlxd 'off'; subset. 'small'; 'large'; 'equilibrium'; 'HB' eight-point (0.9, 0.95, 1.0, 1.05, 1.1, 1.25, 1.5, 2.0) \(\times R_{eq}\) dissociation curve hydrogen-bonded systems; 'MX' eight-point (0.9, 0.95, 1.0, 1.05, 1.1, 1.25, 1.5, 2.0) \(\times R_{eq}\) dissociation curve mixed-influence systems; 'DD' eight-point (0.9, 0.95, 1.0, 1.05, 1.1, 1.25, 1.5, 2.0) \(\times R_{eq}\) dissociation curve dispersion-dominated systems. BAKERJCC93¶. Database of molecules that are challenging to optimize.; Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported; in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002), with a few; further corrections.; No reference energies defined. cp 'off'; rlxd 'off'; subset. 'small'; 'large'. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. A24¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries from <Reference>.; Reference interaction energies from Rezac and Hobza, JCTC (in press). cp 'off' <erase this comment and after unless on is a valid option> || 'on'; rlxd 'off' <erase this comment and after unless on is valid option> || 'on'; benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. O24by5mb¶. Database (O24) of interaction energies for small open-shell high-spin bimolecular complexes.; Geometries taken from https://gitlab.com/piotr.zuchowski/o24x5/-/tree/4ec3cae0546b6ae4f4f2cf28482cd164c8323cc6.; Reference interaction energies taken from J. Chem. Phys. 154, 134106 (2021) https://doi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_available_databases.html:1522,simpl,simple,1522,psi4manual/1.8.x/autodoc_available_databases.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_available_databases.html,2,['simpl'],['simple']
Usability,"f isotopic substitution in PSI4 is not well; developed, and the syntax is subject to change. At present, isotopes can only be specified at creation-time of the molecule; The syntax for a deuterium- and tritium-substituted water is below. Note; that asymmetric isotopic substitution such as this will change the; molecule’s point group symmetry.; 1; 2; 3; 4; 5; 6molecule dto {; units au; O 0.00000000 0.00000000 0.00000000; H@2.014101779 0.00000000 1.93042809 -1.10715266; H_label@3.01604927 0.00000000 -1.93042809 -1.10715266; }. The masses used by PSI4 can be found at; psi4/psi4/include/psi4/masses.h. See freq-isotope for about; the only use to which isotopologues can presently be put in PSI4. PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; 1; 2; 3molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to the output file, prompting the user to provide a more; specific name. For example, if we know that we want to run a computation on a; compou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:7761,intuit,intuitive,7761,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['intuit'],['intuitive']
Usability,"f not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rather than the symmetry; # the the user might have provided.; frame = self.symmetry_frame(); self.rotate_full(frame); #print ""after rotate:""; #self.print_full(). # Recompute point group of the molecule, so the symmetry info is updated to the new frame; self.set_point_group(self.find_point_group()); self.set_full_point_group(). # Disabling symmetrize for now if orientation is fixed, as it is not; # correct. We may want to fix this in the future, but in some cases of; # finite-differences the set geometry is not totally symmetric anyway.; # Symmetrize the molecule to remove any noise; self.symmetrize(); #print ""after symmetry:""; #self.print_full(). self.lock_frame = True. # <<< Methods for Miscellaneous >>>. [docs] def clear(self):; """"""Zero it out.""""""; self.lock_frame = False; self.atoms = []; self.full_atoms = []. [docs] def nuclear_repulsion_energy(self):; """"""Computes nuclear repulsion energy. >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. """"""; e = 0.0; for at1 in range(self.natom()):; for at2 in range(self.natom()):; if at2 < at1:; Zi = self.Z(at1); Zj = self.Z(at2); dist = distance(self.xyz(at1), self.xyz(at2)); e += Zi * Zj / dist; return e. [docs] def nuclear_repulsion_energy_deriv1(self):; """"""Computes nuclear repulsion energy derivatives. >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. """"""; de = []; for i in range(self.natom()):; entry = [0.0, 0.0, 0.0]; for j in range(se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:49314,clear,clear,49314,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['clear'],['clear']
Usability,"f the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; 1; 2; 3; 4; 5; 6; 7CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. A PSI4 Tutorial. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/tutorial-1.html:23277,clear,clear,23277,psi4manual/1.3.2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/tutorial-1.html,2,['clear'],['clear']
Usability,"f', 'casscf']:; ciwfn = run_detcas(name, **kwargs); else:; ciwfn = run_detci(name, **kwargs). # All property names are just CI; if 'CI' in name.upper():; name = 'CI'. states = core.get_global_option('avg_states'); nroots = core.get_global_option('num_roots'); if len(states) != nroots:; states = range(nroots). # Run OEProp; oe = core.OEProp(ciwfn); oe.set_title(name.upper()); for prop in ci_prop:; oe.add(prop.upper()). # Compute ""the"" CI density; oe.compute(); ciwfn.oeprop = oe. # If we have more than one root, compute all data; if nroots > 1:; core.print_out(""\n ===> %s properties for all CI roots <=== \n\n"" % name.upper()); for root in states:; oe.set_title(""%s ROOT %d"" % (name.upper(), root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(root, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(root, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(root, root, ""B"", True)); oe.compute(). # Transition density matrices; if (nroots > 1) and len(ci_trans):; oe.clear(); for tprop in ci_trans:; oe.add(tprop.upper()). core.print_out(""\n ===> %s properties for all CI transition density matrices <=== \n\n"" % name.upper()); for root in states[1:]:; oe.set_title(""%s ROOT %d -> ROOT %d"" % (name.upper(), 0, root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(0, root, ""B"", True)); oe.compute(). _clean_detci(); optstash.restore(); return ciwfn. def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if name == 'eom-ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); core.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); core.set_local_option('CCHBAR', 'WFN', 'EOM_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:106265,clear,clear,106265,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,7,['clear'],['clear']
Usability,"f', 'casscf']:; ciwfn = run_detcas(name, **kwargs); else:; ciwfn = run_detci(name, **kwargs). # All property names are just CI; if 'CI' in name.upper():; name = 'CI'. states = core.get_global_option('avg_states'); nroots = core.get_global_option('num_roots'); if len(states) != nroots:; states = range(nroots). # Run OEProp; oe = core.OEProp(ciwfn); oe.set_title(name.upper()); for prop in ci_prop:; oe.add(prop.upper()). # Compute ""the"" CI density; oe.compute(); ciwfn.oeprop = oe. # If we have more than one root, compute all data; if nroots > 1:; core.print_out(""\n ===> %s properties for all CI roots <=== \n\n"" % name.upper()); for root in states:; oe.set_title(""%s ROOT %d"" % (name.upper(), root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(root, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(root, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(root, root, ""B"", True)); oe.compute(). # Transition density matrices; if (nroots > 1) and len(ci_trans):; oe.clear(); for tprop in ci_trans:; oe.add(tprop.upper()). core.print_out(""\n ===> %s properties for all CI transition density matrices <=== \n\n"" % name.upper()); for root in states[1:]:; oe.set_title(""%s ROOT %d -> ROOT %d"" % (name.upper(), 0, root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(0, root, ""B"", True)); oe.compute(). optstash.restore(); return ciwfn. def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if name == 'eom-ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); core.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CCSD'); core.set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:84658,clear,clear,84658,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,2,['clear'],['clear']
Usability,"f.__root; last = root[0]; last[1] = root[0] = self.__map[key] = [last, root, key]; dict_setitem(self, key, value). def __delitem__(self, key, dict_delitem=dict.__delitem__):; 'od.__delitem__(y) <==> del od[y]'; # Deleting an existing item uses self.__map to find the link which is; # then removed by updating the links in the predecessor and successor nodes.; dict_delitem(self, key); link_prev, link_next, key = self.__map.pop(key); link_prev[1] = link_next; link_next[0] = link_prev. def __iter__(self):; 'od.__iter__() <==> iter(od)'; root = self.__root; curr = root[1]; while curr is not root:; yield curr[2]; curr = curr[1]. def __reversed__(self):; 'od.__reversed__() <==> reversed(od)'; root = self.__root; curr = root[0]; while curr is not root:; yield curr[2]; curr = curr[0]. [docs] def clear(self):; 'od.clear() -> None. Remove all items from od.'; try:; for node in self.__map.itervalues():; del node[:]; root = self.__root; root[:] = [root, root, None]; self.__map.clear(); except AttributeError:; pass; dict.clear(self). [docs] def popitem(self, last=True):; '''od.popitem() -> (k, v), return and remove a (key, value) pair.; Pairs are returned in LIFO order if last is true or FIFO order if false. '''; if not self:; raise KeyError('dictionary is empty'); root = self.__root; if last:; link = root[0]; link_prev = link[0]; link_prev[1] = root; root[0] = link_prev; else:; link = root[1]; link_next = link[1]; root[1] = link_next; link_next[0] = root; key = link[2]; del self.__map[key]; value = dict.pop(self, key); return key, value. # -- the following methods do not depend on the internal structure --. [docs] def keys(self):; 'od.keys() -> list of keys in od'; return list(self). [docs] def values(self):; 'od.values() -> list of values in od'; return [self[key] for key in self]. [docs] def items(self):; 'od.items() -> list of (key, value) pairs in od'; return [(key, self[key]) for key in self]. [docs] def iterkeys(self):; 'od.iterkeys() -> an iterator over the keys in od'; re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:3038,clear,clear,3038,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,1,['clear'],['clear']
Usability,"f_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TDSCF_TDM_PRINT"")). # Shove variables into global space; for k, v in wfn.variables().items():; core.set_variable(k, v). return wfn. def run_tdscf_energy(name, **kwargs):. # Get a wfn in case we aren't given one; ref_wfn = kwargs.get('ref_wfn', None). if ref_wfn is None:; if name is None:; raise ValidationError(""TDSCF: No reference wave function!""); else:; ref_wfn = run_scf(name.strip('td-'), **kwargs). return run_tdscf_excitations(ref_wfn, **kwargs). def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.append(prop); elif (prop in oeprop_list_vals) or (""MULTIPOLE("" in prop):; oe_properties.append(prop); else:; unknown_property.append(prop). if ""DIPOLE"" not in oe_properties:; oe_properties.append(""DIPOLE""). # Throw if we dont know what something is; if len(unknown_property):; complete_options = oeprop_list_vals + response_list_vals; alt_method_name = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:94049,simpl,simple,94049,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,7,['simpl'],['simple']
Usability,"fault methods (RFO step):; 1optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; 1; 2set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; 1optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; 1; 2set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; 1; 2; 3; 4; 5; 6; 7set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; 1; 2set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:5192,simpl,simple,5192,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,6,['simpl'],['simple']
Usability,"fault methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using finite differences of energies instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). import optking. Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States and Reaction Paths¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Constrained Optimizations¶. Optimize a geometry (HOOH) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optking.html:4605,simpl,simple,4605,psi4manual/1.7.x/optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optking.html,3,['simpl'],['simple']
Usability,"fault methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using finite differences of energies instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). import optking. Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States and Reaction Paths¶; Optking currently has two transition state algorithms. The current default is the; newer RS_I_RFO algorithm [Besalu:1998:265] . The old algorithm can be used by setting; STEP_TYPE P_RFO for OPT_TYPE TS. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:4624,simpl,simple,4624,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,1,['simpl'],['simple']
Usability,"ferences;; if it is not, there is a good chance your orbitals are not well converged.; Tighten the SCF E_CONVERGENCE and/or D_CONVERGENCE keywords; and try again.; To increase the efficiency of MP2 energy evaluation, spin integration; and simplification is carried out. This also allows for the identification of; Same-Spin (SS) and Opposite-Spin (OS) terms for use in Grimme’s Spin-Component; Scaled (SCS) MP2. For RHF-MP2 (also labeled as RMP2), the spin-free equations are; (note that the integrals are now chemist’s integrals over spatial orbitals). and. For UHF-MP2 (also labeled as UMP2) and the second-order contribution to; ROHF-MBPT(2) using semicanonical orbitals, the spin-free equations are. and. Note that the UHF-MP2 equations use three classes of integrals, while the; RHF-MP2 equations use only one class. Because of this, a UHF-MP2 or; ROHF-MBPT(2) energy should take roughly three times as long as an RHF-MP2; energy. Recommendations¶; All-in-all, DFMP2 should be a simple module to use, with few keywords (fully; documented in the Appendix DFMP2). Some basic recommendations are included below:. DFMP2 should be run with the -type RI or MP2FIT auxiliary; basis sets, not the -JKFIT basis sets. The automatic basis selector; should work fine for all of the Dunning and Pople bases (provided the auxiliary; basis exists for the atom in question). If it does not, use the; DF_BASIS_MP2 keyword to manually specify the basis.; DFMP2 likes memory. At a minimum, doubles are required,; where is the size of the auxiliary basis set. However, there is; one disk transpose of the tensor in the RHF-MP2 algorithm; [two for UHF-MP2 and ROHF-MBPT(2)], so more memory will reduce seek times.; If you notice DFMP2 using more memory than allowed, it is possible that; the threaded three-index ERI computers are using too much overhead memory.; Set the DF_INTS_NUM_THREADS to a smaller number to prevent this; in this section (does not affect threaded efficiency in the rest of the; code).; DFMP2 l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dfmp2-1.html:5794,simpl,simple,5794,psi4manual/1.0.0/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dfmp2-1.html,8,['simpl'],['simple']
Usability,"ferences;; if it is not, there is a good chance your orbitals are not well converged.; Tighten the SCF E_CONVERGENCE and/or D_CONVERGENCE keywords; and try again.; To increase the efficiency of MP2 energy evaluation, spin integration; and simplification is carried out. This also allows for the identification of; Same-Spin (SS) and Opposite-Spin (OS) terms for use in Grimme’s Spin-Component; Scaled (SCS) MP2. For RHF-MP2 (also labeled as RMP2), the spin-free equations are; (note that the integrals are now chemist’s integrals over spatial orbitals). and. For UHF-MP2 (also labeled as UMP2) and the second-order contribution to; ROHF-MBPT(2) using semicanonical orbitals, the spin-free equations are. and. Note that the UHF-MP2 equations use three classes of integrals, while the; RHF-MP2 equations use only one class. Because of this, a UHF-MP2 or; ROHF-MBPT(2) energy should take roughly three times as long as an RHF-MP2; energy. Recommendations¶; All-in-all, DFMP2 should be a simple module to use, with few keywords (fully; documented in the Appendix DFMP2). Some basic recommendations are included below:. DFMP2 should be run with the -type RI or MP2FIT auxiliary; basis sets, not the -JKFIT basis sets. The automatic basis selector; should work fine for all of the Dunning bases (provided the auxiliary; basis exists for the atom in question). If it does not, use the; DF_BASIS_MP2 keyword to manually specify the basis.; DFMP2 likes memory. At a minimum, doubles are required,; where is the size of the auxiliary basis set. However, there is; one disk transpose of the tensor in the RHF-MP2 algorithm; [two for UHF-MP2 and ROHF-MBPT(2)], so more memory will reduce seek times.; If you notice DFMP2 using more memory than allowed, it is possible that; the threaded three-index ERI computers are using too much overhead memory.; Set the DF_INTS_NUM_THREADS to a smaller number to prevent this; in this section (does not affect threaded efficiency in the rest of the; code).; DFMP2 likes disk.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/dfmp2-1.html:5648,simpl,simple,5648,psi4manual/4.0b2/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/dfmp2-1.html,2,['simpl'],['simple']
Usability,"fferent modules.; Notice also that there’s a special comment immediately before the; declaration of each keyword. You must provide these comments for any; options you add as they will be automatically inserted into the user; manual Providing a clear description will also help you to remember what; the keywords do and how they’re used. The comments must live between the; special comment delimiters. For options that most users shouldn’t need,; add an expert flag to the comment. This will place these options in a; separate section of the user manual.; 1; 2; 3; 4/*- comment -*/; options.add_ ...; /*- comment !expert -*/; options.add_ ... As is apparent from the examples above, comments can span multiple lines; (see PRINT), can refer to other options (through hyperlinks; see; SAVE_INFO), can refer to sections of the manual (through hyperlinks;; see DOCC), and can contain LaTeX notation (see AO_BASIS). (To get; the LaTeX subscript command, use “@@” instead of “_”.); See Best Practices; for guidelines on naming options. What is has_changed ?¶; There are times when we need to know whether an option was provided by the; user or if the defaults are being used. For this reason, the Options; object stores a boolean has_changed value, in addition to the option; value itself. A clarification of definition:. [a] has_changed DOESN’T answer “Has option been changed by the user?”; [b] has_changed DOESN’T answer “Is option now different from the default?”; [c] has_changed DOES answer “Has option value been touched at all, by user or code?”. The above items notwithstanding, psi4 code should be written so that; has_changed DOES effectively mean, “Has option been changed by the; user?”. The way to do this is to isolate and nullify any changes to; options made by the code, the difference between [a] and [c]. C-side,; there is no concern since options are read but essentially never; written-to within the modules.; Py-side is another matter since the driver’s role is to take terse; instruct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optionshandling-1.html:4136,guid,guidelines,4136,psi4manual/1.1.0/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optionshandling-1.html,6,['guid'],['guidelines']
Usability,"fically. write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, …]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(…); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). SCFConvergenceError(eqn_description, …); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, …); Error called for problems with TDSCF iterations. Table([rows, row_label_width, …]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn’t and a simple syntax transition is possible. ValidationError(msg); Error called for problems with the input file. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:22766,simpl,simple,22766,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['simpl'],['simple']
Usability,"float(count_rxn); RMSDerror = math.sqrt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * p4const.psi_cal2J); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:28264,clear,clear,28264,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['clear'],['clear']
Usability,"float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → list[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp) → None¶; Clear the list of properties to compute. compute(self: psi4.core.OEProp) → None¶; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0) → None¶; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0) → None¶; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_names(self: psi4.core.OEProp, arg0: set[str]) → None¶; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str) → None¶; Title OEProp for print purposes. As a side effect, saves variables as title + propertyname and only that. Follow up with side names, if the side effect is undesired,. table of contents. OEProp; OEProp; OEProp.valid_methods; OEProp.Exvals(); OEProp.Eyvals(); OEProp.Ezvals(); OEProp.Vvals(); OEProp.add(); OEProp.clear(); OEProp.compute(); OEProp.set_Da_ao(); OEProp.set_Da_mo(); OEProp.set_Da_so(); OEProp.set_Db_ao(); OEProp.set_Db_mo(); OEProp.set_Db_so(); OEProp.set_names(); OEProp.set_title(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; OEProp. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.OEProp.html:3145,clear,clear,3145,psi4manual/master/api/psi4.core.OEProp.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.OEProp.html,1,['clear'],['clear']
Usability,"for CASSCF; wavefunctions is described in another section of this manual.; As just mentioned, the DETCI module is designed for challenging; chemical systems for which simple CISD is not suitable. Because; CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,; typically the DETCI code will be used in cases where the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; The division of the molecular orbitals into various subspaces such as; RAS spaces, or frozen vs. active orbitals, etc., needs to be clear not; only to detci, but also at least to the transformation program; (and in the case of MCSCF, to other programs as well). Thus, orbital; subspace keywords such as RAS1,; RAS2, RAS3, FROZEN_DOCC, FROZEN_UOCC,; ACTIVE, etc., should be set; in the global section of input so they may also be read by other modules.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. Higher order; single-refernce CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specifed by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/detci-1.html:3848,clear,clear,3848,psi4manual/4.0b2/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/detci-1.html,8,['clear'],['clear']
Usability,"for CASSCF; wavefunctions is described in another section of this manual.; As just mentioned, the DETCI module is designed for challenging; chemical systems for which simple CISD is not suitable. Because; CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,; typically the DETCI code will be used in cases where the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; The division of the molecular orbitals into various subspaces such as; RAS spaces, or frozen vs. active orbitals, etc., needs to be clear not; only to detci, but also at least to the transformation program; (and in the case of MCSCF, to other programs as well). Thus, orbital; subspace keywords such as RAS1,; RAS2, RAS3, FROZEN_DOCC,; FROZEN_UOCC,; ACTIVE, etc., should be set; in the global section of input so they may also be read by other modules.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. Higher order; single-refernce CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specifed by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/detci-1.html:3878,clear,clear,3878,psi4manual/1.0.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/detci-1.html,2,['clear'],['clear']
Usability,"forming a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available. PSIthonPsiAPIe_mp2 = variable('MP2 TOTAL ENERGY'); e_scs_mp2 = variable('SCS-MP2 TOTAL ENERGY'). e_mp2 = psi4.variable('MP2 TOTAL ENERGY'); e_scs_mp2 = psi4.variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. PSIthonPsiAPI# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = psi4.energy(...); E = psi4.optimize(...); E = psi4.frequency(...); G = psi4.gradient(...) # used by optimize(); H = psi4.hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=Tru",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:10002,simpl,simply,10002,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['simpl'],['simply']
Usability,"fs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.print_out(); ExternalPotential.setName(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:2667,clear,clear,2667,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,1,['clear'],['clear']
Usability,"ften requires; careful selection of initial orbitals and damping during iterations to ensure; convergence. This is particularly likely for large systems, metallic systems,; multireference systems, open-shell systems, anions, and systems with diffuse; basis sets.; For initial orbital selection, several options are available. These include:. CORE [Default]; Diagonalization of the core Hamiltonian, removing even mean-field electron; repulsion. Simple, but often too far from the final solution for larger; systems.; SAD; Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis, This can be done by placing a cast_up =; 'SMALL_BASIS' modifier in the energy() procedure call. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:13461,simpl,simple,13461,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,2,['simpl'],['simple']
Usability,"ften requires; careful selection of initial orbitals and damping during iterations to ensure; convergence. This is particularly likely for large systems, metallic systems,; multireference systems, open-shell systems, anions, and systems with diffuse; basis sets.; For initial orbital selection, several options are available. These include:. CORE [Default]; Diagonalization of the core Hamiltonian, removing even mean-field electron; repulsion. Simple, but often too far from the final solution for larger; systems.; SAD; Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; BASIS_GUESS = SMALL_BASIS to the options list. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). With r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/scf-1.html:14232,simpl,simple,14232,psi4manual/4.0b3/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/scf-1.html,2,['simpl'],['simple']
Usability,"full control over cfour program. Gradient methods available through P4C4 interface. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Moller-Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Moller-Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Specification Details¶; The above narrative introduction to the P4C4 interface should be; sufficient to get started. Issues of competition between Psi4 and; Cfour specification format are generally resolved behind the scenes:; not according to a simple rule but according to sensible, sometimes; intricate, rules governed by user intent (and integration of Cfour to; behave like a Psi4 module). Much can be gleaned by just running; inputs and inspecting the ZMAT passed to Cfour, but when questions; arise, here are the specifics, the governing laws. Specifying a piece of input in Psi4 format is entering into; a contract that you mean it. In particular this applies to; molecule (including charge/multiplicity through molecule; optional_molecule_name {...}), memory (through memory; value unit), computational method (through . If Cfour keywords; are specified with values that contradict the Psi4 input,; execution is halted.; As an example, the input below is set up to fail in four ways:; contradictory specification of memory, multiplicity, computational; method, and derivative level. Note, though, that the cfour_units; angstrom setting is permissible, since it concurs with the value; implied in the molecule block.; memory 300 mb. molecule {; H;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:28831,simpl,simple,28831,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['simpl'],['simple']
Usability,"full control over cfour program. Gradient methods available through P4C4 interface. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Specification Details¶; The above narrative introduction to the P4C4 interface should be; sufficient to get started. Issues of competition between PSI4 and; Cfour specification format are generally resolved behind the scenes:; not according to a simple rule but according to sensible, sometimes; intricate, rules governed by user intent (and integration of Cfour to; behave like a PSI4 module). Much can be gleaned by just running; inputs and inspecting the ZMAT passed to Cfour, but when questions; arise, here are the specifics, the governing laws. Specifying a piece of input in PSI4 format is entering into; a contract that you mean it. In particular this applies to; molecule (including charge/multiplicity through molecule; optional_molecule_name {...}), memory (through memory; value unit), computational method (through . If Cfour keywords; are specified with values that contradict the PSI4 input,; execution is halted.; As an example, the input below is set up to fail in four ways:; contradictory specification of memory, multiplicity, computational; method, and derivative level. Note, though, that the cfour_units; angstrom setting is permissible, since it concurs with the value; implied in the molecule block.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:27760,simpl,simple,27760,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,6,['simpl'],['simple']
Usability,"full control over cfour program. Gradient methods available through P4C4 interface. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Specification Details¶; The above narrative introduction to the P4C4 interface should be; sufficient to get started. Issues of competition between PSI4 and; Cfour specification format are generally resolved behind the scenes:; not according to a simple rule but according to sensible, sometimes; intricate, rules governed by user intent (and integration of Cfour to; behave like a PSI4 module). Much can be gleaned by just running; inputs and inspecting the ZMAT passed to Cfour, but when questions; arise, here are the specifics, the governing laws. Specifying a piece of input in PSI4 format is entering into; a contract that you mean it. In particular this applies to; molecule (including charge/multiplicity through molecule; optional_molecule_name {...}), memory (through memory; value unit), computational method (through . If Cfour keywords; are specified with values that contradict the PSI4 input,; execution is halted.; As an example, the input below is set up to fail in four ways:; contradictory specification of memory, multiplicity, computational; method, and derivative level. Note, though, that the cfour_units; angstrom setting is permissible, since it concurs with the value; implied in the molecule block.; memory 300 mb. molecule {; H;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:28806,simpl,simple,28806,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,9,['simpl'],['simple']
Usability,"g* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. Example; -------; >>> psi4.compare_values(2, 3, 2, ""asdf""); asdf..................................................................................FAILED; psi4.driver.p4util.exceptions.TestComparisonError: asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by difference (1.0000).; !----------------------------------------------------------------------------------!; ! !; ! asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by !; ! difference (1.0000). !; ! !; !----------------------------------------------------------------------------------!. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]; class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation :class:`FutureWarning`.; For cases where the syntax just has to jump, an UpgradeHelper can be used; to trap the old syntax at first error and suggest the new. An UpgradeHelper can also be used after the :class:`FutureWarning`; described above has expired. Then the body of the code can be deleted while; the definition is preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters; ----------; old; Previously valid syntax.; new; Suggested replacement syntax.; version; First Major.minor version at which `old` syntax won't run. Generally; the next release at time of commit.; elaboration; Any additional message to convey. Should start with a space. """"""; def __init__(self, old: str, new: str, version: str, elaboration: str):; msg = ""Using `{}` instead of `{}",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:3820,simpl,simple,3820,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,3,['simpl'],['simple']
Usability,"g; As of v1.8, primary binary distribution has moved from; the psi4 channel to the conda-forge channel. Neither install docs; for users nor compile docs for developers have been updated yet to; reflect new patterns. Please consult psicode downloads; page for the latest guides. This section fulfills the duty of every Linux project to have an INSTALL; file detailing how to build it from source. Few (mostly packagers and; sysadmins) are expected to read this file as it is a broad guide to the; many choices in building this project. For a specific, well-tested,; and performance-tuned build path, see psicode.org/installs/latest; (select “source”). For pre-built binaries again well-tested,; performance-tuned, and available for all common operating systems,; see psicode.org/installs/latest (select “conda”).; To see working builds for Linux, Mac, and Windows, see :src:; [this GHA]. Planning: how to configure Psi4 and invoke CMake¶; PSI4 is built through CMake. An abbreviated build guide can be found; within the source itself .; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -S.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make or Ninja in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of arguments to cmake tailored to; your computer. Proceed to quick build or; detailed build. How to build and install Psi4, the compact version¶; This section outlines the main steps of configuring, compiling, and; installing PSI4. More detail is given here.; >>> cd {top-level-psi4-dir}; >>> cmake -S. -Bobjdir [your configurati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/build_planning.html:1222,guid,guide,1222,psi4manual/1.8.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/build_planning.html,1,['guid'],['guide']
Usability,"g; Perl (for some auto-documentation scripts) https://www.perl.org/; nbsphinx (for converting Jupyter notebooks) http://nbsphinx.readthedocs.io/en/jupyter-theme/; sphinx-psi-theme https://github.com/psi4/sphinx-psi-theme; See [“message” lines] :source:`doc/sphinxman/CMakeLists.txt for advice on obtaining docs dependencies; See psi4/.github/workflows/docs.yml for full docs building procedure to follow. Ambit — https://github.com/jturney/ambit; CheMPS2 — [what is CheMPS2?] [CheMPS2 min version]. HDF5 https://support.hdfgroup.org/HDF5/; zlib http://www.zlib.net/. ecpint — [what is ecpint?] [ecpint min version]; dkh — [what is dkh?] [dkh min version]. Fortran Compiler. gdma — [what is gdma?] [gdma min version]. Fortran Compiler. PCMSolver — [what is PCMSolver?]. Fortran Compiler; zlib http://www.zlib.net/. simint — [what is simint?] [simint min version]. Additionally, there are runtime-loaded capabilities:. PylibEFP & libefp — [what is LibEFP?] [LibEFP min version]; cfour — [what is CFOUR?]; dftd3 — [what is DFTD3?]; simple-dftd3 — [what is DFTD3?] (Nov 2022; added by v1.7) preferred alternative to dftd3 https://github.com/dftd3/simple-dftd3; gcp — [what is gCP?]; mctc-gcp — [what is gCP?] (Nov 2022; added by v1.7) preferred alternative to gcp https://github.com/grimme-lab/gcp; dftd4 — <sec:dftd3> https://github.com/dftd4/dftd4; mrcc — [what is MPCC?]; v2rdm_casscf — [what is v2rdm_casscf?]; sns-mp2 — https://github.com/DEShawResearch/sns-mp2/commits/master; resp — https://github.com/cdsgroup/resp; gpu_dfcc — https://github.com/edeprince3/gpu_dfcc/commits/master; OpenFermion-Psi4 — https://github.com/quantumlib/OpenFermion; cppe — https://github.com/maxscheurer/cppe; mp2d — https://github.com/Chandemonium/MP2D; FockCI — https://github.com/shannonhouck/psi4fockci; cct3 — https://github.com/piecuch-group/cct3; adcc — https://github.com/adc-connect/adcc; BrianQC — https://www.brianqc.com/; i-PI — http://ipi-code.org/; psixas — https://github.com/Masterluke87/psixas; MDI — ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/build_planning.html:8160,simpl,simple-,8160,psi4manual/1.7.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/build_planning.html,1,['simpl'],['simple-']
Usability,"ge Z at (x,y,z). clear(self); Reset the field to zero (eliminates all entries). computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None; Add a charge Z at (x,y,z). clear(self: psi4.core.ExternalPotential) → None; Reset the field to zero (eliminates all entries). computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix; Compute the external potential matrix in the given basis set. print_out(self: psi4.core.ExternalPotential) → None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None; Sets the name. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.externalpotential.html:1745,clear,clear,1745,psi4manual/1.3.2/api/psi4.core.externalpotential.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.externalpotential.html,1,['clear'],['clear']
Usability,"ge channel. Neither install docs; for users nor compile docs for developers have been updated yet to; reflect new patterns. Please consult psi4/conda/psi4-path-advisor.py; (extensive help menu at conda/psi4-path-advisor.py -h); or psicode downloads; page for the latest guides. This section fulfills the duty of every Linux project to have an INSTALL; file detailing how to build it from source. Few (mostly packagers and; sysadmins) are expected to read this file as it is a broad guide to the; many choices in building this project. For a specific, well-tested,; and performance-tuned build path, see psicode.org/installs/latest; (select “source”). For pre-built binaries again well-tested,; performance-tuned, and available for all common operating systems,; see psicode.org/installs/latest (select “conda”).; To see working builds for Linux, Mac, and Windows, see :src:; [this GHA]. Planning: how to configure Psi4 and invoke CMake¶; PSI4 is built through CMake. An abbreviated build guide can be found; within the source itself .; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -S.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make or Ninja in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of arguments to cmake tailored to; your computer. Proceed to quick build or; detailed build. How to build and install Psi4, the compact version¶; This section outlines the main steps of configuring, compiling, and; installing PSI4. More detail is given here.; >>> cd {top-level-psi4-dir}; >>> cmake -S. -Bobjdir [your configurati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/build_planning.html:1314,guid,guide,1314,psi4manual/1.9.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/build_planning.html,2,['guid'],['guide']
Usability,"ge()[source]¶; The “atomic charge” of the current atom (for SAD purposes). static d(a1, a2, a3, a4)[source]¶; Computes the dihedral (in rad.) between four sets of coordinates. entry_number()[source]¶; The order in which this appears in the full atom list. everything()[source]¶. is_computed()[source]¶; Whether the current atom’s coordinates are up-to-date. is_equivalent_to(other)[source]¶; Whether this atom has the same mass and ghost status as atom other.; Unlike the libmints version, this does not compare basisset assignment. is_ghosted()[source]¶; Whether the current atom is ghosted or not. label()[source]¶; The atom label. mass()[source]¶; The atomic mass of the current atom. static r(a1, a2)[source]¶; Computes the distance between two sets of coordinates. set_ghosted(gh)[source]¶; Flag the atom as either ghost or real. symbol()[source]¶; The atomic symbol. class CoordValue(fixed=False, computed=False)[source]¶; An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. everything()[source]¶. fixed()[source]¶; Get whether the coordinate value is fixed or not. invalidate()[source]¶; Flag the current value as outdated. set_fixed(fixed)[source]¶; Set whether the coordinate value is fixed or not. class NumberValue(value, fixed=False)[source]¶; Specialization of CoordValue that is simply a number to be stored. clone()[source]¶; Returns new, independent NumberValue object. compute()[source]¶; Computes value of coordinate from member data. everything()[source]¶. rset(val)[source]¶; Resets value of coordinate if not fixed. type()[source]¶; Gets specialization type of CoordValue. variable_to_string(precision)[source]¶; Takes a CoordValue object, and returns a string for printing. class VariableValue(name, geometryVariables, negate=False, fixed=False)[source]¶; Specialization of CoordValue, where the current value depends; on the list",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:37101,simpl,simplifying,37101,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,6,['simpl'],['simplifying']
Usability,"geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]¶; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]¶; Serializes instance into dictionary according to schema dtype. to_string(dtype, units=None, atom_format=None, ghost_format=None, width=17, prec=12)[source]¶; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int) → int¶; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule) → str¶; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int) → float¶; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int) → psi4.core.Vector3¶; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int) → float¶; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int) → float¶; z position [Bohr] of atom arg0 (0-indexed without dummies). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; Molecule. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:39005,clear,clearing,39005,psi4manual/1.7.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html,1,['clear'],['clearing']
Usability,"get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except:; raise PastureRequiredError(""RUN_CCTRANSORT""). while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.get_variable('BRUECKNER CONVERGED'))); if (core.get_variable('BRUECKNER CONVERGED') == True):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if name == 'bccd(t)':; core.cctriples(ref_wfn). optstash.restore(); return ref_wfn. def run_dft_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DFT calculations. This is a simple alias to :py:func:`~proc.run_scf`; since DFT properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.dft_set_reference_local(name). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). scf_wfn = run_scf(name, scf_do_dipole=False, do_timer=False, **kwargs). # Run OEProp; oe = core.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); scf_wfn.set_oeprop(oe). core.tstop(); optstash.restore(); return scf_wfn. def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). scf_wfn = run_scf(name, scf_do_dipole=False, do_timer=False, **kwargs). # Run OEProp; oe = core.OEProp(scf_wfn); oe.set_title(nam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:70407,simpl,simple,70407,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['simpl'],['simple']
Usability,"get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except:; raise PastureRequiredError(""RUN_CCTRANSORT""). while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.get_variable('BRUECKNER CONVERGED'))); if (core.get_variable('BRUECKNER CONVERGED') == True):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if name == 'bccd(t)':; core.cctriples(ref_wfn). optstash.restore(); return ref_wfn. def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.append(prop); elif (prop in oeprop_list_vals) or (""MULTIPOLE("" in prop):; oe_properties.append(prop); else:; unknown_property.append(prop). if ""DIPOLE"" not in oe_properties:; oe_properties.append(""DIPOLE""). # Throw if we dont know what something is; if len(unknown_property):; complete_options = oeprop_list_vals + response_list_vals; alt_method_name = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:74369,simpl,simple,74369,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['simpl'],['simple']
Usability,"grals in PSI4. Integrals in PSI4¶. Introduction¶; PSI4 has a number of backends available to compute integrals. In order to; accomodate these options, while providing a clean interface to the programmer,; an abstraction layer is implemented within Libmints. A recent upgrade to the; primary integral engine has seen some important changes to the way this; interface layer is used; this document is designed to aid new developers as; well as those familiar with the older calling conventions to ensure that the; most efficient calling conventions are applied. The older style¶; A very simple loop that does not use permutational symmetry might look; something like this in the old scheme:; auto sieve = std::make_shared<ERISieve>(basisset, cutoff);; auto factory= std::make_shared<IntegralFactory>(basisset);; int deriv_level = 0;; bool use_shell_pairs = true;; auto eri = factory->eri(deriv_level, use_shell_pairs);; const double* buffer = eri_->buffer();; for (int P = 0; P < basisset->nshell(); ++P) {; const auto& Pshell = basisset->shell(P);; for (int Q = 0; Q < basisset->nshell(); ++Q) {; const auto& Qshell = basisset->shell(Q);; for (int R = 0; R < basisset->nshell(); ++R) {; const auto& Rshell = basisset->shell(R);; for (int S = 0; S < basisset->nshell(); ++S) {; const auto& Sshell = basisset->shell(S);; if(sieve->shell_significant(P, Q, R, S) {; eri->compute_shell(P, Q, R, S);; // results are in buffer, do something with them..; }; }; }; }; }. An integral factory is used, which can then produce integral object for various; operator types and derivative levels. A sieve is also constructed; this allows; a quick determination of whether an integral shell quartet will be significant; in magnitude or not, potentially saving a lot of work. This simple scheme is; clean and easy to understand, and is still supported in the latest version of; PSI4 with only a small change to the sieve syntax and handling of buffer; addresses, noted below. The new syntax¶; The newer integral engines ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_integrals-1.html:678,simpl,simple,678,psi4manual/1.4.0/prog_integrals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_integrals-1.html,9,['simpl'],['simple']
Usability,"h the Ubuntu shell). If using the PSI4 binary, DFTD3 has already been installed alongside. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; the dftd3 executable can be obtained through conda install dftd3. To remove a conda installation, conda remove dftd3. Source. If using PSI4 built from source and you want to build DFTD3 from; from source also,; follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a; Fortran compiler, and run make). From version 3.1.0 onwards, DFTD3 can; be used as-is; for earlier versions, patches are available:; psi4/psi4/share/psi4/scripts/patch_grimme_dftd3.3.0.2. To be used by PSI4, the program binary (dftd3) must be; found in your PSIPATH or PATH (in that order). If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular dftd3 compilation, simply adjust its; position in the path environment variables. Theory¶; The local or semilocal character of conventional density functionals; necessarily leads to neglect of the long-range correlation interactions; which capture attractive van der Waals forces. Initially proposed by Yang; [Wu:2002:515] and assiduously developed by Grimme, [Grimme:2004:1463]; [Grimme:2006:1787] [Grimme:2010:154104] the DFT+Dispersion method; appends to the base functional a scaled, damped, and fitted leading term; to the well-known dispersion energy series, \(E_{disp} = -C_6/R^6; -C_8/R^8 -C_{10}/R^{10}-\cdots\). The DFT-D2 [Grimme:2006:1787] variant; takes the explicit form below. Here, dispersion coefficients,; \(C_6^{ij}\), obtained from the geometric mean of tabulated elemental; values, are summed over interatomic distances, \(R_{ij}\), modulated; by a damping function, \(f_{damp}(R_{ij})\), that gradually activates; the dispersion correction (at a rate characterized by \(\alpha_6\)); over a distance c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dftd3-1.html:1353,simpl,simply,1353,psi4manual/1.1.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dftd3-1.html,2,['simpl'],['simply']
Usability,"he # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). For your convenience, this example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the User Configuration section of; the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; Energy converged. @RHF Final Energy: -76.02665366589162. By default, the energy should be converged to about , so agreement; is only expected for about the first 8 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Obtaining and Installing PSI4).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity ).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:1798,simpl,simple,1798,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,2,['simpl'],['simple']
Usability,"he Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import sys. import numpy as np. from psi4 import core; from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]def array_to_matrix(self, arr, name=""New Matrix"", dim1=None, dim2=None):; """"""; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters; ----------; arr : array or list of arrays; Numpy array or list of arrays to use as the data for a new core.Matrix; name : str; Name to give the new core.Matrix; dim1 : list, tup",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html:1276,simpl,simple,1276,psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,1,['simpl'],['simple']
Usability,"he basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta4_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta5_scheme: function; :param delta5_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta5_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:28063,simpl,simple,28063,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,2,['simpl'],['simple']
Usability,"he following and re-run.\n\n""; msg += ""\t Chemical ID IUPAC Name\n\n""; for result in results:; msg += ""%s"" % (result); if result.name().lower() == string.lower():; #We've found an exact match!; return result.getMoleculeString(); return msg. def process_molecule_command(matchobj):; """"""Function to process match of ``molecule name? { ... }``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); geometry = matchobj.group(3); geometry = pubchemre.sub(process_pubchem_command, geometry); from_filere = re.compile(r'^(\s*from_file\s*:\s*(.*)\n)$', re.MULTILINE | re.IGNORECASE); geometry = from_filere.sub(process_from_file_command,geometry); molecule = spaces. if name != """":; if sys.version_info >= (3, 0):; if not name.isidentifier():; raise ValidationError('Molecule name not valid Python identifier: ' + name); else:; if not re.match(r'^[^\d\W]\w*\Z', name):; raise ValidationError('Molecule name not valid Python identifier: ' + name). molecule += 'core.efp_init()\n' # clear EFP object before Molecule read in; molecule += spaces. if name != """":; molecule += '%s = ' % (name). molecule += 'geometry(""""""%s""""""' % (geometry); if name != """":; molecule += ',""%s""' % (name). molecule += "")\n""; molecule += '%score.IO.set_default_namespace(""%s"")' % (spaces, name). return molecule. def process_literal_blocks(matchobj):; """"""Function to process match of ``literals_psi4_yo-...``.""""""; return literals[matchobj.group(1)]. def process_cfour_command(matchobj):; """"""Function to process match of ``cfour name? { ... }``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); cfourblock = matchobj.group(3). literalkey = str(uuid.uuid4())[:8]; literals[literalkey] = cfourblock; return ""%score.set_global_option(\""%s\"", \""\""\""%s\n\""\""\"")\n"" % \; (spaces, 'LITERAL_CFOUR', 'literals_psi4_yo-' + literalkey). def process_extract_command(matchobj):; """"""Function to process match of ``extract_subsets``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); result = matchobj.group(0); result += '%s%s.s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/inputparser.html:8187,clear,clear,8187,psi4manual/1.1.0/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/inputparser.html,1,['clear'],['clear']
Usability,"herwise instructed by the user.; A Python callable handle to the PSI4 I/O management routines is available,; and is called psi4_io. To instruct the I/O manager to send all files to; another location, say /scratch/user, add the following command to the ~/.psi4rc; file.:; psi4_io.set_default_path('/scratch/user'). For batch jobs running through a queue, it might be more convenient to use an; environmental variable (in this case $MYSCRATCH) to set the scratch directory;; the following code will do that:; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). Individual files can be sent to specific locations. For example, file 32 is; the checkpoint file that the user might want to retain in the working directory; (i.e., where PSI4 was launched from) for restart purposes. This is; accomplished by the commands below:; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). A guide to the contents of individual scratch files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously.; To override any of these defaults for selected jobs, simply place the; appropriate commands from the snippets above in the input file itself. During; excecution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed. Executing PSI4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; psi4 -m. Alternately, the scratch directory can be set through the environment; variable PSI_SCRATCH (overrides ~/.psi4rc settings). (First line; for C shell; second line for bash.); setenv PSI_SCRATCH /scratch/user; export PSI_SCRATCH=/scratch/user. The ~/.psi4rc file can also be used to define constants that are ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/external-1.html:3771,guid,guide,3771,psi4manual/4.0b3/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/external-1.html,2,['guid'],['guide']
Usability,"hifts for the; doubles and singles equations, \(\Delta_{ij}\) and \(\Delta_i\):. (6)¶\[\begin{split}0 &= \langle \Psi_{ij}^{ab} | \hat{H} - E_0 - \Delta_{ij} | \Psi \rangle, \\; 0 &= \langle \Psi_{i}^{a} | \hat{H} - E_0 - \Delta_i | \Psi \rangle.\end{split}\]; These shifts approximate the effects of triple and quadruple excitations.; The values for \(\Delta_{ij}\) and \(\Delta_i\) used in several; coupled-pair methods are given in Table CEPA Shifts. Note that these shifts are defined in a spin-free; formalism for closed-shell references only. method; \(\Delta_{ij}\); \(\Delta_i\). cisd; \(E_c\); \(E_c\). cepa(0); 0; 0. cepa(1); \(\frac{1}{2}\sum_k(\epsilon_{ik}+\epsilon_{jk})\); \(\sum_k \epsilon_{ik}\). cepa(3); \(-\epsilon_{ij}+\sum_k(\epsilon_{ik}+\epsilon_{jk})\); \(-\epsilon_{ii}+2\sum_k \epsilon_{ik}\). acpf; \(\frac{2}{N} E_c\); \(\frac{2}{N} E_c\). aqcc; \([1-\frac{(N-3)(N-2)}{N(N-1)}]E_c\); \([1-\frac{(N-3)(N-2)}{N(N-1)}]E_c\). The pair correlation energy, \(\epsilon_{ij}\), is simply a partial; sum of the correlation energy. In a spin-free formalism, the pair energy; is given by. (7)¶\[\epsilon_{ij} = \sum_{ab} v_{ij}^{ab} (2 t_{ij}^{ab} - t_{ij}^{ba})\]; Methods whose shifts (\(\Delta_{ij}\) and \(\Delta_i\)) do not; explicitly depend on orbitals \(i\) or \(j\) (CISD, CEPA(0), ACPF,; and AQCC) have solutions that render the energy stationary with respect; variations in the amplitudes. This convenient property allows density; matrices and 1-electron properties to be evaluated without any additional; effort. Note, however, that 1-electron properties are currently; unavailable when coupling these stationary CEPA-like methods with frozen; natural orbitals. Density-fitted coupled cluster¶; Density fitting (DF) [or the resolution of the identity (RI)] and Cholesky; decomposition (CD) techniques are popular in quantum chemistry to avoid; the computation and storage of the 4-index electron repulsion integral; (ERI) tensor and even to reduce the computational scal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:9622,simpl,simply,9622,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,15,['simpl'],['simply']
Usability,"highest_1; corl_xtpl_helgaker_2. delta_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. delta2_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. Combined interface. Others. Parameters:molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html:9543,simpl,simple,9543,psi4manual/1.3.2/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html,4,['simpl'],['simple']
Usability,"hile a non-relativistic calculation yields the following energy:; @RHF Final Energy: -100.01041683847258. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.6714586298456027; Two-Electron Energy = 45.4843082290795309; Total Energy = -100.0104168384725796. Basis sets options¶; The X2C module in Psi4 supports different combinations of basis set.; By default, if the input file specifies only the basis keyword, then the X2C; module will solve the modified Dirac equation in an uncontracted basis and then; recontract the X2C Hamiltonian in the original basis.; Alternatively, the user can use the rel_basis keyword to specify a different; basis set to solve the modified Dirac equation.; set {; basis cc-pvdz-dk; rel_basis cc-pvtz-dk; relativistic x2c; }. It is recommended that when employing the X2C relativistic Hamiltonian, that you use a fully; decontracted basis set. This can be done simply in the input by adding “-decontract” to the; name of the primary basis you want to use for the calculation as detailed in; Decontracted Basis Sets. Publications resulting from the use; of X2C should cite the following publication: [Verma:2015]. Theory¶; X2C is based on exact decoupling of; positive-energy ( ; ) and negative-energy ( ); blocks of the Dirac Hamiltonian (). The transformation ( ) is obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984] treatment.; In the X2C treatment, the positive-energy block of the Hamiltonian ( ); is given by the sum; of a transformed kinetic () and potential energy ( ) contribution.; Relativistic kinetic energy ( ) and nuclear-electron interaction potential ( ) is given interms of non-relativisitc kinetic () energy and nuclear-electron interaction potential (), coupling matrix ( ) and renormalization matrix ( ). The coupling matrix ( ) is obtained from the large () and small () components of the positive energy solutions of the Dirac equation.; The renormalization ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/relativistic-1.html:2594,simpl,simply,2594,psi4manual/1.0.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/relativistic-1.html,2,['simpl'],['simply']
Usability,"hlar) of several classes of noncovalent interactions.; Geometries from Truhlar and coworkers at site http://comp.chem.umn.edu/database_noncov/noncovalent.htm; Reference energies from Truhlar and coworkers at site http://comp.chem.umn.edu/database_noncov/noncovalent.htm; First comprehensive citation JPCA 109 5656 (2005). cp 'off' || 'on'; rlxd 'off' || 'on'; benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' 3: HF-HF, He-Ne, HCCH-HCCH; 'large' 1: BzBz_PD; 'HB6' hydrogen-bonded; 'CT7' charge-transfer; 'DI6' dipole-interacting; 'WI7' weakly interacting; 'PPS5' pi-pi stacking. BAKERJCC93¶. Database of molecules that are challenging to optimize.; Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported; in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002), with a few; further corrections.; No reference energies defined. cp 'off'; rlxd 'off'; subset. 'small'; 'large'. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. S22by5¶. Database (Hobza) of interaction energies for dissociation curves of bimolecular complexes.; Geometries and reference interaction energies from Grafova et al. JCTC 6 2365 (2010).; Note that the S22by5-N-1.0 members are essentially the same geometries as S22-N (there’s trivial round-off error) but the reference interaction energies for S22by5 are of lower quality than those of S22. cp 'off' || 'on'; rlxd 'off'; subset. 'small'; 'large'; 'equilibrium'; 'mol1' five-point (0.9, 1.0, 1.2, 1.5, 2.0) \(\times R_{eq}\) dissociation curve for molecule 1; …; 'mol22' five-point (0.9, 1.0, 1.2, 1.5, 2.0) \(\times R_{eq}\) dissociation curve for molecule 22. JSCH¶. Database (Hobza) of interaction energies for nucelobase pairs.; Geometries and reference interaction energies from Jurecka et al. PCCP 8 1985 (2006).; Corrections implemented from foot",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_available_databases.html:8458,simpl,simple,8458,psi4manual/master/autodoc_available_databases.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_available_databases.html,2,['simpl'],['simple']
Usability,"hrm{MBPT,SS}}^{(2)} =; - \frac{[(ia|jb)-(ib|ja)](ia|jb)}{\epsilon_a + \epsilon_b - \epsilon_i - \epsilon_j}.\]; For UHF-MP2 (also labeled as UMP2) and the second-order contribution to; ROHF-MBPT(2) using semicanonical orbitals, the spin-free equations are. \[E_{\mathrm{MBPT,OS}}^{(2)} =; - \frac{(ia^\alpha|jb^\beta)(ia^\alpha|jb^\beta)}{\epsilon_a + \epsilon_b - \epsilon_i - \epsilon_j}\]; and. \[E_{\mathrm{MBPT,SS}}^{(2)} =; - \frac{1}{2}\frac{[(ia^\alpha|jb^\alpha)-(ib^\alpha|ja^\alpha)](ia^\alpha|jb^\alpha)}; {\epsilon_a + \epsilon_b - \epsilon_i - \epsilon_j}; - \frac{1}{2}\frac{[(ia^\beta|jb^\beta)-(ib^\beta|ja^\beta)](ia^\beta|jb^\beta)}; {\epsilon_a + \epsilon_b - \epsilon_i - \epsilon_j}.\]; Note that the UHF-MP2 equations use three classes of integrals, while the; RHF-MP2 equations use only one class. Because of this, a UHF-MP2 or; ROHF-MBPT(2) energy should take roughly three times as long as an RHF-MP2; energy. Recommendations¶; All-in-all, DFMP2 should be a simple module to use, with few keywords (fully; documented in the Appendix DFMP2). Some basic recommendations are included below:. DFMP2 should be run with the \(ov\)-type RI or MP2FIT auxiliary; basis sets, not the -JKFIT basis sets. The automatic basis selector; should work fine for all of the Dunning and Pople bases (provided the auxiliary; basis exists for the atom in question). If it does not, use the; DF_BASIS_MP2 keyword to manually specify the basis.; DFMP2 likes memory. At a minimum, \(2Q^2\) doubles are required,; where \(Q\) is the size of the auxiliary basis set. However, there is; one disk transpose of the \((Q|ov)\) tensor in the RHF-MP2 algorithm; [two for UHF-MP2 and ROHF-MBPT(2)], so more memory will reduce seek times.; If you notice DFMP2 using more memory than allowed, it is possible that; the threaded three-index ERI computers are using too much overhead memory.; Set the DF_INTS_NUM_THREADS to a smaller number to prevent this; in this section (does not affect threaded efficiency in ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dfmp2-1.html:7093,simpl,simple,7093,psi4manual/1.2.1/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dfmp2-1.html,4,['simpl'],['simple']
Usability,"hrm{MBPT,SS}}^{(2)} =; - \frac{[(ia|jb)-(ib|ja)](ia|jb)}{\epsilon_a + \epsilon_b - \epsilon_i - \epsilon_j}.\]; For UHF-MP2 (also labeled as UMP2) and the second-order contribution to; ROHF-MBPT(2) using semicanonical orbitals, the spin-free equations are. \[E_{\mathrm{MBPT,OS}}^{(2)} =; - \frac{(ia^\alpha|jb^\beta)(ia^\alpha|jb^\beta)}{\epsilon_a + \epsilon_b - \epsilon_i - \epsilon_j}\]; and. \[E_{\mathrm{MBPT,SS}}^{(2)} =; - \frac{1}{2}\frac{[(ia^\alpha|jb^\alpha)-(ib^\alpha|ja^\alpha)](ia^\alpha|jb^\alpha)}; {\epsilon_a + \epsilon_b - \epsilon_i - \epsilon_j}; - \frac{1}{2}\frac{[(ia^\beta|jb^\beta)-(ib^\beta|ja^\beta)](ia^\beta|jb^\beta)}; {\epsilon_a + \epsilon_b - \epsilon_i - \epsilon_j}.\]; Note that the UHF-MP2 equations use three classes of integrals, while the; RHF-MP2 equations use only one class. Because of this, a UHF-MP2 or; ROHF-MBPT(2) energy should take roughly three times as long as an RHF-MP2; energy. Recommendations¶; All-in-all, DFMP2 should be a simple module to use, with few keywords (fully; documented in the Appendix DFMP2). Some basic recommendations are included below:. DFMP2 should be run with the \(ov\)-type RI or MP2FIT auxiliary; basis sets, not the -JKFIT basis sets. The automatic basis selector; should work fine for most all bases (exceptions are less common elements; at higher than quadruple-zeta). Generally, it is always better to specify; only the orbital basis set and let the auxiliary bases be chosen; automatically. If you want to specify manually, use the; DF_BASIS_MP2 keyword.; DFMP2 likes memory. At a minimum, \(2Q^2\) doubles are required,; where \(Q\) is the size of the auxiliary basis set. However, there is; one disk transpose of the \((Q|ov)\) tensor in the RHF-MP2 algorithm; [two for UHF-MP2 and ROHF-MBPT(2)], so more memory will reduce seek times.; If you notice DFMP2 using more memory than allowed, it is possible that; the threaded three-index ERI computers are using too much overhead memory.; Set the DF_INTS_NUM_THREA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dfmp2-1.html:7093,simpl,simple,7093,psi4manual/1.3.2/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dfmp2-1.html,11,['simpl'],['simple']
Usability,"https://github.com/psi4/sphinx-psi-theme; See [“message” lines] :source:`doc/sphinxman/CMakeLists.txt for advice on obtaining docs dependencies; See psi4/.github/workflows/docs.yml for full docs building procedure to follow. Ambit — https://github.com/jturney/ambit; CheMPS2 — [what is CheMPS2?] [CheMPS2 min version]. HDF5 https://support.hdfgroup.org/HDF5/; zlib http://www.zlib.net/. ecpint — [what is ecpint?] [ecpint min version]; dkh — [what is dkh?] [dkh min version]. Fortran Compiler. gdma — [what is gdma?] [gdma min version]. Fortran Compiler. PCMSolver — [what is PCMSolver?]. Fortran Compiler; zlib http://www.zlib.net/. simint — [what is simint?] [simint min version]. Additionally, there are runtime-loaded capabilities:. PylibEFP & libefp — [what is LibEFP?] [LibEFP min version]; cfour — [what is CFOUR?]; dftd3 — [what is DFTD3?]; simple-dftd3 — [what is DFTD3?] (Nov 2022; added by v1.7) preferred alternative to dftd3 https://github.com/dftd3/simple-dftd3; gcp — [what is gCP?]; mctc-gcp — [what is gCP?] (Nov 2022; added by v1.7) preferred alternative to gcp https://github.com/grimme-lab/gcp; dftd4 — <sec:dftd3> https://github.com/dftd4/dftd4; mrcc — [what is MPCC?]; v2rdm_casscf — [what is v2rdm_casscf?]; sns-mp2 — https://github.com/DEShawResearch/sns-mp2/commits/master; resp — https://github.com/cdsgroup/resp; gpu_dfcc — https://github.com/edeprince3/gpu_dfcc/commits/master; OpenFermion-Psi4 — https://github.com/quantumlib/OpenFermion; cppe — https://github.com/maxscheurer/cppe; mp2d — https://github.com/Chandemonium/MP2D; FockCI — https://github.com/shannonhouck/psi4fockci; cct3 — https://github.com/piecuch-group/cct3; adcc — https://github.com/adc-connect/adcc; BrianQC — https://www.brianqc.com/; i-PI — http://ipi-code.org/; psixas — https://github.com/Masterluke87/psixas; MDI — https://github.com/MolSSI-MDI/MDI_Library; ddx — https://github.com/ddsolvation/ddx. How to use conda to get a Psi4 development environment¶; PSI4 has a lot of dependencies, some of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/build_planning.html:8274,simpl,simple-,8274,psi4manual/1.7.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/build_planning.html,1,['simpl'],['simple-']
Usability,"i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. \[H=F_A+W_A+F_B+W_B+V\]; Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, \(F\), the fluctuation potential of each monomer, \(W\), and the; interaction potential, \(V\). The monomer Fock operators, \(F_A+F_B\), are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of \(V\), \(W_A\), and \(W_B\).; Through first-order in \(V\), electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in \(V\). For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the closed-shell SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1)¶\[E_{SAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)} + \delta_{HF}^{(2)}\]; In this notation, \(E^{(vw)}\) defines the order in \(V\) and in \(W_A+W_B\); the; subscript, \(resp\), indicates that orbital relaxation effects are included. (2)¶\[E_{SAPT2} = E_{SAPT0} + E_{elst,resp}^{(12)} + E_{exch}^{(11)} +; E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)} + \; ^{t}\!E_{exch-ind}^{(22)}\]. (3)¶\[E_{SAPT2+} = E_{SAPT2} + E_{disp}^{(21)} + E_{disp}^{(22)}\]. (4)¶\[E_{SAPT2+(3)} = E_{SAPT2+} + E_{elst,resp}^{(13)} + E_{disp}^{(30)}\]. (5)¶\[E_{SAPT2+3} = E_{SAPT2+(3)}; + E_{exch-ind}^{(30)} + E_{ind,resp}^{(30)}; + E_{exch-disp}^{(30)} + E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)}; - \delta_{HF}^{(2)} + \delta_{HF}^{(3)}\]; For SAPT(DFT), the SAPT expansion is truncated at the same level of SAPT0, but the zeroth-order Hamiltonian is chosen to be \(K_A+K_B\), the mono",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:2871,simpl,simplest,2871,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['simpl'],['simplest']
Usability,"i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. \[H=F_A+W_A+F_B+W_B+V\]; Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, \(F\), the fluctuation potential of each monomer, \(W\), and the; interaction potential, \(V\). The monomer Fock operators, \(F_A+F_B\), are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of \(V\), \(W_A\), and \(W_B\).; Through first-order in \(V\), electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in \(V\). For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the closed-shell SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1)¶\[E_{SAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)} + \delta_{HF}^{(2)}\]; In this notation, \(E^{(vw)}\) defines the order in \(V\) and in \(W_A+W_B\); the; subscript, \(resp\), indicates that orbital relaxation effects are included. (2)¶\[E_{SAPT2} = E_{SAPT0} + E_{elst,resp}^{(12)} + E_{exch}^{(11)} +; E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)} + \; ^{t}\!E_{exch-ind}^{(22)}\]. (3)¶\[E_{SAPT2+} = E_{SAPT2} + E_{disp}^{(21)} + E_{disp}^{(22)}\]. (4)¶\[E_{SAPT2+(3)} = E_{SAPT2+} + E_{elst,resp}^{(13)} + E_{disp}^{(30)}\]. (5)¶\[E_{SAPT2+3} = E_{SAPT2+(3)}; + E_{exch-ind}^{(30)} + E_{ind,resp}^{(30)}; + E_{exch-disp}^{(30)} + E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)}; - \delta_{HF}^{(2)} + \delta_{HF}^{(3)}\]; The \(\delta_{HF}^{(2)}\) and \(\delta_{HF}^{(3)}\) terms take into; account higher-order induction effects and are included in the definition; o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:2588,simpl,simplest,2588,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,6,['simpl'],['simplest']
Usability,"i4 provides a very simple mechanism; for doing so: simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html:14684,simpl,simply,14684,psi4manual/1.0.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html,2,['simpl'],['simply']
Usability,"i4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:1781,clear,clear,1781,psi4manual/1.8.x/api/psi4.core.BSVec.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html,1,['clear'],['clear']
Usability,"i4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html:1781,clear,clear,1781,psi4manual/1.9.x/api/psi4.core.BSVec.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html,1,['clear'],['clear']
Usability,"iables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. Mark virtual functions in derived classes with override¶; The override keyword introduced in C++11 is used to mark a function in a; derived class and guarantee that it is overloading a function with the same; signature in the base class. This behavior is checked at compile time. Prefer GiB for memory printing¶; As memory sizes get larger, we should work in giga (requires decimal printing to not round to zero) rather than mega units.; As it’s what we’re computing anyways, we should work in 1024-based (mebi, gibi, etc. https://en.wikipedia.org/wiki/Gibibyte) rather than 1000-based units.; As it’s a unit, put it in brackets.; Note that users can supply MiB, GB, bytes, or whatever; this guideline is for output printing.; outfile->Printf("" DFHelper Memory: AOs need %.3f [GiB]; user supplied %.3f [GiB]. "",; (required * 8 / (1024 * 1024 * 1024.0)),. table of contents. C++ Style; Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; Mark virtual functions in derived classes with override; Prefer GiB for memory printing. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Adding New Code to PSI4; C++ Style. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_style_c-1.html:3064,guid,guideline,3064,psi4manual/1.4.0/prog_style_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_style_c-1.html,2,['guid'],['guideline']
Usability,"iables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. Mark virtual functions in derived classes with override¶; The override keyword introduced in C++11 is used to mark a function in a; derived class and guarantee that it is overloading a function with the same; signature in the base class. This behavior is checked at compile time. Prefer GiB for memory printing¶; As memory sizes get larger, we should work in giga (requires decimal printing to not round to zero) rather than mega units.; As it’s what we’re computing anyways, we should work in 1024-based (mebi, gibi, etc. https://en.wikipedia.org/wiki/Gibibyte) rather than 1000-based units.; As it’s a unit, put it in brackets.; Note that users can supply MiB, GB, bytes, or whatever; this guideline is for output printing.; outfile->Printf("" DFHelper Memory: AOs need %.3f [GiB]; user supplied %.3f [GiB]. "",; (required * 8 / (1024 * 1024 * 1024.0)),. table of contents. C++ Style; Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; Mark virtual functions in derived classes with override; Prefer GiB for memory printing. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Adding New Code to PSI4; C++ Style. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/prog_style_c-1.html:3064,guid,guideline,3064,psi4manual/1.5.0/prog_style_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/prog_style_c-1.html,2,['guid'],['guideline']
Usability,"iables.; In this case, follow Adding PsiAPI Test Cases to prepare as PsiAPI (import psi4) for, roughly speaking, running through pytest.; The PsiAPI/pytest test suite occupies psi4/tests/pytests.; The above description sounds as if there are two disjoint test suites, and you have to run both ctest and pytest to fully test PSI4.; This has indeed been the case until March 2022.; The difficulty has been that (1) two test suites is unexpected so some developers don’t know to run both; and (2) there are important tests in the PSIthon suite that can’t be run on a PSI4 installation since CTest only works in a build directory.; Now, by adding an extra file to the test directory (test_input.py), PSIthon tests can also be run through pytest.; This hasn’t rolled out to all ~500 PSIthon tests (help wanted), but eventually PSI4 can be tested with a single command from a build or from an installation.; Therefore, in designing a test, choose its mode based on whether PSIthon or PsiAPI suits it better and whether it’s a simple model for users (probably PSIthon) or for expert users (probably PsiAPI).; Both will continue to work in future, and neither have limitations. Test Contents¶. Most PSI4 tests will be integration tests focusing on non-regression of user input to answers, and we insist on having these.; But if you find unit tests helpful, by all means add them to the test suite.; Most tests should store reference results (from literature or another implementation or a carefully run PSI4 calculation),; run quantum chemistry, then apply one or more of the Comparison Functions so that the test will fail if the answer is unexpected.; The functions are the same in CTest and pytest, but in the former they are, for example, compare_matrices(refmat, mat, ...) while in the latter it’s asserted, like assert compare_matrices(refmat, mat, ...).; The main advantage of the testing functions is that they provide helpful error printing upon failure. Deep down, they’re NumPy functions.; In prep",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/add_tests.html:2825,simpl,simple,2825,psi4manual/1.6.x/add_tests.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/add_tests.html,5,['simpl'],['simple']
Usability,"ial options for lower method in a given stage. This is useful to calculate a direct stage in an otherwise density-fitted calculation, or similar.; `treatment`: treat extrapolation stage as `scf` or `corl`, by default only the first stage is `scf` and every later one is `corl`.; `stage`: tag for the stage used in tables. The next items in the `cbs_metadata` array extrapolate correlation. All of the above parameters are available, with only the `wfn` and `basis` keywords required. Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters:; molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html:12478,simpl,simple,12478,psi4manual/1.7.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html,8,['simpl'],['simple']
Usability,"icResult(; **{; 'driver': self.driver,; #'keywords': self.keywords,; 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=assembled_results[""module""]),; 'extras': {; 'qcvars': qcvars,; 'cbs_record': copy.deepcopy(self.cbsrec),; },; 'return_result': assembled_results['ret_ptype'],; 'success': True,; }). logger.debug('CBS QCSchema\n' + pp.pformat(cbs_model.dict())). return cbs_model. def get_psi_results(self, return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables; - module if simple. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; cbs_model = self.get_results(). if cbs_model.driver == 'energy':; ret_ptype = cbs_model.return_result; else:; ret_ptype = core.Matrix.from_array(cbs_model.return_result); wfn = _cbs_schema_to_wfn(cbs_model). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _cbs_schema_to_wfn(cbs_model):; """"""Helper function to produce Wavefunction from a Composite-flavored AtomicResult."""""". mol = core.Molecule.from_schema(cbs_model.molecule.dict()); basis = core.BasisSet.build(mol, ""ORBITAL"", 'def2-svp', quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(cbs_model.provenance, ""module""):; wfn.set_module(cbs_model.provenance.module). # wfn.set_energy(cbs_model['extras'['qcvars'].get('CBS TOTAL ENERGY')) # catches Wfn.energy_; for qcv, val in cbs_model.extras['qcvars'].items():; for ob",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:60807,simpl,simple,60807,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['simpl'],['simple']
Usability,"ient to use an; environmental variable (in this case $MYSCRATCH) to set the scratch directory;; the following code will do that:; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). Individual files can be sent to specific locations. For example, file 32 is; the checkpoint file that the user might want to retain in the working directory; (i.e., where PSI4 was launched from) for restart purposes. This is; accomplished by the commands below:; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). A guide to the contents of individual scratch files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously.; To override any of these defaults for selected jobs, simply place the; appropriate commands from the snippets above in the input file itself. During; excecution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed. Executing PSI4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; psi4 -m. Alternately, the scratch directory can be set through the environment; variable PSI_SCRATCH (overrides ~/.psi4rc settings). (First line; for C shell; second line for bash.); setenv PSI_SCRATCH /scratch/user; export PSI_SCRATCH=/scratch/user. The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every PSI4 instance. Threading¶; Most new modules in PSI4 are designed to run efficiently on SMP architectures; via application of several thread models. The de facto standard for PSI4; involves using threaded BLAS/LAPACK (particularly Intel’s excellent MKL package); for most tensor-lik",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/external-1.html:4176,simpl,simply,4176,psi4manual/4.0b3/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/external-1.html,2,['simpl'],['simply']
Usability,"immonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; Psi4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by Psi4, ensure that the program binary (dmrcc) can be; found in your PATH. If Psi4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in Psi4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs Psi4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, Psi4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Note that perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are not available with REFERENCE ROHF. name; calls method in Kallay’s MRCC program [manual]. mrccsd; CC through doubles. mrccsdt; CC through triples. mrccsdtq; CC through quadruples. mrccsdtqp; CC through quintuples. mrccsdtqph; CC through sextuples. mrccsd(t); CC through doubles with perturbative triples. mrccsdt(q); CC through triples with perturbative quadruples. mrccsdtq(p); CC through quadruples with pertubative quintuples. mrccsdtqp(h); CC through quintuples with",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/mrcc-1.html:1262,simpl,simply,1262,psi4manual/1.0.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/mrcc-1.html,2,['simpl'],['simply']
Usability,"imply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible \(M_s\) value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; 1; 2; 3; 4; 5; 6; 7mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; ac",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:15711,simpl,simply,15711,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['simpl'],['simply']
Usability,"import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). Individual files can be sent to specific locations. For example, file 32 is; the checkpoint file that the user might want to retain in the working directory; (i.e., where PSI4 was launched from) for restart purposes. This is; accomplished by the commands below:; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). which is equivalent to; psi4_io.set_specific_path(PSIF_CHKPT, './'); psi4_io.set_specific_retention(PSIF_CHKPT, True). A guide to the contents of individual scratch files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously.; To override any of these defaults for selected jobs, simply place the; appropriate commands from the snippets above in the input file itself. During; excecution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed. Executing PSI4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; psi4 -m. Alternately, the scratch directory can be set through the environment; variable PSI_SCRATCH (overrides ~/.psi4rc settings). (First line; for C shell; second line for bash.); setenv PSI_SCRATCH /scratch/user; export PSI_SCRATCH=/scratch/user. The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every PSI4 instance. Threading¶; Most new modules in PSI4 are designed to run efficiently on SMP architectures; via application of several thread models. The de facto standard for PSI4; involves using threaded BLAS/LAPACK (particularly Intel’s excellent MKL package); for most tensor-lik",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/external-1.html:4290,simpl,simply,4290,psi4manual/4.0b4/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/external-1.html,4,['simpl'],['simply']
Usability,"ines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:10426,simpl,simply,10426,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['simpl'],['simply']
Usability,"ing directly at the double bond in ethylene; this will be attractive because the H atoms in acetylene bear a partial positive charge, while the electron rich double bond in ethylene bears a partial negative charge. At the same time, the dispersion interaction should be smaller because the perpendicular geometry does not allow much overlap between the monomers. Hence, the SAPT analysis helps clarify (and quantify) our physical understanding about the; interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as computing the interaction energy between two neon atoms at various interatomic distances. One simple but unappealing way to do this is to generate separate geometries for each distance to be studied. Instead, we can leverage Python loops and string formatting to make our lives simpler. Additionally, let’s suppose you want to do counterpoise (CP) correction to compute interaction energies. Counterpoise correction involves; computing the dimer energy and then subtracting out the energies of the two monomers, each evaluated in the dimer basis. Again, each of these computations could be run in a separate input file, but because counterpoise correction is a fairly standard procedure for intermolecular interactions, Psi4 knows about it and has a built-in routine to perform counterpoise correction. It only needs to know what method you want to do the couterpoise correction on (here, let’s consider CCSD(T)), and it needs; to know what’s monomer A and what’s monomer B. This last issue of specifying the monomers separately was already dealt with in the previous SAPT example, where we saw that two dashes in the psi4.geometry() string can be used to separate monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:17491,simpl,simpler,17491,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,11,['simpl'],['simpler']
Usability,"ing max_nbody accordingly; # * below, process values of `levels`, which are modelchem strings, into kwargs specs; nbodies_per_mc_level = []; prev_body = 0; for nb in levels:; nbodies = []; if nb == ""supersystem"":; nbodies.append(nb); elif nb != (prev_body + 1):; for m in range(prev_body + 1, nb + 1):; nbodies.append(m); else:; nbodies.append(nb); nbodies_per_mc_level.append(nbodies); prev_body += 1. plan.max_nbody = max(nb for nb in levels if nb != ""supersystem""); plan.nbodies_per_mc_level = nbodies_per_mc_level. for mc_level_idx, mtd in enumerate(levels.values()):; method, basis, cbsmeta = expand_cbs_methods(mtd, basis, driver, cbsmeta=cbsmeta, **kwargs); packet.update({'method': method, 'basis': basis}). # Tell the task builder which level to add a task list for; # * see https://github.com/psi4/psi4/pull/1351#issuecomment-549948276 for discussion of where build_tasks logic should live; if method == ""cbs"":; # This CompositeComputer is discarded after being used for dermode.; simplekwargs = copy.deepcopy(kwargs); simplekwargs.pop('dertype', None); simplecbsmeta = copy.deepcopy(cbsmeta); simplecbsmeta['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplecbsmeta, molecule=original_molecule, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info(""PLANNING MB(CBS): {mc_level_idx=} {packet=} {cbsmeta=} kw={kwargs}""); plan.build_tasks(CompositeComputer, **packet, mc_level_idx=mc_level_idx, **cbsmeta, **kwargs). else:; logger.info(; f""PLANNING MB(FD(CBS): {mc_level_idx=} {packet=} {cbsmeta=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; computer=CompositeComputer,; **cbsmeta,; **current_findif_kwargs,; *",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_planner.html:7486,simpl,simplekwargs,7486,psi4manual/1.7.x/_modules/psi4/driver/task_planner.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_planner.html,4,['simpl'],['simplekwargs']
Usability,"inite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. For maximum; flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +---------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:50093,guid,guide,50093,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,3,['guid'],['guide']
Usability,"int ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:8669,clear,cleared,8669,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,10,['clear'],['cleared']
Usability,"ion intended, find appropriate options at; Keywords. These keyword summaries contain the same; information as the proper CFOUR options list; plus notes on keyword relevance when run through PSI4. Information; at the CFOUR manual may; also be useful, as may the many samples at psi4/samples/cfour.; Set Cfour keywords just like PSI4 keywords. The names of keywords; are unchanged beyond a prepended “cfour_”. (Though be aware that common; abbreviations like CALC and REF must be fully spelled out as; CFOUR_CALC_LEVEL and CFOUR_REFERENCE when used in; PSI4.); In limited trial cases, keywords nominally directed at non-Cfour modules; are translated into their Cfour counterparts. For example, setting; REFERENCE will appropriately set CFOUR_REFERENCE. For a; list of applicable keywords, see source of; qcdb.cfour.muster_psi4options().; Consult Functionality for information on what Cfour; functionality is accessible through PSI4. PSI4 for Cfour Users¶; In the simplest use of the Psi4/Cfour interface, a PSI4 input file; can simply “wrap” a ZMAT file and execute xcfour. This is; illustrated in the following example:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17cfour {; UHF-SCF energy calculation; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0. *ACES2(CALC=HF,BASIS=qz2p; MULT=2,REF=UHF; OCCUPATION=3-1-1-0/3-0-1-0; SCF_CONV=12; MEMORY=20000000); }. energy('cfour'). Here, the contents of the cfour {...} block are written directly to a; ZMAT file. This is joined by a default GENBAS file; (psi4/share/basis/GENBAS). To preferentially use your own GENBAS,; place it in PATH or PSIPATH. The line calling; energy() with argument 'cfour' invokes; xcfour.; After execution of the energy('cfour') line completes, Cfour results; are read back into PSI4 format and are thereafter accessible for; further processing in the input file. See Output for; details. This storage of results in variables and arrays in memory for; the duration of the PSI4 instance (as opposed to solely in files); is the only",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:2877,simpl,simplest,2877,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,12,['simpl'],"['simplest', 'simply']"
Usability,"ion intended, find appropriate options at; Keywords. These keyword summaries contain the same; information as the proper CFOUR options list; plus notes on keyword relevance when run through Psi4. Information; at the CFOUR manual may; also be useful, as may the many samples at psi4/samples/cfour.; Set Cfour keywords just like Psi4 keywords. The names of keywords; are unchanged beyond a prepended “cfour_”. (Though be aware that common; abbreviations like CALC and REF must be fully spelled out as; CFOUR_CALC_LEVEL and CFOUR_REFERENCE when used in; Psi4.); In limited trial cases, keywords nominally directed at non-Cfour modules; are translated into their Cfour counterparts. For example, setting; REFERENCE will appropriately set CFOUR_REFERENCE. For a; list of applicable keywords, see source of; qcdb.cfour.muster_psi4options().; Consult Functionality for information on what Cfour; functionality is accessible through Psi4. Psi4 for Cfour Users¶; In the simplest use of the Psi4/Cfour interface, a Psi4 input file; can simply “wrap” a ZMAT file and execute xcfour. This is; illustrated in the following example:; cfour {; UHF-SCF energy calculation; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0. *ACES2(CALC=HF,BASIS=qz2p; MULT=2,REF=UHF; OCCUPATION=3-1-1-0/3-0-1-0; SCF_CONV=12; MEMORY=20000000); }. energy('cfour'). Here, the contents of the cfour {...} block are written directly to a; ZMAT file. This is joined by a default GENBAS file; (psi4/share/basis/GENBAS). To preferentially use your own GENBAS,; place it in PATH or PSIPATH. The line calling; energy() with argument 'cfour' invokes; xcfour.; After execution of the energy('cfour') line completes, Cfour results; are read back into Psi4 format and are thereafter accessible for; further processing in the input file. See Output for; details. This storage of results in variables and arrays in memory for; the duration of the Psi4 instance (as opposed to solely in files); is the only advantage thus far incurred by the P4C4 interface. We’ll",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:2931,simpl,simplest,2931,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,4,['simpl'],"['simplest', 'simply']"
Usability,"is called a; RASSCF. CASSCF and RASSCF computations are types of multi-configurational; self-consistent-field procedures, and are described in MCSCF: Multi-Configurational Self-Consistent-Field.; As mentioned above, the DETCI module is designed for challenging; chemical systems for which simple CISD is not suitable. Because; CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,; typically the DETCI code will be used in cases where the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. As mentioned above, codes; written specifically for CISD will be more efficient than DETCI for a; CISD computation, and energy('cisd') by default will call other,; more efficient modules. To force a CISD computation with DETCI,; set QC_MODULE = DETCI.; Higher order single-reference CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specified by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:4697,simpl,simply,4697,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,9,['simpl'],['simply']
Usability,"is {...}, as shown below. Multiple basis sets can be; specified by adding additional sections within the surrounding brackets.; Use assign statements to actually request the basis set. This; basis {...} section replaces the usual set basis XXX line.; In a more complex input, if the user needs to call the user-defined; basis by name, this can be achieved using the syntax basis mybas {...},; and then the basis can be recalled later as set basis mybas.; To use a custom basis set as described in this section, it must be; defined prior to its use in a function that performs a computation.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14basis {. # assign basset to all atoms and addl to hydrogens; assign basset; assign H addl. # basis set section like in snippet above goes here; [basset]; ... # additional basis set sections follow; [addl]; ...; }. The test case mints2 provides a complete example of; user-specified basis sets. Inputting effective core potentials (ECPs)¶; For ECP containing basis sets, all of the above mechanisms may still be used to; input the basis set; simply place the ECP definitions (in G94 format) in the; same file or input section as the orbital basis definition. Because the ECP; appears in the same section as the orbital basis, it will be parsed; automatically and the number of core electrons the ECP represents will be; detected, so no further input is required to use a core potential. See; Effective core potentials (ECPs) for more information about using ECPs and the; Def2-TZVP basis set definition; for an example of their input syntax. table of contents. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Psithon: Structuring an Input File. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/basissets-1.html:10295,simpl,simply,10295,psi4manual/1.3.2/basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/basissets-1.html,2,['simpl'],['simply']
Usability,"issing correlation effects. More; details on the implementation and numerical accuracy of FNO methods in; PSI4 can be found in Ref. [DePrince:2013:293]. FNO computations; are controlled through the keywords NAT_ORBS and; OCC_TOLERANCE, or by prepending a valid method name with “fno” in; the energy call as; energy('fno-ccsd(t)'). QCISD(T), CCSD(T), MP4, and CEPA¶; The FNOCC module in PSI4 supports several related many-body quantum; chemistry methods, including the CCSD(T) and QCISD(T) methods, several; orders of many-body perturbation theory (MP2-MP4), and a family methods; related to the coupled electron pair approximation (CEPA). Quadratic configuration interaction and coupled cluster¶; The quadratic configuration interaction singles doubles (QCISD) method of; Pople, Head-Gordon, and Raghavachari [Pople:1987:5968] was originally; presented as a size-consistent extension of configuration interaction; singles doubles (CISD). The method can also be obtained as a; simplified version of the coupled cluster singles doubles (CCSD); method [Purvis:1982]. Consider the set of equations defining CCSD:. (1); where we have chosen the intermediate normalization,; , and the symbols ; and represent single and double excitation operators. The; QCISD equations can be obtained by omitting all but two terms that; are nonlinear in and :. (2); QCISD is slightly cheaper that CCSD computationally, but it retains the; complexity of the original equations. Just as in; the familiar CCSD(T) method, the effects of connected triple excitations; may be included noniteratively to yield the QCISD(T) method. Both the; QCISD(T) and CCSD(T) methods are implemented for closed-shell references; in the FNOCC module. Many-body perturbation theory¶; QCI and CC methods are closely related to perturbation theory, and the; MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/fnocc-1.html:2717,simpl,simplified,2717,psi4manual/4.0b4/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/fnocc-1.html,4,['simpl'],['simplified']
Usability,"ist, tuple, or core.Dimension (optional)) – If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 – Same as dim1 only if using a psi4.core.Dimension object. Returns:matrix – Returns the given Psi4 object. Return type:Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; >>> data = np.random.rand(20); >>> vector = array_to_matrix(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); (2, 0, 4). Matrix to Array¶; A general function that converts NumPy arrays to PSI4 data objects. psi4.driver.p4util.numpy_helper._to_array(matrix, copy=True, dense=False)[source]¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. table of contents. Interface to NumPy; Basics; NumPy Views; PSI4 Data Objects with Irreps; Array to Matrix; Matrix to Array. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 Ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/numpy-1.html:4158,simpl,simply,4158,psi4manual/1.3.2/numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/numpy-1.html,2,['simpl'],['simply']
Usability,"it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (i.e., each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (i.e., each monomer utilizes only its; own basis set). It is also possible to run a SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; sapt_basis='monomer' to the energy function, such as; energy('sapt2',sapt_basis='monomer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat_orbs_t2 true; freeze_core true; }. energy('sapt2+3'). To reiterate some of the options mentioned above: the; NAT_ORBS_T2 option will compute MP2 natural orbitals and use; them in the e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:19016,simpl,simply,19016,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['simpl'],['simply']
Usability,"it with the; command basis {...}, as shown below. Multiple basis sets can be; specified by adding additional sections within the surrounding brackets.; Use assign statements to actually request the basis set. This; basis {...} section replaces the usual set basis XXX line.; In a more complex input, if the user needs to call the user-defined; basis by name, this can be achieved using the syntax basis mybas {...},; and then the basis can be recalled later as set basis mybas.; To use a custom basis set as described in this section, it must be; defined prior to its use in a function that performs a computation.; basis {. # assign basset to all atoms and addl to hydrogens; assign basset; assign H addl. # basis set section like in snippet above goes here; [basset]; ... # additional basis set sections follow; [addl]; ...; }. The test case mints2 provides a complete example of; user-specified basis sets. Inputting effective core potentials (ECPs)¶; For ECP containing basis sets, all of the above mechanisms may still be used to; input the basis set; simply place the ECP definitions (in G94 format) in the; same file or input section as the orbital basis definition. Because the ECP; appears in the same section as the orbital basis, it will be parsed; automatically and the number of core electrons the ECP represents will be; detected, so no further input is required to use a core potential. See; Effective core potentials (ECPs) for more information about using ECPs and the; Def2-TZVP basis set definition; for an example of their input syntax. table of contents. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Psithon: Structuring an Input File; Basis Sets. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/basissets.html:10331,simpl,simply,10331,psi4manual/1.8.x/basissets.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/basissets.html,1,['simpl'],['simply']
Usability,"it with the; command basis {...}, as shown below. Multiple basis sets can be; specified by adding additional sections within the surrounding brackets.; Use assign statements to actually request the basis set. This; basis {...} section replaces the usual set basis XXX line.; In a more complex input, if the user needs to call the user-defined; basis by name, this can be achieved using the syntax basis mybas {...},; and then the basis can be recalled later as set basis mybas.; To use a custom basis set as described in this section, it must be; defined prior to its use in a function that performs a computation.; basis {. # assign basset to all atoms and addl to hydrogens; assign basset; assign H addl. # basis set section like in snippet above goes here; [basset]; ... # additional basis set sections follow; [addl]; ...; }. The test case mints2 provides a complete example of; user-specified basis sets. Inputting effective core potentials (ECPs)¶; For ECP containing basis sets, all of the above mechanisms may still be used to; input the basis set; simply place the ECP definitions (in G94 format) in the; same file or input section as the orbital basis definition. Because the ECP; appears in the same section as the orbital basis, it will be parsed; automatically and the number of core electrons the ECP represents will be; detected, so no further input is required to use a core potential. See; Effective core potentials (ECPs) for more information about using ECPs and the; Def2-TZVP basis set definition; for an example of their input syntax. table of contents. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Psithon: Structuring an Input File; Basis Sets. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/basissets.html:10331,simpl,simply,10331,psi4manual/1.9.x/basissets.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/basissets.html,1,['simpl'],['simply']
Usability,"ith the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). For your convenience, this example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the User Configuration; section of the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about , so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity ).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/tutorial-1.html:1808,simpl,simple,1808,psi4manual/4.0b3/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/tutorial-1.html,6,['simpl'],['simple']
Usability,"ither absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; He; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('scf'). Table Of Contents. Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:19260,simpl,simple,19260,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,2,['simpl'],['simple']
Usability,"ity analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None; docstring. clear_external_potentials(self: psi4.core.HF) → None; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float; docstring. compute_energy(); Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float; docstring. compute_spin_contamination(self: psi4.core.HF) → None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None; docstri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html:13363,simpl,simply,13363,psi4manual/1.3.2/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html,1,['simpl'],['simply']
Usability,"iven shell pair. origin¶; The origin about which the one body ints are being computed. class psi4.core.ErfComplementERI¶; Bases: psi4.core.TwoBodyAOInt; Computes ERF complement electron repulsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.ErfERI¶; Bases: psi4.core.TwoBodyAOInt; Computes ERF electron repulsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.ExternalPotential¶; Bases: pybind11_builtins.pybind11_object; Stores external potential field, computes external potential matrix. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. class psi4.core.F12¶; Bases: psi4.core.TwoBodyAOInt; Computes F12 electron repulsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.F12DoubleCommutator¶; Bases: psi4.core.TwoBodyAOInt; Computes F12 Double Commutator electron repulsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.F12G12¶; Bases: psi4.core.TwoBodyAOInt; Computes F12G12 electron repul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:61587,clear,clear,61587,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,4,['clear'],['clear']
Usability,"iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n"");; core.print_out(""\t\t\t - Starship Troopers\n\n"");; core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n"");; core.print_out(""\t\t\t - Edward Valeev\n"");. if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; # retire components in v1.5; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); core.set_variable(""CURRENT DIPOLE X"", core.variable(name.upper() + "" DIPOLE X"")); core.set_variable(""CURRENT DIPOLE Y"", core.variable(name.upper() + "" DIPOLE Y"")); core.set_variable(""CURRENT DIPOLE Z"", core.variable(name.upper() + "" DIPOLE Z"")); core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:124586,simpl,simplefilter,124586,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['simpl'],['simplefilter']
Usability,"ix to val. set(self: psi4.core.Matrix, m: int, n: int, val: float) -> None. Sets a single element of a matrix to val at row m, col n. set(self: psi4.core.Matrix, h: int, m: int, n: int, val: float) -> None. Sets a single element of a matrix, subblock h, row m, col n, with value val. set_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice, block: psi4.core.Matrix) → None; Set a matrix block. shape; Shape of the Psi4 data object. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → None; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix) → float; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule) → None; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float; Returns the trace of the matrix. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html:25532,simpl,simply,25532,psi4manual/1.2.1/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html,1,['simpl'],['simply']
Usability,"ix to val. set(self: psi4.core.Matrix, m: int, n: int, val: float) -> None. Sets a single element of a matrix to val at row m, col n. set(self: psi4.core.Matrix, h: int, m: int, n: int, val: float) -> None. Sets a single element of a matrix, subblock h, row m, col n, with value val. set_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice, block: psi4.core.Matrix) → None; Set a matrix block. shape; Shape of the Psi4 data object. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → None; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix) → float; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule) → None; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float; Returns the trace of the matrix. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html:25439,simpl,simply,25439,psi4manual/1.3.2/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html,1,['simpl'],['simply']
Usability,"izer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +---------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:61697,guid,guide,61697,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,3,['guid'],['guide']
Usability,"kash Verma, Wallace D. Derricotte, and Francesco A. Evangelista; The exact-two-component (X2C) approach is a convenient way to introduce scalar; relativistic effects in DFT and wave function-based methods.; PSI4 implements the spin-free one-electron version of X2C, which produces; a modified one-electron Hamiltonian \(H_{\rm X2C}\):. \[H_{\rm X2C} = T_{\rm X2C} + V_{\rm X2C}\]; that is a sum of a kinetic energy (\(T_{\rm X2C}\)) and potential energy; (\(V_{\rm X2C}\)) operator.; Our implementation is equivalent to the one reported by Cheng and Gauss [Cheng:084114].; X2C calculations require the use of special (alternatively fully uncontracted) basis sets designed for relativistic; calculations. Common choices include the Dunning Douglass–Kroll basis sets; (cc-pVXZ-DK, cc-pCVXZ-DK, cc-pwCVXZ-DK) and Roos’ ANO basis sets. Note; See also Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess for another relativistic Hamiltonian. A First Example¶; The following is a simple input that will perform a Hartree–Fock calculation; using the X2C Hamiltonian.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12molecule {; H; F 1 0.92; }. set {; scf_type pk; basis cc-pvdz; relativistic x2c; }. energy('hf'). This computation yields the following result:; 1; 2; 3; 4; 5; 6; 7; 8@RHF Final Energy: -100.10007984692388. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.7611816259664579; Two-Electron Energy = 45.4843682167491039; Total Energy = -100.1000798469238902. while a non-relativistic calculation yields the following energy:; 1; 2; 3; 4; 5; 6; 7; 8@RHF Final Energy: -100.01928891411315. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.6645256529074572; Two-Electron Energy = 45.4685031765008461; Total Energy = -100.0192889141131474. Basis sets options¶; The X2C module in PSI4 supports different combinations of basis set.; By default, if the input file specifies only BASIS, then the X2C; module will solve the mod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/relativistic-1.html:1226,simpl,simple,1226,psi4manual/1.1.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/relativistic-1.html,6,['simpl'],['simple']
Usability,"kash Verma, Wallace D. Derricotte, and Francesco A. Evangelista; The exact-two-component (X2C) approach is a convenient way to introduce scalar; relativistic effects in DFT and wave function-based methods.; PSI4 implements the spin-free one-electron version of X2C, which produces; a modified one-electron Hamiltonian \(H_{\rm X2C}\):. \[H_{\rm X2C} = T_{\rm X2C} + V_{\rm X2C}\]; that is a sum of a kinetic energy (\(T_{\rm X2C}\)) and potential energy; (\(V_{\rm X2C}\)) operator.; Our implementation is equivalent to the one reported by Cheng and Gauss [Cheng:084114].; X2C calculations require the use of special (alternatively fully uncontracted) basis sets designed for relativistic; calculations. Common choices include the Dunning Douglass–Kroll basis sets; (cc-pVXZ-DK, cc-pCVXZ-DK, cc-pwCVXZ-DK) and Roos’ ANO basis sets. Note; See also Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess for another relativistic Hamiltonian. A First Example¶; The following is a simple input that will perform a Hartree–Fock calculation; using the X2C Hamiltonian.; molecule {; H; F 1 0.92; }. set {; scf_type pk; basis cc-pvdz; relativistic x2c; }. energy('hf'). This computation yields the following result:; @RHF Final Energy: -100.10007984692388. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.7611816259664579; Two-Electron Energy = 45.4843682167491039; Total Energy = -100.1000798469238902. while a non-relativistic calculation yields the following energy:; @RHF Final Energy: -100.01928891411315. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.6645256529074572; Two-Electron Energy = 45.4685031765008461; Total Energy = -100.0192889141131474. Basis sets options¶; The X2C module in PSI4 supports different combinations of basis set.; By default, if the input file specifies only BASIS, then the X2C; module will solve the modified Dirac equation in an uncontracted basis and then; recontract the X2C Hamilt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/relativistic-1.html:1260,simpl,simple,1260,psi4manual/1.4.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/relativistic-1.html,9,['simpl'],['simple']
Usability,"ks like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. Mark virtual functions in derived classes with override¶; The override keyword introduced in C++11 is used to mark a function in a; derived class and guarantee that it is overloading a function with the same; signature in the base class. This behavior is checked at compile time. Prefer GiB for memory printing¶; As memory sizes get larger, we should work in giga (requires decimal printing to not round to zero) rather than mega units.; As it’s what we’re computing anyways, we should work in 1024-based (mebi, gibi, etc. https://en.wikipedia.org/wiki/Gibibyte) rather than 1000-based units.; As it’s a unit, put it in brackets.; Note that users can supply MiB, GB, bytes, or whatever; this guideline is for output printing.; outfile->Printf("" DFHelper Memory: AOs need %.3f [GiB]; user supplied %.3f [GiB]. "",; (required * 8 / (1024 * 1024 * 1024.0)),. table of contents. C++ Style; Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; Mark virtual functions in derived classes with override; Prefer GiB for memory printing. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Adding New Code to PSI4; C++ Style. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_style_c.html:3073,guid,guideline,3073,psi4manual/master/prog_style_c.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_style_c.html,1,['guid'],['guideline']
Usability,"l Dev', '', minDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). PsiMod.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); PsiMod.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); PsiMod.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; PsiMod.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activate(user_molecule); user_molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", user_basis); PsiMod.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; PsiMod.revoke_global_option_changed('REFERENCE'). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy . [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[H] Wt'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:50605,clear,clear,50605,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,1,['clear'],['clear']
Usability,"l#how-to-bump-a-version; Below is tl;dr; # be on clean master up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3rc1'; -__version_long = '1.3rc1+5a7522a'; -__version_upcoming_annotated_v_tag = '1.3rc2'; +__version__ = '1.3rc2'; +__version_long = '1.3rc2+zzzzzzz'; +__version_upcoming_annotated_v_tag = '1.3rc3'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3rc2""; [master bc8d7f5] v1.3rc2. >>> git log --oneline | head -1; bc8d7f5 v1.3rc2; >>> git tag -a v1.3rc2 bc8d7f5 -m ""v1.3rc2"". # goto GH:psi4/psi4 > Settings > Branches > master > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/424295; # uncheck ""Include administrators"" and Save changes. >>> git push --atomic upstream master v1.3rc2. # pause here and push to upstream and let Azure complete for an; # on-tag Windows conda package and docs, not tag+1.dev1 .; # the atomic flag below pushes commit and tag together so only one CI; # which is necessary for Windows conda package to compute the right version.; # After push, can temporarily re-engage ""Include administrators"" protections.; # also, grab the docs build from GHA artifacts. >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version_long = '1.3rc2+zzzzzzz'; +__version_long = '1.3rc2+bc8d7f5'. >>> git add psi4/metadata.py; >>> git commit -m ""Records tag for v1.3rc2""; [master 16dbd3e] Records tag for v1.3rc2. # goto GH:psi4/psi4 > Settings > Branches > master > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/424295; # uncheck ""Include administrators"" and Save changes. >>> git push upstream master. # re-engage ""Include administrators"" protections. Tag postrelease¶. # be on clean maintenance branch up-to-date with upstream in both commits and tags; # * mind ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/manage_release.html:6477,pause,pause,6477,psi4manual/1.7.x/manage_release.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/manage_release.html,2,['pause'],['pause']
Usability,"lculation yields the following energy:; 1; 2; 3; 4; 5; 6; 7; 8@RHF Final Energy: -100.01928891411315. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.6645256529074572; Two-Electron Energy = 45.4685031765008461; Total Energy = -100.0192889141131474. Basis sets options¶; The X2C module in PSI4 supports different combinations of basis set.; By default, if the input file specifies only BASIS, then the X2C; module will solve the modified Dirac equation in an uncontracted basis and then; recontract the X2C Hamiltonian in the original basis.; Alternatively, the user can use BASIS_RELATIVISTIC to specify a different; basis set to solve the modified Dirac equation.; 1; 2; 3; 4; 5set {; basis cc-pvdz-dk; basis_relativistic cc-pvtz-dk; relativistic x2c; }. It is recommended that when employing the X2C relativistic Hamiltonian, that you use a fully; decontracted basis set. This can be done simply in the input by adding “-decon” to the; name of the primary basis you want to use for the calculation as detailed in; Decontracted Basis Sets. Publications resulting from the use; of X2C should cite the following publication: [Verma:2015]. Theory¶; X2C is based on exact decoupling of; positive-energy ( \(h^{FW}_{\rm ++}\); ) and negative-energy (\(h^{FW}_{\rm --}\) ); blocks of the Dirac Hamiltonian (\(h^{D}\)). \[\begin{split}U^\dagger h^{\rm D} U =; U^\dagger; \begin{pmatrix}; h_{LL} & h_{LS} \\; h_{SL} & h_{SS}; \end{pmatrix}; U; =; \begin{pmatrix}; h^{\rm FW}_{++} & 0 \\; 0 & h^{\rm FW}_{--}; \end{pmatrix}\end{split}\]; The transformation ( \(U\) ) is obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984] treatment.; In the X2C treatment, the positive-energy block of the Hamiltonian ( \(h^{FW}_{\rm ++}\) ); is given by the sum; of a transformed kinetic (\(T_{\rm X2C}\)) and potential energy ( \(V_{\rm X2C}\) ) contribution.; Relativistic kinetic energy ( \(T_{\rm X2C}\) ) and nuclear-electron inte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/relativistic-1.html:2710,simpl,simply,2710,psi4manual/1.1.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/relativistic-1.html,6,['simpl'],['simply']
Usability,"ld_wpbesol_x_functional(name)[source]¶. build_wpbesol_x_superfunctional(name, npoints, deriv)[source]¶. build_ws_x_functional(name)[source]¶. build_ws_x_superfunctional(name, npoints, deriv)[source]¶. build_wsvwn_superfunctional(name, npoints, deriv)[source]¶. functional_list()[source]¶. superfunctional_list()[source]¶. test_ccl_functional(functional, ccl_functional)[source]¶. pcmpreprocess¶. convert_area_scalar(keyword)[source]¶. convert_length_array(keyword)[source]¶. convert_length_scalar(keyword)[source]¶. preprocess()[source]¶; Takes the PCM input file in @pcmsolver.inp, and preprocesses to make it machine-readable. setup_keywords()[source]¶. verify_cavity(section)[source]¶. verify_green(section)[source]¶. verify_medium(section)[source]¶. verify_spheres(keyword)[source]¶. verify_top(section)[source]¶. aliases¶; Module with functions that call upon those in modules; proc, driver, and wrappers. Place in this file quickly defined procedures such as. aliases for complex methods; simple modifications to existing methods. grendel¶. p4util¶; Module to define a class BasisFamily that associates; fitting basis sets to an orbital basis and to provide functions to; query appropriate fitting bases for any orbital basis distributed; with Psi4. class BasisFamily(ornate, orbital=None, jk=None, ri=None, dual=None)[source]¶; Class to associate with an orbital basis name ornate; the gbs file names in which the orbital basis orbital; (usually the coded form of ornate) and jkfit, rifit,; and dualfit auxiliary bases can be found. add_dualfit(fit)[source]¶; Function to add basis fit as associated helper basis; member dualfit to a BasisFamily object. add_jkfit(fit)[source]¶; Function to add basis fit as associated fitting basis; member jkfit to a BasisFamily object. add_rifit(fit)[source]¶; Function to add basis fit as associated fitting basis; member rifit to a BasisFamily object. name()[source]¶; Function to return the ornate name of the orbital basis,; e.g., 6-311++G** for 6-311ppg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:27065,simpl,simple,27065,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['simpl'],['simple']
Usability,"le SAPT0-D can be used with any of the -D; variants using default parameters optimized for Hartee–Fock interaction energies,; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters.; A simple water dimer computation using SAPT0-D may look like:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis jun-cc-pvdz. energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; energy(""fsapt0-d3mbj""). See FSAPT documentation for more details on using FSAPT; for functional group analyses. table of contents. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; CPHF_R_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; COUPLED_INDUCTION; EXCH_SCALE_ALPHA; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; DEBUG. Specific open-shell SAPT0 keywords; SAPT_MEM_SAFETY; COUPLED_INDUCTION. SAPT(DFT); Basic Keywords for SAPT(DFT); SAPT_DFT_GRAC_SHIFT_A; SAPT_DFT_GRAC_SHIFT_B; SAPT_DFT_DO_DHF; SAPT_DFT_EXCH_DISP_SCALE_SCHEME. Advanced Keywords for SAPT(DFT); SAPT_DFT_FUNCTIONAL; SAPT_DFT_DO_HYBRID; SAPT_DFT_EXCH_DISP_FIXED_SCALE; SAPT_DFT_MP2_DISP_ALG; SAPT_QUIET. Higher-Order SAPT; Basic Keywords for Higher-order SAPT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/sapt.html:50328,simpl,simply,50328,psi4manual/master/sapt.html,https://psicode.org,https://psicode.org/psi4manual/master/sapt.html,1,['simpl'],['simply']
Usability,"le SAPT0-D can be used with any of the -D; variants using default parameters optimized for Hartee–Fock interaction energies,; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters.; A simple water dimer computation using SAPT0-D may look like:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis jun-cc-pvdz. energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; energy(""fsapt0-d3mbj""). See FSAPT documentation for more details on using FSAPT; for functional group analyses. table of contents. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; D_CONVERGENCE; E_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; COUPLED_INDUCTION; EXCH_SCALE_ALPHA; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; DEBUG. Specific open-shell SAPT0 keywords; SAPT_MEM_SAFETY; COUPLED_INDUCTION. SAPT(DFT); Basic Keywords for SAPT(DFT); SAPT_DFT_GRAC_SHIFT_A; SAPT_DFT_GRAC_SHIFT_B; SAPT_DFT_DO_DHF; SAPT_DFT_EXCH_DISP_SCALE_SCHEME. Advanced Keywords for SAPT(DFT); SAPT_DFT_FUNCTIONAL; SAPT_DFT_DO_HYBRID; SAPT_DFT_EXCH_DISP_FIXED_SCALE; SAPT_DFT_MP2_DISP_ALG; SAPT_QUIET. Higher-Order SAPT; Basic Keywords for Higher-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/sapt.html:49835,simpl,simply,49835,psi4manual/1.7.x/sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/sapt.html,3,['simpl'],['simply']
Usability,"le SAPT0-D can be used with any of the -D; variants using default parameters optimized for Hartee–Fock interaction energies,; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters.; A simple water dimer computation using SAPT0-D may look like:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis jun-cc-pvdz. energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; energy(“fsapt0-d3mbj”). See FSAPT <fisapt> documentation for more details on using FSAPT; for functional group analyses. table of contents. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; D_CONVERGENCE; E_CONVERGENCE; MAXITER; PRINT. Advanced SAPT0 Keywords; AIO_CPHF; AIO_DF_INTS; COUPLED_INDUCTION; EXCH_SCALE_ALPHA; INTS_TOLERANCE; DENOMINATOR_DELTA; DENOMINATOR_ALGORITHM; DEBUG. Specific open-shell SAPT0 keywords; SAPT_MEM_SAFETY; COUPLED_INDUCTION. SAPT(DFT); Basic Keywords for SAPT(DFT); SAPT_DFT_GRAC_SHIFT_A; SAPT_DFT_GRAC_SHIFT_B; SAPT_DFT_DO_DHF; SAPT_DFT_EXCH_DISP_SCALE_SCHEME. Advanced Keywords for SAPT(DFT); SAPT_DFT_FUNCTIONAL; SAPT_DFT_DO_HYBRID; SAPT_DFT_EXCH_DISP_FIXED_SCALE; SAPT_DFT_MP2_DISP_ALG; SAPT_QUIET. Higher-Order SAPT; Basic Keywords fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:46538,simpl,simply,46538,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,5,['simpl'],['simply']
Usability,"le call detected; if ""cbs_metadata"" not in cbsmeta:; method = cbsmeta[""method""]; basis = cbsmeta[""basis""]; else:; method = ""cbs""; else:; cbsmeta = {}. return method, basis, cbsmeta. [docs]def task_planner(driver: DriverEnum, method: str, molecule: core.Molecule, **kwargs) -> TaskComputers:; """"""Plans a task graph of a complex computation. Canonical Task layering:; - ManyBody - BSSE treatment, many-body expansion; - FiniteDifference - derivatives through stencils; - Composite - basis set extrapolation, focal-point methods; - Atomic - analytic single-points. Parameters; ----------; driver; The resulting type of computation: e/g/h. Note for finite difference; that this should be the target driver, not the means driver.; method; A string representation of the method such as ""HF"" or ""B3LYP"". Special; cases are: ""cbs"".; molecule; A Psi4 base molecule to use.; kwargs; User keyword arguments, often used to configure task computers. Returns; -------; Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer]; A simple (:class:`~psi4.driver.AtomicComputer`) or layered (:class:`~psi4.driver.driver_cbs.CompositeComputer`, :class:`~psi4.driver.driver_findif.FiniteDifferenceComputer`, :class:`~psi4.driver.driver_nbody.ManyBodyComputer`) task object. Layered objects contain many and multiple types of computers in a graph. """""". # Only pull the changed options; keywords = p4util.prepare_options_for_set_options(). keywords[""function_kwargs""] = {}; if ""external_potentials"" in kwargs:; keywords[""function_kwargs""].update({""external_potentials"": kwargs.pop(""external_potentials"")}). # Need to add full path to pcm file; if ""PCM__PCMSOLVER_PARSED_FNAME"" in keywords.keys():; fname = keywords[""PCM__PCMSOLVER_PARSED_FNAME""]; keywords[""PCM__PCMSOLVER_PARSED_FNAME""] = os.path.join(os.getcwd(), fname). # Pull basis out of kwargs, override globals if user specified; basis = kwargs.pop(""basis"", keywords.pop(""BASIS"", ""(auto)"")); method = method.lower(). # Expand CBS methods; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_planner.html:3825,simpl,simple,3825,psi4manual/1.7.x/_modules/psi4/driver/task_planner.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_planner.html,1,['simpl'],['simple']
Usability,"le command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. PSIthonPsiAPI# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = psi4.energy(...); E = psi4.optimize(...); E = psi4.frequency(...); G = psi4.gradient(...) # used by optimize(); H = psi4.hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction. PSIthonPsiAPI# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'myca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:10459,simpl,simple,10459,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['simpl'],['simple']
Usability,"le, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible \(M_s\) value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; 1; 2; 3; 4; 5; 6; 7mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fragmented. Advanced Python¶; A named molecule in an input file is a full-fledged instance of the; powerful C++ Molecule class. Thus, all member; functions ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:15927,simpl,simple,15927,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['simpl'],['simple']
Usability,"lecular complexes from protein-indinavir reaction site.; Geometries from and original reference energies from Faver et al. JCTC 7 790 (2011).; Revised reference interaction energies (HSGA) from Marshall et al. JCP 135 194102 (2011). cp 'off' || 'on'; rlxd 'off'; benchmark; 'HSG0' Faver et al. JCTC 7 790 (2011).; \(\Rightarrow\) 'HSGA' \(\Leftarrow\) Marshall et al. JCP 135 194102 (2011). subset; 'small'; 'large'. A24alt¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries from <Reference>.; Reference interaction energies from Rezac and Hobza, JCTC (in press). cp 'off' <erase this comment and after unless on is a valid option> || 'on'; rlxd 'off' <erase this comment and after unless on is valid option> || 'on'; benchmark; '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset; 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. SSI¶. Database (Merz) of interaction energies for protein sidechain-sidechain interactions.; Geometries from Kenneth Merz Group, Univ. of Florida.; Reference interaction energies from <Reference>.; Part of the BioFragment Database (BFDb). cp 'off' || 'on'; rlxd 'off'. ACENES¶. Database of Ed and Rob’s favorite linear acene dimers.; Geometries from nowhere special, and reference energies undefined. cp 'off' || 'on'; rlxd 'off'; subset; 'small'; 'large'; 'FIRST3' benzene, napthalene, and anthracene dimers; 'FIRST5' benzene - pentacene dimers; 'FIRST10' benzene - decacene dimers. RGC10¶. Database (Sherrill) of interaction energies for dissociation curves of rare-gas biatomic complexes.; Geometries and reference interaction energies from Tang et al. JCP 118 4976 (2003). cp 'off' || 'on'; rlxd 'off'; subset; 'small'; 'large'; 'equilibrium'; 'HeHe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_available_databases-1.html:9859,simpl,simple,9859,psi4manual/1.2.1/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_available_databases-1.html,12,['simpl'],['simple']
Usability,"ler # Rarely needed; dft_nuclear_scheme treutler # Rarely needed; dft_density_tolerance 1.0E-10 # Rarely needed; dft_basis_tolerance 1.0E-11 # Can speed things up, but benchmark the error; dft_pruning_scheme robust # Generally safe and will speed things up; }. energy('b3lyp'). ERI Algorithms¶; The ERI algorithms for the Coulomb and hybrid exchange are identical to; those for Hartree–Fock. However, for LRC functionals, the long-range; exchange contributions to the Kohn–Sham matrix have only been implemented in the; DF and DIRECT algorithms. The use of DF is highly recommended for KS-DFT, as the; errors incurred by the density fitting approximation (in a proper -JKFIT; auxiliary basis) are orders of magnitude smaller than the accuracy of any known; functional. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; memory 512 MB. molecule h2o {; 0 1 # must be neutral; O; H 1 1.0; H 1 1.0 2 104.5; # IP fitting runs in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; }. # Optional arguments are minimum omega, maximum omega, molecule object; omega = ip_fitting('wb97', 0.4, 2.0, molecule=h2o). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:24394,simpl,simply,24394,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,5,['simpl'],['simply']
Usability,"ler, and run make). To be used by PSI4, the program binary (gcp or mctc-gcp) must be; found in your PATH so that QCEngine can detect it. Check if and where; found through qcengine info. If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672], “PBEh-3c”; [Grimme:2015:054107], “B97-3c” [Brandenburg:2018:b973c], “r2SCAN-3c” [Grimme:2021:064103],; and “wB97X-3c” [Muller:2023:014103] methods (both energy and gradient).; The interface can use classic or mctc-gcp executables but only the latter implements “B97-3c” and “r2SCAN-3c”.; The newest wB97X-3c method doesn’t use a gcp correction (it does use ECPs down to first row elements); but is listed here for completeness of the “3c” family.; A DFTD3 executable, classic or simple-dftd3, must also be available for; the HF-3c, PBEh-3c, or B97-3c methods to run.; A DFTD4 python module must also be available for; the r2SCAN-3c or wB97X-3c methods to run.; These method are defined with their own basis set and thus no basis set should be set by the user.; PSI4 will select the intended basis sets: HF-3c/MINIX, PBEh-3c/def2-mSVP, B97-3c/def2-mTZVP, r2SCAN-3c/def2-mTZVPP, wB97X-3c/vDZP.; If a basis has previously been set for another calculation, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; optimize('pbeh3c'). r2SCAN-3c with default basis after basis set; set basis cc-pvdz; energy('r2scan3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/gcp.html:2577,simpl,simple-,2577,psi4manual/1.9.x/gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/gcp.html,2,['simpl'],['simple-']
Usability,"libraries; (especially the former). In addition, the most common compilation problems; involve these libraries. Users may therefore wish to consider the following; BLAS and LAPACK recommendations when building PSI4:. It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Perhaps the best choice, if you have it available, is; Intel’s MKL library, which includes BLAS and LAPACK (note: use; version 11 or later, we had difficulty with version 10 for very; large coupled-cluster computations). MKL is efficient and works; well in threaded mode.; Otherwise, the simplest choice is to use ATLAS; (http://math-atlas.sourceforge.net/), which is readily available; on all Linux distributions. Another alternative is OpenBLAS; (https://github.com/xianyi/OpenBLAS, formerly GotoBLAS). These; work well on nearly every achitecture to which the PSI4 developers; have access, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib package that comes with Xcode works well. PSI4 does not require a Fortran compiler, unless the resident BLAS; and LAPACK libraries require Fortran-based system libraries. If you see; compiler complaints about missing symbols like “do_fio” or “e_wsfe”, then; your libraries were most likely compiled with g77 or gfortran, which; require -lg2c to resolve the Fortran I/O calls. Use of the same gcc; package for PSI4 should normally resolve this problem. The PSI4 configure script can often identify and use several; different BLAS and LAPACK libraries, but its ability to do this; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:21486,simpl,simplest,21486,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,2,['simpl'],['simplest']
Usability,"libraries; (especially the former). In addition, the most common compilation problems; involve these libraries. Users may therefore wish to consider the following; BLAS and LAPACK recommendations when building PSI4:. It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Perhaps the best choice, if you have it available, is; Intel’s MKL library, which includes BLAS and LAPACK (note: use; version 11 or later, we had difficulty with version 10 for very; large coupled-cluster computations). MKL is efficient and works; well in threaded mode.; Otherwise, the simplest choice is to use ATLAS; (http://math-atlas.sourceforge.net/), which is readily available; on all Linux distributions. Another alternative is OpenBLAS; (https://github.com/xianyi/OpenBLAS, formerly GotoBLAS). These; work well on nearly every achitecture to which the PSI4 developers; have access, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib package that comes with Xcode works well.; If you prefer to use the ACML; (http://developer.amd.com/tools/cpu-development/amd-core-math-library-acml/); we highly recommend using the latest version. Older versions; of ACML have been known to cause problems. PSI4 does not require a Fortran compiler, unless the resident BLAS; and LAPACK libraries require Fortran-based system libraries. If you see; compiler complaints about missing symbols like “do_fio” or “e_wsfe”, then; your libraries were most likely compiled with g77 or gfortran, which; require -lg2c to resolve the Fortran",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/installfile.html:21252,simpl,simplest,21252,psi4manual/4.0b5/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/installfile.html,1,['simpl'],['simplest']
Usability,"like quantity, the screening can be performed on the; product, which yields more sparsity. To enable this, simply call the integral; object’s update_density member, passing it a SharedMatrix holding the; current density (remember that it changes during each iteration of the SCF) and; the product will be considered during screening. If only coulomb-like terms; are to be computed, the needs_exchange argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking¶; Each underlying integral engine knows whether it will use blocks, and will set up; the metadata automatically. Instead of looping over individual shells, the; user should loop over blocks supplied by the integral object; these blocks will; be just a single shell quartet combination for the case where blocking is not; used. It is simple to loop over pairs within each block using C++11 syntax, as; demonstrated in the code snippet above. Only shell pairs with significant; overlap are included in the shell block information, making this an efficient; way to loop over non-negligible terms. Permutational symmetry¶; The pairs within each block are optimized for efficiency. First, they are; screened during the integral object’s creation to ensure that only terms with; appreciable overlap are stored. Second, only P,Q combinations that are; permutationally unique are stored, ordered with the higher angular momentum; first. Therefore care must be taken to ensure that the missing permutations; are correctly accounted for when processing the integrals within the loop. See; the DirectJK code in libfock for an example of using this scheme for a Fock; matrix build. Using bra-ket symmetry¶; In cases where there is no batching performed, bra-ket symmetry can be; trivially enforced by ensuring that one of the block indices is greater than or; equal to the other. When batching i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_integrals-1.html:7292,simpl,simple,7292,psi4manual/1.4.0/prog_integrals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_integrals-1.html,9,['simpl'],['simple']
Usability,"list (List[psi4.driver.task_base.AtomicComputer]); trove (List[Dict[str, Any]]); verbose (int). Validators:. set_molecule » molecule. field basis: str = '(auto)'¶. field cbsrec: List[Dict[str, Any]] = []¶. field compute_list: List[Dict[str, Any]] = []¶. field driver: DriverEnum [Required]¶. field keywords: Dict[str, Any] = {}¶. field metadata: Any = None¶. field metameta: Dict[str, Any] = {}¶. field method: str = '(auto)'¶. field molecule: Any = None¶. Validated by:. set_molecule. field results_list: List[Any] = []¶. field task_list: List[AtomicComputer] = []¶. field trove: List[Dict[str, Any]] = []¶. field verbose: int = 1¶. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶. Parameters:; client (Optional[FractalClient]) – . get_psi_results(return_wfn=False)[source]¶; Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:; return_wfn (bool) – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. molecule; dummy basis, def2-svp; e/g/h member data; QCVariables; module if simple. Return type:; Union[float, Matrix, Tuple[Union[float, Matrix], Wavefunction]]. Returns:. ret – Energy, gradient, or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. get_results(client=None)[source]¶; Return results as Composite-flavored QCSchema. Return type:; AtomicResult. Parameters:; client (Optional[FractalClient]) – . plan()[source]¶. validator set_molecule  »  molecule[source]¶. table of contents. Complete Basis Set; Output; Extrapolation Schemes; Aliases; API. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon Functions: Invoking a Calculation; Complete Basis Set. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cbs.html:37378,simpl,simple,37378,psi4manual/1.7.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cbs.html,1,['simpl'],['simple']
Usability,"ll possible combinations of cluster size. geometry(geom, name='default')[source]¶; Function to create a molecule object of name name; from the geometry in string geom. Permitted for user use but deprecated in; driver in favor of explicit molecule-passing. new_get_attr(self, name)[source]¶; Function to redefine __getattr__ method of molecule class. new_set_attr(self, name, value)[source]¶; Function to redefine __setattr__ method of molecule class. driver_util¶. parse_arbitrary_order(name)[source]¶; Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. parse_cotton_irreps(irrep, point_group)[source]¶; Function to return validated Cotton ordering index for molecular; point_group from string or integer irreducible representation irrep. aliases¶; Module with functions that call upon those in modules; proc, driver, and wrappers. Place in this file quickly defined procedures such as. aliases for complex methods; simple modifications to existing methods. fake_file11(wfn, filename='fake_file11.dat', **kwargs)[source]¶; Function to print a file filename of the old file11 format; from molecule and gradient information in wfn. New in version 0.6: wfn parameter passed explicitly. Returns:None. Parameters:; filename (string) – destination file name for file11 file; wfn (Wavefunction) – set of molecule, gradient from which to generate file11. Examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). interactive¶. run()[source]¶. pubchem¶. class PubChemObj(cid, mf, iupac)[source]¶. getCartesian()[source]¶; Function to return a string of the atom symbol and XYZ; coordinates of the PubChem object. getMoleculeString()[source]¶; Function to obtain a molecule string through; getCartesian() or fail. getSDF()[source]¶; Function to return the SDF (structure-data file) of the PubChem object. getXYZFile()[source]¶; Function to obtain preferenti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:3246,simpl,simple,3246,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['simpl'],['simple']
Usability,"loat, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential) → psi4.core.Matrix¶; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.gradient_on_charges(); ExternalPotential.print_out(); ExternalPotential.setName(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html:2854,clear,clear,2854,psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,1,['clear'],['clear']
Usability,"lternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_properties[0], alternatives)). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(); adc_wfn = run_adcc(name, do_timer=False, **kwargs); state = adc_wfn.adcc_state; hf = state.reference_state; mp = state.ground_state. # Formats and indention; ind = "" ""; def format_vector(label, data):; assert data.ndim == 1; return f""{label:<40s} "" + "" "".join(f""{d:12.6g}"" for d in data). if ""DIPOLE"" in properties:; lines = [""\nGround state properties""]; lines += [ind + ""Hartree-Fock (HF)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", hf.dipole_moment)]. if state.method.level > 1:; lines += [ind + ""Møller Plesset 2nd order (MP2)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", mp.dipole_moment(2))]; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for i, cart in enumerate([""X"", ""Y"", ""Z""]):; # retire components at v1.5; adc_wfn.set_variable(""MP2 dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""current dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""MP2 dipole"", mp.dipole_moment(2)); adc_wfn.set_variable(""current dipole"", mp.dipole_moment(2)); lines += [""""]; core.print_out(""\n"".join(lines) + ""\n""). gauge = core.get_option(""ADC"", ""GAUGE"").lower(); if gauge == ""velocity"":; gauge_short = ""VEL""; elif gauge == ""length"":; gauge_short = ""LEN""; else:; raise ValidationError(f""Gauge {gauge} not recognised for ADC calculations.""). computed = []; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; props = {}; if any(prop in properties for prop in (""TRANSITION_DIPOLE"", ""OSCILLATOR_STRENGTH"")):; data = excitation.transition_dipole_moment; props[""Transition dipole moment (in a.u.)""] = data; data_mat = data.reshape(1, 3); for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:121830,simpl,simplefilter,121830,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['simpl'],['simplefilter']
Usability,"lternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_properties[0], alternatives)). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(); adc_wfn = run_adcc(name, do_timer=False, **kwargs); state = adc_wfn.adcc_state; hf = state.reference_state; mp = state.ground_state. # Formats and indention; ind = "" ""; def format_vector(label, data):; assert data.ndim == 1; return f""{label:<40s} "" + "" "".join(f""{d:12.6g}"" for d in data). if ""DIPOLE"" in properties:; lines = [""\nGround state properties""]; lines += [ind + ""Hartree-Fock (HF)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", hf.dipole_moment)]. if state.method.level > 1:; lines += [ind + ""Møller Plesset 2nd order (MP2)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", mp.dipole_moment(2))]; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for i, cart in enumerate([""X"", ""Y"", ""Z""]):; # retire components at v1.5; adc_wfn.set_variable(""MP2 dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""current dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""MP2 dipole"", mp.dipole_moment(2)); adc_wfn.set_variable(""current dipole"", mp.dipole_moment(2)); lines += [""""]; core.print_out(""\n"".join(lines) + ""\n""). gauge = core.get_option(""ADC"", ""GAUGE"").lower(); if gauge == ""velocity"":; gauge_short = ""VEL""; elif gauge == ""length"":; gauge_short = ""LEN""; else:; raise ValidationError(f""Gauge {gauge} not recognised for ADC calculations.""). computed = {}; if any(prop in properties for prop in (""TRANSITION_DIPOLE"", ""OSCILLATOR_STRENGTH"")):; data = state.transition_dipole_moment; computed[""Transition dipole moment (in a.u.)""] = data; adc_wfn.set_variable(f""{name} transition dipoles"", core.Matrix.from_array(data)). if ""OSCILLATOR_STRENGTH"" in properties:; if gauge == ""velocity"":; data = state.oscillator_strength_velocity.reshape(-1, 1); else:; da",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:119056,simpl,simplefilter,119056,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['simpl'],['simplefilter']
Usability,"lts,; },; 'return_result': ret_ptype,; 'success': True,; }). return nbody_model. [docs] def get_psi_results(self, return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into ManyBody-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - supersystem molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; nbody_model = self.get_results(); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., ""2""); dicts = [; #""energies"", # retired; #""ptype"", # retired; ""intermediates"",; ""intermediates_energy"", #""intermediates2"",; ""intermediates_gradient"", #""intermediates_ptype"",; ""intermediates_hessian"", #""intermediates_ptype"",; ""energy_body_dict"",; ""gradient_body_dict"", # ptype_body_dict; ""hessian_body_dict"", # ptype_body_dict; ""nbody"",; ""cp_energy_body_dict"",; ""nocp_energy_body_dict"",; ""vmfc_energy_body_dict"",; ""cp_gradient_body_dict"",; ""nocp_gradient_body_dict"",; ""vmfc_gradient_body_dict"",; ""cp_hessian_body_dict"",; ""nocp_hessian_body_dict"",; ""vmfc_hessian_body_dict"",; ]. for qcv, val in nbody_model.extras['qcvars'].items():; if isinstance(val, dict):; if qcv in dicts:; for qcv2, val2 in val.items():; for obj in [core, wfn]:; try:; obj.set_variable(str(qcv2), val2); except ValidationError:; obj.set_variable(f""{self.driver.name} {qcv2}"", val2); else:; for obj in [core, wfn]:; obj.set_variable(qcv, val). if self.driver == 'gradient':; ret = core.M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:91980,simpl,simple,91980,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,1,['simpl'],['simple']
Usability,"lts,; },; 'return_result': ret_ptype,; 'success': True,; }). return nbody_model. [docs] def get_psi_results(self, return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into ManyBody-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - supersystem molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; nbody_model = self.get_results(); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., ""2""); dicts = [; #""energies"", # retired; #""ptype"", # retired; ""intermediates"",; ""intermediates_energy"", #""intermediates2"",; ""intermediates_gradient"", #""intermediates_ptype"",; ""intermediates_hessian"", #""intermediates_ptype"",; ""energy_body_dict"",; ""gradient_body_dict"", # ptype_body_dict; ""hessian_body_dict"", # ptype_body_dict; ""nbody"",; ""cp_energy_body_dict"",; ""nocp_energy_body_dict"",; ""vmfc_energy_body_dict"",; ""cp_gradient_body_dict"",; ""nocp_gradient_body_dict"",; ""vmfc_gradient_body_dict"",; ""cp_hessian_body_dict"",; ""nocp_hessian_body_dict"",; ""vmfc_hessian_body_dict"",; ]. for qcv, val in nbody_model.extras['qcvars'].items():; if isinstance(val, dict):; if qcv in dicts:; for qcv2, val2 in val.items():; for obj in [core, wfn]:; try:; obj.set_variable(str(qcv2), val2); except ValidationError:; obj.set_variable(f""{self.driver} {qcv2}"", val2); else:; for obj in [core, wfn]:; obj.set_variable(qcv, val). if self.driver == 'gradient':; ret = core.Matrix",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:91546,simpl,simple,91546,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,1,['simpl'],['simple']
Usability,"lue for this keyword is slightly complicated. For TDA calculations, the default is EXPECTATION since the evaluation of transition moments involves only a negligible amount of additional computation relative to the evaluation of the excitation energies. For EOMCC, the default is OFF since evaluation of any transition moments or properties requires approximately twice the computational time. Transition moments and dipole strengths are evaluated by default for all values of ESTATE_PROP other than OFF. Type: string; Possible Values: OFF, EXPECTATION, UNRELAXED, RESPONSE; Default: No Default. CFOUR_ESTATE_SYM¶. Specifies the number of excited states which are to be determined in each irreducible representation of the computational subgroup. The program attempts to find all of the lowest roots, but this is not guaranteed because the eigenvalue problem is not solved by direct matrix diagonalization, but rather by an iterative (modified Davidson) algorithm. For excited state gradient calculations, only one root (clearly) is used. In such a case, one and only one non-zero entry in the string can be used, and this value is usually set to one (i.e. 0/1/0/0). (However sometimes one wants to calculate the gradient for, say, the second root of a given symmetry, and in such a case, one could use 0/2/0/0. What happens is that both roots are calculated, but only the second one is used in the subsequent density matrix and gradient calculation.) The format used for this keyword is identical to that used in CFOUR_OCCUPATION For example, for a computational subgroup having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Psi4 Interface: The array above is specified in PSI as (white space tolerant) [3,1,0,2]. Type: array; Default: No Default. C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:19343,clear,clearly,19343,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,13,['clear'],['clearly']
Usability,"lue for this keyword is slightly complicated. For TDA calculations, the default is EXPECTATION since the evaluation of transition moments involves only a negligible amount of additional computation relative to the evaluation of the excitation energies. For EOMCC, the default is OFF since evaluation of any transition moments or properties requires approximately twice the computational time. Transition moments and dipole strengths are evaluated by default for all values of ESTATE_PROP other than OFF. Type: string; Possible Values: OFF, EXPECTATION, UNRELAXED, RESPONSE; Default: No Default. CFOUR_ESTATE_SYM¶. Specifies the number of excited states which are to be determined in each irreducible representation of the computational subgroup. The program attempts to find all of the lowest roots, but this is not guaranteed because the eigenvalue problem is not solved by direct matrix diagonalization, but rather by an iterative (modified Davidson) algorithm. For excited state gradient calculations, only one root (clearly) is used. In such a case, one and only one non-zero entry in the string can be used, and this value is usually set to one (i.e. 0/1/0/0). (However sometimes one wants to calculate the gradient for, say, the second root of a given symmetry, and in such a case, one could use 0/2/0/0. What happens is that both roots are calculated, but only the second one is used in the subsequent density matrix and gradient calculation.) The format used for this keyword is identical to that used in CFOUR_OCCUPATION For example, for a computational subgroup having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Type: array; Default: No Default. CFOUR_ESTATE_TRANS¶. Specifies whether just the excitation energies (OFF, =0) or in additi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:19845,clear,clearly,19845,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,4,['clear'],['clearly']
Usability,"lue},i,i). psi4.NablaInt.origin()¶; Python Library Documentation: property. The origin about which the one body ints are being computed. psi4.NablaInt.py_buffer()¶; Python Library Documentation: property. docstring. psi4.NablaInt.py_buffer_object()¶; Python Library Documentation: property. docstring. psi4.NablaInt.set_enable_pybuffer()¶; Python Library Documentation: method set_enable_pybuffer; set_enable_pybuffer(...) unbound psi4.NablaInt method. set_enable_pybuffer( (OneBodyAOInt)arg1, (bool)arg2) -> None :. docstring; C++ signature :. void set_enable_pybuffer(N3psi12OneBodyAOIntE {lvalue},b). OEProp¶. psi4.OEProp.add()¶; Python Library Documentation: method add; add(...) unbound psi4.OEProp method. add( (OEProp)arg1, (str)arg2) -> None :. docstring; C++ signature :. void add(N3psi6OEPropE {lvalue},Ss). psi4.OEProp.clear()¶; Python Library Documentation: method clear; clear(...) unbound psi4.OEProp method. clear( (OEProp)arg1) -> None :. docstring; C++ signature :. void clear(N3psi6OEPropE {lvalue}). psi4.OEProp.compute()¶; Python Library Documentation: method compute; compute(...) unbound psi4.OEProp method. compute( (OEProp)arg1) -> None :. docstring; C++ signature :. void compute(N3psi6OEPropE {lvalue}). psi4.OEProp.set_Da_ao()¶; Python Library Documentation: method set_Da_ao; set_Da_ao(...) unbound psi4.OEProp method. set_Da_ao( (OEProp)arg1, (Matrix)arg2, (int)arg3) -> None :. docstring; C++ signature :. void set_Da_ao(N3psi6OEPropE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE,i). psi4.OEProp.set_Da_mo()¶; Python Library Documentation: method set_Da_mo; set_Da_mo(...) unbound psi4.OEProp method. set_Da_mo( (OEProp)arg1, (Matrix)arg2) -> None :. docstring; C++ signature :. void set_Da_mo(N3psi6OEPropE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE). psi4.OEProp.set_Da_so()¶; Python Library Documentation: method set_Da_so; set_Da_so(...) unbound psi4.OEProp method. set_Da_so( (OEProp)arg1, (Matrix)arg2) -> None :. docstring; C++ signature :. void set_Da_so(N3psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:261333,clear,clear,261333,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['clear'],['clear']
Usability,"ly at the double bond in ethylene; this will be attractive because; the H atoms in acetylene bear a partial positive charge, while the; electron rich double bond in ethylene bears a partial negative charge.; At the same time, the dispersion interaction should be smaller because; the perpendicular geometry does not allow much overlap between the; monomers. Hence, the SAPT analysis helps clarify (and quantify) our; physical understanding about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops and string formatting to make our lives; simpler. Additionally, let’s suppose you want to do counterpoise (CP); correction to compute interaction energies. Counterpoise correction; involves computing the dimer energy and then subtracting out the; energies of the two monomers, each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of specifying the monomers separately was; already dealt with in the previous SAPT example, where we saw that two; dashes in the psi4.geometry() string can be used to separate; monomers.; So, we’re going to do counterpoise-corrected CCSD(T) en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:17618,simpl,simpler,17618,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['simpl'],['simpler']
Usability,"ly recommended for all CC calculations up to CCSD(T) and has been implemented for energy, gradient, second-derivative, and excitation energy calculations. Type: string; Possible Values: STANDARD, AOBASIS; Default: STANDARD. CFOUR_ACTIVE_ORBI (CFOUR)¶CFOUR — Specifies the active orbitals used in a TCSCF calculation and has to be used in combination with the keyword CFOUR_CORE_ORBITALS. The active orbitals are specified by either NIRREP or 2*NIRREP integers specifying the number of active orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. For more information and an example see CFOUR_OCCUPATION . Type: array; Default: No Default. CFOUR_ANH_ALGORITHM (CFOUR)¶CFOUR — Specifies which algorithm is used for CFOUR_ANHARMONIC =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations being done in series. If PARALLEL (=1), then the job stops after the second-derivative calculation at the reference geometry and generates out all input geometries for the remaining calculation. These can be then processed in “parallel” (currently not recommended). Note that it is recommended to carry out all calculations with PARALLEL, even when the actual calculation is carried out in a sequential mode. Type: string; Possible Values: STANDARD, PARALLEL; Default: STANDARD. CFOUR_ANH_DERIVATIVES (CFOUR)¶CFOUR — Specifies whether the anharmonic force field is calculated using analytic gradients (=FIRST) or analytic Hessians (=SECOND). Type: string; Possible Values: FIRST, SECOND; Default: SECOND. CFOUR_ANH_STEPSIZE (CFOUR)¶CFOUR — Controls the stepsize used in anharmonic force field calculations. The value is specified in reduced normal coordinates, which are dimensionless. The actual stepsize used in the calculation is \(\times 10",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:19642,simpl,simply,19642,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['simpl'],['simply']
Usability,mDIPOLEY. CIROOTn->ROOTmDIPOLEZ. CIROOTn->ROOTmQUADRUPOLEXX. CIROOTn->ROOTmQUADRUPOLEXY. CIROOTn->ROOTmQUADRUPOLEXZ. CIROOTn->ROOTmQUADRUPOLEYY. CIROOTn->ROOTmQUADRUPOLEYZ. CIROOTn->ROOTmQUADRUPOLEZZ. CIROOTnCORRELATIONENERGY. CIROOTnDIPOLEX. CIROOTnDIPOLEY. CIROOTnDIPOLEZ. CIROOTnQUADRUPOLEXX. CIROOTnQUADRUPOLEXY. CIROOTnQUADRUPOLEXZ. CIROOTnQUADRUPOLEYY. CIROOTnQUADRUPOLEYZ. CIROOTnQUADRUPOLEZZ. CIROOTnTOTALENERGY. CIS_AD_STATES (CPHF). CIS_AMPLITUDE_CUTOFF (CPHF). CIS_DOPDM_STATES (CPHF). CIS_MEM_SAFETY_FACTOR (CPHF). CIS_NO_STATES (CPHF). CIS_OPDM_STATES (CPHF). CIS_TOPDM_STATES (CPHF). CISDCORRELATIONENERGY. CISDDIPOLEX. CISDDIPOLEY. CISDDIPOLEZ. CISDQUADRUPOLEXX. CISDQUADRUPOLEXY. CISDQUADRUPOLEXZ. CISDQUADRUPOLEYY. CISDQUADRUPOLEYZ. CISDQUADRUPOLEZZ. CISDTCORRELATIONENERGY. CISDTOTALENERGY. CISDTQCORRELATIONENERGY. CISDTQTOTALENERGY. CISDTTOTALENERGY. CISTATE-AVERAGEDCORRELATIONENERGY. CISTATE-AVERAGEDTOTALENERGY. Citation class in qcdb.modelchems. CITOTALENERGY. clear() LibmintsMolecule method. OrderedDict method. clear_basis_all_atoms() LibmintsMolecule method. clone() CartesianEntry method. LibmintsMolecule method. NumberValue method. VariableValue method. ZMatrixEntry method. coef() ShellInfo method. coefs() ShellInfo method. COLLAPSE_SIZE (DETCI). COLLAPSE_WITH_LAST (CCEOM). colors InPsight attribute. common_init() CharacterTable method. compare_arrays() in module p4util.util. compare_csx() in module p4util.util. compare_cubes() in module p4util.util. compare_integers() in module p4util.util. in module qcdb.psiutil. compare_matrices() in module p4util.util. in module qcdb.psiutil. compare_strings() in module p4util.util. in module qcdb.psiutil. compare_values() in module p4util.util. in module qcdb.psiutil. compare_vectors() in module p4util.util. compilers. compiling. complete_basis_set(); . see cbs(); . complete_basis_set() in module driver_cbs. complex() CharacterTable method. IrreducibleRepresentation method. COMPLEX_TOLERANCE (CCEOM). composition_til,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:23025,clear,clear,23025,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['clear'],['clear']
Usability,"manager to send all files to; another location, say /scratch/user, add the following command to your input; file:; 1psi4_io.set_default_path('/scratch/user'). For batch jobs running through a queue, it might be more convenient to use an; environmental variable (in this case $MYSCRATCH) to set the scratch directory;; the following code will do that:; 1; 2; 3; 4import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). Individual files can be sent to specific locations. For example, file 32 is; the checkpoint file that the user might want to retain in the working directory; (i.e., where PSI4 was launched from) for restart purposes. This is; accomplished by the commands below:; 1; 2; 3; 4; 5; 6psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). # equivalent to above; psi4_io.set_specific_path(PSIF_CHKPT, './'); psi4_io.set_specific_retention(PSIF_CHKPT, True). A guide to the contents of individual scratch files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously. This also means that if the user wants PSI4 to use; information from a previous file, like molecular orbitals, he needs to provide the; name of the file. This can be done through the restart_file option; 1energy('scf',restart_file='./psi.PID.name.filenumber'). where by default, PID is the process number, name the name of the molecule,; and filenumber is listed in content. Only the filenumber; is necessary for the driver to appropriately rename the file for the next PSI4; job, and if none is found it defaults to 32, a checkpoint file. If two or more files; are to be read, they need to be provided as a Python list; 1energy('scf',restart_file=['./file1.filenumber','./file2.filenumber']).",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:6696,guid,guide,6696,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,6,['guid'],['guide']
Usability,"matches to string seq1 among options. format_molecule_for_input(mol[, name, forcexyz]); Old function for input string from molecule. format_options_for_input([molecule]); Function to return a string of commands to replicate the current state of user-modified options. free_atom_volumes(wfn, **kwargs); Computes free-atom volumes using MBIS density partitioning. get_memory(); Return the total memory allocation in bytes. get_psifile(fileno[, pidspace]); Form full path and filename for psi scratch file. getattr_ignorecase(module, attr); Extract attribute attr from module if attr is available in any possible lettercase permutation. hamiltonian_solver(engine, guess, *, nroot); Finds the smallest eigenvalues and associated right and left hand eigenvectors of a large real Hamiltonian eigenvalue problem emulated through an engine. hold_options_state(); Return a context manager that will collect the current state of Process:environment.options on entry to the with-statement and clear and restore the collected keywords state when exiting the with-statement. import_ignorecase(module); Import loader for module in any possible lettercase permutation. kwargs_lower(kwargs); Function to rebuild and return kwargs dictionary sanitized. levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. libint2_configuration(); Returns information on integral classes, derivatives, and AM from currently linked Libint2. libint2_print_out(). mat2arr(mat); Convert Matrix to List. message_box(message[, max_width, min_width]); Put a message string into a box for extra attention. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. pcm_helper(block); Helper to specify the multiline PCMSolver syntax for PCM. plump_qcvar(key, val); Prepare serialized QCVariables for QCSchema AtomicResult.extras[""qcvars""] by converting flat arrays into numpy, shaped ones and floating strings. prefactor_ecd(); Prefactor for converting microscopic observable to decadic molar extinction coeffic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psi4api.html:25901,clear,clear,25901,psi4manual/master/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/master/psi4api.html,1,['clear'],['clear']
Usability,"me pltfile with an Iowa; representation of the modelchems errors in mcdat for BBI/SSI-style; labels. liliowa(mcdat, title='', xlimit=2.0, view=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Saves a plot with a heatmap representation of mcdat. segment_color(argcolor, saptcolor)[source]¶; Find appropriate color expression between overall color directive; argcolor and particular color availibility rxncolor. ternary(sapt, title='', labeled=True, view=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Takes array of arrays sapt in form [elst, indc, disp] and builds formatted; two-triangle ternary diagrams. Either fully-readable or dotsonly depending; on labeled. Saves in formats graphicsformat. threads(data, labels, color=None, title='', xlimit=4.0, mae=None, mape=None, mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None, labeled=True, view=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Generates a tiered slat diagram between model chemistries with; errors (or simply values) in list data, which is supplied as part of the; dictionary for each participating reaction, along with dbse and rxn keys; in argument data. The plot is labeled with title and each tier with; an element of labels and plotted at xlimit from the zero-line. If; color is None, slats are black, if ‘sapt’, colors are taken from color; key in data [0, 1]. Summary statistics mae are plotted on the; overbound side and relative statistics mape on the underbound side.; HTML code for mouseover if mousetext or mouselink or mouseimag specified; based on recipe of Andrew Dalke from; http://www.dalkescientific.com/writings/diary/archive/2005/04/24/interactive_html.html. valerr(data, color=None, title='', xtitle='', view=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶. Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:112182,simpl,simply,112182,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['simpl'],['simply']
Usability,"me>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. BENCH12¶. Database of <description of members and reference energy type>.; Geometries from <Reference>.; Reference interaction energies from <Reference>. benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small'; 'large'; 'alkenes'; 'alkanes'; 'acenes'; 'thiophenes'; 'h2o_size'; 'h2o_shape'; 'atoms'; 'S22_HB'; 'S22_MX'; 'S22_DD'. CORE¶. Database of Pulay corannulene structures. Subsumed into CFLOW. cp 'off' || 'on'; rlxd 'off'. SSI¶. Database (Merz) of interaction energies for protein sidechain-sidechain interactions.; Geometries from Kenneth Merz Group, Univ. of Florida.; Reference interaction energies from <Reference>.; Part of the BioFragment Database (BFDb). cp 'off' || 'on'; rlxd 'off'. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. S66by8¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries and reference interaction energies from Rezac et al. JCTC 7 2427 (2011).; Note that the S66by8-N-1.0 members are not quite the same geometries as S66-N. cp 'off' || 'on'; rlxd 'off'; subset. 'small'; 'large'; 'equilibrium'; 'HB' eight-point (0.9, 0.95, 1.0, 1.05, 1.1, 1.25, 1.5, 2.0) \(\times R_{eq}\) dissociation curve hydrogen-bonded systems; 'MX' eight-point (0.9, 0.95, 1.0, 1.05, 1.1, 1.25, 1.5, 2.0) \(\times R_{eq}\) dissociation curve mixed-influence systems; 'DD' eight-point (0.9, 0.95, 1.0, 1.05, 1.1, 1.25, 1.5, 2.0) \(\times R_{eq}\) dissociation curve dispersion-dominated systems. O24by5mb¶. Database (O24) of interaction energies for small open-shell high-spin bimolecular complexes.; Geometries taken from https://gitlab.com/piotr.zuchowski/o24x",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_available_databases-1.html:2599,simpl,simple,2599,psi4manual/1.4.0/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_available_databases-1.html,4,['simpl'],['simple']
Usability,"mmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be; more robust by Martin. [Martin:2014:785]. name; calls method in Kallay’s MRCC program [manual]. mrccsd; CC through doubles. mrccsdt; CC through triples. mr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/mrcc-1.html:1243,simpl,simply,1243,psi4manual/1.4.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/mrcc-1.html,5,['simpl'],['simply']
Usability,"modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. Ways to Add Code: Psi4NumPy, Plugins, Full Integration¶. Easier and more rapid development¶; Fully-featured electronic structure programs are large and complex. However,; the PSI4 ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of PSI4 were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user’s perspective, programming was; still relatively difficult because it required modifications to be made in C++; code.; Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_ways_to_add.html:1111,simpl,simplified,1111,psi4manual/master/prog_ways_to_add.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_ways_to_add.html,1,['simpl'],['simplified']
Usability,"multiplicity = self.PYmultiplicity; self.PYmolecular_charge = 0; self.PYmultiplicity = 1. for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent':; continue. if self.fragment_types[fr] == 'Real':; self.PYmolecular_charge += self.fragment_charges[fr]; self.PYmultiplicity += self.fragment_multiplicities[fr] - 1. for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; self.full_atoms[at].compute(); self.full_atoms[at].set_ghosted(self.fragment_types[fr] == 'Ghost'); if self.full_atoms[at].symbol() != 'X':; self.atoms.append(self.full_atoms[at]). # TODO: This is a hack to ensure that set_multiplicity and set_molecular_charge; # work for single-fragment molecules.; if self.nfragments() < 2:; self.PYmolecular_charge = temp_charge; self.PYmultiplicity = temp_multiplicity. [docs] def update_geometry(self):; """"""Updates the geometry, by (re)interpreting the string used to; create the molecule, and the current values of the variables.; The atoms list is cleared, and then rebuilt by this routine.; This function must be called after first instantiation of Molecule. >>> H2 = qcdb.Molecule(""H\\nH 1 0.74\\n""); >>> print H2.natom(); 0; >>> H2.update_geometry(); >>> print H2.natom(); 2. """"""; if self.nfragments() == 0:; raise ValidationError(""Molecule::update_geometry: There are no fragments in this molecule.""). # Idempotence condition; if self.lock_frame:; return. #print ""beginning update_geometry:""; #self.print_full(); if self.PYreinterpret_coordentries:; self.reinterpret_coordentries(); #print ""after reinterpret_coordentries:""; #self.print_full(). if self.PYmove_to_com:; self.move_to_com(); #print ""after com:""; #self.print_full(). # If the no_reorient command was given, don't reorient; if not self.PYfix_orientation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rath",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:42039,clear,cleared,42039,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,4,['clear'],['cleared']
Usability,"n Ana/Miniconda. This is recommended for developers to avoid interference between multiple versions (including github/conda versions) or to test python versions, etc.. In practical terms, installing into a conda environment means you can turn PSI4‘s availability on/off by switching conda environments without turning on/off the whole Ana/Miniconda installation. Below, PSI4 is installed into an environment called p4env. Then the environment is activated, removing the main Ana/Miniconda bin and adding envs/p4env/bin to PATH. The conda activate command (conda >=4.4; December 2017) works in all shells, but if you’re using old source activate that only works for bash; adjust as needed for csh/tcsh.; >>> conda create -n p4env psi4; >>> conda activate p4env; # check; >>> which psi4; /path/to/miniconda/envs/p4env/bin/psi4. Configure environment. Preceding steps have placed conda and psi4 in your PATH, either permanently through rc-files or temporarily in this terminal session. You can keep or undo these changes. For general psi4 use, you must enable the psi4 executable to be found through any of:. prepending to PATH in shell, ~/.bashrc, ~/.tcshrc, or PBS cmd file; activating the conda environment (p4env above) in shell, ~/.bashrc, or PBS cmd file; supplying full path to executable (shell or PBS cmd file). Similarly, the scratch directory (see Scratch Files) must be specified through:. defining PSI_SCRATCH in shell, ~/.bashrc, ~/.tcshrc, or PBS cmd file. Useful Commands¶. Initially install PSI4 stable release. # equivalent; >>> conda install psi4 -c psi4; >>> conda install psi4 --channel psi4. Initially install PSI4 stable release with non-current python. >>> conda install psi4 python=3.8 -c psi4. Update to latest PSI4 stable release. >>> conda update psi4 -c psi4. Initially install stable release into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4; >>> conda activate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/conda-1.html:16151,undo,undo,16151,psi4manual/1.4.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/conda-1.html,9,['undo'],['undo']
Usability,"n author: Alexander Yu. Sokolov; Module: Keywords, PSI Variables, DCFT. Theory¶; Density cumulant functional theory (DCFT) is a density-based ab initio theory; that can compute electronic energies without the use of a wavefunction. The; theory starts by writing the exact energy expression in terms of the one- and; two-particle density matrices ( and ):. Here we used Einstein convention for the summation over the repeated indices,; and are the standard one- and two-electron integrals,; and are the elements of and ,; respectively. Naively, one might expect that it is possible to minimize the; energy functional in the equation above and obtain the exact energy. This is,; however, not trivial, as the density matrix elements and; cannot be varied arbitrarily, but must satisfy some; conditions that make sure that the density matrices are N-representable, i.e.; correspond to an antisymmetric N-electron wavefunction. Unfortunately, no; simple set of necessary and sufficient N-representability conditions are known,; and some of the known conditions are not easily imposed. In addition, the lack; of separability of the density matrices may result in the loss of; size-consistency and size-extensivity. In DCFT, one takes a different route and; replaces in favor of its two-particle density cumulant:. The one-particle density matrix is separated into its idempotent part; and a correction :. The idempotent part of corresponds to a mean-field Hartree-Fock-like density,; while the non-idempotent correction ; depends on the density cumulant and describes the electron correlation effects.; Inserting the above two equations into the energy expression, we obtain:. where the antisymmetrized two-electron integrals and the generalized Fock operator; matrix elements were defined as follows:. Energy functional has several important properties. First,; the energy is now a function of two sets of independent parameters, the; idempotent part of () and the density cumulant; (). As a result, the en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:1261,simpl,simple,1261,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['simpl'],['simple']
Usability,"n be built on Linux) and get served from vergil (cdsgroup webserver). Need a conda env with constructor and cookiecutter. This env presently accessed through conda activate cookie.; Enter “constructor-cutter-unified” in the psi4meta repo. There’s a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md; Edit cookiecutter/cookiecutter.json for control. Edit which python versions, if necessary; Edit release field; Edit hash field. This is the 7-char hash that’s on every psi4 conda pkg as part of version; Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string; Leave this file set to a “rc” with Git, as that has more details. For (post)releases (not prereleases), copy cookiecutter.json to cookiecutter.json-vXXX; Edit cookiecutter/{{.../construct.yaml for templating. This is rarely needed; If it’s been a while or you need the space, clear out ~/.conda/constructor, where the downloaded packages are cached; Note that installers get written to build/ and this gets regenerated each time. Clear out between runs.; python run.py; [Outdated] Watch out for py_ in buildstring as this means a noarch package has been pulled. It must be eliminated. Constructors can’t handle “noarch” packages and will fail at runtime. If see a “noarch” package, must find the recipe and rebuild for all OS & Python combinations. Then run constructor again.; [Replacement] After adding a post_install to reposition the noarch packages, they are safe to include.; If fetching times out, may have to run run.py several times. Clear out build/ in between. It’s the fetching that takes a long time, not constucting; In the end, should have several installers; >>> ls -l build/psi4conda-1.3-py3.*/*64.sh; -rwxr-xr-x. 516M Feb 28 20:30 build/psi4conda-1.3-py3.6-linux-64/psi4conda-1.3-py36-Linux-x86_64.sh; -rwxr-xr-x. 299M Feb 28 20:31",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/manage_release-1.html:11988,clear,clear,11988,psi4manual/1.4.0/manage_release-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/manage_release-1.html,7,['clear'],['clear']
Usability,"n encoding sequence of PSI module calls for; a DFMP2 property calculation. run_dfocc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. run_dfocc_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. run_dfocc_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. run_dft(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-functional-theory calculation. run_dft_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. run_dft_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; DFT calculations. This is a simple alias to run_scf(); since DFT properties all handled through oeprop. run_dmrgci(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an DMRG calculation. run_dmrgscf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an DMRG calculation. run_efp(name, **kwargs)[source]¶; Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). run_eom_cc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. run_eom_cc_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. run_fisapt(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an F/ISAPT0 computation. run_fnocc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation.; >>> energy('fno-ccsd(t)'). run_fnodfcc(name, **kwargs)[source]¶; Fu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:163001,simpl,simple,163001,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['simpl'],['simple']
Usability,"n is a valid option> || 'on'; rlxd 'off' <erase this comment and after unless on is valid option> || 'on'; benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. SSI¶. Database (Merz) of interaction energies for protein sidechain-sidechain interactions.; Geometries from Kenneth Merz Group, Univ. of Florida.; Reference interaction energies from <Reference>.; Part of the BioFragment Database (BFDb). cp 'off' || 'on'; rlxd 'off'. HTBH¶. Database (Truhlar) of hydrogen-transfer barrier height reactions.; Geometries from Truhlar and coworkers at site http://t1.chem.umn.edu/misc/database_group/database_therm_bh/raw_geom.cgi (broken link).; Reference energies from Zhao et al. JPCA, 109 2012-2018 (2005) doi: 10.1021/jp045141s [in supporting information]. cp 'off'; rlxd 'off'; subset. 'small'; 'large'. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. S66¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries and reference energies from Rezac et al. JCTC 7 2427 (2011). cp 'off' || 'on'; rlxd 'off'; subset. 'small'; 'large'; 'HB' hydrogen-bonded systems; 'MX' mixed-influence systems; 'DD' dispersion-dominated systems. S22by5¶. Database (Hobza) of interaction energies for dissociation curves of bimolecular complexes.; Geometries and reference interaction energies from Grafova et al. JCTC 6 2365 (2010).; Note that the S22by5-N-1.0 members are essentially the same geometries as S22-N (there’s trivial round-off error) but the reference interaction energies for S22by5 are of lower quality than those of S22. cp 'off' || 'on'; rlxd 'off'; subset. 'small'; 'large'; 'equilibrium'; 'mol1' five-point (0.9, 1.0, 1.2, 1.5, 2.0) \(\times R_{eq}\) dissociation curve for molecul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_available_databases.html:10874,simpl,simple,10874,psi4manual/1.6.x/autodoc_available_databases.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_available_databases.html,2,['simpl'],['simple']
Usability,"n is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]¶; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]¶; Serializes instance into dictionary according to schema dtype. to_string(dtype, units='Angstrom', atom_format=None, ghost_format=None, width=17, prec=12)[source]¶; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int) → int¶; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule) → str¶; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int) → float¶; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int) → psi4.core.Vector3¶; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int) → float¶; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int) → float¶; z position [Bohr] of atom arg0 (0-indexed without dummies). B787(ref_mol, do_plot=False, verbose=1, atoms_map=False, run_resorting=False, mols_align=False, run_to_completion=False, uno_cutoff=0.001, run_mirror=False)[source]; Finds shift, rotation, and atom reordering of concern_mol that best; aligns with ref_mol.; Wraps qcdb.align.B787() for qcdb.Molecule or; psi4.core.Molecule. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-order",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:36242,clear,clearing,36242,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,1,['clear'],['clearing']
Usability,"n is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]¶; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]¶; Serializes instance into dictionary according to schema dtype. to_string(dtype, units='Angstrom', atom_format=None, ghost_format=None, width=17, prec=12)[source]¶; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int) → int¶; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule) → str¶; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int) → float¶; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int) → psi4.core.Vector3¶; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int) → float¶; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int) → float¶; z position [Bohr] of atom arg0 (0-indexed without dummies). class psi4.core.MultipoleInt¶; Bases: psi4.core.OneBodyAOInt; Computes arbitrary-order multipole integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; Compute integrals between basis functions in the given shell pair. origin¶; The origin about which the one body ints are being computed. class psi4.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:181598,clear,clearing,181598,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['clear'],['clearing']
Usability,"n ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irrepped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]; def _to_array(; matrix: Union[core.Matrix, core.Vector],; copy: bool = True,; dense: bool = False,; ) -> Union[np.ndarray, List[np.ndarray]]:; """"""; Converts a |PSIfour| Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters; ----------; matrix; Pointers to which Psi4 core class should be used in the construction.; copy; Copy the data if `True`, return a view otherwise; dense; Converts irrepped Psi4 objects to diagonally blocked dense arrays if; `True`. Returns a list of arrays otherwise. Returns; -------; ~numpy.ndarray or ~typing.List[~numpy.ndarray]; Returns a single or list of NumPy arrays depending on options. Notes; -----; This is a generalized function to convert a Psi4 object to a NumPy array. Examples; --------. >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. matrix_views = _get_raw_views(matrix, copy=copy). # Return the list of arrays; if dense is False:; return matrix_views. # Build the dense matrix; if isinstance(matrix, core.Vector):; ret_type = '1D'; elif isinstance(matrix, core.Matrix):; ret_type = '2D'; else",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:6385,simpl,simply,6385,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,3,['simpl'],['simply']
Usability,"n the appropriate point group. The same syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When most popular basis sets are being used, including Dunning and; Pople-style, the SCF, DF-MP2, and SAPT codes will chose the appropriate; auxiliary basis set automatically according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input. Finally, we note that the basis {...} block may also be used; for defining basis sets, as detailed in User-Defined Basis Sets. Decontracted Basis Sets¶; Decontraction of the basis set can be useful in certain situations. In order to; decontract a given basis set, simply add “-decontract” to the name of the primary basis set.; set basis cc-pvdz-decontract. Obviously this will add significantly to the computational cost of any given calculation, however it can; be useful when checking the basis set dependence of a particular calculated property or in certain situations; where a large basis set is critical. Currently it is recommended that a decontracted basis is always used when performing realtivistic calculations using the X2C Hamiltonian. User-Defined Basis Sets¶. Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. There are three routes by which a basis set in G94 format can be introduced to Psi4‘s notice.; (1) Install new basis set file into Psi4 basis library.; Copy the basis set definitions for all elements into a blank file. Exclamation points denote comments.; As the first line of the file, add the word spherical or cartesian to indicate; whether the basis set will run in ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/basissets-1.html:4448,simpl,simply,4448,psi4manual/1.0.0/basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/basissets-1.html,2,['simpl'],['simply']
Usability,"n to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/opt-1.html:2751,guid,guide,2751,psi4manual/1.1.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/opt-1.html,10,['guid'],['guide']
Usability,"n to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:5116,simpl,simple,5116,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,8,['simpl'],"['simple', 'simpler']"
Usability,"n underscore; to indicate spaces, use a hyphen instead. This directory will need two files. The first is CMakeLists.txt, which is necessary to add the test case to the suite. This file should have the following lines:; 1; 2; 3include(TestingMacros). add_regression_test(directory_name ""psi;semicolon_separated-list-of-applicable-test-labels""). The labels specify which groups of tests include the test case. The psi label should always be added, but the other labels are test-specific. The method tested should always be included, and this is often sufficient. If adding a test for an already existing module, the labels for other tests of the module will suggest other labels to add.; A test requiring over 15 minutes should be labeled longtests. A short test used for general bug checking should be labeled quicktests. A test that confirms PSI4 is operational should be labeled smoketests.; The other necessary file is the input file itself, input.dat. The input file should be just a simple input file to run the test, with small modifications.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25#! RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis.; #! Also a bit more to force a second line. nucenergy = 8.801466202085710 #TEST; refenergy = -76.05098402733282 #TEST. molecule h2o {; symmetry c1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pVTZ; scf_type df; df_basis_scf cc-pVTZ-RI; e_convergence 10; }. thisenergy = energy('rhf'). compare_values(nucenergy, h2o.nuclear_repulsion_energy(), 9, ""Nuclear repulsion energy"") #TEST; compare_values(refenergy, thisenergy, 9, ""Reference energy"") #TEST; compare_values(refenergy, get_variable('scf total energy'), 9, ""Reference energy"") #TEST. Of those small modifications, first, note the special comment at the top (starting with the #! comment marker). This should be very descriptive since it is inlined into the manual (unless !nosample is present in this comment) as a s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/add_tests-1.html:1236,simpl,simple,1236,psi4manual/1.2.1/add_tests-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/add_tests-1.html,4,['simpl'],['simple']
Usability,"n, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. This specifies that there are two neutral, spin-singlet fragments. It is; possible to further specify that the overall complex is neutral and spin-singlet; by inserting another charge multiplicity line, separated from the first; molecule block by a – line. If any information is missing, PSI4 will set the; unprovided charges and multiplicities to be consistent with those that are given.; For example, the overall charge must be simply the sum of all fragment charges.; PSI4 further assumes that any unpaired electrons are coupled to yield the highest; possible \(M_s\) value. Psi will also favor neutral, spin-singlet fragments.; For anything complicated, we strongly suggest explicitly providing the charge; and multiplicity of each fragment as well as the total molecular charge and multiplicity. For details and examples, see https://github.com/MolSSI/QCElemental/blob/master/qcelemental/molparse/chgmult.py#L105-L136 .; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psithonmol.html:15431,simpl,simply,15431,psi4manual/1.8.x/psithonmol.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psithonmol.html,3,['simpl'],['simply']
Usability,"nature of preceding or following; jobs, it is prudent to separate them with the following:; clean() # removes Psi4 scratch files; clean_variables() # empties the PSI variables list; cfour {} # empties the cfour block. Warning; Because p4c4 does not inspect the contents of the cfour {...}; block, once the user specifies a PSI4-style molecule, the; interface cannot judge whether a sandwich mode (drop the PSI4 molecule; and use the cfour block as the entirety of the ZMAT) or a standard mode; (translate the PSI4 molecule and append additional input from the; cfour block) is intended. The latter is what actually occurs. If; there is both a PSI4 molecule and a molecule in the cfour block,; ZMAT will end up with multiple molecules and multiple *CFOUR(...); blocks, and it will not run. Therefore, if mixing sandwich and; standard or pure-PSI4 computations in an input file, place all; the sandwich jobs at the beginning before declaring PSI4; molecules. If necessary, clear the cfour block with cfour {} before; commencing standard P4C4 jobs. Output¶; The output of xcfour invoked from a PSI4 input file is; written to the PSI4 output file as the computation progresses. If a; Cfour module terminates with a non-zero error code, the value will show up; in CFOUR ERROR CODE.; Energies & Scalars; After execution of xcfour has completed, the output string is; extensively parsed and appropriate results are stored in PSI; Variables. All gleaned variables are printed in the; Cfour output section of the PSI4 output file, as shown below.; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//; // Cfour c4-ccsd(t) Energy Results //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. Variable Map:; ----------------------------------------------------------------------------; ""(T) CORRECTION ENERGY"" => -0.007263598030; ""CCSD CORRELATION ENERGY"" => -0.275705492359; ""CCSD TOTAL ENERGY"" => -76.338453952539; ""CCSD(T) CORRELATION ENERGY"" => -0.007263598030; ""CCSD(T) TOTAL ENERGY"" => -76.345717550569; ""CFOUR ERROR CODE"" => 0.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:18564,clear,clear,18564,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,9,['clear'],['clear']
Usability,"nb in levels:; nbodies = []; if nb == ""supersystem"":; nbodies.append(nb); elif nb != (prev_body + 1):; for m in range(prev_body + 1, nb + 1):; nbodies.append(m); else:; nbodies.append(nb); nbodies_per_mc_level.append(nbodies); prev_body += 1. plan.max_nbody = max(nb for nb in levels if nb != ""supersystem""); plan.nbodies_per_mc_level = nbodies_per_mc_level. for mc_level_idx, mtd in enumerate(levels.values()):; method, basis, cbsmeta = expand_cbs_methods(mtd, basis, driver, cbsmeta=cbsmeta, **kwargs); packet.update({'method': method, 'basis': basis}). # Tell the task builder which level to add a task list for; # * see https://github.com/psi4/psi4/pull/1351#issuecomment-549948276 for discussion of where build_tasks logic should live; if method == ""cbs"":; # This CompositeComputer is discarded after being used for dermode.; simplekwargs = copy.deepcopy(kwargs); simplekwargs.pop('dertype', None); simplecbsmeta = copy.deepcopy(cbsmeta); simplecbsmeta['verbose'] = 0; dummyplan = CompositeComputer(**packet, **simplecbsmeta, molecule=original_molecule, **simplekwargs). methods = [sr.method for sr in dummyplan.task_list]; # TODO: pass more info, so fn can use for managed_methods -- ref, qc_module, fc/ae, conv/df; dermode = negotiate_derivative_type(driver, methods, kwargs.pop('dertype', None), verbose=1). if dermode[0] == dermode[1]: # analytic; logger.info(""PLANNING MB(CBS): {mc_level_idx=} {packet=} {cbsmeta=} kw={kwargs}""); plan.build_tasks(CompositeComputer, **packet, mc_level_idx=mc_level_idx, **cbsmeta, **kwargs). else:; logger.info(; f""PLANNING MB(FD(CBS): {mc_level_idx=} {packet=} {cbsmeta=} findif_kw={current_findif_kwargs} kw={kwargs}""; ); plan.build_tasks(FiniteDifferenceComputer,; **packet,; mc_level_idx=mc_level_idx,; findif_mode=dermode,; computer=CompositeComputer,; **cbsmeta,; **current_findif_kwargs,; **kwargs). else:; dermode = negotiate_derivative_type(driver, method, kwargs.pop('dertype', None), verbose=1); if dermode[0] == dermode[1]: # analytic; logger.in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_planner.html:7599,simpl,simplecbsmeta,7599,psi4manual/1.7.x/_modules/psi4/driver/task_planner.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_planner.html,12,['simpl'],"['simplecbsmeta', 'simplekwargs']"
Usability,"nclude SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. PSIthonPsiAPI# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = psi4.energy(...); E = psi4.optimize(...); E = psi4.frequency(...); G = psi4.gradient(...) # used by optimize(); H = psi4.hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction. PSIthonPsiAPI# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). # power user returns; E, wfn = psi4.energy(..., return_wfn=True); E, wfn = psi4.optimize(..., return_wfn=True); E, wfn = psi4.frequency(..., return_wfn=True); G, wfn = psi4.gradient(..., return_wfn=True) # use",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:10742,simpl,simple,10742,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['simpl'],['simple']
Usability,"nctions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Isotopic Substitution¶. Caution; Use of isotopic substitution in Psi4 is not well; developed, and the syntax is subject to change. At present, isotopes can only be specified at creation-time of the molecule; The syntax for a deuterium- and tritium-substituted water is below. Note; that asymmetric isotopic substitution such as this will change the; molecule’s point group symmetry.; molecule dto {; units au; O 0.00000000 0.00000000 0.00000000; H@2.014101779 0.00000000 1.93042809 -1.10715266; H_label@3.01604927 0.00000000 -1.93042809 -1.10715266; }. The masses used by Psi4 can be found at; psi4/include/masses.h. See freq-isotope for about; the only use to which isotopologs can presently be put in Psi4. PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, Psi4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; Psi4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html:7292,intuit,intuitive,7292,psi4manual/1.0.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html,2,['intuit'],['intuitive']
Usability,"nd it with the; command basis {...}, as shown below. Multiple basis sets can be; specified by adding additional sections within the surrounding brackets.; Use assign statements to actually request the basis set. This; basis {...} section replaces the usual set basis XXX line.; In a more complex input, if the user needs to call the user-defined; basis by name, this can be achieved using the syntax basis mybas {...},; and then the basis can be recalled later as set basis mybas.; To use a custom basis set as described in this section, it must be; defined prior to its use in a function that performs a computation.; basis {. # assign basset to all atoms and addl to hydrogens; assign basset; assign H addl. # basis set section like in snippet above goes here; [basset]; ... # additional basis set sections follow; [addl]; ...; }. The test case mints2 provides a complete example of; user-specified basis sets. Inputting effective core potentials (ECPs)¶; For ECP containing basis sets, all of the above mechanisms may still be used to; input the basis set; simply place the ECP definitions (in G94 format) in the; same file or input section as the orbital basis definition. Because the ECP; appears in the same section as the orbital basis, it will be parsed; automatically and the number of core electrons the ECP represents will be; detected, so no further input is required to use a core potential. See; Effective core potentials (ECPs) for more information about using ECPs and the; Def2-TZVP basis set definition; for an example of their input syntax. table of contents. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon: Structuring an Input File; Basis Sets. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/basissets.html:10329,simpl,simply,10329,psi4manual/1.7.x/basissets.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/basissets.html,1,['simpl'],['simply']
Usability,"nd surround it with the; command basis {...}, as shown below. Multiple basis sets can be; specified by adding additional sections within the surrounding brackets.; Use assign statements to actually request the basis set. This; basis {...} section replaces the usual set basis XXX line.; In a more complex input, if the user needs to call the user-defined; basis by name, this can be achieved using the syntax basis mybas {...},; and then the basis can be recalled later as set basis mybas.; To use a custom basis set as described in this section, it must be; defined prior to its use in a function that performs a computation.; basis {. # assign basset to all atoms and addl to hydrogens; assign basset; assign H addl. # basis set section like in snippet above goes here; [basset]; ... # additional basis set sections follow; [addl]; ...; }. The test case mints2 provides a complete example of; user-specified basis sets. Inputting effective core potentials (ECPs)¶; For ECP containing basis sets, all of the above mechanisms may still be used to; input the basis set; simply place the ECP definitions (in G94 format) in the; same file or input section as the orbital basis definition. Because the ECP; appears in the same section as the orbital basis, it will be parsed; automatically and the number of core electrons the ECP represents will be; detected, so no further input is required to use a core potential. See; Effective core potentials (ECPs) for more information about using ECPs and the; Def2-TZVP basis set definition; for an example of their input syntax. table of contents. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon: Structuring an Input File; Basis Sets. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/basissets.html:10329,simpl,simply,10329,psi4manual/1.6.x/basissets.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/basissets.html,1,['simpl'],['simply']
Usability,"nd whether they need version space to grow compatibly and grow incompatibly.; Nightly conda-builds work from master psi4. (Postrelease “practice” works from 1.N.x psi4.). Instead, switch source/git_tag from master to tag (e.g., v1.3rc1) in:. psi4-multiout on Linux & Mac, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-multiout/meta.yaml#L10; psi4-docs on Linux, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-docs/meta.yaml#L10 on L. In cbcy, edit psi4ver to “v”-less tag. For releases and postreleases (not prereleases), in conda_build_config.yaml, edit ltrtver to a new non-dev label (probably a ditto) matching the release (e.g., “1.3”); Set kitandkapoodle.py to the normal *** stack. Should be (psi4, psi4-rt, psi4-dev) * python_versions for Linux & Mac. Also single psi4-docs from Linux; Run kitandkapoodle.py and allow stack to upload to anaconda.org to psi4/label/dev. Poodle emits with --label dev so will go to the subchannel. May need to delete packages to clear out space on anaconda.org; Copy meta.yaml and build.sh of at least psi4-multiout and psi4-rt to e.g., v121-build.sh files for easy reference or rebuilding as dependencies in master change. Publish to main conda label¶. Go through each active conda package off https://anaconda.org/psi4/repo. Find the most recent build set (Linux/Mac, active py versions) that psi/psi-rt/psi-dev is using; _add_ (not replace) the main label. This makes a conda install psi4 -c psi4 get everything psi4 needs. For the moment conda install psi4 -c psi4/label/dev will get the same set, until package psi4-1.4a1.dev1 gets uploaded. May help to check versions and build versions against ltrtver in conda_build_config.yaml.; This step is manual, so takes a while. (It gets checked when Psi4conda installers are built b/c that pulls from “main”, not “dev”). Build Psi4conda set¶; Installers are build using the project constructor and build binary bash scripts, one per OS per Python version. In analogy to Minicond",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/manage_release-1.html:9899,clear,clear,9899,psi4manual/1.4.0/manage_release-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/manage_release-1.html,2,['clear'],['clear']
Usability,"nd whether they need version space to grow compatibly and grow incompatibly.; Nightly conda-builds work from master psi4. (Postrelease “practice” works from 1.N.x psi4.). Instead, switch source/git_tag from master to tag (e.g., v1.3rc1) in:. psi4-multiout on Linux & Mac, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-multiout/meta.yaml#L10; psi4-docs on Linux, https://github.com/psi4/psi4meta/blob/master/conda-recipes/psi4-docs/meta.yaml#L10 on L. In cbcy, edit psi4ver to “v”-less tag. For releases and postreleases (not prereleases), in conda_build_config.yaml, edit ltrtver to a new non-dev label (probably a ditto) matching the release (e.g., “1.3”); Set kitandkapoodle.py to the normal *** stack. Should be (psi4, psi4-rt, psi4-dev) * python_versions for Linux & Mac. Also single psi4-docs from Linux; Run kitandkapoodle.py and allow stack to upload to anaconda.org to psi4/label/dev. Poodle emits with --label dev so will go to the subchannel. May need to delete packages to clear out space on anaconda.org; Copy meta.yaml and build.sh of at least psi4-multiout and psi4-rt to e.g., v121-build.sh files for easy reference or rebuilding as dependencies in master change. Publish to main conda label¶. Go through each active conda package off https://anaconda.org/psi4/repo. Find the most recent build set (Linux/Mac, active py versions) that psi4/psi4-rt/psi4-dev is using; _add_ (not replace) the main label. This makes a conda install psi4 -c psi4 get everything psi4 needs. For the moment conda install psi4 -c psi4/label/dev will get the same set, until package psi4-1.4a1.dev1 gets uploaded. May help to check versions and build versions against ltrtver in conda_build_config.yaml.; This step is manual, so takes a while. (It gets checked when Psi4conda installers are built b/c that pulls from “main”, not “dev”). Build Psi4conda set (pre-Spring 2021)¶; Installers are build using the project constructor and build binary bash scripts, one per OS per Python version. I",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/manage_release-1.html:10243,clear,clear,10243,psi4manual/1.5.0/manage_release-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/manage_release-1.html,5,['clear'],['clear']
Usability,"ndex.html; build/latex-prog/psi4_userman.pdf; build/latex-prog/psi4_progman.pdf. Much of the documentation is auto-generated from the source. At present,; this covers:. Physical Constants: psi4/include/physconst.h; Python Driver: docstrings from *.py files in psi4/lib/python; Databases: docstrings from *.py files in psi4/lib/databases; Basis Sets: *.gbs files in psi4/lib/basis; C++ Keywords: psi4/src/bin/psi4/read_options.cc; Sample Inputs: input.dat files in psi4/samples; PSI Variables: Process::environment.globals lines and comments in the C++ code; Plugins: doc.rst text, *.py modules, and C++ keywords in psi4/tests/plugin_* plugin directories. Some documentation is even extracted from Psi4 objects at runtime. PsiMod: docstrings for the PsiMod built-in module constructed in psi4/src/bin/psi4; DFT: functional availibility and characteristics as encoded in psi4/lib/python/functional.py. Run make help to see choices for cleaning various stages of the build.; Running make realclean clears out the built documentation. Building; all the documentation takes ~10 minutes. There is now good; dependency structure built into the psi4/doc/sphinxman/Makefile.in ,; so very long builds should be infrequent (unless you’re touching psi4/src/bin/psi4/read_options.cc.; Note that not all dependencies; are encoded (PSI variables, for instance, depend on every .cc file in the; source tree), so for a definitive doc build, run make realclean and; start from scratch. reStructuredText¶; Sphinx files are written in reStructuredText (*.rst). In the html; documentation, source code is available from the sidebar. Here’re a; few resources on Sphinx formatting. reStructuredText; rendered test document; vs. source test document; Another reStructuredText; A third reStructuredText and Sphinx; LaTeX that Sphinx can handle; Sphinx Docs. Math in the Codebase¶; It is often useful to have mathematical expressions in docstrings or; comments in the code that are auto-documented into the manual. Such; locat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/documentation-1.html:2816,clear,clears,2816,psi4manual/4.0b2/documentation-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/documentation-1.html,4,['clear'],['clears']
Usability,"ndicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Moller-Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/opt-1.html:2609,guid,guide,2609,psi4manual/1.0.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/opt-1.html,2,['guid'],['guide']
Usability,"ndows, through the Ubuntu shell). If using the Psi4conda installer, gCP has already been installed alongside. If using the PSI4 conda package, the gcp conda package can; be obtained through conda install gcp -c psi4 or conda install; psi4-rt -c psi4. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; the gcp executable can be obtained through conda install gcp -c psi4. To remove a conda installation, conda remove gcp. Source. If using PSI4 built from source and you want to build gCP from; from source also, follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a Fortran compiler, and run make). To be used by PSI4, the program binary (gcp) must be; found in your PSIPATH or PATH (in that order). If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The DFTD3 executable must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; 1energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; 1optimize('pbeh3c'). HF-3c with non-standard basis; 1; 2set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; 1; 2set basis cc-pvdz; energy('pbeh3c/'). If only BSS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/gcp-1.html:1335,simpl,simply,1335,psi4manual/1.2.1/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/gcp-1.html,4,['simpl'],['simply']
Usability,"ne. Sets every element of a matrix to val. set(self: psi4.core.Matrix, m: int, n: int, val: float) -> None. Sets a single element of a matrix to val at row m, col n. set(self: psi4.core.Matrix, h: int, m: int, n: int, val: float) -> None. Sets a single element of a matrix, subblock h, row m, col n, with value val. set_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice, block: psi4.core.Matrix) → None¶; Set a matrix block. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → None¶; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix) → float¶; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule) → None¶; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int¶; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False)¶; Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector]) – Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {‘matrix’, ‘vector’}. Return type:; Dict[str, Any]. trace(self: psi4.core.Matrix) → float¶; Returns the trace of the matrix. transform(*a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:16079,simpl,simply,16079,psi4manual/1.7.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html,4,['simpl'],['simply']
Usability,"ne. Sets every element of a matrix to val. set(self: psi4.core.Matrix, m: int, n: int, val: float) -> None. Sets a single element of a matrix to val at row m, col n. set(self: psi4.core.Matrix, h: int, m: int, n: int, val: float) -> None. Sets a single element of a matrix, subblock h, row m, col n, with value val. set_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice, block: psi4.core.Matrix) → None¶; Set a matrix block. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → None¶; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix) → float¶; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule) → None¶; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int¶; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a NumPy array. Either copies the data or simply; constructs a view. Parameters. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns; Returns either a list of np.array’s or the base array depending on options. Return type; numpy.ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float¶; Returns the trace of the matrix. transform(*args, **kwargs)¶; Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.core.Matrix, a: psi4.core.Mat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.matrix.html:14786,simpl,simply,14786,psi4manual/1.4.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.matrix.html,3,['simpl'],['simply']
Usability,"ne. Sets every element of a matrix to val. set(self: psi4.core.Matrix, m: int, n: int, val: float) -> None. Sets a single element of a matrix to val at row m, col n. set(self: psi4.core.Matrix, h: int, m: int, n: int, val: float) -> None. Sets a single element of a matrix, subblock h, row m, col n, with value val. set_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice, block: psi4.core.Matrix) → None¶; Set a matrix block. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → None¶; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix) → float¶; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule) → None¶; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int¶; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float¶; Returns the trace of the matrix. transform(*args, **kwargs)¶; Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transfo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html:14559,simpl,simply,14559,psi4manual/1.2.1/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html,1,['simpl'],['simply']
Usability,"ne. Sets every element of a matrix to val. set(self: psi4.core.Matrix, m: int, n: int, val: float) -> None. Sets a single element of a matrix to val at row m, col n. set(self: psi4.core.Matrix, h: int, m: int, n: int, val: float) -> None. Sets a single element of a matrix, subblock h, row m, col n, with value val. set_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice, block: psi4.core.Matrix) → None¶; Set a matrix block. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → None¶; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix) → float¶; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule) → None¶; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int¶; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float¶; Returns the trace of the matrix. transform(*args, **kwargs)¶; Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html:14566,simpl,simply,14566,psi4manual/1.3.2/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html,1,['simpl'],['simply']
Usability,"nergies from [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)] at CCSD(T)/cc-pCVTZ level. benchmark. 'RSE42' [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)].; \(\Rightarrow\) 'RSE42' \(\Leftarrow\) [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)]. subset. 'small' <members_description>; 'large' <members_description>; 'RSE30' smaller systems in RSE42; '<subset>' <members_description>. BAKERJCC93¶. Database of molecules that are challenging to optimize.; Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported; in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002), with a few; further corrections.; No reference energies defined. cp 'off'; rlxd 'off'; subset. 'small'; 'large'. BBI¶. Database (Merz) of protein backbone-backbone interactions.; Geometries from Kenneth Merz Group, Univ. of Florida.; Reference interaction energies from Sherrill group, Georgia Tech.; Part of the BioFragment Database (BFDb). cp 'off' || 'on'; rlxd 'off'. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. RGC10¶. Database (Sherrill) of interaction energies for dissociation curves of rare-gas biatomic complexes.; Geometries and reference interaction energies from Tang et al. JCP 118 4976 (2003). cp 'off' || 'on'; rlxd 'off'; subset. 'small'; 'large'; 'equilibrium'; 'HeHe' 18-point dissociation curve for helium dimer; 'HeNe' 18-point dissociation curve for helium-neon complex; 'HeAr' 18-point dissociation curve for helium-argon complex; 'HeKr' 18-point dissociation curve for helium-krypton complex; 'NeNe' 18-point dissociation curve for neon dimer; 'NeAr' 18-point dissociation curve for neon-argon complex; 'NeKr' 18-point dissociation curve for neon-krypton complex; 'ArAr' 18-point dissociation curve for argon dimer; 'ArKr' 18-point dissociation curve for argon-krypton complex; 'KrKr' 18-point dissociation curve for krypton dimer. O24by5mb¶. Da",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_available_databases-1.html:10200,simpl,simple,10200,psi4manual/1.5.0/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_available_databases-1.html,4,['simpl'],['simple']
Usability,"nergy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specif",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:20740,clear,cleared,20740,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,4,['clear'],['cleared']
Usability,"nes, psivar)[source]¶; Harvest SCF results from the SCF section of the output file. muster_memory(mem)[source]¶; Transform input mem in MB into psi4-type options for orca. muster_modelchem(name, dertype)[source]¶; Transform calculation method name and derivative level dertype; into options for orca. While deliberately requested pieces,; generally orca__orca_deriv_level and orca__orca_calc_level,; are set to complain if contradicted (‘clobber’ set to True), other; ‘recommended’ settings, can be countermanded by keywords in input file; (‘clobber’ set to False). Occasionally, we want these pieces to actually; overcome keywords in input file (‘superclobber’ set to True). orca_gradient_list()[source]¶; Return an array of Orca methods with analytical gradients.; Appended to procedures[‘gradient’]. orca_list()[source]¶; Return an array of Orca methods with energies. Appended; to procedures[‘energy’]. class OrderedDict(*args, **kwds)[source]¶; Dictionary that remembers insertion order. clear() → None. Remove all items from od.[source]¶. copy() → a shallow copy of od[source]¶. classmethod fromkeys(S[, v]) → New ordered dictionary with keys from S[source]¶; and values equal to v (which defaults to None). items() → list of (key, value) pairs in od[source]¶. iteritems()[source]¶; od.iteritems -> an iterator over the (key, value) items in od. iterkeys() → an iterator over the keys in od[source]¶. itervalues()[source]¶; od.itervalues -> an iterator over the values in od. keys() → list of keys in od[source]¶. pop(k[, d]) → v, remove specified key and return the corresponding value.[source]¶; If key is not found, d is returned if given, otherwise KeyError is raised. popitem() → (k, v), return and remove a (key, value) pair.[source]¶; Pairs are returned in LIFO order if last is true or FIFO order if false. setdefault(k[, d]) → od.get(k,d), also set od[k]=d if k not in od[source]¶. update(E, **F) → None. Update od from dict/iterable E and F.[source]¶; If E is a dict instance, does: f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:53372,clear,clear,53372,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['clear'],['clear']
Usability,"nfig.yaml; Check psi4/doc/sphinxman/source/introduction.rst for any compiler and Python minimum requirements to edit. Tag (pre)release¶. Thorough version bump directions at master http://psicode.org/psi4manual/master/manage_git.html#how-to-bump-a-version; Below is tl;dr; # be on clean master up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3rc1'; -__version_long = '1.3rc1+5a7522a'; -__version_upcoming_annotated_v_tag = '1.3rc2'; +__version__ = '1.3rc2'; +__version_long = '1.3rc2+zzzzzzz'; +__version_upcoming_annotated_v_tag = '1.3rc3'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3rc2""; [master bc8d7f5] v1.3rc2. >>> git log --oneline | head -1; bc8d7f5 v1.3rc2; >>> git tag -a v1.3rc2 bc8d7f5 -m ""v1.3rc2"". # pause here and push to upstream and let Azure complete if want an; # on-tag Windows conda package, not just tag+1.dev1. >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version_long = '1.3rc2+zzzzzzz'; +__version_long = '1.3rc2+bc8d7f5'. >>> git add psi4/metadata.py; >>> git commit -m ""Records tag for v1.3rc2""; [master 16dbd3e] Records tag for v1.3rc2. # goto GH:psi4/psi4 > Settings > Branches > master > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/424295; # uncheck ""Include administrators"" and Save changes. >>> git push upstream master; >>> git push upstream v1.3rc2. # re-engage ""Include administrators"" protections. Tag postrelease¶. # be on clean maintenance branch up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> git checkout 1.3.x; Switched to branch '1.3.x'. >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/manage_release-1.html:6336,pause,pause,6336,psi4manual/1.5.0/manage_release-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/manage_release-1.html,2,['pause'],['pause']
Usability,"nfig.yaml; Check psi4/doc/sphinxman/source/introduction.rst for any compiler and Python minimum requirements to edit. Tag (pre)release¶. Thorough version bump directions at master http://psicode.org/psi4manual/master/manage_git.html#how-to-bump-a-version; Below is tl;dr; # be on clean master up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3rc1'; -__version_long = '1.3rc1+5a7522a'; -__version_upcoming_annotated_v_tag = '1.3rc2'; +__version__ = '1.3rc2'; +__version_long = '1.3rc2+zzzzzzz'; +__version_upcoming_annotated_v_tag = '1.3rc3'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3rc2""; [master bc8d7f5] v1.3rc2. >>> git log --oneline | head -1; bc8d7f5 v1.3rc2; >>> git tag -a v1.3rc2 bc8d7f5 -m ""v1.3rc2"". # pause here and push to upstream and let Azure complete if want an; # on-tag Windows conda package, not just tag+1.dev1; # below pushes commit and tag together so only one CI; # > git push --atomic upstream master v1.5; # also, grab the docs build from GHA artifacts. >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version_long = '1.3rc2+zzzzzzz'; +__version_long = '1.3rc2+bc8d7f5'. >>> git add psi4/metadata.py; >>> git commit -m ""Records tag for v1.3rc2""; [master 16dbd3e] Records tag for v1.3rc2. # goto GH:psi4/psi4 > Settings > Branches > master > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/424295; # uncheck ""Include administrators"" and Save changes. >>> git push upstream master; >>> git push upstream v1.3rc2. # re-engage ""Include administrators"" protections. Tag postrelease¶. # be on clean maintenance branch up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/manage_release.html:6264,pause,pause,6264,psi4manual/1.6.x/manage_release.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/manage_release.html,1,['pause'],['pause']
Usability,"ng this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that cater",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html:4323,simpl,simply,4323,psi4manual/1.4.0/prog_ways_to_add-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html,9,['simpl'],['simply']
Usability,"ng to removal of the OS code in version 1.6. An overview of the one electron integrals; is shown in table Algorithms used for One Electron Integrals, together with the implementation they use.; The tips below serve as a guide to what changed,; why it changed, and how to interface with PSI4’s one-electron integral; machinery now. Calling compute_shell(int P, int Q)¶; The hand-implemented OS recursion code also took care of the Cartesian->pure; transformation (if required by the basis set). The mechanism for handling this; was to provide a public facing compute_shell(int P, int Q) method for the; caller; this then looked up the appropriate GaussianShell objects that were; passed into the corresponding (private) compute_pair(GaussianShell &s1,; GaussianShell &s2) function that computed the integrals and transformed them; to the spherical harmonic basis, if needed. The switch to Libint2 integrals; preserves this mechanism, but the compute_shell(int P, int Q) simply looks; up the appropriate Libint2-compatible shells and hands them off to the; re-written, private compute_pair() routines, which call Libint2 directly.; Therefore, any calls to shell-pair level integral computations should look the; same as before the introduction of Libint2, however access to the integrals has; changed, as described below. Accessing integrals¶; Before the Libint2 transition, one electron integrals were computed in a flat; array, internally called buffer_, which was accessed through the integral; object’s buffer() method. For integrals with multiple operators, e.g.,; dipole operators that have three distinct components, the buffer was simply; elongated by the appropriate amount and the caller was responsible for striding; through each resulting batch correctly. The Libint2 engines instead return a; list of pointers into each operator’s batch of integrals, the ordering of which; are detailed on the Libint2 wiki. For this reason, the call to buffer(); that returns a single buffer must be replac",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/prog_integrals.html:12496,simpl,simply,12496,psi4manual/1.6.x/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html,5,['simpl'],['simply']
Usability,"ng to the quantum chemical method and so its default value is set; by each module individually. [7](1, 2, 3) For frequency computations by finite difference of energies,; convergence criteria are tightened further still to 10 for; E_CONVERGENCE and D_CONVERGENCE for SCF of HF or DFT, 11; for E_CONVERGENCE and D_CONVERGENCE for SCF of post-HF,; and 10 for E_CONVERGENCE for post-HF of post-HF. Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment. Also, the SAD; UHF guess is very slow in large basis sets, so you may want to cast up for; >TZ.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'). Table Of Contents. H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:32863,simpl,simple,32863,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,6,['simpl'],['simple']
Usability,"ng. scale_column(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float) → None¶; docstring. scale_row(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float) → None¶; docstring. schmidt(self: psi4.core.Matrix) → None¶. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Matrix, arg0: float) -> None. docstring. set(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: float) -> None. docstring. set(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int, arg3: float) -> None. docstring. set(self: psi4.core.Matrix, arg0: list) -> None. docstring. shape¶; Shape of the Psi4 data object. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → None¶; docstring. sum_of_squares(self: psi4.core.Matrix) → float¶; docstring. symmetrize_gradient(self: psi4.core.Matrix, arg0: psi::Molecule) → None¶; docstring. symmetry(self: psi4.core.Matrix) → int¶; docstring. to_array(matrix, copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data)¶; Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float¶; docstring. transform(*args, **kwargs)¶; Overloaded function. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix) -> None. docstring. transform(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:69075,simpl,simply,69075,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['simpl'],['simply']
Usability,"ning at R_CONVERGENCE). It is defined; according to the quantum chemical method and so its default value is set; by each module individually. [7]; (1,2,3); For frequency computations by finite difference of energies,; convergence criteria are tightened further still to 10 for; E_CONVERGENCE and D_CONVERGENCE for SCF of HF or DFT, 11; for E_CONVERGENCE and D_CONVERGENCE for SCF of post-HF,; and 10 for E_CONVERGENCE for post-HF of post-HF. Recommendations¶; The SCF code is quite flexible and powerful.; We have tried as much as possible to keep the number of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'). table of contents. HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Sym",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/scf.html:48961,simpl,simple,48961,psi4manual/1.7.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/scf.html,4,['simpl'],['simple']
Usability,"nning at R_CONVERGENCE). It is defined; according to the quantum chemical method and so its default value is set; by each module individually. [7](1, 2, 3) For frequency computations by finite difference of energies,; convergence criteria are tightened further still to 10 for; E_CONVERGENCE and D_CONVERGENCE for SCF of HF or DFT, 11; for E_CONVERGENCE and D_CONVERGENCE for SCF of post-HF,; and 10 for E_CONVERGENCE for post-HF of post-HF. Recommendations¶; The SCF code is quite flexible and powerful.; We have tried as much as possible to keep the number of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'). table of contents. HF: Hartree–Fock Theory; Introduction; Theor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:35498,simpl,simple,35498,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['simpl'],['simple']
Usability,"ntation:; # Now we need to rotate the geometry to its symmetry frame; # to align the axes correctly for the point group; # symmetry_frame looks for the highest point group so that we can align; # the molecule according to its actual symmetry, rather than the symmetry; # the the user might have provided.; frame = self.symmetry_frame(); self.rotate_full(frame); #print ""after rotate:""; #self.print_full(). # Recompute point group of the molecule, so the symmetry info is updated to the new frame; # TODO self.set_point_group(self.find_point_group()); # TODO self.set_full_point_group(). # Disabling symmetrize for now if orientation is fixed, as it is not; # correct. We may want to fix this in the future, but in some cases of; # finite-differences the set geometry is not totally symmetric anyway.; # Symmetrize the molecule to remove any noise; # TODO self.symmetrize(); #print ""after symmetry:""; #self.print_full(). self.lock_frame = True. # <<< Methods for Miscellaneous >>>. [docs] def clear(self):; """"""Zero it out.""""""; self.lock_frame = False; self.atoms = []; self.full_atoms = []. [docs] def nuclear_repulsion_energy(self):; """"""Computes nuclear repulsion energy. >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. """"""; e = 0.0; for at1 in range(self.natom()):; for at2 in range(self.natom()):; if at2 < at1:; Zi = self.Z(at1); Zj = self.Z(at2); dist = distance(self.xyz(at1), self.xyz(at2)); e += Zi * Zj / dist; return e. [docs] def nuclear_repulsion_energy_deriv1(self):; """"""Computes nuclear repulsion energy derivatives. >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. """"""; de = []; for i in range(self.natom()):; entry = [0.0, 0.0, 0.0]; for j in range(se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:43795,clear,clear,43795,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,3,['clear'],['clear']
Usability,"nts. see ""intermediates_energy"" in big table below for example.; note that there's a lot of natural 1-indexing (1, 2, 3) rather than 0-indexing (0, 1, 2) in manybody. e.g., 2-body energy, Molecule.extract_subsets(1, (1, 2)); note that a ""level"" can be n-body level (how many real molecular fragments) or a modelchem level (`mc_`; e.g., CC on 1-bodies, MP2 on 2-bodies; ""multilevel""). ---------------------------; ManyBodyComputer.__init__(); ---------------------------; * not an explicit function but pydantic handles some defaults and validation; * fields molecule, nfragments, bsse_type, return_total_data, and initial max_nbody set; * BaseComputer.__init__(). task_planner.py::task_planner(); -------------------------------; * computer gets modified from task_planner outside this file!; * modelchem (method and basis) treatment levels for each n-body level determined from user levels kwarg. fields nbodies_per_mc_level set and max_nbody reset; * for each modelchem treatment level, call build_tasks() below via one of four routes, depending on simple MB or layered MB(FD), MB(CBS), or MB(FD(CBS)). ------------------------------; ManyBodyComputer.build_tasks(); ------------------------------; * if supersystem requested as a modelchem level, request (frag, bas) indices for full nbody range of nocp treatment from build_nbody_compute_list(); * otherwise, request (frag, bas) indices for specified nbody range covering specified bsse treatments from build_nbody_compute_list(). build_nbody_compute_list(); --------------------------; * initializes dicts for each of nocp, cp, vmfc (2 for this one) with keys requested n-body levels and values empty sets; * use combinatorics formulas to fill each key with (frag, bas) indices (what fragments are active and what fragments have basis functions); needed to compute the requested bsse treatments at the requested n-body levels.; * merge by n-body level the sets of indices for each bsse treatment into an ""all"" dict. return this and all the per-bs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:2595,simpl,simple,2595,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,5,['simpl'],['simple']
Usability,"nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Isotopic Substitution¶. Caution; Use of isotopic substitution in PSI4 is not well; developed, and the syntax is subject to change. At present, isotopes can only be specified at creation-time of the molecule; The syntax for a deuterium- and tritium-substituted water is below. Note; that asymmetric isotopic substitution such as this will change the; molecule’s point group symmetry.; 1; 2; 3; 4; 5; 6molecule dto {; units au; O 0.00000000 0.00000000 0.00000000; H@2.014101779 0.00000000 1.93042809 -1.10715266; H_label@3.01604927 0.00000000 -1.93042809 -1.10715266; }. The masses used by PSI4 can be found at; psi4/psi4/include/psi4/masses.h. See freq-isotope for about; the only use to which isotopologues can presently be put in PSI4. PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; 1; 2; 3molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are print",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:7657,intuit,intuitive,7657,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['intuit'],['intuitive']
Usability,"o add.; Labels have been added as developers needed, so they are not systematic or thorough. If you see labels to add or rename, please do.; A test requiring over 15 minutes should be labeled longtests. A short test under 30 seconds used for general bug checking should be labeled quicktests. A test that confirms PSI4 is operational should be labeled smoketests.; If a test needs extra input files like grid.dat or extra reference files for checking against, like fchk, specify these in the CMakeLists.txt as shown above. Such tests must be run through ctest and don’t usually work when run “by hand” from the objdir via stage/bin/psi4 ../tests/directory_name/input.dat.; If a test is multiple minutes long, load-balancing a parallel CTest run requires the test to be started early. Use the COST line as shown above to set a weighting to about the number of seconds the test takes. input.dat¶; The other necessary file is the input file itself, input.dat. The input file should be just a simple input file to run the test, with small additions.; #! RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxiliary basis.; #! Also a bit more to force a second line. nucenergy = 8.801466202085710 #TEST; refenergy = -76.05098402733282 #TEST. molecule h2o {; symmetry c1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pVTZ; scf_type df; df_basis_scf cc-pVTZ-RI; e_convergence 10; }. thisenergy = energy(""hf""). compare_values(nucenergy, h2o.nuclear_repulsion_energy(), 9, ""Nuclear repulsion energy"") #TEST; compare_values(refenergy, thisenergy, 9, ""Reference energy"") #TEST; compare_values(refenergy, variable('scf total energy'), 9, ""Reference energy"") #TEST. Of those small modifications, first, note the special comment at the top (starting with the #! comment marker). This should be descriptive since it is inlined into the manual (unless !nosample in the comment) as a sample input.; Reference values are often assigned to variables for later use.; The compare_values function (along ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/add_tests.html:6839,simpl,simple,6839,psi4manual/1.6.x/add_tests.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/add_tests.html,5,['simpl'],['simple']
Usability,"o electrons or nuclear charge. See dfmp2-1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Isotopic Substitution¶. Caution; Use of isotopic substitution in PSI4 is not well; developed, and the syntax is subject to change. At present, isotopes can only be specified at creation-time of the molecule; The syntax for a deuterium- and tritium-substituted water is below. Note; that asymmetric isotopic substitution such as this will change the; molecule’s point group symmetry.; molecule dto {; units au; O 0.00000000 0.00000000 0.00000000; H@2.014101779 0.00000000 1.93042809 -1.10715266; H_label@3.01604927 0.00000000 -1.93042809 -1.10715266; }. The masses used by PSI4 can be found at; psi4/psi4/include/psi4/masses.h. See freq-isotope2 for about; the only use to which isotopologues can presently be put in PSI4. PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html:7286,intuit,intuitive,7286,psi4manual/1.4.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html,9,['intuit'],['intuitive']
Usability,"o the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[detail",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:63574,guid,guide,63574,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['guid'],['guide']
Usability,"o zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:1570,clear,clear,1570,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,1,['clear'],['clear']
Usability,"o zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ExternalPotential.html:1586,clear,clear,1586,psi4manual/1.6.x/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ExternalPotential.html,2,['clear'],['clear']
Usability,"ocessed into method=”cbs” & CBSMetadata spec;; method=""cbs"", cbsmeta=CBSMetadata – passes through. Parameters:. method (str) – User first argument to driver function. A string hint of the method –; see cases above.; basis (str) – User basis hint.; driver (DriverEnum) – The calling driver function. Note for finite difference that this is; the target driver, not the means driver. Return type:; Tuple[str, str, Dict]. psi4.driver.task_planner.task_planner(driver, method, molecule, **kwargs)[source]¶; Plans a task graph of a complex computation. Canonical Task layering:; ManyBody - BSSE treatment, many-body expansion; FiniteDifference - derivatives through stencils; Composite - basis set extrapolation, focal-point methods; Atomic - analytic single-points. Parameters:. driver (DriverEnum) – The resulting type of computation: e/g/h. Note for finite difference; that this should be the target driver, not the means driver.; method (str) – A string representation of the method such as “HF” or “B3LYP”. Special; cases are: “cbs”.; molecule (Molecule) – A Psi4 base molecule to use.; kwargs – User keyword arguments, often used to configure task computers. Returns:; A simple (AtomicComputer) or layered (CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer) task object. Layered objects contain many and multiple types of computers in a graph. Return type:; Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer]. table of contents. External API Objects; Molecule; IPIBroker; auto_fragments(); process_input(); ip_fitting(); frac_traverse(); frac_nuke(); set_output_file(); BaseComputer; BaseComputer.compute(); BaseComputer.plan(). TaskComputers; SubTaskComputers; expand_cbs_methods(); task_planner(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .  · ; 1.10a1.dev61;  · . PSI4. External API Objects. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/external_apis.html:8630,simpl,simple,8630,psi4manual/master/external_apis.html,https://psicode.org,https://psicode.org/psi4manual/master/external_apis.html,1,['simpl'],['simple']
Usability,"ocstring. clear(self); docstring. compute(self); docstring. set_Da_ao(self, Da, symmetry); docstring. set_Da_mo(self, arg0); docstring. set_Da_so(self, arg0); docstring. set_Db_ao(self, Db, symmetry); docstring. set_Db_mo(self, arg0); docstring. set_Db_so(self, arg0); docstring. set_title(self, arg0); docstring. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']¶. Methods Documentation. Exvals(self: psi4.core.OEProp) → List[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; docstring. clear(self: psi4.core.OEProp) → None¶; docstring. compute(self: psi4.core.OEProp) → None¶; docstring. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0) → None¶; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0) → None¶; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_title(self: psi4.core.TaskListComputer, arg0: str) → None¶; docstring. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; OEProp. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.oeprop.html:1619,clear,clear,1619,psi4manual/1.4.0/api/psi4.core.oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.oeprop.html,1,['clear'],['clear']
Usability,"odified damping scheme for DFT-D3 using the rational damping form of; Becke and Johnson was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now \(s_6\), \(s_8\),; \(a_1\), and \(a_2\). \[E_{disp}^{\text{D3BJ}}=-\sum_{n=6,8} s_n \sum_{i,j>i}^{N_{at}}; \frac{C_n^{ij}}{(R_{ij})^n + (f_{damp})^n}\]. \[f_{damp} = a_1 \sqrt{\frac{C_8^{ij}}{C_6^{ij}}} + a_2\]; All parameters characterizing the dispersion correction are taken from; Grimme’s website; or else from the literature. Running DFTD3 or DFTD4¶; A number of a posteriori dispersion corrections are available in; PSI4. While some are computed within PSI4‘s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 or -D4 corrections and their variants are; available only through the DFTD3 or DFTD4 programs. Once installed, the; dftd3/PSI4 and dftd4/PSI4 interfaces are transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, a B3LYP-D3 (zero-damping), and a B3LYP-D4 (Becke-Johnson damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'); energy('b3lyp-d4'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2.; No text output is available from the dftd4 program. Variants of dispersion corrections¶. Extension 1; Variant; Computing Program (engine); DFT_DISPERSION_PARAMETERS 11. -D; alias to -D2. -D1; -D1 2; PSI4‘s libdisp; [\(s_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/dftd3-1.html:4900,simpl,simple,4900,psi4manual/1.5.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/dftd3-1.html,3,['simpl'],['simple']
Usability,"of preceding or following; jobs, it is prudent to separate them with the following:; 1; 2; 3clean() # removes Psi4 scratch files; clean_variables() # empties the PSI variables list; cfour {} # empties the cfour block. Warning; Because p4c4 does not inspect the contents of the cfour {...}; block, once the user specifies a PSI4-style molecule, the; interface cannot judge whether a sandwich mode (drop the PSI4 molecule; and use the cfour block as the entirety of the ZMAT) or a standard mode; (translate the PSI4 molecule and append additional input from the; cfour block) is intended. The latter is what actually occurs. If; there is both a PSI4 molecule and a molecule in the cfour block,; ZMAT will end up with multiple molecules and multiple *CFOUR(...); blocks, and it will not run. Therefore, if mixing sandwich and; standard or pure-PSI4 computations in an input file, place all; the sandwich jobs at the beginning before declaring PSI4; molecules. If necessary, clear the cfour block with cfour {} before; commencing standard P4C4 jobs. Output¶; The output of xcfour invoked from a PSI4 input file is; written to the PSI4 output file as the computation progresses. If a; Cfour module terminates with a non-zero error code, the value will show up; in CFOUR ERROR CODE.; Energies & Scalars; After execution of xcfour has completed, the output string is; extensively parsed and appropriate results are stored in PSI; Variables. All gleaned variables are printed in the; Cfour output section of the PSI4 output file, as shown below.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//; // Cfour c4-ccsd(t) Energy Results //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. Variable Map:; ----------------------------------------------------------------------------; ""(T) CORRECTION ENERGY"" => -0.007263598030; ""CCSD CORRELATION ENERGY"" => -0.275705492359; ""CCSD TOTAL ENERGY"" => -76.338453952539; ""CCSD(T) CORRELATION ENERGY"" => -0.00726",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:19185,clear,clear,19185,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,6,['clear'],['clear']
Usability,"of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the orbital-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals we can simply use “reference rohf” option. For DFT orbitals one should use “reference uks” and “dft_functional b3lyp” options. Of; course users can use any DFT functional available in Psi4. Methods¶; The orbital-optimized MPn and OLCCD methods currently supported in; Psi4 are outlined in Table Orbital-Optimzed OCC/DFOCC; Methods. The following methods are available; and can be controlled through OCC (conventional integrals CONV); and DFOCC (density-fitted DF and Cholesky-decomposed CD); keywords. Switching between the integrals treatments is controlled; through ‘type select’ values; see rightmost Table column. Orbital-Optimized MP and LCCD capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. omp2; Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE CONV. Density-Fitted Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —; MP2_TYPE CD. omp3; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/occ-1.html:6019,simpl,simply,6019,psi4manual/1.0.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/occ-1.html,2,['simpl'],['simply']
Usability,"oing a full CI in the active space. This is called a; RASSCF. CASSCF and RASSCF computations are types of multi-configurational; self-consistent-field procedures, and are described in sec:mcscf.; As mentioned above, the DETCI module is designed for challenging; chemical systems for which simple CISD is not suitable. Because; CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,; typically the DETCI code will be used in cases where the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. Higher order; single-reference CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specified by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Orbital spaces for CI computations¶. CI (e.g., CISD, FCI); RASCI; CASCI. FROZEN_UOCC; FROZEN_UOCC; FROZEN_UOCC [1]. (al",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/detci-1.html:4466,simpl,simply,4466,psi4manual/1.2.1/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/detci-1.html,6,['simpl'],['simply']
Usability,"olecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=self.findifrec[""reference""][""module""]),; 'extras': {; 'qcvars': qcvars,; 'findif_record': copy.deepcopy(self.findifrec),; },; 'return_result': self.findifrec['reference'][self.driver.name],; 'success': True,; }). logger.debug('\nFINDIF QCSchema:\n' + pp.pformat(findif_model.dict())). return findif_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - undisplaced molecule; - compute basis if simple, else dummy basis def2-svp; - e/g/h member data; - QCVariables; - module. Returns; -------; ret; Gradient or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; findif_model = self.get_results(client=client). ret_ptype = core.Matrix.from_array(findif_model.return_result); wfn = _findif_schema_to_wfn(findif_model). gradient_write(wfn); hessian_write(wfn). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _findif_schema_to_wfn(findif_model: AtomicResult) -> core.Wavefunction:; """"""Helper function to produce Wavefunction and Psi4 files from a FiniteDifference-flavored AtomicResult."""""". # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; mol = core.Molecule.from_schema(findif_model.molecule.dict(), nonphysical=True); sbasis = ""def2-svp"" if (findif_model.model.basis == ""(auto)"") else findif_model.model.basis; basis = core.BasisSet.build(mol, ""ORBITAL"", sbasis, quiet=True); wfn = core.Wavefunction",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:52773,simpl,simple,52773,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,3,['simpl'],['simple']
Usability,"ome awareness of the chemical; environment into an otherwise largely heuristic correction. The -D3; dispersion has the following form, where and ; are the customary nonunity parameters fitted for individual functionals. (2). A modified damping scheme for DFT-D3 using the rational damping form of; Becke and Johnson was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now , ,; , and . All parameters characterizing the dispersion correction are taken from; http://toc.uni-muenster.de/DFTD3/; or else from the literature. Running DFTD3¶; A number of a posteriori dispersion corrections are available in; PSI4. While most are computed within PSI4’s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/PSI4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of S. Grimme’s -D correction. Extension [1]; Variant and Computing Program; DFT_DISPERSION_PARAMETERS. -D; alias to -D2P4;  . -D1; -D1 [2] within PSI4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within PSI4; []. -D2GR; -D2 [3] through dftd3; [, ]. -D3; alias to -D3ZERO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/dftd3.html:3789,simpl,simple,3789,psi4manual/4.0b3/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/dftd3.html,5,['simpl'],['simple']
Usability,"ome awareness of the chemical; environment into an otherwise largely heuristic correction. The -D3; dispersion has the following form, where and ; are the customary nonunity parameters fitted for individual functionals. (2). A modified damping scheme for DFT-D3 using the rational damping form of; Becke and Johnson was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now , ,; , and . All parameters characterizing the dispersion correction are taken from; http://toc.uni-muenster.de/DFTD3/; or else from the literature. Running DFTD3¶; A number of a posteriori dispersion corrections are available in; Psi4. While most are computed within Psi4‘s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/Psi4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of S. Grimme’s -D correction¶. Extension [1]; Variant and Computing Program; DFT_DISPERSION_PARAMETERS. -D; alias to -D2P4;  . -D1; -D1 [2] within Psi4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within Psi4; []. -D2GR; -D2 [3] through dftd3; [, ]. -D3; alias to -D3ZER",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dftd3-1.html:4503,simpl,simple,4503,psi4manual/1.0.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dftd3-1.html,2,['simpl'],['simple']
Usability,"omlist=False, *, quiet=False)¶; Build a primary or auxiliary basis set. Parameters:. mol (Molecule) – Molecule for which to build the basis set instance.; key (Optional[str]) – {‘BASIS’, ‘ORBITAL’, ‘DF_BASIS_SCF’, ‘DF_BASIS_MP2’, ‘DF_BASIS_CC’, ‘BASIS_RELATIVISTIC’, ‘DF_BASIS_SAD’}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ""ORBITAL"" or ""BASIS"".; target (Union[str, Callable, None]) – Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely from primary default, can be; an empty string. If None, value taken from key in global options. If; a user-defined-basis callable is available at string target, target; value will be set to it. In practice, setting this argument to a; PSI4 keyword (e.g., core.get_option(""SCF"", ""DF_BASIS_SCF"") or; core.get_global_option(""BASIS"")) works to handle both simple and; user-defined bases.; fitrole (str) – {‘ORBITAL’, ‘JKFIT’, ‘RIFIT’, ‘DECON’}; Role for which to build basis. Only used when key indicates auxiliary; (i.e., is not ""BASIS"") and auxiliary spec from processing target; can’t complete the mol. Then, primary spec from other can be used; to complete the auxiliary basis by looking up suitable default basis; according to fitrole.; other (Union[str, Callable, None]) – Only used when building auxiliary basis sets. Defines the primary basis through a string or callable like target.; puream (int) – Whether to override the native spherical/cartesian-ness of target for; returned basis? Value 1 forces spherical, value 0 forces; Cartesian, value -1 (default) uses native puream. Note that; explicitly setting PUREAM trumps both native; puream and this puream argument.; return_atomlist (bool) – Build one-atom basis sets (e.g., for SAD) rather than one whole-mol; basis set.; quiet (bool) – When True, do not print to the output file. Ret",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisSet.html:4100,simpl,simple,4100,psi4manual/1.7.x/api/psi4.core.BasisSet.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BasisSet.html,4,['simpl'],['simple']
Usability,"omputations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (i.e., each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (i.e., each monomer utilizes only its; own basis set). It is also possible to run a SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; sapt_basis='monomer' to the energy function, such as; energy('sapt2',sapt_basis='monomer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat_orbs_t2 true; freeze_core true; }. energy('sapt2+3'). To reiterate some of the options mentioned above: the; NAT_ORBS_T2 option will compute MP2 natural orbitals and use; them in the e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/sapt-1.html:13607,simpl,simply,13607,psi4manual/4.0b5/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/sapt-1.html,2,['simpl'],['simply']
Usability,"on in symmetry. The \(^2B_2\) state,; whose singly-occupied orbitals are; 1SOCC = [0, 0, 0, 1]. would be mapped to; 1SOCC = [1, 0]. which is the same occupation as the \(^2A_1\) state. In this case, the; \(^2A_1\) state is lower in energy, and is not problematic. The distorted; geometries for the \(^2B_2\) state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so: simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:14715,simpl,simple,14715,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,12,['simpl'],"['simple', 'simply']"
Usability,"on may not be an eigenfunction of the operator.; However, spin contamination is usually less of a problem with UKS than with; UHF, as the spin contamination of the noninteracting quasiparticles (the; metric printed in the output) is usually a severe overestimation; of the spin contamination of the true electrons. These are set in the REFERENCE option.; Note that there are not equivalents to ROHF or CUHF, e.g., no ROKS or CUKS. This; is because ROHF is implicitly assumed to be followed by a correlated method; which can break the positive definiteness of the spin polarization. KS-DFT with; the true functional is expected to be the final step, thus restricting the; solution to positive definite spin polarization is not physical. See the; section in Szabo on methyl radical for an example. Functional Selection¶; PSI4 features an extensive list of LSDA, GGA, Meta, Hybrid, LRC, and -D; functionals. These can be specified by a variety of means. Perhaps the simplest; is to use the functional name as the energy procedure call:; energy('b3lyp'). Note that if you are running an unrestricted computation, you should set the; REFERENCE option before the call to energy:; set reference uks; energy('b3lyp'). The functional may also be manually specified by the DFT_FUNCTIONAL; option:; set dft_functional b3lyp; energy('scf'). For hybrid functionals, the fraction of exact exchange is controlled by the; DFT_ALPHA option. For the LRC functionals, the fraction of long-range; Hartree-Fock and short-range DFA is controlled by the DFT_OMEGA option.; Changing these will override the default behavior of the requested functional.; A brief summary of some of the more notable functionals in PSI4, and links; to the complete listing of all functionals of each class are presented below:. All Functionals; All functionals, including LSDA-only functionals. Note that here and; throughout, functionals which end in _X or _C are exchange or; correlation only, and should not be used for most production-leve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/dft-1.html:10776,simpl,simplest,10776,psi4manual/4.0b2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/dft-1.html,8,['simpl'],['simplest']
Usability,"on may not be an eigenfunction of the operator.; However, spin contamination is usually less of a problem with UKS than with; UHF, as the spin contamination of the noninteracting quasiparticles (the; metric printed in the output) is usually a severe overestimation; of the spin contamination of the true electrons. These are set in the REFERENCE option.; Note that there are not equivalents to ROHF or CUHF, e.g., no ROKS or CUKS. This; is because ROHF is implicitly assumed to be followed by a correlated method; which can break the positive definiteness of the spin polarization. KS-DFT with; the true functional is expected to be the final step, thus restricting the; solution to positive definite spin polarization is not physical. See the; section in Szabo on methyl radical for an example. Functional Selection¶; Psi4 features an extensive list of LSDA, GGA, Meta, Hybrid, LRC, and -D; functionals. These can be specified by a variety of means. Perhaps the simplest; is to use the functional name as the energy procedure call:; energy('b3lyp'). Note that if you are running an unrestricted computation, you should set the; REFERENCE option before the call to energy:; set reference uks; energy('b3lyp'). The functional may also be manually specified by the DFT_FUNCTIONAL; option:; set dft_functional b3lyp; energy('scf'). For hybrid functionals, the fraction of exact exchange is controlled by the; DFT_ALPHA option. For the LRC functionals, the fraction of long-range; Hartree-Fock and short-range DFA is controlled by the DFT_OMEGA option.; Changing these will override the default behavior of the requested functional.; A brief summary of some of the more notable functionals in Psi4, and links; to the complete listing of all functionals of each class are presented below:. All Functionals; All functionals, including LSDA-only functionals. Note that here and; throughout, functionals which end in _X or _C are exchange or; correlation only, and should not be used for most production-leve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:10886,simpl,simplest,10886,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,2,['simpl'],['simplest']
Usability,"on of the \(\hat S^2\) operator.; However, spin contamination is usually less of a problem with UKS than with; UHF, as the spin contamination of the noninteracting quasiparticles (the; \(S^2\) metric printed in the output) is usually a severe overestimation; of the spin contamination of the true electrons. These are set in the REFERENCE option.; Note that there are not equivalents to ROHF or CUHF, e.g., no ROKS or CUKS. This; is because ROHF is implicitly assumed to be followed by a correlated method; which can break the positive definiteness of the spin polarization. KS-DFT with; the true functional is expected to be the final step, thus restricting the; solution to positive definite spin polarization is not physical. See the; section in [Szabo:1982] on methyl radical for an example. Functional Selection¶; PSI4 features an extensive list of LSDA, GGA, Meta, Hybrid, LRC, and -D; functionals. These can be specified by a variety of means. Perhaps the simplest; is to use the functional name as the energy procedure call:; 1energy('b3lyp'). Note that if you are running an unrestricted computation, you should set the; REFERENCE option before the call to energy:; 1; 2set reference uks; energy('b3lyp'). The functional may also be manually specified by calling energy (or any driver function); with a dft_functional argument:; 1energy('scf', dft_functional = 'b3lyp'). Another alternative is providing a specially crafted dict-ionary to the dft_functional; argument:; 1; 2custom_functional = { ""name"": ""my_unique_name"", ... }; energy('scf', dft_functional = custom_functional). For further details about this so called dict_func syntax, see; Advanced Functional Use and Manipulation.; For hybrid functionals, the fraction of exact exchange is controlled by the; DFT_ALPHA option. For the LRC functionals, the fraction of long-range; Hartree–Fock and short-range DFA is controlled by the DFT_OMEGA option.; Changing these will override the default behavior of the requested functional.; A br",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dft-1.html:14638,simpl,simplest,14638,psi4manual/1.3.2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dft-1.html,2,['simpl'],['simplest']
Usability,"on of the \(\hat S^2\) operator.; However, spin contamination is usually less of a problem with UKS than with; UHF, as the spin contamination of the noninteracting quasiparticles (the; \(S^2\) metric printed in the output) is usually a severe overestimation; of the spin contamination of the true electrons. These are set in the REFERENCE option.; Note that there are not equivalents to ROHF or CUHF, e.g., no ROKS or CUKS. This; is because ROHF is implicitly assumed to be followed by a correlated method; which can break the positive definiteness of the spin polarization. KS-DFT with; the true functional is expected to be the final step, thus restricting the; solution to positive definite spin polarization is not physical. See the; section in [Szabo:1982] on methyl radical for an example. Functional Selection¶; PSI4 features an extensive list of LSDA, GGA, Meta, Hybrid, LRC, and -D; functionals. These can be specified by a variety of means. Perhaps the simplest; is to use the functional name as the energy procedure call:; 1energy('b3lyp'). Note that if you are running an unrestricted computation, you should set the; REFERENCE option before the call to energy:; 1; 2set reference uks; energy('b3lyp'). The functional may also be manually specified by calling energy (or any other keyword); with a dft_functional argument:; 1energy('scf', dft_functional = 'b3lyp'). Another alternative is providing a specially crafted dict-ionary to the dft_functional; argument:; 1; 2custom_functional = { ""name"": ""my_unique_name"", ... }; energy('scf', dft_functional = custom_functional). For further details about this so called dict_func syntax, see; :ref: Advanced Functional Use and Manipulation.; For hybrid functionals, the fraction of exact exchange is controlled by the; DFT_ALPHA option. For the LRC functionals, the fraction of long-range; Hartree–Fock and short-range DFA is controlled by the DFT_OMEGA option.; Changing these will override the default behavior of the requested functional.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:14617,simpl,simplest,14617,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,2,['simpl'],['simplest']
Usability,"on of the \(\hat S^2\) operator.; However, spin contamination is usually less of a problem with UKS than with; UHF, as the spin contamination of the noninteracting quasiparticles (the; \(S^2\) metric printed in the output) is usually a severe overestimation; of the spin contamination of the true electrons. These are set in the REFERENCE option.; Note that there are not equivalents to ROHF or CUHF, e.g., no ROKS or CUKS. This; is because ROHF is implicitly assumed to be followed by a correlated method; which can break the positive definiteness of the spin polarization. KS-DFT with; the true functional is expected to be the final step, thus restricting the; solution to positive definite spin polarization is not physical. See the; section in [Szabo:1982] on methyl radical for an example. Functional Selection¶; PSI4 features an extensive list of LSDA, GGA, Meta, Hybrid, LRC, and -D; functionals. These can be specified by a variety of means. Perhaps the simplest; is to use the functional name as the energy procedure call:; 1energy('b3lyp'). Note that if you are running an unrestricted computation, you should set the; REFERENCE option before the call to energy:; 1; 2set reference uks; energy('b3lyp'). The functional may also be manually specified by the DFT_FUNCTIONAL; option:; 1; 2set dft_functional b3lyp; energy('scf'). For hybrid functionals, the fraction of exact exchange is controlled by the; DFT_ALPHA option. For the LRC functionals, the fraction of long-range; Hartree–Fock and short-range DFA is controlled by the DFT_OMEGA option.; Changing these will override the default behavior of the requested functional.; A brief summary of some of the more notable functionals in PSI4, and links; to the complete listing of all functionals of each class are presented below:. All Functionals; All functionals, including LSDA-only functionals. Note that here and; throughout, functionals which end in _X or _C are exchange or; correlation only, and should not be used for most product",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dft-1.html:14342,simpl,simplest,14342,psi4manual/1.1.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dft-1.html,2,['simpl'],['simplest']
Usability,"on of the \(\hat S^2\) operator.; However, spin contamination is usually less of a problem with UKS than with; UHF, as the spin contamination of the noninteracting quasiparticles (the; \(S^2\) metric printed in the output) is usually a severe overestimation; of the spin contamination of the true electrons. These are set in the REFERENCE option.; Note that there are not equivalents to ROHF or CUHF, e.g., no ROKS or CUKS. This; is because ROHF is implicitly assumed to be followed by a correlated method; which can break the positive definiteness of the spin polarization. KS-DFT with; the true functional is expected to be the final step, thus restricting the; solution to positive definite spin polarization is not physical. See the; section in [Szabo:1982] on methyl radical for an example. Functional Selection¶; PSI4 features an extensive list of LSDA, GGA, Meta, Hybrid, LRC, and -D; functionals. These can be specified by a variety of means. Perhaps the simplest; is to use the functional name as the energy procedure call:; energy('b3lyp'). Note that if you are running an unrestricted computation, you should set the; REFERENCE option before the call to energy:; set reference uks; energy('b3lyp'). The functional may also be manually specified by calling energy (or any driver function); with a dft_functional argument:; energy('scf', dft_functional = 'b3lyp'). Another alternative is providing a specially crafted dict-ionary to the dft_functional; argument:; custom_functional = { ""name"": ""my_unique_name"", ... }; energy('scf', dft_functional = custom_functional). For further details about this so called dict_func syntax, see; Advanced Functional Use and Manipulation.; For hybrid functionals, the fraction of exact exchange is controlled by the; DFT_ALPHA option. For the LRC functionals, the fraction of long-range; Hartree–Fock and short-range DFA is controlled by the DFT_OMEGA option.; Changing these will override the default behavior of the requested functional.; A brief summa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:15114,simpl,simplest,15114,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,9,['simpl'],['simplest']
Usability,"on'; rlxd 'off'; benchmark; 'HSG0' Faver et al. JCTC 7 790 (2011).; 'HSGA' Marshall et al. JCP 135 194102 (2011). subset; 'small'; 'large'. A24alt¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries from <Reference>.; Reference interaction energies from Rezac and Hobza, JCTC (in press). cp 'off' <erase this comment and after unless on is a valid option> || 'on'; rlxd 'off' <erase this comment and after unless on is valid option> || 'on'; benchmark; '<benchmark_name>' <Reference>.; '<default_benchmark_name>' <Reference>. subset; 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. BAKERJCC93¶. Database of molecules that are challenging to optimize.; Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported; in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002), with a few; further corrections.; No reference energies defined. cp 'off'; rlxd 'off'; subset; 'small'; 'large'. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. S22by5¶. Database (Hobza) of interaction energies for dissociation curves of bimolecular complexes.; Geometries and reference interaction energies from Grafova et al. JCTC 6 2365 (2010).; Note that the S22by5-N-1.0 members are essentially the same geometries as S22-N (there’s trivial round-off error) but the reference interaction energies for S22by5 are of lower quality than those of S22. cp 'off' || 'on'; rlxd 'off'; subset; 'small'; 'large'; 'equilibrium'; 'mol1' five-point (0.9, 1.0, 1.2, 1.5, 2.0) dissociation curve for molecule 1; ...; 'mol22' five-point (0.9, 1.0, 1.2, 1.5, 2.0) dissociation curve for molecule 22. HTR40¶. Database of Hydrogen transfer reactions.; Geometries from Bozkaya and Sherrill.; Reference energies from Bozkaya and Sherrill. benchmark; '<benchmark_name>' <Reference>.; '<default_benchmark_name>' <Reference>. subset",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_available_databases-1.html:7809,simpl,simple,7809,psi4manual/1.0.0/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_available_databases-1.html,4,['simpl'],['simple']
Usability,"on: method set_enable_pybuffer; set_enable_pybuffer(...) unbound psi4.ErfERI method. set_enable_pybuffer( (TwoBodyAOInt)arg1, (bool)arg2) -> None :. docstring; C++ signature :. void set_enable_pybuffer(N3psi12TwoBodyAOIntE {lvalue},b). ExternalPotential¶. psi4.ExternalPotential.addBasis()¶; Python Library Documentation: method addBasis; addBasis(...) unbound psi4.ExternalPotential method. addBasis( (ExternalPotential)arg1, (BasisSet)arg2, (Vector)arg3) -> None :. docstring; C++ signature :. void addBasis(N3psi17ExternalPotentialE {lvalue},N5boost10shared_ptrIN3psi8BasisSetEEE,N5boost10shared_ptrIN3psi6VectorEEE). psi4.ExternalPotential.addCharge()¶; Python Library Documentation: method addCharge; addCharge(...) unbound psi4.ExternalPotential method. addCharge( (ExternalPotential)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -> None :. docstring; C++ signature :. void addCharge(N3psi17ExternalPotentialE {lvalue},d,d,d,d). psi4.ExternalPotential.clear()¶; Python Library Documentation: method clear; clear(...) unbound psi4.ExternalPotential method. clear( (ExternalPotential)arg1) -> None :. docstring; C++ signature :. void clear(N3psi17ExternalPotentialE {lvalue}). psi4.ExternalPotential.computePotentialMatrix()¶; Python Library Documentation: method computePotentialMatrix; computePotentialMatrix(...) unbound psi4.ExternalPotential method. computePotentialMatrix( (ExternalPotential)arg1, (BasisSet)arg2) -> Matrix :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE computePotentialMatrix(N3psi17ExternalPotentialE {lvalue},N5boost10shared_ptrIN3psi8BasisSetEEE). psi4.ExternalPotential.print_out()¶; Python Library Documentation: method print_out; print_out(...) unbound psi4.ExternalPotential method. print_out( (ExternalPotential)arg1) -> None :. docstring; C++ signature :. void print_out(N3psi17ExternalPotentialE {lvalue}). psi4.ExternalPotential.setName()¶; Python Library Documentation: method setName; setName(...) unbound psi4.ExternalPotential",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:135469,clear,clear,135469,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,6,['clear'],['clear']
Usability,"onError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(f""""""CBS gufunc: Too many brackets given! {method_str}""""""). if method_str.count('/') != 1:; raise ValidationError(f""""""CBS gufunc: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def cbs_text_parser(total_method_name: str, **kwargs) -> Dict:; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; total_method_name; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; if ptype",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:39905,simpl,simple,39905,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['simpl'],['simple']
Usability,"onError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(f""""""CBS gufunc: Too many brackets given! {method_str}""""""). if method_str.count('/') != 1:; raise ValidationError(f""""""CBS gufunc: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def cbs_text_parser(total_method_name: str, **kwargs) -> Dict:; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; total_method_name; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.driver.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:40097,simpl,simple,40097,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,4,['simpl'],['simple']
Usability,"on_¶; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. diis(self: psi4.core.HF, arg0: float) → bool¶; docstring. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s te",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:5917,simpl,simply,5917,psi4manual/1.7.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html,2,['simpl'],['simply']
Usability,"one is aware of it; unless cc’d), are brought up at workshops (where people may be absent, no; record is left, and not everyone may have prepared a position on the; topic), or agreed between a couple people over g-chat (others remain; unaware of plans), or planned by someone (who may not have committed those; plans to a ticket or who wants general approval before restructuring the; code). Path of a PsiPEP¶. Someone creates a file doc/sphinxman/source/pepXXXX.rst modeled; on psi4/doc/sphinxman/source/pep0000model.rst and adds; it to STATICDOC in psi4/doc/sphinxman/CMakeLists.txt. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice.; Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down.; Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history).; Once there’s agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include¶. Best practices or re-vamped best practices; Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. Request/present viewpoint on organization; Draw attention to organization needed in code outside one’s area of; expertise. Request interface for some structure (e.g., gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. Fair Warning: Proposal to change things up; Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/pep0001-1.html:1548,simpl,simple,1548,psi4manual/1.4.0/pep0001-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/pep0001-1.html,9,['simpl'],['simple']
Usability,"or otherwise 2-component Hamiltonians.; * ```treatment```: treat extrapolation stage as ```scf``` or ```corl```, by default only the first; stage is ```scf``` and every later one is ```corl```.; * ```stage```: tag for the stage used in tables. The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters; are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters; are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it; is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the; ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:43765,simpl,simple,43765,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['simpl'],['simple']
Usability,"or why atomic commit needed. Collect docs from GHA artifacts. >>> git push --atomic upstream 1.3.x v1.3.1. Initialize release branch¶. follow tagging procedure; before re-engaging the admins “Do not allow …” button, push a branch at the tag commit (not the records commit); >>> git log --online | head -2; 45315cb Records tag for v1.3; 20e5c7e v1.3. >>> git checkout 20e5c7e; >>> git checkout -b 1.3.x; Switched to a new branch '1.3.x'; >>> git push upstream 1.3.x. set up new branch as protected branch through GitHub psi4 org Settings. Should be already covered under 1.*.x rule. Build extra Conda packages for Psi4 channel¶; Once upon a time, “Psi4 stack”, meant packages psi4, psi4-rt, psi4-dev, and psi4-docs.; Package psi4-docs used to be in “Psi4 stack”, but it’s handled by GHA and netlify now, not Conda.; Package psi4-rt used to be in “Psi4 stack”, but a maximum ecosystem package isn’t provided now, only a customizable env spec.; Package psi4-dev used to be in “Psi4 stack”, but now build environment and guidance is in-repo with psi4-path-advisor.py.; Other packages in the “ecosystem stack” (e.g., libint, gdma) should already be updated and; built on conda-forge. Survey them to check version tick PRs have been merged.; Conda-forge overwhelmingly handles the psi4 package itself, with a full architecture and Python; version matrix. What remains are specialty or development builds for the psi4 channel. High AM and multiarch psi4 builds for Linux. Especially at tagged releases, update and reconcile c-f psi4/feedstock recipe with psinet; psi4meta/conda-recipes/psi4-cf recipe. Differences include:. restricted to only even python versions; c-f libint vs. psi4 libint2 packages (latter with high AM); smoke vs. full tests; no git rev-parse lines; load Intel compilers and specify them in compilers and flags CMake arguments. Prepare recipe, make sure psi4-cf is the only target uncommented in kitandkapoodle.py, set; crontab, view in kpd-anom.log.; Files will upload to psi4/label/de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/manage_release.html:13087,guid,guidance,13087,psi4manual/1.9.x/manage_release.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/manage_release.html,2,['guid'],['guidance']
Usability,"orrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. A PSI4 Tutorial; Psithon Tutorial: Using PSI4 as an Executable. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/tutorial.html:23089,clear,clear,23089,psi4manual/1.8.x/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/tutorial.html,1,['clear'],['clear']
Usability,"orrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. A PSI4 Tutorial; Psithon Tutorial: Using PSI4 as an Executable. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/tutorial.html:23089,clear,clear,23089,psi4manual/1.9.x/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/tutorial.html,1,['clear'],['clear']
Usability,"ot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligible errors into the SAPT energy; (often less than 0.01 kcal/mol for small dimers) and greatly; improves efficiency. The S2 approximation and scaling¶; All exchange terms in SAPT arise from the antisymmetrization; of the wavefunctions of monomers A and B. Taking into account exchange of all possible; electron pairs between the two monomers yields to complicated formulae.; For this reason, exchange terms are often evaluated in the ; approximation, that can be interpreted as the exchange of a single electron; pair between monomers.; The approximation is usually pretty good, but may; break down for short intermolecular distance, particularly in high-order; terms. To compensate these deviations, Parker et al. [Parker:2014:094106]; recommend to scale all approximated exchange terms by the ratio:. where the recommended exponent is . To obtain SAPT energies with this scaling,; simply set the keyword exch_scale_alpha true. Alternatively, another value for ; can be specified by setting EXCH_SCALE_ALPHA to a value. For example,; set exch_scale_alpha 1.0. will set and scale exchange energies with .; Instead of this straightforward scaling, SAPT0 energies benefit from a slightly modified; recipe that involves an empirically adjusted exponent .; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]). (8); where is computed without any scaling. Please note that; sSAPT0 is thus not the same as requesting exch_scale_alpha 3.0. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:5031,simpl,simply,5031,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['simpl'],['simply']
Usability,"ottling so the auto-tuning capabilities have a chance; to work. On Linux, this can be tune using; /usr/bin/cpufreq-selector -g performance. cd into the compilation directory and run the source; directory configure script there, with any necessary flags, e.g.,; /usr/local/src/atlas/configure --prefix=/usr/local/atlas. where prefix gives the installation directory.; It should automatically detect if you’re on an x86_64; Then make and check using; make; make check; make ptcheck. And install; make install. Compilation notes for netlib’s LAPACK; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full LAPACK installation notes.; You’ll need a Fortran compiler installed.; If you decide to compile LAPACK from source, it may be obtained from; http://www.netlib.org/lapack/. Unpack the source code, and in the; top-level source directory, you need to create a make.inc file with; the appropriate options for your machine. For Linux/gfortran,; simply; cp make.inc.example make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library; (full pathnames are recommended):; BLASLIB = /home/david/software/atlas3.9.25/lib/libf77blas.a /home/david/software/atlas3.9.25/lib/libatlas.a. Edit Makefile as necessary (probably not needed).; make. Copy the resulting file [lapack_($ARCH).a] where you want it; (a standard location like /usr/local/lib is easier for PSI to find).; It is probably helpful to rename the file liblapack.a. V. Miscellaneous Architecture-Specific Notes¶. Linux on x86 and x86_64; Intel compilers: We had trouble with icpc 12.0.x. Use 12.1 or; later. VI. Common Problems with PSI Compilation¶. No rule to make target foo.h, needed by bar.d. Stop.; This commonly happens after pulling updates from the repository. It happens; when a library header file is removed or renamed by the update, but there are; still old dependency files in the object directory, which think that they; still need to know about that header. T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:25318,simpl,simply,25318,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,3,['simpl'],['simply']
Usability,"outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html:4620,clear,clear,4620,psi4manual/1.4.0/prog_ways_to_add-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html,9,['clear'],['clear']
Usability,"ow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed project can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at a tested commit/version number so their; development may be ongoing.; communicate with us when they’ve made improvements and minted; a new tag. In return, for Add-Ons the PSI4 project will:. leave control of their code under your purview.; maintain any interfacing code needed.; regularly run integration tests between PSI4 and your code.; build a mostly statically linked conda package so that any; of your users can obtain a pre-built binary distribution through; conda install addon --channel psi4.; provide a development sandbox for your code through PSI4 plugins.; provide conda download counts independent of PSI4. How to name keywords in psi4/src/read_options.cc¶; A few guidelines for standardizing option names among modules. TRIPLES (not trip), TRIPLETS (not trip), SINGLES (not sing),; SINGLETS (not sing); CONVERGENCE (not conv, not converge) and TOLERANCE (not tol); Convergence of a method should be governed by an E_CONVERGENCE for; energy and either a D_CONVERGENCE for density or a R_CONVERGENCE; for residual/amplitudes. All of these should be doubles- let the input; parser handle the flexible input format.; Diis should have a boolean DIIS (not do_diis, not use_diis) to turn; on/off diis extrapolation, a DIIS_MIN_VECS and DIIS_MAX_VECS for; minimum and maximum number of diis vectors to use, and a DIIS_START; which is the iteration at which to start saving vectors for diis. Not all; modules conform to all these at present, but they’re as standardized as; they can be without changing code.; AMPS (not amplitude, not amp) for amplitudes; NUM_ (not n) for number (e.g., NUM_AMPS_PRINT, MAX_NUM_VECS,; NUM_THREADS); Some names that could be split into multiple words are staying ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/manage_addon-1.html:6201,guid,guidelines,6201,psi4manual/1.4.0/manage_addon-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/manage_addon-1.html,9,['guid'],['guidelines']
Usability,"ow us to contribute some CMake files to your build system; so that compile flags and dependencies (e.g., BLAS/LAPACK) can be; consistent with the PSI4 build and so the installed project can; be readily detected by PSI4 or any interested party (through a; CMake imported target).; provide us a tag at a tested commit/version number so their; development may be ongoing.; communicate with us when they’ve made improvements and minted; a new tag. In return, for Add-Ons the PSI4 project will:; leave control of their code under your purview.; maintain any interfacing code needed.; regularly run integration tests between PSI4 and your code.; build a mostly statically linked conda package so that any; of your users can obtain a pre-built binary distribution through; conda install addon --channel psi4.; provide a development sandbox for your code through PSI4 plugins.; provide conda download counts independent of PSI4. How to name keywords in psi4/src/read_options.cc¶; A few guidelines for standardizing option names among modules. TRIPLES (not trip), TRIPLETS (not trip), SINGLES (not sing),; SINGLETS (not sing); CONVERGENCE (not conv, not converge) and TOLERANCE (not tol); Convergence of a method should be governed by an E_CONVERGENCE for; energy and either a D_CONVERGENCE for density or a R_CONVERGENCE; for residual/amplitudes. All of these should be doubles- let the input; parser handle the flexible input format.; Diis should have a boolean DIIS (not do_diis, not use_diis) to turn; on/off diis extrapolation, a DIIS_MIN_VECS and DIIS_MAX_VECS for; minimum and maximum number of diis vectors to use, and a DIIS_START; which is the iteration at which to start saving vectors for diis. Not all; modules conform to all these at present, but they’re as standardized as; they can be without changing code.; AMPS (not amplitude, not amp) for amplitudes; NUM_ (not n) for number (e.g., NUM_AMPS_PRINT, MAX_NUM_VECS,; NUM_THREADS); Some names that could be split into multiple words are staying ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/manage_addon-1.html:6194,guid,guidelines,6194,psi4manual/1.2.1/manage_addon-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/manage_addon-1.html,4,['guid'],['guidelines']
Usability,"ows is a very basic description of the practical differences in; the equations that define each of the coupled-pair methods implemented in; PSI4. We begin with the CISD wave function. (3); where we have chosen the intermediate normalization, . The CISD correlation energy is given by. (4); and the amplitudes can be determined by the solution to the coupled set of; eqations:. (5); The CISD method is not size-extensive, but this problem can be overcome by; making very simple modifications to the amplitude equations. We replace; the correlation energy, , with generalized shifts for the; doubles and singles equations, and :. (6); These shifts approximate the effects of triple and quadruple excitations.; The values for and used in several; coupled-pair methods are given in Table CEPA Shifts. Note that these shifts are defined in a spin-free; formalism for closed-shell references only. method. sdci. dci. NA. cepa(0); 0; 0. cepa(1). cepa(3). acpf. aqcc. The pair correlation energy, , is simply a partial; sum of the correlation energy. In a spin-free formalism, the pair energy; is given by. (7); Methods whose shifts ( and ) do not; explicitly depend on orbitals or (CISD, CEPA(0), ACPF,; and AQCC) have solutions that render the energy stationary with respect; variations in the amplitudes. This convenient property allows density; matrices and 1-electron properties to be evaluated without any additional; effort. Note, however, that 1-electron properties are currently; unavailable when coupling these stationary CEPA-like methods with frozen; natural orbitals. Density-fitted coupled cluster¶; Density fitting (DF) [or the resolution of the identity (RI)] and Cholesky; decomposition (CD) techniques are popular in quantum chemistry to avoid; the computation and storage of the 4-index electron repulsion integral; (ERI) tensor and even to reduce the computational scaling of some terms.; DF/CD-CCSD(T) computations are available in PSI4, with or without the; use of FNOs, through the FNOC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/fnocc-1.html:7083,simpl,simply,7083,psi4manual/4.0b5/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/fnocc-1.html,2,['simpl'],['simply']
Usability,"ows is a very basic description of the practical differences in; the equations that define each of the coupled-pair methods implemented in; PSI4. We begin with the CISD wave function. (3); where we have chosen the intermediate normalization, . The CISD correlation energy is given by. (4); and the amplitudes can be determined by the solution to the coupled set of; eqations:. (5); The CISD method is not size-extensive, but this problem can be overcome by; making very simple modifications to the amplitude equations. We replace; the correlation energy, , with generalized shifts for the; doubles and singles equations, and :. (6); These shifts approximate the effects of triple and quadruple excitations.; The values for and used in several; coupled-pair methods are given in Table CEPA Shifts. Note that these shifts are defined in a spin-free; formalism for closed-shell references only. method. sdci. dci. NA. cepa(0); 0; 0. cepa(1). cepa(3). acpf. aqcc. The pair correlation energy, , is simply a partial; sum of the correlation energy. In a spin-free formalism, the pair energy; is given by. (7); Methods whose shifts ( and ) do not; explicitly depend on orbitals or (CISD, CEPA(0), ACPF,; and AQCC) have solutions that render the energy stationary with respect; variations in the amplitudes. This convenient property allows density; matrices and 1-electron properties to be evaluated without any additional; effort. Note, however, that 1-electron properties are currently; unavailable when coupling these stationary CEPA-like methods with frozen; natural orbitals. Density-fitted coupled cluster¶; Density fitting (DF) or resolution of the identity (RI) techniques are; popular in quantum chemistry to avoid the computation and storage of the; 4-index electron repulsion integral (ERI) tensor and even to reduce the; computational scaling of some terms. DF-CCSD(T) computations are; available in PSI4, with or without the use of FNOs, through the FNOCC; module. The implementation and accuracy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/fnocc-1.html:7045,simpl,simply,7045,psi4manual/4.0b4/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/fnocc-1.html,2,['simpl'],['simply']
Usability,"p ./temp /scratch/parrish/psi.12345.h2o.32; copy_file_to_scratch(‘/tmp/temp’, ‘psi’, ‘h2o’, 32):; -cp /tmp/temp /scratch/parrish/psi.12345.h2o.32; copy_file_to_scratch(‘/tmp/temp’, ‘psi’, ‘’, 32):; -cp /tmp/temp /scratch/parrish/psi.12345.32; copy_file_to_scratch(‘/tmp/temp’, ‘psi’, ‘’, 32, True):; -mv /tmp/temp /scratch/parrish/psi.12345.32. get_memory()[source]¶; Function to return the total memory allocation. get_num_threads()[source]¶; Function to return the number of threads to parallelize across. set_memory(bytes)[source]¶; Function to reset the total memory allocation. set_num_threads(nthread)[source]¶; Function to reset the number of threads to parallelize across. success(label)[source]¶; Function to print a ‘label...PASSED’ line to screen.; Used by util.compare_values() family when functions pass. aliases¶; Module with functions that call upon those in modules; proc, driver, and wrappers. Place in this file quickly defined procedures such as. aliases for complex methods; simple modifications to existing methods. run_mp2_5(name, **kwargs)[source]¶; Function that computes MP2.5 energy from results of a DETCI; MP3 calculation. Psi variables:. MP2.5 TOTAL ENERGY; MP2.5 CORRELATION ENERGY. >>> energy('mp2.5'). run_plugin_omega(name, **kwargs)[source]¶; Function encoding sequence of PSI module and plugin calls, as well; as typical options, to access Rob Parrish’s omega plugin.; >>> energy('plugin_omega'). sherrillgroup_gold_standard(name='mp2', **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluateo; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> energy('sherrillgroup_gold_standard'). Table Of Contents. Python Driver; input; pubchem; psiexceptions; frac; molutil; proc; procutil; driver; physconst; wrappers; qmmm; functional; text; util; aliases. Previous topic; PRINT; Next topic; PsiMod: L",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:22784,simpl,simple,22784,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,2,['simpl'],['simple']
Usability,"parameter :math’:A:. \[\widehat{H}^{(0)}_\text{REMP} = (1-A)\widehat{H}^{(0)}_\text{RE} + A\widehat{H}^{(0)}_\text{MP}\]; Technically, the second order of RE corresponds to LCCD for RHF and UHF references. REMP2 and its orbital-optimized variant OREMP2; are thus straightforward to implement in a (O)LCCD program by appropriate scaling of residual vector contributions and density matrices. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]; OREMP2 [Behnle:2021:OREMP], and [Behnle:2022:OREMP]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals, simply set reference rohf. For DFT orbitals, set reference uks and set dft_functional b3lyp. Of; course users can use any DFT functional available in PSI4. Methods¶; The various orbital-optimized methods supported by the OCC/DFOCC; modules in PSI4 are summarized in Table OCC OO; Methods and detailed in Table OCC; OO Capabilities. Note that while two; separate libraries OCC (conventional integrals CONV) and DFOCC; (density-fitted DF and Cholesky-decomposed CD) together provide; the methods described on this page, they are controlled through one; QC_MODULE value OCC. Without set qc_module occ,; these methods may default to implementations in other modules based on efficiency considerations. Orbital-optimized theoretical methods accessible through OCC/DFOCC¶. name; calls method; OO. omp2; orbital-optimized second-order MP perturbation theory; E/G. omp2.5; orbital-optimized average of MP2 and MP3; E/G. omp3; orbital-optimized third-order MP perturbation theory; E/G. oremp2; orbital-opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/occ.html:9551,simpl,simply,9551,psi4manual/1.7.x/occ.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/occ.html,4,['simpl'],['simply']
Usability,"pass; else:; break. return modobj. _modules = [; # Psi4 Modules; ""CCENERGY"",; ""CCEOM"",; ""CCDENSITY"",; ""CCLAMBDA"",; ""CCHBAR"",; ""CCRESPONSE"",; ""CCTRANSORT"",; ""CCTRIPLES"",; ""CPHF"",; ""DCT"",; ""DETCI"",; ""DFEP2"",; ""DFMP2"",; ""DFOCC"",; ""DLPNO"",; ""DMRG"",; ""EFP"",; ""FINDIF"",; ""FISAPT"",; ""FNOCC"",; ""GDMA"",; ""MCSCF"",; ""MINTS"",; ""MRCC"",; ""OCC"",; ""OPTKING"",; ""PCM"",; ""PE"",; ""PSIMRCC"",; ""RESPONSE"",; ""SAPT"",; ""SCF"",; ""THERMO"",; # External Modules; ""CFOUR"",; ]. [docs]; @contextmanager; def hold_options_state() -> Iterator[None]:; """"""Return a context manager that will collect the current state of; ``Process:environment.options`` on entry to the with-statement and clear; and restore the collected keywords state when exiting the with-statement. """"""; pofm = prepare_options_for_modules(; changedOnly=True, commandsInsteadDict=False, globalsOnly=False, stateInsteadMediated=True; ); yield; _reset_pe_options(pofm). def _reset_pe_options(pofm: Dict):; """"""Acts on ``Process::environment.options`` to clear it, then set it to; state encoded in `pofm`. Parameters; ----------; pofm; Result of :py:func:`prepare_options_for_modules` with; ``changedOnly=True``, ``commandsInsteadDict=False``, and; ``stateInsteadMediated=True``. """"""; core.clean_options(). for go, dgo in pofm['GLOBALS'].items():; if dgo['has_changed']:; core.set_global_option(go, dgo['value']). for module in _modules:; for lo, dlo in pofm[module].items():; if dlo['has_changed']:; core.set_local_option(module, lo, dlo['value']). ## this is a more defensive version if defaults may have changed; # for go, dgo in pofm['GLOBALS'].items():; # core.set_global_option(go, dgo['value']); # if not dgo['has_changed']:; # core.revoke_global_option_changed(go); # for module in _modules:; # for lo, dlo in pofm[module].items():; # core.set_local_option(module, lo, dlo['value']); # if not dlo['has_changed']:; # core.revoke_local_option_changed(module, lo). [docs]; def prepare_options_for_modules(; changedOnly: bool = False,; commandsInsteadDict: bool = False,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:10079,clear,clear,10079,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,3,['clear'],['clear']
Usability,"pe; str. numeric¶; Whether data is numeric. Pass True to disable validating data as float/Decimal/np.ndarray. Type; bool. class qcelemental.models.types.Array[source]¶. qcelemental.molutil.B787(cgeom, rgeom, cuniq, runiq, do_plot=False, verbose=1, atoms_map=False, run_resorting=False, mols_align=False, run_to_completion=False, algorithm='hungarian_uno', uno_cutoff=0.001, run_mirror=False)[source]¶; Use Kabsch algorithm to find best alignment of geometry cgeom onto; rgeom while sampling atom mappings restricted by runiq and cuniq. Parameters. rgeom (ndarray) – (nat, 3) array of reference/target/unchanged geometry. Assumed [a0]; for RMSD purposes.; cgeom (ndarray) – (nat, 3) array of concern/changeable geometry. Assumed [a0] for RMSD; purposes. Must have same nat, units, and atom content as rgeom.; runiq (ndarray) – (nat,) array of str indicating which rows (atoms) in rgeom are shuffleable; without changing the molecule. Generally hashes of element symbol and; mass are used, but could be as simple as [‘C’, ‘H’, ‘H’, ‘D’, ‘H’] for; monodeuterated methane.; cuniq (ndarray) – (nat,) array of str indicating which rows (atoms) in cgeom are shuffleable.; See runiq for more details. Strings and count in cuniq must match; runiq. That is, sorted(cuniq) == sorted(runiq).; do_plot (bool) – Pops up a mpl plot showing before, after, and ref geometries.; verbose (int) – Quantity of printing. 0 to silence.; atoms_map (bool) – Whether atom1 of rgeom already corresponds to atom1 of cgeom and so on.; If True, no resorting will be run, parameters runiq and cuniq; may be passed as None, and much time will be saved.; run_resorting (bool) – Run the resorting machinery even if unnecessary because atoms_map=True.; mols_align (Union[bool, float]) – Whether ref_mol and concern_mol have identical geometries by eye; (barring orientation or atom mapping) and expected final RMSD = 0.; If True, procedure is truncated when RMSD condition met, saving time.; If float, convcrit at which search for mini",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external_apis-1.html:2895,simpl,simple,2895,psi4manual/1.4.0/external_apis-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external_apis-1.html,5,['simpl'],['simple']
Usability,"pl_highest_1` otherwise. :type delta4_scheme: function; :param delta4_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta4_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta5_scheme: function; :param delta5_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta5_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correcti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:27916,simpl,simple,27916,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,2,['simpl'],['simple']
Usability,"place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fragmented. Advanced Python¶; A named molecule in an input file is a full-fledged instance of the; powerful C++ Molecule class. Thus, all member; functions (that have been exp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html:14892,simpl,simple,14892,psi4manual/1.0.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html,2,['simpl'],['simple']
Usability,"place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:16696,simpl,simple,16696,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['simpl'],['simple']
Usability,"ple UHF/6-31G** CH2 computation. memory 250 mb. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:4880,simpl,simple,4880,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,6,['simpl'],['simple']
Usability,"ple UHF/6-31G** CH2 computation. memory 250 mb. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92534160932308. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt.; #! Optimize H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After about 4 cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation), the energy decreases with each step,; and the maximum force on eac",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:4052,simpl,simple,4052,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,4,['simpl'],['simple']
Usability,"plex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; set globals basis cc-pVDZ. or. set basis cc-pVDZ. or. set globals basis = cc-pVDZ. or. set basis = cc-pVDZ. or. set globals{; basis cc-pVDZ; }. or. set {; basis cc-pVDZ; }. or. set {; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html:14760,simpl,simply,14760,psi4manual/4.0b3/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html,2,['simpl'],['simply']
Usability,"plex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule{; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value. Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; set globals basis cc-pVDZ. or. set basis cc-pVDZ. or. set globals basis = cc-pVDZ. or. set basis = cc-pVDZ. or. set globals{; basis cc-pVDZ; }. or. set{; basis cc-pVDZ; }. or. set{; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple k",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:14190,simpl,simply,14190,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,2,['simpl'],['simply']
Usability,"plot as plt. Nweft = 1; positions = range(-1, -1 * Nweft - 1, -1). # initialize plot; fig, ax = plt.subplots(figsize=(12, 0.33)); plt.xlim([-xlimit, xlimit]); plt.ylim([-1 * Nweft - 1, 0]); plt.yticks([]); plt.xticks([]); # fig.patch.set_visible(False); # ax.patch.set_visible(False); ax.axis('off'). for xl in xlines:; plt.axvline(xl, color='grey', linewidth=4); if xl != 0.0:; plt.axvline(-1 * xl, color='grey', linewidth=4). # plot reaction errors and threads; for rxn in data:; xvals = rxn['data']; clr = segment_color(color, rxn['color'] if 'color' in rxn else None). ax.plot(xvals, positions, '|', color=clr, markersize=13.0, mew=4). # plot trimmings; if mae is not None:; plt.axvline(-1 * mae, color='black', linewidth=12); if mape is not None: # equivalent to MAE for a 10 kcal/mol interaction energy; ax.plot(0.025 * mape, positions, 'o', color='black', markersize=15.0). # save and show; pltuid = title # simple (not really unique) filename for LaTeX integration; pltfile = expand_saveas(saveas, pltuid, def_prefix='flat_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight',; frameon=False, pad_inches=0.0); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close() # give this a try; return files_saved. #def mpl_distslat_multiplot_files(pltfile, dbid, dbname, xmin, xmax, mcdats, labels, titles):; # """"""Saves a plot with basename *pltfile* with a slat representation; # of the modelchems errors in *mcdat*. Plot is in PNG, PDF, & EPS; # and suitable for download, no mouseover properties. Both labeled; # and labelless (for pub) figures are constructed.; #; # """"""; # import matplotlib as mpl; # from matplotlib.axes import Subplot; # import sapt_colors; # from matplotlib.figure import Figure; #; # nplots = len(mcdats); # fht = nplots * 0.8; # fig, axt = plt.subplots(figsize=(12.0, fht)); # plt.subplots_adjust(left=0.01, right=0.99, hspace=0.3); #",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:5848,simpl,simple,5848,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['simpl'],['simple']
Usability,"polation scheme to be applied to the second delta correction; to the correlation energy. :type delta3_scheme: function; :param delta3_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. :type delta4_scheme: function; :param delta4_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. :type delta5_scheme: function; :param delta5_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:61860,simpl,simple,61860,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['simpl'],['simple']
Usability,"pretty good, but may; break down for short intermolecular distance, particularly in high-order; terms. To compensate these deviations, Parker et al. [Parker:2014:094106]; recommend to scale all approximated exchange terms by the ratio:. where the recommended exponent is . To obtain SAPT energies with this scaling,; simply set the keyword exch_scale_alpha true. Alternatively, another value for ; can be specified by setting EXCH_SCALE_ALPHA to a value. For example,; set exch_scale_alpha 1.0. will set and scale exchange energies with .; Instead of this straightforward scaling, SAPT0 energies benefit from a slightly modified; recipe that involves an empirically adjusted exponent .; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]). (8); where is computed without any scaling. Please note that; sSAPT0 is thus not the same as requesting exch_scale_alpha 3.0. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard Psi4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:5673,simpl,simplest,5673,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['simpl'],['simplest']
Usability,"profile (Mac) file; unset PSIDATADIR; export PATH={prefix}/bin:$PATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. Run PSI4 as executable.; >>> cat sample.in; molecule {; He; }; energy('hf/cc-pvdz'); compare_values(-2.85518839, get_variable('current energy'), 5, 'SCF E'); >>> psi4 sample.in; SCF E.............................................................PASSED. or Run PSI4 as Python module.; >>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable after compilation using driver from source¶; When developing python driver code, it can be annoying to keep makeing to test the code. PSI4 can be run “inplace” through the; following procedure. To be clear, this is running compiled C++ from the; build directory and python from the source directory. This is an expert; option for development, and not all functionality will be available.; >>> cd {objdir}; >>> ln -s {top-level-psi4-dir}/{objdir}/stage/lib/psi4/core.cpython-{ext_will_vary}.so ../psi4/core.cpython-{ext_will_vary}.so; >>> python ../psi4/run_psi4.py --inplace input.dat. Why not to set PSIDATADIR¶; PSIDATADIR is an environment variable containing the location of the; text resource parts of the PSI4 codebase (e.g., basis sets,; databases, EFP fragments). It is for developer use only. In PSI4 1.1; and beyond, the program always knows where its resources are, and the; only reason to set this variable is to point to another location.; Previously in PSI4 1.0 and previous, only installed executables knew; the location, so it always needed to be explicitly set when run from the; compilation directory.; At runtime; >>> psi4 -p {top-level-psi4-dir}/psi4/share/psi4. Or in the shell; # csh, tcsh: add to shell or ~/.tcshrc file; s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:31024,clear,clear,31024,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,9,['clear'],['clear']
Usability,"provides a very simple mechanism; for doing so: simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible \(M_s\) value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html:15072,simpl,simply,15072,psi4manual/1.4.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html,6,['simpl'],['simply']
Usability,"published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. """"""; import math; import copy; from vecutil import *; from exceptions import *. [docs]class CoordValue(object):; """"""An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. """""". def __init__(self, fixed=False, computed=False):; # Fixed coordinate?; self.PYfixed = fixed; # Whether the current value is up to date or not; self.computed = computed. [docs] def set_fixed(self, fixed):; """"""Set whether the coordinate value is fixed or not""""""; self.PYfixed = fixed. [docs] def fixed(self):; """"""Get whether the coordinate value is fixed or not""""""; return self.PYfixed. [docs] def invalidate(self):; """"""Flag the current value as outdated""""""; self.computed = False. [docs] def everything(self):; print '\nCoordValue\n Fixed = %s\n Computed = %s\n\n' % (self.PYfixed, self.computed). [docs]class NumberValue(CoordValue):; """"""Specialization of CoordValue that is simply a number to be stored."""""". def __init__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html:1454,simpl,simplifying,1454,psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintscoordentry.html,1,['simpl'],['simplifying']
Usability,"putations; are controlled through the keywords NAT_ORBS and; OCC_TOLERANCE, or by prepending a valid method name with “fno” in; the energy call as; energy('fno-ccsd(t)'). If you wish to specify the number of active natural orbitals manually, use; the keyword ACTIVE_NAT_ORBS. This keyword will override the; keyword OCC_TOLERANCE. QCISD(T), CCSD(T), MP4, and CEPA¶; The FNOCC module in PSI4 supports several related many-body quantum; chemistry methods, including the CCSD(T) and QCISD(T) methods, several; orders of many-body perturbation theory (MP2-MP4), and a family methods; related to the coupled electron pair approximation (CEPA). Quadratic configuration interaction and coupled cluster¶; The quadratic configuration interaction singles doubles (QCISD) method of; Pople, Head-Gordon, and Raghavachari [Pople:1987:5968] was originally; presented as a size-consistent extension of configuration interaction; singles doubles (CISD). The method can also be obtained as a; simplified version of the coupled cluster singles doubles (CCSD); method [Purvis:1982]. Consider the set of equations defining CCSD:. (1)¶\[\begin{split}\langle \Psi_0 | (H - E) (1 + T_1 + T_2 + \frac{1}{2}T_1^2)|\Psi_0\rangle = 0, \\; \langle \Psi_i^a | (H - E) (1 + T_1 + T_2 + \frac{1}{2}T_1^2+T_1T_2+\frac{1}{3!}T_1^3)|\Psi_0\rangle = 0, \\; \langle \Psi_{ij}^{ab} | (H - E) (1 + T_1 + T_2 + \frac{1}{2}T_1^2 + T_1T_2+\frac{1}{3!}T_1^3+\frac{1}{2}T_2^2+\frac{1}{2}T_1^2T_2+\frac{1}{4!}T_1^4)|\Psi_0\rangle = 0, \\\end{split}\]; where we have chosen the intermediate normalization,; \(\langle \Psi_0| \Psi \rangle = 1\), and the symbols \(T_1\); and \(T_2\) represent single and double excitation operators. The; QCISD equations can be obtained by omitting all but two terms that; are nonlinear in \(T_1\) and \(T_2\):. (2)¶\[\begin{split}\langle \Psi_0 | (H - E) (1 + T_1 + T_2)|\Psi_0\rangle = 0, \\; \langle \Psi_i^a | (H - E) (1 + T_1 + T_2 + T_1T_2)|\Psi_0\rangle = 0, \\; \langle \Psi_{ij}^{ab} | (H - E) (1 + T_1 +",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:3478,simpl,simplified,3478,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,9,['simpl'],['simplified']
Usability,"putations; are controlled through the keywords NAT_ORBS and; OCC_TOLERANCE, or by prepending a valid method name with “fno” in; the energy call as; energy('fno-ccsd(t)'). If you wish to specify the number of active natural orbitals manually, use; the keyword ACTIVE_NAT_ORBS. This keyword will override the; keyword OCC_TOLERANCE. QCISD(T), CCSD(T), MP4, and CEPA¶; The FNOCC module in Psi4 supports several related many-body quantum; chemistry methods, including the CCSD(T) and QCISD(T) methods, several; orders of many-body perturbation theory (MP2-MP4), and a family methods; related to the coupled electron pair approximation (CEPA). Quadratic configuration interaction and coupled cluster¶; The quadratic configuration interaction singles doubles (QCISD) method of; Pople, Head-Gordon, and Raghavachari [Pople:1987:5968] was originally; presented as a size-consistent extension of configuration interaction; singles doubles (CISD). The method can also be obtained as a; simplified version of the coupled cluster singles doubles (CCSD); method [Purvis:1982]. Consider the set of equations defining CCSD:. (1); where we have chosen the intermediate normalization,; , and the symbols ; and represent single and double excitation operators. The; QCISD equations can be obtained by omitting all but two terms that; are nonlinear in and :. (2); QCISD is slightly cheaper that CCSD computationally, but it retains the; complexity of the original equations. Just as in; the familiar CCSD(T) method, the effects of connected triple excitations; may be included noniteratively to yield the QCISD(T) method. Both the; QCISD(T) and CCSD(T) methods are implemented for closed-shell references; in the FNOCC module. Many-body perturbation theory¶; QCI and CC methods are closely related to perturbation theory, and the; MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/fnocc-1.html:3381,simpl,simplified,3381,psi4manual/1.0.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/fnocc-1.html,2,['simpl'],['simplified']
Usability,"quotify(string, isbasis=False)[source]¶; Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. When basis; is True, allows commas, since basis sets may have commas and are assured to; not involve arrays. driver_nbody¶. nCr(n, r)[source]¶. driver_cbs¶. return_energy_components()[source]¶. driver¶; Module with a procedures dictionary specifying available quantum; chemical methods and functions driving the main quantum chemical; functionality, namely single-point energies, geometry optimizations,; properties, and vibrational frequency calculations. wrapper_autofrag¶. auto_fragments(**kwargs)[source]¶; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. Returns:Molecule) – fragmented molecule. Parameters:molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> molecule mol {\nH 0.0 0.0 0.0\nH 2.0 0.0 0.0\nF 0.0 1.0 0.0\nF 2.0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefunction density. fitScf()[source]¶; Function to run scf and fit a system of diffuse charges to; resulting density. populateExtern(extern)[source]¶. class QMMM[source]¶. addChargeAngstrom(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]¶; Function to add a diffuse charge field diffuse. populateExtern()[source]¶; Function to define a charge field external to the; mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:8533,simpl,simple,8533,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['simpl'],['simple']
Usability,"r SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. iteration_energies = []¶. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. diis(self: psi4.core.HF, arg0: float) → bool¶; docstring. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s te",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html:5965,simpl,simply,5965,psi4manual/1.9.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html,1,['simpl'],['simply']
Usability,"r SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. iteration_energies = []¶. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: list[psi4.core.Matrix]) → list[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: list[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → list[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. diis(self: psi4.core.HF, arg0: float) → bool¶; docstring. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s te",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.HF.html:5972,simpl,simply,5972,psi4manual/master/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html,1,['simpl'],['simply']
Usability,"r as size-extensive modifications; of truncated configuration interaction (CI) theory. The methods have the same complexity as CI; with single and double excitations (CISD), and solving the CISD or coupled-pair equations requires; fewer floating point operations than solving the CC with singles and doubles (CCSD) equations. CISD,; CCSD, and the coupled-pair methods discussed below all scale formally with the sixth power of system size. For a; detailed discussion of the properties of various coupled-pair methods, see Ref. [Wennmohs:2008].; What follows is a very basic description of the practical differences in the equations that define each of the; coupled-pair methods implemented in PSI4. We begin with the CISD wave function. (1); where we have chosen the intermediate normalization, .; The CISD correlation energy is given by. (2); and the amplitudes can be determined by the solution to the coupled set of eqations:. (3); The CISD method is not size-extensive, but this problem can be overcome by making very simple modifications to the amplitude; equations. With malice and forethought, we replace the correlation energy, , with generalized shifts for; the doubles and singles equations, and :. (4); These shifts approximate the effects of triple and quadruple excitations.; The values for and used in several coupled-pair methods are given in Table; CEPA Shifts. Note that these shifts are defined in a spin-free formalism; for closed-shell references only. method. sdci. dci. NA. cepa(0); 0; 0. cepa(1). cepa(3). acpf. aqcc. The pair correlation energy, , is simply a partial sum of the correlation energy. In a spin-free formalism,; the pair energy is given by. (5); Methods whose shifts ( and ) do not explicitly depend on orbitals or ; (CISD, CEPA(0), ACPF, and AQCC); have solutions that render the energy stationary with respect variations in the amplitudes. This convenient property allows; density matrices and 1-electron properties to be evaluated without any additional effor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cepa-1.html:1421,simpl,simple,1421,psi4manual/4.0b3/cepa-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cepa-1.html,2,['simpl'],['simple']
Usability,"r location, say /scratch/user, add the following command to your input; file:; psi4_io.set_default_path('/scratch/user'). For batch jobs running through a queue, it might be more convenient to use an; environmental variable (in this case $MYSCRATCH) to set the scratch directory;; the following code will do that:; import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). Individual files can be sent to specific locations. For example, file 12; contains information about the internal coordiantes of a geometry optimization.; The user may want to retain this in the working directory; (i.e., where PSI4 was launched from) to analyze the optimization. This is; accomplished by the commands below:; psi4_io.set_specific_path(12, './'); psi4_io.set_specific_retention(12, True). # equivalent to above; psi4_io.set_specific_path(PSIF_INTCO, './'); psi4_io.set_specific_retention(PSIF_INTCO, True). A guide to the contents of individual scratch files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously. Elementary Restart¶; The PSI4 intermediate files use the following naming scheme; psi.PID.name.filenumber. where by default, PID is the process number, name the name of the molecule,; and filenumber is listed in content.; For those modules providing restart capabilities, the previous file can; be provided through the``restart_file`` option; energy('scf',restart_file='./psi.PID.name.filenumber'). Only the filenumber is necessary for the driver to appropriately rename the; file and copy it to the scratch directory where PSI4 will expect it.; The restart capabilities of a specific method (if any) are found in that method’s documentation.; To provide multiple files, pass them as arguments",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:6913,guid,guide,6913,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,9,['guid'],['guide']
Usability,"r of irreps. np; View without only one irrep. classmethod np_read(filename, prefix=''); Reads the data from a NumPy compress file. np_write(filename=None, prefix=''); Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph; View with irreps. print_out(self: psi4.core.Vector) → None; Prints the vector to the output file. scale(self: psi4.core.Vector, sc: float) → None; Scales the elements of a vector by sc. set(*args, **kwargs); Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None; Set a vector block. shape; Shape of the Psi4 data object. to_array(copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.vector.html:7767,simpl,simply,7767,psi4manual/1.2.1/api/psi4.core.vector.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.vector.html,1,['simpl'],['simply']
Usability,"r this example has the acetylene perpendicular to; the ethylene, with the acetylene hydrogen pointing directly at the double bond in ethylene; this will be attractive because the H atoms in acetylene bear a partial positive charge, while the electron rich double bond in ethylene bears a partial negative charge. At the same time, the dispersion interaction should be smaller because the perpendicular geometry does not allow much overlap between the monomers. Hence, the SAPT analysis helps clarify (and quantify) our physical understanding about the; interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as computing the interaction energy between two neon atoms at various interatomic distances. One simple but unappealing way to do this is to generate separate geometries for each distance to be studied. Instead, we can leverage Python loops and string formatting to make our lives simpler. Additionally, let’s suppose you want to do counterpoise (CP) correction to compute interaction energies. Counterpoise correction involves; computing the dimer energy and then subtracting out the energies of the two monomers, each evaluated in the dimer basis. Again, each of these computations could be run in a separate input file, but because counterpoise correction is a fairly standard procedure for intermolecular interactions, Psi4 knows about it and has a built-in routine to perform counterpoise correction. It only needs to know what method you want to do the couterpoise correction on (here, let’s consider CCSD(T)), and it needs; to know what’s monomer A and what’s monomer B. This last issue of specifying the monomers separately was already dealt with in the previous SAPT example, where we saw that two dashes in the psi4.geometry() string can",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:17307,simpl,simple,17307,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,11,['simpl'],['simple']
Usability,"r where k is determined by MAX_NUM_VECS ? For open-shell systems REFERENCE is ROHF, WFN is ZAPTN), DETCI will compute the ZAPTn series. GUESS_VECTOR must be set to UNIT, HD_OTF must be set to TRUE, and HD_AVG must be set to orb_ener; these should happen by default for MPN = TRUE. Type: boolean; Default: false. For larger computations, additional keywords may be required, as; described in the DETCI section of the Appendix DETCI. Arbitrary Order Perturbation Theory¶; The DETCI module is capable of computing energies for arbitrary; order Møller–Plesset perturbation theory (MPn, for closed-shell; systems with an RHF reference) and for Z-averaged perturbation theory; (ZAPTn, open-shell systems with a ROHF reference). However, please; note that these computations are essentially doing high-order CI (up to; full CI) computations to obtain these results, and hence they will only; be possible for very small systems (generally a dozen electrons or less).; The simplest way to run high-order perturbation theory computations is to; call, e.g., energy('mp10') to invoke a MP10 computation or; energy('zapt25') to invoke a ZAPT25 computation. This will; automatically set several additional user options to their appropriate; values. The program uses the Wigner (2n+1) rule to obtain higher-order; energies from lower-order wavefunctions.; For the interested reader, the additional user options that are; automatically set up by the calls above are as follows. A call like; energy('mp10') sets MPN to TRUE.; The program uses the Wigner (2n+1) rule by default; (MPN_WIGNER = TRUE); and figures out what order of wavefunction is; necessary to reach the desired order in the energy. The program then; sets MAX_NUM_VECS to the required order in the; wavefunction.; By default, the requested n-th order energy is saved as the current; energy to the process environment. ZAPTN works essentially the same; way for an ROHF reference. Arbitrary Order Coupled-Cluster Theory¶; This DETCI-based version of this ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/detci-1.html:10575,simpl,simplest,10575,psi4manual/1.2.1/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/detci-1.html,6,['simpl'],['simplest']
Usability,"r(); mints.integrals(). PsiMod.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'). while True:; PsiMod.transqt2(); PsiMod.ccsort(); PsiMod.ccenergy(); PsiMod.print_out('Brueckner convergence check: %d\n' % PsiMod.get_variable('BRUECKNER CONVERGED')); if (PsiMod.get_variable('BRUECKNER CONVERGED') == True):; break. optstash.restore(). [docs]def run_bccd_t(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD(T) calculation. """"""; optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCTRIPLES', 'WFN']). PsiMod.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); PsiMod.set_local_option('CCSORT', 'WFN', 'BCCD_T'); PsiMod.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); PsiMod.set_local_option('CCTRIPLES', 'WFN', 'BCCD_T'); run_bccd(name, **kwargs); PsiMod.cctriples(). optstash.restore(). [docs]def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """"""; optstash = OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). run_scf(name, **kwargs). optstash.restore(). [docs]def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; oneel_properties = ['dipole', 'quadrupole']; twoel_properties = []; response_properties = ['polarizability', 'rotation', 'roa']; excited_properties = ['oscillator_strength', 'rotational_strength']. one = []; two = []; response = []; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs.pop('properties'); properties = drop_duplicates(properties). for prop in properties:; if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:25846,simpl,simple,25846,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['simpl'],['simple']
Usability,"rapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. delta2_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. Combined interface. Others. Parameters:molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html:9701,simpl,simple,9701,psi4manual/1.3.2/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html,4,['simpl'],['simple']
Usability,"re placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; 1>>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; 1; 2; 3Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about \(1.0 \times 10^{-6}\), so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity \(2S+1 = 3\)).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. No",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:3225,simpl,simple,3225,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,4,['simpl'],['simple']
Usability,"re the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; The division of the molecular orbitals into various subspaces such as; RAS spaces, or frozen vs. active orbitals, etc., needs to be clear not; only to detci, but also at least to the transformation program; (and in the case of MCSCF, to other programs as well). Thus, orbital; subspace keywords such as RAS1,; RAS2, RAS3, FROZEN_DOCC, FROZEN_UOCC,; ACTIVE, etc., should be set; in the global section of input so they may also be read by other modules.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. Higher order; single-refernce CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specifed by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Basic DETCI Keywords¶. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF; Default: RHF. R",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/detci-1.html:4265,simpl,simply,4265,psi4manual/4.0b2/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/detci-1.html,8,['simpl'],['simply']
Usability,"re.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet) → psi4.core.RHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(save_fock, max_diis_vectors)¶; docstring. Return type; float. Parameters. save_fock (bool) – ; max_diis_vectors (int) – . compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → Li",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.rhf.html:17887,simpl,simply,17887,psi4manual/1.5.0/api/psi4.core.rhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.rhf.html,1,['simpl'],['simply']
Usability,"re.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet) → psi4.core.RHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a giv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.rhf.html:17446,simpl,simply,17446,psi4manual/1.4.0/api/psi4.core.rhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.rhf.html,1,['simpl'],['simply']
Usability,"re.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet) → psi4.core.UHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(save_fock, max_diis_vectors)¶; docstring. Return type; float. Parameters. save_fock (bool) – ; max_diis_vectors (int) – . compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → Li",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.uhf.html:17887,simpl,simply,17887,psi4manual/1.5.0/api/psi4.core.uhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.uhf.html,1,['simpl'],['simply']
Usability,"re.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet) → psi4.core.UHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a giv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.uhf.html:17446,simpl,simply,17446,psi4manual/1.4.0/api/psi4.core.uhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.uhf.html,1,['simpl'],['simply']
Usability,"red and then inserted into the geometry specification using Python 3 string formatting. [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). [4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options() API, to the input. This function takes a Python dictionary as its argument, which is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:6471,simpl,simple,6471,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,11,['simpl'],['simple']
Usability,"ree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:24276,clear,cleared,24276,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['clear'],['cleared']
Usability,"reps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. print_out(self: psi4.core.Vector) → None¶; Prints the vector to the output file. save(self: psi4.core.Vector, psio: psi4.core.IO, file: int) → None¶; Save the vector to disk. scale(self: psi4.core.Vector, sc: float) → None¶; Scales the elements of a vector by sc. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None¶; Set a vector block. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a NumPy array. Either copies the data or simply; constructs a view. Parameters. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns; Returns either a list of np.array’s or the base array depending on options. Return type; numpy.ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. vector_dot(self: psi4.core.Vector, other: psi4.core.Vector) → float¶; Take the dot product of two vectors. zero(self: psi4.core.Vector) → None¶; Zeros the vector. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Vector.html:5171,simpl,simply,5171,psi4manual/1.6.x/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Vector.html,1,['simpl'],['simply']
Usability,"rill, and Matthew L. Leininger; Section author: Daniel G. A. Smith and C. David Sherrill; Module: Keywords, PSI Variables, DETCI; As the cost of Full CI scales exponentially with respect to the number of; active orbitals it is often advantageous to neglect orbitals that do not; exhibit strong correlation. These orbitals are variationally optimized; simultaneously with the CI coefficients and known as Multi-Configurational; Self-Consistent Field (MCSCF). The most commonly used MCSCF procedure is the; complete-active-space self-consistent-field (CASSCF) approach [Roos:1980],; which includes all possible determinants (with the proper symmetry) that can be; formed by distributing a set of active electrons among a set of active; orbitals. The MCSCF module performs CASSCF optimization of molecular orbitals; via a two-step procedure in which the CI coefficients and orbitals are; optimized in an alternating manner. The program uses a fairly simple; approximate orbital Hessian [Chaban:1997:88] and a Newton-Raphson update,; accelerated by Pulay’s DIIS procedure [Pulay:1980]. We have also implemented; the RASSCF method [Malmqvist:1990:RASSCF], which is another kind of MCSCF; which is typically less complete (and less expensive) than CASSCF.; Inactive orbitals in the MCSCF may be specified by the; RESTRICTED_DOCC and RESTRICTED_UOCC keywords. These; orbitals will remain doubly-occupied or doubly-unoccupied, respectively, in the; MCSCF wavefunction. However, the form of these orbitals will be optimized in; the MCSCF procedure. It is also possible to literally freeze inactive orbitals; in their original (SCF) form using the FROZEN_DOCC and; FROZEN_UOCC keywords. This is not normally what one wishes to do in; an MCSCF computation (e.g., it complicates the computation of gradients), but; it can make the computations faster and is helpful in some circumstances where; unphysical mixing of inactive and active occupied orbitals might occur.; Presently, it is not possible to mix the use ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/mcscf-1.html:1254,simpl,simple,1254,psi4manual/1.4.0/mcscf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/mcscf-1.html,9,['simpl'],['simple']
Usability,"ring. clear(self); docstring. compute(self); docstring. set_Da_ao(self, Da[, symmetry]); docstring. set_Da_mo(self, arg0); docstring. set_Da_so(self, arg0); docstring. set_Db_ao(self, Db[, symmetry]); docstring. set_Db_mo(self, arg0); docstring. set_Db_so(self, arg0); docstring. set_title(self, arg0); docstring. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']¶. Methods Documentation. Exvals(self: psi4.core.OEProp) → List[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; docstring. clear(self: psi4.core.OEProp) → None¶; docstring. compute(self: psi4.core.OEProp) → None¶; docstring. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0) → None¶; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0) → None¶; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_title(self: psi4.core.TaskListComputer, arg0: str) → None¶; docstring. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; OEProp. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.oeprop.html:1623,clear,clear,1623,psi4manual/1.5.0/api/psi4.core.oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.oeprop.html,1,['clear'],['clear']
Usability,"rings from *.py files in psi4/lib/python; Databases: docstrings from *.py files in psi4/lib/databases; Basis Sets: *.gbs files in psi4/lib/basis; C++ Keywords: psi4/src/bin/psi4/read_options.cc; Sample Inputs: input.dat files in psi4/samples; PSI Variables: Process::environment.globals lines and comments in the C++ code; Plugins: doc.rst text, *.py modules, and C++ keywords in psi4/tests/plugin_* plugin directories (disabled at the moment); PSI Files: scratch file names and numbers in psi4/include/psifiles.h. Some documentation is even extracted from Psi4 objects at runtime. psi4: docstrings for the psi4 built-in module constructed in psi4/src/bin/psi4; DFT: functional availibility and characteristics as encoded in psi4/lib/python/functional.py; BasisFamily: fitting basis sets for each orbital basis as encoded in psi4/lib/python/basislistdunning.py and psi4/lib/python/basislistother.py. Run make help to see choices for cleaning various stages of the build.; Running make realclean clears out the built documentation. Building; all the documentation takes ~10 minutes. There is now good; dependency structure built into the psi4/doc/sphinxman/Makefile.in ,; so very long builds should be infrequent (unless you’re touching psi4/src/bin/psi4/read_options.cc.; Note that not all dependencies; are encoded (PSI variables, for instance, depend on every .cc file in the; source tree), so for a definitive doc build, run make realclean and; start from scratch. reStructuredText¶; Sphinx files are written in reStructuredText (*.rst). In the html; documentation, source code is available from the sidebar. Here’re a; few resources on Sphinx formatting. reStructuredText; rendered test document; vs. source test document; Another reStructuredText; A third reStructuredText and Sphinx; LaTeX that Sphinx can handle; Sphinx Docs. Math in the Codebase¶; It is often useful to have mathematical expressions in docstrings or; comments in the code that are auto-documented into the manual. Such; locat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/documentation-1.html:3277,clear,clears,3277,psi4manual/4.0b5/documentation-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/documentation-1.html,2,['clear'],['clears']
Usability,"rite_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. Table([rows, row_label_width, ...]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Error called for problems with the input file. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:22926,simpl,simple,22926,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,2,['simpl'],['simple']
Usability,"rmation is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]¶; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]¶; Serializes instance into dictionary according to schema dtype. to_string(dtype, units=None, atom_format=None, ghost_format=None, width=17, prec=12)[source]¶; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int) → int¶; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule) → str¶; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int) → float¶; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int) → psi4.core.Vector3¶; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int) → float¶; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int) → float¶; z position [Bohr] of atom arg0 (0-indexed without dummies). table of contents. Molecule; Molecule; Molecule.B787(); Molecule.BFS(); Molecule.Z(); Molecule.activate_all_fragments(); Molecule.add_atom(); Molecule.atom_at_position(); Molecule.basis_on_atom(); Molecule.center_of_mass(); Molecule.charge(); Molecule.clone(); Molecule.com_fixed(); Molecule.comment(); Molecule.connectivity(); Molecule.create_psi4_string_from_molecule(); Molecule.deactivate_all_fragments(); Molecule.distance_matrix(); Molecu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:39072,clear,clearing,39072,psi4manual/1.8.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html,3,['clear'],['clearing']
Usability,"ror); tables += """"""%23s %19s %8.4f\n"""""" % ('Maximal Dev', '', maxDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Signed Dev', '', MSDerror); tables += """"""%23s %19s %8.4f\n"""""" % ('Mean Absolute Dev', '', MADerror); tables += """"""%23s %19s %8.4f\n"""""" % ('RMS Dev', '', RMSDerror); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). #print tables; psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. # restore molecule and options; activate(user_molecule); user_molecule.update_geometry(); psi4.set_global_option(""BASIS"", user_basis); psi4.set_global_option(""REFERENCE"", user_reference); if not b_user_reference:; psi4.revoke_global_option_changed('REFERENCE'); psi4.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. [docs]def tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %8s"""""" % ('Reaction', 'Reaction Energy', 'Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %6s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %8s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]'); elif ttype == 2:; tbl_str += """"""\n%54s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:51478,clear,clear,51478,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['clear'],['clear']
Usability,"ror, IndexError):; if freq_irrep_only != -1:; raise ValidationError(; f""FINDIF: 0-indexed Irrep value ({freq_irrep_only}) not in valid range: <{len(salc_indices_pi)}.""). # Populate salc_indices_pi for all irreps.; # * Python error if iterate through `salc_list`; for i in range(len(salc_list)):; salc_indices_pi[salc_list[i].irrep_index()].append(i). # If the method allows more than one irrep, print how the irreps partition the SALCS.; if print_lvl and method_allowed_irreps != 0x1 and verbose:; info = "" Index of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; tmp = ("" {:d} "" * len(salc_indices_pi[h])).format(*salc_indices_pi[h]); info += "" {:d} : "".format(h + 1) + tmp + ""\n""; info += "" Number of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; info += "" Irrep {:d}: {:d}\n"".format(h + 1, len(salc_indices_pi[h])); core.print_out(info); logger.info(info). # Now that we've printed the SALCs, clear any that are not of user-specified symmetry.; if freq_irrep_only != -1:; for h in range(n_irrep):; if h != freq_irrep_only:; salc_indices_pi[h].clear(). n_disp_pi = []. for irrep, indices in enumerate(salc_indices_pi):; n_disp = len(indices) * len(disps[""asym_irr"" if irrep != 0 else ""sym_irr""]); if mode == ""2_0"":; # Either len(indices) or len(indices)-1 is even, so dividing by two is safe.; n_disp += len(indices) * (len(indices) - 1) // 2 * len(disps[""off""]); n_disp_pi.append(n_disp). # Let's print out the number of geometries, the displacement multiplicity, and the CdSALCs!; if print_lvl and verbose:; info = f"" Number of geometries (including reference) is {sum(n_disp_pi) + 1}.\n""; if method_allowed_irreps != 0x1:; info += "" Number of displacements per irrep:\n""; for i, ndisp in enumerate(n_disp_pi, start=1):; info += f"" Irrep {i}: {ndisp}\n""; core.print_out(info); logger.info(info). if print_lvl > 1 and verbose:; for i in range(len(salc_list)):; salc_list[i].print_out(). data.update({",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:11087,clear,clear,11087,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,4,['clear'],['clear']
Usability,"rt(RMSDerror / float(count_rxn)). tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Minimal Dev', '', minDerror, minDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Maximal Dev', '', maxDerror, maxDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Signed Dev', '', MSDerror, MSDerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('Mean Absolute Dev', '', MADerror, MADerror * p4const.psi_cal2J); tables += """"""%23s %19s %10.4f %10.4f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * p4const.psi_cal2J); tables += """""" %s\n"""""" % (table_delimit). psi4.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); psi4.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); psi4.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). psi4.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str +=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:28301,clear,clear,28301,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['clear'],['clear']
Usability,"rted into the geometry; specification using Python 3 string; formatting. In [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimizati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:6432,simpl,simple,6432,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['simpl'],['simple']
Usability,"rue;; auto eri = factory->eri(deriv_level, use_shell_pairs);; const double* buffer = eri_->buffer();; for (int P = 0; P < basisset->nshell(); ++P) {; const auto& Pshell = basisset->shell(P);; for (int Q = 0; Q < basisset->nshell(); ++Q) {; const auto& Qshell = basisset->shell(Q);; for (int R = 0; R < basisset->nshell(); ++R) {; const auto& Rshell = basisset->shell(R);; for (int S = 0; S < basisset->nshell(); ++S) {; const auto& Sshell = basisset->shell(S);; if(sieve->shell_significant(P, Q, R, S) {; eri->compute_shell(P, Q, R, S);; // results are in buffer, do something with them..; }; }; }; }; }. An integral factory is used, which can then produce integral object for various; operator types and derivative levels. A sieve is also constructed; this allows; a quick determination of whether an integral shell quartet will be significant; in magnitude or not, potentially saving a lot of work. This simple scheme is; clean and easy to understand, and is still supported in the latest version of; PSI4 with only a small change to the sieve syntax and handling of buffer; addresses, noted below. The new syntax¶; The newer integral engines being interfaced to PSI4 may or may not require; a group of similar integrals to be computed together in a block using; vectorized instructions. To accomodate this possibility, a new syntax has been; introduced in Libmints:; auto blocksPQ = ints[0]->get_blocks12();; auto blocksRS = ints[0]->get_blocks34();. auto factory= std::make_shared<IntegralFactory>(basisset);; int deriv_level = 0;; bool use_shell_pairs = true;; bool needs_exchange = true;; auto eri = factory->eri(deriv_level, use_shell_pairs, needs_exchange);; const auto &buffers = eri->buffers();. eri->update_density(D);; bool use_batching = eri->maximum_block_size() > 1;. // loop over all the blocks of (P>=Q|; for (size_t blockPQ_idx = 0; blockPQ_idx < blocksPQ.size(); blockPQ_idx++) {; const auto& blockPQ = blocksPQ[blockPQ_idx];; // loop over all the blocks of |R>=S); size_t start = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_integrals-1.html:1855,simpl,simple,1855,psi4manual/1.4.0/prog_integrals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_integrals-1.html,9,['simpl'],['simple']
Usability,"ry basis set automatically according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input.; Should needed elements be missing from the best; auxiliary basis or should the orbital basis be unknown to PSI4,; the auxiliary basis will fall back on def2 quad-zeta fitting bases.; Note that if BASIS is known to be larger than quad-zeta,; PSI4 will not attempt to fall back on the def2 fitting bases.; The same basis “block” syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. df_basis_mp2 {; assign cc-pVDZ-RI; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; df_basis_mp2 {; assign C aug-cc-pVDZ-RI; }. Decontracted Basis Sets¶; Decontraction of the basis set can be useful in certain situations. In; order to decontract a given basis set, simply add “-decon” to the name; of the primary basis set (e.g. decontract).; set basis cc-pvdz-decon. Obviously this will add significantly to the computational cost of any given calculation, however it can; be useful when checking the basis set dependence of a particular calculated property or in certain situations; where a large basis set is critical. Currently it is recommended that a decontracted basis is always used when performing relativistic calculations using the X2C Hamiltonian. User-Defined Basis Sets¶. Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. There are three routes by which a basis set in G94 format can be introduced to PSI4‘s notice.; (1) Install new basis set file into PSI4 basis library.; Copy the basis set definitions for all elements into a blank file. Exclamation points denote comments.; As the first line of the file, add the word spherical or cartesian to indicate; whether the basis set wil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/basissets-1.html:6150,simpl,simply,6150,psi4manual/1.4.0/basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/basissets-1.html,4,['simpl'],['simply']
Usability,"s ERIs.; For converged RHF and UHF references, the singles correction,. is zero due to the Brillioun Condition, and the first contribution to the; perturbation series is at the second order:. In the DFMP2 module, the first-order contribution, or “singles energy” is; always evaluated. This term is a significant contributor to the total; second-order energy if a ROHF reference is used. In this case, we have chosen; to use the ROHF-MBPT(2) ansatz, in which the ROHF orbitals are; semicanonicalized, the resultant nonzero Fock matrix elements are used; to form the singles amplitudes, and then the second-order amplitudes are formed; with the semicanonical spin orbitals via the same machinery as a UHF-MP2. Note; that the singles energy should be very close to zero for RHF and UHF references;; if it is not, there is a good chance your orbitals are not well converged.; Tighten the SCF E_CONVERGENCE and/or D_CONVERGENCE keywords; and try again.; To increase the efficiency of MP2 energy evaluation, spin integration; and simplification is carried out. This also allows for the identification of; Same-Spin (SS) and Opposite-Spin (OS) terms for use in Grimme’s Spin-Component; Scaled (SCS) MP2. For RHF-MP2 (also labeled as RMP2), the spin-free equations are; (note that the integrals are now chemist’s integrals over spatial orbitals). and. For UHF-MP2 (also labeled as UMP2) and the second-order contribution to; ROHF-MBPT(2) using semicanonical orbitals, the spin-free equations are. and. Note that the UHF-MP2 equations use three classes of integrals, while the; RHF-MP2 equations use only one class. Because of this, a UHF-MP2 or; ROHF-MBPT(2) energy should take roughly three times as long as an RHF-MP2; energy. Recommendations¶; All-in-all, DFMP2 should be a simple module to use, with few keywords (fully; documented in the Appendix DFMP2). Some basic recommendations are included below:. DFMP2 should be run with the -type RI or MP2FIT auxiliary; basis sets, not the -JKFIT basis sets. The",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dfmp2-1.html:5049,simpl,simplification,5049,psi4manual/1.0.0/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dfmp2-1.html,10,['simpl'],['simplification']
Usability,"s at the passed position b in Bohr with a tolerance tol.; >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. atom_entry(atom)[source]¶; Returns the CoordEntry for an atom. atom_to_unique(iatom)[source]¶; Converts an atom number to the number of its generating unique atom.; The return value is in [0, nunique). atom_to_unique_offset(iatom)[source]¶; Converts an atom number to the offset of this atom; in the list of generated atoms. The unique atom itself is allowed offset 0. center_of_mass()[source]¶; Computes center of mass of molecule (does not translate molecule).; >>> H2OH2O.center_of_mass(); [-0.12442647346606871, 0.00038657002584110707, 0.0]. charge(atom)[source]¶; Returns charge of atom (0-indexed).; Related to SAD guess in libmints version.; >>> print H2OH2O.charge(4); 1.0. charge_specified()[source]¶; Whether the charge was given by the user; >>> print H2OH2O.charge_specified(); True. clear()[source]¶; Zero it out. clear_basis_all_atoms()[source]¶; Remove all basis information from atoms. clone()[source]¶; Returns new, independent Molecule object.; >>> dimer = H2OH2O.clone(). create_molecule_from_string(text)[source]¶; Given a string text of psi4-style geometry specification; (including newlines to separate lines), builds a new molecule.; Called from constructor. create_psi4_string_from_molecule()[source]¶; Regenerates a input file molecule specification string from the; current state of the Molecule. Contains geometry info,; fragmentation, charges and multiplicities, and any frame; restriction. deactivate_all_fragments()[source]¶; Sets all fragments in the molecule to be inactive. distance_matrix()[source]¶; Computes a matrix depicting distances between atoms. Prints; formatted and returns array.; >>> H2OH2O.distance_matrix(); Interatomic Distances (Angstroms); [1] [2] [3] [4] [5] [6]; [1] 0.00000; [2] 0.95711 0.00000; [3] 0.96391 1.51726 0.00000; [4] 2.91042 3.34878 1.95159 0.00",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:76484,clear,clear,76484,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['clear'],['clear']
Usability,"s by other; psi4 developers. """"""; import math; import copy; from vecutil import *; from exceptions import *. [docs]class CoordValue(object):; """"""An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. """""". def __init__(self, fixed=False, computed=False):; # Fixed coordinate?; self.PYfixed = fixed; # Whether the current value is up to date or not; self.computed = computed. [docs] def set_fixed(self, fixed):; """"""Set whether the coordinate value is fixed or not""""""; self.PYfixed = fixed. [docs] def fixed(self):; """"""Get whether the coordinate value is fixed or not""""""; return self.PYfixed. [docs] def invalidate(self):; """"""Flag the current value as outdated""""""; self.computed = False. [docs] def everything(self):; print '\nCoordValue\n Fixed = %s\n Computed = %s\n\n' % (self.PYfixed, self.computed). [docs]class NumberValue(CoordValue):; """"""Specialization of CoordValue that is simply a number to be stored."""""". def __init__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; return self.value. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print '\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' % \; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4)). [docs]class",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html:1363,simpl,simply,1363,psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,3,['simpl'],['simply']
Usability,"s for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import sys; from typing import List, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]def array_to_matrix(self, arr: Union[np.ndarray, List[np.ndarray]], name: str = ""New Matrix"", dim1: Union[List, Tuple, core.Dimension] = None, dim2: core.Dimension = None) -> Union[core.Matrix, core.Vector]:; """"""; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters; ----------; arr; Numpy array or list of ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:1346,simpl,simple,1346,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,3,['simpl'],['simple']
Usability,"s from *.py files in psi4/lib/python; Databases: docstrings from *.py files in psi4/lib/databases; Basis Sets: *.gbs files in psi4/lib/basis; C++ Keywords: psi4/src/bin/psi4/read_options.cc; Sample Inputs: input.dat files in psi4/samples; PSI Variables: Process::environment.globals lines and comments in the C++ code; Plugins: doc.rst text, *.py modules, and C++ keywords in psi4/tests/plugin_* plugin directories (disabled at the moment); PSI Files: scratch file names and numbers in psi4/include/psifiles.h. Some documentation is even extracted from Psi4 objects at runtime. PsiMod: docstrings for the PsiMod built-in module constructed in psi4/src/bin/psi4; DFT: functional availibility and characteristics as encoded in psi4/lib/python/functional.py; BasisFamily: fitting basis sets for each orbital basis as encoded in psi4/lib/python/basislistdunning.py and psi4/lib/python/basislistother.py. Run make help to see choices for cleaning various stages of the build.; Running make realclean clears out the built documentation. Building; all the documentation takes ~10 minutes. There is now good; dependency structure built into the psi4/doc/sphinxman/Makefile.in ,; so very long builds should be infrequent (unless you’re touching psi4/src/bin/psi4/read_options.cc.; Note that not all dependencies; are encoded (PSI variables, for instance, depend on every .cc file in the; source tree), so for a definitive doc build, run make realclean and; start from scratch. reStructuredText¶; Sphinx files are written in reStructuredText (*.rst). In the html; documentation, source code is available from the sidebar. Here’re a; few resources on Sphinx formatting. reStructuredText; rendered test document; vs. source test document; Another reStructuredText; A third reStructuredText and Sphinx; LaTeX that Sphinx can handle; Sphinx Docs. Math in the Codebase¶; It is often useful to have mathematical expressions in docstrings or; comments in the code that are auto-documented into the manual. Such; locat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/documentation-1.html:3281,clear,clears,3281,psi4manual/4.0b4/documentation-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/documentation-1.html,2,['clear'],['clears']
Usability,"s point group.""""""; return CharacterTable(self.PYbits). # def equiv(self, grp, tol=1.0e-6):; # """"""Returns 1 if the point groups *self* and *grp* are equivalent,; # 0 otherwise.; #; # """"""; # return 1 if self.symb == grp.symb else 0. #PointGroup::PointGroup(const PointGroup& pg); #{; # *this = pg;; #}; #; #PointGroup::PointGroup(const boost::shared_ptr<PointGroup>& pg); #{; # *this = *pg.get();; #}; #. # """"""The PointGroup KeyVal constructor looks for three keywords:; # symmetry, symmetry_frame, and origin. symmetry is a string; # containing the Schoenflies symbol of the point group. origin is an; # array of doubles which gives the x, y, and z coordinates of the; # origin of the symmetry frame. symmetry_frame is a 3 by 3 array of; # arrays of doubles which specify the principal axes for the; # transformation matrices as a unitary rotation.; #; # For example, a simple input which will use the default origin and; # symmetry_frame ((0,0,0) and the unit matrix, respectively), might; # look like this:; #; # <pre>; # pointgrp<PointGroup>: (; # symmetry = ""c2v""; # ); # </pre>; #; # By default, the principal rotation axis is taken to be the z axis.; # If you already have a set of coordinates which assume that the; # rotation axis is the x axis, then you'll have to rotate your frame; # of reference with symmetry_frame:; #; # <pre>; # pointgrp<PointGroup>: (; # symmetry = ""c2v""; # symmetry_frame = [; # [ 0 0 1 ]; # [ 0 1 0 ]; # [ 1 0 0 ]; # ]; # ); # </pre>; # """"""; # // PointGroup(const Ref<KeyVal>&);; #; # // PointGroup(StateIn&);; # PointGroup(const PointGroup&);; # PointGroup(const boost::shared_ptr<PointGroup>&);; # ~PointGroup();; #; # PointGroup& operator=(const PointGroup&);; #PointGroup& PointGroup::operator=(const PointGroup& pg); #{; # set_symbol(pg.symb);; # origin_ = pg.origin_;; # return *this;; #}; #. # <<< Methods for Printing >>>. def __str__(self, out=None):; text = 'PointGroup: %s\n' % (self.symb). if out is None:; return text; else:; with open(out, mode='w') as ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:41835,simpl,simple,41835,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['simpl'],['simple']
Usability,"s psi4.core.NBOWriter¶; Bases: object; docstring. write(self: psi4.core.NBOWriter, arg0: str) → None¶; docstring. class psi4.core.NablaInt¶; Bases: psi4.core.OneBodyAOInt; docstring. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; docstring. origin¶; The origin about which the one body ints are being computed. class psi4.core.OEProp¶; Bases: psi4.core.Prop; docstring. Exvals(self: psi4.core.OEProp) → List[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; docstring. clear(self: psi4.core.Prop) → None¶; docstring. compute(self: psi4.core.OEProp) → None¶; docstring. set_Da_ao(self: psi4.core.Prop, Da: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Da_mo(self: psi4.core.Prop, arg0: psi::Matrix) → None¶; docstring. set_Da_so(self: psi4.core.Prop, arg0: psi::Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.Prop, Db: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Db_mo(self: psi4.core.Prop, arg0: psi::Matrix) → None¶; docstring. set_Db_so(self: psi4.core.Prop, arg0: psi::Matrix) → None¶; docstring. set_title(self: psi4.core.Prop, arg0: str) → None¶; docstring. class psi4.core.OneBodyAOInt¶; Bases: object; docstring. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; docstring. origin¶; The origin about which the one body ints are being computed. class psi4.core.OrbitalSpace¶; Bases: object; docstring. C(self",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:91724,clear,clear,91724,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['clear'],['clear']
Usability,"s roots have the right spin. However, be advised that; seeking these higher roots may cause convergence problems, because roundoff may allow the lower-lying; roots of lower multiplicities to re-enter the computation (reducing convergence criteria may help).; For open-shell systems, the MS0 keyword is typically not relevant, and there; is no control over spin multiplicities of higher roots unless|detci__calc_s_squared| is; used. Arbitrary Order Perturbation Theory¶; The DETCI module is capable of computing energies for arbitrary; order Møller–Plesset perturbation theory (MPn, for closed-shell; systems with an RHF reference) and for Z-averaged perturbation theory; (ZAPTn, open-shell systems with a ROHF reference). However, please; note that these computations are essentially doing high-order CI (up to; full CI) computations to obtain these results, and hence they will only; be possible for very small systems (generally a dozen electrons or less).; The simplest way to run high-order perturbation theory computations is to; call, e.g., energy('mp10') to invoke a MP10 computation or; energy('zapt25') to invoke a ZAPT25 computation. This will; automatically set several additional user options to their appropriate; values. The program uses the Wigner (2n+1) rule to obtain higher-order; energies from lower-order wavefunctions.; For the interested reader, the additional user options that are; automatically set up by the calls above are as follows. A call like; energy('mp10') sets MPN to TRUE.; The program uses the Wigner (2n+1) rule by default; (MPN_WIGNER = TRUE); and figures out what order of wavefunction is; necessary to reach the desired order in the energy. The program then; sets MAX_NUM_VECS to the required order in the; wavefunction.; By default, the requested n-th order energy is saved as the current; energy to the process environment. ZAPTN works essentially the same; way for an ROHF reference. Arbitrary Order Coupled-Cluster Theory¶; This DETCI-based version of this ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:13121,simpl,simplest,13121,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,9,['simpl'],['simplest']
Usability,"s the same mass and ghost status as atom other.; Unlike the libmints version, this does not compare basisset assignment. is_ghosted()[source]¶; Whether the current atom is ghosted or not. label()[source]¶; The atom label. mass()[source]¶; The atomic mass of the current atom. static r(a1, a2)[source]¶; Computes the distance between two sets of coordinates. set_ghosted(gh)[source]¶; Flag the atom as either ghost or real. symbol()[source]¶; The atomic symbol. class CoordValue(fixed=False, computed=False)[source]¶; An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. everything()[source]¶. fixed()[source]¶; Get whether the coordinate value is fixed or not. invalidate()[source]¶; Flag the current value as outdated. set_fixed(fixed)[source]¶; Set whether the coordinate value is fixed or not. class NumberValue(value, fixed=False)[source]¶; Specialization of CoordValue that is simply a number to be stored. clone()[source]¶; Returns new, independent NumberValue object. compute()[source]¶; Computes value of coordinate from member data. everything()[source]¶. rset(val)[source]¶; Resets value of coordinate if not fixed. type()[source]¶; Gets specialization type of CoordValue. variable_to_string(precision)[source]¶; Takes a CoordValue object, and returns a string for printing. class VariableValue(name, geometryVariables, negate=False, fixed=False)[source]¶; Specialization of CoordValue, where the current value depends; on the list of geometry values stored by the molecule. clone()[source]¶; Returns new, independent VariableValue object. compute()[source]¶; Computes value of coordinate from member data. everything()[source]¶. name()[source]¶; Gets the name of the variable. negated()[source]¶; Gets whether the coordinate value is actually the negative of the variable value. rset(val)[source]¶; Resets value of coordinate if not fixed. typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:37462,simpl,simply,37462,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,6,['simpl'],['simply']
Usability,"s the same; as a normal Fock build (\(\mathbb{N}^4\)). The overall SOSCF operation is; thus broken down into micro- and macroiterations where the microiterations; refer to solving the SOSCF equations and macroiterations are the construction; of a new Fock matrix based on the orbitals from a SOSCF step.; SOSCF requires that all elements of the gradient to be less than one before the; method is valid. To this end, pre-SOSCF SCF iterations use normal; gradient-based extrapolation procedures (e.g., DIIS) until the gradient; conditions are met. Note that while the total number of macroiterations will be; less for SOSCF than gradient-based convergence acceleration, the cost of solving; the microiterations typically results in the overall cost being greater for; SOSCF than for gradient-based methods. Therefore, SOSCF should only be used if; it is difficult to locate a stable minimum.; SOSCF is only available for RHF, ROHF, and UHF reference (and only for HF, not DFT).; To turn on, simply set; the option SOSCF to true. Additional options to modify the number of; microiterations taken are as follows:. SOSCF_START_CONVERGENCE: when to start SOSCF based on the current density RMS; SOSCF_MAX_ITER: the maximum number of SOSCF microiterations per macroiteration; SOSCF_CONV: the relative convergence tolerance of the SOSCF microiterations; SOSCF_PRINT: option to print the microiterations or not. Stability Analysis¶; SCF algorithms attempt to minimize the gradient of the energy with respect; to orbital variation parameters. At convergence, the gradient should be approximately zero; given a convergence criterion. Although this is enough to make sure the SCF converged to a; stationary point, this is not a sufficient condition for a minimal SCF solution. It may be; a saddle point or a maximum.; To ensure that a minimum has been found, the electronic Hessian, i.e. the matrix of second; derivatives of the energy with respect to orbital variation parameters, must be computed.; If one or mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:24922,simpl,simply,24922,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,4,['simpl'],['simply']
Usability,"s {...}, as shown below. Multiple basis sets can be; specified by adding additional sections within the surrounding brackets.; Use assign statements to actually request the basis set. This; basis {...} section replaces the usual set basis XXX line.; In a more complex input, if the user needs to call the user-defined; basis by name, this can be achieved using the syntax basis mybas {...},; and then the basis can be recalled later as set basis mybas.; To use a custom basis set as described in this section, it must be; defined prior to its use in a function that performs a computation.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14basis {. # assign basset to all atoms and addl to hydrogens; assign basset; assign H addl. # basis set section like in snippet above goes here; [basset]; ... # additional basis set sections follow; [addl]; ...; }. The test case mints2 provides a complete example of; user-specified basis sets. Inputting effective core potentials (ECPs)¶; For ECP containing basis sets, all of the above mechanisms may still be used to; input the basis set; simply place the ECP definitions (in G94 format) in the; same file or input section as the orbital basis definition. Because the ECP; appears in the same section as the orbital basis, it will be parsed; automatically and the number of core electrons the ECP represents will be; detected, so no further input is required to use a core potential. See; Effective core potentials (ECPs) for more information about using ECPs and the; Def2-TZVP basis set definition; for an example of their input syntax. table of contents. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon: Structuring an Input File. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/basissets-1.html:10295,simpl,simply,10295,psi4manual/1.2.1/basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/basissets-1.html,2,['simpl'],['simply']
Usability,"s, because they introduce minimal errors; while providing much faster computations [Hohenstein:2010:184111]; [Hohenstein:2010:014101]. Since we’re using density fitting for the SAPT,; we might as well also use it for the Hartree–Fock computations that are; performed as part of the SAPT. We can specify that with; scf_type DF.; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, PSI4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that PSI4 correctly guesses that we want the jun-cc-pVDZ-JKFIT; auxiliary basis for the Hartree–Fock, and the jun-cc-pVDZ-RI basis set; for the SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons with freeze_core True. The SAPT; procedure is invoked with the simple call, energy('sapt0'). This; call knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in addition; to the total SAPT0 interaction energy. An explanation of the various; energy components can be found in the review by Jeziorski, Moszynski, and; Szalewicz [Jeziorski:1994:1887], and this is discussed in more detail; in the SAPT section later in this manual. For now, we’ll note that most of; the SAPT energy components are negative; this means those are attractive; contributions (the zero of energy in a SAPT computation is defined as; non-interacting monomers). The exchange contributions are positive; (repulsive). In this example, the most attractive contribution between; ethylene and acetylene is an electrostatic term of -2.12 kcal mol-1; (Elst10,r where the 1 indicates the first-order; perturbation theory result with respect to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:13591,simpl,simple,13591,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,19,['simpl'],['simple']
Usability,"s, because they introduce minimal errors; while providing much faster computations [Hohenstein:2010:184111]; [Hohenstein:2010:014101]. Since we’re using density fitting for the SAPT,; we might as well also use it for the Hartree–Fock computations that are; performed as part of the SAPT. We can specify that with; scf_type DF.; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT; auxiliary basis for the Hartree–Fock, and the jun-cc-pVDZ-RI basis set; for the SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons with freeze_core True. The SAPT; procedure is invoked with the simple call, energy('sapt0'). This; call knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in addition; to the total SAPT0 interaction energy. An explanation of the various; energy components can be found in the review by Jeziorski, Moszynski, and; Szalewicz [Jeziorski:1994:1887], and this is discussed in more detail; in the SAPT section later in this manual. For now, we’ll note that most of; the SAPT energy components are negative; this means those are attractive; contributions (the zero of energy in a SAPT computation is defined as; non-interacting monomers). The exchange contributions are positive; (repulsive). In this example, the most attractive contribution between; ethylene and acetylene is an electrostatic term of -2.12 kcal mol-1; (Elst10,r where the 1 indicates the first-order; perturbation theory result with respect to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:12851,simpl,simple,12851,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['simpl'],['simple']
Usability,"s, through the Ubuntu shell).; If using the Psi4conda installer, gCP has already been installed alongside.; If using the PSI4 conda package, the gcp conda package can; be obtained through conda install gcp -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; the gcp executable can be obtained through conda install gcp -c psi4.; To remove a conda installation, conda remove gcp. Source. If using PSI4 built from source and you want to build gCP from; from source also, follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a Fortran compiler, and run make). To be used by PSI4, the program binary (gcp) must be; found in your PSIPATH or PATH (in that order). If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The DFTD3 executable must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; optimize('pbeh3c'). HF-3c with non-standard basis; set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/gcp-1.html:1368,simpl,simply,1368,psi4manual/1.4.0/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/gcp-1.html,5,['simpl'],['simply']
Usability,"s. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. print_out(self: psi4.core.Vector) → None¶; Prints the vector to the output file. scale(self: psi4.core.Vector, sc: float) → None¶; Scales the elements of a vector by sc. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None¶; Set a vector block. shape¶; Shape of the Psi4 data object. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. class psi4.core.Vector3¶; Bases: pybind11_builtins.pybind11_object; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations. cross(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → psi4.core.Vector3¶",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:212875,simpl,simply,212875,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['simpl'],['simply']
Usability,"s. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. print_out(self: psi4.core.Vector) → None¶; Prints the vector to the output file. scale(self: psi4.core.Vector, sc: float) → None¶; Scales the elements of a vector by sc. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None¶; Set a vector block. shape¶; Shape of the Psi4 data object. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. class psi4.core.Vector3¶; Bases: pybind11_builtins.pybind11_object; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations. cross(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → psi4.core.Vector3¶; Returns cro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:263785,simpl,simply,263785,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['simpl'],['simply']
Usability,"salc_indices_pi)}.""). # Populate salc_indices_pi for all irreps.; # * Python error if iterate through `salc_list`; for i in range(len(salc_list)):; salc_indices_pi[salc_list[i].irrep_index()].append(i). # If the method allows more than one irrep, print how the irreps partition the SALCS.; if print_lvl and method_allowed_irreps != 0x1 and verbose:; info = "" Index of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; tmp = ("" {:d} "" * len(salc_indices_pi[h])).format(*salc_indices_pi[h]); info += "" {:d} : "".format(h + 1) + tmp + ""\n""; info += "" Number of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; info += "" Irrep {:d}: {:d}\n"".format(h + 1, len(salc_indices_pi[h])); core.print_out(info); logger.info(info). # Now that we've printed the SALCs, clear any that are not of user-specified symmetry.; if freq_irrep_only != -1:; for h in range(n_irrep):; if h != freq_irrep_only:; salc_indices_pi[h].clear(). n_disp_pi = []. for irrep, indices in enumerate(salc_indices_pi):; n_disp = len(indices) * len(disps[""asym_irr"" if irrep != 0 else ""sym_irr""]); if mode == ""2_0"":; # Either len(indices) or len(indices)-1 is even, so dividing by two is safe.; n_disp += len(indices) * (len(indices) - 1) // 2 * len(disps[""off""]); n_disp_pi.append(n_disp). # Let's print out the number of geometries, the displacement multiplicity, and the CdSALCs!; if print_lvl and verbose:; info = f"" Number of geometries (including reference) is {sum(n_disp_pi) + 1}.\n""; if method_allowed_irreps != 0x1:; info += "" Number of displacements per irrep:\n""; for i, ndisp in enumerate(n_disp_pi, start=1):; info += f"" Irrep {i}: {ndisp}\n""; core.print_out(info); logger.info(info). if print_lvl > 1 and verbose:; for i in range(len(salc_list)):; salc_list[i].print_out(). data.update({; ""n_disp_pi"": n_disp_pi,; ""n_irrep"": n_irrep,; ""n_salc"": n_salc,; ""n_atom"": n_atom,; ""salc_list"": salc_list,; ""salc_indices_pi"": salc_indices_pi,;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:11237,clear,clear,11237,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,4,['clear'],['clear']
Usability,"se ValidationError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(f""""""CBS gufunc: Too many brackets given! {method_str}""""""). if method_str.count('/') != 1:; raise ValidationError(f""""""CBS gufunc: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; func : function; Function to be called (energy, gradient, frequency or cbs).; total_method_name : str; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.cbs`. Returns; -------; tuple or float; Float, or if ``return_wfn`` is specified, a tuple of ``(value, wavefunction)``.; """""". # Catch kwarg issues for all methods; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:64656,simpl,simple,64656,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['simpl'],['simple']
Usability,"se can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/optking-1.html:2133,clear,clear,2133,psi4manual/4.0b3/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html,2,['clear'],['clear']
Usability,"seful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. """"""; from __future__ import absolute_import; from __future__ import print_function; import math; import copy; from .vecutil import *; from .exceptions import *; try:; from collections import OrderedDict; except ImportError:; from .oldpymodules import OrderedDict. [docs]class CoordValue(object):; """"""An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. """""". def __init__(self, fixed=False, computed=False):; # Fixed coordinate?; self.PYfixed = fixed; # Whether the current value is up to date or not; self.computed = computed. [docs] def set_fixed(self, fixed):; """"""Set whether the coordinate value is fixed or not""""""; self.PYfixed = fixed. [docs] def fixed(self):; """"""Get whether the coordinate value is fixed or not""""""; return self.PYfixed. [docs] def invalidate(self):; """"""Flag the current value as outdated""""""; self.computed = False. [docs] def everything(self):; print('\nCoordValue\n Fixed = %s\n Computed = %s\n\n' % (self.PYfixed, self.computed)). [docs]class NumberValue(CoordValue):; """"""Specialization of CoordValue that is simply a number to be stored."""""". def __init__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:1645,simpl,simplifying,1645,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,1,['simpl'],['simplifying']
Usability,"sg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. Example; -------; >>> psi4.compare_values(2, 3, 2, ""asdf""); asdf..................................................................................FAILED; psi4.driver.p4util.exceptions.TestComparisonError: asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by difference (1.0000).; !----------------------------------------------------------------------------------!; ! !; ! asdf: computed value (3.0000) does not match (2.0000) to atol=0.01 by !; ! difference (1.0000). !; ! !; !----------------------------------------------------------------------------------!. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class UpgradeHelper(PsiException):; """"""Error called on previously valid syntax that now isn't and a; simple syntax transition is possible. It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation :class:`FutureWarning`.; For cases where the syntax just has to jump, an UpgradeHelper can be used; to trap the old syntax at first error and suggest the new. An UpgradeHelper can also be used after the :class:`FutureWarning`; described above has expired. Then the body of the code can be deleted while; the definition is preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters; ----------; old; Previously valid syntax.; new; Suggested replacement syntax.; version; First Major.minor version at which `old` syntax won't run. Generally; the next release at time of commit.; elaboration; Any additional message to convey. Should start with a space. """"""; def __init__(self, old: str, new: str, version: str, elaboration: str):; msg = ""Using `{}` instead of `{}`",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html:3808,simpl,simple,3808,psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html,1,['simpl'],['simple']
Usability,"si4.Vector method. print_out( (Vector)arg1) -> None :. docstring; C++ signature :. void print_out(N3psi6VectorE {lvalue}). psi4.Vector.scale()¶; Python Library Documentation: method scale; scale(...) unbound psi4.Vector method. scale( (Vector)arg1, (float)arg2) -> None :. docstring; C++ signature :. void scale(N3psi6VectorE {lvalue},d). psi4.Vector.set()¶; Python Library Documentation: method set; set(...) unbound psi4.Vector method. set( (Vector)arg1, (int)arg2, (float)arg3) -> None :. docstring; C++ signature :. void set(N3psi6VectorE {lvalue},i,d). set( (Vector)arg1, (int)arg2, (int)arg3, (float)arg4) -> None :. docstring; C++ signature :. void set(N3psi6VectorE {lvalue},i,i,d). psi4.Vector.shape()¶; Python Library Documentation: property. psi4.Vector.to_array()¶; Python Library Documentation: method to_array in module p4util.numpy_helper; to_array(matrix, copy=True, dense=False) unbound psi4.Vector method. Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Vector3¶. psi4.Vector3.cross()¶; Python Library Documentation: method cross; cross(...) unbound psi4.Vector3 method. cross( (Vector3)arg1, (Vector3)arg2) -> Vector3 :. Returns cross product of arg1 and arg2; C++ signature :. N3psi7Vector3E cross(N3psi7Vector3E {lvalue},N3psi7Vector3E). psi4.Vector3.distance()¶; Python Library Documentation: method distance; distance(...) unbound psi4.Vector3 method. distance( (Vector3)arg1, (Vector3)arg2) -> float :. Returns distance between two points represented by arg1 and arg2; C++ signature :. d distance(N3psi7Vector3E {lvalue},N3psi7Vector3E). psi4.Vector3.dot()¶; Python Library Documentation: method dot; dot(...) unbound psi4.Vector3 method. dot( (Vector3)arg1, (Vector3)arg2) -> float :. Returns dot product of arg1 and arg2; C++ signature :. d dot(N3psi7Vector3E {lvalue},N3psi7Vector3E). psi4.Vector3.norm()¶; Python Library Documentation: method norm; norm(...) unbound psi4.Vector3 method. norm( (Vector3)arg1) -> float",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:352704,simpl,simply,352704,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['simpl'],['simply']
Usability,"si4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet) → psi4.core.CUHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(save_fock, max_diis_vectors)¶; docstring. Return type; float. Parameters. save_fock (bool) – ; max_diis_vectors (int) – . compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → Li",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:18044,simpl,simply,18044,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,1,['simpl'],['simply']
Usability,"si4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet) → psi4.core.ROHF¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(save_fock, max_diis_vectors)¶; docstring. Return type; float. Parameters. save_fock (bool) – ; max_diis_vectors (int) – . compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → Li",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ROHF.html:18411,simpl,simply,18411,psi4manual/1.6.x/api/psi4.core.ROHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ROHF.html,1,['simpl'],['simply']
Usability,"siAPI mode, you write a pure; Python script with import psi4 at the top and commands are behind; the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the Psithon; mode. Note; Some PSI4 functions and keywords have aliases. For example,; frequency(), frequencies(), and freq() all work to; obtain vibrational frequencies. Basic Input File Structure¶; PSI4 reads input from a text file, which can be prepared in any standard; text editor. The default input file name is input.dat and the; default output file name is output.dat. So that you can give your; files meaningful names, these defaults can be changed by specifying; the input file name and output file name on the the command line.; The syntax is:; 1>>> psi4 input-name output-name. If you give an input name but no output name, then the output name will; be the same as the input name (replacing any “.in” or “.dat” extension by “.out”). Sample Input Files¶; Below, we will provide a few simple input files as examples. A large; number of sample input files, covering everything from single-point energies; using density-functional theory to response properties from coupled-cluster; theory, can be found in the psi4/samples directory. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 600 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). Note; The memory and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/tutorial-1.html:1514,simpl,simple,1514,psi4manual/1.2.1/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/tutorial-1.html,2,['simpl'],['simple']
Usability,"siAPI mode, you write a pure; Python script with import psi4 at the top and commands are behind; the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the Psithon; mode. Note; Some PSI4 functions and keywords have aliases. For example,; frequency(), frequencies(), and freq() all work to; obtain vibrational frequencies. Basic Input File Structure¶; PSI4 reads input from a text file, which can be prepared in any standard; text editor. The default input file name is input.dat and the; default output file name is output.dat. So that you can give your; files meaningful names, these defaults can be changed by specifying; the input file name and output file name on the the command line.; The syntax is:; 1>>> psi4 input-name output-name. If you give an input name but no output name, then the output name will; be the same as the input name (replacing any ”.in” or ”.dat” extension by ”.out”). Sample Input Files¶; Below, we will provide a few simple input files as examples. A large; number of sample input files, covering everything from single-point energies; using density-functional theory to response properties from coupled-cluster; theory, can be found in the psi4/samples directory. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 600 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). Note; The memory and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:1512,simpl,simple,1512,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,2,['simpl'],['simple']
Usability,"sis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input.; Should needed elements be missing from the best; auxiliary basis or should the orbital basis be unknown to PSI4,; the auxiliary basis will fall back on def2 quad-zeta fitting bases; :source:`psi4/driver/qcdb/libmintsbasisset.py#L762.; Note that if BASIS is known to be larger than quad-zeta,; PSI4 will not attempt to fall back on the def2 fitting bases.; The same basis “block” syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. df_basis_mp2 {; assign cc-pVDZ-RI; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; df_basis_mp2 {; assign C aug-cc-pVDZ-RI; }. Decontracted Basis Sets¶; Decontraction of the basis set can be useful in certain situations. In; order to decontract a given basis set, simply add “-decon” to the name; of the primary basis set (e.g. decontract).; set basis cc-pvdz-decon. Obviously this will add significantly to the computational cost of any given calculation, however it can; be useful when checking the basis set dependence of a particular calculated property or in certain situations; where a large basis set is critical. Currently it is recommended that a decontracted basis is always used when performing relativistic calculations using the X2C Hamiltonian. User-Defined Basis Sets¶. Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. There are three routes by which a basis set in G94 format can be introduced to PSI4‘s notice.; (1) Install new basis set file into PSI4 basis library.; Copy the basis set definitions for all elements into a blank file. Exclamation points denote comments.; As the first line of the file, add the word spherical or cartesian to indicate; whether the basis set wil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/basissets.html:6202,simpl,simply,6202,psi4manual/1.6.x/basissets.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/basissets.html,5,['simpl'],['simply']
Usability,"sisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None, *, quiet=False)¶. Parameters; quiet (bool) – . c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a giv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html:18070,simpl,simply,18070,psi4manual/1.6.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html,1,['simpl'],['simply']
Usability,"ski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/sapt-1.html:2417,simpl,simplest,2417,psi4manual/4.0b2/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html,6,['simpl'],['simplest']
Usability,"sks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user’s perspective, programming was; still relatively difficult because it required modifications to be made in C++; code.; Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; NumPy provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, PSI4 exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate PSI4 functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html:1813,simpl,simpler,1813,psi4manual/1.4.0/prog_ways_to_add-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html,9,['simpl'],['simpler']
Usability,"st attractive contribution is the Disp20; term (2nd order intermolecular dispersion, which looks like an MP2 in which; one excitation is placed on each monomer), contributing an attraction of; -1.21 kcal mol-1. It is not surprising that the electrostatic; contribution is dominant, because the geometry chosen for this example has the; acetylene perpendicular to the ethylene, with the acetylene hydrogen; pointing directly at the double bond in ethylene; this will be attractive; because the H atoms in acetylene bear a partial positive charge, while the; electron-rich double bond in ethylene bears a partial negative charge. At; the same time, the dispersion interaction should be smaller because the; perpendicular geometry does not allow much overlap between the monomers.; Hence, the SAPT analysis helps clarify (and quantify) our physical; understanding about the interaction between the two monomers. Potential Surface Scans and Counterpoise Correction Made Easy with Psithon¶; Finally, let’s consider an example that shows how the Python driver; in PSI4 simplifies some routine tasks. PSI4 can interpret; valid Python code in addition to the computational chemistry directives; we’ve seen in the previous examples; we call this mixture Psithon.; The Python computer language is very easy to pick up, and even users; previously unfamiliar with Python can use it to simplify tasks by; modifying some of the example input files supplied with PSI4; in the psi4/samples directory.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; create separate input files for each distance to be studied. But most of; these input files are identical, except that the interatomic distance is; different. Psithon lets you specify all this in a single input file,; looping over the different distances with an array like this:; Rvals=[2.5, 3.0, 4.0]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:13926,simpl,simplifies,13926,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,8,['simpl'],['simplifies']
Usability,"st attractive contribution is the Disp20; term (2nd order intermolecular dispersion, which looks like an MP2 in which; one excitation is placed on each monomer), contributing an attraction of; -1.21 kcal mol-1. It is not surprising that the electrostatic; contribution is dominant, because the geometry chosen for this example has the; acetylene perpendicular to the ethylene, with the acetylene hydrogen; pointing directly at the double bond in ethylene; this will be attractive; because the H atoms in acetylene bear a partial positive charge, while the; electron-rich double bond in ethylene bears a partial negative charge. At; the same time, the dispersion interaction should be smaller because the; perpendicular geometry does not allow much overlap between the monomers.; Hence, the SAPT analysis helps clarify (and quantify) our physical; understanding about the interaction between the two monomers. Potential Surface Scans and Counterpoise Correction Made Easy with Psithon¶; Finally, let’s consider an example that shows how the Python driver; in PSI4 simplifies some routine tasks. PSI4 can interpret; valid Python code in addition to the computational chemistry directives; we’ve seen in the previous examples; we call this mixture Psithon.; The Python computer language is very easy to pick up, and even users; previously unfamiliar with Python can use it to simplify tasks by; modifying some of the example input files supplied with PSI4; in the psi4/samples directory.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; create separate input files for each distance to be studied. Most of; these input files are identical, except that the interatomic distance is; different. Psithon lets you specify all this in a single input file,; looping over the different distances with an array like this:; Rvals=[2.5, 3.0, 4.0].; L",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:15781,simpl,simplifies,15781,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,15,['simpl'],['simplifies']
Usability,"st attractive contribution is the Disp20; term (2nd order intermolecular dispersion, which looks like an MP2 in which; one excitation is placed on each monomer), contributing an attraction of; -1.21 kcal mol-1. It is not surprising that the electrostatic; contribution is dominant, because the geometry chosen for this example has the; acetylene perpendicular to the ethylene, with the acetylene hydrogen; pointing directly at the double bond in ethylene; this will be attractive; because the H atoms in acetylene bear a partial positive charge, while the; electron-rich double bond in ethylene bears a partial negative charge. At; the same time, the dispersion interaction should be smaller because the; perpendicular geometry does not allow much overlap between the monomers.; Hence, the SAPT analysis helps clarify (and quantify) our physical; understanding about the interaction between the two monomers. Potential Surface Scans and Counterpoise Correction Made Easy with Psithon¶; Finally, let’s consider an example that shows how the Python driver; in Psi4 simplifies some routine tasks. Psi4 can interpret; valid Python code in addition to the computational chemistry directives; we’ve seen in the previous examples; we call this mixture Psithon.; The Python computer language is very easy to pick up, and even users; previously unfamiliar with Python can use it to simplify tasks by; modifying some of the example input files supplied with Psi4; in the psi4/samples directory.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; create separate input files for each distance to be studied. Most of; these input files are identical, except that the interatomic distance is; different. Psithon lets you specify all this in a single input file,; looping over the different distances with an array like this:; Rvals=[2.5, 3.0, 4.0].; L",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:15041,simpl,simplifies,15041,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['simpl'],['simplifies']
Usability,"st ones can be captured reliably. Defaults to 4 guess vectors per root. Warning; Prior to Dec 2022, v1.7, Psi4 had a different set of keywords controlling instability analysis, and those were included in the CPHF module rather than the SCF module. Warning; Extending Davidson instability analysis to Kohn-Sham references is under development. As of 1.7, only LDA functionals are currently supported. In case convergence problems are encountered during the Davidson procedure, file a bug report.; If the solver seems to converge on the wrong eigenvalue, try increasing SOLVER_N_GUESS.; Otherwise, if the solver is almost converged but reaches the maximum number of iterations, try increasing; SOLVER_MAXITER. Effective core potentials (ECPs)¶; PSI4 supports the use of effective core potentials to describe the; innermost electrons in heavy elements.; ECPs are only available if PSI4 is compiled with the LibECPInt library.; If a basis set is designed to use an; effective core potential, the ECP definition should be simply placed alongside; the orbital basis set definition, c.f. Inputting effective core potentials (ECPs). All; information related to the definition and number of core electrons will; automatically be detected and no further input is required to use the; ECP-containing basis set. See scf-ecp and dfmp2-ecp; for examples of computations with ECP-containing basis sets. Warning; Prior to May 2022, v1.6, Psi4 used a built-in ECP code. Analytic derivatives of ECPs were not available. The HF and DFT derivatives were implemented in a semi-numerical scheme, where numerical ECP gradients were added to analytic SCF gradients. For post-SCF methods, the entire gradient computation needed to be run as finite difference of energies. Warning; As of May 2022, v1.6, Psi4 uses the LibECPInt library, and analytic derivatives and Hessians of ECPs are available. Analytic derivatives of molecular systems including ECPs should be available whenever the method has analytic derivatives, but t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/scf.html:42664,simpl,simply,42664,psi4manual/1.7.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/scf.html,4,['simpl'],['simply']
Usability,"st[1] = root[0] = self.__map[key] = [last, root, key]; dict_setitem(self, key, value). def __delitem__(self, key, dict_delitem=dict.__delitem__):; 'od.__delitem__(y) <==> del od[y]'; # Deleting an existing item uses self.__map to find the link which is; # then removed by updating the links in the predecessor and successor nodes.; dict_delitem(self, key); link_prev, link_next, key = self.__map.pop(key); link_prev[1] = link_next; link_next[0] = link_prev. def __iter__(self):; 'od.__iter__() <==> iter(od)'; root = self.__root; curr = root[1]; while curr is not root:; yield curr[2]; curr = curr[1]. def __reversed__(self):; 'od.__reversed__() <==> reversed(od)'; root = self.__root; curr = root[0]; while curr is not root:; yield curr[2]; curr = curr[0]. [docs] def clear(self):; 'od.clear() -> None. Remove all items from od.'; try:; for node in self.__map.itervalues():; del node[:]; root = self.__root; root[:] = [root, root, None]; self.__map.clear(); except AttributeError:; pass; dict.clear(self). [docs] def popitem(self, last=True):; '''od.popitem() -> (k, v), return and remove a (key, value) pair.; Pairs are returned in LIFO order if last is true or FIFO order if false. '''; if not self:; raise KeyError('dictionary is empty'); root = self.__root; if last:; link = root[0]; link_prev = link[0]; link_prev[1] = root; root[0] = link_prev; else:; link = root[1]; link_next = link[1]; root[1] = link_next; link_next[0] = root; key = link[2]; del self.__map[key]; value = dict.pop(self, key); return key, value. # -- the following methods do not depend on the internal structure --. [docs] def keys(self):; 'od.keys() -> list of keys in od'; return list(self). [docs] def values(self):; 'od.values() -> list of values in od'; return [self[key] for key in self]. [docs] def items(self):; 'od.items() -> list of (key, value) pairs in od'; return [(key, self[key]) for key in self]. [docs] def iterkeys(self):; 'od.iterkeys() -> an iterator over the keys in od'; return iter(self). [docs] def ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:3082,clear,clear,3082,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,1,['clear'],['clear']
Usability,"stallation¶; Binary. GDMA is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). If using the PSI4 binary, gdma has already been installed alongside. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; gdma can be obtained through conda install gdma.; Then enable it as a feature with ENABLE_gdma,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect gdma and activate dependent code. To remove a conda installation, conda remove gdma. Source. If using PSI4 built from source and you want gdma built from; from source also,; enable it as a feature with ENABLE_gdma,; and let the build system fetch and build it and activate dependent code. Input¶; The distributed multipole analysis (DMA) technique, developed by Anthony J.; Stone and implemented by him into the GDMA package, is available in PSI4.; The current implementation simply embeds Stone’s GDMA code into the main; executable, and generates the appropriate input files automatically. The; program takes as input a data file, and a Gaussian formatted checkpoint (see; Section FCHK) file. The simplest usage of the GDMA code is; demonstrated below, along with a listing of the options supported; these; options correspond to the options described in the; GDMA manual.; If more advanced usage is desired, which is not is permitted by the options; listed below, the user may provide their own data file containing keywords to; control the GDMA code. Simply place the data file in the directory PSI4; is called from, and provide the file name as the datafile argument to the; gdma() routine. For example, if GDMA data file is called; control.dma, the GDMA code is called as follows:; 1; 2grad, wfn = gradient('mp2', return_wfn=True); gdma(wfn, datafile='control.dma'). An FCHK file will be generated for the GDMA code to read; this file will have; the prefix given by WRITER_FILE_LABEL (if set), or else by the name;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/gdma-1.html:1358,simpl,simply,1358,psi4manual/1.1.0/gdma-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/gdma-1.html,2,['simpl'],['simply']
Usability,"still used and is equivalent to VPT2) generates all cubic constants and all quartic constants apart from those of the form \(\phi_{ijkl}\), which is enough for: 1) generation of cubic constants of isotopologs (see manual entries associated with anharmonic calculations for an example); 2) calculation of vibrational energy levels with VPT2. This keyword also directs the program to analyze resonances and calculate intensities of one- and two-quantum transitions. FULLQUARTIC (=2) (not part of the public release) is largely self-explanatory; it directs the program to calculate all quartic constants. This is sufficient (but this has not been implemented) to generate the full quartic force field of all isotopologs. Type: string; Possible Values: CUBIC, VPT2, FULLQUARTIC, VIBROT, OFF; Default: OFF. CFOUR_ANH_ALGORITHM¶. Specifies which algorithm is used for CFOUR_ANHARMONIC =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations being done in series. If PARALLEL (=1), then the job stops after the second-derivative calculation at the reference geometry and generates out all input geometries for the remaining calculation. These can be then processed in “parallel” (currently not recommended). Note that it is recommended to carry out all calculations with PARALLEL, even when the actual calculation is carried out in a sequential mode. Type: string; Possible Values: STANDARD, PARALLEL; Default: STANDARD. CFOUR_ANH_DERIVATIVES¶. Specifies whether the anharmonic force field is calculated using analytic gradients (=FIRST) or analytic Hessians (=SECOND). Type: string; Possible Values: FIRST, SECOND; Default: SECOND. CFOUR_ANH_STEPSIZE¶. Controls the stepsize used in anharmonic force field calculations. The value is specified in reduced normal coordinates, which are dimensionless. The actual stepsize used in the calculation is \(\times 10^6\) the integer value speci",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:3304,simpl,simply,3304,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,15,['simpl'],['simply']
Usability,"ston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""; The SCF iteration functions; """""". import numpy as np. from psi4.driver import p4util; from psi4.driver import constants; from psi4.driver.p4util.exceptions import SCFConvergenceError, ValidationError; from psi4 import core. from .efp import get_qm_atoms_opts, modify_Fock_permanent, modify_Fock_induced. #import logging; #logger = logging.getLogger(""scf.scf_iterator""); #logger.setLevel(logging.DEBUG). # Q: I expect more local settings of options for part of SCF.; # For convcrit, do we want:; # (A) easy to grep; # with p4util.OptionsStateCM(['SCF', 'E_CONVERGENCE'], ['SCF', 'D_CONVERGENCE']):; # core.set_local_option('SCF', 'E_CONVERGENCE', 1.e-5); # core.set_local_option('SCF', 'D_CONVERGENCE', 1.e-4); # self.iterations(); #; # or (B) functional. options never touched; # self.iterations(e_conv=1.e-5, d_conv=1.e-4). def scf_compute_energy(self):; """"""Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). """"""; if core.get_option('SCF', 'DF_SCF_GUESS') and (core.get_global_option('SCF_TYPE') == 'DIRECT'):; # speed up DIRECT algorithm (recomputes full (non-DF) integrals; # each iter) by first converging via fast DF iterations, then; # fully converging in fewer slow DIRECT iterations. aka Andy trick 2.0; core.print_out("" Starting with a DF guess...\n\n""); with p4util.OptionsStateCM(['SCF_TYPE']):; core.set_global_option('SCF_TYPE', 'DF'); self.initialize(); try:; self.iterations(); except SCFConvergenceError:; self.finalize(); raise SCFConvergenceError(""""""SCF DF preiterations"""""", self.iteration_, self, 0, 0); core.print_out(""\n DF guess converged.\n\n""). # reset the DIIS & JK objects in prep for DIRECT; if self.initialized_diis_manager_:; self.diis_manager().reset_subspace(); self.initialize_jk(self.memory_jk_); else:; self.initialize(). try:; self.iterations(); except SCFConvergenceError as",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:2049,simpl,simply,2049,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['simpl'],['simply']
Usability,"structions at Quick Installation),; the dftd3 executable can be obtained through conda install dftd3 -c psi4; or conda install dftd3-python -c conda-forge.; To remove a conda installation, conda remove dftd3 or conda remove dftd3-python. Source. If using PSI4 built from source and you want to build DFTD3 from; from source also,; follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a; Fortran compiler, and run make). From version 3.1.0 onwards, DFTD3 can; be used as-is; for earlier versions, patches are available:; psi4/psi4/share/psi4/scripts/patch_grimme_dftd3.3.0.2. To be used by PSI4, the classic program binary (dftd3) must be; found in your PATH or the s-dftd3 module in your PYTHONPATH; so QCEngine can detect it. Check if and where found through qcengine info. If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular dftd3 compilation, simply adjust its; position in the path environment variables. Theory¶; The local or semilocal character of conventional density functionals; necessarily leads to neglect of the long-range correlation interactions; which capture attractive van der Waals forces. Initially proposed by Yang; [Wu:2002:515] and assiduously developed by Grimme, [Grimme:2004:1463]; [Grimme:2006:1787] [Grimme:2010:154104] the DFT+Dispersion method; appends to the base functional a scaled, damped, and fitted leading term; to the well-known dispersion energy series, \(E_{disp} = -C_6/R^6; -C_8/R^8 -C_{10}/R^{10}-\cdots\). The DFT-D2 [Grimme:2006:1787] variant; takes the explicit form below. Here, dispersion coefficients,; \(C_6^{ij}\), obtained from the geometric mean of tabulated elemental; values, are summed over interatomic distances, \(R_{ij}\), modulated; by a damping function, \(f_{damp}(R_{ij})\), that gradually activates; the dispersion correction (at a rate characterized by \(\alpha_6\)); over a distance c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:3024,simpl,simply,3024,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,4,['simpl'],['simply']
Usability,"supported keywords differ.; After a more general introduction, specific aspects of the two implementations will be highlighted; in section Interface to adcc and Built-in ADC(2) code. ADC capabilities of Psi4¶. Method; Backend; References; Exc. Energies; Props; Supported values for kind keyword. ADC(1); adcc; RHF, UHF; yes; yes; any, singlet, triplet, spin_flip. ADC(2); adcc; RHF, UHF; yes; yes; any, singlet, triplet, spin_flip. built-in; RHF; yes; —; singlet. ADC(2)-x; adcc; RHF, UHF; yes; yes; any, singlet, triplet, spin_flip. ADC(3); adcc; RHF, UHF; yes; yes | any, singlet, triplet, spin_flip. CVS-ADC(1); adcc; RHF, UHF; yes; yes | any, singlet, triplet. CVS-ADC(2); adcc; RHF, UHF; yes; yes; any, singlet, triplet. CVS-ADC(2)-x; adcc; RHF, UHF; yes; yes; any, singlet, triplet. CVS-ADC(3); adcc; RHF, UHF; yes; yes; any, singlet, triplet. The leftmost column of table ADC capabilities of Psi4 provides the supported ADC methods.; If only excitation energies are desired, one can simply pass one; of the listed method strings to the function energy().; For example, energy('adc(2)-x') will compute; excitation energies at ADC(2)-x level.; Properties such as oscillator strengths, transition or state dipole moments; are available by calling the function properties(); with appropriate arguments.; Most commonly users will want to compute at least oscillator strengths; along with the excitation energies,; resulting in a call like properties('adc(2)', properties=[""oscillator_strength""]). Running ADC calculations¶; Section author: Michael F. Herbst; Running an ADC calculation with PSI4 requires; the call to properties() as discussed above; as well as one or more mandatory keyword arguments.; The most important keyword argument is ROOTS_PER_IRREP,; which is an array with the number of excited states desired; for each irreducible representation. Most ADC methods; are only supported at C1 symmetry at the moment, such that; this option should in most cases be set to an array with a si",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/adc-1.html:4563,simpl,simply,4563,psi4manual/1.4.0/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/adc-1.html,5,['simpl'],['simply']
Usability,"surround it with the; command basis {...}, as shown below. Multiple basis sets can be; specified by adding additional sections within the surrounding brackets.; Use assign statements to actually request the basis set. This; basis {...} section replaces the usual set basis XXX line.; In a more complex input, if the user needs to call the user-defined; basis by name, this can be achieved using the syntax basis mybas {...},; and then the basis can be recalled later as set basis mybas.; To use a custom basis set as described in this section, it must be; defined prior to its use in a function that performs a computation.; basis {. # assign basset to all atoms and addl to hydrogens; assign basset; assign H addl. # basis set section like in snippet above goes here; [basset]; ... # additional basis set sections follow; [addl]; ...; }. The test case mints2 provides a complete example of; user-specified basis sets. Inputting effective core potentials (ECPs)¶; For ECP containing basis sets, all of the above mechanisms may still be used to; input the basis set; simply place the ECP definitions (in G94 format) in the; same file or input section as the orbital basis definition. Because the ECP; appears in the same section as the orbital basis, it will be parsed; automatically and the number of core electrons the ECP represents will be; detected, so no further input is required to use a core potential. See; Effective core potentials (ECPs) for more information about using ECPs and the; Def2-TZVP basis set definition; for an example of their input syntax. table of contents. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Psithon: Structuring an Input File; Basis Sets. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/basissets-1.html:10277,simpl,simply,10277,psi4manual/1.4.0/basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/basissets-1.html,2,['simpl'],['simply']
Usability,"surround it with the; command basis {...}, as shown below. Multiple basis sets can be; specified by adding additional sections within the surrounding brackets.; Use assign statements to actually request the basis set. This; basis {...} section replaces the usual set basis XXX line.; In a more complex input, if the user needs to call the user-defined; basis by name, this can be achieved using the syntax basis mybas {...},; and then the basis can be recalled later as set basis mybas.; To use a custom basis set as described in this section, it must be; defined prior to its use in a function that performs a computation.; basis {. # assign basset to all atoms and addl to hydrogens; assign basset; assign H addl. # basis set section like in snippet above goes here; [basset]; ... # additional basis set sections follow; [addl]; ...; }. The test case mints2 provides a complete example of; user-specified basis sets. Inputting effective core potentials (ECPs)¶; For ECP containing basis sets, all of the above mechanisms may still be used to; input the basis set; simply place the ECP definitions (in G94 format) in the; same file or input section as the orbital basis definition. Because the ECP; appears in the same section as the orbital basis, it will be parsed; automatically and the number of core electrons the ECP represents will be; detected, so no further input is required to use a core potential. See; Effective core potentials (ECPs) for more information about using ECPs and the; Def2-TZVP basis set definition; for an example of their input syntax. table of contents. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Psithon: Structuring an Input File; Basis Sets. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/basissets-1.html:10277,simpl,simply,10277,psi4manual/1.5.0/basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/basissets-1.html,2,['simpl'],['simply']
Usability,"t (Dict[str, psi4.driver.task_base.BaseComputer]). Validators:. set_driver » driver; set_molecule » molecule. field driver: DriverEnum [Required]¶. Validated by:. set_driver. field findifrec: Dict[str, Any] = {}¶. field metameta: Dict[str, Any] = {}¶. field method: str [Required]¶. field molecule: Any = None¶. Validated by:. set_molecule. field task_list: Dict[str, BaseComputer] = {}¶. computer¶; alias of AtomicComputer. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶; Run each job in task list. Parameters:; client (qcportal.FractalClient | None). get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. undisplaced molecule; compute basis if simple, else dummy basis def2-svp; e/g/h member data; QCVariables; module. client (qcportal.FractalClient | None). Returns:. ret – Gradient or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. Return type:; float | Matrix | Tuple[float | Matrix, Wavefunction]. get_results(client=None)[source]¶; Return results as FiniteDifference-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None). Return type:; AtomicResult. plan()[source]¶. validator set_driver  »  driver[source]¶. validator set_molecule  »  molecule[source]¶. table of contents. Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Visualization of Normal Modes; Molden Interface Keywords; NORMAL_MODES_WRITE; WRITER_FILE_LABEL. psi4.driver.qcdb.vib Module; Functions. API; FiniteDifferenceComputer; FiniteDifferenceComputer.driver; FiniteDifferenceComputer.findifrec; FiniteDifferenceComputer.metameta; FiniteDifferenceComputer.method; FiniteDifferenceC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/freq.html:10227,simpl,simple,10227,psi4manual/master/freq.html,https://psicode.org,https://psicode.org/psi4manual/master/freq.html,1,['simpl'],['simple']
Usability,"t *; try:; from collections import OrderedDict; except ImportError:; from .oldpymodules import OrderedDict. [docs]class CoordValue(object):; """"""An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. """""". def __init__(self, fixed=False, computed=False):; # Fixed coordinate?; self.PYfixed = fixed; # Whether the current value is up to date or not; self.computed = computed. [docs] def set_fixed(self, fixed):; """"""Set whether the coordinate value is fixed or not""""""; self.PYfixed = fixed. [docs] def fixed(self):; """"""Get whether the coordinate value is fixed or not""""""; return self.PYfixed. [docs] def invalidate(self):; """"""Flag the current value as outdated""""""; self.computed = False. [docs] def everything(self):; print('\nCoordValue\n Fixed = %s\n Computed = %s\n\n' % (self.PYfixed, self.computed)). [docs]class NumberValue(CoordValue):; """"""Specialization of CoordValue that is simply a number to be stored."""""". def __init__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; return self.value. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordValue object, and returns a string for printing.""""""; return ""%*.*f"" % (precision + 5, precision, self.compute()). [docs] def everything(self):; print('\nNumberValue\n Fixed = %s\n Computed = %s\n Type = %s\n Value = %f\n FValue = %s\n\n' %; (self.PYfixed, self.computed, self.type(), self.value, self.variable_to_string(4))). [docs]class ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:2375,simpl,simply,2375,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,1,['simpl'],['simply']
Usability,"t PSIDATADIR; export PATH=/theoryfs2/ds/cdsgroup/miniconda/envs/tpsi4/bin:$PATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/disk/for/scratch/files. Report problems at http://forum.psicode.org/t/report-conda-update-psi4-oddities-here/32. Nuclear Repulsion Energy..........................................PASSED; SAPT0 Eelst.......................................................PASSED; SAPT0 Eexch.......................................................PASSED; SAPT0 Eind........................................................PASSED; SAPT0 Edisp.......................................................PASSED; SAPT0 Etotal......................................................PASSED. [ COMPLETE ]|#######################################################################################################| 100%. Configure environment. Preceding steps have placed conda and psi4 in your PATH, either permanently through rc-files or temporarily in this terminal session. You can keep or undo these changes. For general psi4 use, you must enable the psi4 executable to be found through any of:. prepending to PATH in shell, ~/.bashrc, ~/.tcshrc, or PBS cmd file; activating the conda environment (p4env above) in shell, ~/.bashrc, or PBS cmd file; supplying full path to executable (shell or PBS cmd file). Similarly, the scratch directory (see Scratch Files and Elementary Restart) must be specified through:. defining PSI_SCRATCH in shell, ~/.bashrc, ~/.tcshrc, or PBS cmd file. Suitable values for these variables have been printed to screen during installation (see last codeblock in step 6). Useful Commands¶. Initially install PSI4 stable release. # equivalent; >>> conda install psi4 -c psi4; >>> conda install psi4 –channel psi4. Initially install PSI4 stable release with non-current python. 1>>> conda install psi4 python=3.6 -c psi4. Update to latest PSI4 stable release. 1>>> conda update psi4 -c psi4. Initially install stable release into a conda environment “p4env” instead ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/conda-1.html:19996,undo,undo,19996,psi4manual/1.2.1/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/conda-1.html,2,['undo'],['undo']
Usability,"t PSIDATADIR; export PATH=/theoryfs2/ds/cdsgroup/miniconda/envs/tpsi4/bin:$PATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/disk/for/scratch/files. Report problems at http://forum.psicode.org/t/report-conda-update-psi4-oddities-here/32. Nuclear Repulsion Energy..........................................PASSED; SAPT0 Eelst.......................................................PASSED; SAPT0 Eexch.......................................................PASSED; SAPT0 Eind........................................................PASSED; SAPT0 Edisp.......................................................PASSED; SAPT0 Etotal......................................................PASSED. [ COMPLETE ]|#######################################################################################################| 100%. Configure environment. Preceding steps have placed conda and psi4 in your PATH, either permanently through rc-files or temporarily in this terminal session. You can keep or undo these changes. For general psi4 use, you must enable the psi4 executable to be found through any of:. prepending to PATH in shell, ~/.bashrc, ~/.tcshrc, or PBS cmd file; activating the conda environment (p4env above) in shell, ~/.bashrc, or PBS cmd file; supplying full path to executable (shell or PBS cmd file). Similarly, the scratch directory (see Scratch Files and Elementary Restart) must be specified through:. defining PSI_SCRATCH in shell, ~/.bashrc, ~/.tcshrc, or PBS cmd file. Suitable values for these variables have been printed to screen during installation (see last codeblock in step 6). Useful Commands¶. Initially install PSI4 stable release. # equivalent; >>> conda install psi4 -c psi4; >>> conda install psi4 –channel psi4. Initially install PSI4 stable release with non-current python. >>> conda install psi4 python=3.6 -c psi4. Update to latest PSI4 stable release. >>> conda update psi4 -c psi4. Initially install stable release into a conda environment “p4env” instead of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/conda-1.html:19996,undo,undo,19996,psi4manual/1.3.2/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/conda-1.html,2,['undo'],['undo']
Usability,"t PSIDATADIR; export PATH=/theoryfs2/ds/cdsgroup/miniconda/envs/tpsi4/bin:$PATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/disk/for/scratch/files. Report problems at http://forum.psicode.org/t/report-conda-update-psi4-oddities-here/32. Nuclear Repulsion Energy..........................................PASSED; SAPT0 Eelst.......................................................PASSED; SAPT0 Eexch.......................................................PASSED; SAPT0 Eind........................................................PASSED; SAPT0 Edisp.......................................................PASSED; SAPT0 Etotal......................................................PASSED. [ COMPLETE ]|#######################################################################################################| 100%. Configure environment. Preceding steps have placed conda and psi4 in your PATH, either permanently through rc-files or temporarily in this terminal session. You can keep or undo these changes. For general psi4 use, you must enable the psi4 executable to be found through any of:. prepending to PATH in shell, ~/.bashrc, ~/.tcshrc, or PBS cmd file; activating the conda environment (p4env above) in shell, ~/.bashrc, or PBS cmd file; supplying full path to executable (shell or PBS cmd file). Similarly, the scratch directory (see Scratch Files and Elementary Restart) must be specified through:. defining PSI_SCRATCH in shell, ~/.bashrc, ~/.tcshrc, or PBS cmd file. Suitable values for these variables have been printed to screen during installation (see last codeblock in step 6). Useful Commands¶. Update to latest PSI4 version; 1>>> conda update psi4. Install into a conda environment “p4env” instead of “root”. Second command only works on bash; for csh/tsch, setenv PATH /path/to/miniconda/envs/p4env/bin:$PATH instead. This creates a sandbox with just PSI4 and python (loaded as dependency).; 1; 2>>> conda create -y -n p4env psi4; >>> source activate p4env. Install a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/conda-1.html:17582,undo,undo,17582,psi4manual/1.1.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/conda-1.html,2,['undo'],['undo']
Usability,"t calculation. run_psimrcc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. run_psimrcc_scf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. run_sapt(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a SAPT calculation of any level. run_sapt_ct(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. run_scf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation. run_scf_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a SCF gradient calculation. run_scf_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to run_scf(); since SCF properties all handled through oeprop. run_scs_omp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a spin-component scaled OMP2 computation. run_scs_omp3(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a spin-component scaled OMP3 computation. run_sos_omp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a spin-opposite scaled OMP2 computation. run_sos_omp3(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a spin-opposite scaled OMP3 computation. scf_helper(name, **kwargs)[source]¶; Function serving as helper to SCF, choosing whether to cast; up or just run SCF with a standard guess. This preserves; previous SCF options set by other procedures (e.g., SAPT; output file types for SCF). dashparam¶; Module to hold and distribute the -D dispersion correction parameters. dash_server(func, dashlvl, mode='psi4')[source]¶; Function to serve up dispersion correction paramete",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:14198,simpl,simple,14198,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,4,['simpl'],['simple']
Usability,"t each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; docstring. clear(self: psi4.core.Prop) → None¶; docstring. compute(self: psi4.core.OEProp) → None¶; docstring. set_Da_ao(self: psi4.core.Prop, Da: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Da_mo(self: psi4.core.Prop, arg0: psi::Matrix) → None¶; docstring. set_Da_so(self: psi4.core.Prop, arg0: psi::Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.Prop, Db: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Db_mo(self: psi4.core.Prop, arg0: psi::Matrix) → None¶; docstring. set_Db_so(self: psi4.core.Prop, arg0: psi::Matrix) → None¶; docstring. Exvals(self: psi4.core.OEProp) → List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None; docstring. clear(self: psi4.core.Prop) → None; docstring. compute(self: psi4.core.OEProp) → None; docstring. set_Da_ao(self: psi4.core.Prop, Da: psi::Matrix, symmetry: int=0) → None; docstring. set_Da_mo(self: psi4.core.Prop, arg0: psi::Matrix) → None; docstring. set_Da_so(self: psi4.core.Prop, arg0: psi::Matrix) → None; docstring. set_Db_ao(self: psi4.core.Prop, Db: psi::Matrix, symmetry: int=0) → None; docstring. set_Db_mo(self: psi4.core.Prop, arg0: psi::Matrix) → None; docstring. set_Db_so(self: psi4.core.Prop, arg0: psi::Matrix) → None; docstring. set_title(self: psi4.core.Prop, arg0: str) → None¶; docstring. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.oeprop.html:2605,clear,clear,2605,psi4manual/1.1.0/api/psi4.core.oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.oeprop.html,1,['clear'],['clear']
Usability,"t it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Array function, including NumPy interface and Python extensions to core array; classes:. - Matrix (constructor, view, access, serialization); - Vector (constructor, view, access, serialization); - Dimension (constructor); - CIVector (view); """""". __all__ = [; ""array_to_matrix"",; ""block_diagonal_array"",; ]. import sys; from typing import Any, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]; def array_to_matrix(; self: Union[core.Matrix, core.Vector],; arr: Union[np.ndarray, List[np.ndarray]],; name: str = ""New Matrix"",; dim1: Optional[Union[List, Tuple, core.Dimension]] = None,; dim2: Optional[core.Dimension] = None,; ) -> Union[core.Matrix, core.Vector]:; """"""; Converts a `NumPy array; <https://numpy.org/doc/stable/reference/arrays.nda",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:1691,simpl,simple,1691,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,1,['simpl'],['simple']
Usability,"t it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Array function, including NumPy interface and Python extensions to core array; classes:. - Matrix (constructor, view, access, serialization); - Vector (constructor, view, access, serialization); - Dimension (constructor); - CIVector (view); """""". __all__ = [; ""array_to_matrix"",; ""block_diagonal_array"",; ]. import sys; from typing import Any, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]def array_to_matrix(; self: Union[core.Matrix, core.Vector],; arr: Union[np.ndarray, List[np.ndarray]],; name: str = ""New Matrix"",; dim1: Optional[Union[List, Tuple, core.Dimension]] = None,; dim2: Optional[core.Dimension] = None,; ) -> Union[core.Matrix, core.Vector]:; """"""; Converts a `NumPy array; <https://numpy.org/doc/stable/reference/arrays.ndarr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:1689,simpl,simple,1689,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,1,['simpl'],['simple']
Usability,"t spaces or underscores, in the directory name. This directory will need two files. The first is CMakeLists.txt, which is necessary to add the test case to the suite. This file should have the following lines:; include(TestingMacros). add_regression_test(directory_name ""psi;semicolon_separated-list-of-applicable-test-labels""). The labels specify which groups of tests include the test case. The psi label should always be added, but the other labels are test-specific. The method tested should always be included, and this is often sufficient. If adding a test for an already existing module, the labels for other tests of the module will suggest other labels to add.; A test requiring over 15 minutes should be labeled longtests. A short test under 30 seconds used for general bug checking should be labeled quicktests. A test that confirms PSI4 is operational should be labeled smoketests.; The other necessary file is the input file itself, input.dat. The input file should be just a simple input file to run the test, with small additions.; #! RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxiliary basis.; #! Also a bit more to force a second line. nucenergy = 8.801466202085710 #TEST; refenergy = -76.05098402733282 #TEST. molecule h2o {; symmetry c1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pVTZ; scf_type df; df_basis_scf cc-pVTZ-RI; e_convergence 10; }. thisenergy = energy(""hf""). compare_values(nucenergy, h2o.nuclear_repulsion_energy(), 9, ""Nuclear repulsion energy"") #TEST; compare_values(refenergy, thisenergy, 9, ""Reference energy"") #TEST; compare_values(refenergy, get_variable('scf total energy'), 9, ""Reference energy"") #TEST. Of those small modifications, first, note the special comment at the top (starting with the #! comment marker). This should be descriptive since it is inlined into the manual (unless !nosample in the comment) as a sample input.; The reference values are assigned to variables for later use. The compare_values function (along",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/add_tests-1.html:1219,simpl,simple,1219,psi4manual/1.4.0/add_tests-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/add_tests-1.html,4,['simpl'],['simple']
Usability,"t there’s a special comment immediately before the; declaration of each keyword. You must provide these comments for any; options you add as they will be automatically inserted into the user; manual Providing a clear description will also help you to remember what; the keywords do and how they’re used. The comments must live between the; special comment delimiters. For options that most users shouldn’t need,; add an expert flag to the comment. This will place these options in a; separate section of the user manual.; /*- comment -*/; options.add_ ...; /*- comment !expert -*/; options.add_ ... As is apparent from the examples above, comments can span multiple lines; (see PRINT), can refer to other options (through hyperlinks; see; SAVE_INFO), can refer to sections of the manual (through hyperlinks;; see DOCC), and can contain LaTeX notation (see AO_BASIS). (To get; the LaTeX subscript command, use “@@” instead of “_”.); See How to name keywords in psi4/src/read_options.cc; for guidelines on naming options. What is has_changed ?¶; There are times when we need to know whether an option was provided by the; user or if the defaults are being used. For this reason, the Options; object stores a boolean has_changed value, in addition to the option; value itself. A clarification of definition:. [a] has_changed DOESN’T answer “Has option been changed by the user?”; [b] has_changed DOESN’T answer “Is option now different from the default?”; [c] has_changed DOES answer “Has option value been touched at all, by user or code?”. The above items notwithstanding, psi4 code should be written so that; has_changed DOES effectively mean, “Has option been changed by the; user?”. The way to do this is to isolate and nullify any changes to; options made by the code, the difference between [a] and [c]. C-side,; there is no concern since options are essentially read-only; within the modules.; Py-side is another matter since the driver’s role is to take terse; instructions from the user and tra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optionshandling-1.html:4229,guid,guidelines,4229,psi4manual/1.4.0/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optionshandling-1.html,9,['guid'],['guidelines']
Usability,"t(; **{; 'driver': self.driver,; #'keywords': self.keywords,; 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=assembled_results[""module""]),; 'extras': {; 'qcvars': qcvars,; 'cbs_record': copy.deepcopy(self.cbsrec),; },; 'return_result': assembled_results['ret_ptype'],; 'success': True,; }). logger.debug('CBS QCSchema\n' + pp.pformat(cbs_model.dict())). return cbs_model. [docs] def get_psi_results(self, return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables; - module if simple. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; cbs_model = self.get_results(). if cbs_model.driver == 'energy':; ret_ptype = cbs_model.return_result; else:; ret_ptype = core.Matrix.from_array(cbs_model.return_result); wfn = _cbs_schema_to_wfn(cbs_model). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _cbs_schema_to_wfn(cbs_model):; """"""Helper function to produce Wavefunction from a Composite-flavored AtomicResult."""""". mol = core.Molecule.from_schema(cbs_model.molecule.dict()); basis = core.BasisSet.build(mol, ""ORBITAL"", 'def2-svp', quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(cbs_model.provenance, ""module""):; wfn.set_module(cbs_model.provenance.module). # wfn.set_energy(cbs_model['extras'['qcvars'].get('CBS TOTAL ENERGY')) # catches Wfn.energy_; for qcv, val in cbs_model.extras['qcvars'].items():; for ob",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:61077,simpl,simple,61077,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,1,['simpl'],['simple']
Usability,"t(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); # component qcvars can be retired at v1.5; for xyz in 'XYZ':; obj.set_variable('CURRENT DIPOLE ' + xyz, obj.variable('SCF DIPOLE ' + xyz)); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(""SCF"", ""MOLDEN_WRITE""):; filename = core.get_writer_file_prefix(scf_molecule.name()) + "".molden""; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). occa = scf_wfn.occupation_a(); occb = scf_wfn.occupation_a(). mw = core.MoldenWriter(scf_wfn); mw.write(filename, scf_wfn.Ca(), scf_wfn.Cb(), scf_wfn.epsilon_a(),; scf_wfn.epsilon_b(), scf_wfn.occupation_a(),; scf_wfn.occupation_b(), dovirt). # Write checkpoint file (orbitals and basis); Can be disabled, e.g., for findif displacements; if write_checkpoint_file and isinstance(_chkfile, str):; filename = kwargs['write_orbitals']; scf_wfn.to_file(filename); # core.set_local",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:49124,simpl,simplefilter,49124,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['simpl'],['simplefilter']
Usability,"t(item for item in reversed(xvals) if item is not None); # except StopIteration:; # pass; # else:; # ax.text(toplblposn, -0.75 + 0.6 * random(), rxn['sys'],; # verticalalignment='bottom', horizontalalignment='center',; # family='Times New Roman', fontsize=8); # ax.text(botlblposn, -1 * Nweft - 0.75 + 0.6 * random(), rxn['sys'],; # verticalalignment='bottom', horizontalalignment='center',; # family='Times New Roman', fontsize=8); #; # # plot trimmings; # if mae is not None:; # ax.plot([-x for x in mae], positions, 's', color='black'); # if mape is not None: # equivalent to MAE for a 10 kcal/mol IE; # ax.plot([0.025 * x for x in mape], positions, 'o', color='black'); #; # plt.axvline(0, color='black'); # plt.show(). [docs]def threads(data, labels, color=None, title='', xlimit=4.0, mae=None, mape=None,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; labeled=True, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Generates a tiered slat diagram between model chemistries with; errors (or simply values) in list *data*, which is supplied as part of the; dictionary for each participating reaction, along with *dbse* and *rxn* keys; in argument *data*. The plot is labeled with *title* and each tier with; an element of *labels* and plotted at *xlimit* from the zero-line. If; *color* is None, slats are black, if 'sapt', colors are taken from *color*; key in *data* [0, 1]. Summary statistics *mae* are plotted on the; overbound side and relative statistics *mape* on the underbound side.; HTML code for mouseover if mousetext or mouselink or mouseimag specified; based on recipe of Andrew Dalke from; http://www.dalkescientific.com/writings/diary/archive/2005/04/24/interactive_html.html. """"""; import random; import hashlib; import matplotlib.pyplot as plt; import numpy as np # only needed for missing data with mouseiness. # initialize tiers/wefts; Nweft = len(labels); lenS = 0.2; gapT = 0.04; positions = range(-1, -1 * Nweft - 1, -1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:16590,simpl,simply,16590,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['simpl'],['simply']
Usability,"t, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]¶; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]¶; Serializes instance into dictionary according to schema dtype. to_string(dtype, units=None, atom_format=None, ghost_format=None, width=17, prec=12)[source]¶; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int) → int¶; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule) → str¶; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int) → float¶; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int) → psi4.core.Vector3¶; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int) → float¶; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int) → float¶; z position [Bohr] of atom arg0 (0-indexed without dummies). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; Molecule. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.molecule.html:37078,clear,clearing,37078,psi4manual/1.4.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.molecule.html,1,['clear'],['clearing']
Usability,"t, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]¶; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]¶; Serializes instance into dictionary according to schema dtype. to_string(dtype, units=None, atom_format=None, ghost_format=None, width=17, prec=12)[source]¶; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int) → int¶; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule) → str¶; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int) → float¶; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int) → psi4.core.Vector3¶; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int) → float¶; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int) → float¶; z position [Bohr] of atom arg0 (0-indexed without dummies). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; Molecule. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html:38715,clear,clearing,38715,psi4manual/1.5.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.molecule.html,1,['clear'],['clearing']
Usability,"t, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008).; (doi: 10.1063/1.2834927). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009).; (doi: 10.1039/b822910d). Symmetry-Adapted Perturbation Theory (SAPT)¶; PSI4 features an extremely efficient code to perform wavefunction-based; Symmetry Adapted Perturbation Theory (SAPT). A good review article for this; method is as follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994).; (doi: 10.1021/cr00031a008). PSI4 benefits enormously from the introduction of density fitting (DF); into SAPT. There are several SAPT truncations available in PSI4. For; guidance on which one to choose, see the SAPT section of the manual; and refer to the following systematic study:. “Levels of Symmetry Adapted Perturbation Theory (SAPT). I. Efficiency and; Performance for Interaction Energies,’’ T. M. Parker, L. A. Burns, R. M.; Parrish, A. G. Ryno, and C. D. Sherrill, J. Chem. Phys. 140,; 094106 (2014).; (doi: 10.1063/1.4867135). The theory and implementation of DF-SAPT is discussed; in the following papers for various levels of SAPT.; DF-SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; (doi: 10.1063/1.3656681).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of \(\pi - \pi\) Interactions in Linear Acenes,”; E. G. Hohenstein and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:9714,guid,guidance,9714,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,15,['guid'],['guidance']
Usability,"t, W. D. Allen,; H. F. Schaefer, and J. Gauss, J. Chem. Phys. 128, 124104; (2008).; (doi: 10.1063/1.2834927). Mk-MRPT2. “A Companion Perturbation Theory for State-specific; Multireference Coupled Cluster Methods,”; F. A. Evangelista, A. C. Simmonett, H. F. Schaefer, D. Mukherjee, and; W. D. Allen,; Phys. Chem. Chem. Phys. 11, 4728-4741 (2009).; (doi: 10.1039/b822910d). Symmetry-Adapted Perturbation Theory (SAPT)¶; Psi4 features an extremely efficient code to perform wavefunction-based; Symmetry Adapted Perturbation Theory (SAPT). A good review article for this; method is as follows:. “Perturbation Theory Approach to Intermolecular Potential Energy; Surfaces of van der Waals Complexes,” B. Jeziorski, R. Moszynski,; and K. Szalewicz, Chem. Rev. 94, 1887-1930 (1994).; (doi: 10.1021/cr00031a008). Psi4 benefits enormously from the introduction of density fitting (DF); into SAPT. There are several SAPT truncations available in Psi4. For; guidance on which one to choose, see the SAPT section of the manual; and refer to the following systematic study:. “Levels of Symmetry Adapted Perturbation Theory (SAPT). I. Efficiency and; Performance for Interaction Energies,’’ T. M. Parker, L. A. Burns, R. M.; Parrish, A. G. Ryno, and C. D. Sherrill, J. Chem. Phys. 140,; 094106 (2014).; (doi: 10.1063/1.4867135). The theory and implementation of DF-SAPT is discussed; in the following papers for various levels of SAPT.; DF-SAPT0. “Large-scale Symmetry-adapted Perturbation Theory Computations via; Density Fitting and Laplace Transformation Techniques: Investigating the; Fundamental Forces of DNA-Intercalator Interactions,” E. G. Hohenstein,; R. M. Parrish, C. D. Sherrill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; (doi: 10.1063/1.3656681).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/introduction-1.html:7924,guid,guidance,7924,psi4manual/1.0.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/introduction-1.html,2,['guid'],['guidance']
Usability,t-in function). psi4.MultipoleInt.compute_shell() (built-in function). psi4.MultipoleInt.origin() (built-in function). psi4.MultipoleInt.py_buffer() (built-in function). psi4.MultipoleInt.py_buffer_object() (built-in function). psi4.MultipoleInt.set_enable_pybuffer() (built-in function). psi4.MultipoleSymmetry.create_matrices() (built-in function). psi4.NablaInt.basis() (built-in function). psi4.NablaInt.basis1() (built-in function). psi4.NablaInt.basis2() (built-in function). psi4.NablaInt.compute_shell() (built-in function). psi4.NablaInt.origin() (built-in function). psi4.NablaInt.py_buffer() (built-in function). psi4.NablaInt.py_buffer_object() (built-in function). psi4.NablaInt.set_enable_pybuffer() (built-in function). psi4.NBOWriter.write() (built-in function). psi4.new_wavefunction() (built-in function). psi4.nthread() (built-in function). psi4.nuclear_dipole() (built-in function). psi4.occ() (built-in function). psi4.OEProp.add() (built-in function). psi4.OEProp.clear() (built-in function). psi4.OEProp.compute() (built-in function). psi4.OEProp.set_Da_ao() (built-in function). psi4.OEProp.set_Da_mo() (built-in function). psi4.OEProp.set_Da_so() (built-in function). psi4.OEProp.set_Db_ao() (built-in function). psi4.OEProp.set_Db_mo() (built-in function). psi4.OEProp.set_Db_so() (built-in function). psi4.OEProp.set_title() (built-in function). psi4.OneBodyAOInt.basis() (built-in function). psi4.OneBodyAOInt.basis1() (built-in function). psi4.OneBodyAOInt.basis2() (built-in function). psi4.OneBodyAOInt.compute_shell() (built-in function). psi4.OneBodyAOInt.origin() (built-in function). psi4.OneBodyAOInt.py_buffer() (built-in function). psi4.OneBodyAOInt.py_buffer_object() (built-in function). psi4.OneBodyAOInt.set_enable_pybuffer() (built-in function). psi4.opt_clean() (built-in function). psi4.optking() (built-in function). psi4.OrbitalSpace.basisset() (built-in function). psi4.OrbitalSpace.build_cabs_space() (built-in function). psi4.OrbitalSpace.build_ri_sp,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:99548,clear,clear,99548,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['clear'],['clear']
Usability,"t2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def _to_array(matrix: Union[core.Matrix, core.Vector], copy: bool = True, dense: bool = False) -> Union[np.ndarray, List[np.ndarray]]:; """"""; Converts a Psi4 Matrix or Vector to a NumPy array. Either copies the data or simply; constructs a view. Parameters; ----------; matrix; Pointers to which Psi4 core class should be used in the construction.; copy; Copy the data if `True`, return a view otherwise; dense; Converts irreped Psi4 objects to diagonally blocked dense arrays if `True`. Returns a list of arrays otherwise. Returns; -------; numpy.ndarray; Returns either a list of np.array's or the base array depending on options. Notes; -----; This is a generalized function to convert a Psi4 object to a NumPy array. Examples; --------. >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. matrix_views = _get_raw_views(matrix, copy=copy). # Return the list of arrays; if dense is False:; return matrix_views. # Build the dense matrix; if isinstance(matrix, core.Vector):; ret_type = '1D'; elif isinstance(matrix, core.Matrix):; ret_type = '2D'; else:; raise ValidationErr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:5720,simpl,simply,5720,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,3,['simpl'],['simply']
Usability,"take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1; 3 1.000000. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; F 1 3; R 1 2 1.70; R 1 3 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:9720,simpl,simplest,9720,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,21,['simpl'],"['simple', 'simplest', 'simply']"
Usability,"tart1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); view = _get_raw_views(ret)[0]; view[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError (""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def _to_array(matrix, copy=True, dense=False):; """"""; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters; ----------; matrix : :py:class:`~psi4.core.Matrix` or :py:class:`~psi4.core.Vector`; Pointers to which Psi4 core class should be used in the construction.; copy : bool; Copy the data if True, return a view otherwise; dense : bool; Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns; -------; array : np.array or list of of np.array; Returns either a list of np.array's or the base array depending on options. Notes; -----; This is a generalized function to convert a Psi4 object to a NumPy array. Examples; --------. >>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. ret = _get_raw_views(matrix, copy=copy). # Return the list of arrays; if dense is False:; return ret. # Build the dense matrix; if isinstance(matrix, core.Vector):; ret_type = '1D'; elif isinst",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html:6320,simpl,simply,6320,psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,1,['simpl'],['simply']
Usability,taticInt.origin() (built-in function). psi4.ElectrostaticInt.py_buffer() (built-in function). psi4.ElectrostaticInt.py_buffer_object() (built-in function). psi4.ElectrostaticInt.set_enable_pybuffer() (built-in function). psi4.ErfComplementERI.compute_shell() (built-in function). psi4.ErfComplementERI.py_buffer() (built-in function). psi4.ErfComplementERI.py_buffer_object() (built-in function). psi4.ErfComplementERI.set_enable_pybuffer() (built-in function). psi4.ErfERI.compute_shell() (built-in function). psi4.ErfERI.py_buffer() (built-in function). psi4.ErfERI.py_buffer_object() (built-in function). psi4.ErfERI.set_enable_pybuffer() (built-in function). psi4.ERI.compute_shell() (built-in function). psi4.ERI.py_buffer() (built-in function). psi4.ERI.py_buffer_object() (built-in function). psi4.ERI.set_enable_pybuffer() (built-in function). psi4.ExternalPotential.addBasis() (built-in function). psi4.ExternalPotential.addCharge() (built-in function). psi4.ExternalPotential.clear() (built-in function). psi4.ExternalPotential.computePotentialMatrix() (built-in function). psi4.ExternalPotential.print_out() (built-in function). psi4.ExternalPotential.setName() (built-in function). psi4.F12.compute_shell() (built-in function). psi4.F12.py_buffer() (built-in function). psi4.F12.py_buffer_object() (built-in function). psi4.F12.set_enable_pybuffer() (built-in function). psi4.F12DoubleCommutator.compute_shell() (built-in function). psi4.F12DoubleCommutator.py_buffer() (built-in function). psi4.F12DoubleCommutator.py_buffer_object() (built-in function). psi4.F12DoubleCommutator.set_enable_pybuffer() (built-in function). psi4.F12G12.compute_shell() (built-in function). psi4.F12G12.py_buffer() (built-in function). psi4.F12G12.py_buffer_object() (built-in function). psi4.F12G12.set_enable_pybuffer() (built-in function). psi4.F12Squared.compute_shell() (built-in function). psi4.F12Squared.py_buffer() (built-in function). psi4.F12Squared.py_buffer_object() (built-in function). psi4.,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:77827,clear,clear,77827,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['clear'],['clear']
Usability,"tations require that the molecule is not reoriented; this can be; achieved by adding either no_reorient or noreorient. By default,; Ångström units are used; this is changed by adding a line that reads; units spec, where spec is one of ang,; angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html:7368,intuit,intuitive,7368,psi4manual/4.0b3/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html,2,['intuit'],['intuitive']
Usability,"tations require that the molecule is not; reoriented; this can be achieved by adding either no_reorient or; noreorient. By default, Ångström units are used; this is changed by; adding a line that reads units spec, where spec is one; of ang, angstrom, a.u., au, or bohr. Ghost Atoms¶; While many common computations, such as SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer, with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Geometries from the PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:9075,intuit,intuitive,9075,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['intuit'],['intuitive']
Usability,"ted > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); else:; raise ValidationError(""""""Unknown excited-state CC wave function.""""""); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); # Tight convergence unnecessary for transition properties; core.set_local_option('CCLAMBDA', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'E_CONVERGENCE', 1e-5); core.cceom(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). if n_one > 0:; # call oe prop for GS density; oe = core.OEProp(ccwfn); oe.set_title(name.upper()); for oe_name in one:; oe.add(oe_name.upper()); oe.compute(); # call oe prop for each ES density; if name.startswith('eom'):; # copy GS CC DIP/QUAD ... to CC ROOT 0 DIP/QUAD ... if we are doing multiple roots; # retire components at v1.5; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE X"", core.variable(""CC DIPOLE X"")); core.set_variable(""CC ROOT 0 DIPOLE Y"", core.variable(""CC DIPOLE Y"")); core.set_variable(""CC ROOT 0 DIPOLE Z"", core.variable(""CC DIPOLE Z"")); if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE XX"", core.variable(""CC QUADRUPOLE XX"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XY"", core.variable(""CC QUADRUPOLE XY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE XZ"", core.variable(""CC QUADRUPOLE XZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YY"", core.variable(""CC QUADRUPOLE YY"")); core.set_variable(""CC ROOT 0 QUADRUPOLE YZ"", core.variable(""CC QUADRUPOLE YZ"")); core.set_variable(""CC ROOT 0 QUADRUPOLE ZZ"", core.variable(""CC QUADRUPOLE ZZ"")); if 'dipole' in one:; core.set_variable(""CC ROOT 0 DIPOLE"", core.variable(""CC DIPOLE"")); # core.set_variable(""CC ROOT n DIPOLE"", core.variable(""CC DIPOLE"")) # P::e CCENERGY; if 'quadrupole' in one:; core.set_variable(""CC ROOT 0 QUADRUPOLE"", core.variable(""C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:100609,simpl,simplefilter,100609,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['simpl'],['simplefilter']
Usability,"ted. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:5180,simpl,simple,5180,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,5,['simpl'],['simple']
Usability,"ted. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coord",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/optking-1.html:4934,simpl,simple,4934,psi4manual/4.0b2/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html,8,['simpl'],['simple']
Usability,"ted. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:5192,simpl,simple,5192,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,2,['simpl'],['simple']
Usability,"tein:2012:WIREs] with the jun-cc-pVDZ basis (this is the; usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and; without diffuse \(d\) functions on heavy atoms) [Papajak:2011:10]. So,; we’ll use that as our standard basis set. The SAPT code is designed to; use density fitting techniques, because they introduce minimal errors; while providing much faster computations [Hohenstein:2010:184111]; [Hohenstein:2010:014101]. Since we’re using density fitting for the SAPT,; we might as well also use it for the Hartree–Fock computations that are; performed as part of the SAPT. We can specify that with; scf_type DF.; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, PSI4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that PSI4 correctly guesses that we want the jun-cc-pVDZ-JKFIT; auxiliary basis for the Hartree–Fock, and the jun-cc-pVDZ-RI basis set; for the SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons with freeze_core True. The SAPT; procedure is invoked with the simple call, energy('sapt0'). This; call knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in addition; to the total SAPT0 interaction energy. An explanation of the various; energy components can be found in the review by Jeziorski, Moszynski, and; Szalewicz [Jeziorski:1994:1887], and this is discussed in more detail; in the SAPT section later in this manual. For now, we’ll note that most of; the SAPT energy components are negative; this means those are attractive; contributions (the zero of energy in a SAPT computation is defined a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:13205,simpl,simple,13205,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,15,['simpl'],['simple']
Usability,"the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an examp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/quickadddatabase-1.html:1152,simpl,simply,1152,psi4manual/1.1.0/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/quickadddatabase-1.html,6,['simpl'],['simply']
Usability,"the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry filesAssemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/quickadddatabase-1.html:1173,simpl,simply,1173,psi4manual/1.4.0/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/quickadddatabase-1.html,9,['simpl'],['simply']
Usability,"the cc-pVDZ basis set by passing the method/basis set as a string ('scf/cc-pvdz') into the function psi4.energy(); API:. [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section :psicode:[Compiling and Installing from Source] <psi4manual/master/build_planning.html> .; This very simple input is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin multiplicity (1 for a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program correctly guessed all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not all the electrons are paired. For example, let’s run a computation on methylene (\(\text{CH}_2\)), whose ground electronic state has two unpaired electrons (triplet electronic state, or a spin multiplicity \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is not correct, so we need to tell the program the true value (3). Like many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psiapi.html:4284,simpl,simple,4284,psi4manual/1.6.x/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html,3,['simpl'],['simple']
Usability,"the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Array function, including NumPy interface and Python extensions to core array; classes:. - Matrix (constructor, view, access, serialization); - Vector (constructor, view, access, serialization); - Dimension (constructor); - CIVector (view); """""". __all__ = [; ""array_to_matrix"",; ""block_diagonal_array"",; ]. from typing import Any, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]; def array_to_matrix(; self: Union[core.Matrix, core.Vector],; arr: Union[np.ndarray, List[np.ndarray]],; name: str = ""New Matrix"",; dim1: Optional[Union[List, Tuple, core.Dimension]] = None,; dim2: Optional[core.Dimension] = None,; ) -> Union[core.Matrix, core.Vector]:; """"""; Converts a `NumPy array; <https://numpy.org/doc/stable/reference/arrays.nda",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html:1679,simpl,simple,1679,psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,2,['simpl'],['simple']
Usability,"the index. Note we didn’t need to specify ghost atoms, and we didn’t need; to call the monomer and dimer computations separately. The built-in; Psithon function cp() does it all for us, automatically.; And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol, which is; defined in Sec. Scratch Files and the ~/.psi4rc File. Notice the loop over to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. Table Of Contents. A PSI4 Tutorial; Basic Input File Structure; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. Previous topic; Introduction; Next topic; Configuration: Preparing PSI4’s Environment; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:19609,simpl,simple,19609,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,4,"['clear', 'simpl']","['clear', 'simple']"
Usability,"the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:9586,simpl,simple,9586,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,8,['simpl'],['simple']
Usability,"the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within Psi4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:10154,simpl,simple,10154,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['simpl'],['simple']
Usability,"the; charge-transfer results:; 1; 2; 3; 4; 5 SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (i.e., each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (i.e., each monomer utilizes only its; own basis set). It is also possible to run a closed-shell SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; sapt_basis='monomer' to the energy function, such as; 1energy('sapt2',sapt_basis='monomer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. The open-shell SAPT0 code is not; compatible yet with monomer-centered computations. Computations with Mid-bonds¶; SAPT computations with midbonds can be accomplished by adding a third ghost; monomer to the computation. For example; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10molecule dimer {; 0 1; He 0 0 5; --; 0 1; He 0 0 -5; --; 0 1; @He 0 0 0; }. Here the functions of the third monomer will be added to the virtual space of; the entire computation. Note that an error will be thrown if each atom in the; third monomer is not a ghost to prevent confusion with three-body SAPT which is; not currently supported by Psi4. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/sapt-1.html:26504,simpl,simply,26504,psi4manual/1.2.1/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/sapt-1.html,4,['simpl'],['simply']
Usability,"the; charge-transfer results:; 1; 2; 3; 4; 5 SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (i.e., each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (i.e., each monomer utilizes only its; own basis set). It is also possible to run a closed-shell SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; sapt_basis='monomer' to the energy function, such as; 1energy('sapt2',sapt_basis='monomer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. The open-shell SAPT0 code is not; compatible yet with monomer-centered computations. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat_orbs_t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:26197,simpl,simply,26197,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,2,['simpl'],['simply']
Usability,"thout even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Plan, run, and assemble QC tasks to obtain composite method, basis, & options treatments. ========; CBS Flow; ========; Bullet points are major actions; Lines of dashes denote function calls; stage: scf, corl, delta1, delta2, ...; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian. cbs_text_parser(); -----------------; * called from task_planner() only if ""/"" in method. _parse_cbs_gufunc_string(); --------------------------; * break user string into paired method and basis stages. * transform user string into cbs kwargs inc'l basic cbs_metadata; cbs kwargs may signal simple method/basis single point -or- a modelchem requiring CompositeComputer. ----------------------------; CompositeComputer.__init__(); ----------------------------. _process_cbs_kwargs(); ---------------------; * if input is cbs_metadata dict, skip to _validate_cbs_inputs(); * otherwise, transform user kwargs into trial cbs_metadata format (aka dict spec). _validate_cbs_inputs(); ----------------------. _get_default_xtpl(); -------------------; * supply default xtpl fn for stage and basis conditions. _expand_bracketed_basis(); -------------------------; * parse and validate user bases. * check and supply defaults for cbs_metadata format (various calls to above two fns). * BaseComputer.__init__(). _build_cbs_compute(); --------------------. _expand_scheme_orders(); -----------------------; * form f_fields dict of entries for each zeta in a scheme (single NEED; entries related by nonlinear fn; (that is, constructing the CBS energy from the component energies is nonlinear)). _con",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:1715,simpl,simple,1715,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,5,['simpl'],['simple']
Usability,"thylene, with the acetylene hydrogen; pointing directly at the double bond in ethylene; this will be attractive; because the H atoms in acetylene bear a partial positive charge, while the; electron-rich double bond in ethylene bears a partial negative charge. At; the same time, the dispersion interaction should be smaller because the; perpendicular geometry does not allow much overlap between the monomers.; Hence, the SAPT analysis helps clarify (and quantify) our physical; understanding about the interaction between the two monomers. Potential Surface Scans and Counterpoise Correction Made Easy with Psithon¶; Finally, let’s consider an example that shows how the Python driver; in PSI4 simplifies some routine tasks. PSI4 can interpret; valid Python code in addition to the computational chemistry directives; we’ve seen in the previous examples; we call this mixture Psithon.; The Python computer language is very easy to pick up, and even users; previously unfamiliar with Python can use it to simplify tasks by; modifying some of the example input files supplied with PSI4; in the psi4/samples directory.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; create separate input files for each distance to be studied. But most of; these input files are identical, except that the interatomic distance is; different. Psithon lets you specify all this in a single input file,; looping over the different distances with an array like this:; Rvals=[2.5, 3.0, 4.0].; Let’s also suppose you want to do counterpoise (CP) corrected energies.; Counterpoise correction involves computing the dimer energy and then; subtracting out the energies of the two monomers, each evaluated in the; dimer basis. Again, each of these computations could be run in a separate; input file, but because counterpoise correction is a fairly standard; proc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:14236,simpl,simplify,14236,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,8,['simpl'],['simplify']
Usability,"thylene, with the acetylene hydrogen; pointing directly at the double bond in ethylene; this will be attractive; because the H atoms in acetylene bear a partial positive charge, while the; electron-rich double bond in ethylene bears a partial negative charge. At; the same time, the dispersion interaction should be smaller because the; perpendicular geometry does not allow much overlap between the monomers.; Hence, the SAPT analysis helps clarify (and quantify) our physical; understanding about the interaction between the two monomers. Potential Surface Scans and Counterpoise Correction Made Easy with Psithon¶; Finally, let’s consider an example that shows how the Python driver; in PSI4 simplifies some routine tasks. PSI4 can interpret; valid Python code in addition to the computational chemistry directives; we’ve seen in the previous examples; we call this mixture Psithon.; The Python computer language is very easy to pick up, and even users; previously unfamiliar with Python can use it to simplify tasks by; modifying some of the example input files supplied with PSI4; in the psi4/samples directory.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; create separate input files for each distance to be studied. Most of; these input files are identical, except that the interatomic distance is; different. Psithon lets you specify all this in a single input file,; looping over the different distances with an array like this:; Rvals=[2.5, 3.0, 4.0].; Let’s also suppose you want to do counterpoise (CP) correction to compute interaction energies.; Counterpoise correction involves computing the dimer energy and then; subtracting out the energies of the two monomers, each evaluated in the; dimer basis. Again, each of these computations could be run in a separate; input file, but because counterpoise correction is a f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:16091,simpl,simplify,16091,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,15,['simpl'],['simplify']
Usability,"thylene, with the acetylene hydrogen; pointing directly at the double bond in ethylene; this will be attractive; because the H atoms in acetylene bear a partial positive charge, while the; electron-rich double bond in ethylene bears a partial negative charge. At; the same time, the dispersion interaction should be smaller because the; perpendicular geometry does not allow much overlap between the monomers.; Hence, the SAPT analysis helps clarify (and quantify) our physical; understanding about the interaction between the two monomers. Potential Surface Scans and Counterpoise Correction Made Easy with Psithon¶; Finally, let’s consider an example that shows how the Python driver; in Psi4 simplifies some routine tasks. Psi4 can interpret; valid Python code in addition to the computational chemistry directives; we’ve seen in the previous examples; we call this mixture Psithon.; The Python computer language is very easy to pick up, and even users; previously unfamiliar with Python can use it to simplify tasks by; modifying some of the example input files supplied with Psi4; in the psi4/samples directory.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; create separate input files for each distance to be studied. Most of; these input files are identical, except that the interatomic distance is; different. Psithon lets you specify all this in a single input file,; looping over the different distances with an array like this:; Rvals=[2.5, 3.0, 4.0].; Let’s also suppose you want to do counterpoise (CP) corrected energies.; Counterpoise correction involves computing the dimer energy and then; subtracting out the energies of the two monomers, each evaluated in the; dimer basis. Again, each of these computations could be run in a separate; input file, but because counterpoise correction is a fairly standard; procedur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:15351,simpl,simplify,15351,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['simpl'],['simplify']
Usability,"tion in symmetry. The \(^2B_2\) state,; whose singly-occupied orbitals are; SOCC = [0, 0, 0, 1]. would be mapped to; SOCC = [1, 0]. which is the same occupation as the \(^2A_1\) state. In this case, the; \(^2A_1\) state is lower in energy, and is not problematic. The distorted; geometries for the \(^2B_2\) state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so: simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible \(M_s\) value.; H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html:14125,simpl,simple,14125,psi4manual/1.4.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html,12,['simpl'],"['simple', 'simply']"
Usability,"tion in symmetry. The \(^2B_2\) state,; whose singly-occupied orbitals are; SOCC = [0, 0, 0, 1]. would be mapped to; SOCC = [1, 0]. which is the same occupation as the \(^2A_1\) state. In this case, the; \(^2A_1\) state is lower in energy, and is not problematic. The distorted; geometries for the \(^2B_2\) state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so: simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. This specifies that there are two neutral, spin-singlet fragments. It is; possible to further specify that the overall complex is neutral and spin-singlet; by inserting another charge multiplicity line, separated from the first; molecule block by a – line. If any information is missing, PSI4 will set the; unprovided charges and multiplicities to be consistent with those that are given.; For example, the overall charg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psithonmol.html:14332,simpl,simple,14332,psi4manual/1.8.x/psithonmol.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psithonmol.html,6,['simpl'],"['simple', 'simply']"
Usability,"tion of the practical differences in the equations that define each of the; coupled-pair methods implemented in PSI4. We begin with the CISD wave function. (1); where we have chosen the intermediate normalization, .; The CISD correlation energy is given by. (2); and the amplitudes can be determined by the solution to the coupled set of eqations:. (3); The CISD method is not size-extensive, but this problem can be overcome by making very simple modifications to the amplitude; equations. With malice and forethought, we replace the correlation energy, , with generalized shifts for; the doubles and singles equations, and :. (4); These shifts approximate the effects of triple and quadruple excitations.; The values for and used in several coupled-pair methods are given in Table; CEPA Shifts. Note that these shifts are defined in a spin-free formalism; for closed-shell references only. method. sdci. dci. NA. cepa(0); 0; 0. cepa(1). cepa(3). acpf. aqcc. The pair correlation energy, , is simply a partial sum of the correlation energy. In a spin-free formalism,; the pair energy is given by. (5); Methods whose shifts ( and ) do not explicitly depend on orbitals or ; (CISD, CEPA(0), ACPF, and AQCC); have solutions that render the energy stationary with respect variations in the amplitudes. This convenient property allows; density matrices and 1-electron properties to be evaluated without any additional effort.; The coupled-pair methods currently supported in PSI4 are outlined in Table CEPA Methods. name; calls method; energy; derivatives; 1-electron properties. cepa(0); coupled electron pair approximation, variant 0; Y; N; Y. cepa(1); coupled electron pair approximation, variant 1; Y; N; N. cepa(3); coupled electron pair approximation, variant 3; Y; N; N. acpf; averaged coupled-pair functional; Y; N; Y. aqcc; averaged quadratic coupled-cluster; Y; N; Y. sdci; configuration interaction with single and double excitations; Y; N; Y. dci; configuration interaction with double excita",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cepa-1.html:1974,simpl,simply,1974,psi4manual/4.0b3/cepa-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cepa-1.html,2,['simpl'],['simply']
Usability,"tion scheme to be applied to the delta correction; to the correlation energy. delta2_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. delta3_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. delta4_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. delta5_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:8432,simpl,simple,8432,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,2,['simpl'],['simple']
Usability,"tion. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. ExternalPotential¶. class psi4.core.ExternalPotential¶; Bases: pybind11_builtins.pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self, basis, coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). clear(self); Reset the field to zero (eliminates all entries). computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None; Add a charge Z at (x,y,z). clear(self: psi4.core.ExternalPotential) → None; Reset the field to zero (eliminates all entries). computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix; Compute the external potential matrix in the given basis set. print_out(self: p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.externalpotential.html:1020,clear,clear,1020,psi4manual/1.2.1/api/psi4.core.externalpotential.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.externalpotential.html,1,['clear'],['clear']
Usability,"tion. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. ExternalPotential¶. class psi4.core.ExternalPotential¶; Bases: pybind11_builtins.pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self, basis, coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). clear(self); Reset the field to zero (eliminates all entries). computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None; Add a charge Z at (x,y,z). clear(self: psi4.core.ExternalPotential) → None; Reset the field to zero (eliminates all entries). computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix; Compute the external potential matrix in the given basis set. print_out(self: p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.externalpotential.html:1020,clear,clear,1020,psi4manual/1.3.2/api/psi4.core.externalpotential.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.externalpotential.html,1,['clear'],['clear']
Usability,"tion. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html:2220,guid,guide,2220,psi4manual/1.4.0/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html,15,['guid'],['guide']
Usability,"tive string called DATA_FILE, with a default of “data.dat” and any possible value.; A string called AO_BASIS with a default of “NONE”, and possible values of “NONE”, “DISK”, or “DIRECT”. The purpose of the “if” statement in the above read_options function is; the following. Suppose in an input file the user sets an option through; the construct set mymodule print 1 or through a set mymodule {...}; block. The first thing to happen is a call to read_options with name set; to “MYMODULE”. (Note that all user input is converted to upper case unless a; add_str_i which should be used sparingly for files.) This; call to read_options should tell the Options object only about those; options expected by the module called “mymodule”; this prevents overlap of; options between different modules.; Notice also that there’s a special comment immediately before the; declaration of each keyword. You must provide these comments for any; options you add as they will be automatically inserted into the user; manual Providing a clear description will also help you to remember what; the keywords do and how they’re used. The comments must live between the; special comment delimiters. For options that most users shouldn’t need,; add an expert flag to the comment. This will place these options in a; separate section of the user manual.; /*- comment -*/; options.add_ ...; /*- comment !expert -*/; options.add_ ... As is apparent from the examples above, comments can span multiple lines; (see PRINT), can refer to other options (through hyperlinks; see; SAVE_INFO), can refer to sections of the manual (through hyperlinks;; see DOCC), and can contain LaTeX notation (see AO_BASIS). (To get; the LaTeX subscript command, use “@@” instead of “_”.); See How to name keywords in psi4/src/read_options.cc; for guidelines on naming options. What is has_changed ?¶; There are times when we need to know whether an option was provided by the; user or if the defaults are being used. For this reason, the Options; ob",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optionshandling-1.html:3450,clear,clear,3450,psi4manual/1.4.0/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optionshandling-1.html,9,['clear'],['clear']
Usability,"tivestate.com/recipes/576693/ on 15 Nov 2014. # Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.; # Passes Python2.7's test suite and incorporates all the latest updates. from __future__ import absolute_import; from __future__ import print_function; try:; from thread import get_ident as _get_ident; except ImportError:; from dummy_thread import get_ident as _get_ident. try:; from _abcoll import KeysView, ValuesView, ItemsView; except ImportError:; pass. [docs]class OrderedDict(dict):; 'Dictionary that remembers insertion order'; # An inherited dict maps keys to values.; # The inherited dict provides __getitem__, __len__, __contains__, and get.; # The remaining methods are order-aware.; # Big-O running times for all methods are the same as for regular dictionaries. # The internal self.__map dictionary maps keys to links in a doubly linked list.; # The circular doubly linked list starts and ends with a sentinel element.; # The sentinel element never gets deleted (this simplifies the algorithm).; # Each link is stored as a list of length three: [PREV, NEXT, KEY]. def __init__(self, *args, **kwds):; '''Initialize an ordered dictionary. Signature is the same as for; regular dictionaries, but keyword arguments are not recommended; because their insertion order is arbitrary. '''; if len(args) > 1:; raise TypeError('expected at most 1 arguments, got %d' % len(args)); try:; self.__root; except AttributeError:; self.__root = root = [] # sentinel node; root[:] = [root, root, None]; self.__map = {}; self.__update(*args, **kwds). def __setitem__(self, key, value, dict_setitem=dict.__setitem__):; 'od.__setitem__(i, y) <==> od[i]=y'; # Setting a new item creates a new link which goes at the end of the linked; # list, and the inherited dictionary is updated with the new key/value pair.; if key not in self:; root = self.__root; last = root[0]; last[1] = root[0] = self.__map[key] = [last, root, key]; dict_setitem(self, key, value). def __delitem__(self,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html:1208,simpl,simplifies,1208,psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/oldpymodules.html,1,['simpl'],['simplifies']
Usability,"to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta3_basis and xtpl_highest_1() otherwise. delta4_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). 1; 2>>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). 1; 2; 3>>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). 1; 2>>> # [6] ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:10576,simpl,simple,10576,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,7,['simpl'],['simple']
Usability,"to the; perturbation series is at the second order:. \[E_{\mathrm{MBPT}}^{(2)} = - \frac{1}{4} \frac{\langle ij|ab\rangle^2}{\epsilon_a +; \epsilon_b - \epsilon_i - \epsilon_j}.\]; In the DFMP2 module, the first-order contribution, or “singles energy” is; always evaluated. This term is a significant contributor to the total; second-order energy if a ROHF reference is used. In this case, we have chosen; to use the ROHF-MBPT(2) ansatz, in which the ROHF orbitals are; semicanonicalized, the resultant nonzero Fock matrix elements \(f_{ia}\) are used; to form the singles amplitudes, and then the second-order amplitudes are formed; with the semicanonical spin orbitals via the same machinery as a UHF-MP2. Note; that the singles energy should be very close to zero for RHF and UHF references;; if it is not, there is a good chance your orbitals are not well converged.; Tighten the SCF E_CONVERGENCE and/or D_CONVERGENCE keywords; and try again.; To increase the efficiency of MP2 energy evaluation, spin integration; and simplification is carried out. This also allows for the identification of; Same-Spin (SS) and Opposite-Spin (OS) terms for use in Grimme’s Spin-Component; Scaled (SCS) MP2. For RHF-MP2 (also labeled as RMP2), the spin-free equations are; (note that the integrals are now chemist’s integrals over spatial orbitals). \[E_{\mathrm{MBPT,OS}}^{(2)} =; - \frac{(ia|jb)(ia|jb)}{\epsilon_a + \epsilon_b - \epsilon_i - \epsilon_j}\]; and. \[E_{\mathrm{MBPT,SS}}^{(2)} =; - \frac{[(ia|jb)-(ib|ja)](ia|jb)}{\epsilon_a + \epsilon_b - \epsilon_i - \epsilon_j}.\]; For UHF-MP2 (also labeled as UMP2) and the second-order contribution to; ROHF-MBPT(2) using semicanonical orbitals, the spin-free equations are. \[E_{\mathrm{MBPT,OS}}^{(2)} =; - \frac{(ia^\alpha|jb^\beta)(ia^\alpha|jb^\beta)}{\epsilon_a + \epsilon_b - \epsilon_i - \epsilon_j}\]; and. \[E_{\mathrm{MBPT,SS}}^{(2)} =; - \frac{1}{2}\frac{[(ia^\alpha|jb^\alpha)-(ib^\alpha|ja^\alpha)](ia^\alpha|jb^\alpha)}; {\epsilon_a + \epsil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dfmp2-1.html:5670,simpl,simplification,5670,psi4manual/1.2.1/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dfmp2-1.html,15,['simpl'],['simplification']
Usability,"to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html:2352,guid,guide,2352,psi4manual/1.7.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html,12,['guid'],['guide']
Usability,"to works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:; 1; 2; 3int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:; 1; 2; 3; 4std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. Mark virtual functions in derived classes with override¶; The override keyword introduced in C++11 is used to mark a function in a; derived class and guarantee that it is overloading a function with the same; signature in the base class. This behavior is checked at compile time. Prefer GiB for memory printing¶; As memory sizes get larger, we should work in giga (requires decimal printing to not round to zero) rather than mega units.; As it’s what we’re computing anyways, we should work in 1024-based (mebi, gibi, etc. https://en.wikipedia.org/wiki/Gibibyte) rather than 1000-based units.; As it’s a unit, put it in brackets.; Note that users can supply MiB, GB, bytes, or whatever; this guideline is for output printing.; 1; 2outfile->Printf("" DFHelper Memory: AOs need %.3f [GiB]; user supplied %.3f [GiB]. "",; (required * 8 / (1024 * 1024 * 1024.0)),. table of contents. C++ Style; Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; Mark virtual functions in derived classes with override; Prefer GiB for memory printing. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Adding New Code to PSI4. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/prog_style_c-1.html:3110,guid,guideline,3110,psi4manual/1.3.2/prog_style_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/prog_style_c-1.html,2,['guid'],['guideline']
Usability,"tp://sphinx-doc.org; Perl (for some auto-documentation scripts) https://www.perl.org/; nbsphinx (for converting Jupyter notebooks) http://nbsphinx.readthedocs.io/en/jupyter-theme/; sphinx-psi-theme https://github.com/psi4/sphinx-psi-theme; See [“message” lines] for advice on obtaining docs dependencies or [conda env spec]; See psi4/.github/workflows/docs.yml for full docs building procedure to follow. Ambit — https://github.com/jturney/ambit; CheMPS2 — [what is CheMPS2?] [CheMPS2 min version]. HDF5 https://support.hdfgroup.org/HDF5/; zlib http://www.zlib.net/. ecpint — [what is ecpint?] [ecpint min version]; dkh — [what is dkh?] [dkh min version]. Fortran Compiler. gdma — [what is gdma?] [gdma min version]. Fortran Compiler. PCMSolver — [what is PCMSolver?]. Fortran Compiler; zlib http://www.zlib.net/. simint — [what is simint?] [simint min version]. Additionally, there are runtime-loaded capabilities:. PylibEFP & libefp — [what is LibEFP?] [LibEFP min version]; cfour — [what is CFOUR?]; dftd3 — [what is DFTD3?]; simple-dftd3 — [what is DFTD3?] (Nov 2022; added by v1.7) preferred alternative to dftd3 https://github.com/dftd3/simple-dftd3; gcp — [what is gCP?]; mctc-gcp — [what is gCP?] (Nov 2022; added by v1.7) preferred alternative to gcp https://github.com/grimme-lab/gcp; dftd4 — <sec:dftd3> https://github.com/dftd4/dftd4; mrcc — [what is MPCC?]; v2rdm_casscf — [what is v2rdm_casscf?]; sns-mp2 — https://github.com/DEShawResearch/sns-mp2/commits/master; resp — https://github.com/cdsgroup/resp; gpu_dfcc — https://github.com/edeprince3/gpu_dfcc/commits/master; OpenFermion-Psi4 — https://github.com/quantumlib/OpenFermion; cppe — https://github.com/maxscheurer/cppe; mp2d — https://github.com/Chandemonium/MP2D; FockCI — https://github.com/shannonhouck/psi4fockci; cct3 — https://github.com/piecuch-group/cct3; adcc — https://github.com/adc-connect/adcc; BrianQC — https://www.brianqc.com/; i-PI — http://ipi-code.org/; psixas — https://github.com/Masterluke87/psixas; MDI — ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/build_planning.html:8678,simpl,simple-,8678,psi4manual/1.8.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/build_planning.html,3,['simpl'],['simple-']
Usability,"trapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta3_basis and xtpl_highest_1() otherwise. delta4_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correcti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:9477,simpl,simple,9477,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,2,['simpl'],['simple']
Usability,"troublesome kinetic energy term via the implicit one-body; Kohn-Sham orbitals. KS-DFT borrows much of the machinery of Hartree-Fock, as is; evident by looking at the energy expression,. Here is the noninteracting quasiparticle kinetic energy operator,; is the nucleus-electron attraction potential, ; is the total electron density matrix, and is the (potentially nonlocal) exchange, correlation, and residual; kinetic energy functional. The residual kinetic energy term is usually quite; small, and is often ignored, hence is often referred to; as simply the exchange-correlation functional (exchange and correlation, not; just exchange-type correlation).; In practice, the first few generations of KS-DFT functionals were chosen to be; local, meaning that the form of the exchange correlation energy is an integral; over all of space of a function depending only on local information in the; density, such as the density value or derivatives. The simplest variants are; Local Spin-Density Approximations (LSDA), which depend only on the spin density; or ,. The most popular variants are Generalized Gradient Approximation (GGA); functionals which use the norm of the density gradient; , or; to build an inhomogeneity; parameter. where,. GGA functionals are essentially the same cost as LSDA functionals, and are often; considerably more accurate.; Another local variant which has gained some popularity (though perhaps not as; much as GGA functionals) is the meta approximation, in which information about; the second derivative of the density is incorporated. The most canonical variant; of these functionals rely on the spin kinetic energy density ; and ,. A generic local meta-GGA functional may then be written as,. The potential corresponding to this energy functional is,. This potential is used to build the Kohn-Sham matrix,. which is diagonalized to form the Kohn-Sham orbitals in the same manner as in; Hartree-Fock.; In practice the local functional kernel and its required; partial deriv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:2282,simpl,simplest,2282,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,10,['simpl'],['simplest']
Usability,"true. Alternatively, another value for \(\alpha\); can be specified by setting EXCH_SCALE_ALPHA to a value. For example,; set exch_scale_alpha 1.0. will set \(\alpha = 1.0\) and scale exchange energies with \(p_{EX}(1.0)\).; Instead of this straightforward scaling, SAPT0 energies benefit from a slightly modified; recipe that involves an empirically adjusted exponent \(\alpha = 3.0\).; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]). (9)¶\[E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)}; + \delta_{HF}^{(2)}\]; where \(\delta_{HF}^{(2)}\) is computed without any scaling. Please note that; sSAPT0 is thus not the same as requesting exch_scale_alpha 3.0, and that the; scaling is automatically performed by requesting energy('ssapt0'). A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods,; not all of them).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis aug-cc-pvdz. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and open-shell monomers.; Higher-order SAPT and SAPT(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:9971,simpl,simplest,9971,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,7,['simpl'],['simplest']
Usability,"ts otherwise; keep = yes.match(str(kwargs['keep'])) if 'keep' in kwargs else False; os.chdir('..'); try:; if keep or ('path' in kwargs):; p4out.write('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory); p4out.close(); psi4.reopen_outfile(). psi4.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); psi4.print_variables(); if c4grad:; psi4.get_gradient().print_out(). psi4.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); psi4.print_variables(); if c4grad:; psi4.get_gradient().print_out(). # Quit if Cfour threw error; if psi4.get_variable('CFOUR ERROR CODE'):; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). [docs]def cfour_list():; """"""Form list of Cfour :py:func:`~driver.energy` arguments.""""""; return qcdb.cfour.cfour_list(). [docs]def cfour_gradient_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_gradient_list(). [docs]def cfour_psivar_list():; """"""Form dictionary of :ref:`PSI Variables <apdx:cfour_psivar>` set by Cfour methods.""""""; return qcdb.cfour.cfour_psivar_list(). [docs]def write_zmat(name, dertype):; """"""Returns string with contents of Cfour ZMAT file as gathered from; active molecule, current keyword settings, and cfour {...} block. """"""; # Handle memory; mem = int(0.000001 * psi4.get_memory()); if mem == 256:; memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; molecule = psi4.get_active_molecule(); if molecule.name() == 'blank_molecule_psi4_yo':; molcmd, molkw = '', {}; bascmd, baskw = '', {}; psi4.set_local_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:13300,clear,clear,13300,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html,1,['clear'],['clear']
Usability,"ts that were; passed into the corresponding (private) compute_pair(GaussianShell &s1,; GaussianShell &s2) function that computed the integrals and transformed them; to the spherical harmonic basis, if needed. The switch to Libint2 integrals; preserves this mechanism, but the compute_shell(int P, int Q) simply looks; up the appropriate Libint2-compatible shells and hands them off to the; re-written, private compute_pair() routines, which call Libint2 directly.; Therefore, any calls to shell-pair level integral computations should look the; same as before the introduction of Libint2, however access to the integrals has; changed, as described below. Accessing integrals¶; Before the Libint2 transition, one electron integrals were computed in a flat; array, internally called buffer_, which was accessed through the integral; object’s buffer() method. For integrals with multiple operators, e.g.,; dipole operators that have three distinct components, the buffer was simply; elongated by the appropriate amount and the caller was responsible for striding; through each resulting batch correctly. The Libint2 engines instead return a; list of pointers into each operator’s batch of integrals, the ordering of which; are detailed on the Libint2 wiki. For this reason, the call to buffer(); that returns a single buffer must be replaced with a call to buffer() to; get a list of pointers; we recommend that be assigned the type const auto; &. For simple integrals, such as overlap or kinetic, only the buffer; corresponding to the zeroth element of this array contains integrals. Derivative Integrals¶; The old one electron integral code used translational invariance relations to; minimze the number of integrals to be computed, leaving the caller with some; bookkeeping to do to compute all terms. For example, consider an overlap; integral: its value depends only on the relative separation of the two centers; and not their absolute positions in space. Therefore, the derivative with; respect t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/prog_integrals.html:13164,simpl,simply,13164,psi4manual/1.6.x/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html,5,['simpl'],['simply']
Usability,"ttempt_number_¶; Current macroiteration (1-indexed) for stability analysis. diis_enabled_¶; docstring. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; docstring. iteration_¶; docstring. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. diis(self: psi4.core.HF) → bool¶; docstring. diis_manager(self: psi4.core.HF) → psi4.core.DIISManager¶; docstring. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s temporary data. finaliz",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html:5047,simpl,simply,5047,psi4manual/1.3.2/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html,1,['simpl'],['simply']
Usability,"tual in symmetry block 2 and another will be removed from the second highest occupied orbital in symmetry block 4. Examples given later in this manual further illustrate the QRHF input options and may help to clarify any confusion resulting from this documentation. (Default : 1). Type: array; Default: No Default. CFOUR_QRHFGUES (CFOUR)¶CFOUR — If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_QRHF_GENERAL, CFOUR_QRHF_ORBITAL and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge “difficult” SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calculation; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the CFOUR_REFERENCE keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. CFOUR_RAMAN_INT (CFOUR)¶CFOUR — ON (=1) requests a calculation of Raman intensities based on the geometrical derivatives of the static polarizability tensor, while DYN (=2) requests a calculation of Raman intensities based on the derivatives of the dynamical polarizability tensor. Type: string; Possible Values: ON, DYN, OFF; Default: OFF. CFOUR_RAMAN_ORB (CFOUR)¶CFOUR — Specifies whether Raman intensities are calculated with orbital relaxation with respect to the electric field perturbation (RELAXED, = 1) or without orbital relaxation (UNRELAXED, = 0). Type: string; Possible Values: RELAXED, UNRELAXED; Default: UNRELAXED. CFOUR_RDO (CFOUR)¶CFOUR — Specifies whether or not relaxed density natural orbitals are to be computed. This option only has meaning for a correlated calculation. For =0, Do not compute. For =1, compute. Type: boolean; Default: true. CFOUR_REFERENCE (CFOUR)¶CFOUR — Specifies the type of SCF ca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:69608,simpl,simply,69608,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['simpl'],['simply']
Usability,"tural bond orbitals to a file. class psi4.core.NablaInt¶; Bases: psi4.core.OneBodyAOInt; Computes nabla integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; Compute integrals between basis functions in the given shell pair. origin¶; The origin about which the one body ints are being computed. class psi4.core.OEProp¶; Bases: psi4.core.TaskListComputer; docstring. Exvals(self: psi4.core.OEProp) → List[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; docstring. clear(self: psi4.core.OEProp) → None¶; docstring. compute(self: psi4.core.OEProp) → None¶; docstring. set_Da_ao(self: psi4.core.OEProp, Da: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_title(self: psi4.core.TaskListComputer, arg0: str) → None¶; docstring. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MAYER_INDICES', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']¶. class psi4.core.OneBodyAOInt¶; Bases: pybind11_builtins.pybind11_object; Basis class for all one-electron integrals. basis¶; The basis set on center",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:183959,clear,clear,183959,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['clear'],['clear']
Usability,"tware package; #; # Copyright (c) 2007-2022 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with high-level functions calling wrappers and driver. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """""". __all__ = [; ""allen_focal_point"",; ""fake_file11"",; ""sherrill_gold_standard"",; ]. import os; import re; import warnings; from typing import Any, Dict, List. CBSMetadata = List[Dict[str, Any]]. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn: ""psi4.core.Wavefunction"", filename: str = 'fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :param filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/aliases.html:1245,simpl,simple,1245,psi4manual/1.7.x/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/aliases.html,1,['simpl'],['simple']
Usability,"tware package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with high-level functions calling wrappers and driver. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """""". __all__ = [; ""allen_focal_point"",; ""fake_file11"",; ""sherrill_gold_standard"",; ]. from typing import Any, Dict, List. CBSMetadata = List[Dict[str, Any]]. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn: ""psi4.core.Wavefunction"", filename: str = 'fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :param filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/aliases.html:1247,simpl,simple,1247,psi4manual/1.9.x/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/aliases.html,1,['simpl'],['simple']
Usability,"tware package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with high-level functions calling wrappers and driver. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """""". __all__ = [; ""allen_focal_point"",; ""fake_file11"",; ""sherrill_gold_standard"",; ]. import os; import re; import warnings; from typing import Any, Dict, List. CBSMetadata = List[Dict[str, Any]]. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn: ""psi4.core.Wavefunction"", filename: str = 'fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :param filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:1247,simpl,simple,1247,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html,1,['simpl'],['simple']
Usability,"tware package; #; # Copyright (c) 2007-2024 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with high-level functions calling wrappers and driver. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """""". __all__ = [; ""allen_focal_point"",; ""fake_file11"",; ""sherrill_gold_standard"",; ]. from typing import Any, Dict, List. CBSMetadata = List[Dict[str, Any]]. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end; # of this file. def fake_file11(wfn: ""psi4.core.Wavefunction"", filename: str = 'fake_file11.dat', **kwargs):; r""""""Function to print a file *filename* of the old file11 format; from molecule and gradient information in *wfn*. .. versionadded:: 0.6; *wfn* parameter passed explicitly. :returns: None. :param filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html:1254,simpl,simple,1254,psi4manual/master/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/aliases.html,1,['simpl'],['simple']
Usability,"type of the calculation, an initial guess is; necessary. PSI4 features several initial guesses for the; molecular orbitals. The default guess is the superposition of atomic; densities (SAD), discussed in. “Principles for a direct SCF approach to LCAO-MO ab-initio; calculations”, J. Almlöf, K. Faegri, and K. Korsell,; J. Comput. Chem. 3, 385 (1982).; (doi: 10.1002/jcc.540030314).; “Starting SCF calculations by superposition of atomic; densities”, J. H. Van Lenthe, R. Zwaans, H. J. J. Van Dam,; and M. F. Guest, J. Comput. Chem. 27, 926 (2006).; (doi: 10.1002/jcc.20393). PSI4 also features a SAD natural orbital guess, an extended; Hückel guess that employs on-the-fly atomic calculations alike the SAD; guess, as well as a superposition of atomic potentials (SAP) guess; that is based on screening of atomic nuclei. The SAD natural orbitals,; Hückel and SAP guesses have been described in. “An assessment of initial guesses for self-consistent field; calculations. Superposition of Atomic Potentials: simple yet; efficient”, S. Lehtola, J. Chem. Theory Comput. 15,; 1593 (2019) (doi: 10.1021/acs.jctc.8b01089). Density Cumulant Theory (DCT)¶; PSI4 features several formulations of newly-developed density cumulant; theory (DCT), also known as density cumulant functional theory (DCFT).; The theory and benchmark of this theory are discussed in the following papers:; DC-06 (also known as DCT-06):. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423). DC-12:. “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/introduction-1.html:6234,simpl,simple,6234,psi4manual/1.4.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/introduction-1.html,9,['simpl'],['simple']
Usability,"ual in symmetry block 2 and another will be removed from the second highest occupied orbital in symmetry block 4. Examples given later in this manual further illustrate the QRHF input options and may help to clarify any confusion resulting from this documentation. (Default : 1). Type: array; Default: No Default. CFOUR_QRHFGUES (CFOUR); CFOUR — If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_QRHF_GENERAL, CFOUR_QRHF_ORBITAL and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge “difficult” SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calcualtion; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the CFOUR_REFERENCE keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. CFOUR_RAMAN_INT (CFOUR); CFOUR — ON (=1) requests a calculation of Raman intensities based on the geometrical derivatives of the static polarizability tensor, while DYN (=2) requests a calculation of Raman intensities based on the derivatives of the dynamical polarizability tensor. Type: string; Possible Values: ON, DYN, OFF; Default: OFF. CFOUR_RAMAN_ORB (CFOUR); CFOUR — Specifies whether Raman intensities are calculated with orbital relaxation with respect to the electric field perturbation (RELAXED, = 1) or without orbital relaxation (UNRELAXED, = 0). Type: string; Possible Values: RELAXED, UNRELAXED; Default: UNRELAXED. CFOUR_RDO (CFOUR); CFOUR — Specifies whether or not relaxed density natural orbitals are to be computed. This option only has meaning for a correlated calculation. For =0, Do not compute. For =1, compute. Type: boolean; Default: true. CFOUR_REFERENCE (CFOUR); CFOUR — Specifies the type of SC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:68899,simpl,simply,68899,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['simpl'],['simply']
Usability,"ual in symmetry block 2 and another will be removed from the second highest occupied orbital in symmetry block 4. Examples given later in this manual further illustrate the QRHF input options and may help to clarify any confusion resulting from this documentation. (Default : 1). Type: array; Default: No Default. CFOUR_QRHFGUES (CFOUR); CFOUR — If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_QRHF_GENERAL, CFOUR_QRHF_ORBITAL and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge “difficult” SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calculation; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the CFOUR_REFERENCE keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. CFOUR_RAMAN_INT (CFOUR); CFOUR — ON (=1) requests a calculation of Raman intensities based on the geometrical derivatives of the static polarizability tensor, while DYN (=2) requests a calculation of Raman intensities based on the derivatives of the dynamical polarizability tensor. Type: string; Possible Values: ON, DYN, OFF; Default: OFF. CFOUR_RAMAN_ORB (CFOUR); CFOUR — Specifies whether Raman intensities are calculated with orbital relaxation with respect to the electric field perturbation (RELAXED, = 1) or without orbital relaxation (UNRELAXED, = 0). Type: string; Possible Values: RELAXED, UNRELAXED; Default: UNRELAXED. CFOUR_RDO (CFOUR); CFOUR — Specifies whether or not relaxed density natural orbitals are to be computed. This option only has meaning for a correlated calculation. For =0, Do not compute. For =1, compute. Type: boolean; Default: true. CFOUR_REFERENCE (CFOUR); CFOUR — Specifies the type of SC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:69320,simpl,simply,69320,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['simpl'],['simply']
Usability,"uations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; from the use of the higher-order SAPT code should cite the following:; [Hohenstein:2010:014101].; For methods SAPT2+ and above, one can replace the many-body treatment of; dispersion by an improved method based on coupled-cluster doubles (CCD).; This approach tends to give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]).; As shown in [Parker:2014:094106], whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102], the SAPT code in Psi; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102].; To request CCD dispersion treatment in a SAPT computation, simply append; (ccd) to the name of the method, as in the following examples; energy('sapt2+(ccd)'); energy('sapt2+(3)(ccd)'); energy('sapt2+3(ccd)'). The corrections can also be computed automatically; by appending dmp2 to the name of the method, with or without CCD dispersion; energy('sapt2+dmp2'); energy('sapt2+(3)dmp2'); energy('sapt2+3dmp2'); energy('sapt2+(ccd)dmp2'); energy('sapt2+(3)(ccd)dmp2'); energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the higly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary basis set, describes the monomer molecula",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:12658,simpl,simply,12658,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['simpl'],['simply']
Usability,"ublesome kinetic energy term via the implicit one-body; Kohn–Sham orbitals. KS-DFT borrows much of the machinery of Hartree–Fock, as is; evident by looking at the energy expression,. \[\begin{split}E_{\mathrm{KS}}; &= \sum_{i} \langle i | \hat h | i \rangle; + \frac 1 2 \sum_{i,j} [ii|jj] + E_{\mathrm{xc}} [\rho_\alpha, \rho_\beta] \\; &= D_{\mu\nu}^{\mathrm{T}}\left(T_{\mu\nu} +; V_{\mu\nu}\right) + \frac{1}{2} D_{\mu\nu}^{\mathrm{T}}; D_{\lambda\sigma}^{\mathrm{T}} (\mu\nu|\lambda\sigma) + E_{\mathrm{xc}} [\rho_\alpha, \rho_\beta]\end{split}\]; Here, \(T\) is the noninteracting quasiparticle kinetic energy operator,; \(V\) is the nucleus-electron attraction potential, \(D^{\mathrm{T}}\); is the total electron density matrix, and \(E_{\mathrm{xc}} [\rho_\alpha,; \rho_\beta]\) is the (potentially nonlocal) exchange, correlation, and residual; kinetic energy functional. The residual kinetic energy term is usually quite; small, and is often ignored, hence \(E_{\mathrm{xc}}\) is often referred to; as simply the exchange-correlation functional (exchange and correlation, not; just exchange-type correlation).; In practice, the first few generations of KS-DFT functionals were chosen to be; local, meaning that the form of the exchange correlation energy is an integral; over all of space of a function depending only on local information in the; density, such as the density value or derivatives. The simplest variants are; Local Spin-Density Approximations (LSDA), which depend only on the spin density; \(\rho_\alpha\) or \(\rho_\beta\),. \[\rho_\sigma (\vec r_1) = D_{\mu\nu}^{\sigma} \phi_{\mu} (\vec r_1); \phi_\nu (\vec r_1)\]; The most popular variants are Generalized Gradient Approximation (GGA); functionals which use the norm of the density gradient; \(\gamma_{\alpha\alpha}\), \(\gamma_{\alpha\beta}\) or; \(\gamma_{\beta\beta}\) to build an inhomogeneity; parameter. \[\gamma_{\alpha\alpha} (\vec r_1) = \nabla \rho_{\alpha} (\vec r_1) \cdot \nabla; \rho_{\alpha} (\vec r_1)\]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:2578,simpl,simply,2578,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,15,['simpl'],['simply']
Usability,"ubstitution¶. Caution; Use of isotopic substitution in Psi4 is not well; developed, and the syntax is subject to change. At present, isotopes can only be specified at creation-time of the molecule; The syntax for a deuterium- and tritium-substituted water is below. Note; that asymmetric isotopic substitution such as this will change the; molecule’s point group symmetry.; molecule dto {; units au; O 0.00000000 0.00000000 0.00000000; H@2.014101779 0.00000000 1.93042809 -1.10715266; H_label@3.01604927 0.00000000 -1.93042809 -1.10715266; }. The masses used by Psi4 can be found at; psi4/include/masses.h. See freq-isotope for about; the only use to which isotopologs can presently be put in Psi4. PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, Psi4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; Psi4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to the output file, prompting the user to provide a more; specific name. For example, if we know that we want to run a computation on a; compound whos",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html:7396,intuit,intuitive,7396,psi4manual/1.0.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html,2,['intuit'],['intuitive']
Usability,"ue; dense_ret[start:start + d1] = arr; start += d1; else:; dense_ret = np.zeros(shape=(ndim1, ndim2)); start1 = 0; start2 = 0; for d1, d2, arr in zip(dim1, dim2, matrix_views):; if (d1 == 0) or (d2 == 0): continue. dense_ret[start1:start1 + d1, start2:start2 + d2] = arr; start1 += d1; start2 += d2. return dense_ret. else:; return _get_raw_views(matrix, copy=copy)[0]. @property; def _np_shape(self):; """"""; Shape of the Psi4 data object.; """"""; view_data = _get_raw_views(self); if self.nirrep() > 1:; return tuple(view_data[x].shape for x in range(self.nirrep())); else:; return view_data[0].shape. @property; def _np_view(self):; """"""; View with single irrep.; """"""; if self.nirrep() > 1:; raise ValidationError(""Attempted to call .np on a Psi4 data object with multiple irreps.""; ""Please use .nph for objects with irreps.""); return _get_raw_views(self)[0]. @property; def _nph_view(self):; """"""; View with irreps.; """"""; return _get_raw_views(self). @property; def _array_conversion(self):; """"""; Provides the array interface to simply classes so that np.array(core.Matrix(5, 5)) works flawlessly.; """"""; if self.nirrep() > 1:; raise ValidationError(""__array__interface__ can only be called on Psi4 data object with only one irrep!""); else:; return self.np.__array_interface__. def _np_write(; self: Union[core.Matrix, core.Vector],; filename: Optional[str] = None,; prefix: str = """",; ) -> Optional[Dict[str, Any]]:; """"""; Writes the irrepped matrix to a NumPy uncompressed file using :func:`numpy.savez`. Can return the packed data for saving many matrices into the same file. Parameters; ----------; self; Instance to be serialized.; filename; File name where the data will be saved.; prefix; Name of instance prepared for NumPy. Returns; -------; None or ~typing.Dict[str, ~typing.Any]; When `filename` given, it and dict serialization passed to; :func:`numpy.savez`, so ``.npz`` file saved and None returned.; When `filename` None, dict serialization returned. """"""; ret = {}; ret[prefix + ""Irreps""] =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:8869,simpl,simply,8869,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,4,['simpl'],['simply']
Usability,"ue; dense_ret[start:start + d1] = arr; start += d1; else:; dense_ret = np.zeros(shape=(ndim1, ndim2)); start1 = 0; start2 = 0; for d1, d2, arr in zip(dim1, dim2, matrix_views):; if (d1 == 0) or (d2 == 0): continue. dense_ret[start1:start1 + d1, start2:start2 + d2] = arr; start1 += d1; start2 += d2. return dense_ret. else:; return _get_raw_views(matrix, copy=copy)[0]. @property; def _np_shape(self):; """"""; Shape of the Psi4 data object.; """"""; view_data = _get_raw_views(self); if self.nirrep() > 1:; return tuple(view_data[x].shape for x in range(self.nirrep())); else:; return view_data[0].shape. @property; def _np_view(self):; """"""; View with single irrep.; """"""; if self.nirrep() > 1:; raise ValidationError(""Attempted to call .np on a Psi4 data object with multiple irreps.""; ""Please use .nph for objects with irreps.""); return _get_raw_views(self)[0]. @property; def _nph_view(self):; """"""; View with irreps.; """"""; return _get_raw_views(self). @property; def _array_conversion(self):; """"""; Provides the array interface to simply classes so that np.array(core.Matrix(5, 5)) works flawlessly.; """"""; if self.nirrep() > 1:; raise ValidationError(""__array__interface__ can only be called on Psi4 data object with only one irrep!""); else:; return self.np.__array_interface__. def _np_write(self, filename=None, prefix=""""):; """"""; Writes the irreped matrix to a NumPy zipped file. Can return the packed data for saving many matrices into the same file.; """""". ret = {}; ret[prefix + ""Irreps""] = self.nirrep(); ret[prefix + ""Name""] = self.name; for h, v in enumerate(self.nph):; # If returning arrays to user, we want to return copies (snapshot), not; # views of the core.Matrix's memory.; if filename is None and not v.flags['OWNDATA']:; v = np.copy(v); ret[prefix + ""IrrepData"" + str(h)] = v. if isinstance(self, core.Matrix):; ret[prefix + ""Dim1""] = self.rowdim().to_tuple(); ret[prefix + ""Dim2""] = self.coldim().to_tuple(); if isinstance(self, core.Vector):; ret[prefix + ""Dim""] = [self.dim(x) for x in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:8189,simpl,simply,8189,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,3,['simpl'],['simply']
Usability,"uested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available. PSIthonPsiAPIe_mp2 = variable('MP2 TOTAL ENERGY'); e_scs_mp2 = variable('SCS-MP2 TOTAL ENERGY'). e_mp2 = psi4.variable('MP2 TOTAL ENERGY'); e_scs_mp2 = psi4.variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. PSIthonPsiAPI# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:9530,clear,cleared,9530,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['clear'],['cleared']
Usability,"ulant:. The one-particle density matrix is separated into its idempotent part; and a correction :. The idempotent part of corresponds to a mean-field Hartree-Fock-like density,; while the non-idempotent correction ; depends on the density cumulant and describes the electron correlation effects.; Inserting the above two equations into the energy expression, we obtain:. where the antisymmetrized two-electron integrals and the generalized Fock operator; matrix elements were defined as follows:. Energy functional has several important properties. First,; the energy is now a function of two sets of independent parameters, the; idempotent part of () and the density cumulant; (). As a result, the energy functional is Hermitian,; which is important for the evaluation of the molecular properties. The additive; separability of the density cumulant guarantees that all of the DCFT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent part of is; N-representable by construction. One only needs to worry about the; N-representability of the density cumulant, which is a relatively small part of; .; In order to obtain the DCFT energy, two conditions must be satisfied:; 1) The energy must be stationary with respect to a set of orbitals. This can be done by; diagonalizing the generalized Fock operator (as in the DC-06 and DC-12 methods, see below),; which introduces partial orbital relaxation, or by fully relaxing the orbitals and minimizing the entire energy expression; (as in the ODC-06 and ODC-12 methods).; 2) The energy must be stationary with respect to the variation of the density; cumulant , constrained to N-representability conditions.; Making the energy stationary requires solution of two sets of coupled; equations for orbitals and density cumulant, respectively (also known as; residual equations). At the present moment, three different algorithms for the; solution of the system of coupl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:2610,simpl,simplified,2610,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['simpl'],['simplified']
Usability,"ule, in this case, 2.; # Many optional arguments are available, see the python file; frac_nuke(h2o, nmax = 2). Note: this feature is new/powerful enough that we have several papers pending on; it, and are interested in expanding this work. If you would like to publish; results using this code, please contact Rob Parrish to make arrangements for; collaboration. Dispersion Corrections¶; Dispersion corrections are discussed at this link. Recommendations¶; The KS-DFT code is quite new, but relatively complete. During code development,; emphasis was placed on flexibility of functional technology, efficiency for; medium to large systems in difficult electronic environments (e.g., compact; spatial extents, diffuse basis sets, low band-gaps, LRC and/or hybrid GKS; functionals), and time to code completion. We are very interested in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Table Of Contents. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/dft-1.html:22415,guid,guidelines,22415,psi4manual/4.0b3/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/dft-1.html,6,['guid'],['guidelines']
Usability,"ule, in this case, 2.; # Many optional arguments are available, see the python file; frac_nuke(h2o, nmax = 2). Note: this feature is new/powerful enough that we have several papers pending on; it, and are interested in expanding this work. If you would like to publish; results using this code, please contact Rob Parrish to make arrangements for; collaboration. Dispersion Corrections¶; Dispersion corrections are discussed at this link. Recommendations¶; The KS-DFT code is quite new, but relatively complete. During code development,; emphasis was placed on flexibility of functional technology, efficiency for; medium to large systems in difficult electronic environments (e.g., compact; spatial extents, diffuse basis sets, low band-gaps, LRC and/or hybrid GKS; functionals), and time to code completion. We are very interested in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; Psi4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Table Of Contents. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:22783,guid,guidelines,22783,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,2,['guid'],['guidelines']
Usability,"ult: false. DO_DISP_EXCH_SINF¶. For SAPT(DFT) computes the \(S^{inf}\) Exchange-Dispersion terms. Type: boolean; Default: false. SAPT0-D¶; In SAPT0, the computation of \(E_{disp}^{(20)} + E_{exch-disp}^{(20)}\) represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; Grimme’s dispersion corrections are discussed here.; The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D; variants using default parameters optimized for Hartee–Fock interaction energies,; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters.; A simple water dimer computation using SAPT0-D may look like:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis jun-cc-pvdz. energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; energy(“fsapt0-d3mbj”). See FSAPT <fisapt> documentation for more details on using FSAPT; for functional group analyses. table of contents. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Basic SAPT0 Keywords; SAPT_LEVEL; BASIS; DF_BASIS_SAPT; DF_BASIS_ELST; FREEZE_CORE; D_CONVERGENCE; E_CONVERGENCE; MAXIT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:45890,simpl,simple,45890,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,4,['simpl'],['simple']
Usability,"unknown_property):; complete_options = oeprop_list_vals + response_list_vals; alt_method_name = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""SCF Property: Feature '%s' is not recognized. %s"" % (unknown_property[0], alternatives)). # Validate OEProp; if len(oe_properties):; proc_util.oeprop_validator(oe_properties). if len(linear_response):; optstash_jk = p4util.OptionsState([""SAVE_JK""]); core.set_global_option(""SAVE_JK"", True). # Compute the Wavefunction; scf_wfn = run_scf(name, scf_do_properties=False, do_timer=False, **kwargs). # Run OEProp; oe = core.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in oe_properties:; oe.add(prop.upper()); oe.compute(); scf_wfn.oeprop = oe. # Always must set SCF dipole (retire components at v1.5); with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for cart in [""X"", ""Y"", ""Z""]:; core.set_variable(""SCF DIPOLE "" + cart, core.variable(name + "" DIPOLE "" + cart)); core.set_variable(""SCF DIPOLE"", core.variable(name + "" DIPOLE"")) # P::e SCF. # Run Linear Respsonse; if len(linear_response):; core.prepare_options_for_module(""SCF""); ret = response.scf_response.cpscf_linear_response(scf_wfn, *linear_response,; conv_tol = core.get_global_option(""SOLVER_CONVERGENCE""),; max_iter = core.get_global_option(""SOLVER_MAXITER""),; print_lvl = (core.get_global_option(""PRINT"") + 1)); optstash_jk.restore(). core.tstop(); optstash.restore(); return scf_wfn. def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; optstash = p4util.OptionsState(; ['WFN'],; ['DERTYPE'],; ['ONEPDM'],; ['PROPERTY'],; ['CCLAMBDA', 'R_CONVERGENCE'],; ['CCEOM', 'R_CONVERGENCE'],; ['CCEOM', 'E_CONVERGENCE']) # yapf:disable. oneel_properties = core.OEProp.valid_methods; twoel_properties = []; response_properties = ['P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:95778,simpl,simplefilter,95778,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['simpl'],['simplefilter']
Usability,"untered during the Davidson procedure,; it is recommended to first increase SOLVER_MAX_SUBSPACE, especially if you solve; for a large number of roots. This will result in a higher computational cost of each iteration, but should; make the solver better behaved. However, note that SOLVER_MAX_SUBSPACE should never be larger than; the full subspace minus the number of desired roots to avoid adding artificial zero eigenvalues.; This may happen in minimal basis sets, especially with symmetry, but the code automatically adjusts; SOLVER_MAX_SUBSPACE if it is too large.; If the solver seems to converge on the wrong eigenvalue, try increasing SOLVER_N_GUESS.; Otherwise, if the solver is almost converged but reaches the maximum number of iterations, try increasing; SOLVER_MAXITER. Effective core potentials (ECPs)¶; PSI4 supports the use of effective core potentials to describe the; innermost electrons in heavy elements. If a basis set is designed to use an; effective core potential, the ECP definition should be simply placed alongside; the orbital basis set definition, c.f. Inputting effective core potentials (ECPs). All; information related to the definition and number of core electrons will; automatically be detected and no further input is required to use the; ECP-containing basis set. See scf-ecp and dfmp2-ecp; for examples of computations with ECP-containing basis sets. Warning; Analytic derivatives of ECPs are not yet available. The HF and DFT derivatives are implemented in a semi-numerical scheme, where numerical ECP gradients are added to analytic SCF gradients. Analytic gradients for (DF)MP2 are not yet available, but the standard numerical gradients will work correctly. Fully analytic gradients will be implemented soon. Warning; ECPs have not been tested with projected basis set guesses or with FI-SAPT calculations. If you require this functionality, please contact the developers on GitHub and/or the forum. External potentials and QM/MM¶; In addition to the implement",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/scf-1.html:33109,simpl,simply,33109,psi4manual/1.2.1/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/scf-1.html,8,['simpl'],['simply']
Usability,"ure with ENABLE_gdma,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect gdma and activate dependent code. Previous bullet had details. To build PSI4 from source and use; gdma from conda without thinking, consult sec:condapsi4dev. To remove a conda installation, conda remove gdma. Source. If using PSI4 built from source and you want gdma built from; from source also,; enable it as a feature with ENABLE_gdma,; and let the build system fetch and build it and activate dependent code. Input¶; The distributed multipole analysis (DMA) technique, developed by Anthony J.; Stone and implemented by him into the GDMA package, is available in PSI4.; The current implementation simply embeds Stone’s GDMA code into the main; executable, and generates the appropriate input files automatically. The; program takes as input a data file, and a Gaussian formatted checkpoint (see; Section FCHK) file. The simplest usage of the GDMA code is; demonstrated below, along with a listing of the options supported; these; options correspond to the options described in the; GDMA manual.; If more advanced usage is desired, which is not is permitted by the options; listed below, the user may provide their own data file containing keywords to; control the GDMA code. Simply place the data file in the directory PSI4; is called from, and provide the file name as the datafile argument to the; gdma() routine. For example, if GDMA data file is called; control.dma, the GDMA code is called as follows:; 1; 2grad, wfn = gradient('mp2', return_wfn=True); gdma(wfn, datafile='control.dma'). An FCHK file will be generated for the GDMA code to read; this file will have; the prefix given by WRITER_FILE_LABEL (if set), or else by the name; of the output file plus the name of the current molecule, and the suffix will; be ‘.fchk’. This FCHK file name should be passed to the ‘File’ keyword in the; DGMA data file, to ensure that the GDMA code reads the correct wavefunction; information.; After running, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/gdma-1.html:1715,simpl,simplest,1715,psi4manual/1.2.1/gdma-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/gdma-1.html,4,['simpl'],['simplest']
Usability,"ure; convergence. This is particularly likely for large systems, metallic systems,; multireference systems, open-shell systems, anions, and systems with diffuse; basis sets.; For initial orbital selection, several options are available. These include:. CORE [Default]; Diagonalization of the core Hamiltonian, removing even mean-field electron; repulsion. Simple, but often too far from the final solution for larger; systems. READ becomes the default for the second and later iterations; of geometry optimizations.; SAD; Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. This becomes the; default for the second and later iterations of geometry optimizations. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; BASIS_GUESS = SMALL_BASIS to the options list. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:14901,simpl,simple,14901,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,6,['simpl'],['simple']
Usability,"urn ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irrepped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def _to_array(; matrix: Union[core.Matrix, core.Vector],; copy: bool = True,; dense: bool = False,; ) -> Union[np.ndarray, List[np.ndarray]]:; """"""; Converts a |PSIfour| Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters; ----------; matrix; Pointers to which Psi4 core class should be used in the construction.; copy; Copy the data if `True`, return a view otherwise; dense; Converts irrepped Psi4 objects to diagonally blocked dense arrays if; `True`. Returns a list of arrays otherwise. Returns; -------; ~numpy.ndarray or ~typing.List[~numpy.ndarray]; Returns a single or list of NumPy arrays depending on options. Notes; -----; This is a generalized function to convert a Psi4 object to a NumPy array. Examples; --------. >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. matrix_views = _get_raw_views(matrix, copy=copy). # Return the list of arrays; if dense is False:; return matrix_views. # Build the dense matrix; if isinstance(matrix, core.Vector):; ret_type = '1D'; elif isinstance(matrix, core.Matrix):; ret_type = '2D'; else",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:6379,simpl,simply,6379,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,1,['simpl'],['simply']
Usability,"usual aug-cc-pVDZ basis, but; without diffuse functions on hydrogen and without diffuse \(d\); functions on heavy atoms); (Papajak:2011:10).; So, we’ll use that as our standard basis set. The SAPT code is designed; to use density fitting techniques, because they introduce minimal errors; while providing much faster computations; (Hohenstein:2010:184111,Hohenstein:2010:014101).; Since we’re using density fitting for the SAPT, we might as well also; use it for the Hartree-Fock computations that are performed as part of; the SAPT. We can specify that by adding 'scf_type': 'df' to the; dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in; addition to the total SAPT0 interaction energy. An explanation of the; various energy components can be found in the review by Jeziorski,; Moszynski, and Szalewicz; (Jeziorski:1994:1887),; and this is discussed in more detail in the SAPT; section of the Psi4; manual.; For now, we’ll note that most of the SAPT energy components are; negative; this means those are attra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:14564,simpl,simple,14564,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['simpl'],['simple']
Usability,"utations: {len(compute_list_count[nb])}"" for nb in nbodies]); core.print_out(info + ""\n""); logger.info(info). compute_dict = {; 'all': compute_list,; 'cp': cp_compute_list,; 'nocp': nocp_compute_list,; 'vmfc_compute': vmfc_compute_list,; 'vmfc_levels': vmfc_level_list; }; return compute_dict. def assemble_nbody_components(; ptype: DriverEnum,; component_results: Dict[str, Union[float, np.ndarray]],; metadata: Dict[str, Any],; ) -> Dict[str, Any]:; """"""Assembles N-body components for a single derivative level and a single model chemistry level into interaction quantities according to requested BSSE treatment(s). Parameters; ----------; ptype; Derivative level of component results to assemble. Matters mostly for scalar vs. array and array dimensions.; component_results; Dictionary with keys ""mc_(frag, bas)"" and values e/g/H computed component results according to *ptype*.; metadata; Dictionary of N-body metadata. Items described below.; Later, assemble_nbody_components should become a class function and the below are simply class member data.; quiet : bool; See class field. Whether to print/log energy summaries. Default True. False used by multilevel to suppress per-mc-level printing.; nfragments : int; See class field. Number of distinct fragments comprising the full molecular supersystem.; Formerly max_frag; return_total_data : bool; See class field. Whether the total data (e/g/H) of the molecular system has been requested, as opposed to interaction data.; max_nbody : int; See class field. Maximum number of bodies to include in the many-body treatment.""; embedding_charges : bool; Whether embedding charges are present. Used to NaN the output printing rather than print bad numbers.; molecule : psi4.core.Molecule; See class field. Used to count atoms in fragments.; nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]]; See class field. Distribution of active n-body levels among model chemistry levels.; Formerly nbody_list; bsse_type : List[BsseEnum]; See c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:20744,simpl,simply,20744,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,5,['simpl'],['simply']
Usability,"utations; are controlled through the keywords NAT_ORBS and; OCC_TOLERANCE, or by prepending a valid method name with “fno” in; the energy call as; 1energy('fno-ccsd(t)'). If you wish to specify the number of active natural orbitals manually, use; the keyword ACTIVE_NAT_ORBS. This keyword will override the; keyword OCC_TOLERANCE. QCISD(T), CCSD(T), MP4, and CEPA¶; The FNOCC module in PSI4 supports several related many-body quantum; chemistry methods, including the CCSD(T) and QCISD(T) methods, several; orders of many-body perturbation theory (MP2-MP4), and a family methods; related to the coupled electron pair approximation (CEPA). Quadratic configuration interaction and coupled cluster¶; The quadratic configuration interaction singles doubles (QCISD) method of; Pople, Head-Gordon, and Raghavachari [Pople:1987:5968] was originally; presented as a size-consistent extension of configuration interaction; singles doubles (CISD). The method can also be obtained as a; simplified version of the coupled cluster singles doubles (CCSD); method [Purvis:1982]. Consider the set of equations defining CCSD:. (1)¶\[\begin{split}\langle \Psi_0 | (H - E) (1 + T_1 + T_2 + \frac{1}{2}T_1^2)|\Psi_0\rangle = 0, \\; \langle \Psi_i^a | (H - E) (1 + T_1 + T_2 + \frac{1}{2}T_1^2+T_1T_2+\frac{1}{3!}T_1^3)|\Psi_0\rangle = 0, \\; \langle \Psi_{ij}^{ab} | (H - E) (1 + T_1 + T_2 + \frac{1}{2}T_1^2 + T_1T_2+\frac{1}{3!}T_1^3+\frac{1}{2}T_2^2+\frac{1}{2}T_1^2T_2+\frac{1}{4!}T_1^4)|\Psi_0\rangle = 0, \\\end{split}\]; where we have chosen the intermediate normalization,; \(\langle \Psi_0| \Psi \rangle = 1\), and the symbols \(T_1\); and \(T_2\) represent single and double excitation operators. The; QCISD equations can be obtained by omitting all but two terms that; are nonlinear in \(T_1\) and \(T_2\):. (2)¶\[\begin{split}\langle \Psi_0 | (H - E) (1 + T_1 + T_2)|\Psi_0\rangle = 0, \\; \langle \Psi_i^a | (H - E) (1 + T_1 + T_2 + T_1T_2)|\Psi_0\rangle = 0, \\; \langle \Psi_{ij}^{ab} | (H - E) (1 + T_1 +",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:3410,simpl,simplified,3410,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,6,['simpl'],['simplified']
Usability,"ute(self: psi4.core.OEProp) → None¶; docstring. set_Da_ao(self: psi4.core.OEProp, Da: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. Exvals(self: psi4.core.OEProp) → List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None; docstring. clear(self: psi4.core.OEProp) → None; docstring. compute(self: psi4.core.OEProp) → None; docstring. set_Da_ao(self: psi4.core.OEProp, Da: psi::Matrix, symmetry: int=0) → None; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi::Matrix) → None; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi::Matrix) → None; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi::Matrix, symmetry: int=0) → None; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi::Matrix) → None; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi::Matrix) → None; docstring. set_title(self: psi4.core.Prop, arg0: str) → None¶; docstring. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MAYER_INDICES', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Proj",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.oeprop.html:2614,clear,clear,2614,psi4manual/1.2.1/api/psi4.core.oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.oeprop.html,1,['clear'],['clear']
Usability,"ute(self: psi4.core.OEProp) → None¶; docstring. set_Da_ao(self: psi4.core.OEProp, Da: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. Exvals(self: psi4.core.OEProp) → List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None; docstring. clear(self: psi4.core.OEProp) → None; docstring. compute(self: psi4.core.OEProp) → None; docstring. set_Da_ao(self: psi4.core.OEProp, Da: psi::Matrix, symmetry: int=0) → None; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi::Matrix) → None; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi::Matrix) → None; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi::Matrix, symmetry: int=0) → None; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi::Matrix) → None; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi::Matrix) → None; docstring. set_title(self: psi4.core.TaskListComputer, arg0: str) → None¶; docstring. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MAYER_INDICES', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.oeprop.html:2626,clear,clear,2626,psi4manual/1.3.2/api/psi4.core.oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.oeprop.html,1,['clear'],['clear']
Usability,"uto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. Mark virtual functions in derived classes with override¶; The override keyword introduced in C++11 is used to mark a function in a; derived class and guarantee that it is overloading a function with the same; signature in the base class. This behavior is checked at compile time. Prefer GiB for memory printing¶; As memory sizes get larger, we should work in giga (requires decimal printing to not round to zero) rather than mega units.; As it’s what we’re computing anyways, we should work in 1024-based (mebi, gibi, etc. https://en.wikipedia.org/wiki/Gibibyte) rather than 1000-based units.; As it’s a unit, put it in brackets.; Note that users can supply MiB, GB, bytes, or whatever; this guideline is for output printing.; outfile->Printf("" DFHelper Memory: AOs need %.3f [GiB]; user supplied %.3f [GiB]. "",; (required * 8 / (1024 * 1024 * 1024.0)),. table of contents. C++ Style; Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; Mark virtual functions in derived classes with override; Prefer GiB for memory printing. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Adding New Code to PSI4; C++ Style. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/prog_style_c.html:3066,guid,guideline,3066,psi4manual/1.8.x/prog_style_c.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/prog_style_c.html,1,['guid'],['guideline']
Usability,"uto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. Mark virtual functions in derived classes with override¶; The override keyword introduced in C++11 is used to mark a function in a; derived class and guarantee that it is overloading a function with the same; signature in the base class. This behavior is checked at compile time. Prefer GiB for memory printing¶; As memory sizes get larger, we should work in giga (requires decimal printing to not round to zero) rather than mega units.; As it’s what we’re computing anyways, we should work in 1024-based (mebi, gibi, etc. https://en.wikipedia.org/wiki/Gibibyte) rather than 1000-based units.; As it’s a unit, put it in brackets.; Note that users can supply MiB, GB, bytes, or whatever; this guideline is for output printing.; outfile->Printf("" DFHelper Memory: AOs need %.3f [GiB]; user supplied %.3f [GiB]. "",; (required * 8 / (1024 * 1024 * 1024.0)),. table of contents. C++ Style; Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; Mark virtual functions in derived classes with override; Prefer GiB for memory printing. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Adding New Code to PSI4; C++ Style. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/prog_style_c.html:3066,guid,guideline,3066,psi4manual/1.9.x/prog_style_c.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/prog_style_c.html,1,['guid'],['guideline']
Usability,"variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. Reference: Items 2 and 5 in [Effective Modern C++]. Mark virtual functions in derived classes with override¶; The override keyword introduced in C++11 is used to mark a function in a; derived class and guarantee that it is overloading a function with the same; signature in the base class. This behavior is checked at compile time. Prefer GiB for memory printing¶; As memory sizes get larger, we should work in giga (requires decimal printing to not round to zero) rather than mega units.; As it’s what we’re computing anyways, we should work in 1024-based (mebi, gibi, etc. https://en.wikipedia.org/wiki/Gibibyte) rather than 1000-based units.; As it’s a unit, put it in brackets.; Note that users can supply MiB, GB, bytes, or whatever; this guideline is for output printing.; outfile->Printf("" DFHelper Memory: AOs need %.3f [GiB]; user supplied %.3f [GiB]. "",; (required * 8 / (1024 * 1024 * 1024.0)),. table of contents. C++ Style; Prefer nullptr to 0 or NULL; Prefer std::make_shared to direct use of new; Prefer auto to explicit type declarations; Mark virtual functions in derived classes with override; Prefer GiB for memory printing. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; C++ Style. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/prog_style_c.html:3064,guid,guideline,3064,psi4manual/1.6.x/prog_style_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_style_c.html,1,['guid'],['guideline']
Usability,"ver cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. dft-jk; DFT JK on-disk test. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. serial-wfn; A simple hf/cc-pvdz water calculation. The resulting wavefunction is written to a file, and then a new wavefunction is generated from that file. The member variables of both wavefunctions should be identical in value. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:2807,simpl,simple,2807,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['simpl'],['simple']
Usability,"wo; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible \(M_s\) value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fragmented. Advanced Python¶; A named molecule in an input file is a full-fledged instance of the; powerful C++ Molecule class. Thus, all member; functions (that have been exp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html:15288,simpl,simple,15288,psi4manual/1.4.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html,6,['simpl'],['simple']
Usability,"xE {lvalue},N5boost6python4listE); | ; | set_name(...); | set_name( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | C++ signature :; | void set_name(N3psi6MatrixE {lvalue},Ss); | ; | subtract(...); | subtract( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | C++ signature :; | void subtract(N3psi6MatrixE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE); | ; | sum_of_squares(...); | sum_of_squares( (Matrix)arg1) -> float :; | docstring; | ; | C++ signature :; | d sum_of_squares(N3psi6MatrixE {lvalue}); | ; | symmetrize_gradient(...); | symmetrize_gradient( (Matrix)arg1, (Molecule)arg2) -> None :; | docstring; | ; | C++ signature :; | void symmetrize_gradient(N3psi6MatrixE {lvalue},N5boost10shared_ptrIN3psi8MoleculeEEE); | ; | symmetry(...); | symmetry( (Matrix)arg1) -> int :; | docstring; | ; | C++ signature :; | i symmetry(N3psi6MatrixE {lvalue}); | ; | to_array(matrix, copy=True, dense=False); | Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; | consturcts a view.; | ; | trace(...); | trace( (Matrix)arg1) -> float :; | docstring; | ; | C++ signature :; | d trace(N3psi6MatrixE {lvalue}); | ; | transform(...); | transform( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | C++ signature :; | void transform(N3psi6MatrixE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE); | ; | transform( (Matrix)arg1, (Matrix)arg2 [, (Matrix)arg3]) -> None :; | docstring; | ; | C++ signature :; | void transform(N3psi6MatrixE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE [,N5boost10shared_ptrIN3psi6MatrixEEE]); | ; | vector_dot(...); | vector_dot( (Matrix)arg1, (Matrix)arg2) -> float :; | docstring; | ; | C++ signature :; | d vector_dot(N3psi6MatrixE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE); | ; | zero(...); | zero( (Matrix)arg1) -> None :; | docstring; | ; | C++ signature :; | void zero(N3psi6MatrixE {lvalue}); | ; | zero_diagonal(...); | zero_diagonal( (Matrix)arg1) -> None :; | docstring; | ; | C++ signature :; | void zero_diago",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:521780,simpl,simply,521780,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['simpl'],['simply']
Usability,"xed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet) → psi4.core.RHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.rhf.html:4200,simpl,simply,4200,psi4manual/1.3.2/api/psi4.core.rhf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.rhf.html,1,['simpl'],['simply']
Usability,"xed) for stability analysis. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet) → psi4.core.UHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.uhf.html:4200,simpl,simply,4200,psi4manual/1.3.2/api/psi4.core.uhf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.uhf.html,1,['simpl'],['simply']
Usability,"xpansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligible errors into the SAPT energy; (often less than 0.01 kcal/mol for small dimers) and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/sapt-1.html:2731,simpl,simplest,2731,psi4manual/4.0b5/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/sapt-1.html,2,['simpl'],['simplest']
Usability,"y(), opt(), etc.; with options dictionary largs.; Useful when funcarg to call is stored in variable. convert(p, symbol)[source]¶. reconstitute_bracketed_basis(needarray)[source]¶; Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form ‘cc-pv[q5]z’ from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the f_basis field of a NEED dictionary in; complete_basis_set(). Result is used to print a nicely; formatted basis set string in the results table. split_menial(menial)[source]¶; Function used by complete_basis_set() to separate; menial ‘scftot’ into [scf, tot] and ‘mp2corl’ into [mp2, corl]. tblhead(tbl_maxrgt, tbl_delimit, ttype)[source]¶; Function that prints the header for the changable-width results tables in db().; tbl_maxrgt is the number of reagent columns the table must plan for. tbl_delimit; is a string of dashes of the correct length to set off the table. ttype is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. validate_bracketed_basis(basisstring)[source]¶; Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., ‘6-31+G(d,p)’; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., ‘cc-pV[Q5]Z’ is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by complete_basis_set(). validate_scheme_args(functionname, **largs)[source]¶; Function called by each extrapolation scheme in complete_basis_set().; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, ba",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:12873,simpl,simple,12873,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,8,['simpl'],['simple']
Usability,"y); task_list (Dict[str, psi4.driver.task_base.BaseComputer]). Validators:. set_driver » driver; set_molecule » molecule. field driver: DriverEnum [Required]¶. Validated by:. set_driver. field findifrec: Dict[str, Any] = {}¶. field metameta: Dict[str, Any] = {}¶. field method: str [Required]¶. field molecule: Any = None¶. Validated by:. set_molecule. field task_list: Dict[str, BaseComputer] = {}¶. computer¶; alias of AtomicComputer. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶; Run each job in task list. Parameters:; client (Optional[FractalClient]) – . get_psi_results(return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:; return_wfn (bool) – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. undisplaced molecule; compute basis if simple, else dummy basis def2-svp; e/g/h member data; QCVariables; module. Return type:; Union[float, Matrix, Tuple[Union[float, Matrix], Wavefunction]]. Returns:. ret – Gradient or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. get_results(client=None)[source]¶; Return results as FiniteDifference-flavored QCSchema. Return type:; AtomicResult. Parameters:; client (Optional[FractalClient]) – . plan()[source]¶. validator set_driver  »  driver[source]¶. validator set_molecule  »  molecule[source]¶. table of contents. Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Visualization of Normal Modes; Molden Interface Keywords; NORMAL_MODES_WRITE; WRITER_FILE_LABEL. psi4.driver.qcdb.vib Module; Functions. API. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon Functions: Invoking a Calculation; Harmonic Vibrational Analysis and Visualization of Normal Modes — f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/freq.html:10206,simpl,simple,10206,psi4manual/1.7.x/freq.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/freq.html,1,['simpl'],['simple']
Usability,"y, we will compute the Hartree-Fock SCF energy with the cc-pVDZ basis set by passing the method/basis set as a string ('scf/cc-pvdz') into the function psi4.energy(); API:. [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). [3]:. -76.02663273488399. If everything goes well, the computation should complete and should report a final restricted Hartree-Fock energy in the output file output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about \(1.0\times 10^{-6}\), so agreement is only expected for about the first 6 digits after the decimal. If the computation does not complete, there is probably a problem with the compilation or installation of the program (see the installation instructions in the main Psi4 manual section Compiling and Installing from Source.; This very simple input is sufficient to run the requested information. Notice we didn’t tell the program some otherwise useful information like the charge of the molecule (0, it’s neutral), the spin multiplicity (1 for a closed-shell molecule with all electrons paired), or the reference wavefunction to use (restricted Hartree-Fock, or RHF, is usually appropriate for a closed-shell molecule). The program correctly guessed all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not all the electrons are paired. For example, let’s run a computation on methylene (\(\text{CH}_2\)), whose ground electronic state has two unpaired electrons (triplet electronic state, or a spin multiplicity \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is not correct, so we need to tell the program the true value (3). Like many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psiapi.html:4108,simpl,simple,4108,psi4manual/1.9.x/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psiapi.html,2,['simpl'],['simple']
Usability,"y, which; requires only four full iterations to reach convergence, starting from the DF; guess. This hybrid DF/Direct procedure can significantly accelerate SCF; computations requiring exact integrals.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in Psi4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbita",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:4298,simpl,simplest,4298,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['simpl'],['simplest']
Usability,"you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:5297,simpl,simple,5297,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,8,['simpl'],"['simple', 'simpler']"
Usability,"yword is slightly complicated. For TDA calculations, the default is EXPECTATION since the evaluation of transition moments involves only a negligible amount of additional computation relative to the evaluation of the excitation energies. For EOMCC, the default is OFF since evaluation of any transition moments or properties requires approximately twice the computational time. Transition moments and dipole strengths are evaluated by default for all values of ESTATE_PROP other than OFF. Type: string; Possible Values: OFF, EXPECTATION, UNRELAXED, RESPONSE; Default: No Default. CFOUR_ESTATE_SYM (CFOUR); CFOUR — Specifies the number of excited states which are to be determined in each irreducible representation of the computational subgroup. The program attempts to find all of the lowest roots, but this is not guaranteed because the eigenvalue problem is not solved by direct matrix diagonalization, but rather by an iterative (modified Davidson) algorithm. For excited state gradient calculations, only one root (clearly) is used. In such a case, one and only one non-zero entry in the string can be used, and this value is usually set to one (i.e. 0/1/0/0). (However sometimes one wants to calculate the gradient for, say, the second root of a given symmetry, and in such a case, one could use 0/2/0/0. What happens is that both roots are calculated, but only the second one is used in the subsequent density matrix and gradient calculation.) The format used for this keyword is identical to that used in CFOUR_OCCUPATION. For example, for a computational subgroup having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Psi4 Interface: The array above is specified in PSI as (white space tolerant) [3,1,0,2]. Type: array; Default: No Default. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:37271,clear,clearly,37271,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['clear'],['clearly']
Usability,"yword is slightly complicated. For TDA calculations, the default is EXPECTATION since the evaluation of transition moments involves only a negligible amount of additional computation relative to the evaluation of the excitation energies. For EOMCC, the default is OFF since evaluation of any transition moments or properties requires approximately twice the computational time. Transition moments and dipole strengths are evaluated by default for all values of ESTATE_PROP other than OFF. Type: string; Possible Values: OFF, EXPECTATION, UNRELAXED, RESPONSE; Default: No Default. CFOUR_ESTATE_SYM (CFOUR); CFOUR — Specifies the number of excited states which are to be determined in each irreducible representation of the computational subgroup. The program attempts to find all of the lowest roots, but this is not guaranteed because the eigenvalue problem is not solved by direct matrix diagonalization, but rather by an iterative (modified Davidson) algorithm. For excited state gradient calculations, only one root (clearly) is used. In such a case, one and only one non-zero entry in the string can be used, and this value is usually set to one (i.e. 0/1/0/0). (However sometimes one wants to calculate the gradient for, say, the second root of a given symmetry, and in such a case, one could use 0/2/0/0. What happens is that both roots are calculated, but only the second one is used in the subsequent density matrix and gradient calculation.) The format used for this keyword is identical to that used in CFOUR_OCCUPATION. For example, for a computational subgroup having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Type: array; Default: No Default. CFOUR_ESTATE_TRANS (CFOUR); CFOUR — Specifies whether just the excitation energies (OFF, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:37341,clear,clearly,37341,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,['clear'],['clearly']
Usability,"z"" – processed into method=”cbs” & CBSMetadata spec;; method=""cbs"", cbsmeta=CBSMetadata – passes through. Parameters:. method (str) – User first argument to driver function. A string hint of the method –; see cases above.; basis (str) – User basis hint.; driver (DriverEnum) – The calling driver function. Note for finite difference that this is; the target driver, not the means driver. Return type:; Tuple[str, str, Dict]. psi4.driver.task_planner.task_planner(driver, method, molecule, **kwargs)[source]¶; Plans a task graph of a complex computation. Canonical Task layering:; ManyBody - BSSE treatment, many-body expansion; FiniteDifference - derivatives through stencils; Composite - basis set extrapolation, focal-point methods; Atomic - analytic single-points. Parameters:. driver (DriverEnum) – The resulting type of computation: e/g/h. Note for finite difference; that this should be the target driver, not the means driver.; method (str) – A string representation of the method such as “HF” or “B3LYP”. Special; cases are: “cbs”.; molecule (Molecule) – A Psi4 base molecule to use.; kwargs – User keyword arguments, often used to configure task computers. Returns:; A simple (AtomicComputer) or layered (CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer) task object. Layered objects contain many and multiple types of computers in a graph. Return type:; Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer]. table of contents. External API Objects; Molecule; IPIBroker; auto_fragments(); process_input(); ip_fitting(); frac_traverse(); frac_nuke(); set_output_file(); BaseComputer; BaseComputer.compute(); BaseComputer.plan(). TaskComputers; SubTaskComputers; expand_cbs_methods(); task_planner(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .  · ; 1.8.2;  · . PSI4. External API Objects. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/external_apis.html:8637,simpl,simple,8637,psi4manual/1.8.x/external_apis.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/external_apis.html,1,['simpl'],['simple']
Usability,"z"" – processed into method=”cbs” & CBSMetadata spec;; method=""cbs"", cbsmeta=CBSMetadata – passes through. Parameters:. method (str) – User first argument to driver function. A string hint of the method –; see cases above.; basis (str) – User basis hint.; driver (DriverEnum) – The calling driver function. Note for finite difference that this is; the target driver, not the means driver. Return type:; Tuple[str, str, Dict]. psi4.driver.task_planner.task_planner(driver, method, molecule, **kwargs)[source]¶; Plans a task graph of a complex computation. Canonical Task layering:; ManyBody - BSSE treatment, many-body expansion; FiniteDifference - derivatives through stencils; Composite - basis set extrapolation, focal-point methods; Atomic - analytic single-points. Parameters:. driver (DriverEnum) – The resulting type of computation: e/g/h. Note for finite difference; that this should be the target driver, not the means driver.; method (str) – A string representation of the method such as “HF” or “B3LYP”. Special; cases are: “cbs”.; molecule (Molecule) – A Psi4 base molecule to use.; kwargs – User keyword arguments, often used to configure task computers. Returns:; A simple (AtomicComputer) or layered (CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer) task object. Layered objects contain many and multiple types of computers in a graph. Return type:; Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer, ManyBodyComputer]. table of contents. External API Objects; Molecule; IPIBroker; auto_fragments(); process_input(); ip_fitting(); frac_traverse(); frac_nuke(); set_output_file(); BaseComputer; BaseComputer.compute(); BaseComputer.plan(). TaskComputers; SubTaskComputers; expand_cbs_methods(); task_planner(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .  · ; 1.9.1;  · . PSI4. External API Objects. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/external_apis.html:8707,simpl,simple,8707,psi4manual/1.9.x/external_apis.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/external_apis.html,1,['simpl'],['simple']
Usability,"z) for z in Zhash]; return _nre(pZ, geom). [docs]def B787(; cgeom: np.ndarray,; rgeom: np.ndarray,; cuniq: np.ndarray,; runiq: np.ndarray,; do_plot: bool = False,; verbose: int = 1,; atoms_map: bool = False,; run_resorting: bool = False,; mols_align: Union[bool, float] = False,; run_to_completion: bool = False,; algorithm: str = ""hungarian_uno"",; uno_cutoff: float = 1.0e-3,; run_mirror: bool = False,; ):; r""""""Use Kabsch algorithm to find best alignment of geometry `cgeom` onto; `rgeom` while sampling atom mappings restricted by `runiq` and `cuniq`. Parameters; ----------; rgeom; (nat, 3) array of reference/target/unchanged geometry. Assumed [a0]; for RMSD purposes.; cgeom; (nat, 3) array of concern/changeable geometry. Assumed [a0] for RMSD; purposes. Must have same nat, units, and atom content as rgeom.; runiq; (nat,) array of str indicating which rows (atoms) in `rgeom` are shuffleable; without changing the molecule. Generally hashes of element symbol and; mass are used, but could be as simple as ['C', 'H', 'H', 'D', 'H'] for; monodeuterated methane.; cuniq; (nat,) array of str indicating which rows (atoms) in `cgeom` are shuffleable.; See `runiq` for more details. Strings and count in `cuniq` must match; `runiq`. That is, `sorted(cuniq) == sorted(runiq)`.; do_plot; Pops up a mpl plot showing before, after, and ref geometries.; verbose; Quantity of printing. 0 to silence.; atoms_map; Whether atom1 of rgeom already corresponds to atom1 of cgeom and so on.; If `True`, no resorting will be run, parameters `runiq` and `cuniq`; may be passed as `None`, and much time will be saved.; run_resorting; Run the resorting machinery even if unnecessary because `atoms_map=True`.; mols_align; Whether ref_mol and concern_mol have identical geometries by eye; (barring orientation or atom mapping) and expected final RMSD = 0.; If `True`, procedure is truncated when RMSD condition met, saving time.; If float, convcrit at which search for minimium truncates.; run_to_completion; Run re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html:1909,simpl,simple,1909,psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,3,['simpl'],['simple']
Usability," arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential) → psi4.core.Matrix¶; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html:1639,clear,clear,1639,psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,1,['clear'],['clear']
Usability," arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: list[tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → list[tuple[float, float, float, float]]¶; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential) → psi4.core.Matrix¶; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html:1646,clear,clear,1646,psi4manual/master/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html,1,['clear'],['clear']
Usability,"¶; Binary. GDMA is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the PSI4 binary, gdma has already been installed alongside.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; gdma can be obtained through conda install gdma -c psi4.; Then enable it as a feature with ENABLE_gdma,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect gdma and activate dependent code. To remove a conda installation, conda remove gdma. Source. If using PSI4 built from source and you want gdma built from; from source also,; enable it as a feature with ENABLE_gdma,; and let the build system fetch and build it and activate dependent code. Input¶; The distributed multipole analysis (DMA) technique, developed by Anthony J.; Stone and implemented by him into the GDMA package, is available in PSI4.; The current implementation simply embeds Stone’s GDMA code into the main; executable, and generates the appropriate input files automatically. The; program takes as input a data file, and a Gaussian formatted checkpoint (see; Section FCHK) file. The simplest usage of the GDMA code is; demonstrated below, along with a listing of the options supported; these; options correspond to the options described in the; GDMA manual.; If more advanced usage is desired, which is not is permitted by the options; listed below, the user may provide their own data file containing keywords to; control the GDMA code. Simply place the data file in the directory PSI4; is called from, and provide the file name as the datafile argument to the; gdma() routine. For example, if GDMA data file is called; control.dma, the GDMA code is called as follows:; grad, wfn = gradient('mp2', return_wfn=True); gdma(wfn, datafile='control.dma'). An FCHK file will be generated for the GDMA code to read; this file will have; the prefix given by WRITER_FILE_LABEL (if set), or else by the name; of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/gdma-1.html:1442,simpl,simply,1442,psi4manual/1.4.0/gdma-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/gdma-1.html,9,['simpl'],['simply']
Usability,"¶; Python Library Documentation: method sum_of_squares; sum_of_squares(...) unbound psi4.Matrix method. sum_of_squares( (Matrix)arg1) -> float :. docstring; C++ signature :. d sum_of_squares(N3psi6MatrixE {lvalue}). psi4.Matrix.symmetrize_gradient()¶; Python Library Documentation: method symmetrize_gradient; symmetrize_gradient(...) unbound psi4.Matrix method. symmetrize_gradient( (Matrix)arg1, (Molecule)arg2) -> None :. docstring; C++ signature :. void symmetrize_gradient(N3psi6MatrixE {lvalue},N5boost10shared_ptrIN3psi8MoleculeEEE). psi4.Matrix.symmetry()¶; Python Library Documentation: method symmetry; symmetry(...) unbound psi4.Matrix method. symmetry( (Matrix)arg1) -> int :. docstring; C++ signature :. i symmetry(N3psi6MatrixE {lvalue}). psi4.Matrix.to_array()¶; Python Library Documentation: method to_array in module p4util.numpy_helper; to_array(matrix, copy=True, dense=False) unbound psi4.Matrix method. Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. psi4.Matrix.trace()¶; Python Library Documentation: method trace; trace(...) unbound psi4.Matrix method. trace( (Matrix)arg1) -> float :. docstring; C++ signature :. d trace(N3psi6MatrixE {lvalue}). psi4.Matrix.transform()¶; Python Library Documentation: method transform; transform(...) unbound psi4.Matrix method. transform( (Matrix)arg1, (Matrix)arg2) -> None :. docstring; C++ signature :. void transform(N3psi6MatrixE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE). transform( (Matrix)arg1, (Matrix)arg2 [, (Matrix)arg3]) -> None :. docstring; C++ signature :. void transform(N3psi6MatrixE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE [,N5boost10shared_ptrIN3psi6MatrixEEE]). psi4.Matrix.vector_dot()¶; Python Library Documentation: method vector_dot; vector_dot(...) unbound psi4.Matrix method. vector_dot( (Matrix)arg1, (Matrix)arg2) -> float :. docstring; C++ signature :. d vector_dot(N3psi6MatrixE {lvalue},N5boost10shared_ptrIN3psi6MatrixEEE). psi4.Matrix.zero()¶",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:215067,simpl,simply,215067,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['simpl'],['simply']
Usability,"– If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 (Optional[Dimension]) – Same as dim1 only if using a psi4.core.Dimension object. Returns; Returns the given Psi4 object. Return type; Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; >>> data = np.random.rand(20,1); >>> vector = psi4.core.Matrix.from_array(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4). Matrix to Array¶; A general function that converts NumPy arrays to PSI4 data objects. psi4.driver.p4util.numpy_helper._to_array(matrix, copy=True, dense=False)[source]¶; Converts a Psi4 Matrix or Vector to a NumPy array. Either copies the data or simply; constructs a view. Parameters. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns; Returns either a list of np.array’s or the base array depending on options. Return type; numpy.ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. table of contents. Interface to NumPy; Basics; NumPy Views; PSI4 Data Objects with Irreps; Array to Matrix; Matrix to Array. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/numpy-1.html:4156,simpl,simply,4156,psi4manual/1.4.0/numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/numpy-1.html,2,['simpl'],['simply']
Usability,"– If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 (Optional[Dimension]) – Same as dim1 only if using a psi4.core.Dimension object. Returns; Returns the given Psi4 object. Return type; Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; >>> data = np.random.rand(20,1); >>> vector = psi4.core.Matrix.from_array(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4). Matrix to Array¶; A general function that converts NumPy arrays to PSI4 data objects. psi4.driver.p4util.numpy_helper._to_array(matrix, copy=True, dense=False)[source]¶; Converts a Psi4 Matrix or Vector to a NumPy array. Either copies the data or simply; constructs a view. Parameters. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns; Returns either a list of np.array’s or the base array depending on options. Return type; numpy.ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. table of contents. Interface to NumPy; Basics; NumPy Views; PSI4 Data Objects with Irreps; Array to Matrix; Matrix to Array. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/numpy-1.html:4156,simpl,simply,4156,psi4manual/1.5.0/numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/numpy-1.html,2,['simpl'],['simply']
Usability,"– If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 (Optional[Dimension]) – Same as dim1 only if using a psi4.core.Dimension object. Returns; Returns the given Psi4 object. Return type; Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; >>> data = np.random.rand(20,1); >>> vector = psi4.core.Matrix.from_array(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4). Matrix to Array¶; A general function that converts NumPy arrays to PSI4 data objects. psi4.driver.p4util.numpy_helper._to_array(matrix, copy=True, dense=False)[source]¶; Converts a Psi4 Matrix or Vector to a NumPy array. Either copies the data or simply; constructs a view. Parameters. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns; Returns either a list of np.array’s or the base array depending on options. Return type; numpy.ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. table of contents. Interface to NumPy; Basics; NumPy Views; PSI4 Data Objects with Irreps; Array to Matrix; Matrix to Array. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/numpy.html:4156,simpl,simply,4156,psi4manual/1.6.x/numpy.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/numpy.html,1,['simpl'],['simply']
Usability,"→ List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp) → None¶; Clear the list of properties to compute. compute(self: psi4.core.OEProp) → None¶; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0) → None¶; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0) → None¶; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_names(self: psi4.core.OEProp, arg0: Set[str]) → None¶; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str) → None¶; Title OEProp for print purposes. As a side effect, saves variables as title + propertyname and only that. Follow up with side names, if the side effect is undesired,. table of contents. OEProp; OEProp; OEProp.valid_methods; OEProp.Exvals(); OEProp.Eyvals(); OEProp.Ezvals(); OEProp.Vvals(); OEProp.add(); OEProp.clear(); OEProp.compute(); OEProp.set_Da_ao(); OEProp.set_Da_mo(); OEProp.set_Da_so(); OEProp.set_Db_ao(); OEProp.set_Db_mo(); OEProp.set_Db_so(); OEProp.set_names(); OEProp.set_title(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; OEProp. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.OEProp.html:3138,clear,clear,3138,psi4manual/1.8.x/api/psi4.core.OEProp.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.OEProp.html,1,['clear'],['clear']
Usability,"→ List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp) → None¶; Clear the list of properties to compute. compute(self: psi4.core.OEProp) → None¶; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0) → None¶; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0) → None¶; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_names(self: psi4.core.OEProp, arg0: Set[str]) → None¶; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str) → None¶; Title OEProp for print purposes. As a side effect, saves variables as title + propertyname and only that. Follow up with side names, if the side effect is undesired,. table of contents. OEProp; OEProp; OEProp.valid_methods; OEProp.Exvals(); OEProp.Eyvals(); OEProp.Ezvals(); OEProp.Vvals(); OEProp.add(); OEProp.clear(); OEProp.compute(); OEProp.set_Da_ao(); OEProp.set_Da_mo(); OEProp.set_Da_so(); OEProp.set_Db_ao(); OEProp.set_Db_mo(); OEProp.set_Db_so(); OEProp.set_names(); OEProp.set_title(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; OEProp. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.OEProp.html:3138,clear,clear,3138,psi4manual/1.9.x/api/psi4.core.OEProp.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.OEProp.html,1,['clear'],['clear']
Usability,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_ANH_ALGORITHM. Specifies which algorithm is used for CFOUR_ANHARMONIC =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations being done in series. If PARALLEL (=1), then the job stops after the second-derivative calculation at the reference geometry and generates out all input geometries for the remaining calculation. These can be then processed in “parallel” (currently not recommended). Note that it is recommended to carry out all calculations with PARALLEL, even when the actual calculation is carried out in a sequential mode. Type: string; Possible Values: STANDARD, PARALLEL; Default: STANDARD. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_anh_algorithm-1.html:276,simpl,simply,276,psi4manual/1.1.0/autodir_options_c/cfour__cfour_anh_algorithm-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_anh_algorithm-1.html,2,['simpl'],['simply']
Usability,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_ESTATE_SYM. Specifies the number of excited states which are to be determined in each irreducible representation of the computational subgroup. The program attempts to find all of the lowest roots, but this is not guaranteed because the eigenvalue problem is not solved by direct matrix diagonalization, but rather by an iterative (modified Davidson) algorithm. For excited state gradient calculations, only one root (clearly) is used. In such a case, one and only one non-zero entry in the string can be used, and this value is usually set to one (i.e. 0/1/0/0). (However sometimes one wants to calculate the gradient for, say, the second root of a given symmetry, and in such a case, one could use 0/2/0/0. What happens is that both roots are calculated, but only the second one is used in the subsequent density matrix and gradient calculation.) The format used for this keyword is identical to that used in CFOUR_OCCUPATION For example, for a computational subgroup having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Type: array; Default: No Default. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_estate_sym-1.html:546,clear,clearly,546,psi4manual/1.1.0/autodir_options_c/cfour__cfour_estate_sym-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_estate_sym-1.html,2,['clear'],['clearly']
Usability,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_QRHFGUES. If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_QRHF_GENERAL CFOUR_QRHF_ORBITAL and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge “difficult” SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calculation; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the CFOUR_REFERENCE keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_qrhfgues-1.html:791,simpl,simply,791,psi4manual/1.1.0/autodir_options_c/cfour__cfour_qrhfgues-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_qrhfgues-1.html,2,['simpl'],['simply']
Usability,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_ANH_ALGORITHM. Specifies which algorithm is used for CFOUR_ANHARMONIC =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations being done in series. If PARALLEL (=1), then the job stops after the second-derivative calculation at the reference geometry and generates out all input geometries for the remaining calculation. These can be then processed in “parallel” (currently not recommended). Note that it is recommended to carry out all calculations with PARALLEL, even when the actual calculation is carried out in a sequential mode. Type: string; Possible Values: STANDARD, PARALLEL; Default: STANDARD. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_anh_algorithm-1.html:278,simpl,simply,278,psi4manual/1.2.1/autodir_options_c/cfour__cfour_anh_algorithm-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_anh_algorithm-1.html,2,['simpl'],['simply']
Usability,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_ESTATE_SYM. Specifies the number of excited states which are to be determined in each irreducible representation of the computational subgroup. The program attempts to find all of the lowest roots, but this is not guaranteed because the eigenvalue problem is not solved by direct matrix diagonalization, but rather by an iterative (modified Davidson) algorithm. For excited state gradient calculations, only one root (clearly) is used. In such a case, one and only one non-zero entry in the string can be used, and this value is usually set to one (i.e. 0/1/0/0). (However sometimes one wants to calculate the gradient for, say, the second root of a given symmetry, and in such a case, one could use 0/2/0/0. What happens is that both roots are calculated, but only the second one is used in the subsequent density matrix and gradient calculation.) The format used for this keyword is identical to that used in CFOUR_OCCUPATION For example, for a computational subgroup having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Psi4 Interface: The array above is specified in PSI as (white space tolerant) [3,1,0,2]. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_estate_sym-1.html:548,clear,clearly,548,psi4manual/1.2.1/autodir_options_c/cfour__cfour_estate_sym-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_estate_sym-1.html,2,['clear'],['clearly']
Usability,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_QRHFGUES. If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_QRHF_GENERAL CFOUR_QRHF_ORBITAL and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge “difficult” SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calculation; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the CFOUR_REFERENCE keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_qrhfgues-1.html:793,simpl,simply,793,psi4manual/1.2.1/autodir_options_c/cfour__cfour_qrhfgues-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_qrhfgues-1.html,2,['simpl'],['simply']
Usability,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_ANH_ALGORITHM. Specifies which algorithm is used for CFOUR_ANHARMONIC =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations being done in series. If PARALLEL (=1), then the job stops after the second-derivative calculation at the reference geometry and generates out all input geometries for the remaining calculation. These can be then processed in “parallel” (currently not recommended). Note that it is recommended to carry out all calculations with PARALLEL, even when the actual calculation is carried out in a sequential mode. Type: string; Possible Values: STANDARD, PARALLEL; Default: STANDARD. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_anh_algorithm-1.html:278,simpl,simply,278,psi4manual/1.3.2/autodir_options_c/cfour__cfour_anh_algorithm-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_anh_algorithm-1.html,2,['simpl'],['simply']
Usability,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_ESTATE_SYM. Specifies the number of excited states which are to be determined in each irreducible representation of the computational subgroup. The program attempts to find all of the lowest roots, but this is not guaranteed because the eigenvalue problem is not solved by direct matrix diagonalization, but rather by an iterative (modified Davidson) algorithm. For excited state gradient calculations, only one root (clearly) is used. In such a case, one and only one non-zero entry in the string can be used, and this value is usually set to one (i.e. 0/1/0/0). (However sometimes one wants to calculate the gradient for, say, the second root of a given symmetry, and in such a case, one could use 0/2/0/0. What happens is that both roots are calculated, but only the second one is used in the subsequent density matrix and gradient calculation.) The format used for this keyword is identical to that used in CFOUR_OCCUPATION For example, for a computational subgroup having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Psi4 Interface: The array above is specified in PSI as (white space tolerant) [3,1,0,2]. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_estate_sym-1.html:548,clear,clearly,548,psi4manual/1.3.2/autodir_options_c/cfour__cfour_estate_sym-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_estate_sym-1.html,2,['clear'],['clearly']
Usability,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_QRHFGUES. If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_QRHF_GENERAL CFOUR_QRHF_ORBITAL and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge “difficult” SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calculation; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the CFOUR_REFERENCE keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_qrhfgues-1.html:793,simpl,simply,793,psi4manual/1.3.2/autodir_options_c/cfour__cfour_qrhfgues-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_qrhfgues-1.html,2,['simpl'],['simply']
Usability,"﻿. A Psi4 Tutorial — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » . A Psi4 Tutorial¶. Note; Some Psi4 functions and keywords have aliases. For example,; frequency(), frequencies(), and freq() all work to; obtain vibrational frequencies. Basic Input File Structure¶; Psi4 reads input from a text file, which can be prepared in any standard; text editor. The default input file name is input.dat and the; default output file name is output.dat. So that you can give your; files meaningful names, these defaults can be changed by specifying; the input file name and output file name on the the command line.; The syntax is:; >>> psi4 input-name output-name. If you give an input name but no output name, then the output name will; be the same as the input name (subtracting any ”.in” or ”.dat” suffix),; plus a ”.out” suffix. Sample Input Files¶; Below, we will provide a few simple input files as examples. A large; number of sample input files, covering everything from single-point energies; using density-functional theory to response properties from coupled-cluster; theory, can be found in the psi4/samples directory. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). Note; The memory and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once Psi4 is in your path (see the; User Configuration; section of the installation instr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:943,simpl,simple,943,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['simpl'],['simple']
Usability,"﻿. A24. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Psithon Functions: Invoking a Calculation; Database — database(); A24. A24¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries from <Reference>.; Reference interaction energies from Rezac and Hobza, JCTC (in press). cp 'off' <erase this comment and after unless on is a valid option> || 'on'; rlxd 'off' <erase this comment and after unless on is valid option> || 'on'; benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. BBI¶. Database (Merz) of protein backbone-backbone interactions.; Geometries from Kenneth Merz Group, Univ. of Florida.; Reference interaction energies from Sherrill group, Georgia Tech.; Part of the BioFragment Database (BFDb). cp 'off' || 'on'; rlxd 'off'. BENCH12¶. Database of <description of members and reference energy type>.; Geometries from <Reference>.; Reference interaction energies from <Reference>. benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small'; 'large'; 'alkenes'; 'alkanes'; 'acenes'; 'thiophenes'; 'h2o_size'; 'h2o_shape'; 'atoms'; 'S22_HB'; 'S22_MX'; 'S22_DD'. O24by5mb¶. Database (O24) of interaction energies for small open-shell high-spin bimolecular complexes.; Geometries taken from https://gitlab.com/piotr.zuchowski/o24x5/-/tree/4ec3cae0546b6ae4f4f2cf28482cd164c8323cc6.; Reference interaction energies taken from J. Chem. Phys. 154, 134106 (2021) https://doi.org/10.1063/5.0043793.; Variant with ghosted hydrogen as midbonds in the COM. no | name | subset. 1 | CN - He | DD; 2 | NH - He | DD; 3 | C2H3 - C2H4 | DD;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_available_databases.html:717,simpl,simple,717,psi4manual/1.9.x/autodoc_available_databases.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_available_databases.html,1,['simpl'],['simple']
Usability,"﻿. BSVec. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec¶. class psi4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: list[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: list[psi4.core.ShellInfo], L: list[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: list[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: list[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: list[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: list[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: list[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html:254,clear,clear,254,psi4manual/master/api/psi4.core.BSVec.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.BSVec.html,2,['clear'],['clear']
Usability,"﻿. BSVec. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec¶. class psi4.core.BSVec¶; Bases: pybind11_builtins.pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.bsvec.html:263,clear,clear,263,psi4manual/1.4.0/api/psi4.core.bsvec.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.bsvec.html,2,['clear'],['clear']
Usability,"﻿. BSVec. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec¶. class psi4.core.BSVec¶; Bases: pybind11_builtins.pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.bsvec.html:263,clear,clear,263,psi4manual/1.5.0/api/psi4.core.bsvec.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.bsvec.html,2,['clear'],['clear']
Usability,"﻿. BSVec. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec¶. class psi4.core.BSVec¶; Bases: pybind11_builtins.pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.BSVec.html:263,clear,clear,263,psi4manual/1.6.x/api/psi4.core.BSVec.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.BSVec.html,2,['clear'],['clear']
Usability,"﻿. BSVec. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec¶. class psi4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html:245,clear,clear,245,psi4manual/1.7.x/api/psi4.core.BSVec.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.BSVec.html,2,['clear'],['clear']
Usability,"﻿. BSVec. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec¶. class psi4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Pytho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html:247,clear,clear,247,psi4manual/1.8.x/api/psi4.core.BSVec.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.BSVec.html,2,['clear'],['clear']
Usability,"﻿. BSVec. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec¶. class psi4.core.BSVec¶; Bases: pybind11_object; Methods Summary. append(self, x); Add an item to the end of the list. clear(self); Clear the contents. count(self, x); Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. insert(self, i, x); Insert an item at a given position. pop(*args, **kwargs); Overloaded function. remove(self, x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo]) → None¶; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → int¶; Return the number of times x appears in the list. extend(*args, **kwargs)¶; Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo) → None¶; Insert an item at a given position. pop(*args, **kwargs)¶; Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo) → None¶; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Pytho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html:247,clear,clear,247,psi4manual/1.9.x/api/psi4.core.BSVec.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html,2,['clear'],['clear']
Usability,"﻿. Build & Run FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Installation and Runtime Configuration; Build & Run FAQ. Build & Run FAQ¶. Warning; As of v1.8, primary binary distribution has moved from; the psi4 channel to the conda-forge channel. Neither install docs; for users nor compile docs for developers have been updated yet to; reflect new patterns. Please consult psicode downloads; page for the latest guides. Obtaining and Updating PSI4¶. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}; Find-the-code Quiz; Binary Installer; Clone from GitHub Repository; Fork from GitHub Repository; Tarball from GitHub Repository; How to update and rebuild Psi4. Configuring and Installing PSI4 via Binary¶. How to install a Psi4 binary with the Psi4conda installer, download site; How to install a Psi4 binary with the Psi4conda installer, command-line; How to install a Psi4 binary into an Ana/Miniconda distribution; How to update a Psi4 binary; How to use conda to compile Psi4 faster and easier; What do the conda packages psi4 & psi4-dev and the installer psi4conda contain; How to get high angular momentum integrals from conda. Configuring, Building, and Installing PSI4 via Source¶. Planning: how to configure Psi4 and invoke CMake; How to build and install Psi4, the compact version; How to build, test, and install Psi4, in detail; How to see what build configuration options are available; How to choose the compilation directory, {objdir}; How to install elsewhere than /usr/local/psi4; How to use conda to get a Psi4 development environment; How to configure code to use high angular momentum basis sets; How to see the actual compiling commands (or errors) with cmake; How to save configuration settings for a future compilation; How to configure a Psi4 build on Cray. Non-QC Dependencies¶. What are the tools and dependencies strictly required for building Psi4; How to configure Python for building Psi4; How to handle “",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_faq.html:448,guid,guides,448,psi4manual/master/build_faq.html,https://psicode.org,https://psicode.org/psi4manual/master/build_faq.html,1,['guid'],['guides']
Usability,"﻿. Build & Run FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Installation and Runtime Configuration; Build & Run FAQ. Build & Run FAQ¶. Warning; As of v1.8, primary binary distribution has moved from; the psi4 channel to the conda-forge channel. Neither install docs; for users nor compile docs for developers have been updated yet to; reflect new patterns. Please consult psicode downloads; page for the latest guides. Obtaining and Updating PSI4¶. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}; Find-the-code Quiz; Binary Installer; Clone from GitHub Repository; Fork from GitHub Repository; Tarball from GitHub Repository; How to update and rebuild Psi4. Configuring and Installing PSI4 via Binary¶. How to install a Psi4 binary with the Psi4conda installer, download site; How to install a Psi4 binary with the Psi4conda installer, command-line; How to install a Psi4 binary into an Ana/Miniconda distribution; How to update a Psi4 binary; How to use conda to compile Psi4 faster and easier; What do the conda packages psi4 & psi4-dev and the installer psi4conda contain; How to get high angular momentum integrals from conda. Configuring, Building, and Installing PSI4 via Source¶. Planning: how to configure Psi4 and invoke CMake; How to build and install Psi4, the compact version; How to build, test, and install Psi4, in detail; How to see what build configuration options are available; How to choose the compilation directory, {objdir}; How to install elsewhere than /usr/local/psi4; How to use conda to get a Psi4 development environment; How to configure code to use high angular momentum basis sets; How to see the actual compiling commands (or errors) with cmake; How to save configuration settings for a future compilation; How to configure a Psi4 build on Cray. Non-QC Dependencies¶. What are the tools and dependencies strictly required for building Psi4; How to configure Python for building Psi4; How to handle “runtime",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/build_faq.html:441,guid,guides,441,psi4manual/1.8.x/build_faq.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/build_faq.html,1,['guid'],['guides']
Usability,"﻿. Build & Run FAQ. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Installation and Runtime Configuration; Build & Run FAQ. Build & Run FAQ¶. Warning; As of v1.8, primary binary distribution has moved from; the psi4 channel to the conda-forge channel. Neither install docs; for users nor compile docs for developers have been updated yet to; reflect new patterns. Please consult psicode downloads; page for the latest guides. Obtaining and Updating PSI4¶. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}; Find-the-code Quiz; Binary Installer; Clone from GitHub Repository; Fork from GitHub Repository; Tarball from GitHub Repository; How to update and rebuild Psi4. Configuring and Installing PSI4 via Binary¶. How to install a Psi4 binary with the Psi4conda installer, download site; How to install a Psi4 binary with the Psi4conda installer, command-line; How to install a Psi4 binary into an Ana/Miniconda distribution; How to update a Psi4 binary; How to use conda to compile Psi4 faster and easier; What do the conda packages psi4 & psi4-dev and the installer psi4conda contain; How to get high angular momentum integrals from conda. Configuring, Building, and Installing PSI4 via Source¶. Planning: how to configure Psi4 and invoke CMake; How to build and install Psi4, the compact version; How to build, test, and install Psi4, in detail; How to see what build configuration options are available; How to choose the compilation directory, {objdir}; How to install elsewhere than /usr/local/psi4; How to use conda to get a Psi4 development environment; How to configure code to use high angular momentum basis sets; How to see the actual compiling commands (or errors) with cmake; How to save configuration settings for a future compilation; How to configure a Psi4 build on Cray. Non-QC Dependencies¶. What are the tools and dependencies strictly required for building Psi4; How to configure Python for building Psi4; How to handle “runtime",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/build_faq.html:441,guid,guides,441,psi4manual/1.9.x/build_faq.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/build_faq.html,1,['guid'],['guides']
Usability,"﻿. CFOUR_ANH_ALGORITHM — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Keywords by Module »; CFOUR ». CFOUR_ANH_ALGORITHM¶. Specifies which algorithm is used for CFOUR_ANHARMONIC =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations being done in series. If PARALLEL (=1), then the job stops after the second-derivative calculation at the reference geometry and generates out all input geometries for the remaining calculation. These can be then processed in “parallel” (currently not recommended). Note that it is recommended to carry out all calculations with PARALLEL, even when the actual calculation is carried out in a sequential mode. Type: string; Possible Values: STANDARD, PARALLEL; Default: STANDARD. Previous topic; CFOUR_ACTIVE_ORBI; Next topic; CFOUR_ANH_DERIVATIVES. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Keywords by Module »; CFOUR ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/cfour__cfour_anh_algorithm-1.html:342,simpl,simply,342,psi4manual/1.0.0/autodir_options_c/cfour__cfour_anh_algorithm-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/cfour__cfour_anh_algorithm-1.html,2,['simpl'],['simply']
Usability,"﻿. CFOUR_ANH_ALGORITHM. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ANH_ALGORITHM. CFOUR_ANH_ALGORITHM¶. Specifies which algorithm is used for CFOUR_ANHARMONIC =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations being done in series. If PARALLEL (=1), then the job stops after the second-derivative calculation at the reference geometry and generates out all input geometries for the remaining calculation. These can be then processed in “parallel” (currently not recommended). Note that it is recommended to carry out all calculations with PARALLEL, even when the actual calculation is carried out in a sequential mode. Type: string; Possible Values: STANDARD, PARALLEL; Default: STANDARD. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ANH_ALGORITHM. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/cfour__cfour_anh_algorithm.html:316,simpl,simply,316,psi4manual/master/autodir_options_c/cfour__cfour_anh_algorithm.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/cfour__cfour_anh_algorithm.html,1,['simpl'],['simply']
Usability,"﻿. CFOUR_ANH_ALGORITHM. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ANH_ALGORITHM. CFOUR_ANH_ALGORITHM¶. Specifies which algorithm is used for CFOUR_ANHARMONIC =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations being done in series. If PARALLEL (=1), then the job stops after the second-derivative calculation at the reference geometry and generates out all input geometries for the remaining calculation. These can be then processed in “parallel” (currently not recommended). Note that it is recommended to carry out all calculations with PARALLEL, even when the actual calculation is carried out in a sequential mode. Type: string; Possible Values: STANDARD, PARALLEL; Default: STANDARD. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ANH_ALGORITHM. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/cfour__cfour_anh_algorithm-1.html:307,simpl,simply,307,psi4manual/1.4.0/autodir_options_c/cfour__cfour_anh_algorithm-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/cfour__cfour_anh_algorithm-1.html,2,['simpl'],['simply']
Usability,"﻿. CFOUR_ANH_ALGORITHM. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ANH_ALGORITHM. CFOUR_ANH_ALGORITHM¶. Specifies which algorithm is used for CFOUR_ANHARMONIC =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations being done in series. If PARALLEL (=1), then the job stops after the second-derivative calculation at the reference geometry and generates out all input geometries for the remaining calculation. These can be then processed in “parallel” (currently not recommended). Note that it is recommended to carry out all calculations with PARALLEL, even when the actual calculation is carried out in a sequential mode. Type: string; Possible Values: STANDARD, PARALLEL; Default: STANDARD. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ANH_ALGORITHM. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/cfour__cfour_anh_algorithm-1.html:307,simpl,simply,307,psi4manual/1.5.0/autodir_options_c/cfour__cfour_anh_algorithm-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/cfour__cfour_anh_algorithm-1.html,2,['simpl'],['simply']
Usability,"﻿. CFOUR_ANH_ALGORITHM. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ANH_ALGORITHM. CFOUR_ANH_ALGORITHM¶. Specifies which algorithm is used for CFOUR_ANHARMONIC =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations being done in series. If PARALLEL (=1), then the job stops after the second-derivative calculation at the reference geometry and generates out all input geometries for the remaining calculation. These can be then processed in “parallel” (currently not recommended). Note that it is recommended to carry out all calculations with PARALLEL, even when the actual calculation is carried out in a sequential mode. Type: string; Possible Values: STANDARD, PARALLEL; Default: STANDARD. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ANH_ALGORITHM. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/cfour__cfour_anh_algorithm.html:307,simpl,simply,307,psi4manual/1.6.x/autodir_options_c/cfour__cfour_anh_algorithm.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/cfour__cfour_anh_algorithm.html,1,['simpl'],['simply']
Usability,"﻿. CFOUR_ANH_ALGORITHM. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ANH_ALGORITHM. CFOUR_ANH_ALGORITHM¶. Specifies which algorithm is used for CFOUR_ANHARMONIC =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations being done in series. If PARALLEL (=1), then the job stops after the second-derivative calculation at the reference geometry and generates out all input geometries for the remaining calculation. These can be then processed in “parallel” (currently not recommended). Note that it is recommended to carry out all calculations with PARALLEL, even when the actual calculation is carried out in a sequential mode. Type: string; Possible Values: STANDARD, PARALLEL; Default: STANDARD. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ANH_ALGORITHM. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/cfour__cfour_anh_algorithm.html:307,simpl,simply,307,psi4manual/1.7.x/autodir_options_c/cfour__cfour_anh_algorithm.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/cfour__cfour_anh_algorithm.html,1,['simpl'],['simply']
Usability,"﻿. CFOUR_ANH_ALGORITHM. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ANH_ALGORITHM. CFOUR_ANH_ALGORITHM¶. Specifies which algorithm is used for CFOUR_ANHARMONIC =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations being done in series. If PARALLEL (=1), then the job stops after the second-derivative calculation at the reference geometry and generates out all input geometries for the remaining calculation. These can be then processed in “parallel” (currently not recommended). Note that it is recommended to carry out all calculations with PARALLEL, even when the actual calculation is carried out in a sequential mode. Type: string; Possible Values: STANDARD, PARALLEL; Default: STANDARD. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ANH_ALGORITHM. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/cfour__cfour_anh_algorithm.html:309,simpl,simply,309,psi4manual/1.8.x/autodir_options_c/cfour__cfour_anh_algorithm.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/cfour__cfour_anh_algorithm.html,1,['simpl'],['simply']
Usability,"﻿. CFOUR_ANH_ALGORITHM. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ANH_ALGORITHM. CFOUR_ANH_ALGORITHM¶. Specifies which algorithm is used for CFOUR_ANHARMONIC =VIBROT, VPT2, and FULLQUARTIC calculations. If STANDARD (=0) is chosen, then simply invoking xcfour will cause a complete job to be run with all second-derivative calculations being done in series. If PARALLEL (=1), then the job stops after the second-derivative calculation at the reference geometry and generates out all input geometries for the remaining calculation. These can be then processed in “parallel” (currently not recommended). Note that it is recommended to carry out all calculations with PARALLEL, even when the actual calculation is carried out in a sequential mode. Type: string; Possible Values: STANDARD, PARALLEL; Default: STANDARD. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ANH_ALGORITHM. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/cfour__cfour_anh_algorithm.html:309,simpl,simply,309,psi4manual/1.9.x/autodir_options_c/cfour__cfour_anh_algorithm.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/cfour__cfour_anh_algorithm.html,1,['simpl'],['simply']
Usability,"﻿. CFOUR_ESTATE_SYM — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Keywords by Module »; CFOUR ». CFOUR_ESTATE_SYM¶. Specifies the number of excited states which are to be determined in each irreducible representation of the computational subgroup. The program attempts to find all of the lowest roots, but this is not guaranteed because the eigenvalue problem is not solved by direct matrix diagonalization, but rather by an iterative (modified Davidson) algorithm. For excited state gradient calculations, only one root (clearly) is used. In such a case, one and only one non-zero entry in the string can be used, and this value is usually set to one (i.e. 0/1/0/0). (However sometimes one wants to calculate the gradient for, say, the second root of a given symmetry, and in such a case, one could use 0/2/0/0. What happens is that both roots are calculated, but only the second one is used in the subsequent density matrix and gradient calculation.) The format used for this keyword is identical to that used in CFOUR_OCCUPATION For example, for a computational subgroup having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Type: array; Default: No Default. Previous topic; CFOUR_ESTATE_PROP; Next topic; CFOUR_ESTATE_TRANS. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Keywords by Module »; CFOUR ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/cfour__cfour_estate_sym-1.html:609,clear,clearly,609,psi4manual/1.0.0/autodir_options_c/cfour__cfour_estate_sym-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/cfour__cfour_estate_sym-1.html,2,['clear'],['clearly']
Usability,"﻿. CFOUR_ESTATE_SYM. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ESTATE_SYM. CFOUR_ESTATE_SYM¶. Specifies the number of excited states which are to be determined in each irreducible representation of the computational subgroup. The program attempts to find all of the lowest roots, but this is not guaranteed because the eigenvalue problem is not solved by direct matrix diagonalization, but rather by an iterative (modified Davidson) algorithm. For excited state gradient calculations, only one root (clearly) is used. In such a case, one and only one non-zero entry in the string can be used, and this value is usually set to one (i.e. 0/1/0/0). (However sometimes one wants to calculate the gradient for, say, the second root of a given symmetry, and in such a case, one could use 0/2/0/0. What happens is that both roots are calculated, but only the second one is used in the subsequent density matrix and gradient calculation.) The format used for this keyword is identical to that used in CFOUR_OCCUPATION For example, for a computational subgroup having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Psi4 Interface: The array above is specified in PSI as (white space tolerant) [3,1,0,2]. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ESTATE_SYM. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/cfour__cfour_estate_sym.html:580,clear,clearly,580,psi4manual/master/autodir_options_c/cfour__cfour_estate_sym.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/cfour__cfour_estate_sym.html,1,['clear'],['clearly']
Usability,"﻿. CFOUR_ESTATE_SYM. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ESTATE_SYM. CFOUR_ESTATE_SYM¶. Specifies the number of excited states which are to be determined in each irreducible representation of the computational subgroup. The program attempts to find all of the lowest roots, but this is not guaranteed because the eigenvalue problem is not solved by direct matrix diagonalization, but rather by an iterative (modified Davidson) algorithm. For excited state gradient calculations, only one root (clearly) is used. In such a case, one and only one non-zero entry in the string can be used, and this value is usually set to one (i.e. 0/1/0/0). (However sometimes one wants to calculate the gradient for, say, the second root of a given symmetry, and in such a case, one could use 0/2/0/0. What happens is that both roots are calculated, but only the second one is used in the subsequent density matrix and gradient calculation.) The format used for this keyword is identical to that used in CFOUR_OCCUPATION For example, for a computational subgroup having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Psi4 Interface: The array above is specified in PSI as (white space tolerant) [3,1,0,2]. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ESTATE_SYM. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/cfour__cfour_estate_sym-1.html:571,clear,clearly,571,psi4manual/1.4.0/autodir_options_c/cfour__cfour_estate_sym-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/cfour__cfour_estate_sym-1.html,2,['clear'],['clearly']
Usability,"﻿. CFOUR_ESTATE_SYM. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ESTATE_SYM. CFOUR_ESTATE_SYM¶. Specifies the number of excited states which are to be determined in each irreducible representation of the computational subgroup. The program attempts to find all of the lowest roots, but this is not guaranteed because the eigenvalue problem is not solved by direct matrix diagonalization, but rather by an iterative (modified Davidson) algorithm. For excited state gradient calculations, only one root (clearly) is used. In such a case, one and only one non-zero entry in the string can be used, and this value is usually set to one (i.e. 0/1/0/0). (However sometimes one wants to calculate the gradient for, say, the second root of a given symmetry, and in such a case, one could use 0/2/0/0. What happens is that both roots are calculated, but only the second one is used in the subsequent density matrix and gradient calculation.) The format used for this keyword is identical to that used in CFOUR_OCCUPATION For example, for a computational subgroup having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Psi4 Interface: The array above is specified in PSI as (white space tolerant) [3,1,0,2]. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ESTATE_SYM. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/cfour__cfour_estate_sym-1.html:571,clear,clearly,571,psi4manual/1.5.0/autodir_options_c/cfour__cfour_estate_sym-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/cfour__cfour_estate_sym-1.html,2,['clear'],['clearly']
Usability,"﻿. CFOUR_ESTATE_SYM. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ESTATE_SYM. CFOUR_ESTATE_SYM¶. Specifies the number of excited states which are to be determined in each irreducible representation of the computational subgroup. The program attempts to find all of the lowest roots, but this is not guaranteed because the eigenvalue problem is not solved by direct matrix diagonalization, but rather by an iterative (modified Davidson) algorithm. For excited state gradient calculations, only one root (clearly) is used. In such a case, one and only one non-zero entry in the string can be used, and this value is usually set to one (i.e. 0/1/0/0). (However sometimes one wants to calculate the gradient for, say, the second root of a given symmetry, and in such a case, one could use 0/2/0/0. What happens is that both roots are calculated, but only the second one is used in the subsequent density matrix and gradient calculation.) The format used for this keyword is identical to that used in CFOUR_OCCUPATION For example, for a computational subgroup having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Psi4 Interface: The array above is specified in PSI as (white space tolerant) [3,1,0,2]. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ESTATE_SYM. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/cfour__cfour_estate_sym.html:571,clear,clearly,571,psi4manual/1.6.x/autodir_options_c/cfour__cfour_estate_sym.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/cfour__cfour_estate_sym.html,1,['clear'],['clearly']
Usability,"﻿. CFOUR_ESTATE_SYM. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ESTATE_SYM. CFOUR_ESTATE_SYM¶. Specifies the number of excited states which are to be determined in each irreducible representation of the computational subgroup. The program attempts to find all of the lowest roots, but this is not guaranteed because the eigenvalue problem is not solved by direct matrix diagonalization, but rather by an iterative (modified Davidson) algorithm. For excited state gradient calculations, only one root (clearly) is used. In such a case, one and only one non-zero entry in the string can be used, and this value is usually set to one (i.e. 0/1/0/0). (However sometimes one wants to calculate the gradient for, say, the second root of a given symmetry, and in such a case, one could use 0/2/0/0. What happens is that both roots are calculated, but only the second one is used in the subsequent density matrix and gradient calculation.) The format used for this keyword is identical to that used in CFOUR_OCCUPATION For example, for a computational subgroup having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Psi4 Interface: The array above is specified in PSI as (white space tolerant) [3,1,0,2]. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ESTATE_SYM. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/cfour__cfour_estate_sym.html:571,clear,clearly,571,psi4manual/1.7.x/autodir_options_c/cfour__cfour_estate_sym.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/cfour__cfour_estate_sym.html,1,['clear'],['clearly']
Usability,"﻿. CFOUR_ESTATE_SYM. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ESTATE_SYM. CFOUR_ESTATE_SYM¶. Specifies the number of excited states which are to be determined in each irreducible representation of the computational subgroup. The program attempts to find all of the lowest roots, but this is not guaranteed because the eigenvalue problem is not solved by direct matrix diagonalization, but rather by an iterative (modified Davidson) algorithm. For excited state gradient calculations, only one root (clearly) is used. In such a case, one and only one non-zero entry in the string can be used, and this value is usually set to one (i.e. 0/1/0/0). (However sometimes one wants to calculate the gradient for, say, the second root of a given symmetry, and in such a case, one could use 0/2/0/0. What happens is that both roots are calculated, but only the second one is used in the subsequent density matrix and gradient calculation.) The format used for this keyword is identical to that used in CFOUR_OCCUPATION For example, for a computational subgroup having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Psi4 Interface: The array above is specified in PSI as (white space tolerant) [3,1,0,2]. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ESTATE_SYM. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/cfour__cfour_estate_sym.html:573,clear,clearly,573,psi4manual/1.8.x/autodir_options_c/cfour__cfour_estate_sym.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/cfour__cfour_estate_sym.html,1,['clear'],['clearly']
Usability,"﻿. CFOUR_ESTATE_SYM. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ESTATE_SYM. CFOUR_ESTATE_SYM¶. Specifies the number of excited states which are to be determined in each irreducible representation of the computational subgroup. The program attempts to find all of the lowest roots, but this is not guaranteed because the eigenvalue problem is not solved by direct matrix diagonalization, but rather by an iterative (modified Davidson) algorithm. For excited state gradient calculations, only one root (clearly) is used. In such a case, one and only one non-zero entry in the string can be used, and this value is usually set to one (i.e. 0/1/0/0). (However sometimes one wants to calculate the gradient for, say, the second root of a given symmetry, and in such a case, one could use 0/2/0/0. What happens is that both roots are calculated, but only the second one is used in the subsequent density matrix and gradient calculation.) The format used for this keyword is identical to that used in CFOUR_OCCUPATION For example, for a computational subgroup having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Psi4 Interface: The array above is specified in PSI as (white space tolerant) [3,1,0,2]. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_ESTATE_SYM. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/cfour__cfour_estate_sym.html:573,clear,clearly,573,psi4manual/1.9.x/autodir_options_c/cfour__cfour_estate_sym.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/cfour__cfour_estate_sym.html,1,['clear'],['clearly']
Usability,"﻿. CFOUR_QRHFGUES — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Keywords by Module »; CFOUR ». CFOUR_QRHFGUES¶. If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_QRHF_GENERAL CFOUR_QRHF_ORBITAL and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge “difficult” SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calcualtion; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the CFOUR_REFERENCE keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. Previous topic; CFOUR_QRHF_ORBITAL; Next topic; CFOUR_RAMAN_INT. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Keywords by Module »; CFOUR ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/cfour__cfour_qrhfgues-1.html:852,simpl,simply,852,psi4manual/1.0.0/autodir_options_c/cfour__cfour_qrhfgues-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/cfour__cfour_qrhfgues-1.html,2,['simpl'],['simply']
Usability,"﻿. CFOUR_QRHFGUES. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_QRHFGUES. CFOUR_QRHFGUES¶. If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_QRHF_GENERAL CFOUR_QRHF_ORBITAL and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge “difficult” SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calculation; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the CFOUR_REFERENCE keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_QRHFGUES. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/cfour__cfour_qrhfgues.html:821,simpl,simply,821,psi4manual/master/autodir_options_c/cfour__cfour_qrhfgues.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/cfour__cfour_qrhfgues.html,1,['simpl'],['simply']
Usability,"﻿. CFOUR_QRHFGUES. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_QRHFGUES. CFOUR_QRHFGUES¶. If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_QRHF_GENERAL CFOUR_QRHF_ORBITAL and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge “difficult” SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calculation; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the CFOUR_REFERENCE keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_QRHFGUES. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/cfour__cfour_qrhfgues-1.html:812,simpl,simply,812,psi4manual/1.4.0/autodir_options_c/cfour__cfour_qrhfgues-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/cfour__cfour_qrhfgues-1.html,2,['simpl'],['simply']
Usability,"﻿. CFOUR_QRHFGUES. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_QRHFGUES. CFOUR_QRHFGUES¶. If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_QRHF_GENERAL CFOUR_QRHF_ORBITAL and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge “difficult” SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calculation; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the CFOUR_REFERENCE keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_QRHFGUES. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/cfour__cfour_qrhfgues-1.html:812,simpl,simply,812,psi4manual/1.5.0/autodir_options_c/cfour__cfour_qrhfgues-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/cfour__cfour_qrhfgues-1.html,2,['simpl'],['simply']
Usability,"﻿. CFOUR_QRHFGUES. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_QRHFGUES. CFOUR_QRHFGUES¶. If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_QRHF_GENERAL CFOUR_QRHF_ORBITAL and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge “difficult” SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calculation; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the CFOUR_REFERENCE keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_QRHFGUES. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/cfour__cfour_qrhfgues.html:812,simpl,simply,812,psi4manual/1.6.x/autodir_options_c/cfour__cfour_qrhfgues.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/cfour__cfour_qrhfgues.html,1,['simpl'],['simply']
Usability,"﻿. CFOUR_QRHFGUES. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_QRHFGUES. CFOUR_QRHFGUES¶. If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_QRHF_GENERAL CFOUR_QRHF_ORBITAL and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge “difficult” SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calculation; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the CFOUR_REFERENCE keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_QRHFGUES. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/cfour__cfour_qrhfgues.html:812,simpl,simply,812,psi4manual/1.7.x/autodir_options_c/cfour__cfour_qrhfgues.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/cfour__cfour_qrhfgues.html,1,['simpl'],['simply']
Usability,"﻿. CFOUR_QRHFGUES. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_QRHFGUES. CFOUR_QRHFGUES¶. If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_QRHF_GENERAL CFOUR_QRHF_ORBITAL and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge “difficult” SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calculation; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the CFOUR_REFERENCE keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_QRHFGUES. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/cfour__cfour_qrhfgues.html:814,simpl,simply,814,psi4manual/1.8.x/autodir_options_c/cfour__cfour_qrhfgues.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/cfour__cfour_qrhfgues.html,1,['simpl'],['simply']
Usability,"﻿. CFOUR_QRHFGUES. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_QRHFGUES. CFOUR_QRHFGUES¶. If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_QRHF_GENERAL CFOUR_QRHF_ORBITAL and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge “difficult” SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calculation; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the CFOUR_REFERENCE keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_QRHFGUES. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/cfour__cfour_qrhfgues.html:814,simpl,simply,814,psi4manual/1.9.x/autodir_options_c/cfour__cfour_qrhfgues.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/cfour__cfour_qrhfgues.html,1,['simpl'],['simply']
Usability,"﻿. CI: Configuration Interaction — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». CI: Configuration Interaction¶; Code author: C. David Sherrill and Matthew L. Leininger; Section author: C. David Sherrill; Module: Keywords, PSI Variables, DETCI; Configuration interaction (CI) is one of the most general ways to; improve upon Hartree–Fock theory by adding a description of the; correlated motions of electrons. Simply put, a CI wavefunction; is a linear combination of Slater determinants (or spin-adapted; configuration state functions), with the linear coefficients being; determined variationally via diagonalization of the Hamiltonian in the; given subspace of determinants. For a “single-reference” CI based; on reference function , we can write the CI expansion as; follows:. (1); The simplest standard CI method that improves upon Hartree–Fock is a CI; that adds all singly and doubly. substituted determinants (CISD) to the reference determinant; . The CISD wavefunction has fallen out of favor; because truncated CI wavefunctions are not size-extensive, meaning; that their quality degrades for larger molecules. MP2 is a less; expensive alternative giving results similar to those of CISD for small; molecules, but the quality of MP2 does not degrade for larger molecules.; Coupled-cluster singles and doubles (CCSD) is another size-extensive; alternative; it is only slightly more costly computationally than CISD,; but it typically provides significantly more accurate results.; The CI code in PSI4 is described in detail in; [Sherrill:1999:CI]. For the reasons stated above, the CI code in; PSI4 is not optimized for CISD computations. Instead, emphasis; has been placed on developing a very efficient program to handle more; general CI wavefunctions which may be helpful in more challenging cases; such as highly strained molecules or bond breaking reactions. The CI; code is based on the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/detci-1.html:889,simpl,simplest,889,psi4manual/4.0b3/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/detci-1.html,2,['simpl'],['simplest']
Usability,"﻿. CI: Configuration Interaction — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». CI: Configuration Interaction¶; Code author: C. David Sherrill and Matthew L. Leininger; Section author: C. David Sherrill; Module: Keywords, PSI Variables, DETCI; Configuration interaction (CI) is one of the most general ways to; improve upon Hartree–Fock theory by adding a description of the; correlated motions of electrons. Simply put, a CI wavefunction; is a linear combination of Slater determinants (or spin-adapted; configuration state functions), with the linear coefficients being; determined variationally via diagonalization of the Hamiltonian in the; given subspace of determinants. For a “single-reference” CI based; on reference function , we can write the CI expansion as; follows:. (1); The simplest standard CI method that improves upon Hartree–Fock is a CI; that adds all singly and doubly. substituted determinants (CISD) to the reference determinant; . The CISD wavefunction has fallen out of favor; because truncated CI wavefunctions are not size-extensive, meaning; that their quality degrades for larger molecules. MP2 is a less; expensive alternative giving results similar to those of CISD for small; molecules, but the quality of MP2 does not degrade for larger molecules.; Coupled-cluster singles and doubles (CCSD) is another size-extensive; alternative; it is only slightly more costly computationally than CISD,; but it typically provides significantly more accurate results.; The CI code in PSI4 is described in detail in; [Sherrill:1999:CI]. For the reasons stated above, the CI code in; PSI4 is not optimized for CISD computations. Instead, emphasis; has been placed on developing a very efficient program to handle more; general CI wavefunctions which may be helpful in more challenging cases; such as highly strained molecules or bond breaking reactions. The CI; code is based on the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/detci-1.html:889,simpl,simplest,889,psi4manual/4.0b4/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/detci-1.html,2,['simpl'],['simplest']
Usability,"﻿. CI: Configuration Interaction — PSI4 [beta5] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Theoretical Methods: SCF to FCI ». CI: Configuration Interaction¶; Code author: C. David Sherrill and Matthew L. Leininger; Section author: C. David Sherrill; Module: Keywords, PSI Variables, DETCI; Configuration interaction (CI) is one of the most general ways to; improve upon Hartree–Fock theory by adding a description of the; correlated motions of electrons. Simply put, a CI wavefunction; is a linear combination of Slater determinants (or spin-adapted; configuration state functions), with the linear coefficients being; determined variationally via diagonalization of the Hamiltonian in the; given subspace of determinants. For a “single-reference” CI based; on reference function , we can write the CI expansion as; follows:. (1); The simplest standard CI method that improves upon Hartree–Fock is a CI; that adds all singly and doubly. substituted determinants (CISD) to the reference determinant; . The CISD wavefunction has fallen out of favor; because truncated CI wavefunctions are not size-extensive, meaning; that their quality degrades for larger molecules. MP2 is a less; expensive alternative giving results similar to those of CISD for small; molecules, but the quality of MP2 does not degrade for larger molecules.; Coupled-cluster singles and doubles (CCSD) is another size-extensive; alternative; it is only slightly more costly computationally than CISD,; but it typically provides significantly more accurate results.; The CI code in PSI4 is described in detail in; [Sherrill:1999:CI]. For the reasons stated above, the CI code in; PSI4 is not optimized for CISD computations. Instead, emphasis; has been placed on developing a very efficient program to handle more; general CI wavefunctions which may be helpful in more challenging cases; such as highly strained molecules or bond breaking reactions. The CI; code is based on the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/detci-1.html:889,simpl,simplest,889,psi4manual/4.0b5/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/detci-1.html,2,['simpl'],['simplest']
Usability,"﻿. CI: Configuration Interaction — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Theoretical Methods: SCF to FCI ». CI: Configuration Interaction¶; Code author: C. David Sherrill and Matthew L. Leininger; Section author: C. David Sherrill; Module: Keywords, PSI Variables, DETCI; Configuration interaction (CI) is one of the most general ways to; improve upon Hartree–Fock theory by adding a description of the; correlated motions of electrons. Simply put, a CI wavefunction; is a linear combination of Slater determinants (or spin-adapted; configuration state functions), with the linear coefficients being; determined variationally via diagonalization of the Hamiltonian in the; given subspace of determinants. For a “single-reference” CI based; on reference function , we can write the CI expansion as; follows:. (1); The simplest standard CI method that improves upon Hartree–Fock is a CI; that adds all singly and doubly. substituted determinants (CISD) to the reference determinant; . The CISD wavefunction has fallen out of favor; because truncated CI wavefunctions are not size-extensive, meaning; that their quality degrades for larger molecules. MP2 is a less; expensive alternative giving results similar to those of CISD for small; molecules, but the quality of MP2 does not degrade for larger molecules.; Coupled-cluster singles and doubles (CCSD) is another size-extensive; alternative; it is only slightly more costly computationally than CISD,; but it typically provides significantly more accurate results.; The CI code in Psi4 is described in detail in; [Sherrill:1999:CI]. For the reasons stated above, the CI code in; Psi4 is not optimized for CISD computations. Instead, emphasis; has been placed on developing a very efficient program to handle more; general CI wavefunctions which may be helpful in more challenging cases; such as highly strained molecules or bond breaking reactions. The CI; code is based ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/detci-1.html:896,simpl,simplest,896,psi4manual/1.0.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/detci-1.html,2,['simpl'],['simplest']
Usability,"﻿. CORE. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon Functions: Invoking a Calculation; Database — database(); CORE. CORE¶. Database of Pulay corannulene structures. Subsumed into CFLOW. cp 'off' || 'on'; rlxd 'off'. BAKERJCC93¶. Database of molecules that are challenging to optimize.; Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported; in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002), with a few; further corrections.; No reference energies defined. cp 'off'; rlxd 'off'; subset. 'small'; 'large'. BAKERJCC96¶. Geometries from Baker and Chan J. Comput. Chem. 17 888 (1996),. as reported in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002). No reference energies defined. cp 'off'; rlxd 'off'. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. HTR40¶. Database of Hydrogen transfer reactions.; Geometries from Bozkaya and Sherrill.; Reference energies from Bozkaya and Sherrill. benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. A24alt¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries from <Reference>.; Reference interaction energies from Rezac and Hobza, JCTC (in press). cp 'off' <erase this comment and after unless on is a valid option> || 'on'; rlxd 'off' <erase this comment and after unless on is valid option> || 'on'; benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. HTBH¶. Database (Truhlar) of hydrogen-transfer barrier height reactions.; Geometries from Truhlar and coworkers at site http://t1.chem.umn.edu/misc/database_grou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_available_databases.html:776,simpl,simple,776,psi4manual/1.7.x/autodoc_available_databases.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_available_databases.html,1,['simpl'],['simple']
Usability,"﻿. Compiling and Installing from Source. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Installation and Runtime Configuration; Compiling and Installing from Source. Compiling and Installing from Source¶. Warning; As of v1.8, primary binary distribution has moved from; the psi4 channel to the conda-forge channel. Neither install docs; for users nor compile docs for developers have been updated yet to; reflect new patterns. Please consult psi4/conda/psi4-path-advisor.py; (extensive help menu at conda/psi4-path-advisor.py -h); or psicode downloads; page for the latest guides. This section fulfills the duty of every Linux project to have an INSTALL; file detailing how to build it from source. Few (mostly packagers and; sysadmins) are expected to read this file as it is a broad guide to the; many choices in building this project. For a specific, well-tested,; and performance-tuned build path, see psicode.org/installs/latest; (select “source”). For pre-built binaries again well-tested,; performance-tuned, and available for all common operating systems,; see psicode.org/installs/latest (select “conda”).; To see working builds for Linux, Mac, and Windows, see :src:; [this GHA]. Planning: how to configure Psi4 and invoke CMake¶; PSI4 is built through CMake. An abbreviated build guide can be found; within the source itself .; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -S.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make or Ninja in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_planning.html:603,guid,guides,603,psi4manual/master/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/master/build_planning.html,2,['guid'],"['guide', 'guides']"
Usability,"﻿. Compiling and Installing from Source. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Installation and Runtime Configuration. Compiling and Installing from Source¶. Planning: how to configure Psi4 and invoke CMake¶; PSI4 is built through CMake. Prior to 1.1, PSI4 had a Python; script setup as a frontend to CMake, but this is no more, and; cmake is now invoked directly. An abbreviated build guide can be found; within the source itself.; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -H.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of arguments to cmake tailored to; your computer. Proceed to quick build or; detailed build. How to build and install Psi4, the compact version¶; This section outlines the main steps of configuring, compiling, and; installing PSI4. More detail is given here.; 1; 2; 3; 4; 5>>> cd {top-level-psi4-dir}; >>> cmake -H. -Bobjdir [your configuration options]; >>> cd objdir; >>> make -j`getconf _NPROCESSORS_ONLN`; >>> make install. How to build, test, and install Psi4, in detail¶; 1. Plan Directories. Get ahold of the PSI4 codebase, and navigate to the top level source; directory, hereafter top-level-psi4-dir. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}. 1>>> cd {top-level-psi4-dir}. Choose a compilation directory, hereafter objdir. How to choose the compilation directory, {objdir}. Choose an installation directory, hereafter prefix. How to install elsewhere than /usr/loca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:416,guid,guide,416,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['guid'],['guide']
Usability,"﻿. Compiling and Installing from Source. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Installation and Runtime Configuration. Compiling and Installing from Source¶. Planning: how to configure Psi4 and invoke CMake¶; PSI4 is built through CMake. Prior to 1.1, PSI4 had a Python; script setup as a frontend to CMake, but this is no more, and; cmake is now invoked directly. An abbreviated build guide can be found; within the source itself.; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -H.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of arguments to cmake tailored to; your computer. Proceed to quick build or; detailed build. How to build and install Psi4, the compact version¶; This section outlines the main steps of configuring, compiling, and; installing PSI4. More detail is given here.; 1; 2; 3; 4; 5>>> cd {top-level-psi4-dir}; >>> cmake -H. -Bobjdir [your configuration options]; >>> cd objdir; >>> make -j`getconf _NPROCESSORS_ONLN`; >>> make install. How to build, test, and install Psi4, in detail¶; 1. Plan Directories. Get ahold of the PSI4 codebase, and navigate to the top level source; directory, hereafter top-level-psi4-dir. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}. 1>>> cd {top-level-psi4-dir}. Choose a compilation directory, hereafter objdir. How to choose the compilation directory, {objdir}. Choose an installation directory, hereafter prefix. How to install elsewhere than /usr/lo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:418,guid,guide,418,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['guid'],['guide']
Usability,"﻿. Compiling and Installing from Source. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Installation and Runtime Configuration. Compiling and Installing from Source¶; This section fulfills the duty of every Linux project to have an INSTALL; file detailing how to build it from source. Few (mostly packagers and; sysadmins) are expected to read this file as it is a broad guide to the; many choices in building this project. For a specific, well-tested,; and performance-tuned build path, see psicode.org/installs/latest; (select “source”). For pre-built binaries again well-tested,; performance-tuned, and available for all common operating systems,; see psicode.org/installs/latest (select “conda”). Planning: how to configure Psi4 and invoke CMake¶; PSI4 is built through CMake. An abbreviated build guide can be found; within the source itself.; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -H.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of arguments to cmake tailored to; your computer. Proceed to quick build or; detailed build. How to build and install Psi4, the compact version¶; This section outlines the main steps of configuring, compiling, and; installing PSI4. More detail is given here.; 1; 2; 3; 4; 5>>> cd {top-level-psi4-dir}; >>> cmake -H. -Bobjdir [your configuration options]; >>> cd objdir; >>> make -j`getconf _NPROCESSORS_ONLN`; >>> make install. How to build, test, and install Psi4, in detail¶; 1. Plan Directories. Get ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:394,guid,guide,394,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,4,['guid'],['guide']
Usability,"﻿. Compiling and Installing from Source. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Installation and Runtime Configuration; Compiling and Installing from Source. Compiling and Installing from Source¶; This section fulfills the duty of every Linux project to have an INSTALL; file detailing how to build it from source. Few (mostly packagers and; sysadmins) are expected to read this file as it is a broad guide to the; many choices in building this project. For a specific, well-tested,; and performance-tuned build path, see psicode.org/installs/latest; (select “source”). For pre-built binaries again well-tested,; performance-tuned, and available for all common operating systems,; see psicode.org/installs/latest (select “conda”). Planning: how to configure Psi4 and invoke CMake¶; PSI4 is built through CMake. An abbreviated build guide can be found; within the source itself.; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -S.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make or Ninja in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of arguments to cmake tailored to; your computer. Proceed to quick build or; detailed build. How to build and install Psi4, the compact version¶; This section outlines the main steps of configuring, compiling, and; installing PSI4. More detail is given here.; >>> cd {top-level-psi4-dir}; >>> cmake -S. -Bobjdir [your configuration options]; >>> cd objdir; >>> make -j`getconf _NPROCESSORS_ONLN`; >>> make install. How to build, test, and install Psi4, in de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:430,guid,guide,430,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,4,['guid'],['guide']
Usability,"﻿. Compiling and Installing from Source. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Installation and Runtime Configuration; Compiling and Installing from Source. Compiling and Installing from Source¶; This section fulfills the duty of every Linux project to have an INSTALL; file detailing how to build it from source. Few (mostly packagers and; sysadmins) are expected to read this file as it is a broad guide to the; many choices in building this project. For a specific, well-tested,; and performance-tuned build path, see psicode.org/installs/latest; (select “source”). For pre-built binaries again well-tested,; performance-tuned, and available for all common operating systems,; see psicode.org/installs/latest (select “conda”). Planning: how to configure Psi4 and invoke CMake¶; PSI4 is built through CMake. An abbreviated build guide can be found; within the source itself.; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -S.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make or Ninja in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of arguments to cmake tailored to; your computer. Proceed to quick build or; detailed build. How to build and install Psi4, the compact version¶; This section outlines the main steps of configuring, compiling, and; installing PSI4. More detail is given here.; >>> cd {top-level-psi4-dir}; >>> cmake -S. -Bobjdir [your configuration options]; >>> cd objdir; >>> make -j`getconf _NPROCESSORS_ONLN`; >>> make install. How to build, test, and install Psi4, in de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/build_planning-1.html:430,guid,guide,430,psi4manual/1.5.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/build_planning-1.html,4,['guid'],['guide']
Usability,"﻿. Compiling and Installing from Source. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Installation and Runtime Configuration; Compiling and Installing from Source. Compiling and Installing from Source¶; This section fulfills the duty of every Linux project to have an INSTALL; file detailing how to build it from source. Few (mostly packagers and; sysadmins) are expected to read this file as it is a broad guide to the; many choices in building this project. For a specific, well-tested,; and performance-tuned build path, see psicode.org/installs/latest; (select “source”). For pre-built binaries again well-tested,; performance-tuned, and available for all common operating systems,; see psicode.org/installs/latest (select “conda”). Planning: how to configure Psi4 and invoke CMake¶; PSI4 is built through CMake. An abbreviated build guide can be found; within the source itself .; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -S.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make or Ninja in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of arguments to cmake tailored to; your computer. Proceed to quick build or; detailed build. How to build and install Psi4, the compact version¶; This section outlines the main steps of configuring, compiling, and; installing PSI4. More detail is given here.; >>> cd {top-level-psi4-dir}; >>> cmake -S. -Bobjdir [your configuration options]; >>> cd objdir; >>> make -j`getconf _NPROCESSORS_ONLN`; >>> make install. How to build, test, and install Psi4, in d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/build_planning.html:430,guid,guide,430,psi4manual/1.6.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/build_planning.html,2,['guid'],['guide']
Usability,"﻿. Compiling and Installing from Source. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Installation and Runtime Configuration; Compiling and Installing from Source. Compiling and Installing from Source¶; This section fulfills the duty of every Linux project to have an INSTALL; file detailing how to build it from source. Few (mostly packagers and; sysadmins) are expected to read this file as it is a broad guide to the; many choices in building this project. For a specific, well-tested,; and performance-tuned build path, see psicode.org/installs/latest; (select “source”). For pre-built binaries again well-tested,; performance-tuned, and available for all common operating systems,; see psicode.org/installs/latest (select “conda”). Planning: how to configure Psi4 and invoke CMake¶; PSI4 is built through CMake. An abbreviated build guide can be found; within the source itself .; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -S.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make or Ninja in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of arguments to cmake tailored to; your computer. Proceed to quick build or; detailed build. How to build and install Psi4, the compact version¶; This section outlines the main steps of configuring, compiling, and; installing PSI4. More detail is given here.; >>> cd {top-level-psi4-dir}; >>> cmake -S. -Bobjdir [your configuration options]; >>> cd objdir; >>> make -j`getconf _NPROCESSORS_ONLN`; >>> make install. How to build, test, and install Psi4, in d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/build_planning.html:430,guid,guide,430,psi4manual/1.7.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/build_planning.html,2,['guid'],['guide']
Usability,"﻿. Compiling and Installing from Source. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Installation and Runtime Configuration; Compiling and Installing from Source. Compiling and Installing from Source¶. Warning; As of v1.8, primary binary distribution has moved from; the psi4 channel to the conda-forge channel. Neither install docs; for users nor compile docs for developers have been updated yet to; reflect new patterns. Please consult psicode downloads; page for the latest guides. This section fulfills the duty of every Linux project to have an INSTALL; file detailing how to build it from source. Few (mostly packagers and; sysadmins) are expected to read this file as it is a broad guide to the; many choices in building this project. For a specific, well-tested,; and performance-tuned build path, see psicode.org/installs/latest; (select “source”). For pre-built binaries again well-tested,; performance-tuned, and available for all common operating systems,; see psicode.org/installs/latest (select “conda”).; To see working builds for Linux, Mac, and Windows, see :src:; [this GHA]. Planning: how to configure Psi4 and invoke CMake¶; PSI4 is built through CMake. An abbreviated build guide can be found; within the source itself .; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -S.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make or Ninja in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of arguments to cmake tailored to; your computer. Proceed to quick build or; detailed build. How",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/build_planning.html:504,guid,guides,504,psi4manual/1.8.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/build_planning.html,2,['guid'],"['guide', 'guides']"
Usability,"﻿. Compiling and Installing from Source. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Installation and Runtime Configuration; Compiling and Installing from Source. Compiling and Installing from Source¶. Warning; As of v1.8, primary binary distribution has moved from; the psi4 channel to the conda-forge channel. Neither install docs; for users nor compile docs for developers have been updated yet to; reflect new patterns. Please consult psi4/conda/psi4-path-advisor.py; (extensive help menu at conda/psi4-path-advisor.py -h); or psicode downloads; page for the latest guides. This section fulfills the duty of every Linux project to have an INSTALL; file detailing how to build it from source. Few (mostly packagers and; sysadmins) are expected to read this file as it is a broad guide to the; many choices in building this project. For a specific, well-tested,; and performance-tuned build path, see psicode.org/installs/latest; (select “source”). For pre-built binaries again well-tested,; performance-tuned, and available for all common operating systems,; see psicode.org/installs/latest (select “conda”).; To see working builds for Linux, Mac, and Windows, see :src:; [this GHA]. Planning: how to configure Psi4 and invoke CMake¶; PSI4 is built through CMake. An abbreviated build guide can be found; within the source itself .; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -S.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make or Ninja in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/build_planning.html:596,guid,guides,596,psi4manual/1.9.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/build_planning.html,2,['guid'],"['guide', 'guides']"
Usability,"﻿. Conda Binary Distribution. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Installation and Runtime Configuration; Conda Binary Distribution. Conda Binary Distribution¶. Warning; As of v1.8, primary binary distribution has moved from; the psi4 channel to the conda-forge channel. Neither install docs; for users nor compile docs for developers have been updated yet to; reflect new patterns. Please consult psicode downloads; page for the latest guides. Warning; As of v1.2rc1, new (conda build 3; updated compilers); conda packages are available for Linux but not Mac).; Psi4conda installers are not ready for either platform. PSI4 is available as a pre-compiled binary for Mac and Linux (and; Windows, through the Ubuntu shell) and native Windows architectures; through Anaconda (formerly Continuum Analytics, the company that produces; Anaconda Python (a; full-fledged scientific python environment with package manager conda) and, more particularly, Miniconda (a lightweight Python; distribution with same package manager conda). Some nice features for us:. cross-platform; no root, administrator, or sudo access required; built with high-performance math libraries; lightweight software stack (<100 MB w/o PSI4; ~1 GB including PSI4, numpy, and MKL); updated nightly so new features accessible; standardizes python distribution so no need to find/install libpython packages; add-ons (plugins, extra features requiring Fortran compiler, etc.) can be made available as conda packages; develop PSI4 through plugins without a pre-existing development environment, see Creating a New Plugin Using a Conda Pre-compiled Binary. The PSI4 binary repository is at Anaconda (formerly Binstar).; For commands to get a default installation, go to How to install a Psi4 binary with the Psi4conda installer, command-line; or the psicode downloads page .; Users proficient with conda may prefer to consult What do the conda packages psi4 & psi4-dev and the installer psi4conda con",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/conda.html:478,guid,guides,478,psi4manual/master/conda.html,https://psicode.org,https://psicode.org/psi4manual/master/conda.html,1,['guid'],['guides']
Usability,"﻿. Conda Binary Distribution. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Installation and Runtime Configuration; Conda Binary Distribution. Conda Binary Distribution¶. Warning; As of v1.8, primary binary distribution has moved from; the psi4 channel to the conda-forge channel. Neither install docs; for users nor compile docs for developers have been updated yet to; reflect new patterns. Please consult psicode downloads; page for the latest guides. Warning; As of v1.2rc1, new (conda build 3; updated compilers); conda packages are available for Linux but not Mac).; Psi4conda installers are not ready for either platform. PSI4 is available as a pre-compiled binary for Mac and Linux (and; Windows, through the Ubuntu shell) and native Windows architectures; through Anaconda (formerly Continuum Analytics, the company that produces; Anaconda Python (a; full-fledged scientific python environment with package manager conda) and, more particularly, Miniconda (a lightweight Python; distribution with same package manager conda). Some nice features for us:. cross-platform; no root, administrator, or sudo access required; built with high-performance math libraries; lightweight software stack (<100 MB w/o PSI4; ~1 GB including PSI4, numpy, and MKL); updated nightly so new features accessible; standardizes python distribution so no need to find/install libpython packages; add-ons (plugins, extra features requiring Fortran compiler, etc.) can be made available as conda packages; develop PSI4 through plugins without a pre-existing development environment, see Creating a New Plugin Using a Conda Pre-compiled Binary. The PSI4 binary repository is at Anaconda (formerly Binstar).; For commands to get a default installation, go to How to install a Psi4 binary with the Psi4conda installer, command-line; or the psicode downloads page .; Users proficient with conda may prefer to consult What do the conda packages psi4 & psi4-dev and the installer psi4conda contain.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/conda.html:471,guid,guides,471,psi4manual/1.8.x/conda.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/conda.html,1,['guid'],['guides']
Usability,"﻿. Conda Binary Distribution. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Installation and Runtime Configuration; Conda Binary Distribution. Conda Binary Distribution¶. Warning; As of v1.8, primary binary distribution has moved from; the psi4 channel to the conda-forge channel. Neither install docs; for users nor compile docs for developers have been updated yet to; reflect new patterns. Please consult psicode downloads; page for the latest guides. Warning; As of v1.2rc1, new (conda build 3; updated compilers); conda packages are available for Linux but not Mac).; Psi4conda installers are not ready for either platform. PSI4 is available as a pre-compiled binary for Mac and Linux (and; Windows, through the Ubuntu shell) and native Windows architectures; through Anaconda (formerly Continuum Analytics, the company that produces; Anaconda Python (a; full-fledged scientific python environment with package manager conda) and, more particularly, Miniconda (a lightweight Python; distribution with same package manager conda). Some nice features for us:. cross-platform; no root, administrator, or sudo access required; built with high-performance math libraries; lightweight software stack (<100 MB w/o PSI4; ~1 GB including PSI4, numpy, and MKL); updated nightly so new features accessible; standardizes python distribution so no need to find/install libpython packages; add-ons (plugins, extra features requiring Fortran compiler, etc.) can be made available as conda packages; develop PSI4 through plugins without a pre-existing development environment, see Creating a New Plugin Using a Conda Pre-compiled Binary. The PSI4 binary repository is at Anaconda (formerly Binstar).; For commands to get a default installation, go to How to install a Psi4 binary with the Psi4conda installer, command-line; or the psicode downloads page .; Users proficient with conda may prefer to consult What do the conda packages psi4 & psi4-dev and the installer psi4conda contain.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/conda.html:471,guid,guides,471,psi4manual/1.9.x/conda.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/conda.html,1,['guid'],['guides']
Usability,"﻿. Configuration Interaction — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Configuration Interaction¶; Code author: C. David Sherrill and Matthew L. Leininger; Section author: C. David Sherrill; Module: Keywords, PSI Variables, DETCI; Configuration interaction (CI) is one of the most general ways to; improve upon Hartree–Fock theory by adding a description of the; correlated motions of electrons. Simply put, a CI wavefunction; is a linear combination of Slater determinants (or spin-adapted; configuration state functions), with the linear coefficients being; determined variationally via diagonalization of the Hamiltonian in the; given subspace of determinants. For a “single-reference” CI based; on reference function , we can write the CI expansion as; follows:. (1); The simplest standard CI method that improves upon Hartree–Fock is a CI; that adds all singly and doubly. substituted determinants (CISD) to the reference determinant; . The CISD wavefunction has fallen out of favor; because truncated CI wavefunctions are not size-extensive, meaning; that their quality degrades for larger molecules. MP2 is a less; expensive alternative giving results similar to those of CISD for small; molecules, but the quality of MP2 does not degrade for larger molecules.; Coupled-cluster singles and doubles (CCSD) is another size-extensive; alternative; it is only slightly more costly computationally than CISD,; but it typically provides significantly more accurate results.; The CI code in PSI4 is described in detail in; [Sherrill:1999:CI]. For the reasons stated above, the CI code in; PSI4 is not optimized for CISD computations. Instead, emphasis; has been placed on developing a very efficient program to handle more; general CI wavefunctions which may be helpful in more challenging cases; such as highly strained molecules or bond breaking reactions. The CI; code is based on the fast, determinant-based",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/detci-1.html:866,simpl,simplest,866,psi4manual/4.0b2/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/detci-1.html,2,['simpl'],['simplest']
Usability,"﻿. Creating New Plugins. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. Creating New Plugins¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/plugins.html:383,learn,learn,383,psi4manual/master/plugins.html,https://psicode.org,https://psicode.org/psi4manual/master/plugins.html,1,['learn'],['learn']
Usability,"﻿. Creating New Plugins. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Adding New Code to PSI4. Creating New Plugins¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/plugins-1.html:354,learn,learn,354,psi4manual/1.3.2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/plugins-1.html,2,['learn'],['learn']
Usability,"﻿. Creating New Plugins. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. Creating New Plugins¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-te",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/plugins-1.html:374,learn,learn,374,psi4manual/1.4.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/plugins-1.html,2,['learn'],['learn']
Usability,"﻿. Creating New Plugins. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. Creating New Plugins¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-te",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/plugins-1.html:374,learn,learn,374,psi4manual/1.5.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/plugins-1.html,2,['learn'],['learn']
Usability,"﻿. Creating New Plugins. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. Creating New Plugins¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-te",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/plugins.html:374,learn,learn,374,psi4manual/1.6.x/plugins.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html,1,['learn'],['learn']
Usability,"﻿. Creating New Plugins. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. Creating New Plugins¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-te",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/plugins.html:374,learn,learn,374,psi4manual/1.7.x/plugins.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/plugins.html,1,['learn'],['learn']
Usability,"﻿. Creating New Plugins. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. Creating New Plugins¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/plugins.html:376,learn,learn,376,psi4manual/1.8.x/plugins.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/plugins.html,1,['learn'],['learn']
Usability,"﻿. Creating New Plugins. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. Creating New Plugins¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; >>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/plugins.html:376,learn,learn,376,psi4manual/1.9.x/plugins.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/plugins.html,1,['learn'],['learn']
Usability,"﻿. Embarrassing Parallelism — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». Embarrassing Parallelism¶; Many of the tasks automated by Python wrappers consist of a number of; independent PSI4 calculations and are thus suited to an embarrassingly; parallel mode of operation. In Psithon, these have been dubbed sow/reap; procedures and have the following general structure. Prepare an input file, simply adding mode='sow' to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations.; According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation.; The ‘sow’ stage also produces a master input file (with a; mode='reap' directive). When all the jobs in the above step are; completed, place their output files in the same location as the; master input, and run this last, quick job to collect the results. Sow/reap procedures are governed by the mode keyword, choices being; 'continuous', 'sow', and 'reap'. Only 'sow' is likely to; be used by the user, as 'continuous' is always the default, and; input files with 'reap' are autogenerated.; Available at present for Database and finite difference operation; of Optimize. Caution; Some features are not yet implemented. Buy a developer a coffee. Local options (e.g., set scf e_convergence 9) will not get transmitted to the child jobs.; Array options (e.g., set states_per_irrep [2, 1]) will not get transmitted to the child jobs.; Function intercalls (e.g., db(opt())) are not tested with sow/reap procedures. Previous topic; Function Intercalls; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/sowreap-1.html:489,simpl,simply,489,psi4manual/4.0b2/sowreap-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sowreap-1.html,2,['simpl'],['simply']
Usability,"﻿. Embarrassing Parallelism — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Psithon Functions: Invoking a Calculation ». Embarrassing Parallelism¶; Many of the tasks automated by Python wrappers consist of a number of; independent Psi4 calculations and are thus suited to an embarrassingly; parallel mode of operation. In Psithon, these have been dubbed sow/reap; procedures and have the following general structure. Prepare an input file, simply adding mode='sow' to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations.; According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation.; The ‘sow’ stage also produces a master input file (with a; mode='reap' directive). When all the jobs in the above step are; completed, place their output files in the same location as the; master input, and run this last, quick job to collect the results. Sow/reap procedures are governed by the mode keyword, choices being; 'continuous', 'sow', and 'reap'. Only 'sow' is likely to; be used by the user, as 'continuous' is always the default, and; input files with 'reap' are autogenerated.; Embarrassingly parallel algorithm available at present for:; Database, database(); finite difference operation of Geometry Optimization, optimize() and gradient(); finite difference of energies of Harmonic Vibrational Analysis, frequency() and hessian(); finite difference of gradients of Harmonic Vibrational Analysis, frequency() and hessian(). Caution; Some features are not yet implemented. Buy a developer a coffee. Local options (e.g., set scf e_convergence 9) will not get transmitted to the child jobs.; Array options (e.g., set states_per_irrep [2, 1]) will not get transmitted to the child jobs.; Function intercalls (e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sowreap-1.html:511,simpl,simply,511,psi4manual/1.0.0/sowreap-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sowreap-1.html,2,['simpl'],['simply']
Usability,"﻿. Embarrassing Parallelism. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Psithon Functions: Invoking a Calculation; Embarrassing Parallelism. Embarrassing Parallelism¶; Many of the tasks automated by Python wrappers consist of a number of; independent PSI4 calculations and are thus suited to an embarrassingly; parallel mode of operation. In Psithon, these have been dubbed sow/reap; procedures and have the following general structure. Prepare an input file, simply adding mode='sow' to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations.; According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation.; The ‘sow’ stage also produces a master input file (with a; mode='reap' directive). When all the jobs in the above step are; completed, place their output files in the same location as the; master input, and run this last, quick job to collect the results. Sow/reap procedures are governed by the mode keyword, choices being; 'continuous', 'sow', and 'reap'. Only 'sow' is likely to; be used by the user, as 'continuous' is always the default, and; input files with 'reap' are autogenerated.; Embarrassingly parallel algorithm available at present for:. Database — database(); finite difference operation of Geometry Optimization — optimize() and gradient(); finite difference of energies of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); finite difference of gradients of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Caution; Some features are not yet implemented. Buy a developer a coffee. Local options (e.g., set scf e_convergence 9) will not get transmitted to the child jobs.; Array options (e.g., set states_per_irrep [2, 1]) will not get",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/sowreap.html:494,simpl,simply,494,psi4manual/master/sowreap.html,https://psicode.org,https://psicode.org/psi4manual/master/sowreap.html,1,['simpl'],['simply']
Usability,"﻿. Embarrassing Parallelism. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Psithon Functions: Invoking a Calculation. Embarrassing Parallelism¶; Many of the tasks automated by Python wrappers consist of a number of; independent PSI4 calculations and are thus suited to an embarrassingly; parallel mode of operation. In Psithon, these have been dubbed sow/reap; procedures and have the following general structure. Prepare an input file, simply adding mode='sow' to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations.; According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation.; The ‘sow’ stage also produces a master input file (with a; mode='reap' directive). When all the jobs in the above step are; completed, place their output files in the same location as the; master input, and run this last, quick job to collect the results. Sow/reap procedures are governed by the mode keyword, choices being; 'continuous', 'sow', and 'reap'. Only 'sow' is likely to; be used by the user, as 'continuous' is always the default, and; input files with 'reap' are autogenerated.; Embarrassingly parallel algorithm available at present for:; Database — database(); finite difference operation of Geometry Optimization — optimize() and gradient(); finite difference of energies of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); finite difference of gradients of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Caution; Some features are not yet implemented. Buy a developer a coffee. Local options (e.g., set scf e_convergence 9) will not get transmitted to the child jobs.; Array options (e.g., set states_per_irrep [2, 1]) will not get transmitted to the child jobs.; Fu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sowreap-1.html:459,simpl,simply,459,psi4manual/1.1.0/sowreap-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sowreap-1.html,2,['simpl'],['simply']
Usability,"﻿. Embarrassing Parallelism. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation. Embarrassing Parallelism¶; Many of the tasks automated by Python wrappers consist of a number of; independent PSI4 calculations and are thus suited to an embarrassingly; parallel mode of operation. In Psithon, these have been dubbed sow/reap; procedures and have the following general structure. Prepare an input file, simply adding mode='sow' to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations.; According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation.; The ‘sow’ stage also produces a master input file (with a; mode='reap' directive). When all the jobs in the above step are; completed, place their output files in the same location as the; master input, and run this last, quick job to collect the results. Sow/reap procedures are governed by the mode keyword, choices being; 'continuous', 'sow', and 'reap'. Only 'sow' is likely to; be used by the user, as 'continuous' is always the default, and; input files with 'reap' are autogenerated.; Embarrassingly parallel algorithm available at present for:; Database — database(); finite difference operation of Geometry Optimization — optimize() and gradient(); finite difference of energies of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); finite difference of gradients of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Caution; Some features are not yet implemented. Buy a developer a coffee. Local options (e.g., set scf e_convergence 9) will not get transmitted to the child jobs.; Array options (e.g., set states_per_irrep [2, 1]) will not get transmitted to the child jobs.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/sowreap-1.html:461,simpl,simply,461,psi4manual/1.2.1/sowreap-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/sowreap-1.html,2,['simpl'],['simply']
Usability,"﻿. Embarrassing Parallelism. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Psithon Functions: Invoking a Calculation. Embarrassing Parallelism¶; Many of the tasks automated by Python wrappers consist of a number of; independent PSI4 calculations and are thus suited to an embarrassingly; parallel mode of operation. In Psithon, these have been dubbed sow/reap; procedures and have the following general structure. Prepare an input file, simply adding mode='sow' to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations.; According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation.; The ‘sow’ stage also produces a master input file (with a; mode='reap' directive). When all the jobs in the above step are; completed, place their output files in the same location as the; master input, and run this last, quick job to collect the results. Sow/reap procedures are governed by the mode keyword, choices being; 'continuous', 'sow', and 'reap'. Only 'sow' is likely to; be used by the user, as 'continuous' is always the default, and; input files with 'reap' are autogenerated.; Embarrassingly parallel algorithm available at present for:; Database — database(); finite difference operation of Geometry Optimization — optimize() and gradient(); finite difference of energies of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); finite difference of gradients of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Caution; Some features are not yet implemented. Buy a developer a coffee. Local options (e.g., set scf e_convergence 9) will not get transmitted to the child jobs.; Array options (e.g., set states_per_irrep [2, 1]) will not get transmitted to the child jobs.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/sowreap-1.html:461,simpl,simply,461,psi4manual/1.3.2/sowreap-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/sowreap-1.html,2,['simpl'],['simply']
Usability,"﻿. Embarrassing Parallelism. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Psithon Functions: Invoking a Calculation; Embarrassing Parallelism. Embarrassing Parallelism¶; Many of the tasks automated by Python wrappers consist of a number of; independent PSI4 calculations and are thus suited to an embarrassingly; parallel mode of operation. In Psithon, these have been dubbed sow/reap; procedures and have the following general structure. Prepare an input file, simply adding mode='sow' to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations.; According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation.; The ‘sow’ stage also produces a master input file (with a; mode='reap' directive). When all the jobs in the above step are; completed, place their output files in the same location as the; master input, and run this last, quick job to collect the results. Sow/reap procedures are governed by the mode keyword, choices being; 'continuous', 'sow', and 'reap'. Only 'sow' is likely to; be used by the user, as 'continuous' is always the default, and; input files with 'reap' are autogenerated.; Embarrassingly parallel algorithm available at present for:. Database — database(); finite difference operation of Geometry Optimization — optimize() and gradient(); finite difference of energies of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); finite difference of gradients of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Caution; Some features are not yet implemented. Buy a developer a coffee. Local options (e.g., set scf e_convergence 9) will not get transmitted to the child jobs.; Array options (e.g., set states_per_irrep [2, 1]) will not get transmit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sowreap-1.html:485,simpl,simply,485,psi4manual/1.4.0/sowreap-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sowreap-1.html,2,['simpl'],['simply']
Usability,"﻿. Embarrassing Parallelism. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Psithon Functions: Invoking a Calculation; Embarrassing Parallelism. Embarrassing Parallelism¶; Many of the tasks automated by Python wrappers consist of a number of; independent PSI4 calculations and are thus suited to an embarrassingly; parallel mode of operation. In Psithon, these have been dubbed sow/reap; procedures and have the following general structure. Prepare an input file, simply adding mode='sow' to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations.; According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation.; The ‘sow’ stage also produces a master input file (with a; mode='reap' directive). When all the jobs in the above step are; completed, place their output files in the same location as the; master input, and run this last, quick job to collect the results. Sow/reap procedures are governed by the mode keyword, choices being; 'continuous', 'sow', and 'reap'. Only 'sow' is likely to; be used by the user, as 'continuous' is always the default, and; input files with 'reap' are autogenerated.; Embarrassingly parallel algorithm available at present for:. Database — database(); finite difference operation of Geometry Optimization — optimize() and gradient(); finite difference of energies of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); finite difference of gradients of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Caution; Some features are not yet implemented. Buy a developer a coffee. Local options (e.g., set scf e_convergence 9) will not get transmitted to the child jobs.; Array options (e.g., set states_per_irrep [2, 1]) will not get transmit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/sowreap-1.html:485,simpl,simply,485,psi4manual/1.5.0/sowreap-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/sowreap-1.html,2,['simpl'],['simply']
Usability,"﻿. Embarrassing Parallelism. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Embarrassing Parallelism. Embarrassing Parallelism¶; Many of the tasks automated by Python wrappers consist of a number of; independent PSI4 calculations and are thus suited to an embarrassingly; parallel mode of operation. In Psithon, these have been dubbed sow/reap; procedures and have the following general structure. Prepare an input file, simply adding mode='sow' to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations.; According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation.; The ‘sow’ stage also produces a master input file (with a; mode='reap' directive). When all the jobs in the above step are; completed, place their output files in the same location as the; master input, and run this last, quick job to collect the results. Sow/reap procedures are governed by the mode keyword, choices being; 'continuous', 'sow', and 'reap'. Only 'sow' is likely to; be used by the user, as 'continuous' is always the default, and; input files with 'reap' are autogenerated.; Embarrassingly parallel algorithm available at present for:. Database — database(); finite difference operation of Geometry Optimization — optimize() and gradient(); finite difference of energies of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); finite difference of gradients of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Caution; Some features are not yet implemented. Buy a developer a coffee. Local options (e.g., set scf e_convergence 9) will not get transmitted to the child jobs.; Array options (e.g., set states_per_irrep [2, 1]) will not get transmit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/sowreap.html:485,simpl,simply,485,psi4manual/1.6.x/sowreap.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/sowreap.html,1,['simpl'],['simply']
Usability,"﻿. Embarrassing Parallelism. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon Functions: Invoking a Calculation; Embarrassing Parallelism. Embarrassing Parallelism¶; Many of the tasks automated by Python wrappers consist of a number of; independent PSI4 calculations and are thus suited to an embarrassingly; parallel mode of operation. In Psithon, these have been dubbed sow/reap; procedures and have the following general structure. Prepare an input file, simply adding mode='sow' to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations.; According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation.; The ‘sow’ stage also produces a master input file (with a; mode='reap' directive). When all the jobs in the above step are; completed, place their output files in the same location as the; master input, and run this last, quick job to collect the results. Sow/reap procedures are governed by the mode keyword, choices being; 'continuous', 'sow', and 'reap'. Only 'sow' is likely to; be used by the user, as 'continuous' is always the default, and; input files with 'reap' are autogenerated.; Embarrassingly parallel algorithm available at present for:. Database — database(); finite difference operation of Geometry Optimization — optimize() and gradient(); finite difference of energies of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); finite difference of gradients of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Caution; Some features are not yet implemented. Buy a developer a coffee. Local options (e.g., set scf e_convergence 9) will not get transmitted to the child jobs.; Array options (e.g., set states_per_irrep [2, 1]) will not get transmit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/sowreap.html:485,simpl,simply,485,psi4manual/1.7.x/sowreap.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/sowreap.html,1,['simpl'],['simply']
Usability,"﻿. Embarrassing Parallelism. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Psithon Functions: Invoking a Calculation; Embarrassing Parallelism. Embarrassing Parallelism¶; Many of the tasks automated by Python wrappers consist of a number of; independent PSI4 calculations and are thus suited to an embarrassingly; parallel mode of operation. In Psithon, these have been dubbed sow/reap; procedures and have the following general structure. Prepare an input file, simply adding mode='sow' to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations.; According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation.; The ‘sow’ stage also produces a master input file (with a; mode='reap' directive). When all the jobs in the above step are; completed, place their output files in the same location as the; master input, and run this last, quick job to collect the results. Sow/reap procedures are governed by the mode keyword, choices being; 'continuous', 'sow', and 'reap'. Only 'sow' is likely to; be used by the user, as 'continuous' is always the default, and; input files with 'reap' are autogenerated.; Embarrassingly parallel algorithm available at present for:. Database — database(); finite difference operation of Geometry Optimization — optimize() and gradient(); finite difference of energies of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); finite difference of gradients of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Caution; Some features are not yet implemented. Buy a developer a coffee. Local options (e.g., set scf e_convergence 9) will not get transmitted to the child jobs.; Array options (e.g., set states_per_irrep [2, 1]) will not get transm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/sowreap.html:487,simpl,simply,487,psi4manual/1.8.x/sowreap.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/sowreap.html,1,['simpl'],['simply']
Usability,"﻿. Embarrassing Parallelism. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Psithon Functions: Invoking a Calculation; Embarrassing Parallelism. Embarrassing Parallelism¶; Many of the tasks automated by Python wrappers consist of a number of; independent PSI4 calculations and are thus suited to an embarrassingly; parallel mode of operation. In Psithon, these have been dubbed sow/reap; procedures and have the following general structure. Prepare an input file, simply adding mode='sow' to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations.; According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation.; The ‘sow’ stage also produces a master input file (with a; mode='reap' directive). When all the jobs in the above step are; completed, place their output files in the same location as the; master input, and run this last, quick job to collect the results. Sow/reap procedures are governed by the mode keyword, choices being; 'continuous', 'sow', and 'reap'. Only 'sow' is likely to; be used by the user, as 'continuous' is always the default, and; input files with 'reap' are autogenerated.; Embarrassingly parallel algorithm available at present for:. Database — database(); finite difference operation of Geometry Optimization — optimize() and gradient(); finite difference of energies of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); finite difference of gradients of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Caution; Some features are not yet implemented. Buy a developer a coffee. Local options (e.g., set scf e_convergence 9) will not get transmitted to the child jobs.; Array options (e.g., set states_per_irrep [2, 1]) will not get transm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/sowreap.html:487,simpl,simply,487,psi4manual/1.9.x/sowreap.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/sowreap.html,1,['simpl'],['simply']
Usability,"﻿. ExternalPotential. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential¶. class psi4.core.ExternalPotential¶; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self, basis, coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). appendCharges(self, arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: list[tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html:555,clear,clear,555,psi4manual/master/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html,1,['clear'],['clear']
Usability,"﻿. ExternalPotential. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. ExternalPotential¶. class psi4.core.ExternalPotential¶; Bases: pybind11_builtins.pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self, basis, coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). clear(self); Reset the field to zero (eliminates all entries). computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None; Add a charge Z at (x,y,z). clear(self: psi4.core.ExternalPotential) → None; Reset the field to zero (eliminates all entries). computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix; Compute the external potential matrix in the given b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.externalpotential.html:455,clear,clear,455,psi4manual/1.2.1/api/psi4.core.externalpotential.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.externalpotential.html,1,['clear'],['clear']
Usability,"﻿. ExternalPotential. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. ExternalPotential¶. class psi4.core.ExternalPotential¶; Bases: pybind11_builtins.pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self, basis, coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). clear(self); Reset the field to zero (eliminates all entries). computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None; Add a charge Z at (x,y,z). clear(self: psi4.core.ExternalPotential) → None; Reset the field to zero (eliminates all entries). computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix; Compute the external potential matrix in the given b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.externalpotential.html:455,clear,clear,455,psi4manual/1.3.2/api/psi4.core.externalpotential.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.externalpotential.html,1,['clear'],['clear']
Usability,"﻿. ExternalPotential. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential¶. class psi4.core.ExternalPotential¶; Bases: pybind11_builtins.pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self, basis, coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). appendCharges(self, arg0, float, float, float]]); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0, arg1); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential, arg1: bool) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → fl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.externalpotential.html:587,clear,clear,587,psi4manual/1.4.0/api/psi4.core.externalpotential.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.externalpotential.html,1,['clear'],['clear']
Usability,"﻿. ExternalPotential. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential¶. class psi4.core.ExternalPotential¶; Bases: pybind11_builtins.pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self, basis, coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). appendCharges(self, arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0, arg1); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential, arg1: bool) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.externalpotential.html:564,clear,clear,564,psi4manual/1.5.0/api/psi4.core.externalpotential.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.externalpotential.html,1,['clear'],['clear']
Usability,"﻿. ExternalPotential. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential¶. class psi4.core.ExternalPotential¶; Bases: pybind11_builtins.pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self, basis, coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). appendCharges(self, arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ExternalPotential.html:564,clear,clear,564,psi4manual/1.6.x/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ExternalPotential.html,1,['clear'],['clear']
Usability,"﻿. ExternalPotential. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential¶. class psi4.core.ExternalPotential¶; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self, basis, coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). appendCharges(self, arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html:546,clear,clear,546,psi4manual/1.7.x/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.ExternalPotential.html,1,['clear'],['clear']
Usability,"﻿. ExternalPotential. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential¶. class psi4.core.ExternalPotential¶; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self, basis, coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). appendCharges(self, arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:548,clear,clear,548,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,1,['clear'],['clear']
Usability,"﻿. ExternalPotential. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential¶. class psi4.core.ExternalPotential¶; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self, basis, coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). appendCharges(self, arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html:548,clear,clear,548,psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,1,['clear'],['clear']
Usability,"﻿. Interface to DFTD3 by S. Grimme. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to DFTD3 by S. Grimme. Interface to DFTD3 by S. Grimme¶; Code author: Lori A. Burns; Section author: Lori A. Burns; Module: Samples. Empirical Dispersion Implementations¶. Empirical dispersion correction packages¶. Package; Provides; before v1.7; since v1.7; Request; Source; Nickname. D3. psi4::dftd3; bin/dftd3; preferred; works; engine=""dftd3""; https://github.com/loriab/dftd3; classic. conda-forge::dftd3-python; import dftd3; nyi; preferred; engine=""s-dftd3""; https://github.com/dftd3/simple-dftd3; s-dftd3. (dep) conda-forge::simple-dftd3; bin/simple-dftd3. https://github.com/dftd3/simple-dftd3. D4. psi4::dftd4; bin/dftd4, import dftd4; preferred; works; engine=""dftd4""; https://github.com/dftd4/dftd4. conda-forge::dftd4-python; import dftd4; nyi; preferred; engine=""dftd4""; https://github.com/dftd4/dftd4. (dep) conda-forge::dftd4; bin/dftd4. https://github.com/dftd4/dftd4. GCP. psi4::gcp; bin/gcp; preferred; works; gcp_engine=""gcp""; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp_v202.tar.gz; classic. conda-forge::gcp-correction; bin/mctc-gcp; nyi; preferred; gcp_engine=""mctc-gcp""; https://github.com/grimme-lab/gcp; mctc. Installation¶; Binary. There are two implementations of DFTD3; see Empirical dispersion correction packages . The newer; “s-dftd3” one is preferred, while the older “classic” one will work for the immediate future.; PSI4 will automatically select whichever is available.; Starting with v1.9, only “s-dftd3” is supported, though the “classic” continues to work for many applications.; DFTD3 is available as a conda package for Linux and macOS and Windows.; If using the Psi4conda installer, DFTD3 has already been installed alongside.; If using the PSI4 conda package, the classic dftd3 conda package can; be obtained through conda install dftd3 -c psi4 or the newer implementat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/dftd3.html:654,simpl,simple-,654,psi4manual/master/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/master/dftd3.html,4,['simpl'],['simple-']
Usability,"﻿. Interface to DFTD3 by S. Grimme. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to DFTD3 by S. Grimme. Interface to DFTD3 by S. Grimme¶; Code author: Lori A. Burns; Section author: Lori A. Burns; Module: Samples. Empirical Dispersion Implementations¶. Empirical dispersion correction packages¶. Package; Provides; before v1.7; since v1.7; Request; Source; Nickname. D3. psi4::dftd3; bin/dftd3; preferred; works; engine=""dftd3""; https://github.com/loriab/dftd3; classic. conda-forge::dftd3-python; import dftd3; nyi; preferred; engine=""s-dftd3""; https://github.com/dftd3/simple-dftd3; s-dftd3. (dep) conda-forge::simple-dftd3; bin/simple-dftd3. https://github.com/dftd3/simple-dftd3. D4. psi4::dftd4; bin/dftd4, import dftd4; preferred; works; engine=""dftd4""; https://github.com/dftd4/dftd4. conda-forge::dftd4-python; import dftd4; nyi; preferred; engine=""dftd4""; https://github.com/dftd4/dftd4. (dep) conda-forge::dftd4; bin/dftd4. https://github.com/dftd4/dftd4. GCP. psi4::gcp; bin/gcp; preferred; works; gcp_engine=""gcp""; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp_v202.tar.gz; classic. conda-forge::gcp-correction; bin/mctc-gcp; nyi; preferred; gcp_engine=""mctc-gcp""; https://github.com/grimme-lab/gcp; mctc. Installation¶; Binary. There are two implementations of DFTD3; see Empirical dispersion correction packages . The newer; “s-dftd3” one is preferred, while the older “classic” one will work for the immediate future.; PSI4 will automatically select whichever is available.; DFTD3 is available as a conda package for Linux and macOS and Windows.; If using the Psi4conda installer, DFTD3 has already been installed alongside.; If using the PSI4 conda package, the classic dftd3 conda package can; be obtained through conda install dftd3 -c psi4 or the newer implementation; through conda install dftd3-python -c conda-forge.; If using PSI4 built from source, and anaconda or miniconda has; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:645,simpl,simple-,645,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,4,['simpl'],['simple-']
Usability,"﻿. Interface to DFTD3 by S. Grimme. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to DFTD3 by S. Grimme. Interface to DFTD3 by S. Grimme¶; Code author: Lori A. Burns; Section author: Lori A. Burns; Module: Samples. Empirical Dispersion Implementations¶. Empirical dispersion correction packages¶. Package; Provides; before v1.7; since v1.7; Request; Source; Nickname. D3. psi4::dftd3; bin/dftd3; preferred; works; engine=""dftd3""; https://github.com/loriab/dftd3; classic. conda-forge::dftd3-python; import dftd3; nyi; preferred; engine=""s-dftd3""; https://github.com/dftd3/simple-dftd3; s-dftd3. (dep) conda-forge::simple-dftd3; bin/simple-dftd3. https://github.com/dftd3/simple-dftd3. D4. psi4::dftd4; bin/dftd4, import dftd4; preferred; works; engine=""dftd4""; https://github.com/dftd4/dftd4. conda-forge::dftd4-python; import dftd4; nyi; preferred; engine=""dftd4""; https://github.com/dftd4/dftd4. (dep) conda-forge::dftd4; bin/dftd4. https://github.com/dftd4/dftd4. GCP. psi4::gcp; bin/gcp; preferred; works; gcp_engine=""gcp""; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp_v202.tar.gz; classic. conda-forge::gcp-correction; bin/mctc-gcp; nyi; preferred; gcp_engine=""mctc-gcp""; https://github.com/grimme-lab/gcp; mctc. Installation¶; Binary. There are two implementations of DFTD3; see Empirical dispersion correction packages . The newer; “s-dftd3” one is preferred, while the older “classic” one will work for the immediate future.; PSI4 will automatically select whichever is available.; DFTD3 is available as a conda package for Linux and macOS and Windows.; If using the Psi4conda installer, DFTD3 has already been installed alongside.; If using the PSI4 conda package, the classic dftd3 conda package can; be obtained through conda install dftd3 -c psi4 or the newer implementation; through conda install dftd3-python -c conda-forge.; If using PSI4 built from source, and anaconda or miniconda has",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/dftd3.html:647,simpl,simple-,647,psi4manual/1.8.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/dftd3.html,4,['simpl'],['simple-']
Usability,"﻿. Interface to DFTD3 by S. Grimme. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to DFTD3 by S. Grimme. Interface to DFTD3 by S. Grimme¶; Code author: Lori A. Burns; Section author: Lori A. Burns; Module: Samples. Empirical Dispersion Implementations¶. Empirical dispersion correction packages¶. Package; Provides; before v1.7; since v1.7; Request; Source; Nickname. D3. psi4::dftd3; bin/dftd3; preferred; works; engine=""dftd3""; https://github.com/loriab/dftd3; classic. conda-forge::dftd3-python; import dftd3; nyi; preferred; engine=""s-dftd3""; https://github.com/dftd3/simple-dftd3; s-dftd3. (dep) conda-forge::simple-dftd3; bin/simple-dftd3. https://github.com/dftd3/simple-dftd3. D4. psi4::dftd4; bin/dftd4, import dftd4; preferred; works; engine=""dftd4""; https://github.com/dftd4/dftd4. conda-forge::dftd4-python; import dftd4; nyi; preferred; engine=""dftd4""; https://github.com/dftd4/dftd4. (dep) conda-forge::dftd4; bin/dftd4. https://github.com/dftd4/dftd4. GCP. psi4::gcp; bin/gcp; preferred; works; gcp_engine=""gcp""; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp_v202.tar.gz; classic. conda-forge::gcp-correction; bin/mctc-gcp; nyi; preferred; gcp_engine=""mctc-gcp""; https://github.com/grimme-lab/gcp; mctc. Installation¶; Binary. There are two implementations of DFTD3; see Empirical dispersion correction packages . The newer; “s-dftd3” one is preferred, while the older “classic” one will work for the immediate future.; PSI4 will automatically select whichever is available.; Starting with v1.9, only “s-dftd3” is supported, though the “classic” continues to work for many applications.; DFTD3 is available as a conda package for Linux and macOS and Windows.; If using the Psi4conda installer, DFTD3 has already been installed alongside.; If using the PSI4 conda package, the classic dftd3 conda package can; be obtained through conda install dftd3 -c psi4 or the newer implementation; th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/dftd3.html:647,simpl,simple-,647,psi4manual/1.9.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/dftd3.html,4,['simpl'],['simple-']
Usability,"﻿. Interface to GDMA Distributed Multipole Analysis by A. J. Stone, gdma() — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Interfaces: Enhancing Psi4 Capabilities ». Interface to GDMA Distributed Multipole Analysis by A. J. Stone, gdma()¶; Code author: Anthony J. Stone, Andrew C. Simmonett; Section author: Andrew C. Simmonett; Module: Keywords, PSI Variables, PCMSolver; Input; ~~~; The distributed multipole analysis (DMA) technique, developed by Anthony J.; Stone and implemented by him into the GDMA package, is available in Psi4.; The current implementation simply embeds Stone’s GDMA code into the main; executable, and generates the appropriate input files automatically. The; program takes as input a data file, and a Gaussian formatted checkpoint (see; Section FCHK) file. The simplest usage of the GDMA code is; demonstrated below, along with a listing of the options supported; these; options correspond to the options described in the; GDMA manual.; If more advanced usage is desired, which is not is permitted by the options; listed below, the user may provide their own data file containing keywords to; control the GDMA code. Simply place the data file in the directory Psi4; is called from, and provide the file name as the datafile argument to the; gdma() routine. For example, if GDMA data file is called; control.dma, the GDMA code is called as follows:; grad, wfn = gradient('mp2', return_wfn=True); gdma(wfn, datafile='control.dma'). An FCHK file will be generated for the GDMA code to read; this file will have; the prefix given by WRITER_FILE_LABEL (if set), or else by the name; of the output file plus the name of the current molecule, and the suffix will; be ‘.fchk’. This FCHK file name should be passed to the ‘File’ keyword in the; DGMA data file, to ensure that the GDMA code reads the correct wavefunction; information.; After running, two matrices of results can be accessed:; dma_results = get_ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/gdma-1.html:635,simpl,simply,635,psi4manual/1.0.0/gdma-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/gdma-1.html,4,['simpl'],"['simplest', 'simply']"
Usability,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/mrcc-1.html:942,simpl,simply,942,psi4manual/4.0b2/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/mrcc-1.html,2,['simpl'],['simply']
Usability,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/mrcc-1.html:957,simpl,simply,957,psi4manual/4.0b3/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html,2,['simpl'],['simply']
Usability,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/mrcc-1.html:965,simpl,simply,965,psi4manual/4.0b4/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html,2,['simpl'],['simply']
Usability,"﻿. Interface to MRCC by M. Kállay — PSI4 [beta5] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Interfaces: Enhancing PSI4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/mrcc-1.html:965,simpl,simply,965,psi4manual/4.0b5/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/mrcc-1.html,2,['simpl'],['simply']
Usability,"﻿. Interface to MRCC by M. Kállay — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Interfaces: Enhancing Psi4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; Psi4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by Psi4, ensure that the program binary (dmrcc) can be; found in your PATH. If Psi4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in Psi4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs Psi4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, Psi4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Note that perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are not available with REFERENCE ROHF. name; calls method in Kallay’s MRCC program [manual]. mrccsd; CC through doubles. mrccsdt; CC through triples. mrccsdtq; CC through quadruples. mrccsdtqp; CC thr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/mrcc-1.html:981,simpl,simply,981,psi4manual/1.0.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/mrcc-1.html,2,['simpl'],['simply']
Usability,"﻿. Interface to MRCC by M. Kállay. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; 1; 2; 3; 4; 5; 6; 7; 8; 9molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B.[Kallay:2008:144101]_ Psi4 will save both ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/mrcc-1.html:929,simpl,simply,929,psi4manual/1.1.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/mrcc-1.html,2,['simpl'],['simply']
Usability,"﻿. Interface to MRCC by M. Kállay. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; 1; 2; 3; 4; 5; 6; 7; 8; 9molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B.[Kallay:2008:144101]_ Psi4 will save both en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/mrcc-1.html:931,simpl,simply,931,psi4manual/1.2.1/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/mrcc-1.html,2,['simpl'],['simply']
Usability,"﻿. Interface to MRCC by M. Kállay. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; 1; 2; 3; 4; 5; 6; 7; 8; 9molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B.[Kallay:2008:144101]_ Psi4 will save both en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/mrcc-1.html:931,simpl,simply,931,psi4manual/1.3.2/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/mrcc-1.html,2,['simpl'],['simply']
Usability,"﻿. Interface to MRCC by M. Kállay. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/mrcc-1.html:962,simpl,simply,962,psi4manual/1.4.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/mrcc-1.html,2,['simpl'],['simply']
Usability,"﻿. Interface to MRCC by M. Kállay. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/mrcc-1.html:962,simpl,simply,962,psi4manual/1.5.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/mrcc-1.html,2,['simpl'],['simply']
Usability,"﻿. Interface to MRCC by M. Kállay. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/mrcc.html:962,simpl,simply,962,psi4manual/1.6.x/mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html,1,['simpl'],['simply']
Usability,"﻿. Interface to NumPy. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy. Interface to NumPy¶; Code author: Daniel G. A. Smith; Section author: Daniel G. A. Smith; Module: psi4/psi4/driver/p4util/numpy_helper.py. Basics¶; Converting between the PSI4 Data classes and a NumPy array is easy through; various helper functions as detailed in this section. A quick overview NumPy; functionality can be found here. In addition,; numerous example of hybrid NumPy and Psi4 can be found at the Psi4Numpy; project. Currently only the Matrix; and Vector objects support NumPy interfacing. Let us begin with a simple; conversion from these objects to a NumPy array:; >>> import psi4; >>> import numpy as np. # Build the Psi4 data objects; >>> mat = psi4.core.Matrix(3, 3); >>> vec = psi4.core.Vector(3). # Convert to a NumPy array; >>> numpy_mat = np.array(mat); >>> numpy_vec = np.array(vec). Here the data is copied into new NumPy arrays. NumPy arrays can be converted; back to PSI4 objects using the from_array interface:; >>> new_mat = psi4.core.Matrix.from_array(mat); >>> new_vec = psi4.core.Vector.from_array(vec). NumPy Views¶; Copying the data between NumPy and Psi4 objects can lead to excessive data; movement and convoluted code. Here we introduce the idea of “Views” where the; same data can be viewed by multiple objects. However, this can lead to very; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; >>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; >>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducibl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/numpy.html:685,simpl,simple,685,psi4manual/master/numpy.html,https://psicode.org,https://psicode.org/psi4manual/master/numpy.html,1,['simpl'],['simple']
Usability,"﻿. Interface to NumPy. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Interface to NumPy¶; Code author: Daniel G. A. Smith; Section author: Daniel G. A. Smith; Module: Keywords, psi4/psi4/driver/p4util/numpy_helper.py. Basics¶; Converting between the PSI4 Data classes and a NumPy array is easy through; various helper functions as detailed in this section. A quick overview NumPy; functionality can be found here. In addition,; numerous example of hybrid NumPy and Psi4 can be found at the `Psi4Numpy; project <https://github.com/dgasmith/psi4numpy`_. Currently only the Matrix; and Vector objects support NumPy interfacing. Let us begin with a simple; conversion from these objects to a NumPy array:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10>>> import psi4; >>> import numpy as np. # Build the Psi4 data objects; >>> mat = psi4.Matrix(3, 3); >>> vec = psi4.Vector(3). # Convert to a NumPy array; >>> numpy_mat = np.array(mat); >>> numpy_vec = np.array(vec). Here the data is copied into new NumPy arrays. NumPy arrays can be converted; back to PSI4 objects using the from_array interface:; 1; 2>>> new_mat = psi4.Matrix.from_array(mat); >>> new_vec = psi4.Vector.from_array(vec). NumPy Views¶; Copying the data between NumPy and Psi4 objects can lead to excessive data; movement and convoluted code. Here we introduce the idea of “Views” where the; same data can be viewed by multiple objects. However, this can lead to very; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; 1>>> mat.np[:] = 1. this operation is identical to the above. Warning; The following w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/numpy-1.html:708,simpl,simple,708,psi4manual/1.1.0/numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/numpy-1.html,2,['simpl'],['simple']
Usability,"﻿. Interface to NumPy. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Interface to NumPy¶; Code author: Daniel G. A. Smith; Section author: Daniel G. A. Smith; Module: Keywords, psi4/psi4/driver/p4util/numpy_helper.py. Basics¶; Converting between the PSI4 Data classes and a NumPy array is easy through; various helper functions as detailed in this section. A quick overview NumPy; functionality can be found here. In addition,; numerous example of hybrid NumPy and Psi4 can be found at the Psi4Numpy; project. Currently only the Matrix; and Vector objects support NumPy interfacing. Let us begin with a simple; conversion from these objects to a NumPy array:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10>>> import psi4; >>> import numpy as np. # Build the Psi4 data objects; >>> mat = psi4.Matrix(3, 3); >>> vec = psi4.Vector(3). # Convert to a NumPy array; >>> numpy_mat = np.array(mat); >>> numpy_vec = np.array(vec). Here the data is copied into new NumPy arrays. NumPy arrays can be converted; back to PSI4 objects using the from_array interface:; 1; 2>>> new_mat = psi4.Matrix.from_array(mat); >>> new_vec = psi4.Vector.from_array(vec). NumPy Views¶; Copying the data between NumPy and Psi4 objects can lead to excessive data; movement and convoluted code. Here we introduce the idea of “Views” where the; same data can be viewed by multiple objects. However, this can lead to very; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; 1>>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively suppo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/numpy-1.html:668,simpl,simple,668,psi4manual/1.2.1/numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/numpy-1.html,2,['simpl'],['simple']
Usability,"﻿. Interface to NumPy. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Interface to NumPy¶; Code author: Daniel G. A. Smith; Section author: Daniel G. A. Smith; Module: Keywords, psi4/psi4/driver/p4util/numpy_helper.py. Basics¶; Converting between the PSI4 Data classes and a NumPy array is easy through; various helper functions as detailed in this section. A quick overview NumPy; functionality can be found here. In addition,; numerous example of hybrid NumPy and Psi4 can be found at the Psi4Numpy; project. Currently only the Matrix; and Vector objects support NumPy interfacing. Let us begin with a simple; conversion from these objects to a NumPy array:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10>>> import psi4; >>> import numpy as np. # Build the Psi4 data objects; >>> mat = psi4.Matrix(3, 3); >>> vec = psi4.Vector(3). # Convert to a NumPy array; >>> numpy_mat = np.array(mat); >>> numpy_vec = np.array(vec). Here the data is copied into new NumPy arrays. NumPy arrays can be converted; back to PSI4 objects using the from_array interface:; 1; 2>>> new_mat = psi4.Matrix.from_array(mat); >>> new_vec = psi4.Vector.from_array(vec). NumPy Views¶; Copying the data between NumPy and Psi4 objects can lead to excessive data; movement and convoluted code. Here we introduce the idea of “Views” where the; same data can be viewed by multiple objects. However, this can lead to very; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; 1>>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively suppo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/numpy-1.html:668,simpl,simple,668,psi4manual/1.3.2/numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/numpy-1.html,2,['simpl'],['simple']
Usability,"﻿. Interface to NumPy. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy. Interface to NumPy¶; Code author: Daniel G. A. Smith; Section author: Daniel G. A. Smith; Module: psi4/psi4/driver/p4util/numpy_helper.py. Basics¶; Converting between the PSI4 Data classes and a NumPy array is easy through; various helper functions as detailed in this section. A quick overview NumPy; functionality can be found here. In addition,; numerous example of hybrid NumPy and Psi4 can be found at the Psi4Numpy; project. Currently only the Matrix; and Vector objects support NumPy interfacing. Let us begin with a simple; conversion from these objects to a NumPy array:; >>> import psi4; >>> import numpy as np. # Build the Psi4 data objects; >>> mat = psi4.core.Matrix(3, 3); >>> vec = psi4.core.Vector(3). # Convert to a NumPy array; >>> numpy_mat = np.array(mat); >>> numpy_vec = np.array(vec). Here the data is copied into new NumPy arrays. NumPy arrays can be converted; back to PSI4 objects using the from_array interface:; >>> new_mat = psi4.core.Matrix.from_array(mat); >>> new_vec = psi4.core.Vector.from_array(vec). NumPy Views¶; Copying the data between NumPy and Psi4 objects can lead to excessive data; movement and convoluted code. Here we introduce the idea of “Views” where the; same data can be viewed by multiple objects. However, this can lead to very; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; >>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; >>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible represe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/numpy-1.html:676,simpl,simple,676,psi4manual/1.4.0/numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/numpy-1.html,2,['simpl'],['simple']
Usability,"﻿. Interface to NumPy. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy. Interface to NumPy¶; Code author: Daniel G. A. Smith; Section author: Daniel G. A. Smith; Module: psi4/psi4/driver/p4util/numpy_helper.py. Basics¶; Converting between the PSI4 Data classes and a NumPy array is easy through; various helper functions as detailed in this section. A quick overview NumPy; functionality can be found here. In addition,; numerous example of hybrid NumPy and Psi4 can be found at the Psi4Numpy; project. Currently only the Matrix; and Vector objects support NumPy interfacing. Let us begin with a simple; conversion from these objects to a NumPy array:; >>> import psi4; >>> import numpy as np. # Build the Psi4 data objects; >>> mat = psi4.core.Matrix(3, 3); >>> vec = psi4.core.Vector(3). # Convert to a NumPy array; >>> numpy_mat = np.array(mat); >>> numpy_vec = np.array(vec). Here the data is copied into new NumPy arrays. NumPy arrays can be converted; back to PSI4 objects using the from_array interface:; >>> new_mat = psi4.core.Matrix.from_array(mat); >>> new_vec = psi4.core.Vector.from_array(vec). NumPy Views¶; Copying the data between NumPy and Psi4 objects can lead to excessive data; movement and convoluted code. Here we introduce the idea of “Views” where the; same data can be viewed by multiple objects. However, this can lead to very; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; >>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; >>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible represe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/numpy-1.html:676,simpl,simple,676,psi4manual/1.5.0/numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/numpy-1.html,2,['simpl'],['simple']
Usability,"﻿. Interface to NumPy. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy. Interface to NumPy¶; Code author: Daniel G. A. Smith; Section author: Daniel G. A. Smith; Module: psi4/psi4/driver/p4util/numpy_helper.py. Basics¶; Converting between the PSI4 Data classes and a NumPy array is easy through; various helper functions as detailed in this section. A quick overview NumPy; functionality can be found here. In addition,; numerous example of hybrid NumPy and Psi4 can be found at the Psi4Numpy; project. Currently only the Matrix; and Vector objects support NumPy interfacing. Let us begin with a simple; conversion from these objects to a NumPy array:; >>> import psi4; >>> import numpy as np. # Build the Psi4 data objects; >>> mat = psi4.core.Matrix(3, 3); >>> vec = psi4.core.Vector(3). # Convert to a NumPy array; >>> numpy_mat = np.array(mat); >>> numpy_vec = np.array(vec). Here the data is copied into new NumPy arrays. NumPy arrays can be converted; back to PSI4 objects using the from_array interface:; >>> new_mat = psi4.core.Matrix.from_array(mat); >>> new_vec = psi4.core.Vector.from_array(vec). NumPy Views¶; Copying the data between NumPy and Psi4 objects can lead to excessive data; movement and convoluted code. Here we introduce the idea of “Views” where the; same data can be viewed by multiple objects. However, this can lead to very; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; >>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; >>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible represe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/numpy.html:676,simpl,simple,676,psi4manual/1.6.x/numpy.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/numpy.html,1,['simpl'],['simple']
Usability,"﻿. Interface to NumPy. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy. Interface to NumPy¶; Code author: Daniel G. A. Smith; Section author: Daniel G. A. Smith; Module: psi4/psi4/driver/p4util/numpy_helper.py. Basics¶; Converting between the PSI4 Data classes and a NumPy array is easy through; various helper functions as detailed in this section. A quick overview NumPy; functionality can be found here. In addition,; numerous example of hybrid NumPy and Psi4 can be found at the Psi4Numpy; project. Currently only the Matrix; and Vector objects support NumPy interfacing. Let us begin with a simple; conversion from these objects to a NumPy array:; >>> import psi4; >>> import numpy as np. # Build the Psi4 data objects; >>> mat = psi4.core.Matrix(3, 3); >>> vec = psi4.core.Vector(3). # Convert to a NumPy array; >>> numpy_mat = np.array(mat); >>> numpy_vec = np.array(vec). Here the data is copied into new NumPy arrays. NumPy arrays can be converted; back to PSI4 objects using the from_array interface:; >>> new_mat = psi4.core.Matrix.from_array(mat); >>> new_vec = psi4.core.Vector.from_array(vec). NumPy Views¶; Copying the data between NumPy and Psi4 objects can lead to excessive data; movement and convoluted code. Here we introduce the idea of “Views” where the; same data can be viewed by multiple objects. However, this can lead to very; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; >>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; >>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible represe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/numpy.html:676,simpl,simple,676,psi4manual/1.7.x/numpy.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/numpy.html,1,['simpl'],['simple']
Usability,"﻿. Interface to NumPy. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy. Interface to NumPy¶; Code author: Daniel G. A. Smith; Section author: Daniel G. A. Smith; Module: psi4/psi4/driver/p4util/numpy_helper.py. Basics¶; Converting between the PSI4 Data classes and a NumPy array is easy through; various helper functions as detailed in this section. A quick overview NumPy; functionality can be found here. In addition,; numerous example of hybrid NumPy and Psi4 can be found at the Psi4Numpy; project. Currently only the Matrix; and Vector objects support NumPy interfacing. Let us begin with a simple; conversion from these objects to a NumPy array:; >>> import psi4; >>> import numpy as np. # Build the Psi4 data objects; >>> mat = psi4.core.Matrix(3, 3); >>> vec = psi4.core.Vector(3). # Convert to a NumPy array; >>> numpy_mat = np.array(mat); >>> numpy_vec = np.array(vec). Here the data is copied into new NumPy arrays. NumPy arrays can be converted; back to PSI4 objects using the from_array interface:; >>> new_mat = psi4.core.Matrix.from_array(mat); >>> new_vec = psi4.core.Vector.from_array(vec). NumPy Views¶; Copying the data between NumPy and Psi4 objects can lead to excessive data; movement and convoluted code. Here we introduce the idea of “Views” where the; same data can be viewed by multiple objects. However, this can lead to very; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; >>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; >>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible repre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/numpy.html:678,simpl,simple,678,psi4manual/1.8.x/numpy.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/numpy.html,1,['simpl'],['simple']
Usability,"﻿. Interface to NumPy. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy. Interface to NumPy¶; Code author: Daniel G. A. Smith; Section author: Daniel G. A. Smith; Module: psi4/psi4/driver/p4util/numpy_helper.py. Basics¶; Converting between the PSI4 Data classes and a NumPy array is easy through; various helper functions as detailed in this section. A quick overview NumPy; functionality can be found here. In addition,; numerous example of hybrid NumPy and Psi4 can be found at the Psi4Numpy; project. Currently only the Matrix; and Vector objects support NumPy interfacing. Let us begin with a simple; conversion from these objects to a NumPy array:; >>> import psi4; >>> import numpy as np. # Build the Psi4 data objects; >>> mat = psi4.core.Matrix(3, 3); >>> vec = psi4.core.Vector(3). # Convert to a NumPy array; >>> numpy_mat = np.array(mat); >>> numpy_vec = np.array(vec). Here the data is copied into new NumPy arrays. NumPy arrays can be converted; back to PSI4 objects using the from_array interface:; >>> new_mat = psi4.core.Matrix.from_array(mat); >>> new_vec = psi4.core.Vector.from_array(vec). NumPy Views¶; Copying the data between NumPy and Psi4 objects can lead to excessive data; movement and convoluted code. Here we introduce the idea of “Views” where the; same data can be viewed by multiple objects. However, this can lead to very; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; >>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; >>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible repre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/numpy.html:678,simpl,simple,678,psi4manual/1.9.x/numpy.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/numpy.html,1,['simpl'],['simple']
Usability,"﻿. Interface to programs through FCHK files — fchk(). Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to programs through FCHK files — fchk(). Interface to programs through FCHK files — fchk()¶; Code author: Andrew C. Simmonett; Section author: Andrew C. Simmonett; Many post-processing tools can read information from Gaussian’s formatted; checkpoint (FCHK) files.; To allow interoperability with such tools, PSI4 includes a utility to; generate FCHK files. Wavefunction information, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and hand it to the fchk driver function:; energy, wfn = energy('scf', return_wfn=True); fchk(wfn,'output.fchk'). The file will be written to the name passed to the fchk function.; Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree–Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; grad, wfn = gradient('mp2', return_wfn=True); fchk(wfn,'output.fchk'). psi4.fchk(wfn, filename, *, debug=False, strict_label=True)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. Added in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/fchk.html:785,simpl,simply,785,psi4manual/master/fchk.html,https://psicode.org,https://psicode.org/psi4manual/master/fchk.html,1,['simpl'],['simply']
Usability,"﻿. Interface to programs through FCHK files — fchk(). Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Interface to programs through FCHK files — fchk()¶; Code author: Andrew C. Simmonett; Section author: Andrew C. Simmonett; Many post-processing tools can read information from Gaussian’s formatted; checkpoint (FCHK) files.; To allow interoperability with such tools, PSI4 includes a utility to; generate FCHK files. Wavefunction information, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and use it to create an FCHK writer:; 1; 2; 3energy, wfn = energy('scf', return_wfn=True); fchk_writer = psi4.FCHKWriter(wfn); fchk_writer.write('output.fchk'). The file will be written to the name passed to the FCHK writer’s write(); method. Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree–Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; 1; 2; 3grad, wfn = gradient('mp2', return_wfn=True); fchk_writer = psi4.FCHKWriter(wfn); fchk_writer.write('output.fchk'). psi4.fchk(wfn, filename)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:None. Parameters:; filename (string) – destination file name for FCHK file; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file. Examples:. 1; 2; 3>>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). Navigation. Index. mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fchk-1.html:725,simpl,simply,725,psi4manual/1.1.0/fchk-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fchk-1.html,2,['simpl'],['simply']
Usability,"﻿. Interface to programs through FCHK files — fchk(). Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Interface to programs through FCHK files — fchk()¶; Code author: Andrew C. Simmonett; Section author: Andrew C. Simmonett; Many post-processing tools can read information from Gaussian’s formatted; checkpoint (FCHK) files.; To allow interoperability with such tools, PSI4 includes a utility to; generate FCHK files. Wavefunction information, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and use it to create an FCHK writer:; 1; 2; 3energy, wfn = energy('scf', return_wfn=True); fchk_writer = psi4.core.FCHKWriter(wfn); fchk_writer.write('output.fchk'). The file will be written to the name passed to the FCHK writer’s write(); method. Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree–Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; 1; 2; 3grad, wfn = gradient('mp2', return_wfn=True); fchk_writer = psi4.core.FCHKWriter(wfn); fchk_writer.write('output.fchk'). psi4.fchk(wfn, filename)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:None. Parameters:; filename (string) – destination file name for FCHK file; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file. Examples:. 1; 2; 3>>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). «; hide m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/fchk-1.html:727,simpl,simply,727,psi4manual/1.2.1/fchk-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/fchk-1.html,2,['simpl'],['simply']
Usability,"﻿. Interface to programs through FCHK files — fchk(). Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. Interface to programs through FCHK files — fchk()¶; Code author: Andrew C. Simmonett; Section author: Andrew C. Simmonett; Many post-processing tools can read information from Gaussian’s formatted; checkpoint (FCHK) files.; To allow interoperability with such tools, PSI4 includes a utility to; generate FCHK files. Wavefunction information, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and use it to create an FCHK writer:; 1; 2; 3energy, wfn = energy('scf', return_wfn=True); fchk_writer = psi4.core.FCHKWriter(wfn); fchk_writer.write('output.fchk'). The file will be written to the name passed to the FCHK writer’s write(); method. Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree–Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; 1; 2; 3grad, wfn = gradient('mp2', return_wfn=True); fchk_writer = psi4.core.FCHKWriter(wfn); fchk_writer.write('output.fchk'). psi4.fchk(wfn, filename)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:None. Parameters:; filename (string) – destination file name for FCHK file; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/fchk-1.html:727,simpl,simply,727,psi4manual/1.3.2/fchk-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/fchk-1.html,2,['simpl'],['simply']
Usability,"﻿. Interface to programs through FCHK files — fchk(). Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to programs through FCHK files — fchk(). Interface to programs through FCHK files — fchk()¶; Code author: Andrew C. Simmonett; Section author: Andrew C. Simmonett; Many post-processing tools can read information from Gaussian’s formatted; checkpoint (FCHK) files.; To allow interoperability with such tools, PSI4 includes a utility to; generate FCHK files. Wavefunction information, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and hand it to the fchk driver function:; energy, wfn = energy('scf', return_wfn=True); fchk(wfn,'output.fchk'). The file will be written to the name passed to the fchk function.; Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree–Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; grad, wfn = gradient('mp2', return_wfn=True); fchk(wfn,'output.fchk'). psi4.fchk(wfn, filename, *, debug=False, strict_label=True)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns; None. Parameters. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is no",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fchk-1.html:776,simpl,simply,776,psi4manual/1.4.0/fchk-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fchk-1.html,2,['simpl'],['simply']
Usability,"﻿. Interface to programs through FCHK files — fchk(). Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to programs through FCHK files — fchk(). Interface to programs through FCHK files — fchk()¶; Code author: Andrew C. Simmonett; Section author: Andrew C. Simmonett; Many post-processing tools can read information from Gaussian’s formatted; checkpoint (FCHK) files.; To allow interoperability with such tools, PSI4 includes a utility to; generate FCHK files. Wavefunction information, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and hand it to the fchk driver function:; energy, wfn = energy('scf', return_wfn=True); fchk(wfn,'output.fchk'). The file will be written to the name passed to the fchk function.; Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree–Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; grad, wfn = gradient('mp2', return_wfn=True); fchk(wfn,'output.fchk'). psi4.fchk(wfn, filename, *, debug=False, strict_label=True)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns; None. Parameters. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is no",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/fchk-1.html:776,simpl,simply,776,psi4manual/1.5.0/fchk-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/fchk-1.html,2,['simpl'],['simply']
Usability,"﻿. Interface to programs through FCHK files — fchk(). Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to programs through FCHK files — fchk(). Interface to programs through FCHK files — fchk()¶; Code author: Andrew C. Simmonett; Section author: Andrew C. Simmonett; Many post-processing tools can read information from Gaussian’s formatted; checkpoint (FCHK) files.; To allow interoperability with such tools, PSI4 includes a utility to; generate FCHK files. Wavefunction information, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and hand it to the fchk driver function:; energy, wfn = energy('scf', return_wfn=True); fchk(wfn,'output.fchk'). The file will be written to the name passed to the fchk function.; Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree–Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; grad, wfn = gradient('mp2', return_wfn=True); fchk(wfn,'output.fchk'). psi4.fchk(wfn, filename, *, debug=False, strict_label=True)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns; None. Parameters. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is no",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/fchk.html:776,simpl,simply,776,psi4manual/1.6.x/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/fchk.html,1,['simpl'],['simply']
Usability,"﻿. Interface to programs through FCHK files — fchk(). Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to programs through FCHK files — fchk(). Interface to programs through FCHK files — fchk()¶; Code author: Andrew C. Simmonett; Section author: Andrew C. Simmonett; Many post-processing tools can read information from Gaussian’s formatted; checkpoint (FCHK) files.; To allow interoperability with such tools, PSI4 includes a utility to; generate FCHK files. Wavefunction information, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and hand it to the fchk driver function:; energy, wfn = energy('scf', return_wfn=True); fchk(wfn,'output.fchk'). The file will be written to the name passed to the fchk function.; Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree–Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; grad, wfn = gradient('mp2', return_wfn=True); fchk(wfn,'output.fchk'). psi4.fchk(wfn, filename, *, debug=False, strict_label=True)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/fchk.html:776,simpl,simply,776,psi4manual/1.7.x/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/fchk.html,1,['simpl'],['simply']
Usability,"﻿. Interface to programs through FCHK files — fchk(). Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to programs through FCHK files — fchk(). Interface to programs through FCHK files — fchk()¶; Code author: Andrew C. Simmonett; Section author: Andrew C. Simmonett; Many post-processing tools can read information from Gaussian’s formatted; checkpoint (FCHK) files.; To allow interoperability with such tools, PSI4 includes a utility to; generate FCHK files. Wavefunction information, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and hand it to the fchk driver function:; energy, wfn = energy('scf', return_wfn=True); fchk(wfn,'output.fchk'). The file will be written to the name passed to the fchk function.; Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree–Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; grad, wfn = gradient('mp2', return_wfn=True); fchk(wfn,'output.fchk'). psi4.fchk(wfn, filename, *, debug=False, strict_label=True)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/fchk.html:778,simpl,simply,778,psi4manual/1.8.x/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/fchk.html,1,['simpl'],['simply']
Usability,"﻿. Interface to programs through FCHK files — fchk(). Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to programs through FCHK files — fchk(). Interface to programs through FCHK files — fchk()¶; Code author: Andrew C. Simmonett; Section author: Andrew C. Simmonett; Many post-processing tools can read information from Gaussian’s formatted; checkpoint (FCHK) files.; To allow interoperability with such tools, PSI4 includes a utility to; generate FCHK files. Wavefunction information, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and hand it to the fchk driver function:; energy, wfn = energy('scf', return_wfn=True); fchk(wfn,'output.fchk'). The file will be written to the name passed to the fchk function.; Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree–Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; grad, wfn = gradient('mp2', return_wfn=True); fchk(wfn,'output.fchk'). psi4.fchk(wfn, filename, *, debug=False, strict_label=True)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/fchk.html:778,simpl,simply,778,psi4manual/1.9.x/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/fchk.html,1,['simpl'],['simply']
Usability,"﻿. Interface to programs through FCHK files, fchk() — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Interfaces: Enhancing Psi4 Capabilities ». Interface to programs through FCHK files, fchk()¶; Code author: Andrew C. Simmonett; Section author: Andrew C. Simmonett; Many post-processing tools can read information from Gaussian’s formatted; checkpoint (FCHK) files.; To allow interoperability with such tools, Psi4 includes a utility to; generate FCHK files. Wavefunction information, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and use it to create an FCHK writer:; energy, wfn = energy('scf', return_wfn=True); fchk_writer = psi4.FCHKWriter(wfn); fchk_writer.write('output.fchk'). The file will be written to the name passed to the FCHK writer’s write(); method. Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree-Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; grad, wfn = gradient('mp2', return_wfn=True); fchk_writer = psi4.FCHKWriter(wfn); fchk_writer.write('output.fchk'). fchk(wfn, filename)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:None. Parameters:; filename (string) – destination file name for FCHK file; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file. Examples:. >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/fchk-1.html:775,simpl,simply,775,psi4manual/1.0.0/fchk-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/fchk-1.html,2,['simpl'],['simply']
Usability,"﻿. Introduction — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,”; J. M. Turney",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/introduction-1.html:460,simpl,simple,460,psi4manual/4.0b2/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html,2,['simpl'],['simple']
Usability,"﻿. Introduction — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/introduction-1.html:475,simpl,simple,475,psi4manual/4.0b3/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html,2,['simpl'],['simple']
Usability,"﻿. Introduction — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices include a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶. Overall PSI4 Package¶; The following citation should be used in any publication utilizing the; PSI4 program package:. “Psi4: An open-source ab initio electronic s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/introduction-1.html:475,simpl,simple,475,psi4manual/4.0b4/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html,2,['simpl'],['simple']
Usability,"﻿. Introduction — PSI4 [beta5] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » . Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices include a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶. Overall PSI4 Package¶; The following citation should be used in any publication utilizing the; PSI4 program package:. “Psi4: An open-source ab initio electronic s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/introduction-1.html:475,simpl,simple,475,psi4manual/4.0b5/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/introduction-1.html,2,['simpl'],['simple']
Usability,"﻿. Introduction — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » . Introduction¶. Overview¶; Psi4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; Psi4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of Psi4 input files and how Python can be mixed with; quantum chemistry directives in Psi4. Section Psithon Functions; provides more detail on the Python functions provided by Psi4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using Psi4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices include a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest Psi4 documentation, check; www.psicode.org. Citing Psi4¶. Overall Psi4 Package¶; The following citation should be used in any publication utilizing the; Psi4 program package:. “Psi4: An open-source ab initio elect",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/introduction-1.html:482,simpl,simple,482,psi4manual/1.0.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/introduction-1.html,2,['simpl'],['simple']
Usability,"﻿. Introduction. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Introduction. Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/introduction.html:455,simpl,simple,455,psi4manual/master/introduction.html,https://psicode.org,https://psicode.org/psi4manual/master/introduction.html,2,"['simpl', 'user-friendly']","['simple', 'user-friendly']"
Usability,"﻿. Introduction. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and h",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:432,simpl,simple,432,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,4,"['simpl', 'user-friendly']","['simple', 'user-friendly']"
Usability,"﻿. Introduction. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/introduction-1.html:434,simpl,simple,434,psi4manual/1.2.1/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/introduction-1.html,4,"['simpl', 'user-friendly']","['simple', 'user-friendly']"
Usability,"﻿. Introduction. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/introduction-1.html:434,simpl,simple,434,psi4manual/1.3.2/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/introduction-1.html,4,"['simpl', 'user-friendly']","['simple', 'user-friendly']"
Usability,"﻿. Introduction. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Introduction. Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 inp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/introduction-1.html:446,simpl,simple,446,psi4manual/1.4.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/introduction-1.html,4,"['simpl', 'user-friendly']","['simple', 'user-friendly']"
Usability,"﻿. Introduction. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Introduction. Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 inp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/introduction-1.html:446,simpl,simple,446,psi4manual/1.5.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/introduction-1.html,4,"['simpl', 'user-friendly']","['simple', 'user-friendly']"
Usability,"﻿. Introduction. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction. Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 inp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/introduction.html:446,simpl,simple,446,psi4manual/1.6.x/introduction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html,2,"['simpl', 'user-friendly']","['simple', 'user-friendly']"
Usability,"﻿. Introduction. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Introduction. Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 inp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/introduction.html:446,simpl,simple,446,psi4manual/1.7.x/introduction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/introduction.html,2,"['simpl', 'user-friendly']","['simple', 'user-friendly']"
Usability,"﻿. Introduction. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Introduction. Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/introduction.html:448,simpl,simple,448,psi4manual/1.8.x/introduction.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/introduction.html,2,"['simpl', 'user-friendly']","['simple', 'user-friendly']"
Usability,"﻿. Introduction. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Introduction. Introduction¶. Overview¶; PSI4 provides a wide variety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/introduction.html:448,simpl,simple,448,psi4manual/1.9.x/introduction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/introduction.html,2,"['simpl', 'user-friendly']","['simple', 'user-friendly']"
Usability,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:269,simpl,simplify,269,psi4manual/4.0b3/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html,2,['simpl'],['simplify']
Usability,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html:269,simpl,simplify,269,psi4manual/4.0b4/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optionshandling-1.html,2,['simpl'],['simplify']
Usability,"﻿. LibOptions: globals, locals, has_changed and all that — PSI4 [beta5] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- The algor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/optionshandling-1.html:269,simpl,simplify,269,psi4manual/4.0b5/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/optionshandling-1.html,2,['simpl'],['simplify']
Usability,"﻿. LibOptions: globals, locals, has_changed and all that — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Programming: Using the Core Libraries ». LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native Psi4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /*- Th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optionshandling-1.html:276,simpl,simplify,276,psi4manual/1.0.0/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optionshandling-1.html,2,['simpl'],['simplify']
Usability,"﻿. LibOptions: globals, locals, has_changed and all that. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Programming with the Core Libraries; LibOptions: globals, locals, has_changed and all that. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options section. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/psi4/src/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str_i(""DATA_FILE"", ""data.dat"");;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optionshandling.html:286,simpl,simplify,286,psi4manual/master/optionshandling.html,https://psicode.org,https://psicode.org/psi4manual/master/optionshandling.html,1,['simpl'],['simplify']
Usability,"﻿. LibOptions: globals, locals, has_changed and all that. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Programming: Using the Core Libraries. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optionshandling-1.html:224,simpl,simplify,224,psi4manual/1.1.0/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optionshandling-1.html,2,['simpl'],['simplify']
Usability,"﻿. LibOptions: globals, locals, has_changed and all that. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/optionshandling-1.html:226,simpl,simplify,226,psi4manual/1.2.1/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/optionshandling-1.html,2,['simpl'],['simplify']
Usability,"﻿. LibOptions: globals, locals, has_changed and all that. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Programming with the Core Libraries. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options function. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/src/bin/psi4/read_options.cc.; An example of such a routine is; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str(""DATA_FILE"", ""data.dat"");; /",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/optionshandling-1.html:224,simpl,simplify,224,psi4manual/1.3.2/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/optionshandling-1.html,2,['simpl'],['simplify']
Usability,"﻿. LibOptions: globals, locals, has_changed and all that. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Programming with the Core Libraries; LibOptions: globals, locals, has_changed and all that. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options section. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/psi4/src/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str_i(""DATA_FILE"", ""data.dat"");; /*- The ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optionshandling-1.html:277,simpl,simplify,277,psi4manual/1.4.0/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optionshandling-1.html,2,['simpl'],['simplify']
Usability,"﻿. LibOptions: globals, locals, has_changed and all that. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Programming with the Core Libraries; LibOptions: globals, locals, has_changed and all that. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options section. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/psi4/src/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str_i(""DATA_FILE"", ""data.dat"");; /*- The ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/optionshandling-1.html:277,simpl,simplify,277,psi4manual/1.5.0/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/optionshandling-1.html,2,['simpl'],['simplify']
Usability,"﻿. LibOptions: globals, locals, has_changed and all that. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Programming with the Core Libraries; LibOptions: globals, locals, has_changed and all that. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options section. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/psi4/src/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str_i(""DATA_FILE"", ""data.dat"");; /*- The ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/optionshandling.html:277,simpl,simplify,277,psi4manual/1.6.x/optionshandling.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/optionshandling.html,1,['simpl'],['simplify']
Usability,"﻿. LibOptions: globals, locals, has_changed and all that. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Programming with the Core Libraries; LibOptions: globals, locals, has_changed and all that. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options section. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/psi4/src/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str_i(""DATA_FILE"", ""data.dat"");; /*- The ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optionshandling.html:277,simpl,simplify,277,psi4manual/1.7.x/optionshandling.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optionshandling.html,1,['simpl'],['simplify']
Usability,"﻿. LibOptions: globals, locals, has_changed and all that. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Programming with the Core Libraries; LibOptions: globals, locals, has_changed and all that. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options section. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/psi4/src/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str_i(""DATA_FILE"", ""data.dat"");; /*- Th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/optionshandling.html:279,simpl,simplify,279,psi4manual/1.8.x/optionshandling.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/optionshandling.html,1,['simpl'],['simplify']
Usability,"﻿. LibOptions: globals, locals, has_changed and all that. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Programming with the Core Libraries; LibOptions: globals, locals, has_changed and all that. LibOptions: globals, locals, has_changed and all that¶; To simplify parsing of options and handling of defaults, the Options class; was created. It functions in the following way:. Each module (or plugin) declares which options it will look for in the; input: their name, type (string, int, double, array, etc.), and any; default value they take.; The input is parsed for these options, and defaults are assigned for; those keywords not specified by the user.; The c-side module or plugin can then query the Options object for the; values associated with each keyword.; The options will also be accessible py-side to the procedures that drive; the modules. Array-type options are not available in python. Declaring Options¶; Each module needs to make itself known to the Options object, via a; read_options section. For plugins, this routine is provided by the user; in the plugin code. For native PSI4 modules, the entries need to; be appended to the read_options code in psi4/psi4/src/read_options.cc.; An example of such a routine is; if (name == ""MYMODULE""|| options.read_globals()) {; /*- The amount of information printed; to the output file -*/; options.add_int(""PRINT"", 1);; /*- Do save information to |mymodule__data_file| at the end of the computation? -*/; options.add_bool(""SAVE_INFO"", true);; /*- An array containing the number of doubly occupied orbitals per irrep; (in :ref:`Cotton order <table:irrepOrdering>`) -*/; options.add(""DOCC"", new ArrayType());; /*- The factor by which the harmonic vibrational frequencies are multiplied to; obtain an approximation to the fundamental vibrational frequencies -*/; options.add_double(""FREQUENCY_SCALE_FACTOR"", 1.0);; /*- The filename to which data is dumped. !expert -*/; options.add_str_i(""DATA_FILE"", ""data.dat"");; /*- Th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/optionshandling.html:279,simpl,simplify,279,psi4manual/1.9.x/optionshandling.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/optionshandling.html,1,['simpl'],['simplify']
Usability,"﻿. OEProp. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; OEProp. OEProp¶. class psi4.core.OEProp¶; Bases: pybind11_object; docstring; Attributes Summary. valid_methods. Methods Summary. Exvals(self); The x component of the field (in a.u.) at each grid point. Eyvals(self); The y component of the field (in a.u.) at each grid point. Ezvals(self); The z component of the field (in a.u.) at each grid point. Vvals(self); The electrostatic potential (in a.u.) at each grid point. add(self, arg0); Append the given task to the list of properties to compute. clear(self); Clear the list of properties to compute. compute(self); Compute the properties. set_Da_ao(self, Da[, symmetry]); docstring. set_Da_mo(self, arg0); docstring. set_Da_so(self, arg0); docstring. set_Db_ao(self, Db[, symmetry]); docstring. set_Db_mo(self, arg0); docstring. set_Db_so(self, arg0); docstring. set_names(self, arg0); Instruct OEProp to save variables under all specified names. set_title(self, title); Title OEProp for print purposes. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']¶. Methods Documentation. Exvals(self: psi4.core.OEProp) → list[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → list[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → list[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → list[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp) → None¶; Clear the list of properties to compute. compute(self: psi4.core.OEProp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.OEProp.html:618,clear,clear,618,psi4manual/master/api/psi4.core.OEProp.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.OEProp.html,1,['clear'],['clear']
Usability,"﻿. OEProp. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. OEProp¶. class psi4.core.OEProp¶; Bases: psi4.core.Prop; docstring; Attributes Summary. valid_methods. Methods Summary. Exvals(self); The x component of the field (in a.u.) at each grid point. Eyvals(self); The y component of the field (in a.u.) at each grid point. Ezvals(self); The z component of the field (in a.u.) at each grid point. Vvals(self); The electrostatic potential (in a.u.) at each grid point. add(self, arg0); docstring. clear(self); docstring. compute(self); docstring. set_Da_ao(self, Da, symmetry); docstring. set_Da_mo(self, arg0); docstring. set_Da_so(self, arg0); docstring. set_Db_ao(self, Db, symmetry); docstring. set_Db_mo(self, arg0); docstring. set_Db_so(self, arg0); docstring. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MAYER_INDICES', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']¶. Methods Documentation. Exvals(self: psi4.core.OEProp) → List[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; docstring. clear(self: psi4.core.OEProp) → None¶; docstring. compute(self: psi4.core.OEProp) → None¶; docstring. set_Da_ao(self: psi4.core.OEProp, Da: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Db_mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.oeprop.html:553,clear,clear,553,psi4manual/1.2.1/api/psi4.core.oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.oeprop.html,1,['clear'],['clear']
Usability,"﻿. OEProp. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. OEProp¶. class psi4.core.OEProp¶; Bases: psi4.core.TaskListComputer; docstring; Attributes Summary. valid_methods. Methods Summary. Exvals(self); The x component of the field (in a.u.) at each grid point. Eyvals(self); The y component of the field (in a.u.) at each grid point. Ezvals(self); The z component of the field (in a.u.) at each grid point. Vvals(self); The electrostatic potential (in a.u.) at each grid point. add(self, arg0); docstring. clear(self); docstring. compute(self); docstring. set_Da_ao(self, Da, symmetry); docstring. set_Da_mo(self, arg0); docstring. set_Da_so(self, arg0); docstring. set_Db_ao(self, Db, symmetry); docstring. set_Db_mo(self, arg0); docstring. set_Db_so(self, arg0); docstring. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MAYER_INDICES', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']¶. Methods Documentation. Exvals(self: psi4.core.OEProp) → List[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; docstring. clear(self: psi4.core.OEProp) → None¶; docstring. compute(self: psi4.core.OEProp) → None¶; docstring. set_Da_ao(self: psi4.core.OEProp, Da: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi::Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi::Matrix, symmetry: int=0) → None¶; docstrin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.oeprop.html:565,clear,clear,565,psi4manual/1.3.2/api/psi4.core.oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.oeprop.html,1,['clear'],['clear']
Usability,"﻿. OEProp. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; OEProp. OEProp¶. class psi4.core.OEProp¶; Bases: psi4.core.TaskListComputer; docstring; Attributes Summary. valid_methods. Methods Summary. Exvals(self); The x component of the field (in a.u.) at each grid point. Eyvals(self); The y component of the field (in a.u.) at each grid point. Ezvals(self); The z component of the field (in a.u.) at each grid point. Vvals(self); The electrostatic potential (in a.u.) at each grid point. add(self, arg0); docstring. clear(self); docstring. compute(self); docstring. set_Da_ao(self, Da, symmetry); docstring. set_Da_mo(self, arg0); docstring. set_Da_so(self, arg0); docstring. set_Db_ao(self, Db, symmetry); docstring. set_Db_mo(self, arg0); docstring. set_Db_so(self, arg0); docstring. set_title(self, arg0); docstring. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']¶. Methods Documentation. Exvals(self: psi4.core.OEProp) → List[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; docstring. clear(self: psi4.core.OEProp) → None¶; docstring. compute(self: psi4.core.OEProp) → None¶; docstring. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0) → None¶; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.OEP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.oeprop.html:571,clear,clear,571,psi4manual/1.4.0/api/psi4.core.oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.oeprop.html,1,['clear'],['clear']
Usability,"﻿. OEProp. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; OEProp. OEProp¶. class psi4.core.OEProp¶; Bases: psi4.core.TaskListComputer; docstring; Attributes Summary. valid_methods. Methods Summary. Exvals(self); The x component of the field (in a.u.) at each grid point. Eyvals(self); The y component of the field (in a.u.) at each grid point. Ezvals(self); The z component of the field (in a.u.) at each grid point. Vvals(self); The electrostatic potential (in a.u.) at each grid point. add(self, arg0); docstring. clear(self); docstring. compute(self); docstring. set_Da_ao(self, Da[, symmetry]); docstring. set_Da_mo(self, arg0); docstring. set_Da_so(self, arg0); docstring. set_Db_ao(self, Db[, symmetry]); docstring. set_Db_mo(self, arg0); docstring. set_Db_so(self, arg0); docstring. set_title(self, arg0); docstring. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']¶. Methods Documentation. Exvals(self: psi4.core.OEProp) → List[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; docstring. clear(self: psi4.core.OEProp) → None¶; docstring. compute(self: psi4.core.OEProp) → None¶; docstring. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0) → None¶; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix) → None¶; docstring. set_Db_ao(self: psi4.core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.oeprop.html:571,clear,clear,571,psi4manual/1.5.0/api/psi4.core.oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.oeprop.html,1,['clear'],['clear']
Usability,"﻿. OEProp. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; OEProp. OEProp¶. class psi4.core.OEProp¶; Bases: pybind11_builtins.pybind11_object; docstring; Attributes Summary. valid_methods. Methods Summary. Exvals(self); The x component of the field (in a.u.) at each grid point. Eyvals(self); The y component of the field (in a.u.) at each grid point. Ezvals(self); The z component of the field (in a.u.) at each grid point. Vvals(self); The electrostatic potential (in a.u.) at each grid point. add(self, arg0); Append the given task to the list of properties to compute. clear(self); Clear the list of properties to compute. compute(self); Compute the properties. set_Da_ao(self, Da[, symmetry]); docstring. set_Da_mo(self, arg0); docstring. set_Da_so(self, arg0); docstring. set_Db_ao(self, Db[, symmetry]); docstring. set_Db_mo(self, arg0); docstring. set_Db_so(self, arg0); docstring. set_names(self, arg0); Instruct OEProp to save variables under all specified names. set_title(self, title); Title OEProp for print purposes. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']¶. Methods Documentation. Exvals(self: psi4.core.OEProp) → List[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp) → None¶; Clear the list of properties to compute. compute(self: psi4.co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.OEProp.html:627,clear,clear,627,psi4manual/1.6.x/api/psi4.core.OEProp.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.OEProp.html,1,['clear'],['clear']
Usability,"﻿. OEProp. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; OEProp. OEProp¶. class psi4.core.OEProp¶; Bases: pybind11_object; docstring; Attributes Summary. valid_methods. Methods Summary. Exvals(self); The x component of the field (in a.u.) at each grid point. Eyvals(self); The y component of the field (in a.u.) at each grid point. Ezvals(self); The z component of the field (in a.u.) at each grid point. Vvals(self); The electrostatic potential (in a.u.) at each grid point. add(self, arg0); Append the given task to the list of properties to compute. clear(self); Clear the list of properties to compute. compute(self); Compute the properties. set_Da_ao(self, Da[, symmetry]); docstring. set_Da_mo(self, arg0); docstring. set_Da_so(self, arg0); docstring. set_Db_ao(self, Db[, symmetry]); docstring. set_Db_mo(self, arg0); docstring. set_Db_so(self, arg0); docstring. set_names(self, arg0); Instruct OEProp to save variables under all specified names. set_title(self, title); Title OEProp for print purposes. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']¶. Methods Documentation. Exvals(self: psi4.core.OEProp) → List[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp) → None¶; Clear the list of properties to compute. compute(self: psi4.core.OEProp) → None¶",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.OEProp.html:609,clear,clear,609,psi4manual/1.7.x/api/psi4.core.OEProp.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.OEProp.html,1,['clear'],['clear']
Usability,"﻿. OEProp. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; OEProp. OEProp¶. class psi4.core.OEProp¶; Bases: pybind11_object; docstring; Attributes Summary. valid_methods. Methods Summary. Exvals(self); The x component of the field (in a.u.) at each grid point. Eyvals(self); The y component of the field (in a.u.) at each grid point. Ezvals(self); The z component of the field (in a.u.) at each grid point. Vvals(self); The electrostatic potential (in a.u.) at each grid point. add(self, arg0); Append the given task to the list of properties to compute. clear(self); Clear the list of properties to compute. compute(self); Compute the properties. set_Da_ao(self, Da[, symmetry]); docstring. set_Da_mo(self, arg0); docstring. set_Da_so(self, arg0); docstring. set_Db_ao(self, Db[, symmetry]); docstring. set_Db_mo(self, arg0); docstring. set_Db_so(self, arg0); docstring. set_names(self, arg0); Instruct OEProp to save variables under all specified names. set_title(self, title); Title OEProp for print purposes. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']¶. Methods Documentation. Exvals(self: psi4.core.OEProp) → List[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp) → None¶; Clear the list of properties to compute. compute(self: psi4.core.OEProp) → Non",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.OEProp.html:611,clear,clear,611,psi4manual/1.8.x/api/psi4.core.OEProp.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.OEProp.html,1,['clear'],['clear']
Usability,"﻿. OEProp. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; OEProp. OEProp¶. class psi4.core.OEProp¶; Bases: pybind11_object; docstring; Attributes Summary. valid_methods. Methods Summary. Exvals(self); The x component of the field (in a.u.) at each grid point. Eyvals(self); The y component of the field (in a.u.) at each grid point. Ezvals(self); The z component of the field (in a.u.) at each grid point. Vvals(self); The electrostatic potential (in a.u.) at each grid point. add(self, arg0); Append the given task to the list of properties to compute. clear(self); Clear the list of properties to compute. compute(self); Compute the properties. set_Da_ao(self, Da[, symmetry]); docstring. set_Da_mo(self, arg0); docstring. set_Da_so(self, arg0); docstring. set_Db_ao(self, Db[, symmetry]); docstring. set_Db_mo(self, arg0); docstring. set_Db_so(self, arg0); docstring. set_names(self, arg0); Instruct OEProp to save variables under all specified names. set_title(self, title); Title OEProp for print purposes. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']¶. Methods Documentation. Exvals(self: psi4.core.OEProp) → List[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp) → None¶; Clear the list of properties to compute. compute(self: psi4.core.OEProp) → Non",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.OEProp.html:611,clear,clear,611,psi4manual/1.9.x/api/psi4.core.OEProp.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.OEProp.html,1,['clear'],['clear']
Usability,"﻿. Obtaining PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Installation and Runtime Configuration; Obtaining PSI4. Obtaining PSI4¶. Warning; As of v1.8, primary binary distribution has moved from; the psi4 channel to the conda-forge channel. Neither install docs; for users nor compile docs for developers have been updated yet to; reflect new patterns. Please consult psicode downloads; page for the latest guides. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}¶; A better decision tree is available at psicode.org/installs/latest,; though the below remains valid.; Take a quiz to find the best version of the codebase for; your needs, be it binary, tarball, or version-controlled repository. Or,; select outright among:. Binary Installer; Conda Binary Package; Clone from GitHub Repository; Fork from GitHub Repository (only path to develop PSI4); Tarball from GitHub Repository. Find-the-code Quiz¶; A better decision tree is available at psicode.org/installs/latest,; though the below remains valid. I just want to run the code. I may tweak the Python, but I’m not; developing anything to contribute back to the code base. Provided I still get good, threaded BLAS/LAPACK, OpenMP parallelism,; and optimization for a variety of processor architectures, I’m willing to forgo; architecture tuning wizardry to avoid compiling it myself. I’m on Linux or Mac (Intel or Silicon chips) or Windows (native or WSL/Ubuntu Bash Shell). I’m familiar with conda and want to manage PSI4 as an; ordinary conda package. — Goto Binary-Package; I just want a PSI4 installer. — Goto; Binary-Installer. I want to compile it myself to eke out best performance on my; computer. I accept responsibility for navigating compiler, threading,; and BLAS/LAPACK compatibility. I’m willing to have minimal dealings with git (e.g., commands git; clone and git pull) in return for easy access in future to new; features and bug fixes. — Goto Clone-from-GitHub; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_obtaining.html:445,guid,guides,445,psi4manual/master/build_obtaining.html,https://psicode.org,https://psicode.org/psi4manual/master/build_obtaining.html,1,['guid'],['guides']
Usability,"﻿. Obtaining PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Installation and Runtime Configuration; Obtaining PSI4. Obtaining PSI4¶. Warning; As of v1.8, primary binary distribution has moved from; the psi4 channel to the conda-forge channel. Neither install docs; for users nor compile docs for developers have been updated yet to; reflect new patterns. Please consult psicode downloads; page for the latest guides. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}¶; A better decision tree is available at psicode.org/installs/latest,; though the below remains valid.; Take a quiz to find the best version of the codebase for; your needs, be it binary, tarball, or version-controlled repository. Or,; select outright among:. Binary Installer; Conda Binary Package; Clone from GitHub Repository; Fork from GitHub Repository (only path to develop PSI4); Tarball from GitHub Repository. Find-the-code Quiz¶; A better decision tree is available at psicode.org/installs/latest,; though the below remains valid. I just want to run the code. I may tweak the Python, but I’m not; developing anything to contribute back to the code base. Provided I still get good, threaded BLAS/LAPACK, OpenMP parallelism,; and optimization for a variety of processor architectures, I’m willing to forgo; architecture tuning wizardry to avoid compiling it myself. I’m on Linux or Mac (Intel or Silicon chips) or Windows (native or WSL/Ubuntu Bash Shell). I’m familiar with conda and want to manage PSI4 as an; ordinary conda package. — Goto Binary-Package; I just want a PSI4 installer. — Goto; Binary-Installer. I want to compile it myself to eke out best performance on my; computer. I accept responsibility for navigating compiler, threading,; and BLAS/LAPACK compatibility. I’m willing to have minimal dealings with git (e.g., commands git; clone and git pull) in return for easy access in future to new; features and bug fixes. — Goto Clone-from-GitHub; I don’t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/build_obtaining.html:438,guid,guides,438,psi4manual/1.8.x/build_obtaining.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/build_obtaining.html,1,['guid'],['guides']
Usability,"﻿. Obtaining PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Installation and Runtime Configuration; Obtaining PSI4. Obtaining PSI4¶. Warning; As of v1.8, primary binary distribution has moved from; the psi4 channel to the conda-forge channel. Neither install docs; for users nor compile docs for developers have been updated yet to; reflect new patterns. Please consult psicode downloads; page for the latest guides. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}¶; A better decision tree is available at psicode.org/installs/latest,; though the below remains valid.; Take a quiz to find the best version of the codebase for; your needs, be it binary, tarball, or version-controlled repository. Or,; select outright among:. Binary Installer; Conda Binary Package; Clone from GitHub Repository; Fork from GitHub Repository (only path to develop PSI4); Tarball from GitHub Repository. Find-the-code Quiz¶; A better decision tree is available at psicode.org/installs/latest,; though the below remains valid. I just want to run the code. I may tweak the Python, but I’m not; developing anything to contribute back to the code base. Provided I still get good, threaded BLAS/LAPACK, OpenMP parallelism,; and optimization for a variety of processor architectures, I’m willing to forgo; architecture tuning wizardry to avoid compiling it myself. I’m on Linux or Mac (Intel or Silicon chips) or Windows (native or WSL/Ubuntu Bash Shell). I’m familiar with conda and want to manage PSI4 as an; ordinary conda package. — Goto Binary-Package; I just want a PSI4 installer. — Goto; Binary-Installer. I want to compile it myself to eke out best performance on my; computer. I accept responsibility for navigating compiler, threading,; and BLAS/LAPACK compatibility. I’m willing to have minimal dealings with git (e.g., commands git; clone and git pull) in return for easy access in future to new; features and bug fixes. — Goto Clone-from-GitHub; I don’t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/build_obtaining.html:438,guid,guides,438,psi4manual/1.9.x/build_obtaining.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/build_obtaining.html,1,['guid'],['guides']
Usability,"﻿. PSI4NUMPY. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Test Suite and Sample Inputs; PSI4NUMPY. PSI4NUMPY¶. Input File; Description. psi4numpy/cphf; Tests out the CG solver with CPHF Polarizabilities. psi4numpy/dfmp2; A simple Psi 4 input script to compute MP2 from a RHF reference. psi4numpy/rhf-gradient; rhf gradient code. psi4numpy/rhf; A simple Psi 4 input script to compute a SCF reference using Psi4’s libJK. psi4numpy/fci; coded full CI vs. detci. psi4numpy/rhf-hessian; RHF Hessian code. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Test Suite and Sample Inputs; PSI4NUMPY. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_psi4numpy.html:268,simpl,simple,268,psi4manual/master/autodoc_testsuite_psi4numpy.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_psi4numpy.html,2,['simpl'],['simple']
Usability,"﻿. PSI4NUMPY. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Test Suite and Sample Inputs. PSI4NUMPY¶. Input File; Description. psi4numpy/rhf; A simple Psi 4 input script to compute a SCF reference using Psi4’s libJK. psi4numpy/fci; coded full CI vs. detci. psi4numpy/rhf-gradient; rhf gradient code. psi4numpy/rhf-hessian; RHF Hessian code. psi4numpy/dfmp2; A simple Psi 4 input script to compute MP2 from a RHF reference. psi4numpy/cphf; Tests out the CG solver with CPHF Polarizabilities. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Test Suite and Sample Inputs. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_psi4numpy-1.html:180,simpl,simple,180,psi4manual/1.2.1/autodoc_testsuite_psi4numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_psi4numpy-1.html,4,['simpl'],['simple']
Usability,"﻿. PSI4NUMPY. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Test Suite and Sample Inputs. PSI4NUMPY¶. Input File; Description. psi4numpy/rhf; A simple Psi 4 input script to compute a SCF reference using Psi4’s libJK. psi4numpy/fci; coded full CI vs. detci. psi4numpy/rhf-gradient; rhf gradient code. psi4numpy/rhf-hessian; RHF Hessian code. psi4numpy/dfmp2; A simple Psi 4 input script to compute MP2 from a RHF reference. psi4numpy/cphf; Tests out the CG solver with CPHF Polarizabilities. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Test Suite and Sample Inputs. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_psi4numpy-1.html:180,simpl,simple,180,psi4manual/1.3.2/autodoc_testsuite_psi4numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_psi4numpy-1.html,4,['simpl'],['simple']
Usability,"﻿. PSI4NUMPY. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Test Suite and Sample Inputs; PSI4NUMPY. PSI4NUMPY¶. Input File; Description. psi4numpy/rhf; A simple Psi 4 input script to compute a SCF reference using Psi4’s libJK. psi4numpy/rhf-gradient; rhf gradient code. psi4numpy/rhf-hessian; RHF Hessian code. psi4numpy/cphf; Tests out the CG solver with CPHF Polarizabilities. psi4numpy/dfmp2; A simple Psi 4 input script to compute MP2 from a RHF reference. psi4numpy/fci; coded full CI vs. detci. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Test Suite and Sample Inputs; PSI4NUMPY. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_psi4numpy-1.html:189,simpl,simple,189,psi4manual/1.4.0/autodoc_testsuite_psi4numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_psi4numpy-1.html,4,['simpl'],['simple']
Usability,"﻿. PSI4NUMPY. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Test Suite and Sample Inputs; PSI4NUMPY. PSI4NUMPY¶. Input File; Description. psi4numpy/rhf-hessian; RHF Hessian code. psi4numpy/dfmp2; A simple Psi 4 input script to compute MP2 from a RHF reference. psi4numpy/cphf; Tests out the CG solver with CPHF Polarizabilities. psi4numpy/fci; coded full CI vs. detci. psi4numpy/rhf-gradient; rhf gradient code. psi4numpy/rhf; A simple Psi 4 input script to compute a SCF reference using Psi4’s libJK. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Test Suite and Sample Inputs; PSI4NUMPY. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_psi4numpy-1.html:232,simpl,simple,232,psi4manual/1.5.0/autodoc_testsuite_psi4numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_psi4numpy-1.html,4,['simpl'],['simple']
Usability,"﻿. PSI4NUMPY. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Test Suite and Sample Inputs; PSI4NUMPY. PSI4NUMPY¶. Input File; Description. psi4numpy/rhf; A simple Psi 4 input script to compute a SCF reference using Psi4’s libJK. psi4numpy/fci; coded full CI vs. detci. psi4numpy/rhf-gradient; rhf gradient code. psi4numpy/rhf-hessian; RHF Hessian code. psi4numpy/dfmp2; A simple Psi 4 input script to compute MP2 from a RHF reference. psi4numpy/cphf; Tests out the CG solver with CPHF Polarizabilities. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Test Suite and Sample Inputs; PSI4NUMPY. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_psi4numpy.html:189,simpl,simple,189,psi4manual/1.6.x/autodoc_testsuite_psi4numpy.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_psi4numpy.html,2,['simpl'],['simple']
Usability,"﻿. PSI4NUMPY. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Test Suite and Sample Inputs; PSI4NUMPY. PSI4NUMPY¶. Input File; Description. psi4numpy/cphf; Tests out the CG solver with CPHF Polarizabilities. psi4numpy/fci; coded full CI vs. detci. psi4numpy/rhf; A simple Psi 4 input script to compute a SCF reference using Psi4’s libJK. psi4numpy/rhf-gradient; rhf gradient code. psi4numpy/dfmp2; A simple Psi 4 input script to compute MP2 from a RHF reference. psi4numpy/rhf-hessian; RHF Hessian code. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Test Suite and Sample Inputs; PSI4NUMPY. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_psi4numpy.html:297,simpl,simple,297,psi4manual/1.7.x/autodoc_testsuite_psi4numpy.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_psi4numpy.html,2,['simpl'],['simple']
Usability,"﻿. PSI4NUMPY. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Test Suite and Sample Inputs; PSI4NUMPY. PSI4NUMPY¶. Input File; Description. psi4numpy/cphf; Tests out the CG solver with CPHF Polarizabilities. psi4numpy/rhf-gradient; rhf gradient code. psi4numpy/rhf; A simple Psi 4 input script to compute a SCF reference using Psi4’s libJK. psi4numpy/rhf-hessian; RHF Hessian code. psi4numpy/dfmp2; A simple Psi 4 input script to compute MP2 from a RHF reference. psi4numpy/fci; coded full CI vs. detci. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Test Suite and Sample Inputs; PSI4NUMPY. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_psi4numpy.html:302,simpl,simple,302,psi4manual/1.8.x/autodoc_testsuite_psi4numpy.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_psi4numpy.html,2,['simpl'],['simple']
Usability,"﻿. PSI4NUMPY. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Test Suite and Sample Inputs; PSI4NUMPY. PSI4NUMPY¶. Input File; Description. psi4numpy/rhf; A simple Psi 4 input script to compute a SCF reference using Psi4’s libJK. psi4numpy/cphf; Tests out the CG solver with CPHF Polarizabilities. psi4numpy/rhf-gradient; rhf gradient code. psi4numpy/rhf-hessian; RHF Hessian code. psi4numpy/fci; coded full CI vs. detci. psi4numpy/dfmp2; A simple Psi 4 input script to compute MP2 from a RHF reference. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Test Suite and Sample Inputs; PSI4NUMPY. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_psi4numpy.html:191,simpl,simple,191,psi4manual/1.9.x/autodoc_testsuite_psi4numpy.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_psi4numpy.html,2,['simpl'],['simple']
Usability,"﻿. Plugins: Adding New Functionality to PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Contributions: Intro to Programming in PSI4. Plugins: Adding New Functionality to PSI4¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/plugins-1.html:414,learn,learn,414,psi4manual/1.1.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/plugins-1.html,2,['learn'],['learn']
Usability,"﻿. Plugins: Adding New Functionality to PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. Plugins: Adding New Functionality to PSI4¶. Modular Approach to Development¶; It is slightly cumbersome to the development cycle to recompile PSI4; every time a change is made to the C++ code.; It’s also daunting to new developers if they’re required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, PSI4 now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi’s vast library. The plugins can be loaded at; run-time from any location. Creating a New Plugin¶; PSI4 can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing myplugin with the name of your great code.; If the name you provide is not valid, PSI4 will complain.; 1>>> psi4 --plugin-name myplugin. PSI4 will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is cd into the directory, use PSI4 to generate; a Makefile, and type make. Then execute psi4 in the directory on the; default input file.; 1; 2; 3; 4>>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. PSI4 comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs:; 1; 2; 3; 4; 5; 6>>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/plugins-1.html:416,learn,learn,416,psi4manual/1.2.1/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html,2,['learn'],['learn']
Usability,"﻿. Psithon: Structuring an Input File — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:310,simpl,simpler,310,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,2,['simpl'],['simpler']
Usability,"﻿. Psithon: Structuring an Input File — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html:325,simpl,simpler,325,psi4manual/4.0b3/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html,2,['simpl'],['simpler']
Usability,"﻿. Psithon: Structuring an Input File — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:325,simpl,simpler,325,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,2,['simpl'],['simpler']
Usability,"﻿. Psithon: Structuring an Input File — PSI4 [beta5] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psithoninput-1.html:325,simpl,simpler,325,psi4manual/4.0b5/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psithoninput-1.html,2,['simpl'],['simpler']
Usability,"﻿. Psithon: Structuring an Input File — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » . Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, Psi4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; Psi4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level Psi4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all Psi4 input files.; For convenience, the physical constants used within the Psi4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within Psi4, which are automatically; made available within all Psi4 input files.; # @END LICENSE; #. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/include/physconst.h; psi_h = 6.62606896E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:332,simpl,simpler,332,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['simpl'],['simpler']
Usability,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Psithon: Structuring an Input File. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples.; The equivalent Python PsiAPI syntax is shown alongside the Psithon code snippets.; When using the Python API, one must import the PSI4 module with:; import psi4. No such directive is neccesary when using Psithon, which is run using the psi4; executable. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made availa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:327,simpl,simpler,327,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['simpl'],['simpler']
Usability,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of lig",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:282,simpl,simpler,282,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,2,['simpl'],['simpler']
Usability,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:284,simpl,simpler,284,psi4manual/1.2.1/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html,2,['simpl'],['simpler']
Usability,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psithoninput-1.html:284,simpl,simpler,284,psi4manual/1.3.2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psithoninput-1.html,2,['simpl'],['simpler']
Usability,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Psithon: Structuring an Input File. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:318,simpl,simpler,318,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,2,['simpl'],['simpler']
Usability,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Psithon: Structuring an Input File. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psithoninput-1.html:318,simpl,simpler,318,psi4manual/1.5.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psithoninput-1.html,2,['simpl'],['simpler']
Usability,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon: Structuring an Input File. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psithoninput.html:318,simpl,simpler,318,psi4manual/1.6.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psithoninput.html,1,['simpl'],['simpler']
Usability,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon: Structuring an Input File. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psithoninput.html:318,simpl,simpler,318,psi4manual/1.7.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psithoninput.html,1,['simpl'],['simpler']
Usability,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Psithon: Structuring an Input File. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psithoninput.html:320,simpl,simpler,320,psi4manual/1.8.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psithoninput.html,1,['simpl'],['simpler']
Usability,"﻿. Psithon: Structuring an Input File. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Psithon: Structuring an Input File. Psithon: Structuring an Input File¶; To allow arbitrarily complex computations to be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psithoninput.html:320,simpl,simpler,320,psi4manual/1.9.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psithoninput.html,1,['simpl'],['simpler']
Usability,"﻿. Python Style. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Adding New Code to PSI4; Python Style. Python Style¶. How to Ignore the Bots¶; Formatting and analysis bots are great because it takes more effort; to defy them than to accept their criticism. Nevertheless, for code; clarity, they can be honestly wrong, so we need a way to specifically; clear their findings. Py Formatting (yapf) # yapf: disable (single line or block) # yapf: enable (resume); C++ Formatting (clang-format) // clang-format off (single line or block) // clang-format on (resume); Py Dynamic Analysis (coverage.py) # pragma: no cover; C++ Dynamic Analysis (gcov) https://stackoverflow.com/a/30078276 untested; Py Static Analysis (lgtm) # lgtm[py/not-named-self] (click on the “?” to get the “Query ID”); C++ Static Analysis (lgtm) // lgtm[cpp/wrong-type-format-argument] (click on the “?” to get the “Query ID”). table of contents. Python Style; How to Ignore the Bots. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Adding New Code to PSI4; Python Style. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_style_py.html:382,clear,clear,382,psi4manual/master/prog_style_py.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_style_py.html,3,"['clear', 'resume']","['clear', 'resume']"
Usability,"﻿. Python Style. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Adding New Code to PSI4; Python Style. Python Style¶. How to Ignore the Bots¶; Formatting and analysis bots are great because it takes more effort; to defy them than to accept their criticism. Nevertheless, for code; clarity, they can be honestly wrong, so we need a way to specifically; clear their findings. Py Formatting (yapf) # yapf: disable (single line or block) # yapf: enable (resume); C++ Formatting (clang-format) // clang-format off (single line or block) // clang-format on (resume); Py Dynamic Analysis (coverage.py) # pragma: no cover; C++ Dynamic Analysis (gcov) https://stackoverflow.com/a/30078276 untested; Py Static Analysis (lgtm) # lgtm[py/not-named-self] (click on the “?” to get the “Query ID”); C++ Static Analysis (lgtm) // lgtm[cpp/wrong-type-format-argument] (click on the “?” to get the “Query ID”). table of contents. Python Style; How to Ignore the Bots. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Adding New Code to PSI4; Python Style. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_style_py-1.html:373,clear,clear,373,psi4manual/1.4.0/prog_style_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_style_py-1.html,6,"['clear', 'resume']","['clear', 'resume']"
Usability,"﻿. Python Style. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Adding New Code to PSI4; Python Style. Python Style¶. How to Ignore the Bots¶; Formatting and analysis bots are great because it takes more effort; to defy them than to accept their criticism. Nevertheless, for code; clarity, they can be honestly wrong, so we need a way to specifically; clear their findings. Py Formatting (yapf) # yapf: disable (single line or block) # yapf: enable (resume); C++ Formatting (clang-format) // clang-format off (single line or block) // clang-format on (resume); Py Dynamic Analysis (coverage.py) # pragma: no cover; C++ Dynamic Analysis (gcov) https://stackoverflow.com/a/30078276 untested; Py Static Analysis (lgtm) # lgtm[py/not-named-self] (click on the “?” to get the “Query ID”); C++ Static Analysis (lgtm) // lgtm[cpp/wrong-type-format-argument] (click on the “?” to get the “Query ID”). table of contents. Python Style; How to Ignore the Bots. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Adding New Code to PSI4; Python Style. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/prog_style_py-1.html:373,clear,clear,373,psi4manual/1.5.0/prog_style_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/prog_style_py-1.html,6,"['clear', 'resume']","['clear', 'resume']"
Usability,"﻿. Python Style. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Python Style. Python Style¶. How to Ignore the Bots¶; Formatting and analysis bots are great because it takes more effort; to defy them than to accept their criticism. Nevertheless, for code; clarity, they can be honestly wrong, so we need a way to specifically; clear their findings. Py Formatting (yapf) # yapf: disable (single line or block) # yapf: enable (resume); C++ Formatting (clang-format) // clang-format off (single line or block) // clang-format on (resume); Py Dynamic Analysis (coverage.py) # pragma: no cover; C++ Dynamic Analysis (gcov) https://stackoverflow.com/a/30078276 untested; Py Static Analysis (lgtm) # lgtm[py/not-named-self] (click on the “?” to get the “Query ID”); C++ Static Analysis (lgtm) // lgtm[cpp/wrong-type-format-argument] (click on the “?” to get the “Query ID”). table of contents. Python Style; How to Ignore the Bots. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Python Style. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/prog_style_py.html:373,clear,clear,373,psi4manual/1.6.x/prog_style_py.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_style_py.html,3,"['clear', 'resume']","['clear', 'resume']"
Usability,"﻿. Python Style. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Adding New Code to PSI4; Python Style. Python Style¶. How to Ignore the Bots¶; Formatting and analysis bots are great because it takes more effort; to defy them than to accept their criticism. Nevertheless, for code; clarity, they can be honestly wrong, so we need a way to specifically; clear their findings. Py Formatting (yapf) # yapf: disable (single line or block) # yapf: enable (resume); C++ Formatting (clang-format) // clang-format off (single line or block) // clang-format on (resume); Py Dynamic Analysis (coverage.py) # pragma: no cover; C++ Dynamic Analysis (gcov) https://stackoverflow.com/a/30078276 untested; Py Static Analysis (lgtm) # lgtm[py/not-named-self] (click on the “?” to get the “Query ID”); C++ Static Analysis (lgtm) // lgtm[cpp/wrong-type-format-argument] (click on the “?” to get the “Query ID”). table of contents. Python Style; How to Ignore the Bots. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Adding New Code to PSI4; Python Style. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/prog_style_py.html:373,clear,clear,373,psi4manual/1.7.x/prog_style_py.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/prog_style_py.html,3,"['clear', 'resume']","['clear', 'resume']"
Usability,"﻿. Python Style. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Adding New Code to PSI4; Python Style. Python Style¶. How to Ignore the Bots¶; Formatting and analysis bots are great because it takes more effort; to defy them than to accept their criticism. Nevertheless, for code; clarity, they can be honestly wrong, so we need a way to specifically; clear their findings. Py Formatting (yapf) # yapf: disable (single line or block) # yapf: enable (resume); C++ Formatting (clang-format) // clang-format off (single line or block) // clang-format on (resume); Py Dynamic Analysis (coverage.py) # pragma: no cover; C++ Dynamic Analysis (gcov) https://stackoverflow.com/a/30078276 untested; Py Static Analysis (lgtm) # lgtm[py/not-named-self] (click on the “?” to get the “Query ID”); C++ Static Analysis (lgtm) // lgtm[cpp/wrong-type-format-argument] (click on the “?” to get the “Query ID”). table of contents. Python Style; How to Ignore the Bots. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Adding New Code to PSI4; Python Style. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/prog_style_py.html:375,clear,clear,375,psi4manual/1.8.x/prog_style_py.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/prog_style_py.html,3,"['clear', 'resume']","['clear', 'resume']"
Usability,"﻿. Python Style. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Adding New Code to PSI4; Python Style. Python Style¶. How to Ignore the Bots¶; Formatting and analysis bots are great because it takes more effort; to defy them than to accept their criticism. Nevertheless, for code; clarity, they can be honestly wrong, so we need a way to specifically; clear their findings. Py Formatting (yapf) # yapf: disable (single line or block) # yapf: enable (resume); C++ Formatting (clang-format) // clang-format off (single line or block) // clang-format on (resume); Py Dynamic Analysis (coverage.py) # pragma: no cover; C++ Dynamic Analysis (gcov) https://stackoverflow.com/a/30078276 untested; Py Static Analysis (lgtm) # lgtm[py/not-named-self] (click on the “?” to get the “Query ID”); C++ Static Analysis (lgtm) // lgtm[cpp/wrong-type-format-argument] (click on the “?” to get the “Query ID”). table of contents. Python Style; How to Ignore the Bots. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Adding New Code to PSI4; Python Style. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/prog_style_py.html:375,clear,clear,375,psi4manual/1.9.x/prog_style_py.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/prog_style_py.html,3,"['clear', 'resume']","['clear', 'resume']"
Usability,"﻿. UpgradeHelper. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; UpgradeHelper. UpgradeHelper¶. exception psi4.driver.UpgradeHelper(old, new, version, elaboration)[source]¶; Error called on previously valid syntax that now isn’t and a; simple syntax transition is possible.; It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning.; For cases where the syntax just has to jump, an UpgradeHelper can be used; to trap the old syntax at first error and suggest the new.; An UpgradeHelper can also be used after the FutureWarning; described above has expired. Then the body of the code can be deleted while; the definition is preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters:. old (str) – Previously valid syntax.; new (str) – Suggested replacement syntax.; version (str) – First Major.minor version at which old syntax won’t run. Generally; the next release at time of commit.; elaboration (str) – Any additional message to convey. Should start with a space. table of contents. UpgradeHelper; UpgradeHelper. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; UpgradeHelper. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.UpgradeHelper.html:300,simpl,simple,300,psi4manual/master/api/psi4.driver.UpgradeHelper.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.UpgradeHelper.html,2,"['guid', 'simpl']","['guide', 'simple']"
Usability,"﻿. UpgradeHelper. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; UpgradeHelper. UpgradeHelper¶. exception psi4.driver.UpgradeHelper(old, new, version, elaboration)[source]¶; Error called on previously valid syntax that now isn’t and a; simple syntax transition is possible.; It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning. For; cases where the syntax just has to jump, this can be used to trap; the old syntax at first error and suggest the new. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; UpgradeHelper. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.upgradehelper.html:291,simpl,simple,291,psi4manual/1.4.0/api/psi4.driver.upgradehelper.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.upgradehelper.html,1,['simpl'],['simple']
Usability,"﻿. UpgradeHelper. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; UpgradeHelper. UpgradeHelper¶. exception psi4.driver.UpgradeHelper(old, new, version, elaboration)[source]¶; Error called on previously valid syntax that now isn’t and a; simple syntax transition is possible.; It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning. For; cases where the syntax just has to jump, this can be used to trap; the old syntax at first error and suggest the new. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; UpgradeHelper. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.upgradehelper.html:291,simpl,simple,291,psi4manual/1.5.0/api/psi4.driver.upgradehelper.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.upgradehelper.html,1,['simpl'],['simple']
Usability,"﻿. UpgradeHelper. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; UpgradeHelper. UpgradeHelper¶. exception psi4.driver.UpgradeHelper(old, new, version, elaboration)[source]¶; Error called on previously valid syntax that now isn’t and a; simple syntax transition is possible.; It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning. For; cases where the syntax just has to jump, this can be used to trap; the old syntax at first error and suggest the new. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; UpgradeHelper. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.UpgradeHelper.html:291,simpl,simple,291,psi4manual/1.6.x/api/psi4.driver.UpgradeHelper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.UpgradeHelper.html,1,['simpl'],['simple']
Usability,"﻿. UpgradeHelper. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; UpgradeHelper. UpgradeHelper¶. exception psi4.driver.UpgradeHelper(old, new, version, elaboration)[source]¶; Error called on previously valid syntax that now isn’t and a; simple syntax transition is possible.; It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning.; For cases where the syntax just has to jump, an UpgradeHelper can be used; to trap the old syntax at first error and suggest the new.; An UpgradeHelper can also be used after the FutureWarning; described above has expired. Then the body of the code can be deleted while; the definition is preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters:. old (str) – Previously valid syntax.; new (str) – Suggested replacement syntax.; version (str) – First Major.minor version at which old syntax won’t run. Generally; the next release at time of commit.; elaboration (str) – Any additional message to convey. Should start with a space. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; UpgradeHelper. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.UpgradeHelper.html:291,simpl,simple,291,psi4manual/1.7.x/api/psi4.driver.UpgradeHelper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.UpgradeHelper.html,2,"['guid', 'simpl']","['guide', 'simple']"
Usability,"﻿. UpgradeHelper. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; UpgradeHelper. UpgradeHelper¶. exception psi4.driver.UpgradeHelper(old, new, version, elaboration)[source]¶; Error called on previously valid syntax that now isn’t and a; simple syntax transition is possible.; It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning.; For cases where the syntax just has to jump, an UpgradeHelper can be used; to trap the old syntax at first error and suggest the new.; An UpgradeHelper can also be used after the FutureWarning; described above has expired. Then the body of the code can be deleted while; the definition is preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters:. old (str) – Previously valid syntax.; new (str) – Suggested replacement syntax.; version (str) – First Major.minor version at which old syntax won’t run. Generally; the next release at time of commit.; elaboration (str) – Any additional message to convey. Should start with a space. table of contents. UpgradeHelper; UpgradeHelper. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; UpgradeHelper. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.UpgradeHelper.html:293,simpl,simple,293,psi4manual/1.8.x/api/psi4.driver.UpgradeHelper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.UpgradeHelper.html,2,"['guid', 'simpl']","['guide', 'simple']"
Usability,"﻿. UpgradeHelper. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; UpgradeHelper. UpgradeHelper¶. exception psi4.driver.UpgradeHelper(old, new, version, elaboration)[source]¶; Error called on previously valid syntax that now isn’t and a; simple syntax transition is possible.; It is much preferred to leave the old syntax valid for a release; cycle and have the old syntax raise a deprecation FutureWarning.; For cases where the syntax just has to jump, an UpgradeHelper can be used; to trap the old syntax at first error and suggest the new.; An UpgradeHelper can also be used after the FutureWarning; described above has expired. Then the body of the code can be deleted while; the definition is preserved, and an UpgradeHelper called in place of the; body to guide users with lagging syntax. Parameters:. old (str) – Previously valid syntax.; new (str) – Suggested replacement syntax.; version (str) – First Major.minor version at which old syntax won’t run. Generally; the next release at time of commit.; elaboration (str) – Any additional message to convey. Should start with a space. table of contents. UpgradeHelper; UpgradeHelper. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; UpgradeHelper. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.UpgradeHelper.html:293,simpl,simple,293,psi4manual/1.9.x/api/psi4.driver.UpgradeHelper.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.UpgradeHelper.html,2,"['guid', 'simpl']","['guide', 'simple']"
Usability,"﻿. Vibrational and Thermochemical Analysis — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Theoretical Methods: SCF to FCI ». Vibrational and Thermochemical Analysis¶; Code author: Rollin A. King; Module: Keywords, PSI Variables, THERMO. Caution; It is important to know that Psi4, like any other; quantum chemistry program, does not compute the usual enthalpies,; entropies, or Gibbs free energies of formation provided by most; reference books. Instead, quantum chemistry programs compute “absolute”; thermodynamic properties relative to infinitely separated nuclei and; electrons, not “formation” values relative to elements in their standard; states. If you are computing thermodynamic differences, like a reaction; enthalpy computed as the enthalpy of the products minus the enthalpy; of the reactants, then these “absolute” enthalpies are perfectly valid; and usable. However, they cannot be mixed and matched with enthalpies of; formation from reference books, since the zero of energy is not the same.; Additionally, the “thermal energies” reported in kcal/mol are the; finite-temperature corrections to the electronic total energy, and; not the overall thermal energies themselves. If in doubt, use the; reported Total Energies in Hartree/particle. Keywords¶. T¶. Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. P¶. Pressure in Pascal for thermodynamic analysis. Note that 100000. is the value for IUPAC STP. Type: double; Default: 101325. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this option is the sole way to influence the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/thermo-1.html:937,usab,usable,937,psi4manual/1.0.0/thermo-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/thermo-1.html,2,['usab'],['usable']
Usability,"﻿. Vibrational and Thermochemical Analysis. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Theoretical Methods: SCF to FCI; Vibrational and Thermochemical Analysis. Vibrational and Thermochemical Analysis¶; Code author: Rollin A. King and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, THERMO. Caution; It is important to know that PSI4, like any other; quantum chemistry program, does not compute the usual enthalpies,; entropies, or Gibbs free energies of formation provided by most; reference books. Instead, quantum chemistry programs compute “absolute”; thermodynamic properties relative to infinitely separated nuclei and; electrons, not “formation” values relative to elements in their standard; states. If you are computing thermodynamic differences, like a reaction; enthalpy computed as the enthalpy of the products minus the enthalpy; of the reactants, then these “absolute” enthalpies are perfectly valid; and usable. However, they cannot be mixed and matched with enthalpies of; formation from reference books, since the zero of energy is not the same.; Additionally, the “thermal energies” reported in kcal/mol are the; finite-temperature corrections to the electronic total energy, and; not the overall thermal energies themselves. If in doubt, use the; reported Total Energies in Hartree/particle. Keywords¶. T¶. Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. P¶. Pressure in Pascal for thermodynamic analysis. Note that 100000. is the value for IUPAC STP. Type: double; Default: 101325. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/thermo.html:984,usab,usable,984,psi4manual/master/thermo.html,https://psicode.org,https://psicode.org/psi4manual/master/thermo.html,1,['usab'],['usable']
Usability,"﻿. Vibrational and Thermochemical Analysis. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Theoretical Methods: SCF to FCI. Vibrational and Thermochemical Analysis¶; Code author: Rollin A. King; Module: Keywords, PSI Variables, THERMO. Caution; It is important to know that PSI4, like any other; quantum chemistry program, does not compute the usual enthalpies,; entropies, or Gibbs free energies of formation provided by most; reference books. Instead, quantum chemistry programs compute “absolute”; thermodynamic properties relative to infinitely separated nuclei and; electrons, not “formation” values relative to elements in their standard; states. If you are computing thermodynamic differences, like a reaction; enthalpy computed as the enthalpy of the products minus the enthalpy; of the reactants, then these “absolute” enthalpies are perfectly valid; and usable. However, they cannot be mixed and matched with enthalpies of; formation from reference books, since the zero of energy is not the same.; Additionally, the “thermal energies” reported in kcal/mol are the; finite-temperature corrections to the electronic total energy, and; not the overall thermal energies themselves. If in doubt, use the; reported Total Energies in Hartree/particle. Keywords¶. T¶. Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. P¶. Pressure in Pascal for thermodynamic analysis. Note that 100000. is the value for IUPAC STP. Type: double; Default: 101325. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this option is the sole way to influence the symmetry-dependent aspects of the thermodynamic ana",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/thermo-1.html:885,usab,usable,885,psi4manual/1.1.0/thermo-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/thermo-1.html,2,['usab'],['usable']
Usability,"﻿. Vibrational and Thermochemical Analysis. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Theoretical Methods: SCF to FCI. Vibrational and Thermochemical Analysis¶; Code author: Rollin A. King and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, THERMO. Caution; It is important to know that PSI4, like any other; quantum chemistry program, does not compute the usual enthalpies,; entropies, or Gibbs free energies of formation provided by most; reference books. Instead, quantum chemistry programs compute “absolute”; thermodynamic properties relative to infinitely separated nuclei and; electrons, not “formation” values relative to elements in their standard; states. If you are computing thermodynamic differences, like a reaction; enthalpy computed as the enthalpy of the products minus the enthalpy; of the reactants, then these “absolute” enthalpies are perfectly valid; and usable. However, they cannot be mixed and matched with enthalpies of; formation from reference books, since the zero of energy is not the same.; Additionally, the “thermal energies” reported in kcal/mol are the; finite-temperature corrections to the electronic total energy, and; not the overall thermal energies themselves. If in doubt, use the; reported Total Energies in Hartree/particle. Keywords¶. T¶. Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. P¶. Pressure in Pascal for thermodynamic analysis. Note that 100000. is the value for IUPAC STP. Type: double; Default: 101325. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this option is the sole way to influence the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/thermo-1.html:936,usab,usable,936,psi4manual/1.2.1/thermo-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/thermo-1.html,2,['usab'],['usable']
Usability,"﻿. Vibrational and Thermochemical Analysis. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Theoretical Methods: SCF to FCI. Vibrational and Thermochemical Analysis¶; Code author: Rollin A. King and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, THERMO. Caution; It is important to know that PSI4, like any other; quantum chemistry program, does not compute the usual enthalpies,; entropies, or Gibbs free energies of formation provided by most; reference books. Instead, quantum chemistry programs compute “absolute”; thermodynamic properties relative to infinitely separated nuclei and; electrons, not “formation” values relative to elements in their standard; states. If you are computing thermodynamic differences, like a reaction; enthalpy computed as the enthalpy of the products minus the enthalpy; of the reactants, then these “absolute” enthalpies are perfectly valid; and usable. However, they cannot be mixed and matched with enthalpies of; formation from reference books, since the zero of energy is not the same.; Additionally, the “thermal energies” reported in kcal/mol are the; finite-temperature corrections to the electronic total energy, and; not the overall thermal energies themselves. If in doubt, use the; reported Total Energies in Hartree/particle. Keywords¶. T¶. Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. P¶. Pressure in Pascal for thermodynamic analysis. Note that 100000. is the value for IUPAC STP. Type: double; Default: 101325. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this option is the sole way to influence the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/thermo-1.html:936,usab,usable,936,psi4manual/1.3.2/thermo-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/thermo-1.html,2,['usab'],['usable']
Usability,"﻿. Vibrational and Thermochemical Analysis. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Theoretical Methods: SCF to FCI; Vibrational and Thermochemical Analysis. Vibrational and Thermochemical Analysis¶; Code author: Rollin A. King and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, THERMO. Caution; It is important to know that PSI4, like any other; quantum chemistry program, does not compute the usual enthalpies,; entropies, or Gibbs free energies of formation provided by most; reference books. Instead, quantum chemistry programs compute “absolute”; thermodynamic properties relative to infinitely separated nuclei and; electrons, not “formation” values relative to elements in their standard; states. If you are computing thermodynamic differences, like a reaction; enthalpy computed as the enthalpy of the products minus the enthalpy; of the reactants, then these “absolute” enthalpies are perfectly valid; and usable. However, they cannot be mixed and matched with enthalpies of; formation from reference books, since the zero of energy is not the same.; Additionally, the “thermal energies” reported in kcal/mol are the; finite-temperature corrections to the electronic total energy, and; not the overall thermal energies themselves. If in doubt, use the; reported Total Energies in Hartree/particle. Keywords¶. T¶. Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. P¶. Pressure in Pascal for thermodynamic analysis. Note that 100000. is the value for IUPAC STP. Type: double; Default: 101325. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/thermo-1.html:975,usab,usable,975,psi4manual/1.4.0/thermo-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/thermo-1.html,2,['usab'],['usable']
Usability,"﻿. Vibrational and Thermochemical Analysis. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Theoretical Methods: SCF to FCI; Vibrational and Thermochemical Analysis. Vibrational and Thermochemical Analysis¶; Code author: Rollin A. King and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, THERMO. Caution; It is important to know that PSI4, like any other; quantum chemistry program, does not compute the usual enthalpies,; entropies, or Gibbs free energies of formation provided by most; reference books. Instead, quantum chemistry programs compute “absolute”; thermodynamic properties relative to infinitely separated nuclei and; electrons, not “formation” values relative to elements in their standard; states. If you are computing thermodynamic differences, like a reaction; enthalpy computed as the enthalpy of the products minus the enthalpy; of the reactants, then these “absolute” enthalpies are perfectly valid; and usable. However, they cannot be mixed and matched with enthalpies of; formation from reference books, since the zero of energy is not the same.; Additionally, the “thermal energies” reported in kcal/mol are the; finite-temperature corrections to the electronic total energy, and; not the overall thermal energies themselves. If in doubt, use the; reported Total Energies in Hartree/particle. Keywords¶. T¶. Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. P¶. Pressure in Pascal for thermodynamic analysis. Note that 100000. is the value for IUPAC STP. Type: double; Default: 101325. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/thermo-1.html:975,usab,usable,975,psi4manual/1.5.0/thermo-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/thermo-1.html,2,['usab'],['usable']
Usability,"﻿. Vibrational and Thermochemical Analysis. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Vibrational and Thermochemical Analysis. Vibrational and Thermochemical Analysis¶; Code author: Rollin A. King and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, THERMO. Caution; It is important to know that PSI4, like any other; quantum chemistry program, does not compute the usual enthalpies,; entropies, or Gibbs free energies of formation provided by most; reference books. Instead, quantum chemistry programs compute “absolute”; thermodynamic properties relative to infinitely separated nuclei and; electrons, not “formation” values relative to elements in their standard; states. If you are computing thermodynamic differences, like a reaction; enthalpy computed as the enthalpy of the products minus the enthalpy; of the reactants, then these “absolute” enthalpies are perfectly valid; and usable. However, they cannot be mixed and matched with enthalpies of; formation from reference books, since the zero of energy is not the same.; Additionally, the “thermal energies” reported in kcal/mol are the; finite-temperature corrections to the electronic total energy, and; not the overall thermal energies themselves. If in doubt, use the; reported Total Energies in Hartree/particle. Keywords¶. T¶. Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. P¶. Pressure in Pascal for thermodynamic analysis. Note that 100000. is the value for IUPAC STP. Type: double; Default: 101325. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/thermo.html:975,usab,usable,975,psi4manual/1.6.x/thermo.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/thermo.html,1,['usab'],['usable']
Usability,"﻿. Vibrational and Thermochemical Analysis. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Theoretical Methods: SCF to FCI; Vibrational and Thermochemical Analysis. Vibrational and Thermochemical Analysis¶; Code author: Rollin A. King and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, THERMO. Caution; It is important to know that PSI4, like any other; quantum chemistry program, does not compute the usual enthalpies,; entropies, or Gibbs free energies of formation provided by most; reference books. Instead, quantum chemistry programs compute “absolute”; thermodynamic properties relative to infinitely separated nuclei and; electrons, not “formation” values relative to elements in their standard; states. If you are computing thermodynamic differences, like a reaction; enthalpy computed as the enthalpy of the products minus the enthalpy; of the reactants, then these “absolute” enthalpies are perfectly valid; and usable. However, they cannot be mixed and matched with enthalpies of; formation from reference books, since the zero of energy is not the same.; Additionally, the “thermal energies” reported in kcal/mol are the; finite-temperature corrections to the electronic total energy, and; not the overall thermal energies themselves. If in doubt, use the; reported Total Energies in Hartree/particle. Keywords¶. T¶. Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. P¶. Pressure in Pascal for thermodynamic analysis. Note that 100000. is the value for IUPAC STP. Type: double; Default: 101325. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/thermo.html:975,usab,usable,975,psi4manual/1.7.x/thermo.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/thermo.html,1,['usab'],['usable']
Usability,"﻿. Vibrational and Thermochemical Analysis. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Theoretical Methods: SCF to FCI; Vibrational and Thermochemical Analysis. Vibrational and Thermochemical Analysis¶; Code author: Rollin A. King and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, THERMO. Caution; It is important to know that PSI4, like any other; quantum chemistry program, does not compute the usual enthalpies,; entropies, or Gibbs free energies of formation provided by most; reference books. Instead, quantum chemistry programs compute “absolute”; thermodynamic properties relative to infinitely separated nuclei and; electrons, not “formation” values relative to elements in their standard; states. If you are computing thermodynamic differences, like a reaction; enthalpy computed as the enthalpy of the products minus the enthalpy; of the reactants, then these “absolute” enthalpies are perfectly valid; and usable. However, they cannot be mixed and matched with enthalpies of; formation from reference books, since the zero of energy is not the same.; Additionally, the “thermal energies” reported in kcal/mol are the; finite-temperature corrections to the electronic total energy, and; not the overall thermal energies themselves. If in doubt, use the; reported Total Energies in Hartree/particle. Keywords¶. T¶. Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. P¶. Pressure in Pascal for thermodynamic analysis. Note that 100000. is the value for IUPAC STP. Type: double; Default: 101325. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/thermo.html:977,usab,usable,977,psi4manual/1.8.x/thermo.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/thermo.html,1,['usab'],['usable']
Usability,"﻿. Vibrational and Thermochemical Analysis. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Theoretical Methods: SCF to FCI; Vibrational and Thermochemical Analysis. Vibrational and Thermochemical Analysis¶; Code author: Rollin A. King and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, THERMO. Caution; It is important to know that PSI4, like any other; quantum chemistry program, does not compute the usual enthalpies,; entropies, or Gibbs free energies of formation provided by most; reference books. Instead, quantum chemistry programs compute “absolute”; thermodynamic properties relative to infinitely separated nuclei and; electrons, not “formation” values relative to elements in their standard; states. If you are computing thermodynamic differences, like a reaction; enthalpy computed as the enthalpy of the products minus the enthalpy; of the reactants, then these “absolute” enthalpies are perfectly valid; and usable. However, they cannot be mixed and matched with enthalpies of; formation from reference books, since the zero of energy is not the same.; Additionally, the “thermal energies” reported in kcal/mol are the; finite-temperature corrections to the electronic total energy, and; not the overall thermal energies themselves. If in doubt, use the; reported Total Energies in Hartree/particle. Keywords¶. T¶. Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. P¶. Pressure in Pascal for thermodynamic analysis. Note that 100000. is the value for IUPAC STP. Type: double; Default: 101325. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/thermo.html:977,usab,usable,977,psi4manual/1.9.x/thermo.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/thermo.html,1,['usab'],['usable']
Usability,"﻿. Welcome to New Programmers. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Introduction to Programming in PSI4; Welcome to New Programmers. Welcome to New Programmers¶. The PSI4 community¶; PSI4 is an open-source project and welcomes contributions from; developers around the world. etc. We have annual meetings, we welcome; feedback, slack channel, etc. table of contents. Welcome to New Programmers; The PSI4 community. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Introduction to Programming in PSI4; Welcome to New Programmers. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_welcome.html:358,feedback,feedback,358,psi4manual/master/prog_welcome.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_welcome.html,1,['feedback'],['feedback']
Usability,"﻿. Welcome to New Programmers. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Introduction to Programming in PSI4. Welcome to New Programmers¶. The PSI4 community¶; PSI4 is an open-source project and welcomes contributions from; developers around the world. etc. We have annual meetings, we welcome; feedback, slack channel, etc. table of contents. Welcome to New Programmers; The PSI4 community. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Introduction to Programming in PSI4. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/prog_welcome-1.html:323,feedback,feedback,323,psi4manual/1.3.2/prog_welcome-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/prog_welcome-1.html,2,['feedback'],['feedback']
Usability,"﻿. Welcome to New Programmers. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Introduction to Programming in PSI4; Welcome to New Programmers. Welcome to New Programmers¶. The PSI4 community¶; PSI4 is an open-source project and welcomes contributions from; developers around the world. etc. We have annual meetings, we welcome; feedback, slack channel, etc. table of contents. Welcome to New Programmers; The PSI4 community. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Introduction to Programming in PSI4; Welcome to New Programmers. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_welcome-1.html:349,feedback,feedback,349,psi4manual/1.4.0/prog_welcome-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_welcome-1.html,2,['feedback'],['feedback']
Usability,"﻿. Welcome to New Programmers. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Introduction to Programming in PSI4; Welcome to New Programmers. Welcome to New Programmers¶. The PSI4 community¶; PSI4 is an open-source project and welcomes contributions from; developers around the world. etc. We have annual meetings, we welcome; feedback, slack channel, etc. table of contents. Welcome to New Programmers; The PSI4 community. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Introduction to Programming in PSI4; Welcome to New Programmers. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/prog_welcome-1.html:349,feedback,feedback,349,psi4manual/1.5.0/prog_welcome-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/prog_welcome-1.html,2,['feedback'],['feedback']
Usability,"﻿. Welcome to New Programmers. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; Welcome to New Programmers. Welcome to New Programmers¶. The PSI4 community¶; PSI4 is an open-source project and welcomes contributions from; developers around the world. etc. We have annual meetings, we welcome; feedback, slack channel, etc. table of contents. Welcome to New Programmers; The PSI4 community. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; Welcome to New Programmers. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/prog_welcome.html:349,feedback,feedback,349,psi4manual/1.6.x/prog_welcome.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_welcome.html,1,['feedback'],['feedback']
Usability,"﻿. Welcome to New Programmers. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Introduction to Programming in PSI4; Welcome to New Programmers. Welcome to New Programmers¶. The PSI4 community¶; PSI4 is an open-source project and welcomes contributions from; developers around the world. etc. We have annual meetings, we welcome; feedback, slack channel, etc. table of contents. Welcome to New Programmers; The PSI4 community. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Introduction to Programming in PSI4; Welcome to New Programmers. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/prog_welcome.html:349,feedback,feedback,349,psi4manual/1.7.x/prog_welcome.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/prog_welcome.html,1,['feedback'],['feedback']
Usability,"﻿. Welcome to New Programmers. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Introduction to Programming in PSI4; Welcome to New Programmers. Welcome to New Programmers¶. The PSI4 community¶; PSI4 is an open-source project and welcomes contributions from; developers around the world. etc. We have annual meetings, we welcome; feedback, slack channel, etc. table of contents. Welcome to New Programmers; The PSI4 community. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Introduction to Programming in PSI4; Welcome to New Programmers. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/prog_welcome.html:351,feedback,feedback,351,psi4manual/1.8.x/prog_welcome.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/prog_welcome.html,1,['feedback'],['feedback']
Usability,"﻿. Welcome to New Programmers. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Introduction to Programming in PSI4; Welcome to New Programmers. Welcome to New Programmers¶. The PSI4 community¶; PSI4 is an open-source project and welcomes contributions from; developers around the world. etc. We have annual meetings, we welcome; feedback, slack channel, etc. table of contents. Welcome to New Programmers; The PSI4 community. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Introduction to Programming in PSI4; Welcome to New Programmers. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/prog_welcome.html:351,feedback,feedback,351,psi4manual/1.9.x/prog_welcome.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/prog_welcome.html,1,['feedback'],['feedback']
Usability,"﻿. aliases — PSI4 [beta2] documentation. Navigation. index. modules |; PSI4 [beta2] » ; Module code ». Source code for aliases; """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; import PsiMod; import re; import os; import input; import math; import warnings; from driver import *; from wrappers import *; from molutil import *; from text import *; from procutil import *. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end of this file. [docs]def sherrillgroup_gold_standard(name='mp2', **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~wrappers.complete_basis_set` to evaluateo; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~wrappers.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> energy('sherrillgroup_gold_standard'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). if not ('func_cbs' in kwargs):; kwargs['func_cbs'] = energy. if not ('scf_basis' in kwargs):; kwargs['scf_basis'] = 'aug-cc-pVQZ'; if not ('scf_scheme' in kwargs):; kwargs['scf_scheme'] = highest_1. if not ('corl_wfn' in kwargs):; kwargs['corl_wfn'] = 'mp2'; if not ('corl_basis' in kwargs):; kwargs['corl_basis'] = 'aug-cc-pV[TQ]Z'; if not ('corl_scheme' in kwargs):; kwargs['corl_scheme'] = corl_xtpl_helgaker_2. if not ('delta_wfn' in kwargs):; kwargs['delta_wfn'] = 'ccsd(t)'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html:332,simpl,simple,332,psi4manual/4.0b2/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html,1,['simpl'],['simple']
Usability,"﻿. aliases — PSI4 [beta3] documentation. Navigation. index. modules    . toc    ; PSI4 [beta3] » ; Module code ». Source code for aliases; """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; import PsiMod; import re; import os; import math; import warnings; from driver import *; from wrappers import *; from molutil import *; from text import *; from procutil import *. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end of this file. [docs]def sherrillgroup_gold_standard(name='mp2', **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~wrappers.complete_basis_set` to evaluateo; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~wrappers.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> energy('sherrillgroup_gold_standard'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). if not ('func_cbs' in kwargs):; kwargs['func_cbs'] = energy. if not ('scf_basis' in kwargs):; kwargs['scf_basis'] = 'aug-cc-pVQZ'; if not ('scf_scheme' in kwargs):; kwargs['scf_scheme'] = highest_1. if not ('corl_wfn' in kwargs):; kwargs['corl_wfn'] = 'mp2'; if not ('corl_basis' in kwargs):; kwargs['corl_basis'] = 'aug-cc-pV[TQ]Z'; if not ('corl_scheme' in kwargs):; kwargs['corl_scheme'] = corl_xtpl_helgaker_2. if not ('delta_wfn' in kwargs):; kwargs['delta_wfn'] = 'ccsd(t)'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis' i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html:343,simpl,simple,343,psi4manual/4.0b3/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html,1,['simpl'],['simple']
Usability,"﻿. aliases — PSI4 [beta4] documentation. Navigation. index. modules    . toc    ; PSI4 [beta4] » ; Module code ». Source code for aliases; """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; import PsiMod; import re; import os; import math; import warnings; from driver import *; from wrappers import *; from molutil import *; from text import *; from procutil import *. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end of this file. [docs]def sherrillgroup_gold_standard(name='mp2', **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~wrappers.complete_basis_set` to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~wrappers.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> energy('sherrillgroup_gold_standard'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). if not ('func_cbs' in kwargs):; kwargs['func_cbs'] = energy. if not ('scf_basis' in kwargs):; kwargs['scf_basis'] = 'aug-cc-pVQZ'; if not ('scf_scheme' in kwargs):; kwargs['scf_scheme'] = highest_1. if not ('corl_wfn' in kwargs):; kwargs['corl_wfn'] = 'mp2'; if not ('corl_basis' in kwargs):; kwargs['corl_basis'] = 'aug-cc-pV[TQ]Z'; if not ('corl_scheme' in kwargs):; kwargs['corl_scheme'] = corl_xtpl_helgaker_2. if not ('delta_wfn' in kwargs):; kwargs['delta_wfn'] = 'ccsd(t)'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis' in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html:343,simpl,simple,343,psi4manual/4.0b4/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html,1,['simpl'],['simple']
Usability,"﻿. hold_options_state. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; hold_options_state. hold_options_state¶. psi4.driver.p4util.hold_options_state()[source]¶; Return a context manager that will collect the current state of; Process:environment.options on entry to the with-statement and clear; and restore the collected keywords state when exiting the with-statement. Return type:; Iterator[None]. table of contents. hold_options_state; hold_options_state(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; hold_options_state. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.p4util.hold_options_state.html:353,clear,clear,353,psi4manual/master/api/psi4.driver.p4util.hold_options_state.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.p4util.hold_options_state.html,1,['clear'],['clear']
Usability,"﻿. hold_options_state. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; hold_options_state. hold_options_state¶. psi4.driver.p4util.hold_options_state()[source]¶; Return a context manager that will collect the current state of; Process:environment.options on entry to the with-statement and clear; and restore the collected keywords state when exiting the with-statement. Return type:; Iterator[None]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; hold_options_state. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.p4util.hold_options_state.html:344,clear,clear,344,psi4manual/1.7.x/api/psi4.driver.p4util.hold_options_state.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.p4util.hold_options_state.html,1,['clear'],['clear']
Usability,"﻿. hold_options_state. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; hold_options_state. hold_options_state¶. psi4.driver.p4util.hold_options_state()[source]¶; Return a context manager that will collect the current state of; Process:environment.options on entry to the with-statement and clear; and restore the collected keywords state when exiting the with-statement. Return type:; Iterator[None]. table of contents. hold_options_state; hold_options_state(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; hold_options_state. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.hold_options_state.html:346,clear,clear,346,psi4manual/1.8.x/api/psi4.driver.p4util.hold_options_state.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.hold_options_state.html,1,['clear'],['clear']
Usability,"﻿. hold_options_state. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; hold_options_state. hold_options_state¶. psi4.driver.p4util.hold_options_state()[source]¶; Return a context manager that will collect the current state of; :rtype: Iterator[None]; Process:environment.options on entry to the with-statement and clear; and restore the collected keywords state when exiting the with-statement. Return type:; Iterator[None]. table of contents. hold_options_state; hold_options_state(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; hold_options_state. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.p4util.hold_options_state.html:370,clear,clear,370,psi4manual/1.9.x/api/psi4.driver.p4util.hold_options_state.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.p4util.hold_options_state.html,1,['clear'],['clear']
Usability,"﻿. pcmgetkw — PSI4 [beta5] documentation. Navigation. index. modules    . toc    ; PSI4 [beta5] » ; Module code ». Source code for pcmgetkw; #!/usr/bin/env python; # -*- coding: utf-8 -*-; # vim:syntax=python; #; ## @package getkw.py; ## @brief getkw -- a simple input parser for Fortran 95; #; # Written by Jonas Juselius <jonas.juselius@chem.uit.no> ; # University of Tromsø, 2006; #; # TODO: ; # o general cleanup; # o better python interface; # o Pretty print inputs back to human readable form; #; # Known bugs: names with '-' mess things up...; #. import sys,os,inspect; import re, string; from copy import deepcopy; from types import *; from pyparsing import \; 	Literal, Word, ZeroOrMore, Group, Dict, Optional, removeQuotes, \; 	printables, ParseException, restOfLine, alphas, alphanums, nums, \; 	pythonStyleComment, oneOf, quotedString, SkipTo, Forward, \; 	commaSeparatedList, OneOrMore, Combine, srange, delimitedList, \; 	downcaseTokens, line, lineno, StringEnd, Regex. verbose=True; strict=True. [docs]class Section:; 	""""""Section class. 	Placehoder for section objects; 	""""""; 	def __init__(self,name,tag=None,req=False, callback=None):; 		self.name=name; 		self.sect={}; 		self.kw={}; 		self.tag=tag; 		self.req=req; 		self.isset=False; 		self.callback=callback; 		self.fullname=self.name; 		if tag != None:; 			self.fullname=self.fullname+'<'+self.tag+'>'. 	def __cmp__(self, other):; 		return cmp(self.name,other.name). 	def __getitem__(self, key):; 		if self.sect.has_key(key):; 			foo=self.sect; 		elif self.kw.has_key(key):; 			foo=self.kw; 		else:; 			return None; 		return foo[key]. 	def __setitem__(self, k, val):; 		if isinstance(val, Section):; 			self.sect[k]=val; 		elif isinstance(val, Keyword):; 			self.kw[k]=val; 		else:; 			raise TypeError, 'Not a Section or Keyword'; 	; [docs]	def get(self, k):; 		return self.__getitem__(k). [docs]	def set(self, k, val):; 		self.__setitem__(k,val). 	def _split_tag(self, key):; 		i=string.find(key, '<'); 		if i == -1:; 			return (k",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/pcmgetkw.html:256,simpl,simple,256,psi4manual/4.0b5/_modules/pcmgetkw.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/pcmgetkw.html,1,['simpl'],['simple']
Usability,"﻿. psi4.core.ExternalPotential. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. psi4.core.ExternalPotential¶. class psi4.core.ExternalPotential¶; Bases: object; docstring; Methods Summary. addBasis((self: psi4.core.ExternalPotential, ...); docstring. addCharge(...); docstring. clear(...); docstring. computePotentialMatrix(...); docstring. print_out(...); docstring. setName((self: psi4.core.ExternalPotential, ...); docstring. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet, arg1: psi4.core.Vector) → None¶; docstring. addCharge(self: psi4.core.ExternalPotential, arg0: float, arg1: float, arg2: float, arg3: float) → None¶; docstring. clear(self: psi4.core.ExternalPotential) → None¶; docstring. computePotentialMatrix(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet) → psi4.core.Matrix¶; docstring. print_out(self: psi4.core.ExternalPotential) → None¶; docstring. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; docstring. addBasis(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet, arg1: psi4.core.Vector) → None; docstring. addCharge(self: psi4.core.ExternalPotential, arg0: float, arg1: float, arg2: float, arg3: float) → None; docstring. clear(self: psi4.core.ExternalPotential) → None; docstring. computePotentialMatrix(self: psi4.core.ExternalPotential, arg0: psi4.core.BasisSet) → psi4.core.Matrix; docstring. print_out(self: psi4.core.ExternalPotential) → None; docstring. setName(self: psi4.core.ExternalPotential, arg0: str) → None; docstring. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.externalpotential.html:288,clear,clear,288,psi4manual/1.1.0/api/psi4.core.externalpotential.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.externalpotential.html,3,['clear'],['clear']
Usability,"﻿. psi4.core.OEProp. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. psi4.core.OEProp¶. class psi4.core.OEProp¶; Bases: psi4.core.Prop; docstring; Methods Summary. Exvals((self: psi4.core.OEProp) -> List[float]); The x component of the field (in a.u.) at each grid point. Eyvals((self: psi4.core.OEProp) -> List[float]); The y component of the field (in a.u.) at each grid point. Ezvals((self: psi4.core.OEProp) -> List[float]); The z component of the field (in a.u.) at each grid point. Vvals((self: psi4.core.OEProp) -> List[float]); The electrostatic potential (in a.u.) at each grid point. add((self: psi4.core.OEProp, arg0: str) -> None); docstring. clear((self: psi4.core.Prop) -> None); docstring. compute((self: psi4.core.OEProp) -> None); docstring. set_Da_ao((self: psi4.core.Prop, ...); docstring. set_Da_mo((self: psi4.core.Prop, ...); docstring. set_Da_so((self: psi4.core.Prop, ...); docstring. set_Db_ao((self: psi4.core.Prop, ...); docstring. set_Db_mo((self: psi4.core.Prop, ...); docstring. set_Db_so((self: psi4.core.Prop, ...); docstring. Methods Documentation. Exvals(self: psi4.core.OEProp) → List[float]¶; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp) → List[float]¶; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp) → List[float]¶; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp) → List[float]¶; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str) → None¶; docstring. clear(self: psi4.core.Prop) → None¶; docstring. compute(self: psi4.core.OEProp) → None¶; docstring. set_Da_ao(self: psi4.core.Prop, Da: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Da_mo(self: psi4.core.Prop, arg0: psi::Matrix) → None¶; docstring. set_Da_so(self: psi4.core.Prop, arg0: psi::Matrix) → None¶; docstring. set_Db_ao(self: psi4.core.Prop, Db: psi::Matrix, symmetry: int=0) → None¶; docstring. set_Db_mo(self",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.oeprop.html:665,clear,clear,665,psi4manual/1.1.0/api/psi4.core.oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.oeprop.html,1,['clear'],['clear']
Usability,"﻿. qcdb.libmintscoordentry — PSI4 [beta3] documentation. Navigation. index. modules    . toc    ; PSI4 [beta3] » ; Module code ». Source code for qcdb.libmintscoordentry; r""""""Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. """"""; import math; import copy; from vecutil import *; from exceptions import *. [docs]class CoordValue(object):; """"""An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. """""". def __init__(self, fixed=False, computed=False):; # Fixed coordinate?; self.PYfixed = fixed; # Whether the current value is up to date or not; self.computed = computed. [docs] def set_fixed(self, fixed):; """"""Set whether the coordinate value is fixed or not""""""; self.PYfixed = fixed. [docs] def fixed(self):; """"""Get whether the coordinate value is fixed or not""""""; return self.PYfixed. [docs] def invalidate(self):; """"""Flag the current value as outdated""""""; self.computed = False. [docs] def everything(self):; print '\nCoordValue\n Fixed = %s\n Computed = %s\n\n' % (self.PYfixed, self.computed). [docs]class NumberValue(CoordValue):; """"""Specialization of CoordValue that is simply a number to be stored."""""". def __init__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; return self.value. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordV",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html:634,simpl,simplifying,634,psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,1,['simpl'],['simplifying']
Usability,"﻿. qcdb.libmintscoordentry — PSI4 [beta4] documentation. Navigation. index. modules    . toc    ; PSI4 [beta4] » ; Module code ». Source code for qcdb.libmintscoordentry; r""""""Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. """"""; import math; import copy; from vecutil import *; from exceptions import *. [docs]class CoordValue(object):; """"""An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. """""". def __init__(self, fixed=False, computed=False):; # Fixed coordinate?; self.PYfixed = fixed; # Whether the current value is up to date or not; self.computed = computed. [docs] def set_fixed(self, fixed):; """"""Set whether the coordinate value is fixed or not""""""; self.PYfixed = fixed. [docs] def fixed(self):; """"""Get whether the coordinate value is fixed or not""""""; return self.PYfixed. [docs] def invalidate(self):; """"""Flag the current value as outdated""""""; self.computed = False. [docs] def everything(self):; print '\nCoordValue\n Fixed = %s\n Computed = %s\n\n' % (self.PYfixed, self.computed). [docs]class NumberValue(CoordValue):; """"""Specialization of CoordValue that is simply a number to be stored."""""". def __init__(self, value, fixed=False):; CoordValue.__init__(self, fixed, True); # coordinate number value; self.value = value. [docs] def compute(self):; """"""Computes value of coordinate from member data""""""; return self.value. [docs] def rset(self, val):; """"""Resets value of coordinate if not fixed""""""; if not self.PYfixed:; self.value = val. [docs] def type(self):; """"""Gets specialization type of CoordValue""""""; return 'NumberType'. [docs] def clone(self):; """"""Returns new, independent NumberValue object""""""; return copy.deepcopy(self). [docs] def variable_to_string(self, precision):; """"""Takes a CoordV",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html:634,simpl,simplifying,634,psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/libmintscoordentry.html,1,['simpl'],['simplifying']
